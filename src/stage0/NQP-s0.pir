
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.loadlib "trans_ops"

.loadlib "io_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1306916577.75068")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7325 = "624_1306916577.75068" 
    capture_lex $P7325
    .const 'Sub' $P7192 = "616_1306916577.75068" 
    capture_lex $P7192
    .const 'Sub' $P2935 = "436_1306916577.75068" 
    capture_lex $P2935
    .const 'Sub' $P2870 = "415_1306916577.75068" 
    capture_lex $P2870
    .const 'Sub' $P986 = "40_1306916577.75068" 
    capture_lex $P986
    .const 'Sub' $P57 = "13_1306916577.75068" 
    capture_lex $P57
    .const 'Sub' $P49 = "12_1306916577.75068" 
    capture_lex $P49
    .const 'Sub' $P16 = "11_1306916577.75068" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2758
    .const 'Sub' $P16 = "11_1306916577.75068" 
    newclosure $P48, $P16
    .lex "MAIN", $P48
.annotate 'line', 2779
    .const 'Sub' $P49 = "12_1306916577.75068" 
    newclosure $P55, $P49
    .lex "hll-config", $P55
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P57 = "13_1306916577.75068" 
    capture_lex $P57
    $P57()
.annotate 'line', 435
    .const 'Sub' $P986 = "40_1306916577.75068" 
    capture_lex $P986
    $P986()
.annotate 'line', 1158
    .const 'Sub' $P2870 = "415_1306916577.75068" 
    capture_lex $P2870
    $P2870()
.annotate 'line', 1201
    .const 'Sub' $P2935 = "436_1306916577.75068" 
    capture_lex $P2935
    $P2935()
.annotate 'line', 2700
    .const 'Sub' $P7192 = "616_1306916577.75068" 
    capture_lex $P7192
    $P7192()
.annotate 'line', 2755
    .const 'Sub' $P7325 = "624_1306916577.75068" 
    capture_lex $P7325
    $P7325()
    find_lex $P7328, "MAIN"
    find_lex $P7329, "hll-config"
    find_lex $P7332, "@ARGS"
    if $P7332, if_7331
    set $P7330, $P7332
    goto if_7331_end
  if_7331:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7333, "ModuleLoader"
    getinterp $P7334
    set $P7335, $P7334["context"]
    $P7333."set_mainline_module"($P7335)
    .const 'Sub' $P7336 = "11_1306916577.75068" 
    find_lex $P7337, "@ARGS"
    $P7338 = $P7336($P7337 :flat)
    set $P7330, $P7338
  if_7331_end:
.annotate 'line', 1
    .return ($P7330)
    .const 'Sub' $P7340 = "625_1306916577.75068" 
    .return ($P7340)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post626") :outer("10_1306916577.75068")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1306916577.75068" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7344, "1306916558.44963"
    isnull $I7345, $P7344
    if $I7345, if_7343
    .const 'Sub' $P9538 = "10_1306916577.75068" 
    $P9539 = $P9538."get_lexinfo"()
    nqp_get_sc_object $P9540, "1306916558.44963", 0
    $P9539."set_static_lexpad_value"("GLOBALish", $P9540)
    .const 'Sub' $P9541 = "10_1306916577.75068" 
    $P9542 = $P9541."get_lexinfo"()
    $P9542."finish_static_lexpad"()
    .const 'Sub' $P9543 = "10_1306916577.75068" 
    $P9544 = $P9543."get_lexinfo"()
    nqp_get_sc_object $P9545, "1306916558.44963", 0
    $P9544."set_static_lexpad_value"("$?PACKAGE", $P9545)
    .const 'Sub' $P9546 = "10_1306916577.75068" 
    $P9547 = $P9546."get_lexinfo"()
    $P9547."finish_static_lexpad"()
    nqp_get_sc_object $P9548, "1306916558.44963", 2
    .const 'Sub' $P9549 = "14_1306916577.75068" 
    assign $P9548, $P9549
    nqp_get_sc_object $P9550, "1306916558.44963", 3
    .const 'Sub' $P9551 = "16_1306916577.75068" 
    assign $P9550, $P9551
    nqp_get_sc_object $P9552, "1306916558.44963", 4
    .const 'Sub' $P9553 = "17_1306916577.75068" 
    assign $P9552, $P9553
    nqp_get_sc_object $P9554, "1306916558.44963", 5
    .const 'Sub' $P9555 = "20_1306916577.75068" 
    assign $P9554, $P9555
    nqp_get_sc_object $P9556, "1306916558.44963", 6
    .const 'Sub' $P9557 = "21_1306916577.75068" 
    assign $P9556, $P9557
    nqp_get_sc_object $P9558, "1306916558.44963", 7
    .const 'Sub' $P9559 = "22_1306916577.75068" 
    assign $P9558, $P9559
    nqp_get_sc_object $P9560, "1306916558.44963", 8
    .const 'Sub' $P9561 = "23_1306916577.75068" 
    assign $P9560, $P9561
    nqp_get_sc_object $P9562, "1306916558.44963", 9
    .const 'Sub' $P9563 = "26_1306916577.75068" 
    assign $P9562, $P9563
    nqp_get_sc_object $P9564, "1306916558.44963", 10
    .const 'Sub' $P9565 = "29_1306916577.75068" 
    assign $P9564, $P9565
    nqp_get_sc_object $P9566, "1306916558.44963", 11
    .const 'Sub' $P9567 = "30_1306916577.75068" 
    assign $P9566, $P9567
    nqp_get_sc_object $P9568, "1306916558.44963", 12
    .const 'Sub' $P9569 = "35_1306916577.75068" 
    assign $P9568, $P9569
    nqp_get_sc_object $P9570, "1306916558.44963", 13
    .const 'Sub' $P9571 = "36_1306916577.75068" 
    assign $P9570, $P9571
    nqp_get_sc_object $P9572, "1306916558.44963", 14
    .const 'Sub' $P9573 = "37_1306916577.75068" 
    assign $P9572, $P9573
    nqp_get_sc_object $P9574, "1306916558.44963", 15
    .const 'Sub' $P9575 = "38_1306916577.75068" 
    assign $P9574, $P9575
    .const 'Sub' $P9576 = "13_1306916577.75068" 
    $P9577 = $P9576."get_lexinfo"()
    nqp_get_sc_object $P9578, "1306916558.44963", 1
    $P9577."set_static_lexpad_value"("$?PACKAGE", $P9578)
    .const 'Sub' $P9579 = "13_1306916577.75068" 
    $P9580 = $P9579."get_lexinfo"()
    $P9580."finish_static_lexpad"()
    .const 'Sub' $P9581 = "13_1306916577.75068" 
    $P9582 = $P9581."get_lexinfo"()
    nqp_get_sc_object $P9583, "1306916558.44963", 1
    $P9582."set_static_lexpad_value"("$?CLASS", $P9583)
    .const 'Sub' $P9584 = "13_1306916577.75068" 
    $P9585 = $P9584."get_lexinfo"()
    $P9585."finish_static_lexpad"()
    nqp_get_sc_object $P9586, "1306916558.44963", 17
    .const 'Sub' $P9587 = "41_1306916577.75068" 
    assign $P9586, $P9587
    nqp_get_sc_object $P9588, "1306916558.44963", 18
    .const 'Sub' $P9589 = "42_1306916577.75068" 
    assign $P9588, $P9589
    nqp_get_sc_object $P9590, "1306916558.44963", 19
    .const 'Sub' $P9591 = "43_1306916577.75068" 
    assign $P9590, $P9591
    nqp_get_sc_object $P9592, "1306916558.44963", 20
    .const 'Sub' $P9593 = "44_1306916577.75068" 
    assign $P9592, $P9593
    nqp_get_sc_object $P9594, "1306916558.44963", 21
    .const 'Sub' $P9595 = "45_1306916577.75068" 
    assign $P9594, $P9595
    nqp_get_sc_object $P9596, "1306916558.44963", 22
    .const 'Sub' $P9597 = "46_1306916577.75068" 
    assign $P9596, $P9597
    nqp_get_sc_object $P9598, "1306916558.44963", 23
    .const 'Sub' $P9599 = "47_1306916577.75068" 
    assign $P9598, $P9599
    nqp_get_sc_object $P9600, "1306916558.44963", 24
    .const 'Sub' $P9601 = "48_1306916577.75068" 
    assign $P9600, $P9601
    nqp_get_sc_object $P9602, "1306916558.44963", 25
    .const 'Sub' $P9603 = "49_1306916577.75068" 
    assign $P9602, $P9603
    nqp_get_sc_object $P9604, "1306916558.44963", 26
    .const 'Sub' $P9605 = "50_1306916577.75068" 
    assign $P9604, $P9605
    nqp_get_sc_object $P9606, "1306916558.44963", 27
    .const 'Sub' $P9607 = "51_1306916577.75068" 
    assign $P9606, $P9607
    nqp_get_sc_object $P9608, "1306916558.44963", 28
    .const 'Sub' $P9609 = "52_1306916577.75068" 
    assign $P9608, $P9609
    nqp_get_sc_object $P9610, "1306916558.44963", 29
    .const 'Sub' $P9611 = "54_1306916577.75068" 
    assign $P9610, $P9611
    nqp_get_sc_object $P9612, "1306916558.44963", 30
    .const 'Sub' $P9613 = "55_1306916577.75068" 
    assign $P9612, $P9613
    nqp_get_sc_object $P9614, "1306916558.44963", 31
    .const 'Sub' $P9615 = "57_1306916577.75068" 
    assign $P9614, $P9615
    nqp_get_sc_object $P9616, "1306916558.44963", 32
    .const 'Sub' $P9617 = "58_1306916577.75068" 
    assign $P9616, $P9617
    nqp_get_sc_object $P9618, "1306916558.44963", 33
    .const 'Sub' $P9619 = "59_1306916577.75068" 
    assign $P9618, $P9619
    nqp_get_sc_object $P9620, "1306916558.44963", 34
    .const 'Sub' $P9621 = "60_1306916577.75068" 
    assign $P9620, $P9621
    nqp_get_sc_object $P9622, "1306916558.44963", 35
    .const 'Sub' $P9623 = "61_1306916577.75068" 
    assign $P9622, $P9623
    nqp_get_sc_object $P9624, "1306916558.44963", 36
    .const 'Sub' $P9625 = "62_1306916577.75068" 
    assign $P9624, $P9625
    nqp_get_sc_object $P9626, "1306916558.44963", 37
    .const 'Sub' $P9627 = "64_1306916577.75068" 
    assign $P9626, $P9627
    nqp_get_sc_object $P9628, "1306916558.44963", 38
    .const 'Sub' $P9629 = "65_1306916577.75068" 
    assign $P9628, $P9629
    nqp_get_sc_object $P9630, "1306916558.44963", 39
    .const 'Sub' $P9631 = "66_1306916577.75068" 
    assign $P9630, $P9631
    nqp_get_sc_object $P9632, "1306916558.44963", 40
    .const 'Sub' $P9633 = "67_1306916577.75068" 
    assign $P9632, $P9633
    nqp_get_sc_object $P9634, "1306916558.44963", 41
    .const 'Sub' $P9635 = "68_1306916577.75068" 
    assign $P9634, $P9635
    nqp_get_sc_object $P9636, "1306916558.44963", 42
    .const 'Sub' $P9637 = "69_1306916577.75068" 
    assign $P9636, $P9637
    nqp_get_sc_object $P9638, "1306916558.44963", 43
    .const 'Sub' $P9639 = "70_1306916577.75068" 
    assign $P9638, $P9639
    nqp_get_sc_object $P9640, "1306916558.44963", 44
    .const 'Sub' $P9641 = "71_1306916577.75068" 
    assign $P9640, $P9641
    nqp_get_sc_object $P9642, "1306916558.44963", 45
    .const 'Sub' $P9643 = "72_1306916577.75068" 
    assign $P9642, $P9643
    nqp_get_sc_object $P9644, "1306916558.44963", 46
    .const 'Sub' $P9645 = "73_1306916577.75068" 
    assign $P9644, $P9645
    nqp_get_sc_object $P9646, "1306916558.44963", 47
    .const 'Sub' $P9647 = "74_1306916577.75068" 
    assign $P9646, $P9647
    nqp_get_sc_object $P9648, "1306916558.44963", 48
    .const 'Sub' $P9649 = "75_1306916577.75068" 
    assign $P9648, $P9649
    nqp_get_sc_object $P9650, "1306916558.44963", 49
    .const 'Sub' $P9651 = "76_1306916577.75068" 
    assign $P9650, $P9651
    nqp_get_sc_object $P9652, "1306916558.44963", 50
    .const 'Sub' $P9653 = "77_1306916577.75068" 
    assign $P9652, $P9653
    nqp_get_sc_object $P9654, "1306916558.44963", 51
    .const 'Sub' $P9655 = "78_1306916577.75068" 
    assign $P9654, $P9655
    nqp_get_sc_object $P9656, "1306916558.44963", 52
    .const 'Sub' $P9657 = "79_1306916577.75068" 
    assign $P9656, $P9657
    nqp_get_sc_object $P9658, "1306916558.44963", 53
    .const 'Sub' $P9659 = "80_1306916577.75068" 
    assign $P9658, $P9659
    nqp_get_sc_object $P9660, "1306916558.44963", 54
    .const 'Sub' $P9661 = "81_1306916577.75068" 
    assign $P9660, $P9661
    nqp_get_sc_object $P9662, "1306916558.44963", 55
    .const 'Sub' $P9663 = "82_1306916577.75068" 
    assign $P9662, $P9663
    nqp_get_sc_object $P9664, "1306916558.44963", 56
    .const 'Sub' $P9665 = "83_1306916577.75068" 
    assign $P9664, $P9665
    nqp_get_sc_object $P9666, "1306916558.44963", 57
    .const 'Sub' $P9667 = "84_1306916577.75068" 
    assign $P9666, $P9667
    nqp_get_sc_object $P9668, "1306916558.44963", 58
    .const 'Sub' $P9669 = "85_1306916577.75068" 
    assign $P9668, $P9669
    nqp_get_sc_object $P9670, "1306916558.44963", 59
    .const 'Sub' $P9671 = "86_1306916577.75068" 
    assign $P9670, $P9671
    nqp_get_sc_object $P9672, "1306916558.44963", 60
    .const 'Sub' $P9673 = "87_1306916577.75068" 
    assign $P9672, $P9673
    nqp_get_sc_object $P9674, "1306916558.44963", 61
    .const 'Sub' $P9675 = "88_1306916577.75068" 
    assign $P9674, $P9675
    nqp_get_sc_object $P9676, "1306916558.44963", 62
    .const 'Sub' $P9677 = "89_1306916577.75068" 
    assign $P9676, $P9677
    nqp_get_sc_object $P9678, "1306916558.44963", 63
    .const 'Sub' $P9679 = "90_1306916577.75068" 
    assign $P9678, $P9679
    nqp_get_sc_object $P9680, "1306916558.44963", 64
    .const 'Sub' $P9681 = "91_1306916577.75068" 
    assign $P9680, $P9681
    nqp_get_sc_object $P9682, "1306916558.44963", 65
    .const 'Sub' $P9683 = "92_1306916577.75068" 
    assign $P9682, $P9683
    nqp_get_sc_object $P9684, "1306916558.44963", 66
    .const 'Sub' $P9685 = "93_1306916577.75068" 
    assign $P9684, $P9685
    nqp_get_sc_object $P9686, "1306916558.44963", 67
    .const 'Sub' $P9687 = "94_1306916577.75068" 
    assign $P9686, $P9687
    nqp_get_sc_object $P9688, "1306916558.44963", 68
    .const 'Sub' $P9689 = "95_1306916577.75068" 
    assign $P9688, $P9689
    nqp_get_sc_object $P9690, "1306916558.44963", 69
    .const 'Sub' $P9691 = "96_1306916577.75068" 
    assign $P9690, $P9691
    nqp_get_sc_object $P9692, "1306916558.44963", 70
    .const 'Sub' $P9693 = "97_1306916577.75068" 
    assign $P9692, $P9693
    nqp_get_sc_object $P9694, "1306916558.44963", 71
    .const 'Sub' $P9695 = "98_1306916577.75068" 
    assign $P9694, $P9695
    nqp_get_sc_object $P9696, "1306916558.44963", 72
    .const 'Sub' $P9697 = "99_1306916577.75068" 
    assign $P9696, $P9697
    nqp_get_sc_object $P9698, "1306916558.44963", 73
    .const 'Sub' $P9699 = "101_1306916577.75068" 
    assign $P9698, $P9699
    nqp_get_sc_object $P9700, "1306916558.44963", 74
    .const 'Sub' $P9701 = "102_1306916577.75068" 
    assign $P9700, $P9701
    nqp_get_sc_object $P9702, "1306916558.44963", 75
    .const 'Sub' $P9703 = "103_1306916577.75068" 
    assign $P9702, $P9703
    nqp_get_sc_object $P9704, "1306916558.44963", 76
    .const 'Sub' $P9705 = "104_1306916577.75068" 
    assign $P9704, $P9705
    nqp_get_sc_object $P9706, "1306916558.44963", 77
    .const 'Sub' $P9707 = "105_1306916577.75068" 
    assign $P9706, $P9707
    nqp_get_sc_object $P9708, "1306916558.44963", 78
    .const 'Sub' $P9709 = "106_1306916577.75068" 
    assign $P9708, $P9709
    nqp_get_sc_object $P9710, "1306916558.44963", 79
    .const 'Sub' $P9711 = "107_1306916577.75068" 
    assign $P9710, $P9711
    nqp_get_sc_object $P9712, "1306916558.44963", 80
    .const 'Sub' $P9713 = "108_1306916577.75068" 
    assign $P9712, $P9713
    nqp_get_sc_object $P9714, "1306916558.44963", 81
    .const 'Sub' $P9715 = "109_1306916577.75068" 
    assign $P9714, $P9715
    nqp_get_sc_object $P9716, "1306916558.44963", 82
    .const 'Sub' $P9717 = "110_1306916577.75068" 
    assign $P9716, $P9717
    nqp_get_sc_object $P9718, "1306916558.44963", 83
    .const 'Sub' $P9719 = "111_1306916577.75068" 
    assign $P9718, $P9719
    nqp_get_sc_object $P9720, "1306916558.44963", 84
    .const 'Sub' $P9721 = "112_1306916577.75068" 
    assign $P9720, $P9721
    nqp_get_sc_object $P9722, "1306916558.44963", 85
    .const 'Sub' $P9723 = "113_1306916577.75068" 
    assign $P9722, $P9723
    nqp_get_sc_object $P9724, "1306916558.44963", 86
    .const 'Sub' $P9725 = "114_1306916577.75068" 
    assign $P9724, $P9725
    nqp_get_sc_object $P9726, "1306916558.44963", 87
    .const 'Sub' $P9727 = "115_1306916577.75068" 
    assign $P9726, $P9727
    nqp_get_sc_object $P9728, "1306916558.44963", 88
    .const 'Sub' $P9729 = "116_1306916577.75068" 
    assign $P9728, $P9729
    nqp_get_sc_object $P9730, "1306916558.44963", 89
    .const 'Sub' $P9731 = "117_1306916577.75068" 
    assign $P9730, $P9731
    nqp_get_sc_object $P9732, "1306916558.44963", 90
    .const 'Sub' $P9733 = "118_1306916577.75068" 
    assign $P9732, $P9733
    nqp_get_sc_object $P9734, "1306916558.44963", 91
    .const 'Sub' $P9735 = "119_1306916577.75068" 
    assign $P9734, $P9735
    nqp_get_sc_object $P9736, "1306916558.44963", 92
    .const 'Sub' $P9737 = "120_1306916577.75068" 
    assign $P9736, $P9737
    nqp_get_sc_object $P9738, "1306916558.44963", 93
    .const 'Sub' $P9739 = "121_1306916577.75068" 
    assign $P9738, $P9739
    nqp_get_sc_object $P9740, "1306916558.44963", 94
    .const 'Sub' $P9741 = "122_1306916577.75068" 
    assign $P9740, $P9741
    nqp_get_sc_object $P9742, "1306916558.44963", 95
    .const 'Sub' $P9743 = "123_1306916577.75068" 
    assign $P9742, $P9743
    nqp_get_sc_object $P9744, "1306916558.44963", 96
    .const 'Sub' $P9745 = "124_1306916577.75068" 
    assign $P9744, $P9745
    nqp_get_sc_object $P9746, "1306916558.44963", 97
    .const 'Sub' $P9747 = "125_1306916577.75068" 
    assign $P9746, $P9747
    nqp_get_sc_object $P9748, "1306916558.44963", 98
    .const 'Sub' $P9749 = "126_1306916577.75068" 
    assign $P9748, $P9749
    nqp_get_sc_object $P9750, "1306916558.44963", 99
    .const 'Sub' $P9751 = "127_1306916577.75068" 
    assign $P9750, $P9751
    nqp_get_sc_object $P9752, "1306916558.44963", 100
    .const 'Sub' $P9753 = "128_1306916577.75068" 
    assign $P9752, $P9753
    nqp_get_sc_object $P9754, "1306916558.44963", 101
    .const 'Sub' $P9755 = "129_1306916577.75068" 
    assign $P9754, $P9755
    nqp_get_sc_object $P9756, "1306916558.44963", 102
    .const 'Sub' $P9757 = "130_1306916577.75068" 
    assign $P9756, $P9757
    nqp_get_sc_object $P9758, "1306916558.44963", 103
    .const 'Sub' $P9759 = "131_1306916577.75068" 
    assign $P9758, $P9759
    nqp_get_sc_object $P9760, "1306916558.44963", 104
    .const 'Sub' $P9761 = "132_1306916577.75068" 
    assign $P9760, $P9761
    nqp_get_sc_object $P9762, "1306916558.44963", 105
    .const 'Sub' $P9763 = "133_1306916577.75068" 
    assign $P9762, $P9763
    nqp_get_sc_object $P9764, "1306916558.44963", 106
    .const 'Sub' $P9765 = "134_1306916577.75068" 
    assign $P9764, $P9765
    nqp_get_sc_object $P9766, "1306916558.44963", 107
    .const 'Sub' $P9767 = "135_1306916577.75068" 
    assign $P9766, $P9767
    nqp_get_sc_object $P9768, "1306916558.44963", 108
    .const 'Sub' $P9769 = "136_1306916577.75068" 
    assign $P9768, $P9769
    nqp_get_sc_object $P9770, "1306916558.44963", 109
    .const 'Sub' $P9771 = "137_1306916577.75068" 
    assign $P9770, $P9771
    nqp_get_sc_object $P9772, "1306916558.44963", 110
    .const 'Sub' $P9773 = "138_1306916577.75068" 
    assign $P9772, $P9773
    nqp_get_sc_object $P9774, "1306916558.44963", 111
    .const 'Sub' $P9775 = "139_1306916577.75068" 
    assign $P9774, $P9775
    nqp_get_sc_object $P9776, "1306916558.44963", 112
    .const 'Sub' $P9777 = "140_1306916577.75068" 
    assign $P9776, $P9777
    nqp_get_sc_object $P9778, "1306916558.44963", 113
    .const 'Sub' $P9779 = "141_1306916577.75068" 
    assign $P9778, $P9779
    nqp_get_sc_object $P9780, "1306916558.44963", 114
    .const 'Sub' $P9781 = "142_1306916577.75068" 
    assign $P9780, $P9781
    nqp_get_sc_object $P9782, "1306916558.44963", 115
    .const 'Sub' $P9783 = "143_1306916577.75068" 
    assign $P9782, $P9783
    nqp_get_sc_object $P9784, "1306916558.44963", 116
    .const 'Sub' $P9785 = "144_1306916577.75068" 
    assign $P9784, $P9785
    nqp_get_sc_object $P9786, "1306916558.44963", 117
    .const 'Sub' $P9787 = "145_1306916577.75068" 
    assign $P9786, $P9787
    nqp_get_sc_object $P9788, "1306916558.44963", 118
    .const 'Sub' $P9789 = "146_1306916577.75068" 
    assign $P9788, $P9789
    nqp_get_sc_object $P9790, "1306916558.44963", 119
    .const 'Sub' $P9791 = "149_1306916577.75068" 
    assign $P9790, $P9791
    nqp_get_sc_object $P9792, "1306916558.44963", 120
    .const 'Sub' $P9793 = "150_1306916577.75068" 
    assign $P9792, $P9793
    nqp_get_sc_object $P9794, "1306916558.44963", 121
    .const 'Sub' $P9795 = "151_1306916577.75068" 
    assign $P9794, $P9795
    nqp_get_sc_object $P9796, "1306916558.44963", 122
    .const 'Sub' $P9797 = "152_1306916577.75068" 
    assign $P9796, $P9797
    nqp_get_sc_object $P9798, "1306916558.44963", 123
    .const 'Sub' $P9799 = "153_1306916577.75068" 
    assign $P9798, $P9799
    nqp_get_sc_object $P9800, "1306916558.44963", 124
    .const 'Sub' $P9801 = "154_1306916577.75068" 
    assign $P9800, $P9801
    nqp_get_sc_object $P9802, "1306916558.44963", 125
    .const 'Sub' $P9803 = "155_1306916577.75068" 
    assign $P9802, $P9803
    nqp_get_sc_object $P9804, "1306916558.44963", 126
    .const 'Sub' $P9805 = "156_1306916577.75068" 
    assign $P9804, $P9805
    nqp_get_sc_object $P9806, "1306916558.44963", 127
    .const 'Sub' $P9807 = "157_1306916577.75068" 
    assign $P9806, $P9807
    nqp_get_sc_object $P9808, "1306916558.44963", 128
    .const 'Sub' $P9809 = "158_1306916577.75068" 
    assign $P9808, $P9809
    nqp_get_sc_object $P9810, "1306916558.44963", 129
    .const 'Sub' $P9811 = "159_1306916577.75068" 
    assign $P9810, $P9811
    nqp_get_sc_object $P9812, "1306916558.44963", 130
    .const 'Sub' $P9813 = "160_1306916577.75068" 
    assign $P9812, $P9813
    nqp_get_sc_object $P9814, "1306916558.44963", 131
    .const 'Sub' $P9815 = "161_1306916577.75068" 
    assign $P9814, $P9815
    nqp_get_sc_object $P9816, "1306916558.44963", 132
    .const 'Sub' $P9817 = "162_1306916577.75068" 
    assign $P9816, $P9817
    nqp_get_sc_object $P9818, "1306916558.44963", 133
    .const 'Sub' $P9819 = "163_1306916577.75068" 
    assign $P9818, $P9819
    nqp_get_sc_object $P9820, "1306916558.44963", 134
    .const 'Sub' $P9821 = "164_1306916577.75068" 
    assign $P9820, $P9821
    nqp_get_sc_object $P9822, "1306916558.44963", 135
    .const 'Sub' $P9823 = "165_1306916577.75068" 
    assign $P9822, $P9823
    nqp_get_sc_object $P9824, "1306916558.44963", 136
    .const 'Sub' $P9825 = "166_1306916577.75068" 
    assign $P9824, $P9825
    nqp_get_sc_object $P9826, "1306916558.44963", 137
    .const 'Sub' $P9827 = "167_1306916577.75068" 
    assign $P9826, $P9827
    nqp_get_sc_object $P9828, "1306916558.44963", 138
    .const 'Sub' $P9829 = "168_1306916577.75068" 
    assign $P9828, $P9829
    nqp_get_sc_object $P9830, "1306916558.44963", 139
    .const 'Sub' $P9831 = "169_1306916577.75068" 
    assign $P9830, $P9831
    nqp_get_sc_object $P9832, "1306916558.44963", 140
    .const 'Sub' $P9833 = "170_1306916577.75068" 
    assign $P9832, $P9833
    nqp_get_sc_object $P9834, "1306916558.44963", 141
    .const 'Sub' $P9835 = "171_1306916577.75068" 
    assign $P9834, $P9835
    nqp_get_sc_object $P9836, "1306916558.44963", 142
    .const 'Sub' $P9837 = "172_1306916577.75068" 
    assign $P9836, $P9837
    nqp_get_sc_object $P9838, "1306916558.44963", 143
    .const 'Sub' $P9839 = "173_1306916577.75068" 
    assign $P9838, $P9839
    nqp_get_sc_object $P9840, "1306916558.44963", 144
    .const 'Sub' $P9841 = "174_1306916577.75068" 
    assign $P9840, $P9841
    nqp_get_sc_object $P9842, "1306916558.44963", 145
    .const 'Sub' $P9843 = "175_1306916577.75068" 
    assign $P9842, $P9843
    nqp_get_sc_object $P9844, "1306916558.44963", 146
    .const 'Sub' $P9845 = "176_1306916577.75068" 
    assign $P9844, $P9845
    nqp_get_sc_object $P9846, "1306916558.44963", 147
    .const 'Sub' $P9847 = "177_1306916577.75068" 
    assign $P9846, $P9847
    nqp_get_sc_object $P9848, "1306916558.44963", 148
    .const 'Sub' $P9849 = "178_1306916577.75068" 
    assign $P9848, $P9849
    nqp_get_sc_object $P9850, "1306916558.44963", 149
    .const 'Sub' $P9851 = "179_1306916577.75068" 
    assign $P9850, $P9851
    nqp_get_sc_object $P9852, "1306916558.44963", 150
    .const 'Sub' $P9853 = "180_1306916577.75068" 
    assign $P9852, $P9853
    nqp_get_sc_object $P9854, "1306916558.44963", 151
    .const 'Sub' $P9855 = "181_1306916577.75068" 
    assign $P9854, $P9855
    nqp_get_sc_object $P9856, "1306916558.44963", 152
    .const 'Sub' $P9857 = "182_1306916577.75068" 
    assign $P9856, $P9857
    nqp_get_sc_object $P9858, "1306916558.44963", 153
    .const 'Sub' $P9859 = "184_1306916577.75068" 
    assign $P9858, $P9859
    nqp_get_sc_object $P9860, "1306916558.44963", 154
    .const 'Sub' $P9861 = "185_1306916577.75068" 
    assign $P9860, $P9861
    nqp_get_sc_object $P9862, "1306916558.44963", 155
    .const 'Sub' $P9863 = "186_1306916577.75068" 
    assign $P9862, $P9863
    nqp_get_sc_object $P9864, "1306916558.44963", 156
    .const 'Sub' $P9865 = "187_1306916577.75068" 
    assign $P9864, $P9865
    nqp_get_sc_object $P9866, "1306916558.44963", 157
    .const 'Sub' $P9867 = "188_1306916577.75068" 
    assign $P9866, $P9867
    nqp_get_sc_object $P9868, "1306916558.44963", 158
    .const 'Sub' $P9869 = "189_1306916577.75068" 
    assign $P9868, $P9869
    nqp_get_sc_object $P9870, "1306916558.44963", 159
    .const 'Sub' $P9871 = "190_1306916577.75068" 
    assign $P9870, $P9871
    nqp_get_sc_object $P9872, "1306916558.44963", 160
    .const 'Sub' $P9873 = "191_1306916577.75068" 
    assign $P9872, $P9873
    nqp_get_sc_object $P9874, "1306916558.44963", 161
    .const 'Sub' $P9875 = "192_1306916577.75068" 
    assign $P9874, $P9875
    nqp_get_sc_object $P9876, "1306916558.44963", 162
    .const 'Sub' $P9877 = "193_1306916577.75068" 
    assign $P9876, $P9877
    nqp_get_sc_object $P9878, "1306916558.44963", 163
    .const 'Sub' $P9879 = "194_1306916577.75068" 
    assign $P9878, $P9879
    nqp_get_sc_object $P9880, "1306916558.44963", 164
    .const 'Sub' $P9881 = "195_1306916577.75068" 
    assign $P9880, $P9881
    nqp_get_sc_object $P9882, "1306916558.44963", 165
    .const 'Sub' $P9883 = "197_1306916577.75068" 
    assign $P9882, $P9883
    nqp_get_sc_object $P9884, "1306916558.44963", 166
    .const 'Sub' $P9885 = "198_1306916577.75068" 
    assign $P9884, $P9885
    nqp_get_sc_object $P9886, "1306916558.44963", 167
    .const 'Sub' $P9887 = "199_1306916577.75068" 
    assign $P9886, $P9887
    nqp_get_sc_object $P9888, "1306916558.44963", 168
    .const 'Sub' $P9889 = "200_1306916577.75068" 
    assign $P9888, $P9889
    nqp_get_sc_object $P9890, "1306916558.44963", 169
    .const 'Sub' $P9891 = "202_1306916577.75068" 
    assign $P9890, $P9891
    nqp_get_sc_object $P9892, "1306916558.44963", 170
    .const 'Sub' $P9893 = "203_1306916577.75068" 
    assign $P9892, $P9893
    nqp_get_sc_object $P9894, "1306916558.44963", 171
    .const 'Sub' $P9895 = "204_1306916577.75068" 
    assign $P9894, $P9895
    nqp_get_sc_object $P9896, "1306916558.44963", 172
    .const 'Sub' $P9897 = "205_1306916577.75068" 
    assign $P9896, $P9897
    nqp_get_sc_object $P9898, "1306916558.44963", 173
    .const 'Sub' $P9899 = "206_1306916577.75068" 
    assign $P9898, $P9899
    nqp_get_sc_object $P9900, "1306916558.44963", 174
    .const 'Sub' $P9901 = "207_1306916577.75068" 
    assign $P9900, $P9901
    nqp_get_sc_object $P9902, "1306916558.44963", 175
    .const 'Sub' $P9903 = "208_1306916577.75068" 
    assign $P9902, $P9903
    nqp_get_sc_object $P9904, "1306916558.44963", 176
    .const 'Sub' $P9905 = "209_1306916577.75068" 
    assign $P9904, $P9905
    nqp_get_sc_object $P9906, "1306916558.44963", 177
    .const 'Sub' $P9907 = "210_1306916577.75068" 
    assign $P9906, $P9907
    nqp_get_sc_object $P9908, "1306916558.44963", 178
    .const 'Sub' $P9909 = "211_1306916577.75068" 
    assign $P9908, $P9909
    nqp_get_sc_object $P9910, "1306916558.44963", 179
    .const 'Sub' $P9911 = "213_1306916577.75068" 
    assign $P9910, $P9911
    nqp_get_sc_object $P9912, "1306916558.44963", 180
    .const 'Sub' $P9913 = "214_1306916577.75068" 
    assign $P9912, $P9913
    nqp_get_sc_object $P9914, "1306916558.44963", 181
    .const 'Sub' $P9915 = "216_1306916577.75068" 
    assign $P9914, $P9915
    nqp_get_sc_object $P9916, "1306916558.44963", 182
    .const 'Sub' $P9917 = "217_1306916577.75068" 
    assign $P9916, $P9917
    nqp_get_sc_object $P9918, "1306916558.44963", 183
    .const 'Sub' $P9919 = "218_1306916577.75068" 
    assign $P9918, $P9919
    nqp_get_sc_object $P9920, "1306916558.44963", 184
    .const 'Sub' $P9921 = "219_1306916577.75068" 
    assign $P9920, $P9921
    nqp_get_sc_object $P9922, "1306916558.44963", 185
    .const 'Sub' $P9923 = "220_1306916577.75068" 
    assign $P9922, $P9923
    nqp_get_sc_object $P9924, "1306916558.44963", 186
    .const 'Sub' $P9925 = "221_1306916577.75068" 
    assign $P9924, $P9925
    nqp_get_sc_object $P9926, "1306916558.44963", 187
    .const 'Sub' $P9927 = "222_1306916577.75068" 
    assign $P9926, $P9927
    nqp_get_sc_object $P9928, "1306916558.44963", 188
    .const 'Sub' $P9929 = "223_1306916577.75068" 
    assign $P9928, $P9929
    nqp_get_sc_object $P9930, "1306916558.44963", 189
    .const 'Sub' $P9931 = "224_1306916577.75068" 
    assign $P9930, $P9931
    nqp_get_sc_object $P9932, "1306916558.44963", 190
    .const 'Sub' $P9933 = "225_1306916577.75068" 
    assign $P9932, $P9933
    nqp_get_sc_object $P9934, "1306916558.44963", 191
    .const 'Sub' $P9935 = "227_1306916577.75068" 
    assign $P9934, $P9935
    nqp_get_sc_object $P9936, "1306916558.44963", 192
    .const 'Sub' $P9937 = "228_1306916577.75068" 
    assign $P9936, $P9937
    nqp_get_sc_object $P9938, "1306916558.44963", 193
    .const 'Sub' $P9939 = "229_1306916577.75068" 
    assign $P9938, $P9939
    nqp_get_sc_object $P9940, "1306916558.44963", 194
    .const 'Sub' $P9941 = "230_1306916577.75068" 
    assign $P9940, $P9941
    nqp_get_sc_object $P9942, "1306916558.44963", 195
    .const 'Sub' $P9943 = "231_1306916577.75068" 
    assign $P9942, $P9943
    nqp_get_sc_object $P9944, "1306916558.44963", 196
    .const 'Sub' $P9945 = "232_1306916577.75068" 
    assign $P9944, $P9945
    nqp_get_sc_object $P9946, "1306916558.44963", 197
    .const 'Sub' $P9947 = "233_1306916577.75068" 
    assign $P9946, $P9947
    nqp_get_sc_object $P9948, "1306916558.44963", 198
    .const 'Sub' $P9949 = "234_1306916577.75068" 
    assign $P9948, $P9949
    nqp_get_sc_object $P9950, "1306916558.44963", 199
    .const 'Sub' $P9951 = "235_1306916577.75068" 
    assign $P9950, $P9951
    nqp_get_sc_object $P9952, "1306916558.44963", 200
    .const 'Sub' $P9953 = "236_1306916577.75068" 
    assign $P9952, $P9953
    nqp_get_sc_object $P9954, "1306916558.44963", 201
    .const 'Sub' $P9955 = "237_1306916577.75068" 
    assign $P9954, $P9955
    nqp_get_sc_object $P9956, "1306916558.44963", 202
    .const 'Sub' $P9957 = "238_1306916577.75068" 
    assign $P9956, $P9957
    nqp_get_sc_object $P9958, "1306916558.44963", 203
    .const 'Sub' $P9959 = "239_1306916577.75068" 
    assign $P9958, $P9959
    nqp_get_sc_object $P9960, "1306916558.44963", 204
    .const 'Sub' $P9961 = "240_1306916577.75068" 
    assign $P9960, $P9961
    nqp_get_sc_object $P9962, "1306916558.44963", 205
    .const 'Sub' $P9963 = "241_1306916577.75068" 
    assign $P9962, $P9963
    nqp_get_sc_object $P9964, "1306916558.44963", 206
    .const 'Sub' $P9965 = "242_1306916577.75068" 
    assign $P9964, $P9965
    nqp_get_sc_object $P9966, "1306916558.44963", 207
    .const 'Sub' $P9967 = "243_1306916577.75068" 
    assign $P9966, $P9967
    nqp_get_sc_object $P9968, "1306916558.44963", 208
    .const 'Sub' $P9969 = "244_1306916577.75068" 
    assign $P9968, $P9969
    nqp_get_sc_object $P9970, "1306916558.44963", 209
    .const 'Sub' $P9971 = "245_1306916577.75068" 
    assign $P9970, $P9971
    nqp_get_sc_object $P9972, "1306916558.44963", 210
    .const 'Sub' $P9973 = "246_1306916577.75068" 
    assign $P9972, $P9973
    nqp_get_sc_object $P9974, "1306916558.44963", 211
    .const 'Sub' $P9975 = "247_1306916577.75068" 
    assign $P9974, $P9975
    nqp_get_sc_object $P9976, "1306916558.44963", 212
    .const 'Sub' $P9977 = "248_1306916577.75068" 
    assign $P9976, $P9977
    nqp_get_sc_object $P9978, "1306916558.44963", 213
    .const 'Sub' $P9979 = "249_1306916577.75068" 
    assign $P9978, $P9979
    nqp_get_sc_object $P9980, "1306916558.44963", 214
    .const 'Sub' $P9981 = "250_1306916577.75068" 
    assign $P9980, $P9981
    nqp_get_sc_object $P9982, "1306916558.44963", 215
    .const 'Sub' $P9983 = "251_1306916577.75068" 
    assign $P9982, $P9983
    nqp_get_sc_object $P9984, "1306916558.44963", 216
    .const 'Sub' $P9985 = "252_1306916577.75068" 
    assign $P9984, $P9985
    nqp_get_sc_object $P9986, "1306916558.44963", 217
    .const 'Sub' $P9987 = "253_1306916577.75068" 
    assign $P9986, $P9987
    nqp_get_sc_object $P9988, "1306916558.44963", 218
    .const 'Sub' $P9989 = "254_1306916577.75068" 
    assign $P9988, $P9989
    nqp_get_sc_object $P9990, "1306916558.44963", 219
    .const 'Sub' $P9991 = "255_1306916577.75068" 
    assign $P9990, $P9991
    nqp_get_sc_object $P9992, "1306916558.44963", 220
    .const 'Sub' $P9993 = "256_1306916577.75068" 
    assign $P9992, $P9993
    nqp_get_sc_object $P9994, "1306916558.44963", 221
    .const 'Sub' $P9995 = "258_1306916577.75068" 
    assign $P9994, $P9995
    nqp_get_sc_object $P9996, "1306916558.44963", 222
    .const 'Sub' $P9997 = "259_1306916577.75068" 
    assign $P9996, $P9997
    nqp_get_sc_object $P9998, "1306916558.44963", 223
    .const 'Sub' $P9999 = "260_1306916577.75068" 
    assign $P9998, $P9999
    nqp_get_sc_object $P10000, "1306916558.44963", 224
    .const 'Sub' $P10001 = "261_1306916577.75068" 
    assign $P10000, $P10001
    nqp_get_sc_object $P10002, "1306916558.44963", 225
    .const 'Sub' $P10003 = "262_1306916577.75068" 
    assign $P10002, $P10003
    nqp_get_sc_object $P10004, "1306916558.44963", 226
    .const 'Sub' $P10005 = "263_1306916577.75068" 
    assign $P10004, $P10005
    nqp_get_sc_object $P10006, "1306916558.44963", 227
    .const 'Sub' $P10007 = "264_1306916577.75068" 
    assign $P10006, $P10007
    nqp_get_sc_object $P10008, "1306916558.44963", 228
    .const 'Sub' $P10009 = "265_1306916577.75068" 
    assign $P10008, $P10009
    nqp_get_sc_object $P10010, "1306916558.44963", 229
    .const 'Sub' $P10011 = "266_1306916577.75068" 
    assign $P10010, $P10011
    nqp_get_sc_object $P10012, "1306916558.44963", 230
    .const 'Sub' $P10013 = "267_1306916577.75068" 
    assign $P10012, $P10013
    nqp_get_sc_object $P10014, "1306916558.44963", 231
    .const 'Sub' $P10015 = "268_1306916577.75068" 
    assign $P10014, $P10015
    nqp_get_sc_object $P10016, "1306916558.44963", 232
    .const 'Sub' $P10017 = "269_1306916577.75068" 
    assign $P10016, $P10017
    nqp_get_sc_object $P10018, "1306916558.44963", 233
    .const 'Sub' $P10019 = "270_1306916577.75068" 
    assign $P10018, $P10019
    nqp_get_sc_object $P10020, "1306916558.44963", 234
    .const 'Sub' $P10021 = "271_1306916577.75068" 
    assign $P10020, $P10021
    nqp_get_sc_object $P10022, "1306916558.44963", 235
    .const 'Sub' $P10023 = "272_1306916577.75068" 
    assign $P10022, $P10023
    nqp_get_sc_object $P10024, "1306916558.44963", 236
    .const 'Sub' $P10025 = "273_1306916577.75068" 
    assign $P10024, $P10025
    nqp_get_sc_object $P10026, "1306916558.44963", 237
    .const 'Sub' $P10027 = "274_1306916577.75068" 
    assign $P10026, $P10027
    nqp_get_sc_object $P10028, "1306916558.44963", 238
    .const 'Sub' $P10029 = "275_1306916577.75068" 
    assign $P10028, $P10029
    nqp_get_sc_object $P10030, "1306916558.44963", 239
    .const 'Sub' $P10031 = "276_1306916577.75068" 
    assign $P10030, $P10031
    nqp_get_sc_object $P10032, "1306916558.44963", 240
    .const 'Sub' $P10033 = "277_1306916577.75068" 
    assign $P10032, $P10033
    nqp_get_sc_object $P10034, "1306916558.44963", 241
    .const 'Sub' $P10035 = "278_1306916577.75068" 
    assign $P10034, $P10035
    nqp_get_sc_object $P10036, "1306916558.44963", 242
    .const 'Sub' $P10037 = "279_1306916577.75068" 
    assign $P10036, $P10037
    nqp_get_sc_object $P10038, "1306916558.44963", 243
    .const 'Sub' $P10039 = "280_1306916577.75068" 
    assign $P10038, $P10039
    nqp_get_sc_object $P10040, "1306916558.44963", 244
    .const 'Sub' $P10041 = "281_1306916577.75068" 
    assign $P10040, $P10041
    nqp_get_sc_object $P10042, "1306916558.44963", 245
    .const 'Sub' $P10043 = "282_1306916577.75068" 
    assign $P10042, $P10043
    nqp_get_sc_object $P10044, "1306916558.44963", 246
    .const 'Sub' $P10045 = "283_1306916577.75068" 
    assign $P10044, $P10045
    nqp_get_sc_object $P10046, "1306916558.44963", 247
    .const 'Sub' $P10047 = "284_1306916577.75068" 
    assign $P10046, $P10047
    nqp_get_sc_object $P10048, "1306916558.44963", 248
    .const 'Sub' $P10049 = "285_1306916577.75068" 
    assign $P10048, $P10049
    nqp_get_sc_object $P10050, "1306916558.44963", 249
    .const 'Sub' $P10051 = "286_1306916577.75068" 
    assign $P10050, $P10051
    nqp_get_sc_object $P10052, "1306916558.44963", 250
    .const 'Sub' $P10053 = "287_1306916577.75068" 
    assign $P10052, $P10053
    nqp_get_sc_object $P10054, "1306916558.44963", 251
    .const 'Sub' $P10055 = "288_1306916577.75068" 
    assign $P10054, $P10055
    nqp_get_sc_object $P10056, "1306916558.44963", 252
    .const 'Sub' $P10057 = "289_1306916577.75068" 
    assign $P10056, $P10057
    nqp_get_sc_object $P10058, "1306916558.44963", 253
    .const 'Sub' $P10059 = "290_1306916577.75068" 
    assign $P10058, $P10059
    nqp_get_sc_object $P10060, "1306916558.44963", 254
    .const 'Sub' $P10061 = "291_1306916577.75068" 
    assign $P10060, $P10061
    nqp_get_sc_object $P10062, "1306916558.44963", 255
    .const 'Sub' $P10063 = "292_1306916577.75068" 
    assign $P10062, $P10063
    nqp_get_sc_object $P10064, "1306916558.44963", 256
    .const 'Sub' $P10065 = "293_1306916577.75068" 
    assign $P10064, $P10065
    nqp_get_sc_object $P10066, "1306916558.44963", 257
    .const 'Sub' $P10067 = "294_1306916577.75068" 
    assign $P10066, $P10067
    nqp_get_sc_object $P10068, "1306916558.44963", 258
    .const 'Sub' $P10069 = "295_1306916577.75068" 
    assign $P10068, $P10069
    nqp_get_sc_object $P10070, "1306916558.44963", 259
    .const 'Sub' $P10071 = "296_1306916577.75068" 
    assign $P10070, $P10071
    nqp_get_sc_object $P10072, "1306916558.44963", 260
    .const 'Sub' $P10073 = "297_1306916577.75068" 
    assign $P10072, $P10073
    nqp_get_sc_object $P10074, "1306916558.44963", 261
    .const 'Sub' $P10075 = "298_1306916577.75068" 
    assign $P10074, $P10075
    nqp_get_sc_object $P10076, "1306916558.44963", 262
    .const 'Sub' $P10077 = "299_1306916577.75068" 
    assign $P10076, $P10077
    nqp_get_sc_object $P10078, "1306916558.44963", 263
    .const 'Sub' $P10079 = "300_1306916577.75068" 
    assign $P10078, $P10079
    nqp_get_sc_object $P10080, "1306916558.44963", 264
    .const 'Sub' $P10081 = "301_1306916577.75068" 
    assign $P10080, $P10081
    nqp_get_sc_object $P10082, "1306916558.44963", 265
    .const 'Sub' $P10083 = "302_1306916577.75068" 
    assign $P10082, $P10083
    nqp_get_sc_object $P10084, "1306916558.44963", 266
    .const 'Sub' $P10085 = "303_1306916577.75068" 
    assign $P10084, $P10085
    nqp_get_sc_object $P10086, "1306916558.44963", 267
    .const 'Sub' $P10087 = "304_1306916577.75068" 
    assign $P10086, $P10087
    nqp_get_sc_object $P10088, "1306916558.44963", 268
    .const 'Sub' $P10089 = "305_1306916577.75068" 
    assign $P10088, $P10089
    nqp_get_sc_object $P10090, "1306916558.44963", 269
    .const 'Sub' $P10091 = "306_1306916577.75068" 
    assign $P10090, $P10091
    nqp_get_sc_object $P10092, "1306916558.44963", 270
    .const 'Sub' $P10093 = "307_1306916577.75068" 
    assign $P10092, $P10093
    nqp_get_sc_object $P10094, "1306916558.44963", 271
    .const 'Sub' $P10095 = "308_1306916577.75068" 
    assign $P10094, $P10095
    nqp_get_sc_object $P10096, "1306916558.44963", 272
    .const 'Sub' $P10097 = "309_1306916577.75068" 
    assign $P10096, $P10097
    nqp_get_sc_object $P10098, "1306916558.44963", 273
    .const 'Sub' $P10099 = "310_1306916577.75068" 
    assign $P10098, $P10099
    nqp_get_sc_object $P10100, "1306916558.44963", 274
    .const 'Sub' $P10101 = "311_1306916577.75068" 
    assign $P10100, $P10101
    nqp_get_sc_object $P10102, "1306916558.44963", 275
    .const 'Sub' $P10103 = "312_1306916577.75068" 
    assign $P10102, $P10103
    nqp_get_sc_object $P10104, "1306916558.44963", 276
    .const 'Sub' $P10105 = "313_1306916577.75068" 
    assign $P10104, $P10105
    nqp_get_sc_object $P10106, "1306916558.44963", 277
    .const 'Sub' $P10107 = "314_1306916577.75068" 
    assign $P10106, $P10107
    nqp_get_sc_object $P10108, "1306916558.44963", 278
    .const 'Sub' $P10109 = "315_1306916577.75068" 
    assign $P10108, $P10109
    nqp_get_sc_object $P10110, "1306916558.44963", 279
    .const 'Sub' $P10111 = "316_1306916577.75068" 
    assign $P10110, $P10111
    nqp_get_sc_object $P10112, "1306916558.44963", 280
    .const 'Sub' $P10113 = "317_1306916577.75068" 
    assign $P10112, $P10113
    nqp_get_sc_object $P10114, "1306916558.44963", 281
    .const 'Sub' $P10115 = "318_1306916577.75068" 
    assign $P10114, $P10115
    nqp_get_sc_object $P10116, "1306916558.44963", 282
    .const 'Sub' $P10117 = "319_1306916577.75068" 
    assign $P10116, $P10117
    nqp_get_sc_object $P10118, "1306916558.44963", 283
    .const 'Sub' $P10119 = "320_1306916577.75068" 
    assign $P10118, $P10119
    nqp_get_sc_object $P10120, "1306916558.44963", 284
    .const 'Sub' $P10121 = "321_1306916577.75068" 
    assign $P10120, $P10121
    nqp_get_sc_object $P10122, "1306916558.44963", 285
    .const 'Sub' $P10123 = "322_1306916577.75068" 
    assign $P10122, $P10123
    nqp_get_sc_object $P10124, "1306916558.44963", 286
    .const 'Sub' $P10125 = "323_1306916577.75068" 
    assign $P10124, $P10125
    nqp_get_sc_object $P10126, "1306916558.44963", 287
    .const 'Sub' $P10127 = "324_1306916577.75068" 
    assign $P10126, $P10127
    nqp_get_sc_object $P10128, "1306916558.44963", 288
    .const 'Sub' $P10129 = "325_1306916577.75068" 
    assign $P10128, $P10129
    nqp_get_sc_object $P10130, "1306916558.44963", 289
    .const 'Sub' $P10131 = "326_1306916577.75068" 
    assign $P10130, $P10131
    nqp_get_sc_object $P10132, "1306916558.44963", 290
    .const 'Sub' $P10133 = "327_1306916577.75068" 
    assign $P10132, $P10133
    nqp_get_sc_object $P10134, "1306916558.44963", 291
    .const 'Sub' $P10135 = "328_1306916577.75068" 
    assign $P10134, $P10135
    nqp_get_sc_object $P10136, "1306916558.44963", 292
    .const 'Sub' $P10137 = "329_1306916577.75068" 
    assign $P10136, $P10137
    nqp_get_sc_object $P10138, "1306916558.44963", 293
    .const 'Sub' $P10139 = "330_1306916577.75068" 
    assign $P10138, $P10139
    nqp_get_sc_object $P10140, "1306916558.44963", 294
    .const 'Sub' $P10141 = "331_1306916577.75068" 
    assign $P10140, $P10141
    nqp_get_sc_object $P10142, "1306916558.44963", 295
    .const 'Sub' $P10143 = "332_1306916577.75068" 
    assign $P10142, $P10143
    nqp_get_sc_object $P10144, "1306916558.44963", 296
    .const 'Sub' $P10145 = "333_1306916577.75068" 
    assign $P10144, $P10145
    nqp_get_sc_object $P10146, "1306916558.44963", 297
    .const 'Sub' $P10147 = "334_1306916577.75068" 
    assign $P10146, $P10147
    nqp_get_sc_object $P10148, "1306916558.44963", 298
    .const 'Sub' $P10149 = "335_1306916577.75068" 
    assign $P10148, $P10149
    nqp_get_sc_object $P10150, "1306916558.44963", 299
    .const 'Sub' $P10151 = "336_1306916577.75068" 
    assign $P10150, $P10151
    nqp_get_sc_object $P10152, "1306916558.44963", 300
    .const 'Sub' $P10153 = "337_1306916577.75068" 
    assign $P10152, $P10153
    nqp_get_sc_object $P10154, "1306916558.44963", 301
    .const 'Sub' $P10155 = "338_1306916577.75068" 
    assign $P10154, $P10155
    nqp_get_sc_object $P10156, "1306916558.44963", 302
    .const 'Sub' $P10157 = "339_1306916577.75068" 
    assign $P10156, $P10157
    nqp_get_sc_object $P10158, "1306916558.44963", 303
    .const 'Sub' $P10159 = "340_1306916577.75068" 
    assign $P10158, $P10159
    nqp_get_sc_object $P10160, "1306916558.44963", 304
    .const 'Sub' $P10161 = "341_1306916577.75068" 
    assign $P10160, $P10161
    nqp_get_sc_object $P10162, "1306916558.44963", 305
    .const 'Sub' $P10163 = "342_1306916577.75068" 
    assign $P10162, $P10163
    nqp_get_sc_object $P10164, "1306916558.44963", 306
    .const 'Sub' $P10165 = "343_1306916577.75068" 
    assign $P10164, $P10165
    nqp_get_sc_object $P10166, "1306916558.44963", 307
    .const 'Sub' $P10167 = "344_1306916577.75068" 
    assign $P10166, $P10167
    nqp_get_sc_object $P10168, "1306916558.44963", 308
    .const 'Sub' $P10169 = "345_1306916577.75068" 
    assign $P10168, $P10169
    nqp_get_sc_object $P10170, "1306916558.44963", 309
    .const 'Sub' $P10171 = "346_1306916577.75068" 
    assign $P10170, $P10171
    nqp_get_sc_object $P10172, "1306916558.44963", 310
    .const 'Sub' $P10173 = "347_1306916577.75068" 
    assign $P10172, $P10173
    nqp_get_sc_object $P10174, "1306916558.44963", 311
    .const 'Sub' $P10175 = "348_1306916577.75068" 
    assign $P10174, $P10175
    nqp_get_sc_object $P10176, "1306916558.44963", 312
    .const 'Sub' $P10177 = "349_1306916577.75068" 
    assign $P10176, $P10177
    nqp_get_sc_object $P10178, "1306916558.44963", 313
    .const 'Sub' $P10179 = "350_1306916577.75068" 
    assign $P10178, $P10179
    nqp_get_sc_object $P10180, "1306916558.44963", 314
    .const 'Sub' $P10181 = "351_1306916577.75068" 
    assign $P10180, $P10181
    nqp_get_sc_object $P10182, "1306916558.44963", 315
    .const 'Sub' $P10183 = "352_1306916577.75068" 
    assign $P10182, $P10183
    nqp_get_sc_object $P10184, "1306916558.44963", 316
    .const 'Sub' $P10185 = "353_1306916577.75068" 
    assign $P10184, $P10185
    nqp_get_sc_object $P10186, "1306916558.44963", 317
    .const 'Sub' $P10187 = "354_1306916577.75068" 
    assign $P10186, $P10187
    nqp_get_sc_object $P10188, "1306916558.44963", 318
    .const 'Sub' $P10189 = "355_1306916577.75068" 
    assign $P10188, $P10189
    nqp_get_sc_object $P10190, "1306916558.44963", 319
    .const 'Sub' $P10191 = "356_1306916577.75068" 
    assign $P10190, $P10191
    nqp_get_sc_object $P10192, "1306916558.44963", 320
    .const 'Sub' $P10193 = "357_1306916577.75068" 
    assign $P10192, $P10193
    nqp_get_sc_object $P10194, "1306916558.44963", 321
    .const 'Sub' $P10195 = "358_1306916577.75068" 
    assign $P10194, $P10195
    nqp_get_sc_object $P10196, "1306916558.44963", 322
    .const 'Sub' $P10197 = "359_1306916577.75068" 
    assign $P10196, $P10197
    nqp_get_sc_object $P10198, "1306916558.44963", 323
    .const 'Sub' $P10199 = "360_1306916577.75068" 
    assign $P10198, $P10199
    nqp_get_sc_object $P10200, "1306916558.44963", 324
    .const 'Sub' $P10201 = "361_1306916577.75068" 
    assign $P10200, $P10201
    nqp_get_sc_object $P10202, "1306916558.44963", 325
    .const 'Sub' $P10203 = "362_1306916577.75068" 
    assign $P10202, $P10203
    nqp_get_sc_object $P10204, "1306916558.44963", 326
    .const 'Sub' $P10205 = "363_1306916577.75068" 
    assign $P10204, $P10205
    nqp_get_sc_object $P10206, "1306916558.44963", 327
    .const 'Sub' $P10207 = "364_1306916577.75068" 
    assign $P10206, $P10207
    nqp_get_sc_object $P10208, "1306916558.44963", 328
    .const 'Sub' $P10209 = "365_1306916577.75068" 
    assign $P10208, $P10209
    nqp_get_sc_object $P10210, "1306916558.44963", 329
    .const 'Sub' $P10211 = "366_1306916577.75068" 
    assign $P10210, $P10211
    nqp_get_sc_object $P10212, "1306916558.44963", 330
    .const 'Sub' $P10213 = "367_1306916577.75068" 
    assign $P10212, $P10213
    nqp_get_sc_object $P10214, "1306916558.44963", 331
    .const 'Sub' $P10215 = "368_1306916577.75068" 
    assign $P10214, $P10215
    nqp_get_sc_object $P10216, "1306916558.44963", 332
    .const 'Sub' $P10217 = "369_1306916577.75068" 
    assign $P10216, $P10217
    nqp_get_sc_object $P10218, "1306916558.44963", 333
    .const 'Sub' $P10219 = "370_1306916577.75068" 
    assign $P10218, $P10219
    nqp_get_sc_object $P10220, "1306916558.44963", 334
    .const 'Sub' $P10221 = "371_1306916577.75068" 
    assign $P10220, $P10221
    nqp_get_sc_object $P10222, "1306916558.44963", 335
    .const 'Sub' $P10223 = "372_1306916577.75068" 
    assign $P10222, $P10223
    nqp_get_sc_object $P10224, "1306916558.44963", 336
    .const 'Sub' $P10225 = "373_1306916577.75068" 
    assign $P10224, $P10225
    nqp_get_sc_object $P10226, "1306916558.44963", 337
    .const 'Sub' $P10227 = "374_1306916577.75068" 
    assign $P10226, $P10227
    nqp_get_sc_object $P10228, "1306916558.44963", 338
    .const 'Sub' $P10229 = "375_1306916577.75068" 
    assign $P10228, $P10229
    nqp_get_sc_object $P10230, "1306916558.44963", 339
    .const 'Sub' $P10231 = "376_1306916577.75068" 
    assign $P10230, $P10231
    nqp_get_sc_object $P10232, "1306916558.44963", 340
    .const 'Sub' $P10233 = "377_1306916577.75068" 
    assign $P10232, $P10233
    nqp_get_sc_object $P10234, "1306916558.44963", 341
    .const 'Sub' $P10235 = "378_1306916577.75068" 
    assign $P10234, $P10235
    nqp_get_sc_object $P10236, "1306916558.44963", 342
    .const 'Sub' $P10237 = "379_1306916577.75068" 
    assign $P10236, $P10237
    nqp_get_sc_object $P10238, "1306916558.44963", 343
    .const 'Sub' $P10239 = "380_1306916577.75068" 
    assign $P10238, $P10239
    nqp_get_sc_object $P10240, "1306916558.44963", 344
    .const 'Sub' $P10241 = "381_1306916577.75068" 
    assign $P10240, $P10241
    nqp_get_sc_object $P10242, "1306916558.44963", 345
    .const 'Sub' $P10243 = "382_1306916577.75068" 
    assign $P10242, $P10243
    nqp_get_sc_object $P10244, "1306916558.44963", 346
    .const 'Sub' $P10245 = "383_1306916577.75068" 
    assign $P10244, $P10245
    nqp_get_sc_object $P10246, "1306916558.44963", 347
    .const 'Sub' $P10247 = "384_1306916577.75068" 
    assign $P10246, $P10247
    nqp_get_sc_object $P10248, "1306916558.44963", 348
    .const 'Sub' $P10249 = "385_1306916577.75068" 
    assign $P10248, $P10249
    nqp_get_sc_object $P10250, "1306916558.44963", 349
    .const 'Sub' $P10251 = "386_1306916577.75068" 
    assign $P10250, $P10251
    nqp_get_sc_object $P10252, "1306916558.44963", 350
    .const 'Sub' $P10253 = "387_1306916577.75068" 
    assign $P10252, $P10253
    nqp_get_sc_object $P10254, "1306916558.44963", 351
    .const 'Sub' $P10255 = "388_1306916577.75068" 
    assign $P10254, $P10255
    nqp_get_sc_object $P10256, "1306916558.44963", 352
    .const 'Sub' $P10257 = "389_1306916577.75068" 
    assign $P10256, $P10257
    nqp_get_sc_object $P10258, "1306916558.44963", 353
    .const 'Sub' $P10259 = "390_1306916577.75068" 
    assign $P10258, $P10259
    nqp_get_sc_object $P10260, "1306916558.44963", 354
    .const 'Sub' $P10261 = "391_1306916577.75068" 
    assign $P10260, $P10261
    nqp_get_sc_object $P10262, "1306916558.44963", 355
    .const 'Sub' $P10263 = "392_1306916577.75068" 
    assign $P10262, $P10263
    nqp_get_sc_object $P10264, "1306916558.44963", 356
    .const 'Sub' $P10265 = "393_1306916577.75068" 
    assign $P10264, $P10265
    nqp_get_sc_object $P10266, "1306916558.44963", 357
    .const 'Sub' $P10267 = "394_1306916577.75068" 
    assign $P10266, $P10267
    nqp_get_sc_object $P10268, "1306916558.44963", 358
    .const 'Sub' $P10269 = "395_1306916577.75068" 
    assign $P10268, $P10269
    nqp_get_sc_object $P10270, "1306916558.44963", 359
    .const 'Sub' $P10271 = "396_1306916577.75068" 
    assign $P10270, $P10271
    nqp_get_sc_object $P10272, "1306916558.44963", 360
    .const 'Sub' $P10273 = "397_1306916577.75068" 
    assign $P10272, $P10273
    nqp_get_sc_object $P10274, "1306916558.44963", 361
    .const 'Sub' $P10275 = "398_1306916577.75068" 
    assign $P10274, $P10275
    nqp_get_sc_object $P10276, "1306916558.44963", 362
    .const 'Sub' $P10277 = "399_1306916577.75068" 
    assign $P10276, $P10277
    nqp_get_sc_object $P10278, "1306916558.44963", 363
    .const 'Sub' $P10279 = "400_1306916577.75068" 
    assign $P10278, $P10279
    nqp_get_sc_object $P10280, "1306916558.44963", 364
    .const 'Sub' $P10281 = "401_1306916577.75068" 
    assign $P10280, $P10281
    nqp_get_sc_object $P10282, "1306916558.44963", 365
    .const 'Sub' $P10283 = "402_1306916577.75068" 
    assign $P10282, $P10283
    nqp_get_sc_object $P10284, "1306916558.44963", 366
    .const 'Sub' $P10285 = "403_1306916577.75068" 
    assign $P10284, $P10285
    nqp_get_sc_object $P10286, "1306916558.44963", 367
    .const 'Sub' $P10287 = "405_1306916577.75068" 
    assign $P10286, $P10287
    nqp_get_sc_object $P10288, "1306916558.44963", 368
    .const 'Sub' $P10289 = "406_1306916577.75068" 
    assign $P10288, $P10289
    nqp_get_sc_object $P10290, "1306916558.44963", 369
    .const 'Sub' $P10291 = "407_1306916577.75068" 
    assign $P10290, $P10291
    nqp_get_sc_object $P10292, "1306916558.44963", 370
    .const 'Sub' $P10293 = "408_1306916577.75068" 
    assign $P10292, $P10293
    nqp_get_sc_object $P10294, "1306916558.44963", 371
    .const 'Sub' $P10295 = "409_1306916577.75068" 
    assign $P10294, $P10295
    nqp_get_sc_object $P10296, "1306916558.44963", 372
    .const 'Sub' $P10297 = "410_1306916577.75068" 
    assign $P10296, $P10297
    nqp_get_sc_object $P10298, "1306916558.44963", 373
    .const 'Sub' $P10299 = "411_1306916577.75068" 
    assign $P10298, $P10299
    nqp_get_sc_object $P10300, "1306916558.44963", 374
    .const 'Sub' $P10301 = "412_1306916577.75068" 
    assign $P10300, $P10301
    nqp_get_sc_object $P10302, "1306916558.44963", 375
    .const 'Sub' $P10303 = "413_1306916577.75068" 
    assign $P10302, $P10303
    nqp_get_sc_object $P10304, "1306916558.44963", 376
    .const 'Sub' $P10305 = "414_1306916577.75068" 
    assign $P10304, $P10305
    .const 'Sub' $P10306 = "40_1306916577.75068" 
    $P10307 = $P10306."get_lexinfo"()
    nqp_get_sc_object $P10308, "1306916558.44963", 16
    $P10307."set_static_lexpad_value"("$?PACKAGE", $P10308)
    .const 'Sub' $P10309 = "40_1306916577.75068" 
    $P10310 = $P10309."get_lexinfo"()
    $P10310."finish_static_lexpad"()
    .const 'Sub' $P10311 = "40_1306916577.75068" 
    $P10312 = $P10311."get_lexinfo"()
    nqp_get_sc_object $P10313, "1306916558.44963", 16
    $P10312."set_static_lexpad_value"("$?CLASS", $P10313)
    .const 'Sub' $P10314 = "40_1306916577.75068" 
    $P10315 = $P10314."get_lexinfo"()
    $P10315."finish_static_lexpad"()
    nqp_get_sc_object $P10316, "1306916558.44963", 378
    .const 'Sub' $P10317 = "416_1306916577.75068" 
    assign $P10316, $P10317
    nqp_get_sc_object $P10318, "1306916558.44963", 379
    .const 'Sub' $P10319 = "418_1306916577.75068" 
    assign $P10318, $P10319
    nqp_get_sc_object $P10320, "1306916558.44963", 380
    .const 'Sub' $P10321 = "419_1306916577.75068" 
    assign $P10320, $P10321
    nqp_get_sc_object $P10322, "1306916558.44963", 381
    .const 'Sub' $P10323 = "420_1306916577.75068" 
    assign $P10322, $P10323
    nqp_get_sc_object $P10324, "1306916558.44963", 382
    .const 'Sub' $P10325 = "421_1306916577.75068" 
    assign $P10324, $P10325
    nqp_get_sc_object $P10326, "1306916558.44963", 383
    .const 'Sub' $P10327 = "423_1306916577.75068" 
    assign $P10326, $P10327
    nqp_get_sc_object $P10328, "1306916558.44963", 384
    .const 'Sub' $P10329 = "424_1306916577.75068" 
    assign $P10328, $P10329
    nqp_get_sc_object $P10330, "1306916558.44963", 385
    .const 'Sub' $P10331 = "425_1306916577.75068" 
    assign $P10330, $P10331
    nqp_get_sc_object $P10332, "1306916558.44963", 386
    .const 'Sub' $P10333 = "426_1306916577.75068" 
    assign $P10332, $P10333
    nqp_get_sc_object $P10334, "1306916558.44963", 387
    .const 'Sub' $P10335 = "428_1306916577.75068" 
    assign $P10334, $P10335
    nqp_get_sc_object $P10336, "1306916558.44963", 388
    .const 'Sub' $P10337 = "429_1306916577.75068" 
    assign $P10336, $P10337
    nqp_get_sc_object $P10338, "1306916558.44963", 389
    .const 'Sub' $P10339 = "431_1306916577.75068" 
    assign $P10338, $P10339
    nqp_get_sc_object $P10340, "1306916558.44963", 390
    .const 'Sub' $P10341 = "432_1306916577.75068" 
    assign $P10340, $P10341
    nqp_get_sc_object $P10342, "1306916558.44963", 391
    .const 'Sub' $P10343 = "433_1306916577.75068" 
    assign $P10342, $P10343
    nqp_get_sc_object $P10344, "1306916558.44963", 392
    .const 'Sub' $P10345 = "434_1306916577.75068" 
    assign $P10344, $P10345
    nqp_get_sc_object $P10346, "1306916558.44963", 393
    .const 'Sub' $P10347 = "435_1306916577.75068" 
    assign $P10346, $P10347
    .const 'Sub' $P10348 = "415_1306916577.75068" 
    $P10349 = $P10348."get_lexinfo"()
    nqp_get_sc_object $P10350, "1306916558.44963", 377
    $P10349."set_static_lexpad_value"("$?PACKAGE", $P10350)
    .const 'Sub' $P10351 = "415_1306916577.75068" 
    $P10352 = $P10351."get_lexinfo"()
    $P10352."finish_static_lexpad"()
    .const 'Sub' $P10353 = "415_1306916577.75068" 
    $P10354 = $P10353."get_lexinfo"()
    nqp_get_sc_object $P10355, "1306916558.44963", 377
    $P10354."set_static_lexpad_value"("$?CLASS", $P10355)
    .const 'Sub' $P10356 = "415_1306916577.75068" 
    $P10357 = $P10356."get_lexinfo"()
    $P10357."finish_static_lexpad"()
    nqp_get_sc_object $P10358, "1306916558.44963", 395
    .const 'Sub' $P10359 = "463_1306916577.75068" 
    assign $P10358, $P10359
    nqp_get_sc_object $P10360, "1306916558.44963", 396
    .const 'Sub' $P10361 = "464_1306916577.75068" 
    assign $P10360, $P10361
    nqp_get_sc_object $P10362, "1306916558.44963", 397
    .const 'Sub' $P10363 = "465_1306916577.75068" 
    assign $P10362, $P10363
    nqp_get_sc_object $P10364, "1306916558.44963", 398
    .const 'Sub' $P10365 = "467_1306916577.75068" 
    assign $P10364, $P10365
    nqp_get_sc_object $P10366, "1306916558.44963", 399
    .const 'Sub' $P10367 = "469_1306916577.75068" 
    assign $P10366, $P10367
    nqp_get_sc_object $P10368, "1306916558.44963", 400
    .const 'Sub' $P10369 = "471_1306916577.75068" 
    assign $P10368, $P10369
    nqp_get_sc_object $P10370, "1306916558.44963", 401
    .const 'Sub' $P10371 = "472_1306916577.75068" 
    assign $P10370, $P10371
    nqp_get_sc_object $P10372, "1306916558.44963", 402
    .const 'Sub' $P10373 = "473_1306916577.75068" 
    assign $P10372, $P10373
    nqp_get_sc_object $P10374, "1306916558.44963", 403
    .const 'Sub' $P10375 = "474_1306916577.75068" 
    assign $P10374, $P10375
    nqp_get_sc_object $P10376, "1306916558.44963", 404
    .const 'Sub' $P10377 = "476_1306916577.75068" 
    assign $P10376, $P10377
    nqp_get_sc_object $P10378, "1306916558.44963", 405
    .const 'Sub' $P10379 = "477_1306916577.75068" 
    assign $P10378, $P10379
    nqp_get_sc_object $P10380, "1306916558.44963", 406
    .const 'Sub' $P10381 = "479_1306916577.75068" 
    assign $P10380, $P10381
    nqp_get_sc_object $P10382, "1306916558.44963", 407
    .const 'Sub' $P10383 = "480_1306916577.75068" 
    assign $P10382, $P10383
    nqp_get_sc_object $P10384, "1306916558.44963", 408
    .const 'Sub' $P10385 = "481_1306916577.75068" 
    assign $P10384, $P10385
    nqp_get_sc_object $P10386, "1306916558.44963", 409
    .const 'Sub' $P10387 = "482_1306916577.75068" 
    assign $P10386, $P10387
    nqp_get_sc_object $P10388, "1306916558.44963", 410
    .const 'Sub' $P10389 = "484_1306916577.75068" 
    assign $P10388, $P10389
    nqp_get_sc_object $P10390, "1306916558.44963", 411
    .const 'Sub' $P10391 = "485_1306916577.75068" 
    assign $P10390, $P10391
    nqp_get_sc_object $P10392, "1306916558.44963", 412
    .const 'Sub' $P10393 = "486_1306916577.75068" 
    assign $P10392, $P10393
    nqp_get_sc_object $P10394, "1306916558.44963", 413
    .const 'Sub' $P10395 = "487_1306916577.75068" 
    assign $P10394, $P10395
    nqp_get_sc_object $P10396, "1306916558.44963", 414
    .const 'Sub' $P10397 = "488_1306916577.75068" 
    assign $P10396, $P10397
    nqp_get_sc_object $P10398, "1306916558.44963", 415
    .const 'Sub' $P10399 = "489_1306916577.75068" 
    assign $P10398, $P10399
    nqp_get_sc_object $P10400, "1306916558.44963", 416
    .const 'Sub' $P10401 = "490_1306916577.75068" 
    assign $P10400, $P10401
    nqp_get_sc_object $P10402, "1306916558.44963", 417
    .const 'Sub' $P10403 = "491_1306916577.75068" 
    assign $P10402, $P10403
    nqp_get_sc_object $P10404, "1306916558.44963", 418
    .const 'Sub' $P10405 = "492_1306916577.75068" 
    assign $P10404, $P10405
    nqp_get_sc_object $P10406, "1306916558.44963", 419
    .const 'Sub' $P10407 = "493_1306916577.75068" 
    assign $P10406, $P10407
    nqp_get_sc_object $P10408, "1306916558.44963", 420
    .const 'Sub' $P10409 = "494_1306916577.75068" 
    assign $P10408, $P10409
    nqp_get_sc_object $P10410, "1306916558.44963", 421
    .const 'Sub' $P10411 = "495_1306916577.75068" 
    assign $P10410, $P10411
    nqp_get_sc_object $P10412, "1306916558.44963", 422
    .const 'Sub' $P10413 = "496_1306916577.75068" 
    assign $P10412, $P10413
    nqp_get_sc_object $P10414, "1306916558.44963", 423
    .const 'Sub' $P10415 = "497_1306916577.75068" 
    assign $P10414, $P10415
    nqp_get_sc_object $P10416, "1306916558.44963", 424
    .const 'Sub' $P10417 = "498_1306916577.75068" 
    assign $P10416, $P10417
    nqp_get_sc_object $P10418, "1306916558.44963", 425
    .const 'Sub' $P10419 = "499_1306916577.75068" 
    assign $P10418, $P10419
    nqp_get_sc_object $P10420, "1306916558.44963", 426
    .const 'Sub' $P10421 = "500_1306916577.75068" 
    assign $P10420, $P10421
    nqp_get_sc_object $P10422, "1306916558.44963", 427
    .const 'Sub' $P10423 = "501_1306916577.75068" 
    assign $P10422, $P10423
    nqp_get_sc_object $P10424, "1306916558.44963", 428
    .const 'Sub' $P10425 = "502_1306916577.75068" 
    assign $P10424, $P10425
    nqp_get_sc_object $P10426, "1306916558.44963", 429
    .const 'Sub' $P10427 = "503_1306916577.75068" 
    assign $P10426, $P10427
    nqp_get_sc_object $P10428, "1306916558.44963", 430
    .const 'Sub' $P10429 = "504_1306916577.75068" 
    assign $P10428, $P10429
    nqp_get_sc_object $P10430, "1306916558.44963", 431
    .const 'Sub' $P10431 = "505_1306916577.75068" 
    assign $P10430, $P10431
    nqp_get_sc_object $P10432, "1306916558.44963", 432
    .const 'Sub' $P10433 = "506_1306916577.75068" 
    assign $P10432, $P10433
    nqp_get_sc_object $P10434, "1306916558.44963", 433
    .const 'Sub' $P10435 = "507_1306916577.75068" 
    assign $P10434, $P10435
    nqp_get_sc_object $P10436, "1306916558.44963", 434
    .const 'Sub' $P10437 = "508_1306916577.75068" 
    assign $P10436, $P10437
    nqp_get_sc_object $P10438, "1306916558.44963", 435
    .const 'Sub' $P10439 = "514_1306916577.75068" 
    assign $P10438, $P10439
    nqp_get_sc_object $P10440, "1306916558.44963", 436
    .const 'Sub' $P10441 = "515_1306916577.75068" 
    assign $P10440, $P10441
    nqp_get_sc_object $P10442, "1306916558.44963", 437
    .const 'Sub' $P10443 = "516_1306916577.75068" 
    assign $P10442, $P10443
    nqp_get_sc_object $P10444, "1306916558.44963", 438
    .const 'Sub' $P10445 = "517_1306916577.75068" 
    assign $P10444, $P10445
    nqp_get_sc_object $P10446, "1306916558.44963", 439
    .const 'Sub' $P10447 = "518_1306916577.75068" 
    assign $P10446, $P10447
    nqp_get_sc_object $P10448, "1306916558.44963", 440
    .const 'Sub' $P10449 = "519_1306916577.75068" 
    assign $P10448, $P10449
    nqp_get_sc_object $P10450, "1306916558.44963", 441
    .const 'Sub' $P10451 = "520_1306916577.75068" 
    assign $P10450, $P10451
    nqp_get_sc_object $P10452, "1306916558.44963", 442
    .const 'Sub' $P10453 = "521_1306916577.75068" 
    assign $P10452, $P10453
    nqp_get_sc_object $P10454, "1306916558.44963", 443
    .const 'Sub' $P10455 = "527_1306916577.75068" 
    assign $P10454, $P10455
    nqp_get_sc_object $P10456, "1306916558.44963", 444
    .const 'Sub' $P10457 = "528_1306916577.75068" 
    assign $P10456, $P10457
    nqp_get_sc_object $P10458, "1306916558.44963", 445
    .const 'Sub' $P10459 = "529_1306916577.75068" 
    assign $P10458, $P10459
    nqp_get_sc_object $P10460, "1306916558.44963", 446
    .const 'Sub' $P10461 = "530_1306916577.75068" 
    assign $P10460, $P10461
    nqp_get_sc_object $P10462, "1306916558.44963", 447
    .const 'Sub' $P10463 = "531_1306916577.75068" 
    assign $P10462, $P10463
    nqp_get_sc_object $P10464, "1306916558.44963", 448
    .const 'Sub' $P10465 = "532_1306916577.75068" 
    assign $P10464, $P10465
    nqp_get_sc_object $P10466, "1306916558.44963", 449
    .const 'Sub' $P10467 = "533_1306916577.75068" 
    assign $P10466, $P10467
    nqp_get_sc_object $P10468, "1306916558.44963", 450
    .const 'Sub' $P10469 = "534_1306916577.75068" 
    assign $P10468, $P10469
    nqp_get_sc_object $P10470, "1306916558.44963", 451
    .const 'Sub' $P10471 = "535_1306916577.75068" 
    assign $P10470, $P10471
    nqp_get_sc_object $P10472, "1306916558.44963", 452
    .const 'Sub' $P10473 = "538_1306916577.75068" 
    assign $P10472, $P10473
    nqp_get_sc_object $P10474, "1306916558.44963", 453
    .const 'Sub' $P10475 = "539_1306916577.75068" 
    assign $P10474, $P10475
    nqp_get_sc_object $P10476, "1306916558.44963", 454
    .const 'Sub' $P10477 = "540_1306916577.75068" 
    assign $P10476, $P10477
    nqp_get_sc_object $P10478, "1306916558.44963", 455
    .const 'Sub' $P10479 = "547_1306916577.75068" 
    assign $P10478, $P10479
    nqp_get_sc_object $P10480, "1306916558.44963", 456
    .const 'Sub' $P10481 = "550_1306916577.75068" 
    assign $P10480, $P10481
    nqp_get_sc_object $P10482, "1306916558.44963", 457
    .const 'Sub' $P10483 = "553_1306916577.75068" 
    assign $P10482, $P10483
    nqp_get_sc_object $P10484, "1306916558.44963", 458
    .const 'Sub' $P10485 = "554_1306916577.75068" 
    assign $P10484, $P10485
    nqp_get_sc_object $P10486, "1306916558.44963", 459
    .const 'Sub' $P10487 = "555_1306916577.75068" 
    assign $P10486, $P10487
    nqp_get_sc_object $P10488, "1306916558.44963", 460
    .const 'Sub' $P10489 = "556_1306916577.75068" 
    assign $P10488, $P10489
    nqp_get_sc_object $P10490, "1306916558.44963", 461
    .const 'Sub' $P10491 = "558_1306916577.75068" 
    assign $P10490, $P10491
    nqp_get_sc_object $P10492, "1306916558.44963", 462
    .const 'Sub' $P10493 = "559_1306916577.75068" 
    assign $P10492, $P10493
    nqp_get_sc_object $P10494, "1306916558.44963", 463
    .const 'Sub' $P10495 = "564_1306916577.75068" 
    assign $P10494, $P10495
    nqp_get_sc_object $P10496, "1306916558.44963", 464
    .const 'Sub' $P10497 = "569_1306916577.75068" 
    assign $P10496, $P10497
    nqp_get_sc_object $P10498, "1306916558.44963", 465
    .const 'Sub' $P10499 = "570_1306916577.75068" 
    assign $P10498, $P10499
    nqp_get_sc_object $P10500, "1306916558.44963", 466
    .const 'Sub' $P10501 = "571_1306916577.75068" 
    assign $P10500, $P10501
    nqp_get_sc_object $P10502, "1306916558.44963", 467
    .const 'Sub' $P10503 = "572_1306916577.75068" 
    assign $P10502, $P10503
    nqp_get_sc_object $P10504, "1306916558.44963", 468
    .const 'Sub' $P10505 = "574_1306916577.75068" 
    assign $P10504, $P10505
    nqp_get_sc_object $P10506, "1306916558.44963", 469
    .const 'Sub' $P10507 = "575_1306916577.75068" 
    assign $P10506, $P10507
    nqp_get_sc_object $P10508, "1306916558.44963", 470
    .const 'Sub' $P10509 = "576_1306916577.75068" 
    assign $P10508, $P10509
    nqp_get_sc_object $P10510, "1306916558.44963", 471
    .const 'Sub' $P10511 = "577_1306916577.75068" 
    assign $P10510, $P10511
    nqp_get_sc_object $P10512, "1306916558.44963", 472
    .const 'Sub' $P10513 = "580_1306916577.75068" 
    assign $P10512, $P10513
    nqp_get_sc_object $P10514, "1306916558.44963", 473
    .const 'Sub' $P10515 = "581_1306916577.75068" 
    assign $P10514, $P10515
    nqp_get_sc_object $P10516, "1306916558.44963", 474
    .const 'Sub' $P10517 = "582_1306916577.75068" 
    assign $P10516, $P10517
    nqp_get_sc_object $P10518, "1306916558.44963", 475
    .const 'Sub' $P10519 = "583_1306916577.75068" 
    assign $P10518, $P10519
    nqp_get_sc_object $P10520, "1306916558.44963", 476
    .const 'Sub' $P10521 = "584_1306916577.75068" 
    assign $P10520, $P10521
    nqp_get_sc_object $P10522, "1306916558.44963", 477
    .const 'Sub' $P10523 = "585_1306916577.75068" 
    assign $P10522, $P10523
    nqp_get_sc_object $P10524, "1306916558.44963", 478
    .const 'Sub' $P10525 = "586_1306916577.75068" 
    assign $P10524, $P10525
    nqp_get_sc_object $P10526, "1306916558.44963", 479
    .const 'Sub' $P10527 = "588_1306916577.75068" 
    assign $P10526, $P10527
    nqp_get_sc_object $P10528, "1306916558.44963", 480
    .const 'Sub' $P10529 = "589_1306916577.75068" 
    assign $P10528, $P10529
    nqp_get_sc_object $P10530, "1306916558.44963", 481
    .const 'Sub' $P10531 = "590_1306916577.75068" 
    assign $P10530, $P10531
    nqp_get_sc_object $P10532, "1306916558.44963", 482
    .const 'Sub' $P10533 = "591_1306916577.75068" 
    assign $P10532, $P10533
    nqp_get_sc_object $P10534, "1306916558.44963", 483
    .const 'Sub' $P10535 = "592_1306916577.75068" 
    assign $P10534, $P10535
    nqp_get_sc_object $P10536, "1306916558.44963", 484
    .const 'Sub' $P10537 = "593_1306916577.75068" 
    assign $P10536, $P10537
    nqp_get_sc_object $P10538, "1306916558.44963", 485
    .const 'Sub' $P10539 = "594_1306916577.75068" 
    assign $P10538, $P10539
    nqp_get_sc_object $P10540, "1306916558.44963", 486
    .const 'Sub' $P10541 = "595_1306916577.75068" 
    assign $P10540, $P10541
    nqp_get_sc_object $P10542, "1306916558.44963", 487
    .const 'Sub' $P10543 = "596_1306916577.75068" 
    assign $P10542, $P10543
    nqp_get_sc_object $P10544, "1306916558.44963", 488
    .const 'Sub' $P10545 = "597_1306916577.75068" 
    assign $P10544, $P10545
    nqp_get_sc_object $P10546, "1306916558.44963", 489
    .const 'Sub' $P10547 = "598_1306916577.75068" 
    assign $P10546, $P10547
    nqp_get_sc_object $P10548, "1306916558.44963", 490
    .const 'Sub' $P10549 = "599_1306916577.75068" 
    assign $P10548, $P10549
    nqp_get_sc_object $P10550, "1306916558.44963", 491
    .const 'Sub' $P10551 = "600_1306916577.75068" 
    assign $P10550, $P10551
    nqp_get_sc_object $P10552, "1306916558.44963", 492
    .const 'Sub' $P10553 = "601_1306916577.75068" 
    assign $P10552, $P10553
    nqp_get_sc_object $P10554, "1306916558.44963", 493
    .const 'Sub' $P10555 = "602_1306916577.75068" 
    assign $P10554, $P10555
    nqp_get_sc_object $P10556, "1306916558.44963", 494
    .const 'Sub' $P10557 = "603_1306916577.75068" 
    assign $P10556, $P10557
    nqp_get_sc_object $P10558, "1306916558.44963", 495
    .const 'Sub' $P10559 = "604_1306916577.75068" 
    assign $P10558, $P10559
    nqp_get_sc_object $P10560, "1306916558.44963", 496
    .const 'Sub' $P10561 = "605_1306916577.75068" 
    assign $P10560, $P10561
    nqp_get_sc_object $P10562, "1306916558.44963", 497
    .const 'Sub' $P10563 = "606_1306916577.75068" 
    assign $P10562, $P10563
    nqp_get_sc_object $P10564, "1306916558.44963", 498
    .const 'Sub' $P10565 = "607_1306916577.75068" 
    assign $P10564, $P10565
    nqp_get_sc_object $P10566, "1306916558.44963", 499
    .const 'Sub' $P10567 = "608_1306916577.75068" 
    assign $P10566, $P10567
    nqp_get_sc_object $P10568, "1306916558.44963", 500
    .const 'Sub' $P10569 = "609_1306916577.75068" 
    assign $P10568, $P10569
    nqp_get_sc_object $P10570, "1306916558.44963", 501
    .const 'Sub' $P10571 = "610_1306916577.75068" 
    assign $P10570, $P10571
    nqp_get_sc_object $P10572, "1306916558.44963", 502
    .const 'Sub' $P10573 = "611_1306916577.75068" 
    assign $P10572, $P10573
    nqp_get_sc_object $P10574, "1306916558.44963", 503
    .const 'Sub' $P10575 = "612_1306916577.75068" 
    assign $P10574, $P10575
    nqp_get_sc_object $P10576, "1306916558.44963", 504
    .const 'Sub' $P10577 = "613_1306916577.75068" 
    assign $P10576, $P10577
    nqp_get_sc_object $P10578, "1306916558.44963", 505
    .const 'Sub' $P10579 = "614_1306916577.75068" 
    assign $P10578, $P10579
    .const 'Sub' $P10580 = "436_1306916577.75068" 
    $P10581 = $P10580."get_lexinfo"()
    nqp_get_sc_object $P10582, "1306916558.44963", 394
    $P10581."set_static_lexpad_value"("$?PACKAGE", $P10582)
    .const 'Sub' $P10583 = "436_1306916577.75068" 
    $P10584 = $P10583."get_lexinfo"()
    $P10584."finish_static_lexpad"()
    .const 'Sub' $P10585 = "436_1306916577.75068" 
    $P10586 = $P10585."get_lexinfo"()
    nqp_get_sc_object $P10587, "1306916558.44963", 394
    $P10586."set_static_lexpad_value"("$?CLASS", $P10587)
    .const 'Sub' $P10588 = "436_1306916577.75068" 
    $P10589 = $P10588."get_lexinfo"()
    $P10589."finish_static_lexpad"()
    nqp_get_sc_object $P10590, "1306916558.44963", 507
    .const 'Sub' $P10591 = "617_1306916577.75068" 
    assign $P10590, $P10591
    nqp_get_sc_object $P10592, "1306916558.44963", 508
    .const 'Sub' $P10593 = "618_1306916577.75068" 
    assign $P10592, $P10593
    nqp_get_sc_object $P10594, "1306916558.44963", 509
    .const 'Sub' $P10595 = "619_1306916577.75068" 
    assign $P10594, $P10595
    nqp_get_sc_object $P10596, "1306916558.44963", 510
    .const 'Sub' $P10597 = "620_1306916577.75068" 
    assign $P10596, $P10597
    nqp_get_sc_object $P10598, "1306916558.44963", 511
    .const 'Sub' $P10599 = "621_1306916577.75068" 
    assign $P10598, $P10599
    nqp_get_sc_object $P10600, "1306916558.44963", 512
    .const 'Sub' $P10601 = "622_1306916577.75068" 
    assign $P10600, $P10601
    nqp_get_sc_object $P10602, "1306916558.44963", 513
    .const 'Sub' $P10603 = "623_1306916577.75068" 
    assign $P10602, $P10603
    .const 'Sub' $P10604 = "616_1306916577.75068" 
    $P10605 = $P10604."get_lexinfo"()
    nqp_get_sc_object $P10606, "1306916558.44963", 506
    $P10605."set_static_lexpad_value"("$?PACKAGE", $P10606)
    .const 'Sub' $P10607 = "616_1306916577.75068" 
    $P10608 = $P10607."get_lexinfo"()
    $P10608."finish_static_lexpad"()
    .const 'Sub' $P10609 = "616_1306916577.75068" 
    $P10610 = $P10609."get_lexinfo"()
    nqp_get_sc_object $P10611, "1306916558.44963", 506
    $P10610."set_static_lexpad_value"("$?CLASS", $P10611)
    .const 'Sub' $P10612 = "616_1306916577.75068" 
    $P10613 = $P10612."get_lexinfo"()
    $P10613."finish_static_lexpad"()
    .const 'Sub' $P10614 = "624_1306916577.75068" 
    $P10615 = $P10614."get_lexinfo"()
    nqp_get_sc_object $P10616, "1306916558.44963", 514
    $P10615."set_static_lexpad_value"("$?PACKAGE", $P10616)
    .const 'Sub' $P10617 = "624_1306916577.75068" 
    $P10618 = $P10617."get_lexinfo"()
    $P10618."finish_static_lexpad"()
    .const 'Sub' $P10619 = "624_1306916577.75068" 
    $P10620 = $P10619."get_lexinfo"()
    nqp_get_sc_object $P10621, "1306916558.44963", 514
    $P10620."set_static_lexpad_value"("$?CLASS", $P10621)
    .const 'Sub' $P10622 = "624_1306916577.75068" 
    $P10623 = $P10622."get_lexinfo"()
    $P10623."finish_static_lexpad"()
    goto if_7343_end
  if_7343:
    nqp_dynop_setup 
    getinterp $P7346
    get_class $P7347, "LexPad"
    get_class $P7348, "NQPLexPad"
    $P7346."hll_map"($P7347, $P7348)
    nqp_create_sc $P7349, "1306916558.44963"
    .local pmc cur_sc
    set cur_sc, $P7349
    nqp_get_sc_object $P7350, "__6MODEL_CORE__", 0
    $P7351 = $P7350."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7351, cur_sc
    nqp_set_sc_object "1306916558.44963", 0, $P7351
    .const 'Sub' $P7352 = "10_1306916577.75068" 
    $P7353 = $P7352."get_lexinfo"()
    nqp_get_sc_object $P7354, "1306916558.44963", 0
    $P7353."set_static_lexpad_value"("GLOBALish", $P7354)
    .const 'Sub' $P7355 = "10_1306916577.75068" 
    $P7356 = $P7355."get_lexinfo"()
    $P7356."finish_static_lexpad"()
    .const 'Sub' $P7357 = "10_1306916577.75068" 
    $P7358 = $P7357."get_lexinfo"()
    nqp_get_sc_object $P7359, "1306916558.44963", 0
    $P7358."set_static_lexpad_value"("$?PACKAGE", $P7359)
    .const 'Sub' $P7360 = "10_1306916577.75068" 
    $P7361 = $P7360."get_lexinfo"()
    $P7361."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7362, "ModuleLoader"
    $P7363 = $P7362."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7363)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7364, "ModuleLoader"
    nqp_get_sc_object $P7365, "1306916558.44963", 0
    $P7364."load_module"("NQPRegex", $P7365)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7366, "ModuleLoader"
    nqp_get_sc_object $P7367, "1306916558.44963", 0
    $P7366."load_module"("NQPP6Regex", $P7367)
    nqp_get_sc_object $P7368, "1306916525.99765", 41
    $P7369 = $P7368."new_type"("NQP::SymbolTable" :named("name"))
    nqp_set_sc_for_object $P7369, cur_sc
    nqp_set_sc_object "1306916558.44963", 1, $P7369
    nqp_get_sc_object $P7370, "1306916558.44963", 1
    nqp_get_sc_object $P7371, "1306916558.44963", 0
    nqp_get_package_through_who $P7372, $P7371, "NQP"
    get_who $P7373, $P7372
    set $P7373["SymbolTable"], $P7370
    nqp_get_sc_object $P7374, "1306916558.44963", 1
    get_how $P7375, $P7374
    nqp_get_sc_object $P7376, "1306916558.44963", 1
    .const 'Sub' $P7377 = "14_1306916577.75068" 
    $P7375."add_method"($P7376, "load_setting", $P7377)
    nqp_get_sc_object $P7378, "1306916558.44963", 1
    get_how $P7379, $P7378
    nqp_get_sc_object $P7380, "1306916558.44963", 1
    .const 'Sub' $P7381 = "16_1306916577.75068" 
    $P7379."add_method"($P7380, "load_module", $P7381)
    nqp_get_sc_object $P7382, "1306916558.44963", 1
    get_how $P7383, $P7382
    nqp_get_sc_object $P7384, "1306916558.44963", 1
    .const 'Sub' $P7385 = "17_1306916577.75068" 
    $P7383."add_method"($P7384, "install_package_symbol", $P7385)
    nqp_get_sc_object $P7386, "1306916558.44963", 1
    get_how $P7387, $P7386
    nqp_get_sc_object $P7388, "1306916558.44963", 1
    .const 'Sub' $P7389 = "20_1306916577.75068" 
    $P7387."add_method"($P7388, "install_lexical_symbol", $P7389)
    nqp_get_sc_object $P7390, "1306916558.44963", 1
    get_how $P7391, $P7390
    nqp_get_sc_object $P7392, "1306916558.44963", 1
    .const 'Sub' $P7393 = "21_1306916577.75068" 
    $P7391."add_method"($P7392, "install_package_routine", $P7393)
    nqp_get_sc_object $P7394, "1306916558.44963", 1
    get_how $P7395, $P7394
    nqp_get_sc_object $P7396, "1306916558.44963", 1
    .const 'Sub' $P7397 = "22_1306916577.75068" 
    $P7395."add_method"($P7396, "pkg_create_mo", $P7397)
    nqp_get_sc_object $P7398, "1306916558.44963", 1
    get_how $P7399, $P7398
    nqp_get_sc_object $P7400, "1306916558.44963", 1
    .const 'Sub' $P7401 = "23_1306916577.75068" 
    $P7399."add_method"($P7400, "pkg_add_attribute", $P7401)
    nqp_get_sc_object $P7402, "1306916558.44963", 1
    get_how $P7403, $P7402
    nqp_get_sc_object $P7404, "1306916558.44963", 1
    .const 'Sub' $P7405 = "26_1306916577.75068" 
    $P7403."add_method"($P7404, "pkg_add_method", $P7405)
    nqp_get_sc_object $P7406, "1306916558.44963", 1
    get_how $P7407, $P7406
    nqp_get_sc_object $P7408, "1306916558.44963", 1
    .const 'Sub' $P7409 = "29_1306916577.75068" 
    $P7407."add_method"($P7408, "set_routine_signature", $P7409)
    nqp_get_sc_object $P7410, "1306916558.44963", 1
    get_how $P7411, $P7410
    nqp_get_sc_object $P7412, "1306916558.44963", 1
    .const 'Sub' $P7413 = "30_1306916577.75068" 
    $P7411."add_method"($P7412, "pkg_set_body_block", $P7413)
    nqp_get_sc_object $P7414, "1306916558.44963", 1
    get_how $P7415, $P7414
    nqp_get_sc_object $P7416, "1306916558.44963", 1
    .const 'Sub' $P7417 = "35_1306916577.75068" 
    $P7415."add_method"($P7416, "pkg_add_parent_or_role", $P7417)
    nqp_get_sc_object $P7418, "1306916558.44963", 1
    get_how $P7419, $P7418
    nqp_get_sc_object $P7420, "1306916558.44963", 1
    .const 'Sub' $P7421 = "36_1306916577.75068" 
    $P7419."add_method"($P7420, "pkg_add_parrot_vtable_handler_mapping", $P7421)
    nqp_get_sc_object $P7422, "1306916558.44963", 1
    get_how $P7423, $P7422
    nqp_get_sc_object $P7424, "1306916558.44963", 1
    .const 'Sub' $P7425 = "37_1306916577.75068" 
    $P7423."add_method"($P7424, "pkg_compose", $P7425)
    nqp_get_sc_object $P7426, "1306916558.44963", 1
    get_how $P7427, $P7426
    nqp_get_sc_object $P7428, "1306916558.44963", 1
    .const 'Sub' $P7429 = "38_1306916577.75068" 
    $P7427."add_method"($P7428, "to_past", $P7429)
    .const 'Sub' $P7430 = "13_1306916577.75068" 
    $P7431 = $P7430."get_lexinfo"()
    nqp_get_sc_object $P7432, "1306916558.44963", 1
    $P7431."set_static_lexpad_value"("$?PACKAGE", $P7432)
    .const 'Sub' $P7433 = "13_1306916577.75068" 
    $P7434 = $P7433."get_lexinfo"()
    $P7434."finish_static_lexpad"()
    .const 'Sub' $P7435 = "13_1306916577.75068" 
    $P7436 = $P7435."get_lexinfo"()
    nqp_get_sc_object $P7437, "1306916558.44963", 1
    $P7436."set_static_lexpad_value"("$?CLASS", $P7437)
    .const 'Sub' $P7438 = "13_1306916577.75068" 
    $P7439 = $P7438."get_lexinfo"()
    $P7439."finish_static_lexpad"()
    nqp_get_sc_object $P7440, "1306916558.44963", 1
    get_how $P7441, $P7440
    nqp_get_sc_object $P7442, "1306916558.44963", 1
    nqp_get_sc_object $P7443, "1306916536.11825", 194
    $P7441."add_parent"($P7442, $P7443)
    nqp_get_sc_object $P7444, "1306916558.44963", 1
    get_how $P7445, $P7444
    nqp_get_sc_object $P7446, "1306916558.44963", 1
    $P7445."compose"($P7446)
    nqp_get_sc_object $P7447, "1306916525.99765", 41
    $P7448 = $P7447."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7448, cur_sc
    nqp_set_sc_object "1306916558.44963", 16, $P7448
    nqp_get_sc_object $P7449, "1306916558.44963", 16
    nqp_get_sc_object $P7450, "1306916558.44963", 0
    nqp_get_package_through_who $P7451, $P7450, "NQP"
    get_who $P7452, $P7451
    set $P7452["Grammar"], $P7449
    nqp_get_sc_object $P7453, "1306916558.44963", 16
    get_how $P7454, $P7453
    nqp_get_sc_object $P7455, "1306916558.44963", 16
    .const 'Sub' $P7456 = "41_1306916577.75068" 
    $P7454."add_method"($P7455, "TOP", $P7456)
    nqp_get_sc_object $P7457, "1306916558.44963", 16
    get_how $P7458, $P7457
    nqp_get_sc_object $P7459, "1306916558.44963", 16
    .const 'Sub' $P7460 = "42_1306916577.75068" 
    $P7458."add_method"($P7459, "identifier", $P7460)
    nqp_get_sc_object $P7461, "1306916558.44963", 16
    get_how $P7462, $P7461
    nqp_get_sc_object $P7463, "1306916558.44963", 16
    .const 'Sub' $P7464 = "43_1306916577.75068" 
    $P7462."add_method"($P7463, "!PREFIX__identifier", $P7464)
    nqp_get_sc_object $P7465, "1306916558.44963", 16
    get_how $P7466, $P7465
    nqp_get_sc_object $P7467, "1306916558.44963", 16
    .const 'Sub' $P7468 = "44_1306916577.75068" 
    $P7466."add_method"($P7467, "name", $P7468)
    nqp_get_sc_object $P7469, "1306916558.44963", 16
    get_how $P7470, $P7469
    nqp_get_sc_object $P7471, "1306916558.44963", 16
    .const 'Sub' $P7472 = "45_1306916577.75068" 
    $P7470."add_method"($P7471, "!PREFIX__name", $P7472)
    nqp_get_sc_object $P7473, "1306916558.44963", 16
    get_how $P7474, $P7473
    nqp_get_sc_object $P7475, "1306916558.44963", 16
    .const 'Sub' $P7476 = "46_1306916577.75068" 
    $P7474."add_method"($P7475, "deflongname", $P7476)
    nqp_get_sc_object $P7477, "1306916558.44963", 16
    get_how $P7478, $P7477
    nqp_get_sc_object $P7479, "1306916558.44963", 16
    .const 'Sub' $P7480 = "47_1306916577.75068" 
    $P7478."add_method"($P7479, "!PREFIX__deflongname", $P7480)
    nqp_get_sc_object $P7481, "1306916558.44963", 16
    get_how $P7482, $P7481
    nqp_get_sc_object $P7483, "1306916558.44963", 16
    .const 'Sub' $P7484 = "48_1306916577.75068" 
    $P7482."add_method"($P7483, "ENDSTMT", $P7484)
    nqp_get_sc_object $P7485, "1306916558.44963", 16
    get_how $P7486, $P7485
    nqp_get_sc_object $P7487, "1306916558.44963", 16
    .const 'Sub' $P7488 = "49_1306916577.75068" 
    $P7486."add_method"($P7487, "!PREFIX__ENDSTMT", $P7488)
    nqp_get_sc_object $P7489, "1306916558.44963", 16
    get_how $P7490, $P7489
    nqp_get_sc_object $P7491, "1306916558.44963", 16
    .const 'Sub' $P7492 = "50_1306916577.75068" 
    $P7490."add_method"($P7491, "ws", $P7492)
    nqp_get_sc_object $P7493, "1306916558.44963", 16
    get_how $P7494, $P7493
    nqp_get_sc_object $P7495, "1306916558.44963", 16
    .const 'Sub' $P7496 = "51_1306916577.75068" 
    $P7494."add_method"($P7495, "!PREFIX__ws", $P7496)
    nqp_get_sc_object $P7497, "1306916558.44963", 16
    get_how $P7498, $P7497
    nqp_get_sc_object $P7499, "1306916558.44963", 16
    .const 'Sub' $P7500 = "52_1306916577.75068" 
    $P7498."add_method"($P7499, "unv", $P7500)
    nqp_get_sc_object $P7501, "1306916558.44963", 16
    get_how $P7502, $P7501
    nqp_get_sc_object $P7503, "1306916558.44963", 16
    .const 'Sub' $P7504 = "54_1306916577.75068" 
    $P7502."add_method"($P7503, "!PREFIX__unv", $P7504)
    nqp_get_sc_object $P7505, "1306916558.44963", 16
    get_how $P7506, $P7505
    nqp_get_sc_object $P7507, "1306916558.44963", 16
    .const 'Sub' $P7508 = "55_1306916577.75068" 
    $P7506."add_method"($P7507, "pod_comment", $P7508)
    nqp_get_sc_object $P7509, "1306916558.44963", 16
    get_how $P7510, $P7509
    nqp_get_sc_object $P7511, "1306916558.44963", 16
    .const 'Sub' $P7512 = "57_1306916577.75068" 
    $P7510."add_method"($P7511, "!PREFIX__pod_comment", $P7512)
    nqp_get_sc_object $P7513, "1306916558.44963", 16
    get_how $P7514, $P7513
    nqp_get_sc_object $P7515, "1306916558.44963", 16
    .const 'Sub' $P7516 = "58_1306916577.75068" 
    $P7514."add_method"($P7515, "comp_unit", $P7516)
    nqp_get_sc_object $P7517, "1306916558.44963", 16
    get_how $P7518, $P7517
    nqp_get_sc_object $P7519, "1306916558.44963", 16
    .const 'Sub' $P7520 = "59_1306916577.75068" 
    $P7518."add_method"($P7519, "!PREFIX__comp_unit", $P7520)
    nqp_get_sc_object $P7521, "1306916558.44963", 16
    get_how $P7522, $P7521
    nqp_get_sc_object $P7523, "1306916558.44963", 16
    .const 'Sub' $P7524 = "60_1306916577.75068" 
    $P7522."add_method"($P7523, "statementlist", $P7524)
    nqp_get_sc_object $P7525, "1306916558.44963", 16
    get_how $P7526, $P7525
    nqp_get_sc_object $P7527, "1306916558.44963", 16
    .const 'Sub' $P7528 = "61_1306916577.75068" 
    $P7526."add_method"($P7527, "!PREFIX__statementlist", $P7528)
    nqp_get_sc_object $P7529, "1306916558.44963", 16
    get_how $P7530, $P7529
    nqp_get_sc_object $P7531, "1306916558.44963", 16
    .const 'Sub' $P7532 = "62_1306916577.75068" 
    $P7530."add_method"($P7531, "statement", $P7532)
    nqp_get_sc_object $P7533, "1306916558.44963", 16
    get_how $P7534, $P7533
    nqp_get_sc_object $P7535, "1306916558.44963", 16
    .const 'Sub' $P7536 = "64_1306916577.75068" 
    $P7534."add_method"($P7535, "!PREFIX__statement", $P7536)
    nqp_get_sc_object $P7537, "1306916558.44963", 16
    get_how $P7538, $P7537
    nqp_get_sc_object $P7539, "1306916558.44963", 16
    .const 'Sub' $P7540 = "65_1306916577.75068" 
    $P7538."add_method"($P7539, "eat_terminator", $P7540)
    nqp_get_sc_object $P7541, "1306916558.44963", 16
    get_how $P7542, $P7541
    nqp_get_sc_object $P7543, "1306916558.44963", 16
    .const 'Sub' $P7544 = "66_1306916577.75068" 
    $P7542."add_method"($P7543, "!PREFIX__eat_terminator", $P7544)
    nqp_get_sc_object $P7545, "1306916558.44963", 16
    get_how $P7546, $P7545
    nqp_get_sc_object $P7547, "1306916558.44963", 16
    .const 'Sub' $P7548 = "67_1306916577.75068" 
    $P7546."add_method"($P7547, "xblock", $P7548)
    nqp_get_sc_object $P7549, "1306916558.44963", 16
    get_how $P7550, $P7549
    nqp_get_sc_object $P7551, "1306916558.44963", 16
    .const 'Sub' $P7552 = "68_1306916577.75068" 
    $P7550."add_method"($P7551, "!PREFIX__xblock", $P7552)
    nqp_get_sc_object $P7553, "1306916558.44963", 16
    get_how $P7554, $P7553
    nqp_get_sc_object $P7555, "1306916558.44963", 16
    .const 'Sub' $P7556 = "69_1306916577.75068" 
    $P7554."add_method"($P7555, "pblock", $P7556)
    nqp_get_sc_object $P7557, "1306916558.44963", 16
    get_how $P7558, $P7557
    nqp_get_sc_object $P7559, "1306916558.44963", 16
    .const 'Sub' $P7560 = "70_1306916577.75068" 
    $P7558."add_method"($P7559, "!PREFIX__pblock", $P7560)
    nqp_get_sc_object $P7561, "1306916558.44963", 16
    get_how $P7562, $P7561
    nqp_get_sc_object $P7563, "1306916558.44963", 16
    .const 'Sub' $P7564 = "71_1306916577.75068" 
    $P7562."add_method"($P7563, "lambda", $P7564)
    nqp_get_sc_object $P7565, "1306916558.44963", 16
    get_how $P7566, $P7565
    nqp_get_sc_object $P7567, "1306916558.44963", 16
    .const 'Sub' $P7568 = "72_1306916577.75068" 
    $P7566."add_method"($P7567, "!PREFIX__lambda", $P7568)
    nqp_get_sc_object $P7569, "1306916558.44963", 16
    get_how $P7570, $P7569
    nqp_get_sc_object $P7571, "1306916558.44963", 16
    .const 'Sub' $P7572 = "73_1306916577.75068" 
    $P7570."add_method"($P7571, "block", $P7572)
    nqp_get_sc_object $P7573, "1306916558.44963", 16
    get_how $P7574, $P7573
    nqp_get_sc_object $P7575, "1306916558.44963", 16
    .const 'Sub' $P7576 = "74_1306916577.75068" 
    $P7574."add_method"($P7575, "!PREFIX__block", $P7576)
    nqp_get_sc_object $P7577, "1306916558.44963", 16
    get_how $P7578, $P7577
    nqp_get_sc_object $P7579, "1306916558.44963", 16
    .const 'Sub' $P7580 = "75_1306916577.75068" 
    $P7578."add_method"($P7579, "blockoid", $P7580)
    nqp_get_sc_object $P7581, "1306916558.44963", 16
    get_how $P7582, $P7581
    nqp_get_sc_object $P7583, "1306916558.44963", 16
    .const 'Sub' $P7584 = "76_1306916577.75068" 
    $P7582."add_method"($P7583, "!PREFIX__blockoid", $P7584)
    nqp_get_sc_object $P7585, "1306916558.44963", 16
    get_how $P7586, $P7585
    nqp_get_sc_object $P7587, "1306916558.44963", 16
    .const 'Sub' $P7588 = "77_1306916577.75068" 
    $P7586."add_method"($P7587, "newpad", $P7588)
    nqp_get_sc_object $P7589, "1306916558.44963", 16
    get_how $P7590, $P7589
    nqp_get_sc_object $P7591, "1306916558.44963", 16
    .const 'Sub' $P7592 = "78_1306916577.75068" 
    $P7590."add_method"($P7591, "!PREFIX__newpad", $P7592)
    nqp_get_sc_object $P7593, "1306916558.44963", 16
    get_how $P7594, $P7593
    nqp_get_sc_object $P7595, "1306916558.44963", 16
    .const 'Sub' $P7596 = "79_1306916577.75068" 
    $P7594."add_method"($P7595, "outerctx", $P7596)
    nqp_get_sc_object $P7597, "1306916558.44963", 16
    get_how $P7598, $P7597
    nqp_get_sc_object $P7599, "1306916558.44963", 16
    .const 'Sub' $P7600 = "80_1306916577.75068" 
    $P7598."add_method"($P7599, "!PREFIX__outerctx", $P7600)
    nqp_get_sc_object $P7601, "1306916558.44963", 16
    get_how $P7602, $P7601
    nqp_get_sc_object $P7603, "1306916558.44963", 16
    .const 'Sub' $P7604 = "81_1306916577.75068" 
    $P7602."add_method"($P7603, "GLOBALish", $P7604)
    nqp_get_sc_object $P7605, "1306916558.44963", 16
    get_how $P7606, $P7605
    nqp_get_sc_object $P7607, "1306916558.44963", 16
    .const 'Sub' $P7608 = "82_1306916577.75068" 
    $P7606."add_method"($P7607, "!PREFIX__GLOBALish", $P7608)
    nqp_get_sc_object $P7609, "1306916558.44963", 16
    get_how $P7610, $P7609
    nqp_get_sc_object $P7611, "1306916558.44963", 16
    .const 'Sub' $P7612 = "83_1306916577.75068" 
    $P7610."add_method"($P7611, "finishpad", $P7612)
    nqp_get_sc_object $P7613, "1306916558.44963", 16
    get_how $P7614, $P7613
    nqp_get_sc_object $P7615, "1306916558.44963", 16
    .const 'Sub' $P7616 = "84_1306916577.75068" 
    $P7614."add_method"($P7615, "!PREFIX__finishpad", $P7616)
    nqp_get_sc_object $P7617, "1306916558.44963", 16
    get_how $P7618, $P7617
    nqp_get_sc_object $P7619, "1306916558.44963", 16
    .const 'Sub' $P7620 = "85_1306916577.75068" 
    $P7618."add_method"($P7619, "you_are_here", $P7620)
    nqp_get_sc_object $P7621, "1306916558.44963", 16
    get_how $P7622, $P7621
    nqp_get_sc_object $P7623, "1306916558.44963", 16
    .const 'Sub' $P7624 = "86_1306916577.75068" 
    $P7622."add_method"($P7623, "!PREFIX__you_are_here", $P7624)
    nqp_get_sc_object $P7625, "1306916558.44963", 16
    get_how $P7626, $P7625
    nqp_get_sc_object $P7627, "1306916558.44963", 16
    .const 'Sub' $P7628 = "87_1306916577.75068" 
    $P7626."add_method"($P7627, "terminator", $P7628)
    nqp_get_sc_object $P7629, "1306916558.44963", 16
    get_how $P7630, $P7629
    nqp_get_sc_object $P7631, "1306916558.44963", 16
    .const 'Sub' $P7632 = "88_1306916577.75068" 
    $P7630."add_method"($P7631, "!PREFIX__terminator", $P7632)
    nqp_get_sc_object $P7633, "1306916558.44963", 16
    get_how $P7634, $P7633
    nqp_get_sc_object $P7635, "1306916558.44963", 16
    .const 'Sub' $P7636 = "89_1306916577.75068" 
    $P7634."add_method"($P7635, "terminator:sym<;>", $P7636)
    nqp_get_sc_object $P7637, "1306916558.44963", 16
    get_how $P7638, $P7637
    nqp_get_sc_object $P7639, "1306916558.44963", 16
    .const 'Sub' $P7640 = "90_1306916577.75068" 
    $P7638."add_method"($P7639, "!PREFIX__terminator:sym<;>", $P7640)
    nqp_get_sc_object $P7641, "1306916558.44963", 16
    get_how $P7642, $P7641
    nqp_get_sc_object $P7643, "1306916558.44963", 16
    .const 'Sub' $P7644 = "91_1306916577.75068" 
    $P7642."add_method"($P7643, "terminator:sym<}>", $P7644)
    nqp_get_sc_object $P7645, "1306916558.44963", 16
    get_how $P7646, $P7645
    nqp_get_sc_object $P7647, "1306916558.44963", 16
    .const 'Sub' $P7648 = "92_1306916577.75068" 
    $P7646."add_method"($P7647, "!PREFIX__terminator:sym<}>", $P7648)
    nqp_get_sc_object $P7649, "1306916558.44963", 16
    get_how $P7650, $P7649
    nqp_get_sc_object $P7651, "1306916558.44963", 16
    .const 'Sub' $P7652 = "93_1306916577.75068" 
    $P7650."add_method"($P7651, "statement_control", $P7652)
    nqp_get_sc_object $P7653, "1306916558.44963", 16
    get_how $P7654, $P7653
    nqp_get_sc_object $P7655, "1306916558.44963", 16
    .const 'Sub' $P7656 = "94_1306916577.75068" 
    $P7654."add_method"($P7655, "!PREFIX__statement_control", $P7656)
    nqp_get_sc_object $P7657, "1306916558.44963", 16
    get_how $P7658, $P7657
    nqp_get_sc_object $P7659, "1306916558.44963", 16
    .const 'Sub' $P7660 = "95_1306916577.75068" 
    $P7658."add_method"($P7659, "statement_control:sym<use>", $P7660)
    nqp_get_sc_object $P7661, "1306916558.44963", 16
    get_how $P7662, $P7661
    nqp_get_sc_object $P7663, "1306916558.44963", 16
    .const 'Sub' $P7664 = "96_1306916577.75068" 
    $P7662."add_method"($P7663, "!PREFIX__statement_control:sym<use>", $P7664)
    nqp_get_sc_object $P7665, "1306916558.44963", 16
    get_how $P7666, $P7665
    nqp_get_sc_object $P7667, "1306916558.44963", 16
    .const 'Sub' $P7668 = "97_1306916577.75068" 
    $P7666."add_method"($P7667, "statement_control:sym<if>", $P7668)
    nqp_get_sc_object $P7669, "1306916558.44963", 16
    get_how $P7670, $P7669
    nqp_get_sc_object $P7671, "1306916558.44963", 16
    .const 'Sub' $P7672 = "98_1306916577.75068" 
    $P7670."add_method"($P7671, "!PREFIX__statement_control:sym<if>", $P7672)
    nqp_get_sc_object $P7673, "1306916558.44963", 16
    get_how $P7674, $P7673
    nqp_get_sc_object $P7675, "1306916558.44963", 16
    .const 'Sub' $P7676 = "99_1306916577.75068" 
    $P7674."add_method"($P7675, "statement_control:sym<unless>", $P7676)
    nqp_get_sc_object $P7677, "1306916558.44963", 16
    get_how $P7678, $P7677
    nqp_get_sc_object $P7679, "1306916558.44963", 16
    .const 'Sub' $P7680 = "101_1306916577.75068" 
    $P7678."add_method"($P7679, "!PREFIX__statement_control:sym<unless>", $P7680)
    nqp_get_sc_object $P7681, "1306916558.44963", 16
    get_how $P7682, $P7681
    nqp_get_sc_object $P7683, "1306916558.44963", 16
    .const 'Sub' $P7684 = "102_1306916577.75068" 
    $P7682."add_method"($P7683, "statement_control:sym<while>", $P7684)
    nqp_get_sc_object $P7685, "1306916558.44963", 16
    get_how $P7686, $P7685
    nqp_get_sc_object $P7687, "1306916558.44963", 16
    .const 'Sub' $P7688 = "103_1306916577.75068" 
    $P7686."add_method"($P7687, "!PREFIX__statement_control:sym<while>", $P7688)
    nqp_get_sc_object $P7689, "1306916558.44963", 16
    get_how $P7690, $P7689
    nqp_get_sc_object $P7691, "1306916558.44963", 16
    .const 'Sub' $P7692 = "104_1306916577.75068" 
    $P7690."add_method"($P7691, "statement_control:sym<repeat>", $P7692)
    nqp_get_sc_object $P7693, "1306916558.44963", 16
    get_how $P7694, $P7693
    nqp_get_sc_object $P7695, "1306916558.44963", 16
    .const 'Sub' $P7696 = "105_1306916577.75068" 
    $P7694."add_method"($P7695, "!PREFIX__statement_control:sym<repeat>", $P7696)
    nqp_get_sc_object $P7697, "1306916558.44963", 16
    get_how $P7698, $P7697
    nqp_get_sc_object $P7699, "1306916558.44963", 16
    .const 'Sub' $P7700 = "106_1306916577.75068" 
    $P7698."add_method"($P7699, "statement_control:sym<for>", $P7700)
    nqp_get_sc_object $P7701, "1306916558.44963", 16
    get_how $P7702, $P7701
    nqp_get_sc_object $P7703, "1306916558.44963", 16
    .const 'Sub' $P7704 = "107_1306916577.75068" 
    $P7702."add_method"($P7703, "!PREFIX__statement_control:sym<for>", $P7704)
    nqp_get_sc_object $P7705, "1306916558.44963", 16
    get_how $P7706, $P7705
    nqp_get_sc_object $P7707, "1306916558.44963", 16
    .const 'Sub' $P7708 = "108_1306916577.75068" 
    $P7706."add_method"($P7707, "statement_control:sym<CATCH>", $P7708)
    nqp_get_sc_object $P7709, "1306916558.44963", 16
    get_how $P7710, $P7709
    nqp_get_sc_object $P7711, "1306916558.44963", 16
    .const 'Sub' $P7712 = "109_1306916577.75068" 
    $P7710."add_method"($P7711, "!PREFIX__statement_control:sym<CATCH>", $P7712)
    nqp_get_sc_object $P7713, "1306916558.44963", 16
    get_how $P7714, $P7713
    nqp_get_sc_object $P7715, "1306916558.44963", 16
    .const 'Sub' $P7716 = "110_1306916577.75068" 
    $P7714."add_method"($P7715, "statement_control:sym<CONTROL>", $P7716)
    nqp_get_sc_object $P7717, "1306916558.44963", 16
    get_how $P7718, $P7717
    nqp_get_sc_object $P7719, "1306916558.44963", 16
    .const 'Sub' $P7720 = "111_1306916577.75068" 
    $P7718."add_method"($P7719, "!PREFIX__statement_control:sym<CONTROL>", $P7720)
    nqp_get_sc_object $P7721, "1306916558.44963", 16
    get_how $P7722, $P7721
    nqp_get_sc_object $P7723, "1306916558.44963", 16
    .const 'Sub' $P7724 = "112_1306916577.75068" 
    $P7722."add_method"($P7723, "statement_prefix", $P7724)
    nqp_get_sc_object $P7725, "1306916558.44963", 16
    get_how $P7726, $P7725
    nqp_get_sc_object $P7727, "1306916558.44963", 16
    .const 'Sub' $P7728 = "113_1306916577.75068" 
    $P7726."add_method"($P7727, "!PREFIX__statement_prefix", $P7728)
    nqp_get_sc_object $P7729, "1306916558.44963", 16
    get_how $P7730, $P7729
    nqp_get_sc_object $P7731, "1306916558.44963", 16
    .const 'Sub' $P7732 = "114_1306916577.75068" 
    $P7730."add_method"($P7731, "statement_prefix:sym<INIT>", $P7732)
    nqp_get_sc_object $P7733, "1306916558.44963", 16
    get_how $P7734, $P7733
    nqp_get_sc_object $P7735, "1306916558.44963", 16
    .const 'Sub' $P7736 = "115_1306916577.75068" 
    $P7734."add_method"($P7735, "!PREFIX__statement_prefix:sym<INIT>", $P7736)
    nqp_get_sc_object $P7737, "1306916558.44963", 16
    get_how $P7738, $P7737
    nqp_get_sc_object $P7739, "1306916558.44963", 16
    .const 'Sub' $P7740 = "116_1306916577.75068" 
    $P7738."add_method"($P7739, "statement_prefix:sym<try>", $P7740)
    nqp_get_sc_object $P7741, "1306916558.44963", 16
    get_how $P7742, $P7741
    nqp_get_sc_object $P7743, "1306916558.44963", 16
    .const 'Sub' $P7744 = "117_1306916577.75068" 
    $P7742."add_method"($P7743, "!PREFIX__statement_prefix:sym<try>", $P7744)
    nqp_get_sc_object $P7745, "1306916558.44963", 16
    get_how $P7746, $P7745
    nqp_get_sc_object $P7747, "1306916558.44963", 16
    .const 'Sub' $P7748 = "118_1306916577.75068" 
    $P7746."add_method"($P7747, "blorst", $P7748)
    nqp_get_sc_object $P7749, "1306916558.44963", 16
    get_how $P7750, $P7749
    nqp_get_sc_object $P7751, "1306916558.44963", 16
    .const 'Sub' $P7752 = "119_1306916577.75068" 
    $P7750."add_method"($P7751, "!PREFIX__blorst", $P7752)
    nqp_get_sc_object $P7753, "1306916558.44963", 16
    get_how $P7754, $P7753
    nqp_get_sc_object $P7755, "1306916558.44963", 16
    .const 'Sub' $P7756 = "120_1306916577.75068" 
    $P7754."add_method"($P7755, "statement_mod_cond", $P7756)
    nqp_get_sc_object $P7757, "1306916558.44963", 16
    get_how $P7758, $P7757
    nqp_get_sc_object $P7759, "1306916558.44963", 16
    .const 'Sub' $P7760 = "121_1306916577.75068" 
    $P7758."add_method"($P7759, "!PREFIX__statement_mod_cond", $P7760)
    nqp_get_sc_object $P7761, "1306916558.44963", 16
    get_how $P7762, $P7761
    nqp_get_sc_object $P7763, "1306916558.44963", 16
    .const 'Sub' $P7764 = "122_1306916577.75068" 
    $P7762."add_method"($P7763, "statement_mod_cond:sym<if>", $P7764)
    nqp_get_sc_object $P7765, "1306916558.44963", 16
    get_how $P7766, $P7765
    nqp_get_sc_object $P7767, "1306916558.44963", 16
    .const 'Sub' $P7768 = "123_1306916577.75068" 
    $P7766."add_method"($P7767, "!PREFIX__statement_mod_cond:sym<if>", $P7768)
    nqp_get_sc_object $P7769, "1306916558.44963", 16
    get_how $P7770, $P7769
    nqp_get_sc_object $P7771, "1306916558.44963", 16
    .const 'Sub' $P7772 = "124_1306916577.75068" 
    $P7770."add_method"($P7771, "statement_mod_cond:sym<unless>", $P7772)
    nqp_get_sc_object $P7773, "1306916558.44963", 16
    get_how $P7774, $P7773
    nqp_get_sc_object $P7775, "1306916558.44963", 16
    .const 'Sub' $P7776 = "125_1306916577.75068" 
    $P7774."add_method"($P7775, "!PREFIX__statement_mod_cond:sym<unless>", $P7776)
    nqp_get_sc_object $P7777, "1306916558.44963", 16
    get_how $P7778, $P7777
    nqp_get_sc_object $P7779, "1306916558.44963", 16
    .const 'Sub' $P7780 = "126_1306916577.75068" 
    $P7778."add_method"($P7779, "statement_mod_loop", $P7780)
    nqp_get_sc_object $P7781, "1306916558.44963", 16
    get_how $P7782, $P7781
    nqp_get_sc_object $P7783, "1306916558.44963", 16
    .const 'Sub' $P7784 = "127_1306916577.75068" 
    $P7782."add_method"($P7783, "!PREFIX__statement_mod_loop", $P7784)
    nqp_get_sc_object $P7785, "1306916558.44963", 16
    get_how $P7786, $P7785
    nqp_get_sc_object $P7787, "1306916558.44963", 16
    .const 'Sub' $P7788 = "128_1306916577.75068" 
    $P7786."add_method"($P7787, "statement_mod_loop:sym<while>", $P7788)
    nqp_get_sc_object $P7789, "1306916558.44963", 16
    get_how $P7790, $P7789
    nqp_get_sc_object $P7791, "1306916558.44963", 16
    .const 'Sub' $P7792 = "129_1306916577.75068" 
    $P7790."add_method"($P7791, "!PREFIX__statement_mod_loop:sym<while>", $P7792)
    nqp_get_sc_object $P7793, "1306916558.44963", 16
    get_how $P7794, $P7793
    nqp_get_sc_object $P7795, "1306916558.44963", 16
    .const 'Sub' $P7796 = "130_1306916577.75068" 
    $P7794."add_method"($P7795, "statement_mod_loop:sym<until>", $P7796)
    nqp_get_sc_object $P7797, "1306916558.44963", 16
    get_how $P7798, $P7797
    nqp_get_sc_object $P7799, "1306916558.44963", 16
    .const 'Sub' $P7800 = "131_1306916577.75068" 
    $P7798."add_method"($P7799, "!PREFIX__statement_mod_loop:sym<until>", $P7800)
    nqp_get_sc_object $P7801, "1306916558.44963", 16
    get_how $P7802, $P7801
    nqp_get_sc_object $P7803, "1306916558.44963", 16
    .const 'Sub' $P7804 = "132_1306916577.75068" 
    $P7802."add_method"($P7803, "statement_mod_loop:sym<for>", $P7804)
    nqp_get_sc_object $P7805, "1306916558.44963", 16
    get_how $P7806, $P7805
    nqp_get_sc_object $P7807, "1306916558.44963", 16
    .const 'Sub' $P7808 = "133_1306916577.75068" 
    $P7806."add_method"($P7807, "!PREFIX__statement_mod_loop:sym<for>", $P7808)
    nqp_get_sc_object $P7809, "1306916558.44963", 16
    get_how $P7810, $P7809
    nqp_get_sc_object $P7811, "1306916558.44963", 16
    .const 'Sub' $P7812 = "134_1306916577.75068" 
    $P7810."add_method"($P7811, "term:sym<fatarrow>", $P7812)
    nqp_get_sc_object $P7813, "1306916558.44963", 16
    get_how $P7814, $P7813
    nqp_get_sc_object $P7815, "1306916558.44963", 16
    .const 'Sub' $P7816 = "135_1306916577.75068" 
    $P7814."add_method"($P7815, "!PREFIX__term:sym<fatarrow>", $P7816)
    nqp_get_sc_object $P7817, "1306916558.44963", 16
    get_how $P7818, $P7817
    nqp_get_sc_object $P7819, "1306916558.44963", 16
    .const 'Sub' $P7820 = "136_1306916577.75068" 
    $P7818."add_method"($P7819, "term:sym<colonpair>", $P7820)
    nqp_get_sc_object $P7821, "1306916558.44963", 16
    get_how $P7822, $P7821
    nqp_get_sc_object $P7823, "1306916558.44963", 16
    .const 'Sub' $P7824 = "137_1306916577.75068" 
    $P7822."add_method"($P7823, "!PREFIX__term:sym<colonpair>", $P7824)
    nqp_get_sc_object $P7825, "1306916558.44963", 16
    get_how $P7826, $P7825
    nqp_get_sc_object $P7827, "1306916558.44963", 16
    .const 'Sub' $P7828 = "138_1306916577.75068" 
    $P7826."add_method"($P7827, "term:sym<variable>", $P7828)
    nqp_get_sc_object $P7829, "1306916558.44963", 16
    get_how $P7830, $P7829
    nqp_get_sc_object $P7831, "1306916558.44963", 16
    .const 'Sub' $P7832 = "139_1306916577.75068" 
    $P7830."add_method"($P7831, "!PREFIX__term:sym<variable>", $P7832)
    nqp_get_sc_object $P7833, "1306916558.44963", 16
    get_how $P7834, $P7833
    nqp_get_sc_object $P7835, "1306916558.44963", 16
    .const 'Sub' $P7836 = "140_1306916577.75068" 
    $P7834."add_method"($P7835, "term:sym<package_declarator>", $P7836)
    nqp_get_sc_object $P7837, "1306916558.44963", 16
    get_how $P7838, $P7837
    nqp_get_sc_object $P7839, "1306916558.44963", 16
    .const 'Sub' $P7840 = "141_1306916577.75068" 
    $P7838."add_method"($P7839, "!PREFIX__term:sym<package_declarator>", $P7840)
    nqp_get_sc_object $P7841, "1306916558.44963", 16
    get_how $P7842, $P7841
    nqp_get_sc_object $P7843, "1306916558.44963", 16
    .const 'Sub' $P7844 = "142_1306916577.75068" 
    $P7842."add_method"($P7843, "term:sym<scope_declarator>", $P7844)
    nqp_get_sc_object $P7845, "1306916558.44963", 16
    get_how $P7846, $P7845
    nqp_get_sc_object $P7847, "1306916558.44963", 16
    .const 'Sub' $P7848 = "143_1306916577.75068" 
    $P7846."add_method"($P7847, "!PREFIX__term:sym<scope_declarator>", $P7848)
    nqp_get_sc_object $P7849, "1306916558.44963", 16
    get_how $P7850, $P7849
    nqp_get_sc_object $P7851, "1306916558.44963", 16
    .const 'Sub' $P7852 = "144_1306916577.75068" 
    $P7850."add_method"($P7851, "term:sym<routine_declarator>", $P7852)
    nqp_get_sc_object $P7853, "1306916558.44963", 16
    get_how $P7854, $P7853
    nqp_get_sc_object $P7855, "1306916558.44963", 16
    .const 'Sub' $P7856 = "145_1306916577.75068" 
    $P7854."add_method"($P7855, "!PREFIX__term:sym<routine_declarator>", $P7856)
    nqp_get_sc_object $P7857, "1306916558.44963", 16
    get_how $P7858, $P7857
    nqp_get_sc_object $P7859, "1306916558.44963", 16
    .const 'Sub' $P7860 = "146_1306916577.75068" 
    $P7858."add_method"($P7859, "term:sym<multi_declarator>", $P7860)
    nqp_get_sc_object $P7861, "1306916558.44963", 16
    get_how $P7862, $P7861
    nqp_get_sc_object $P7863, "1306916558.44963", 16
    .const 'Sub' $P7864 = "149_1306916577.75068" 
    $P7862."add_method"($P7863, "!PREFIX__term:sym<multi_declarator>", $P7864)
    nqp_get_sc_object $P7865, "1306916558.44963", 16
    get_how $P7866, $P7865
    nqp_get_sc_object $P7867, "1306916558.44963", 16
    .const 'Sub' $P7868 = "150_1306916577.75068" 
    $P7866."add_method"($P7867, "term:sym<regex_declarator>", $P7868)
    nqp_get_sc_object $P7869, "1306916558.44963", 16
    get_how $P7870, $P7869
    nqp_get_sc_object $P7871, "1306916558.44963", 16
    .const 'Sub' $P7872 = "151_1306916577.75068" 
    $P7870."add_method"($P7871, "!PREFIX__term:sym<regex_declarator>", $P7872)
    nqp_get_sc_object $P7873, "1306916558.44963", 16
    get_how $P7874, $P7873
    nqp_get_sc_object $P7875, "1306916558.44963", 16
    .const 'Sub' $P7876 = "152_1306916577.75068" 
    $P7874."add_method"($P7875, "term:sym<statement_prefix>", $P7876)
    nqp_get_sc_object $P7877, "1306916558.44963", 16
    get_how $P7878, $P7877
    nqp_get_sc_object $P7879, "1306916558.44963", 16
    .const 'Sub' $P7880 = "153_1306916577.75068" 
    $P7878."add_method"($P7879, "!PREFIX__term:sym<statement_prefix>", $P7880)
    nqp_get_sc_object $P7881, "1306916558.44963", 16
    get_how $P7882, $P7881
    nqp_get_sc_object $P7883, "1306916558.44963", 16
    .const 'Sub' $P7884 = "154_1306916577.75068" 
    $P7882."add_method"($P7883, "term:sym<lambda>", $P7884)
    nqp_get_sc_object $P7885, "1306916558.44963", 16
    get_how $P7886, $P7885
    nqp_get_sc_object $P7887, "1306916558.44963", 16
    .const 'Sub' $P7888 = "155_1306916577.75068" 
    $P7886."add_method"($P7887, "!PREFIX__term:sym<lambda>", $P7888)
    nqp_get_sc_object $P7889, "1306916558.44963", 16
    get_how $P7890, $P7889
    nqp_get_sc_object $P7891, "1306916558.44963", 16
    .const 'Sub' $P7892 = "156_1306916577.75068" 
    $P7890."add_method"($P7891, "fatarrow", $P7892)
    nqp_get_sc_object $P7893, "1306916558.44963", 16
    get_how $P7894, $P7893
    nqp_get_sc_object $P7895, "1306916558.44963", 16
    .const 'Sub' $P7896 = "157_1306916577.75068" 
    $P7894."add_method"($P7895, "!PREFIX__fatarrow", $P7896)
    nqp_get_sc_object $P7897, "1306916558.44963", 16
    get_how $P7898, $P7897
    nqp_get_sc_object $P7899, "1306916558.44963", 16
    .const 'Sub' $P7900 = "158_1306916577.75068" 
    $P7898."add_method"($P7899, "colonpair", $P7900)
    nqp_get_sc_object $P7901, "1306916558.44963", 16
    get_how $P7902, $P7901
    nqp_get_sc_object $P7903, "1306916558.44963", 16
    .const 'Sub' $P7904 = "159_1306916577.75068" 
    $P7902."add_method"($P7903, "!PREFIX__colonpair", $P7904)
    nqp_get_sc_object $P7905, "1306916558.44963", 16
    get_how $P7906, $P7905
    nqp_get_sc_object $P7907, "1306916558.44963", 16
    .const 'Sub' $P7908 = "160_1306916577.75068" 
    $P7906."add_method"($P7907, "variable", $P7908)
    nqp_get_sc_object $P7909, "1306916558.44963", 16
    get_how $P7910, $P7909
    nqp_get_sc_object $P7911, "1306916558.44963", 16
    .const 'Sub' $P7912 = "161_1306916577.75068" 
    $P7910."add_method"($P7911, "!PREFIX__variable", $P7912)
    nqp_get_sc_object $P7913, "1306916558.44963", 16
    get_how $P7914, $P7913
    nqp_get_sc_object $P7915, "1306916558.44963", 16
    .const 'Sub' $P7916 = "162_1306916577.75068" 
    $P7914."add_method"($P7915, "sigil", $P7916)
    nqp_get_sc_object $P7917, "1306916558.44963", 16
    get_how $P7918, $P7917
    nqp_get_sc_object $P7919, "1306916558.44963", 16
    .const 'Sub' $P7920 = "163_1306916577.75068" 
    $P7918."add_method"($P7919, "!PREFIX__sigil", $P7920)
    nqp_get_sc_object $P7921, "1306916558.44963", 16
    get_how $P7922, $P7921
    nqp_get_sc_object $P7923, "1306916558.44963", 16
    .const 'Sub' $P7924 = "164_1306916577.75068" 
    $P7922."add_method"($P7923, "twigil", $P7924)
    nqp_get_sc_object $P7925, "1306916558.44963", 16
    get_how $P7926, $P7925
    nqp_get_sc_object $P7927, "1306916558.44963", 16
    .const 'Sub' $P7928 = "165_1306916577.75068" 
    $P7926."add_method"($P7927, "!PREFIX__twigil", $P7928)
    nqp_get_sc_object $P7929, "1306916558.44963", 16
    get_how $P7930, $P7929
    nqp_get_sc_object $P7931, "1306916558.44963", 16
    .const 'Sub' $P7932 = "166_1306916577.75068" 
    $P7930."add_method"($P7931, "package_declarator", $P7932)
    nqp_get_sc_object $P7933, "1306916558.44963", 16
    get_how $P7934, $P7933
    nqp_get_sc_object $P7935, "1306916558.44963", 16
    .const 'Sub' $P7936 = "167_1306916577.75068" 
    $P7934."add_method"($P7935, "!PREFIX__package_declarator", $P7936)
    nqp_get_sc_object $P7937, "1306916558.44963", 16
    get_how $P7938, $P7937
    nqp_get_sc_object $P7939, "1306916558.44963", 16
    .const 'Sub' $P7940 = "168_1306916577.75068" 
    $P7938."add_method"($P7939, "package_declarator:sym<module>", $P7940)
    nqp_get_sc_object $P7941, "1306916558.44963", 16
    get_how $P7942, $P7941
    nqp_get_sc_object $P7943, "1306916558.44963", 16
    .const 'Sub' $P7944 = "169_1306916577.75068" 
    $P7942."add_method"($P7943, "!PREFIX__package_declarator:sym<module>", $P7944)
    nqp_get_sc_object $P7945, "1306916558.44963", 16
    get_how $P7946, $P7945
    nqp_get_sc_object $P7947, "1306916558.44963", 16
    .const 'Sub' $P7948 = "170_1306916577.75068" 
    $P7946."add_method"($P7947, "package_declarator:sym<knowhow>", $P7948)
    nqp_get_sc_object $P7949, "1306916558.44963", 16
    get_how $P7950, $P7949
    nqp_get_sc_object $P7951, "1306916558.44963", 16
    .const 'Sub' $P7952 = "171_1306916577.75068" 
    $P7950."add_method"($P7951, "!PREFIX__package_declarator:sym<knowhow>", $P7952)
    nqp_get_sc_object $P7953, "1306916558.44963", 16
    get_how $P7954, $P7953
    nqp_get_sc_object $P7955, "1306916558.44963", 16
    .const 'Sub' $P7956 = "172_1306916577.75068" 
    $P7954."add_method"($P7955, "package_declarator:sym<class>", $P7956)
    nqp_get_sc_object $P7957, "1306916558.44963", 16
    get_how $P7958, $P7957
    nqp_get_sc_object $P7959, "1306916558.44963", 16
    .const 'Sub' $P7960 = "173_1306916577.75068" 
    $P7958."add_method"($P7959, "!PREFIX__package_declarator:sym<class>", $P7960)
    nqp_get_sc_object $P7961, "1306916558.44963", 16
    get_how $P7962, $P7961
    nqp_get_sc_object $P7963, "1306916558.44963", 16
    .const 'Sub' $P7964 = "174_1306916577.75068" 
    $P7962."add_method"($P7963, "package_declarator:sym<grammar>", $P7964)
    nqp_get_sc_object $P7965, "1306916558.44963", 16
    get_how $P7966, $P7965
    nqp_get_sc_object $P7967, "1306916558.44963", 16
    .const 'Sub' $P7968 = "175_1306916577.75068" 
    $P7966."add_method"($P7967, "!PREFIX__package_declarator:sym<grammar>", $P7968)
    nqp_get_sc_object $P7969, "1306916558.44963", 16
    get_how $P7970, $P7969
    nqp_get_sc_object $P7971, "1306916558.44963", 16
    .const 'Sub' $P7972 = "176_1306916577.75068" 
    $P7970."add_method"($P7971, "package_declarator:sym<role>", $P7972)
    nqp_get_sc_object $P7973, "1306916558.44963", 16
    get_how $P7974, $P7973
    nqp_get_sc_object $P7975, "1306916558.44963", 16
    .const 'Sub' $P7976 = "177_1306916577.75068" 
    $P7974."add_method"($P7975, "!PREFIX__package_declarator:sym<role>", $P7976)
    nqp_get_sc_object $P7977, "1306916558.44963", 16
    get_how $P7978, $P7977
    nqp_get_sc_object $P7979, "1306916558.44963", 16
    .const 'Sub' $P7980 = "178_1306916577.75068" 
    $P7978."add_method"($P7979, "package_declarator:sym<native>", $P7980)
    nqp_get_sc_object $P7981, "1306916558.44963", 16
    get_how $P7982, $P7981
    nqp_get_sc_object $P7983, "1306916558.44963", 16
    .const 'Sub' $P7984 = "179_1306916577.75068" 
    $P7982."add_method"($P7983, "!PREFIX__package_declarator:sym<native>", $P7984)
    nqp_get_sc_object $P7985, "1306916558.44963", 16
    get_how $P7986, $P7985
    nqp_get_sc_object $P7987, "1306916558.44963", 16
    .const 'Sub' $P7988 = "180_1306916577.75068" 
    $P7986."add_method"($P7987, "package_declarator:sym<stub>", $P7988)
    nqp_get_sc_object $P7989, "1306916558.44963", 16
    get_how $P7990, $P7989
    nqp_get_sc_object $P7991, "1306916558.44963", 16
    .const 'Sub' $P7992 = "181_1306916577.75068" 
    $P7990."add_method"($P7991, "!PREFIX__package_declarator:sym<stub>", $P7992)
    nqp_get_sc_object $P7993, "1306916558.44963", 16
    get_how $P7994, $P7993
    nqp_get_sc_object $P7995, "1306916558.44963", 16
    .const 'Sub' $P7996 = "182_1306916577.75068" 
    $P7994."add_method"($P7995, "package_def", $P7996)
    nqp_get_sc_object $P7997, "1306916558.44963", 16
    get_how $P7998, $P7997
    nqp_get_sc_object $P7999, "1306916558.44963", 16
    .const 'Sub' $P8000 = "184_1306916577.75068" 
    $P7998."add_method"($P7999, "!PREFIX__package_def", $P8000)
    nqp_get_sc_object $P8001, "1306916558.44963", 16
    get_how $P8002, $P8001
    nqp_get_sc_object $P8003, "1306916558.44963", 16
    .const 'Sub' $P8004 = "185_1306916577.75068" 
    $P8002."add_method"($P8003, "scope_declarator", $P8004)
    nqp_get_sc_object $P8005, "1306916558.44963", 16
    get_how $P8006, $P8005
    nqp_get_sc_object $P8007, "1306916558.44963", 16
    .const 'Sub' $P8008 = "186_1306916577.75068" 
    $P8006."add_method"($P8007, "!PREFIX__scope_declarator", $P8008)
    nqp_get_sc_object $P8009, "1306916558.44963", 16
    get_how $P8010, $P8009
    nqp_get_sc_object $P8011, "1306916558.44963", 16
    .const 'Sub' $P8012 = "187_1306916577.75068" 
    $P8010."add_method"($P8011, "scope_declarator:sym<my>", $P8012)
    nqp_get_sc_object $P8013, "1306916558.44963", 16
    get_how $P8014, $P8013
    nqp_get_sc_object $P8015, "1306916558.44963", 16
    .const 'Sub' $P8016 = "188_1306916577.75068" 
    $P8014."add_method"($P8015, "!PREFIX__scope_declarator:sym<my>", $P8016)
    nqp_get_sc_object $P8017, "1306916558.44963", 16
    get_how $P8018, $P8017
    nqp_get_sc_object $P8019, "1306916558.44963", 16
    .const 'Sub' $P8020 = "189_1306916577.75068" 
    $P8018."add_method"($P8019, "scope_declarator:sym<our>", $P8020)
    nqp_get_sc_object $P8021, "1306916558.44963", 16
    get_how $P8022, $P8021
    nqp_get_sc_object $P8023, "1306916558.44963", 16
    .const 'Sub' $P8024 = "190_1306916577.75068" 
    $P8022."add_method"($P8023, "!PREFIX__scope_declarator:sym<our>", $P8024)
    nqp_get_sc_object $P8025, "1306916558.44963", 16
    get_how $P8026, $P8025
    nqp_get_sc_object $P8027, "1306916558.44963", 16
    .const 'Sub' $P8028 = "191_1306916577.75068" 
    $P8026."add_method"($P8027, "scope_declarator:sym<has>", $P8028)
    nqp_get_sc_object $P8029, "1306916558.44963", 16
    get_how $P8030, $P8029
    nqp_get_sc_object $P8031, "1306916558.44963", 16
    .const 'Sub' $P8032 = "192_1306916577.75068" 
    $P8030."add_method"($P8031, "!PREFIX__scope_declarator:sym<has>", $P8032)
    nqp_get_sc_object $P8033, "1306916558.44963", 16
    get_how $P8034, $P8033
    nqp_get_sc_object $P8035, "1306916558.44963", 16
    .const 'Sub' $P8036 = "193_1306916577.75068" 
    $P8034."add_method"($P8035, "scoped", $P8036)
    nqp_get_sc_object $P8037, "1306916558.44963", 16
    get_how $P8038, $P8037
    nqp_get_sc_object $P8039, "1306916558.44963", 16
    .const 'Sub' $P8040 = "194_1306916577.75068" 
    $P8038."add_method"($P8039, "!PREFIX__scoped", $P8040)
    nqp_get_sc_object $P8041, "1306916558.44963", 16
    get_how $P8042, $P8041
    nqp_get_sc_object $P8043, "1306916558.44963", 16
    .const 'Sub' $P8044 = "195_1306916577.75068" 
    $P8042."add_method"($P8043, "typename", $P8044)
    nqp_get_sc_object $P8045, "1306916558.44963", 16
    get_how $P8046, $P8045
    nqp_get_sc_object $P8047, "1306916558.44963", 16
    .const 'Sub' $P8048 = "197_1306916577.75068" 
    $P8046."add_method"($P8047, "!PREFIX__typename", $P8048)
    nqp_get_sc_object $P8049, "1306916558.44963", 16
    get_how $P8050, $P8049
    nqp_get_sc_object $P8051, "1306916558.44963", 16
    .const 'Sub' $P8052 = "198_1306916577.75068" 
    $P8050."add_method"($P8051, "declarator", $P8052)
    nqp_get_sc_object $P8053, "1306916558.44963", 16
    get_how $P8054, $P8053
    nqp_get_sc_object $P8055, "1306916558.44963", 16
    .const 'Sub' $P8056 = "199_1306916577.75068" 
    $P8054."add_method"($P8055, "!PREFIX__declarator", $P8056)
    nqp_get_sc_object $P8057, "1306916558.44963", 16
    get_how $P8058, $P8057
    nqp_get_sc_object $P8059, "1306916558.44963", 16
    .const 'Sub' $P8060 = "200_1306916577.75068" 
    $P8058."add_method"($P8059, "variable_declarator", $P8060)
    nqp_get_sc_object $P8061, "1306916558.44963", 16
    get_how $P8062, $P8061
    nqp_get_sc_object $P8063, "1306916558.44963", 16
    .const 'Sub' $P8064 = "202_1306916577.75068" 
    $P8062."add_method"($P8063, "!PREFIX__variable_declarator", $P8064)
    nqp_get_sc_object $P8065, "1306916558.44963", 16
    get_how $P8066, $P8065
    nqp_get_sc_object $P8067, "1306916558.44963", 16
    .const 'Sub' $P8068 = "203_1306916577.75068" 
    $P8066."add_method"($P8067, "routine_declarator", $P8068)
    nqp_get_sc_object $P8069, "1306916558.44963", 16
    get_how $P8070, $P8069
    nqp_get_sc_object $P8071, "1306916558.44963", 16
    .const 'Sub' $P8072 = "204_1306916577.75068" 
    $P8070."add_method"($P8071, "!PREFIX__routine_declarator", $P8072)
    nqp_get_sc_object $P8073, "1306916558.44963", 16
    get_how $P8074, $P8073
    nqp_get_sc_object $P8075, "1306916558.44963", 16
    .const 'Sub' $P8076 = "205_1306916577.75068" 
    $P8074."add_method"($P8075, "routine_declarator:sym<sub>", $P8076)
    nqp_get_sc_object $P8077, "1306916558.44963", 16
    get_how $P8078, $P8077
    nqp_get_sc_object $P8079, "1306916558.44963", 16
    .const 'Sub' $P8080 = "206_1306916577.75068" 
    $P8078."add_method"($P8079, "!PREFIX__routine_declarator:sym<sub>", $P8080)
    nqp_get_sc_object $P8081, "1306916558.44963", 16
    get_how $P8082, $P8081
    nqp_get_sc_object $P8083, "1306916558.44963", 16
    .const 'Sub' $P8084 = "207_1306916577.75068" 
    $P8082."add_method"($P8083, "routine_declarator:sym<method>", $P8084)
    nqp_get_sc_object $P8085, "1306916558.44963", 16
    get_how $P8086, $P8085
    nqp_get_sc_object $P8087, "1306916558.44963", 16
    .const 'Sub' $P8088 = "208_1306916577.75068" 
    $P8086."add_method"($P8087, "!PREFIX__routine_declarator:sym<method>", $P8088)
    nqp_get_sc_object $P8089, "1306916558.44963", 16
    get_how $P8090, $P8089
    nqp_get_sc_object $P8091, "1306916558.44963", 16
    .const 'Sub' $P8092 = "209_1306916577.75068" 
    $P8090."add_method"($P8091, "routine_def", $P8092)
    nqp_get_sc_object $P8093, "1306916558.44963", 16
    get_how $P8094, $P8093
    nqp_get_sc_object $P8095, "1306916558.44963", 16
    .const 'Sub' $P8096 = "210_1306916577.75068" 
    $P8094."add_method"($P8095, "!PREFIX__routine_def", $P8096)
    nqp_get_sc_object $P8097, "1306916558.44963", 16
    get_how $P8098, $P8097
    nqp_get_sc_object $P8099, "1306916558.44963", 16
    .const 'Sub' $P8100 = "211_1306916577.75068" 
    $P8098."add_method"($P8099, "method_def", $P8100)
    nqp_get_sc_object $P8101, "1306916558.44963", 16
    get_how $P8102, $P8101
    nqp_get_sc_object $P8103, "1306916558.44963", 16
    .const 'Sub' $P8104 = "213_1306916577.75068" 
    $P8102."add_method"($P8103, "!PREFIX__method_def", $P8104)
    nqp_get_sc_object $P8105, "1306916558.44963", 16
    get_how $P8106, $P8105
    nqp_get_sc_object $P8107, "1306916558.44963", 16
    .const 'Sub' $P8108 = "214_1306916577.75068" 
    $P8106."add_method"($P8107, "onlystar", $P8108)
    nqp_get_sc_object $P8109, "1306916558.44963", 16
    get_how $P8110, $P8109
    nqp_get_sc_object $P8111, "1306916558.44963", 16
    .const 'Sub' $P8112 = "216_1306916577.75068" 
    $P8110."add_method"($P8111, "!PREFIX__onlystar", $P8112)
    nqp_get_sc_object $P8113, "1306916558.44963", 16
    get_how $P8114, $P8113
    nqp_get_sc_object $P8115, "1306916558.44963", 16
    .const 'Sub' $P8116 = "217_1306916577.75068" 
    $P8114."add_method"($P8115, "multi_declarator", $P8116)
    nqp_get_sc_object $P8117, "1306916558.44963", 16
    get_how $P8118, $P8117
    nqp_get_sc_object $P8119, "1306916558.44963", 16
    .const 'Sub' $P8120 = "218_1306916577.75068" 
    $P8118."add_method"($P8119, "!PREFIX__multi_declarator", $P8120)
    nqp_get_sc_object $P8121, "1306916558.44963", 16
    get_how $P8122, $P8121
    nqp_get_sc_object $P8123, "1306916558.44963", 16
    .const 'Sub' $P8124 = "219_1306916577.75068" 
    $P8122."add_method"($P8123, "multi_declarator:sym<multi>", $P8124)
    nqp_get_sc_object $P8125, "1306916558.44963", 16
    get_how $P8126, $P8125
    nqp_get_sc_object $P8127, "1306916558.44963", 16
    .const 'Sub' $P8128 = "220_1306916577.75068" 
    $P8126."add_method"($P8127, "!PREFIX__multi_declarator:sym<multi>", $P8128)
    nqp_get_sc_object $P8129, "1306916558.44963", 16
    get_how $P8130, $P8129
    nqp_get_sc_object $P8131, "1306916558.44963", 16
    .const 'Sub' $P8132 = "221_1306916577.75068" 
    $P8130."add_method"($P8131, "multi_declarator:sym<proto>", $P8132)
    nqp_get_sc_object $P8133, "1306916558.44963", 16
    get_how $P8134, $P8133
    nqp_get_sc_object $P8135, "1306916558.44963", 16
    .const 'Sub' $P8136 = "222_1306916577.75068" 
    $P8134."add_method"($P8135, "!PREFIX__multi_declarator:sym<proto>", $P8136)
    nqp_get_sc_object $P8137, "1306916558.44963", 16
    get_how $P8138, $P8137
    nqp_get_sc_object $P8139, "1306916558.44963", 16
    .const 'Sub' $P8140 = "223_1306916577.75068" 
    $P8138."add_method"($P8139, "multi_declarator:sym<null>", $P8140)
    nqp_get_sc_object $P8141, "1306916558.44963", 16
    get_how $P8142, $P8141
    nqp_get_sc_object $P8143, "1306916558.44963", 16
    .const 'Sub' $P8144 = "224_1306916577.75068" 
    $P8142."add_method"($P8143, "!PREFIX__multi_declarator:sym<null>", $P8144)
    nqp_get_sc_object $P8145, "1306916558.44963", 16
    get_how $P8146, $P8145
    nqp_get_sc_object $P8147, "1306916558.44963", 16
    .const 'Sub' $P8148 = "225_1306916577.75068" 
    $P8146."add_method"($P8147, "signature", $P8148)
    nqp_get_sc_object $P8149, "1306916558.44963", 16
    get_how $P8150, $P8149
    nqp_get_sc_object $P8151, "1306916558.44963", 16
    .const 'Sub' $P8152 = "227_1306916577.75068" 
    $P8150."add_method"($P8151, "!PREFIX__signature", $P8152)
    nqp_get_sc_object $P8153, "1306916558.44963", 16
    get_how $P8154, $P8153
    nqp_get_sc_object $P8155, "1306916558.44963", 16
    .const 'Sub' $P8156 = "228_1306916577.75068" 
    $P8154."add_method"($P8155, "parameter", $P8156)
    nqp_get_sc_object $P8157, "1306916558.44963", 16
    get_how $P8158, $P8157
    nqp_get_sc_object $P8159, "1306916558.44963", 16
    .const 'Sub' $P8160 = "229_1306916577.75068" 
    $P8158."add_method"($P8159, "!PREFIX__parameter", $P8160)
    nqp_get_sc_object $P8161, "1306916558.44963", 16
    get_how $P8162, $P8161
    nqp_get_sc_object $P8163, "1306916558.44963", 16
    .const 'Sub' $P8164 = "230_1306916577.75068" 
    $P8162."add_method"($P8163, "param_var", $P8164)
    nqp_get_sc_object $P8165, "1306916558.44963", 16
    get_how $P8166, $P8165
    nqp_get_sc_object $P8167, "1306916558.44963", 16
    .const 'Sub' $P8168 = "231_1306916577.75068" 
    $P8166."add_method"($P8167, "!PREFIX__param_var", $P8168)
    nqp_get_sc_object $P8169, "1306916558.44963", 16
    get_how $P8170, $P8169
    nqp_get_sc_object $P8171, "1306916558.44963", 16
    .const 'Sub' $P8172 = "232_1306916577.75068" 
    $P8170."add_method"($P8171, "named_param", $P8172)
    nqp_get_sc_object $P8173, "1306916558.44963", 16
    get_how $P8174, $P8173
    nqp_get_sc_object $P8175, "1306916558.44963", 16
    .const 'Sub' $P8176 = "233_1306916577.75068" 
    $P8174."add_method"($P8175, "!PREFIX__named_param", $P8176)
    nqp_get_sc_object $P8177, "1306916558.44963", 16
    get_how $P8178, $P8177
    nqp_get_sc_object $P8179, "1306916558.44963", 16
    .const 'Sub' $P8180 = "234_1306916577.75068" 
    $P8178."add_method"($P8179, "default_value", $P8180)
    nqp_get_sc_object $P8181, "1306916558.44963", 16
    get_how $P8182, $P8181
    nqp_get_sc_object $P8183, "1306916558.44963", 16
    .const 'Sub' $P8184 = "235_1306916577.75068" 
    $P8182."add_method"($P8183, "!PREFIX__default_value", $P8184)
    nqp_get_sc_object $P8185, "1306916558.44963", 16
    get_how $P8186, $P8185
    nqp_get_sc_object $P8187, "1306916558.44963", 16
    .const 'Sub' $P8188 = "236_1306916577.75068" 
    $P8186."add_method"($P8187, "trait", $P8188)
    nqp_get_sc_object $P8189, "1306916558.44963", 16
    get_how $P8190, $P8189
    nqp_get_sc_object $P8191, "1306916558.44963", 16
    .const 'Sub' $P8192 = "237_1306916577.75068" 
    $P8190."add_method"($P8191, "!PREFIX__trait", $P8192)
    nqp_get_sc_object $P8193, "1306916558.44963", 16
    get_how $P8194, $P8193
    nqp_get_sc_object $P8195, "1306916558.44963", 16
    .const 'Sub' $P8196 = "238_1306916577.75068" 
    $P8194."add_method"($P8195, "trait_mod", $P8196)
    nqp_get_sc_object $P8197, "1306916558.44963", 16
    get_how $P8198, $P8197
    nqp_get_sc_object $P8199, "1306916558.44963", 16
    .const 'Sub' $P8200 = "239_1306916577.75068" 
    $P8198."add_method"($P8199, "!PREFIX__trait_mod", $P8200)
    nqp_get_sc_object $P8201, "1306916558.44963", 16
    get_how $P8202, $P8201
    nqp_get_sc_object $P8203, "1306916558.44963", 16
    .const 'Sub' $P8204 = "240_1306916577.75068" 
    $P8202."add_method"($P8203, "trait_mod:sym<is>", $P8204)
    nqp_get_sc_object $P8205, "1306916558.44963", 16
    get_how $P8206, $P8205
    nqp_get_sc_object $P8207, "1306916558.44963", 16
    .const 'Sub' $P8208 = "241_1306916577.75068" 
    $P8206."add_method"($P8207, "!PREFIX__trait_mod:sym<is>", $P8208)
    nqp_get_sc_object $P8209, "1306916558.44963", 16
    get_how $P8210, $P8209
    nqp_get_sc_object $P8211, "1306916558.44963", 16
    .const 'Sub' $P8212 = "242_1306916577.75068" 
    $P8210."add_method"($P8211, "regex_declarator", $P8212)
    nqp_get_sc_object $P8213, "1306916558.44963", 16
    get_how $P8214, $P8213
    nqp_get_sc_object $P8215, "1306916558.44963", 16
    .const 'Sub' $P8216 = "243_1306916577.75068" 
    $P8214."add_method"($P8215, "!PREFIX__regex_declarator", $P8216)
    nqp_get_sc_object $P8217, "1306916558.44963", 16
    get_how $P8218, $P8217
    nqp_get_sc_object $P8219, "1306916558.44963", 16
    .const 'Sub' $P8220 = "244_1306916577.75068" 
    $P8218."add_method"($P8219, "dotty", $P8220)
    nqp_get_sc_object $P8221, "1306916558.44963", 16
    get_how $P8222, $P8221
    nqp_get_sc_object $P8223, "1306916558.44963", 16
    .const 'Sub' $P8224 = "245_1306916577.75068" 
    $P8222."add_method"($P8223, "!PREFIX__dotty", $P8224)
    nqp_get_sc_object $P8225, "1306916558.44963", 16
    get_how $P8226, $P8225
    nqp_get_sc_object $P8227, "1306916558.44963", 16
    .const 'Sub' $P8228 = "246_1306916577.75068" 
    $P8226."add_method"($P8227, "term", $P8228)
    nqp_get_sc_object $P8229, "1306916558.44963", 16
    get_how $P8230, $P8229
    nqp_get_sc_object $P8231, "1306916558.44963", 16
    .const 'Sub' $P8232 = "247_1306916577.75068" 
    $P8230."add_method"($P8231, "!PREFIX__term", $P8232)
    nqp_get_sc_object $P8233, "1306916558.44963", 16
    get_how $P8234, $P8233
    nqp_get_sc_object $P8235, "1306916558.44963", 16
    .const 'Sub' $P8236 = "248_1306916577.75068" 
    $P8234."add_method"($P8235, "term:sym<self>", $P8236)
    nqp_get_sc_object $P8237, "1306916558.44963", 16
    get_how $P8238, $P8237
    nqp_get_sc_object $P8239, "1306916558.44963", 16
    .const 'Sub' $P8240 = "249_1306916577.75068" 
    $P8238."add_method"($P8239, "!PREFIX__term:sym<self>", $P8240)
    nqp_get_sc_object $P8241, "1306916558.44963", 16
    get_how $P8242, $P8241
    nqp_get_sc_object $P8243, "1306916558.44963", 16
    .const 'Sub' $P8244 = "250_1306916577.75068" 
    $P8242."add_method"($P8243, "term:sym<identifier>", $P8244)
    nqp_get_sc_object $P8245, "1306916558.44963", 16
    get_how $P8246, $P8245
    nqp_get_sc_object $P8247, "1306916558.44963", 16
    .const 'Sub' $P8248 = "251_1306916577.75068" 
    $P8246."add_method"($P8247, "!PREFIX__term:sym<identifier>", $P8248)
    nqp_get_sc_object $P8249, "1306916558.44963", 16
    get_how $P8250, $P8249
    nqp_get_sc_object $P8251, "1306916558.44963", 16
    .const 'Sub' $P8252 = "252_1306916577.75068" 
    $P8250."add_method"($P8251, "term:sym<name>", $P8252)
    nqp_get_sc_object $P8253, "1306916558.44963", 16
    get_how $P8254, $P8253
    nqp_get_sc_object $P8255, "1306916558.44963", 16
    .const 'Sub' $P8256 = "253_1306916577.75068" 
    $P8254."add_method"($P8255, "!PREFIX__term:sym<name>", $P8256)
    nqp_get_sc_object $P8257, "1306916558.44963", 16
    get_how $P8258, $P8257
    nqp_get_sc_object $P8259, "1306916558.44963", 16
    .const 'Sub' $P8260 = "254_1306916577.75068" 
    $P8258."add_method"($P8259, "term:sym<pir::op>", $P8260)
    nqp_get_sc_object $P8261, "1306916558.44963", 16
    get_how $P8262, $P8261
    nqp_get_sc_object $P8263, "1306916558.44963", 16
    .const 'Sub' $P8264 = "255_1306916577.75068" 
    $P8262."add_method"($P8263, "!PREFIX__term:sym<pir::op>", $P8264)
    nqp_get_sc_object $P8265, "1306916558.44963", 16
    get_how $P8266, $P8265
    nqp_get_sc_object $P8267, "1306916558.44963", 16
    .const 'Sub' $P8268 = "256_1306916577.75068" 
    $P8266."add_method"($P8267, "term:sym<onlystar>", $P8268)
    nqp_get_sc_object $P8269, "1306916558.44963", 16
    get_how $P8270, $P8269
    nqp_get_sc_object $P8271, "1306916558.44963", 16
    .const 'Sub' $P8272 = "258_1306916577.75068" 
    $P8270."add_method"($P8271, "!PREFIX__term:sym<onlystar>", $P8272)
    nqp_get_sc_object $P8273, "1306916558.44963", 16
    get_how $P8274, $P8273
    nqp_get_sc_object $P8275, "1306916558.44963", 16
    .const 'Sub' $P8276 = "259_1306916577.75068" 
    $P8274."add_method"($P8275, "args", $P8276)
    nqp_get_sc_object $P8277, "1306916558.44963", 16
    get_how $P8278, $P8277
    nqp_get_sc_object $P8279, "1306916558.44963", 16
    .const 'Sub' $P8280 = "260_1306916577.75068" 
    $P8278."add_method"($P8279, "!PREFIX__args", $P8280)
    nqp_get_sc_object $P8281, "1306916558.44963", 16
    get_how $P8282, $P8281
    nqp_get_sc_object $P8283, "1306916558.44963", 16
    .const 'Sub' $P8284 = "261_1306916577.75068" 
    $P8282."add_method"($P8283, "arglist", $P8284)
    nqp_get_sc_object $P8285, "1306916558.44963", 16
    get_how $P8286, $P8285
    nqp_get_sc_object $P8287, "1306916558.44963", 16
    .const 'Sub' $P8288 = "262_1306916577.75068" 
    $P8286."add_method"($P8287, "!PREFIX__arglist", $P8288)
    nqp_get_sc_object $P8289, "1306916558.44963", 16
    get_how $P8290, $P8289
    nqp_get_sc_object $P8291, "1306916558.44963", 16
    .const 'Sub' $P8292 = "263_1306916577.75068" 
    $P8290."add_method"($P8291, "term:sym<value>", $P8292)
    nqp_get_sc_object $P8293, "1306916558.44963", 16
    get_how $P8294, $P8293
    nqp_get_sc_object $P8295, "1306916558.44963", 16
    .const 'Sub' $P8296 = "264_1306916577.75068" 
    $P8294."add_method"($P8295, "!PREFIX__term:sym<value>", $P8296)
    nqp_get_sc_object $P8297, "1306916558.44963", 16
    get_how $P8298, $P8297
    nqp_get_sc_object $P8299, "1306916558.44963", 16
    .const 'Sub' $P8300 = "265_1306916577.75068" 
    $P8298."add_method"($P8299, "value", $P8300)
    nqp_get_sc_object $P8301, "1306916558.44963", 16
    get_how $P8302, $P8301
    nqp_get_sc_object $P8303, "1306916558.44963", 16
    .const 'Sub' $P8304 = "266_1306916577.75068" 
    $P8302."add_method"($P8303, "!PREFIX__value", $P8304)
    nqp_get_sc_object $P8305, "1306916558.44963", 16
    get_how $P8306, $P8305
    nqp_get_sc_object $P8307, "1306916558.44963", 16
    .const 'Sub' $P8308 = "267_1306916577.75068" 
    $P8306."add_method"($P8307, "number", $P8308)
    nqp_get_sc_object $P8309, "1306916558.44963", 16
    get_how $P8310, $P8309
    nqp_get_sc_object $P8311, "1306916558.44963", 16
    .const 'Sub' $P8312 = "268_1306916577.75068" 
    $P8310."add_method"($P8311, "!PREFIX__number", $P8312)
    nqp_get_sc_object $P8313, "1306916558.44963", 16
    get_how $P8314, $P8313
    nqp_get_sc_object $P8315, "1306916558.44963", 16
    .const 'Sub' $P8316 = "269_1306916577.75068" 
    $P8314."add_method"($P8315, "quote", $P8316)
    nqp_get_sc_object $P8317, "1306916558.44963", 16
    get_how $P8318, $P8317
    nqp_get_sc_object $P8319, "1306916558.44963", 16
    .const 'Sub' $P8320 = "270_1306916577.75068" 
    $P8318."add_method"($P8319, "!PREFIX__quote", $P8320)
    nqp_get_sc_object $P8321, "1306916558.44963", 16
    get_how $P8322, $P8321
    nqp_get_sc_object $P8323, "1306916558.44963", 16
    .const 'Sub' $P8324 = "271_1306916577.75068" 
    $P8322."add_method"($P8323, "quote:sym<apos>", $P8324)
    nqp_get_sc_object $P8325, "1306916558.44963", 16
    get_how $P8326, $P8325
    nqp_get_sc_object $P8327, "1306916558.44963", 16
    .const 'Sub' $P8328 = "272_1306916577.75068" 
    $P8326."add_method"($P8327, "!PREFIX__quote:sym<apos>", $P8328)
    nqp_get_sc_object $P8329, "1306916558.44963", 16
    get_how $P8330, $P8329
    nqp_get_sc_object $P8331, "1306916558.44963", 16
    .const 'Sub' $P8332 = "273_1306916577.75068" 
    $P8330."add_method"($P8331, "quote:sym<dblq>", $P8332)
    nqp_get_sc_object $P8333, "1306916558.44963", 16
    get_how $P8334, $P8333
    nqp_get_sc_object $P8335, "1306916558.44963", 16
    .const 'Sub' $P8336 = "274_1306916577.75068" 
    $P8334."add_method"($P8335, "!PREFIX__quote:sym<dblq>", $P8336)
    nqp_get_sc_object $P8337, "1306916558.44963", 16
    get_how $P8338, $P8337
    nqp_get_sc_object $P8339, "1306916558.44963", 16
    .const 'Sub' $P8340 = "275_1306916577.75068" 
    $P8338."add_method"($P8339, "quote:sym<q>", $P8340)
    nqp_get_sc_object $P8341, "1306916558.44963", 16
    get_how $P8342, $P8341
    nqp_get_sc_object $P8343, "1306916558.44963", 16
    .const 'Sub' $P8344 = "276_1306916577.75068" 
    $P8342."add_method"($P8343, "!PREFIX__quote:sym<q>", $P8344)
    nqp_get_sc_object $P8345, "1306916558.44963", 16
    get_how $P8346, $P8345
    nqp_get_sc_object $P8347, "1306916558.44963", 16
    .const 'Sub' $P8348 = "277_1306916577.75068" 
    $P8346."add_method"($P8347, "quote:sym<qq>", $P8348)
    nqp_get_sc_object $P8349, "1306916558.44963", 16
    get_how $P8350, $P8349
    nqp_get_sc_object $P8351, "1306916558.44963", 16
    .const 'Sub' $P8352 = "278_1306916577.75068" 
    $P8350."add_method"($P8351, "!PREFIX__quote:sym<qq>", $P8352)
    nqp_get_sc_object $P8353, "1306916558.44963", 16
    get_how $P8354, $P8353
    nqp_get_sc_object $P8355, "1306916558.44963", 16
    .const 'Sub' $P8356 = "279_1306916577.75068" 
    $P8354."add_method"($P8355, "quote:sym<Q>", $P8356)
    nqp_get_sc_object $P8357, "1306916558.44963", 16
    get_how $P8358, $P8357
    nqp_get_sc_object $P8359, "1306916558.44963", 16
    .const 'Sub' $P8360 = "280_1306916577.75068" 
    $P8358."add_method"($P8359, "!PREFIX__quote:sym<Q>", $P8360)
    nqp_get_sc_object $P8361, "1306916558.44963", 16
    get_how $P8362, $P8361
    nqp_get_sc_object $P8363, "1306916558.44963", 16
    .const 'Sub' $P8364 = "281_1306916577.75068" 
    $P8362."add_method"($P8363, "quote:sym<Q:PIR>", $P8364)
    nqp_get_sc_object $P8365, "1306916558.44963", 16
    get_how $P8366, $P8365
    nqp_get_sc_object $P8367, "1306916558.44963", 16
    .const 'Sub' $P8368 = "282_1306916577.75068" 
    $P8366."add_method"($P8367, "!PREFIX__quote:sym<Q:PIR>", $P8368)
    nqp_get_sc_object $P8369, "1306916558.44963", 16
    get_how $P8370, $P8369
    nqp_get_sc_object $P8371, "1306916558.44963", 16
    .const 'Sub' $P8372 = "283_1306916577.75068" 
    $P8370."add_method"($P8371, "quote:sym</ />", $P8372)
    nqp_get_sc_object $P8373, "1306916558.44963", 16
    get_how $P8374, $P8373
    nqp_get_sc_object $P8375, "1306916558.44963", 16
    .const 'Sub' $P8376 = "284_1306916577.75068" 
    $P8374."add_method"($P8375, "!PREFIX__quote:sym</ />", $P8376)
    nqp_get_sc_object $P8377, "1306916558.44963", 16
    get_how $P8378, $P8377
    nqp_get_sc_object $P8379, "1306916558.44963", 16
    .const 'Sub' $P8380 = "285_1306916577.75068" 
    $P8378."add_method"($P8379, "quote_escape:sym<$>", $P8380)
    nqp_get_sc_object $P8381, "1306916558.44963", 16
    get_how $P8382, $P8381
    nqp_get_sc_object $P8383, "1306916558.44963", 16
    .const 'Sub' $P8384 = "286_1306916577.75068" 
    $P8382."add_method"($P8383, "!PREFIX__quote_escape:sym<$>", $P8384)
    nqp_get_sc_object $P8385, "1306916558.44963", 16
    get_how $P8386, $P8385
    nqp_get_sc_object $P8387, "1306916558.44963", 16
    .const 'Sub' $P8388 = "287_1306916577.75068" 
    $P8386."add_method"($P8387, "quote_escape:sym<{ }>", $P8388)
    nqp_get_sc_object $P8389, "1306916558.44963", 16
    get_how $P8390, $P8389
    nqp_get_sc_object $P8391, "1306916558.44963", 16
    .const 'Sub' $P8392 = "288_1306916577.75068" 
    $P8390."add_method"($P8391, "!PREFIX__quote_escape:sym<{ }>", $P8392)
    nqp_get_sc_object $P8393, "1306916558.44963", 16
    get_how $P8394, $P8393
    nqp_get_sc_object $P8395, "1306916558.44963", 16
    .const 'Sub' $P8396 = "289_1306916577.75068" 
    $P8394."add_method"($P8395, "quote_escape:sym<esc>", $P8396)
    nqp_get_sc_object $P8397, "1306916558.44963", 16
    get_how $P8398, $P8397
    nqp_get_sc_object $P8399, "1306916558.44963", 16
    .const 'Sub' $P8400 = "290_1306916577.75068" 
    $P8398."add_method"($P8399, "!PREFIX__quote_escape:sym<esc>", $P8400)
    nqp_get_sc_object $P8401, "1306916558.44963", 16
    get_how $P8402, $P8401
    nqp_get_sc_object $P8403, "1306916558.44963", 16
    .const 'Sub' $P8404 = "291_1306916577.75068" 
    $P8402."add_method"($P8403, "circumfix:sym<( )>", $P8404)
    nqp_get_sc_object $P8405, "1306916558.44963", 16
    get_how $P8406, $P8405
    nqp_get_sc_object $P8407, "1306916558.44963", 16
    .const 'Sub' $P8408 = "292_1306916577.75068" 
    $P8406."add_method"($P8407, "!PREFIX__circumfix:sym<( )>", $P8408)
    nqp_get_sc_object $P8409, "1306916558.44963", 16
    get_how $P8410, $P8409
    nqp_get_sc_object $P8411, "1306916558.44963", 16
    .const 'Sub' $P8412 = "293_1306916577.75068" 
    $P8410."add_method"($P8411, "circumfix:sym<[ ]>", $P8412)
    nqp_get_sc_object $P8413, "1306916558.44963", 16
    get_how $P8414, $P8413
    nqp_get_sc_object $P8415, "1306916558.44963", 16
    .const 'Sub' $P8416 = "294_1306916577.75068" 
    $P8414."add_method"($P8415, "!PREFIX__circumfix:sym<[ ]>", $P8416)
    nqp_get_sc_object $P8417, "1306916558.44963", 16
    get_how $P8418, $P8417
    nqp_get_sc_object $P8419, "1306916558.44963", 16
    .const 'Sub' $P8420 = "295_1306916577.75068" 
    $P8418."add_method"($P8419, "circumfix:sym<ang>", $P8420)
    nqp_get_sc_object $P8421, "1306916558.44963", 16
    get_how $P8422, $P8421
    nqp_get_sc_object $P8423, "1306916558.44963", 16
    .const 'Sub' $P8424 = "296_1306916577.75068" 
    $P8422."add_method"($P8423, "!PREFIX__circumfix:sym<ang>", $P8424)
    nqp_get_sc_object $P8425, "1306916558.44963", 16
    get_how $P8426, $P8425
    nqp_get_sc_object $P8427, "1306916558.44963", 16
    .const 'Sub' $P8428 = "297_1306916577.75068" 
    $P8426."add_method"($P8427, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P8428)
    nqp_get_sc_object $P8429, "1306916558.44963", 16
    get_how $P8430, $P8429
    nqp_get_sc_object $P8431, "1306916558.44963", 16
    .const 'Sub' $P8432 = "298_1306916577.75068" 
    $P8430."add_method"($P8431, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P8432)
    nqp_get_sc_object $P8433, "1306916558.44963", 16
    get_how $P8434, $P8433
    nqp_get_sc_object $P8435, "1306916558.44963", 16
    .const 'Sub' $P8436 = "299_1306916577.75068" 
    $P8434."add_method"($P8435, "circumfix:sym<{ }>", $P8436)
    nqp_get_sc_object $P8437, "1306916558.44963", 16
    get_how $P8438, $P8437
    nqp_get_sc_object $P8439, "1306916558.44963", 16
    .const 'Sub' $P8440 = "300_1306916577.75068" 
    $P8438."add_method"($P8439, "!PREFIX__circumfix:sym<{ }>", $P8440)
    nqp_get_sc_object $P8441, "1306916558.44963", 16
    get_how $P8442, $P8441
    nqp_get_sc_object $P8443, "1306916558.44963", 16
    .const 'Sub' $P8444 = "301_1306916577.75068" 
    $P8442."add_method"($P8443, "circumfix:sym<sigil>", $P8444)
    nqp_get_sc_object $P8445, "1306916558.44963", 16
    get_how $P8446, $P8445
    nqp_get_sc_object $P8447, "1306916558.44963", 16
    .const 'Sub' $P8448 = "302_1306916577.75068" 
    $P8446."add_method"($P8447, "!PREFIX__circumfix:sym<sigil>", $P8448)
    nqp_get_sc_object $P8449, "1306916558.44963", 16
    get_how $P8450, $P8449
    nqp_get_sc_object $P8451, "1306916558.44963", 16
    .const 'Sub' $P8452 = "303_1306916577.75068" 
    $P8450."add_method"($P8451, "semilist", $P8452)
    nqp_get_sc_object $P8453, "1306916558.44963", 16
    get_how $P8454, $P8453
    nqp_get_sc_object $P8455, "1306916558.44963", 16
    .const 'Sub' $P8456 = "304_1306916577.75068" 
    $P8454."add_method"($P8455, "!PREFIX__semilist", $P8456)
    nqp_get_sc_object $P8457, "1306916558.44963", 16
    get_how $P8458, $P8457
    nqp_get_sc_object $P8459, "1306916558.44963", 16
    .const 'Sub' $P8460 = "305_1306916577.75068" 
    $P8458."add_method"($P8459, "infixish", $P8460)
    nqp_get_sc_object $P8461, "1306916558.44963", 16
    get_how $P8462, $P8461
    nqp_get_sc_object $P8463, "1306916558.44963", 16
    .const 'Sub' $P8464 = "306_1306916577.75068" 
    $P8462."add_method"($P8463, "!PREFIX__infixish", $P8464)
    nqp_get_sc_object $P8465, "1306916558.44963", 16
    get_how $P8466, $P8465
    nqp_get_sc_object $P8467, "1306916558.44963", 16
    .const 'Sub' $P8468 = "307_1306916577.75068" 
    $P8466."add_method"($P8467, "infixstopper", $P8468)
    nqp_get_sc_object $P8469, "1306916558.44963", 16
    get_how $P8470, $P8469
    nqp_get_sc_object $P8471, "1306916558.44963", 16
    .const 'Sub' $P8472 = "308_1306916577.75068" 
    $P8470."add_method"($P8471, "!PREFIX__infixstopper", $P8472)
    nqp_get_sc_object $P8473, "1306916558.44963", 16
    get_how $P8474, $P8473
    nqp_get_sc_object $P8475, "1306916558.44963", 16
    .const 'Sub' $P8476 = "309_1306916577.75068" 
    $P8474."add_method"($P8475, "postcircumfix:sym<[ ]>", $P8476)
    nqp_get_sc_object $P8477, "1306916558.44963", 16
    get_how $P8478, $P8477
    nqp_get_sc_object $P8479, "1306916558.44963", 16
    .const 'Sub' $P8480 = "310_1306916577.75068" 
    $P8478."add_method"($P8479, "!PREFIX__postcircumfix:sym<[ ]>", $P8480)
    nqp_get_sc_object $P8481, "1306916558.44963", 16
    get_how $P8482, $P8481
    nqp_get_sc_object $P8483, "1306916558.44963", 16
    .const 'Sub' $P8484 = "311_1306916577.75068" 
    $P8482."add_method"($P8483, "postcircumfix:sym<{ }>", $P8484)
    nqp_get_sc_object $P8485, "1306916558.44963", 16
    get_how $P8486, $P8485
    nqp_get_sc_object $P8487, "1306916558.44963", 16
    .const 'Sub' $P8488 = "312_1306916577.75068" 
    $P8486."add_method"($P8487, "!PREFIX__postcircumfix:sym<{ }>", $P8488)
    nqp_get_sc_object $P8489, "1306916558.44963", 16
    get_how $P8490, $P8489
    nqp_get_sc_object $P8491, "1306916558.44963", 16
    .const 'Sub' $P8492 = "313_1306916577.75068" 
    $P8490."add_method"($P8491, "postcircumfix:sym<ang>", $P8492)
    nqp_get_sc_object $P8493, "1306916558.44963", 16
    get_how $P8494, $P8493
    nqp_get_sc_object $P8495, "1306916558.44963", 16
    .const 'Sub' $P8496 = "314_1306916577.75068" 
    $P8494."add_method"($P8495, "!PREFIX__postcircumfix:sym<ang>", $P8496)
    nqp_get_sc_object $P8497, "1306916558.44963", 16
    get_how $P8498, $P8497
    nqp_get_sc_object $P8499, "1306916558.44963", 16
    .const 'Sub' $P8500 = "315_1306916577.75068" 
    $P8498."add_method"($P8499, "postcircumfix:sym<( )>", $P8500)
    nqp_get_sc_object $P8501, "1306916558.44963", 16
    get_how $P8502, $P8501
    nqp_get_sc_object $P8503, "1306916558.44963", 16
    .const 'Sub' $P8504 = "316_1306916577.75068" 
    $P8502."add_method"($P8503, "!PREFIX__postcircumfix:sym<( )>", $P8504)
    nqp_get_sc_object $P8505, "1306916558.44963", 16
    get_how $P8506, $P8505
    nqp_get_sc_object $P8507, "1306916558.44963", 16
    .const 'Sub' $P8508 = "317_1306916577.75068" 
    $P8506."add_method"($P8507, "postfix:sym<.>", $P8508)
    nqp_get_sc_object $P8509, "1306916558.44963", 16
    get_how $P8510, $P8509
    nqp_get_sc_object $P8511, "1306916558.44963", 16
    .const 'Sub' $P8512 = "318_1306916577.75068" 
    $P8510."add_method"($P8511, "!PREFIX__postfix:sym<.>", $P8512)
    nqp_get_sc_object $P8513, "1306916558.44963", 16
    get_how $P8514, $P8513
    nqp_get_sc_object $P8515, "1306916558.44963", 16
    .const 'Sub' $P8516 = "319_1306916577.75068" 
    $P8514."add_method"($P8515, "prefix:sym<++>", $P8516)
    nqp_get_sc_object $P8517, "1306916558.44963", 16
    get_how $P8518, $P8517
    nqp_get_sc_object $P8519, "1306916558.44963", 16
    .const 'Sub' $P8520 = "320_1306916577.75068" 
    $P8518."add_method"($P8519, "!PREFIX__prefix:sym<++>", $P8520)
    nqp_get_sc_object $P8521, "1306916558.44963", 16
    get_how $P8522, $P8521
    nqp_get_sc_object $P8523, "1306916558.44963", 16
    .const 'Sub' $P8524 = "321_1306916577.75068" 
    $P8522."add_method"($P8523, "prefix:sym<-->", $P8524)
    nqp_get_sc_object $P8525, "1306916558.44963", 16
    get_how $P8526, $P8525
    nqp_get_sc_object $P8527, "1306916558.44963", 16
    .const 'Sub' $P8528 = "322_1306916577.75068" 
    $P8526."add_method"($P8527, "!PREFIX__prefix:sym<-->", $P8528)
    nqp_get_sc_object $P8529, "1306916558.44963", 16
    get_how $P8530, $P8529
    nqp_get_sc_object $P8531, "1306916558.44963", 16
    .const 'Sub' $P8532 = "323_1306916577.75068" 
    $P8530."add_method"($P8531, "postfix:sym<++>", $P8532)
    nqp_get_sc_object $P8533, "1306916558.44963", 16
    get_how $P8534, $P8533
    nqp_get_sc_object $P8535, "1306916558.44963", 16
    .const 'Sub' $P8536 = "324_1306916577.75068" 
    $P8534."add_method"($P8535, "!PREFIX__postfix:sym<++>", $P8536)
    nqp_get_sc_object $P8537, "1306916558.44963", 16
    get_how $P8538, $P8537
    nqp_get_sc_object $P8539, "1306916558.44963", 16
    .const 'Sub' $P8540 = "325_1306916577.75068" 
    $P8538."add_method"($P8539, "postfix:sym<-->", $P8540)
    nqp_get_sc_object $P8541, "1306916558.44963", 16
    get_how $P8542, $P8541
    nqp_get_sc_object $P8543, "1306916558.44963", 16
    .const 'Sub' $P8544 = "326_1306916577.75068" 
    $P8542."add_method"($P8543, "!PREFIX__postfix:sym<-->", $P8544)
    nqp_get_sc_object $P8545, "1306916558.44963", 16
    get_how $P8546, $P8545
    nqp_get_sc_object $P8547, "1306916558.44963", 16
    .const 'Sub' $P8548 = "327_1306916577.75068" 
    $P8546."add_method"($P8547, "infix:sym<**>", $P8548)
    nqp_get_sc_object $P8549, "1306916558.44963", 16
    get_how $P8550, $P8549
    nqp_get_sc_object $P8551, "1306916558.44963", 16
    .const 'Sub' $P8552 = "328_1306916577.75068" 
    $P8550."add_method"($P8551, "!PREFIX__infix:sym<**>", $P8552)
    nqp_get_sc_object $P8553, "1306916558.44963", 16
    get_how $P8554, $P8553
    nqp_get_sc_object $P8555, "1306916558.44963", 16
    .const 'Sub' $P8556 = "329_1306916577.75068" 
    $P8554."add_method"($P8555, "prefix:sym<+>", $P8556)
    nqp_get_sc_object $P8557, "1306916558.44963", 16
    get_how $P8558, $P8557
    nqp_get_sc_object $P8559, "1306916558.44963", 16
    .const 'Sub' $P8560 = "330_1306916577.75068" 
    $P8558."add_method"($P8559, "!PREFIX__prefix:sym<+>", $P8560)
    nqp_get_sc_object $P8561, "1306916558.44963", 16
    get_how $P8562, $P8561
    nqp_get_sc_object $P8563, "1306916558.44963", 16
    .const 'Sub' $P8564 = "331_1306916577.75068" 
    $P8562."add_method"($P8563, "prefix:sym<~>", $P8564)
    nqp_get_sc_object $P8565, "1306916558.44963", 16
    get_how $P8566, $P8565
    nqp_get_sc_object $P8567, "1306916558.44963", 16
    .const 'Sub' $P8568 = "332_1306916577.75068" 
    $P8566."add_method"($P8567, "!PREFIX__prefix:sym<~>", $P8568)
    nqp_get_sc_object $P8569, "1306916558.44963", 16
    get_how $P8570, $P8569
    nqp_get_sc_object $P8571, "1306916558.44963", 16
    .const 'Sub' $P8572 = "333_1306916577.75068" 
    $P8570."add_method"($P8571, "prefix:sym<->", $P8572)
    nqp_get_sc_object $P8573, "1306916558.44963", 16
    get_how $P8574, $P8573
    nqp_get_sc_object $P8575, "1306916558.44963", 16
    .const 'Sub' $P8576 = "334_1306916577.75068" 
    $P8574."add_method"($P8575, "!PREFIX__prefix:sym<->", $P8576)
    nqp_get_sc_object $P8577, "1306916558.44963", 16
    get_how $P8578, $P8577
    nqp_get_sc_object $P8579, "1306916558.44963", 16
    .const 'Sub' $P8580 = "335_1306916577.75068" 
    $P8578."add_method"($P8579, "prefix:sym<?>", $P8580)
    nqp_get_sc_object $P8581, "1306916558.44963", 16
    get_how $P8582, $P8581
    nqp_get_sc_object $P8583, "1306916558.44963", 16
    .const 'Sub' $P8584 = "336_1306916577.75068" 
    $P8582."add_method"($P8583, "!PREFIX__prefix:sym<?>", $P8584)
    nqp_get_sc_object $P8585, "1306916558.44963", 16
    get_how $P8586, $P8585
    nqp_get_sc_object $P8587, "1306916558.44963", 16
    .const 'Sub' $P8588 = "337_1306916577.75068" 
    $P8586."add_method"($P8587, "prefix:sym<!>", $P8588)
    nqp_get_sc_object $P8589, "1306916558.44963", 16
    get_how $P8590, $P8589
    nqp_get_sc_object $P8591, "1306916558.44963", 16
    .const 'Sub' $P8592 = "338_1306916577.75068" 
    $P8590."add_method"($P8591, "!PREFIX__prefix:sym<!>", $P8592)
    nqp_get_sc_object $P8593, "1306916558.44963", 16
    get_how $P8594, $P8593
    nqp_get_sc_object $P8595, "1306916558.44963", 16
    .const 'Sub' $P8596 = "339_1306916577.75068" 
    $P8594."add_method"($P8595, "prefix:sym<|>", $P8596)
    nqp_get_sc_object $P8597, "1306916558.44963", 16
    get_how $P8598, $P8597
    nqp_get_sc_object $P8599, "1306916558.44963", 16
    .const 'Sub' $P8600 = "340_1306916577.75068" 
    $P8598."add_method"($P8599, "!PREFIX__prefix:sym<|>", $P8600)
    nqp_get_sc_object $P8601, "1306916558.44963", 16
    get_how $P8602, $P8601
    nqp_get_sc_object $P8603, "1306916558.44963", 16
    .const 'Sub' $P8604 = "341_1306916577.75068" 
    $P8602."add_method"($P8603, "infix:sym<*>", $P8604)
    nqp_get_sc_object $P8605, "1306916558.44963", 16
    get_how $P8606, $P8605
    nqp_get_sc_object $P8607, "1306916558.44963", 16
    .const 'Sub' $P8608 = "342_1306916577.75068" 
    $P8606."add_method"($P8607, "!PREFIX__infix:sym<*>", $P8608)
    nqp_get_sc_object $P8609, "1306916558.44963", 16
    get_how $P8610, $P8609
    nqp_get_sc_object $P8611, "1306916558.44963", 16
    .const 'Sub' $P8612 = "343_1306916577.75068" 
    $P8610."add_method"($P8611, "infix:sym</>", $P8612)
    nqp_get_sc_object $P8613, "1306916558.44963", 16
    get_how $P8614, $P8613
    nqp_get_sc_object $P8615, "1306916558.44963", 16
    .const 'Sub' $P8616 = "344_1306916577.75068" 
    $P8614."add_method"($P8615, "!PREFIX__infix:sym</>", $P8616)
    nqp_get_sc_object $P8617, "1306916558.44963", 16
    get_how $P8618, $P8617
    nqp_get_sc_object $P8619, "1306916558.44963", 16
    .const 'Sub' $P8620 = "345_1306916577.75068" 
    $P8618."add_method"($P8619, "infix:sym<%>", $P8620)
    nqp_get_sc_object $P8621, "1306916558.44963", 16
    get_how $P8622, $P8621
    nqp_get_sc_object $P8623, "1306916558.44963", 16
    .const 'Sub' $P8624 = "346_1306916577.75068" 
    $P8622."add_method"($P8623, "!PREFIX__infix:sym<%>", $P8624)
    nqp_get_sc_object $P8625, "1306916558.44963", 16
    get_how $P8626, $P8625
    nqp_get_sc_object $P8627, "1306916558.44963", 16
    .const 'Sub' $P8628 = "347_1306916577.75068" 
    $P8626."add_method"($P8627, "infix:sym<+&>", $P8628)
    nqp_get_sc_object $P8629, "1306916558.44963", 16
    get_how $P8630, $P8629
    nqp_get_sc_object $P8631, "1306916558.44963", 16
    .const 'Sub' $P8632 = "348_1306916577.75068" 
    $P8630."add_method"($P8631, "!PREFIX__infix:sym<+&>", $P8632)
    nqp_get_sc_object $P8633, "1306916558.44963", 16
    get_how $P8634, $P8633
    nqp_get_sc_object $P8635, "1306916558.44963", 16
    .const 'Sub' $P8636 = "349_1306916577.75068" 
    $P8634."add_method"($P8635, "infix:sym<+>", $P8636)
    nqp_get_sc_object $P8637, "1306916558.44963", 16
    get_how $P8638, $P8637
    nqp_get_sc_object $P8639, "1306916558.44963", 16
    .const 'Sub' $P8640 = "350_1306916577.75068" 
    $P8638."add_method"($P8639, "!PREFIX__infix:sym<+>", $P8640)
    nqp_get_sc_object $P8641, "1306916558.44963", 16
    get_how $P8642, $P8641
    nqp_get_sc_object $P8643, "1306916558.44963", 16
    .const 'Sub' $P8644 = "351_1306916577.75068" 
    $P8642."add_method"($P8643, "infix:sym<->", $P8644)
    nqp_get_sc_object $P8645, "1306916558.44963", 16
    get_how $P8646, $P8645
    nqp_get_sc_object $P8647, "1306916558.44963", 16
    .const 'Sub' $P8648 = "352_1306916577.75068" 
    $P8646."add_method"($P8647, "!PREFIX__infix:sym<->", $P8648)
    nqp_get_sc_object $P8649, "1306916558.44963", 16
    get_how $P8650, $P8649
    nqp_get_sc_object $P8651, "1306916558.44963", 16
    .const 'Sub' $P8652 = "353_1306916577.75068" 
    $P8650."add_method"($P8651, "infix:sym<+|>", $P8652)
    nqp_get_sc_object $P8653, "1306916558.44963", 16
    get_how $P8654, $P8653
    nqp_get_sc_object $P8655, "1306916558.44963", 16
    .const 'Sub' $P8656 = "354_1306916577.75068" 
    $P8654."add_method"($P8655, "!PREFIX__infix:sym<+|>", $P8656)
    nqp_get_sc_object $P8657, "1306916558.44963", 16
    get_how $P8658, $P8657
    nqp_get_sc_object $P8659, "1306916558.44963", 16
    .const 'Sub' $P8660 = "355_1306916577.75068" 
    $P8658."add_method"($P8659, "infix:sym<+^>", $P8660)
    nqp_get_sc_object $P8661, "1306916558.44963", 16
    get_how $P8662, $P8661
    nqp_get_sc_object $P8663, "1306916558.44963", 16
    .const 'Sub' $P8664 = "356_1306916577.75068" 
    $P8662."add_method"($P8663, "!PREFIX__infix:sym<+^>", $P8664)
    nqp_get_sc_object $P8665, "1306916558.44963", 16
    get_how $P8666, $P8665
    nqp_get_sc_object $P8667, "1306916558.44963", 16
    .const 'Sub' $P8668 = "357_1306916577.75068" 
    $P8666."add_method"($P8667, "infix:sym<~>", $P8668)
    nqp_get_sc_object $P8669, "1306916558.44963", 16
    get_how $P8670, $P8669
    nqp_get_sc_object $P8671, "1306916558.44963", 16
    .const 'Sub' $P8672 = "358_1306916577.75068" 
    $P8670."add_method"($P8671, "!PREFIX__infix:sym<~>", $P8672)
    nqp_get_sc_object $P8673, "1306916558.44963", 16
    get_how $P8674, $P8673
    nqp_get_sc_object $P8675, "1306916558.44963", 16
    .const 'Sub' $P8676 = "359_1306916577.75068" 
    $P8674."add_method"($P8675, "infix:sym<==>", $P8676)
    nqp_get_sc_object $P8677, "1306916558.44963", 16
    get_how $P8678, $P8677
    nqp_get_sc_object $P8679, "1306916558.44963", 16
    .const 'Sub' $P8680 = "360_1306916577.75068" 
    $P8678."add_method"($P8679, "!PREFIX__infix:sym<==>", $P8680)
    nqp_get_sc_object $P8681, "1306916558.44963", 16
    get_how $P8682, $P8681
    nqp_get_sc_object $P8683, "1306916558.44963", 16
    .const 'Sub' $P8684 = "361_1306916577.75068" 
    $P8682."add_method"($P8683, "infix:sym<!=>", $P8684)
    nqp_get_sc_object $P8685, "1306916558.44963", 16
    get_how $P8686, $P8685
    nqp_get_sc_object $P8687, "1306916558.44963", 16
    .const 'Sub' $P8688 = "362_1306916577.75068" 
    $P8686."add_method"($P8687, "!PREFIX__infix:sym<!=>", $P8688)
    nqp_get_sc_object $P8689, "1306916558.44963", 16
    get_how $P8690, $P8689
    nqp_get_sc_object $P8691, "1306916558.44963", 16
    .const 'Sub' $P8692 = "363_1306916577.75068" 
    $P8690."add_method"($P8691, "infix:sym<<=>", $P8692)
    nqp_get_sc_object $P8693, "1306916558.44963", 16
    get_how $P8694, $P8693
    nqp_get_sc_object $P8695, "1306916558.44963", 16
    .const 'Sub' $P8696 = "364_1306916577.75068" 
    $P8694."add_method"($P8695, "!PREFIX__infix:sym<<=>", $P8696)
    nqp_get_sc_object $P8697, "1306916558.44963", 16
    get_how $P8698, $P8697
    nqp_get_sc_object $P8699, "1306916558.44963", 16
    .const 'Sub' $P8700 = "365_1306916577.75068" 
    $P8698."add_method"($P8699, "infix:sym<>=>", $P8700)
    nqp_get_sc_object $P8701, "1306916558.44963", 16
    get_how $P8702, $P8701
    nqp_get_sc_object $P8703, "1306916558.44963", 16
    .const 'Sub' $P8704 = "366_1306916577.75068" 
    $P8702."add_method"($P8703, "!PREFIX__infix:sym<>=>", $P8704)
    nqp_get_sc_object $P8705, "1306916558.44963", 16
    get_how $P8706, $P8705
    nqp_get_sc_object $P8707, "1306916558.44963", 16
    .const 'Sub' $P8708 = "367_1306916577.75068" 
    $P8706."add_method"($P8707, "infix:sym<<>", $P8708)
    nqp_get_sc_object $P8709, "1306916558.44963", 16
    get_how $P8710, $P8709
    nqp_get_sc_object $P8711, "1306916558.44963", 16
    .const 'Sub' $P8712 = "368_1306916577.75068" 
    $P8710."add_method"($P8711, "!PREFIX__infix:sym<<>", $P8712)
    nqp_get_sc_object $P8713, "1306916558.44963", 16
    get_how $P8714, $P8713
    nqp_get_sc_object $P8715, "1306916558.44963", 16
    .const 'Sub' $P8716 = "369_1306916577.75068" 
    $P8714."add_method"($P8715, "infix:sym<>>", $P8716)
    nqp_get_sc_object $P8717, "1306916558.44963", 16
    get_how $P8718, $P8717
    nqp_get_sc_object $P8719, "1306916558.44963", 16
    .const 'Sub' $P8720 = "370_1306916577.75068" 
    $P8718."add_method"($P8719, "!PREFIX__infix:sym<>>", $P8720)
    nqp_get_sc_object $P8721, "1306916558.44963", 16
    get_how $P8722, $P8721
    nqp_get_sc_object $P8723, "1306916558.44963", 16
    .const 'Sub' $P8724 = "371_1306916577.75068" 
    $P8722."add_method"($P8723, "infix:sym<eq>", $P8724)
    nqp_get_sc_object $P8725, "1306916558.44963", 16
    get_how $P8726, $P8725
    nqp_get_sc_object $P8727, "1306916558.44963", 16
    .const 'Sub' $P8728 = "372_1306916577.75068" 
    $P8726."add_method"($P8727, "!PREFIX__infix:sym<eq>", $P8728)
    nqp_get_sc_object $P8729, "1306916558.44963", 16
    get_how $P8730, $P8729
    nqp_get_sc_object $P8731, "1306916558.44963", 16
    .const 'Sub' $P8732 = "373_1306916577.75068" 
    $P8730."add_method"($P8731, "infix:sym<ne>", $P8732)
    nqp_get_sc_object $P8733, "1306916558.44963", 16
    get_how $P8734, $P8733
    nqp_get_sc_object $P8735, "1306916558.44963", 16
    .const 'Sub' $P8736 = "374_1306916577.75068" 
    $P8734."add_method"($P8735, "!PREFIX__infix:sym<ne>", $P8736)
    nqp_get_sc_object $P8737, "1306916558.44963", 16
    get_how $P8738, $P8737
    nqp_get_sc_object $P8739, "1306916558.44963", 16
    .const 'Sub' $P8740 = "375_1306916577.75068" 
    $P8738."add_method"($P8739, "infix:sym<le>", $P8740)
    nqp_get_sc_object $P8741, "1306916558.44963", 16
    get_how $P8742, $P8741
    nqp_get_sc_object $P8743, "1306916558.44963", 16
    .const 'Sub' $P8744 = "376_1306916577.75068" 
    $P8742."add_method"($P8743, "!PREFIX__infix:sym<le>", $P8744)
    nqp_get_sc_object $P8745, "1306916558.44963", 16
    get_how $P8746, $P8745
    nqp_get_sc_object $P8747, "1306916558.44963", 16
    .const 'Sub' $P8748 = "377_1306916577.75068" 
    $P8746."add_method"($P8747, "infix:sym<ge>", $P8748)
    nqp_get_sc_object $P8749, "1306916558.44963", 16
    get_how $P8750, $P8749
    nqp_get_sc_object $P8751, "1306916558.44963", 16
    .const 'Sub' $P8752 = "378_1306916577.75068" 
    $P8750."add_method"($P8751, "!PREFIX__infix:sym<ge>", $P8752)
    nqp_get_sc_object $P8753, "1306916558.44963", 16
    get_how $P8754, $P8753
    nqp_get_sc_object $P8755, "1306916558.44963", 16
    .const 'Sub' $P8756 = "379_1306916577.75068" 
    $P8754."add_method"($P8755, "infix:sym<lt>", $P8756)
    nqp_get_sc_object $P8757, "1306916558.44963", 16
    get_how $P8758, $P8757
    nqp_get_sc_object $P8759, "1306916558.44963", 16
    .const 'Sub' $P8760 = "380_1306916577.75068" 
    $P8758."add_method"($P8759, "!PREFIX__infix:sym<lt>", $P8760)
    nqp_get_sc_object $P8761, "1306916558.44963", 16
    get_how $P8762, $P8761
    nqp_get_sc_object $P8763, "1306916558.44963", 16
    .const 'Sub' $P8764 = "381_1306916577.75068" 
    $P8762."add_method"($P8763, "infix:sym<gt>", $P8764)
    nqp_get_sc_object $P8765, "1306916558.44963", 16
    get_how $P8766, $P8765
    nqp_get_sc_object $P8767, "1306916558.44963", 16
    .const 'Sub' $P8768 = "382_1306916577.75068" 
    $P8766."add_method"($P8767, "!PREFIX__infix:sym<gt>", $P8768)
    nqp_get_sc_object $P8769, "1306916558.44963", 16
    get_how $P8770, $P8769
    nqp_get_sc_object $P8771, "1306916558.44963", 16
    .const 'Sub' $P8772 = "383_1306916577.75068" 
    $P8770."add_method"($P8771, "infix:sym<=:=>", $P8772)
    nqp_get_sc_object $P8773, "1306916558.44963", 16
    get_how $P8774, $P8773
    nqp_get_sc_object $P8775, "1306916558.44963", 16
    .const 'Sub' $P8776 = "384_1306916577.75068" 
    $P8774."add_method"($P8775, "!PREFIX__infix:sym<=:=>", $P8776)
    nqp_get_sc_object $P8777, "1306916558.44963", 16
    get_how $P8778, $P8777
    nqp_get_sc_object $P8779, "1306916558.44963", 16
    .const 'Sub' $P8780 = "385_1306916577.75068" 
    $P8778."add_method"($P8779, "infix:sym<~~>", $P8780)
    nqp_get_sc_object $P8781, "1306916558.44963", 16
    get_how $P8782, $P8781
    nqp_get_sc_object $P8783, "1306916558.44963", 16
    .const 'Sub' $P8784 = "386_1306916577.75068" 
    $P8782."add_method"($P8783, "!PREFIX__infix:sym<~~>", $P8784)
    nqp_get_sc_object $P8785, "1306916558.44963", 16
    get_how $P8786, $P8785
    nqp_get_sc_object $P8787, "1306916558.44963", 16
    .const 'Sub' $P8788 = "387_1306916577.75068" 
    $P8786."add_method"($P8787, "infix:sym<&&>", $P8788)
    nqp_get_sc_object $P8789, "1306916558.44963", 16
    get_how $P8790, $P8789
    nqp_get_sc_object $P8791, "1306916558.44963", 16
    .const 'Sub' $P8792 = "388_1306916577.75068" 
    $P8790."add_method"($P8791, "!PREFIX__infix:sym<&&>", $P8792)
    nqp_get_sc_object $P8793, "1306916558.44963", 16
    get_how $P8794, $P8793
    nqp_get_sc_object $P8795, "1306916558.44963", 16
    .const 'Sub' $P8796 = "389_1306916577.75068" 
    $P8794."add_method"($P8795, "infix:sym<||>", $P8796)
    nqp_get_sc_object $P8797, "1306916558.44963", 16
    get_how $P8798, $P8797
    nqp_get_sc_object $P8799, "1306916558.44963", 16
    .const 'Sub' $P8800 = "390_1306916577.75068" 
    $P8798."add_method"($P8799, "!PREFIX__infix:sym<||>", $P8800)
    nqp_get_sc_object $P8801, "1306916558.44963", 16
    get_how $P8802, $P8801
    nqp_get_sc_object $P8803, "1306916558.44963", 16
    .const 'Sub' $P8804 = "391_1306916577.75068" 
    $P8802."add_method"($P8803, "infix:sym<//>", $P8804)
    nqp_get_sc_object $P8805, "1306916558.44963", 16
    get_how $P8806, $P8805
    nqp_get_sc_object $P8807, "1306916558.44963", 16
    .const 'Sub' $P8808 = "392_1306916577.75068" 
    $P8806."add_method"($P8807, "!PREFIX__infix:sym<//>", $P8808)
    nqp_get_sc_object $P8809, "1306916558.44963", 16
    get_how $P8810, $P8809
    nqp_get_sc_object $P8811, "1306916558.44963", 16
    .const 'Sub' $P8812 = "393_1306916577.75068" 
    $P8810."add_method"($P8811, "infix:sym<?? !!>", $P8812)
    nqp_get_sc_object $P8813, "1306916558.44963", 16
    get_how $P8814, $P8813
    nqp_get_sc_object $P8815, "1306916558.44963", 16
    .const 'Sub' $P8816 = "394_1306916577.75068" 
    $P8814."add_method"($P8815, "!PREFIX__infix:sym<?? !!>", $P8816)
    nqp_get_sc_object $P8817, "1306916558.44963", 16
    get_how $P8818, $P8817
    nqp_get_sc_object $P8819, "1306916558.44963", 16
    .const 'Sub' $P8820 = "395_1306916577.75068" 
    $P8818."add_method"($P8819, "infix:sym<=>", $P8820)
    nqp_get_sc_object $P8821, "1306916558.44963", 16
    get_how $P8822, $P8821
    nqp_get_sc_object $P8823, "1306916558.44963", 16
    .const 'Sub' $P8824 = "396_1306916577.75068" 
    $P8822."add_method"($P8823, "!PREFIX__infix:sym<=>", $P8824)
    nqp_get_sc_object $P8825, "1306916558.44963", 16
    get_how $P8826, $P8825
    nqp_get_sc_object $P8827, "1306916558.44963", 16
    .const 'Sub' $P8828 = "397_1306916577.75068" 
    $P8826."add_method"($P8827, "infix:sym<:=>", $P8828)
    nqp_get_sc_object $P8829, "1306916558.44963", 16
    get_how $P8830, $P8829
    nqp_get_sc_object $P8831, "1306916558.44963", 16
    .const 'Sub' $P8832 = "398_1306916577.75068" 
    $P8830."add_method"($P8831, "!PREFIX__infix:sym<:=>", $P8832)
    nqp_get_sc_object $P8833, "1306916558.44963", 16
    get_how $P8834, $P8833
    nqp_get_sc_object $P8835, "1306916558.44963", 16
    .const 'Sub' $P8836 = "399_1306916577.75068" 
    $P8834."add_method"($P8835, "infix:sym<::=>", $P8836)
    nqp_get_sc_object $P8837, "1306916558.44963", 16
    get_how $P8838, $P8837
    nqp_get_sc_object $P8839, "1306916558.44963", 16
    .const 'Sub' $P8840 = "400_1306916577.75068" 
    $P8838."add_method"($P8839, "!PREFIX__infix:sym<::=>", $P8840)
    nqp_get_sc_object $P8841, "1306916558.44963", 16
    get_how $P8842, $P8841
    nqp_get_sc_object $P8843, "1306916558.44963", 16
    .const 'Sub' $P8844 = "401_1306916577.75068" 
    $P8842."add_method"($P8843, "infix:sym<,>", $P8844)
    nqp_get_sc_object $P8845, "1306916558.44963", 16
    get_how $P8846, $P8845
    nqp_get_sc_object $P8847, "1306916558.44963", 16
    .const 'Sub' $P8848 = "402_1306916577.75068" 
    $P8846."add_method"($P8847, "!PREFIX__infix:sym<,>", $P8848)
    nqp_get_sc_object $P8849, "1306916558.44963", 16
    get_how $P8850, $P8849
    nqp_get_sc_object $P8851, "1306916558.44963", 16
    .const 'Sub' $P8852 = "403_1306916577.75068" 
    $P8850."add_method"($P8851, "prefix:sym<return>", $P8852)
    nqp_get_sc_object $P8853, "1306916558.44963", 16
    get_how $P8854, $P8853
    nqp_get_sc_object $P8855, "1306916558.44963", 16
    .const 'Sub' $P8856 = "405_1306916577.75068" 
    $P8854."add_method"($P8855, "!PREFIX__prefix:sym<return>", $P8856)
    nqp_get_sc_object $P8857, "1306916558.44963", 16
    get_how $P8858, $P8857
    nqp_get_sc_object $P8859, "1306916558.44963", 16
    .const 'Sub' $P8860 = "406_1306916577.75068" 
    $P8858."add_method"($P8859, "prefix:sym<make>", $P8860)
    nqp_get_sc_object $P8861, "1306916558.44963", 16
    get_how $P8862, $P8861
    nqp_get_sc_object $P8863, "1306916558.44963", 16
    .const 'Sub' $P8864 = "407_1306916577.75068" 
    $P8862."add_method"($P8863, "!PREFIX__prefix:sym<make>", $P8864)
    nqp_get_sc_object $P8865, "1306916558.44963", 16
    get_how $P8866, $P8865
    nqp_get_sc_object $P8867, "1306916558.44963", 16
    .const 'Sub' $P8868 = "408_1306916577.75068" 
    $P8866."add_method"($P8867, "term:sym<last>", $P8868)
    nqp_get_sc_object $P8869, "1306916558.44963", 16
    get_how $P8870, $P8869
    nqp_get_sc_object $P8871, "1306916558.44963", 16
    .const 'Sub' $P8872 = "409_1306916577.75068" 
    $P8870."add_method"($P8871, "!PREFIX__term:sym<last>", $P8872)
    nqp_get_sc_object $P8873, "1306916558.44963", 16
    get_how $P8874, $P8873
    nqp_get_sc_object $P8875, "1306916558.44963", 16
    .const 'Sub' $P8876 = "410_1306916577.75068" 
    $P8874."add_method"($P8875, "term:sym<next>", $P8876)
    nqp_get_sc_object $P8877, "1306916558.44963", 16
    get_how $P8878, $P8877
    nqp_get_sc_object $P8879, "1306916558.44963", 16
    .const 'Sub' $P8880 = "411_1306916577.75068" 
    $P8878."add_method"($P8879, "!PREFIX__term:sym<next>", $P8880)
    nqp_get_sc_object $P8881, "1306916558.44963", 16
    get_how $P8882, $P8881
    nqp_get_sc_object $P8883, "1306916558.44963", 16
    .const 'Sub' $P8884 = "412_1306916577.75068" 
    $P8882."add_method"($P8883, "term:sym<redo>", $P8884)
    nqp_get_sc_object $P8885, "1306916558.44963", 16
    get_how $P8886, $P8885
    nqp_get_sc_object $P8887, "1306916558.44963", 16
    .const 'Sub' $P8888 = "413_1306916577.75068" 
    $P8886."add_method"($P8887, "!PREFIX__term:sym<redo>", $P8888)
    nqp_get_sc_object $P8889, "1306916558.44963", 16
    get_how $P8890, $P8889
    nqp_get_sc_object $P8891, "1306916558.44963", 16
    .const 'Sub' $P8892 = "414_1306916577.75068" 
    $P8890."add_method"($P8891, "smartmatch", $P8892)
    .const 'Sub' $P8893 = "40_1306916577.75068" 
    $P8894 = $P8893."get_lexinfo"()
    nqp_get_sc_object $P8895, "1306916558.44963", 16
    $P8894."set_static_lexpad_value"("$?PACKAGE", $P8895)
    .const 'Sub' $P8896 = "40_1306916577.75068" 
    $P8897 = $P8896."get_lexinfo"()
    $P8897."finish_static_lexpad"()
    .const 'Sub' $P8898 = "40_1306916577.75068" 
    $P8899 = $P8898."get_lexinfo"()
    nqp_get_sc_object $P8900, "1306916558.44963", 16
    $P8899."set_static_lexpad_value"("$?CLASS", $P8900)
    .const 'Sub' $P8901 = "40_1306916577.75068" 
    $P8902 = $P8901."get_lexinfo"()
    $P8902."finish_static_lexpad"()
    nqp_get_sc_object $P8903, "1306916558.44963", 16
    get_how $P8904, $P8903
    nqp_get_sc_object $P8905, "1306916558.44963", 16
    nqp_get_sc_object $P8906, "1306916536.11825", 1
    $P8904."add_parent"($P8905, $P8906)
    nqp_get_sc_object $P8907, "1306916558.44963", 16
    get_how $P8908, $P8907
    nqp_get_sc_object $P8909, "1306916558.44963", 16
    $P8908."compose"($P8909)
    nqp_get_sc_object $P8910, "1306916525.99765", 41
    $P8911 = $P8910."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P8911, cur_sc
    nqp_set_sc_object "1306916558.44963", 377, $P8911
    nqp_get_sc_object $P8912, "1306916558.44963", 377
    nqp_get_sc_object $P8913, "1306916558.44963", 0
    nqp_get_package_through_who $P8914, $P8913, "NQP"
    get_who $P8915, $P8914
    set $P8915["Regex"], $P8912
    nqp_get_sc_object $P8916, "1306916558.44963", 377
    get_how $P8917, $P8916
    nqp_get_sc_object $P8918, "1306916558.44963", 377
    .const 'Sub' $P8919 = "416_1306916577.75068" 
    $P8917."add_method"($P8918, "metachar:sym<:my>", $P8919)
    nqp_get_sc_object $P8920, "1306916558.44963", 377
    get_how $P8921, $P8920
    nqp_get_sc_object $P8922, "1306916558.44963", 377
    .const 'Sub' $P8923 = "418_1306916577.75068" 
    $P8921."add_method"($P8922, "!PREFIX__metachar:sym<:my>", $P8923)
    nqp_get_sc_object $P8924, "1306916558.44963", 377
    get_how $P8925, $P8924
    nqp_get_sc_object $P8926, "1306916558.44963", 377
    .const 'Sub' $P8927 = "419_1306916577.75068" 
    $P8925."add_method"($P8926, "metachar:sym<{ }>", $P8927)
    nqp_get_sc_object $P8928, "1306916558.44963", 377
    get_how $P8929, $P8928
    nqp_get_sc_object $P8930, "1306916558.44963", 377
    .const 'Sub' $P8931 = "420_1306916577.75068" 
    $P8929."add_method"($P8930, "!PREFIX__metachar:sym<{ }>", $P8931)
    nqp_get_sc_object $P8932, "1306916558.44963", 377
    get_how $P8933, $P8932
    nqp_get_sc_object $P8934, "1306916558.44963", 377
    .const 'Sub' $P8935 = "421_1306916577.75068" 
    $P8933."add_method"($P8934, "metachar:sym<nqpvar>", $P8935)
    nqp_get_sc_object $P8936, "1306916558.44963", 377
    get_how $P8937, $P8936
    nqp_get_sc_object $P8938, "1306916558.44963", 377
    .const 'Sub' $P8939 = "423_1306916577.75068" 
    $P8937."add_method"($P8938, "!PREFIX__metachar:sym<nqpvar>", $P8939)
    nqp_get_sc_object $P8940, "1306916558.44963", 377
    get_how $P8941, $P8940
    nqp_get_sc_object $P8942, "1306916558.44963", 377
    .const 'Sub' $P8943 = "424_1306916577.75068" 
    $P8941."add_method"($P8942, "assertion:sym<{ }>", $P8943)
    nqp_get_sc_object $P8944, "1306916558.44963", 377
    get_how $P8945, $P8944
    nqp_get_sc_object $P8946, "1306916558.44963", 377
    .const 'Sub' $P8947 = "425_1306916577.75068" 
    $P8945."add_method"($P8946, "!PREFIX__assertion:sym<{ }>", $P8947)
    nqp_get_sc_object $P8948, "1306916558.44963", 377
    get_how $P8949, $P8948
    nqp_get_sc_object $P8950, "1306916558.44963", 377
    .const 'Sub' $P8951 = "426_1306916577.75068" 
    $P8949."add_method"($P8950, "assertion:sym<?{ }>", $P8951)
    nqp_get_sc_object $P8952, "1306916558.44963", 377
    get_how $P8953, $P8952
    nqp_get_sc_object $P8954, "1306916558.44963", 377
    .const 'Sub' $P8955 = "428_1306916577.75068" 
    $P8953."add_method"($P8954, "!PREFIX__assertion:sym<?{ }>", $P8955)
    nqp_get_sc_object $P8956, "1306916558.44963", 377
    get_how $P8957, $P8956
    nqp_get_sc_object $P8958, "1306916558.44963", 377
    .const 'Sub' $P8959 = "429_1306916577.75068" 
    $P8957."add_method"($P8958, "assertion:sym<name>", $P8959)
    nqp_get_sc_object $P8960, "1306916558.44963", 377
    get_how $P8961, $P8960
    nqp_get_sc_object $P8962, "1306916558.44963", 377
    .const 'Sub' $P8963 = "431_1306916577.75068" 
    $P8961."add_method"($P8962, "!PREFIX__assertion:sym<name>", $P8963)
    nqp_get_sc_object $P8964, "1306916558.44963", 377
    get_how $P8965, $P8964
    nqp_get_sc_object $P8966, "1306916558.44963", 377
    .const 'Sub' $P8967 = "432_1306916577.75068" 
    $P8965."add_method"($P8966, "assertion:sym<var>", $P8967)
    nqp_get_sc_object $P8968, "1306916558.44963", 377
    get_how $P8969, $P8968
    nqp_get_sc_object $P8970, "1306916558.44963", 377
    .const 'Sub' $P8971 = "433_1306916577.75068" 
    $P8969."add_method"($P8970, "!PREFIX__assertion:sym<var>", $P8971)
    nqp_get_sc_object $P8972, "1306916558.44963", 377
    get_how $P8973, $P8972
    nqp_get_sc_object $P8974, "1306916558.44963", 377
    .const 'Sub' $P8975 = "434_1306916577.75068" 
    $P8973."add_method"($P8974, "codeblock", $P8975)
    nqp_get_sc_object $P8976, "1306916558.44963", 377
    get_how $P8977, $P8976
    nqp_get_sc_object $P8978, "1306916558.44963", 377
    .const 'Sub' $P8979 = "435_1306916577.75068" 
    $P8977."add_method"($P8978, "!PREFIX__codeblock", $P8979)
    .const 'Sub' $P8980 = "415_1306916577.75068" 
    $P8981 = $P8980."get_lexinfo"()
    nqp_get_sc_object $P8982, "1306916558.44963", 377
    $P8981."set_static_lexpad_value"("$?PACKAGE", $P8982)
    .const 'Sub' $P8983 = "415_1306916577.75068" 
    $P8984 = $P8983."get_lexinfo"()
    $P8984."finish_static_lexpad"()
    .const 'Sub' $P8985 = "415_1306916577.75068" 
    $P8986 = $P8985."get_lexinfo"()
    nqp_get_sc_object $P8987, "1306916558.44963", 377
    $P8986."set_static_lexpad_value"("$?CLASS", $P8987)
    .const 'Sub' $P8988 = "415_1306916577.75068" 
    $P8989 = $P8988."get_lexinfo"()
    $P8989."finish_static_lexpad"()
    nqp_get_sc_object $P8990, "1306916558.44963", 377
    get_how $P8991, $P8990
    nqp_get_sc_object $P8992, "1306916558.44963", 377
    nqp_get_sc_object $P8993, "1306916549.32795", 1
    $P8991."add_parent"($P8992, $P8993)
    nqp_get_sc_object $P8994, "1306916558.44963", 377
    get_how $P8995, $P8994
    nqp_get_sc_object $P8996, "1306916558.44963", 377
    $P8995."compose"($P8996)
    nqp_get_sc_object $P8997, "1306916525.99765", 41
    $P8998 = $P8997."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P8998, cur_sc
    nqp_set_sc_object "1306916558.44963", 394, $P8998
    nqp_get_sc_object $P8999, "1306916558.44963", 394
    nqp_get_sc_object $P9000, "1306916558.44963", 0
    nqp_get_package_through_who $P9001, $P9000, "NQP"
    get_who $P9002, $P9001
    set $P9002["Actions"], $P8999
    nqp_get_sc_object $P9003, "1306916558.44963", 394
    get_how $P9004, $P9003
    nqp_get_sc_object $P9005, "1306916558.44963", 394
    .const 'Sub' $P9006 = "463_1306916577.75068" 
    $P9004."add_method"($P9005, "TOP", $P9006)
    nqp_get_sc_object $P9007, "1306916558.44963", 394
    get_how $P9008, $P9007
    nqp_get_sc_object $P9009, "1306916558.44963", 394
    .const 'Sub' $P9010 = "464_1306916577.75068" 
    $P9008."add_method"($P9009, "deflongname", $P9010)
    nqp_get_sc_object $P9011, "1306916558.44963", 394
    get_how $P9012, $P9011
    nqp_get_sc_object $P9013, "1306916558.44963", 394
    .const 'Sub' $P9014 = "465_1306916577.75068" 
    $P9012."add_method"($P9013, "comp_unit", $P9014)
    nqp_get_sc_object $P9015, "1306916558.44963", 394
    get_how $P9016, $P9015
    nqp_get_sc_object $P9017, "1306916558.44963", 394
    .const 'Sub' $P9018 = "467_1306916577.75068" 
    $P9016."add_method"($P9017, "statementlist", $P9018)
    nqp_get_sc_object $P9019, "1306916558.44963", 394
    get_how $P9020, $P9019
    nqp_get_sc_object $P9021, "1306916558.44963", 394
    .const 'Sub' $P9022 = "469_1306916577.75068" 
    $P9020."add_method"($P9021, "statement", $P9022)
    nqp_get_sc_object $P9023, "1306916558.44963", 394
    get_how $P9024, $P9023
    nqp_get_sc_object $P9025, "1306916558.44963", 394
    .const 'Sub' $P9026 = "471_1306916577.75068" 
    $P9024."add_method"($P9025, "xblock", $P9026)
    nqp_get_sc_object $P9027, "1306916558.44963", 394
    get_how $P9028, $P9027
    nqp_get_sc_object $P9029, "1306916558.44963", 394
    .const 'Sub' $P9030 = "472_1306916577.75068" 
    $P9028."add_method"($P9029, "pblock", $P9030)
    nqp_get_sc_object $P9031, "1306916558.44963", 394
    get_how $P9032, $P9031
    nqp_get_sc_object $P9033, "1306916558.44963", 394
    .const 'Sub' $P9034 = "473_1306916577.75068" 
    $P9032."add_method"($P9033, "block", $P9034)
    nqp_get_sc_object $P9035, "1306916558.44963", 394
    get_how $P9036, $P9035
    nqp_get_sc_object $P9037, "1306916558.44963", 394
    .const 'Sub' $P9038 = "474_1306916577.75068" 
    $P9036."add_method"($P9037, "blockoid", $P9038)
    nqp_get_sc_object $P9039, "1306916558.44963", 394
    get_how $P9040, $P9039
    nqp_get_sc_object $P9041, "1306916558.44963", 394
    .const 'Sub' $P9042 = "476_1306916577.75068" 
    $P9040."add_method"($P9041, "newpad", $P9042)
    nqp_get_sc_object $P9043, "1306916558.44963", 394
    get_how $P9044, $P9043
    nqp_get_sc_object $P9045, "1306916558.44963", 394
    .const 'Sub' $P9046 = "477_1306916577.75068" 
    $P9044."add_method"($P9045, "outerctx", $P9046)
    nqp_get_sc_object $P9047, "1306916558.44963", 394
    get_how $P9048, $P9047
    nqp_get_sc_object $P9049, "1306916558.44963", 394
    .const 'Sub' $P9050 = "479_1306916577.75068" 
    $P9048."add_method"($P9049, "GLOBALish", $P9050)
    nqp_get_sc_object $P9051, "1306916558.44963", 394
    get_how $P9052, $P9051
    nqp_get_sc_object $P9053, "1306916558.44963", 394
    .const 'Sub' $P9054 = "480_1306916577.75068" 
    $P9052."add_method"($P9053, "you_are_here", $P9054)
    nqp_get_sc_object $P9055, "1306916558.44963", 394
    get_how $P9056, $P9055
    nqp_get_sc_object $P9057, "1306916558.44963", 394
    .const 'Sub' $P9058 = "481_1306916577.75068" 
    $P9056."add_method"($P9057, "statement_control:sym<use>", $P9058)
    nqp_get_sc_object $P9059, "1306916558.44963", 394
    get_how $P9060, $P9059
    nqp_get_sc_object $P9061, "1306916558.44963", 394
    .const 'Sub' $P9062 = "482_1306916577.75068" 
    $P9060."add_method"($P9061, "statement_control:sym<if>", $P9062)
    nqp_get_sc_object $P9063, "1306916558.44963", 394
    get_how $P9064, $P9063
    nqp_get_sc_object $P9065, "1306916558.44963", 394
    .const 'Sub' $P9066 = "484_1306916577.75068" 
    $P9064."add_method"($P9065, "statement_control:sym<unless>", $P9066)
    nqp_get_sc_object $P9067, "1306916558.44963", 394
    get_how $P9068, $P9067
    nqp_get_sc_object $P9069, "1306916558.44963", 394
    .const 'Sub' $P9070 = "485_1306916577.75068" 
    $P9068."add_method"($P9069, "statement_control:sym<while>", $P9070)
    nqp_get_sc_object $P9071, "1306916558.44963", 394
    get_how $P9072, $P9071
    nqp_get_sc_object $P9073, "1306916558.44963", 394
    .const 'Sub' $P9074 = "486_1306916577.75068" 
    $P9072."add_method"($P9073, "statement_control:sym<repeat>", $P9074)
    nqp_get_sc_object $P9075, "1306916558.44963", 394
    get_how $P9076, $P9075
    nqp_get_sc_object $P9077, "1306916558.44963", 394
    .const 'Sub' $P9078 = "487_1306916577.75068" 
    $P9076."add_method"($P9077, "statement_control:sym<for>", $P9078)
    nqp_get_sc_object $P9079, "1306916558.44963", 394
    get_how $P9080, $P9079
    nqp_get_sc_object $P9081, "1306916558.44963", 394
    .const 'Sub' $P9082 = "488_1306916577.75068" 
    $P9080."add_method"($P9081, "statement_control:sym<CATCH>", $P9082)
    nqp_get_sc_object $P9083, "1306916558.44963", 394
    get_how $P9084, $P9083
    nqp_get_sc_object $P9085, "1306916558.44963", 394
    .const 'Sub' $P9086 = "489_1306916577.75068" 
    $P9084."add_method"($P9085, "statement_control:sym<CONTROL>", $P9086)
    nqp_get_sc_object $P9087, "1306916558.44963", 394
    get_how $P9088, $P9087
    nqp_get_sc_object $P9089, "1306916558.44963", 394
    .const 'Sub' $P9090 = "490_1306916577.75068" 
    $P9088."add_method"($P9089, "statement_prefix:sym<INIT>", $P9090)
    nqp_get_sc_object $P9091, "1306916558.44963", 394
    get_how $P9092, $P9091
    nqp_get_sc_object $P9093, "1306916558.44963", 394
    .const 'Sub' $P9094 = "491_1306916577.75068" 
    $P9092."add_method"($P9093, "statement_prefix:sym<try>", $P9094)
    nqp_get_sc_object $P9095, "1306916558.44963", 394
    get_how $P9096, $P9095
    nqp_get_sc_object $P9097, "1306916558.44963", 394
    .const 'Sub' $P9098 = "492_1306916577.75068" 
    $P9096."add_method"($P9097, "blorst", $P9098)
    nqp_get_sc_object $P9099, "1306916558.44963", 394
    get_how $P9100, $P9099
    nqp_get_sc_object $P9101, "1306916558.44963", 394
    .const 'Sub' $P9102 = "493_1306916577.75068" 
    $P9100."add_method"($P9101, "statement_mod_cond:sym<if>", $P9102)
    nqp_get_sc_object $P9103, "1306916558.44963", 394
    get_how $P9104, $P9103
    nqp_get_sc_object $P9105, "1306916558.44963", 394
    .const 'Sub' $P9106 = "494_1306916577.75068" 
    $P9104."add_method"($P9105, "statement_mod_cond:sym<unless>", $P9106)
    nqp_get_sc_object $P9107, "1306916558.44963", 394
    get_how $P9108, $P9107
    nqp_get_sc_object $P9109, "1306916558.44963", 394
    .const 'Sub' $P9110 = "495_1306916577.75068" 
    $P9108."add_method"($P9109, "statement_mod_loop:sym<while>", $P9110)
    nqp_get_sc_object $P9111, "1306916558.44963", 394
    get_how $P9112, $P9111
    nqp_get_sc_object $P9113, "1306916558.44963", 394
    .const 'Sub' $P9114 = "496_1306916577.75068" 
    $P9112."add_method"($P9113, "statement_mod_loop:sym<until>", $P9114)
    nqp_get_sc_object $P9115, "1306916558.44963", 394
    get_how $P9116, $P9115
    nqp_get_sc_object $P9117, "1306916558.44963", 394
    .const 'Sub' $P9118 = "497_1306916577.75068" 
    $P9116."add_method"($P9117, "term:sym<fatarrow>", $P9118)
    nqp_get_sc_object $P9119, "1306916558.44963", 394
    get_how $P9120, $P9119
    nqp_get_sc_object $P9121, "1306916558.44963", 394
    .const 'Sub' $P9122 = "498_1306916577.75068" 
    $P9120."add_method"($P9121, "term:sym<colonpair>", $P9122)
    nqp_get_sc_object $P9123, "1306916558.44963", 394
    get_how $P9124, $P9123
    nqp_get_sc_object $P9125, "1306916558.44963", 394
    .const 'Sub' $P9126 = "499_1306916577.75068" 
    $P9124."add_method"($P9125, "term:sym<variable>", $P9126)
    nqp_get_sc_object $P9127, "1306916558.44963", 394
    get_how $P9128, $P9127
    nqp_get_sc_object $P9129, "1306916558.44963", 394
    .const 'Sub' $P9130 = "500_1306916577.75068" 
    $P9128."add_method"($P9129, "term:sym<package_declarator>", $P9130)
    nqp_get_sc_object $P9131, "1306916558.44963", 394
    get_how $P9132, $P9131
    nqp_get_sc_object $P9133, "1306916558.44963", 394
    .const 'Sub' $P9134 = "501_1306916577.75068" 
    $P9132."add_method"($P9133, "term:sym<scope_declarator>", $P9134)
    nqp_get_sc_object $P9135, "1306916558.44963", 394
    get_how $P9136, $P9135
    nqp_get_sc_object $P9137, "1306916558.44963", 394
    .const 'Sub' $P9138 = "502_1306916577.75068" 
    $P9136."add_method"($P9137, "term:sym<routine_declarator>", $P9138)
    nqp_get_sc_object $P9139, "1306916558.44963", 394
    get_how $P9140, $P9139
    nqp_get_sc_object $P9141, "1306916558.44963", 394
    .const 'Sub' $P9142 = "503_1306916577.75068" 
    $P9140."add_method"($P9141, "term:sym<regex_declarator>", $P9142)
    nqp_get_sc_object $P9143, "1306916558.44963", 394
    get_how $P9144, $P9143
    nqp_get_sc_object $P9145, "1306916558.44963", 394
    .const 'Sub' $P9146 = "504_1306916577.75068" 
    $P9144."add_method"($P9145, "term:sym<statement_prefix>", $P9146)
    nqp_get_sc_object $P9147, "1306916558.44963", 394
    get_how $P9148, $P9147
    nqp_get_sc_object $P9149, "1306916558.44963", 394
    .const 'Sub' $P9150 = "505_1306916577.75068" 
    $P9148."add_method"($P9149, "term:sym<lambda>", $P9150)
    nqp_get_sc_object $P9151, "1306916558.44963", 394
    get_how $P9152, $P9151
    nqp_get_sc_object $P9153, "1306916558.44963", 394
    .const 'Sub' $P9154 = "506_1306916577.75068" 
    $P9152."add_method"($P9153, "fatarrow", $P9154)
    nqp_get_sc_object $P9155, "1306916558.44963", 394
    get_how $P9156, $P9155
    nqp_get_sc_object $P9157, "1306916558.44963", 394
    .const 'Sub' $P9158 = "507_1306916577.75068" 
    $P9156."add_method"($P9157, "colonpair", $P9158)
    nqp_get_sc_object $P9159, "1306916558.44963", 394
    get_how $P9160, $P9159
    nqp_get_sc_object $P9161, "1306916558.44963", 394
    .const 'Sub' $P9162 = "508_1306916577.75068" 
    $P9160."add_method"($P9161, "variable", $P9162)
    nqp_get_sc_object $P9163, "1306916558.44963", 394
    get_how $P9164, $P9163
    nqp_get_sc_object $P9165, "1306916558.44963", 394
    .const 'Sub' $P9166 = "514_1306916577.75068" 
    $P9164."add_method"($P9165, "package_declarator:sym<module>", $P9166)
    nqp_get_sc_object $P9167, "1306916558.44963", 394
    get_how $P9168, $P9167
    nqp_get_sc_object $P9169, "1306916558.44963", 394
    .const 'Sub' $P9170 = "515_1306916577.75068" 
    $P9168."add_method"($P9169, "package_declarator:sym<knowhow>", $P9170)
    nqp_get_sc_object $P9171, "1306916558.44963", 394
    get_how $P9172, $P9171
    nqp_get_sc_object $P9173, "1306916558.44963", 394
    .const 'Sub' $P9174 = "516_1306916577.75068" 
    $P9172."add_method"($P9173, "package_declarator:sym<class>", $P9174)
    nqp_get_sc_object $P9175, "1306916558.44963", 394
    get_how $P9176, $P9175
    nqp_get_sc_object $P9177, "1306916558.44963", 394
    .const 'Sub' $P9178 = "517_1306916577.75068" 
    $P9176."add_method"($P9177, "package_declarator:sym<grammar>", $P9178)
    nqp_get_sc_object $P9179, "1306916558.44963", 394
    get_how $P9180, $P9179
    nqp_get_sc_object $P9181, "1306916558.44963", 394
    .const 'Sub' $P9182 = "518_1306916577.75068" 
    $P9180."add_method"($P9181, "package_declarator:sym<role>", $P9182)
    nqp_get_sc_object $P9183, "1306916558.44963", 394
    get_how $P9184, $P9183
    nqp_get_sc_object $P9185, "1306916558.44963", 394
    .const 'Sub' $P9186 = "519_1306916577.75068" 
    $P9184."add_method"($P9185, "package_declarator:sym<native>", $P9186)
    nqp_get_sc_object $P9187, "1306916558.44963", 394
    get_how $P9188, $P9187
    nqp_get_sc_object $P9189, "1306916558.44963", 394
    .const 'Sub' $P9190 = "520_1306916577.75068" 
    $P9188."add_method"($P9189, "package_declarator:sym<stub>", $P9190)
    nqp_get_sc_object $P9191, "1306916558.44963", 394
    get_how $P9192, $P9191
    nqp_get_sc_object $P9193, "1306916558.44963", 394
    .const 'Sub' $P9194 = "521_1306916577.75068" 
    $P9192."add_method"($P9193, "package_def", $P9194)
    nqp_get_sc_object $P9195, "1306916558.44963", 394
    get_how $P9196, $P9195
    nqp_get_sc_object $P9197, "1306916558.44963", 394
    .const 'Sub' $P9198 = "527_1306916577.75068" 
    $P9196."add_method"($P9197, "scope_declarator:sym<my>", $P9198)
    nqp_get_sc_object $P9199, "1306916558.44963", 394
    get_how $P9200, $P9199
    nqp_get_sc_object $P9201, "1306916558.44963", 394
    .const 'Sub' $P9202 = "528_1306916577.75068" 
    $P9200."add_method"($P9201, "scope_declarator:sym<our>", $P9202)
    nqp_get_sc_object $P9203, "1306916558.44963", 394
    get_how $P9204, $P9203
    nqp_get_sc_object $P9205, "1306916558.44963", 394
    .const 'Sub' $P9206 = "529_1306916577.75068" 
    $P9204."add_method"($P9205, "scope_declarator:sym<has>", $P9206)
    nqp_get_sc_object $P9207, "1306916558.44963", 394
    get_how $P9208, $P9207
    nqp_get_sc_object $P9209, "1306916558.44963", 394
    .const 'Sub' $P9210 = "530_1306916577.75068" 
    $P9208."add_method"($P9209, "scoped", $P9210)
    nqp_get_sc_object $P9211, "1306916558.44963", 394
    get_how $P9212, $P9211
    nqp_get_sc_object $P9213, "1306916558.44963", 394
    .const 'Sub' $P9214 = "531_1306916577.75068" 
    $P9212."add_method"($P9213, "declarator", $P9214)
    nqp_get_sc_object $P9215, "1306916558.44963", 394
    get_how $P9216, $P9215
    nqp_get_sc_object $P9217, "1306916558.44963", 394
    .const 'Sub' $P9218 = "532_1306916577.75068" 
    $P9216."add_method"($P9217, "multi_declarator:sym<multi>", $P9218)
    nqp_get_sc_object $P9219, "1306916558.44963", 394
    get_how $P9220, $P9219
    nqp_get_sc_object $P9221, "1306916558.44963", 394
    .const 'Sub' $P9222 = "533_1306916577.75068" 
    $P9220."add_method"($P9221, "multi_declarator:sym<proto>", $P9222)
    nqp_get_sc_object $P9223, "1306916558.44963", 394
    get_how $P9224, $P9223
    nqp_get_sc_object $P9225, "1306916558.44963", 394
    .const 'Sub' $P9226 = "534_1306916577.75068" 
    $P9224."add_method"($P9225, "multi_declarator:sym<null>", $P9226)
    nqp_get_sc_object $P9227, "1306916558.44963", 394
    get_how $P9228, $P9227
    nqp_get_sc_object $P9229, "1306916558.44963", 394
    .const 'Sub' $P9230 = "535_1306916577.75068" 
    $P9228."add_method"($P9229, "variable_declarator", $P9230)
    nqp_get_sc_object $P9231, "1306916558.44963", 394
    get_how $P9232, $P9231
    nqp_get_sc_object $P9233, "1306916558.44963", 394
    .const 'Sub' $P9234 = "538_1306916577.75068" 
    $P9232."add_method"($P9233, "routine_declarator:sym<sub>", $P9234)
    nqp_get_sc_object $P9235, "1306916558.44963", 394
    get_how $P9236, $P9235
    nqp_get_sc_object $P9237, "1306916558.44963", 394
    .const 'Sub' $P9238 = "539_1306916577.75068" 
    $P9236."add_method"($P9237, "routine_declarator:sym<method>", $P9238)
    nqp_get_sc_object $P9239, "1306916558.44963", 394
    get_how $P9240, $P9239
    nqp_get_sc_object $P9241, "1306916558.44963", 394
    .const 'Sub' $P9242 = "540_1306916577.75068" 
    $P9240."add_method"($P9241, "routine_def", $P9242)
    nqp_get_sc_object $P9243, "1306916558.44963", 394
    get_how $P9244, $P9243
    nqp_get_sc_object $P9245, "1306916558.44963", 394
    .const 'Sub' $P9246 = "547_1306916577.75068" 
    $P9244."add_method"($P9245, "method_def", $P9246)
    nqp_get_sc_object $P9247, "1306916558.44963", 394
    get_how $P9248, $P9247
    nqp_get_sc_object $P9249, "1306916558.44963", 394
    .const 'Sub' $P9250 = "550_1306916577.75068" 
    $P9248."add_method"($P9249, "signature", $P9250)
    nqp_get_sc_object $P9251, "1306916558.44963", 394
    get_how $P9252, $P9251
    nqp_get_sc_object $P9253, "1306916558.44963", 394
    .const 'Sub' $P9254 = "553_1306916577.75068" 
    $P9252."add_method"($P9253, "parameter", $P9254)
    nqp_get_sc_object $P9255, "1306916558.44963", 394
    get_how $P9256, $P9255
    nqp_get_sc_object $P9257, "1306916558.44963", 394
    .const 'Sub' $P9258 = "554_1306916577.75068" 
    $P9256."add_method"($P9257, "param_var", $P9258)
    nqp_get_sc_object $P9259, "1306916558.44963", 394
    get_how $P9260, $P9259
    nqp_get_sc_object $P9261, "1306916558.44963", 394
    .const 'Sub' $P9262 = "555_1306916577.75068" 
    $P9260."add_method"($P9261, "named_param", $P9262)
    nqp_get_sc_object $P9263, "1306916558.44963", 394
    get_how $P9264, $P9263
    nqp_get_sc_object $P9265, "1306916558.44963", 394
    .const 'Sub' $P9266 = "556_1306916577.75068" 
    $P9264."add_method"($P9265, "typename", $P9266)
    nqp_get_sc_object $P9267, "1306916558.44963", 394
    get_how $P9268, $P9267
    nqp_get_sc_object $P9269, "1306916558.44963", 394
    .const 'Sub' $P9270 = "558_1306916577.75068" 
    $P9268."add_method"($P9269, "trait", $P9270)
    nqp_get_sc_object $P9271, "1306916558.44963", 394
    get_how $P9272, $P9271
    nqp_get_sc_object $P9273, "1306916558.44963", 394
    .const 'Sub' $P9274 = "559_1306916577.75068" 
    $P9272."add_method"($P9273, "trait_mod:sym<is>", $P9274)
    nqp_get_sc_object $P9275, "1306916558.44963", 394
    get_how $P9276, $P9275
    nqp_get_sc_object $P9277, "1306916558.44963", 394
    .const 'Sub' $P9278 = "564_1306916577.75068" 
    $P9276."add_method"($P9277, "regex_declarator", $P9278)
    nqp_get_sc_object $P9279, "1306916558.44963", 394
    get_how $P9280, $P9279
    nqp_get_sc_object $P9281, "1306916558.44963", 394
    .const 'Sub' $P9282 = "569_1306916577.75068" 
    $P9280."add_method"($P9281, "dotty", $P9282)
    nqp_get_sc_object $P9283, "1306916558.44963", 394
    get_how $P9284, $P9283
    nqp_get_sc_object $P9285, "1306916558.44963", 394
    .const 'Sub' $P9286 = "570_1306916577.75068" 
    $P9284."add_method"($P9285, "term:sym<self>", $P9286)
    nqp_get_sc_object $P9287, "1306916558.44963", 394
    get_how $P9288, $P9287
    nqp_get_sc_object $P9289, "1306916558.44963", 394
    .const 'Sub' $P9290 = "571_1306916577.75068" 
    $P9288."add_method"($P9289, "term:sym<identifier>", $P9290)
    nqp_get_sc_object $P9291, "1306916558.44963", 394
    get_how $P9292, $P9291
    nqp_get_sc_object $P9293, "1306916558.44963", 394
    .const 'Sub' $P9294 = "572_1306916577.75068" 
    $P9292."add_method"($P9293, "term:sym<name>", $P9294)
    nqp_get_sc_object $P9295, "1306916558.44963", 394
    get_how $P9296, $P9295
    nqp_get_sc_object $P9297, "1306916558.44963", 394
    .const 'Sub' $P9298 = "574_1306916577.75068" 
    $P9296."add_method"($P9297, "term:sym<pir::op>", $P9298)
    nqp_get_sc_object $P9299, "1306916558.44963", 394
    get_how $P9300, $P9299
    nqp_get_sc_object $P9301, "1306916558.44963", 394
    .const 'Sub' $P9302 = "575_1306916577.75068" 
    $P9300."add_method"($P9301, "term:sym<onlystar>", $P9302)
    nqp_get_sc_object $P9303, "1306916558.44963", 394
    get_how $P9304, $P9303
    nqp_get_sc_object $P9305, "1306916558.44963", 394
    .const 'Sub' $P9306 = "576_1306916577.75068" 
    $P9304."add_method"($P9305, "args", $P9306)
    nqp_get_sc_object $P9307, "1306916558.44963", 394
    get_how $P9308, $P9307
    nqp_get_sc_object $P9309, "1306916558.44963", 394
    .const 'Sub' $P9310 = "577_1306916577.75068" 
    $P9308."add_method"($P9309, "arglist", $P9310)
    nqp_get_sc_object $P9311, "1306916558.44963", 394
    get_how $P9312, $P9311
    nqp_get_sc_object $P9313, "1306916558.44963", 394
    .const 'Sub' $P9314 = "580_1306916577.75068" 
    $P9312."add_method"($P9313, "term:sym<multi_declarator>", $P9314)
    nqp_get_sc_object $P9315, "1306916558.44963", 394
    get_how $P9316, $P9315
    nqp_get_sc_object $P9317, "1306916558.44963", 394
    .const 'Sub' $P9318 = "581_1306916577.75068" 
    $P9316."add_method"($P9317, "term:sym<value>", $P9318)
    nqp_get_sc_object $P9319, "1306916558.44963", 394
    get_how $P9320, $P9319
    nqp_get_sc_object $P9321, "1306916558.44963", 394
    .const 'Sub' $P9322 = "582_1306916577.75068" 
    $P9320."add_method"($P9321, "circumfix:sym<( )>", $P9322)
    nqp_get_sc_object $P9323, "1306916558.44963", 394
    get_how $P9324, $P9323
    nqp_get_sc_object $P9325, "1306916558.44963", 394
    .const 'Sub' $P9326 = "583_1306916577.75068" 
    $P9324."add_method"($P9325, "circumfix:sym<[ ]>", $P9326)
    nqp_get_sc_object $P9327, "1306916558.44963", 394
    get_how $P9328, $P9327
    nqp_get_sc_object $P9329, "1306916558.44963", 394
    .const 'Sub' $P9330 = "584_1306916577.75068" 
    $P9328."add_method"($P9329, "circumfix:sym<ang>", $P9330)
    nqp_get_sc_object $P9331, "1306916558.44963", 394
    get_how $P9332, $P9331
    nqp_get_sc_object $P9333, "1306916558.44963", 394
    .const 'Sub' $P9334 = "585_1306916577.75068" 
    $P9332."add_method"($P9333, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P9334)
    nqp_get_sc_object $P9335, "1306916558.44963", 394
    get_how $P9336, $P9335
    nqp_get_sc_object $P9337, "1306916558.44963", 394
    .const 'Sub' $P9338 = "586_1306916577.75068" 
    $P9336."add_method"($P9337, "circumfix:sym<{ }>", $P9338)
    nqp_get_sc_object $P9339, "1306916558.44963", 394
    get_how $P9340, $P9339
    nqp_get_sc_object $P9341, "1306916558.44963", 394
    .const 'Sub' $P9342 = "588_1306916577.75068" 
    $P9340."add_method"($P9341, "circumfix:sym<sigil>", $P9342)
    nqp_get_sc_object $P9343, "1306916558.44963", 394
    get_how $P9344, $P9343
    nqp_get_sc_object $P9345, "1306916558.44963", 394
    .const 'Sub' $P9346 = "589_1306916577.75068" 
    $P9344."add_method"($P9345, "semilist", $P9346)
    nqp_get_sc_object $P9347, "1306916558.44963", 394
    get_how $P9348, $P9347
    nqp_get_sc_object $P9349, "1306916558.44963", 394
    .const 'Sub' $P9350 = "590_1306916577.75068" 
    $P9348."add_method"($P9349, "postcircumfix:sym<[ ]>", $P9350)
    nqp_get_sc_object $P9351, "1306916558.44963", 394
    get_how $P9352, $P9351
    nqp_get_sc_object $P9353, "1306916558.44963", 394
    .const 'Sub' $P9354 = "591_1306916577.75068" 
    $P9352."add_method"($P9353, "postcircumfix:sym<{ }>", $P9354)
    nqp_get_sc_object $P9355, "1306916558.44963", 394
    get_how $P9356, $P9355
    nqp_get_sc_object $P9357, "1306916558.44963", 394
    .const 'Sub' $P9358 = "592_1306916577.75068" 
    $P9356."add_method"($P9357, "postcircumfix:sym<ang>", $P9358)
    nqp_get_sc_object $P9359, "1306916558.44963", 394
    get_how $P9360, $P9359
    nqp_get_sc_object $P9361, "1306916558.44963", 394
    .const 'Sub' $P9362 = "593_1306916577.75068" 
    $P9360."add_method"($P9361, "postcircumfix:sym<( )>", $P9362)
    nqp_get_sc_object $P9363, "1306916558.44963", 394
    get_how $P9364, $P9363
    nqp_get_sc_object $P9365, "1306916558.44963", 394
    .const 'Sub' $P9366 = "594_1306916577.75068" 
    $P9364."add_method"($P9365, "value", $P9366)
    nqp_get_sc_object $P9367, "1306916558.44963", 394
    get_how $P9368, $P9367
    nqp_get_sc_object $P9369, "1306916558.44963", 394
    .const 'Sub' $P9370 = "595_1306916577.75068" 
    $P9368."add_method"($P9369, "number", $P9370)
    nqp_get_sc_object $P9371, "1306916558.44963", 394
    get_how $P9372, $P9371
    nqp_get_sc_object $P9373, "1306916558.44963", 394
    .const 'Sub' $P9374 = "596_1306916577.75068" 
    $P9372."add_method"($P9373, "quote:sym<apos>", $P9374)
    nqp_get_sc_object $P9375, "1306916558.44963", 394
    get_how $P9376, $P9375
    nqp_get_sc_object $P9377, "1306916558.44963", 394
    .const 'Sub' $P9378 = "597_1306916577.75068" 
    $P9376."add_method"($P9377, "quote:sym<dblq>", $P9378)
    nqp_get_sc_object $P9379, "1306916558.44963", 394
    get_how $P9380, $P9379
    nqp_get_sc_object $P9381, "1306916558.44963", 394
    .const 'Sub' $P9382 = "598_1306916577.75068" 
    $P9380."add_method"($P9381, "quote:sym<qq>", $P9382)
    nqp_get_sc_object $P9383, "1306916558.44963", 394
    get_how $P9384, $P9383
    nqp_get_sc_object $P9385, "1306916558.44963", 394
    .const 'Sub' $P9386 = "599_1306916577.75068" 
    $P9384."add_method"($P9385, "quote:sym<q>", $P9386)
    nqp_get_sc_object $P9387, "1306916558.44963", 394
    get_how $P9388, $P9387
    nqp_get_sc_object $P9389, "1306916558.44963", 394
    .const 'Sub' $P9390 = "600_1306916577.75068" 
    $P9388."add_method"($P9389, "quote:sym<Q>", $P9390)
    nqp_get_sc_object $P9391, "1306916558.44963", 394
    get_how $P9392, $P9391
    nqp_get_sc_object $P9393, "1306916558.44963", 394
    .const 'Sub' $P9394 = "601_1306916577.75068" 
    $P9392."add_method"($P9393, "quote:sym<Q:PIR>", $P9394)
    nqp_get_sc_object $P9395, "1306916558.44963", 394
    get_how $P9396, $P9395
    nqp_get_sc_object $P9397, "1306916558.44963", 394
    .const 'Sub' $P9398 = "602_1306916577.75068" 
    $P9396."add_method"($P9397, "quote:sym</ />", $P9398)
    nqp_get_sc_object $P9399, "1306916558.44963", 394
    get_how $P9400, $P9399
    nqp_get_sc_object $P9401, "1306916558.44963", 394
    .const 'Sub' $P9402 = "603_1306916577.75068" 
    $P9400."add_method"($P9401, "quote_escape:sym<$>", $P9402)
    nqp_get_sc_object $P9403, "1306916558.44963", 394
    get_how $P9404, $P9403
    nqp_get_sc_object $P9405, "1306916558.44963", 394
    .const 'Sub' $P9406 = "604_1306916577.75068" 
    $P9404."add_method"($P9405, "quote_escape:sym<{ }>", $P9406)
    nqp_get_sc_object $P9407, "1306916558.44963", 394
    get_how $P9408, $P9407
    nqp_get_sc_object $P9409, "1306916558.44963", 394
    .const 'Sub' $P9410 = "605_1306916577.75068" 
    $P9408."add_method"($P9409, "quote_escape:sym<esc>", $P9410)
    nqp_get_sc_object $P9411, "1306916558.44963", 394
    get_how $P9412, $P9411
    nqp_get_sc_object $P9413, "1306916558.44963", 394
    .const 'Sub' $P9414 = "606_1306916577.75068" 
    $P9412."add_method"($P9413, "postfix:sym<.>", $P9414)
    nqp_get_sc_object $P9415, "1306916558.44963", 394
    get_how $P9416, $P9415
    nqp_get_sc_object $P9417, "1306916558.44963", 394
    .const 'Sub' $P9418 = "607_1306916577.75068" 
    $P9416."add_method"($P9417, "postfix:sym<++>", $P9418)
    nqp_get_sc_object $P9419, "1306916558.44963", 394
    get_how $P9420, $P9419
    nqp_get_sc_object $P9421, "1306916558.44963", 394
    .const 'Sub' $P9422 = "608_1306916577.75068" 
    $P9420."add_method"($P9421, "postfix:sym<-->", $P9422)
    nqp_get_sc_object $P9423, "1306916558.44963", 394
    get_how $P9424, $P9423
    nqp_get_sc_object $P9425, "1306916558.44963", 394
    .const 'Sub' $P9426 = "609_1306916577.75068" 
    $P9424."add_method"($P9425, "prefix:sym<make>", $P9426)
    nqp_get_sc_object $P9427, "1306916558.44963", 394
    get_how $P9428, $P9427
    nqp_get_sc_object $P9429, "1306916558.44963", 394
    .const 'Sub' $P9430 = "610_1306916577.75068" 
    $P9428."add_method"($P9429, "term:sym<next>", $P9430)
    nqp_get_sc_object $P9431, "1306916558.44963", 394
    get_how $P9432, $P9431
    nqp_get_sc_object $P9433, "1306916558.44963", 394
    .const 'Sub' $P9434 = "611_1306916577.75068" 
    $P9432."add_method"($P9433, "term:sym<last>", $P9434)
    nqp_get_sc_object $P9435, "1306916558.44963", 394
    get_how $P9436, $P9435
    nqp_get_sc_object $P9437, "1306916558.44963", 394
    .const 'Sub' $P9438 = "612_1306916577.75068" 
    $P9436."add_method"($P9437, "term:sym<redo>", $P9438)
    nqp_get_sc_object $P9439, "1306916558.44963", 394
    get_how $P9440, $P9439
    nqp_get_sc_object $P9441, "1306916558.44963", 394
    .const 'Sub' $P9442 = "613_1306916577.75068" 
    $P9440."add_method"($P9441, "infix:sym<~~>", $P9442)
    nqp_get_sc_object $P9443, "1306916558.44963", 394
    get_how $P9444, $P9443
    nqp_get_sc_object $P9445, "1306916558.44963", 394
    .const 'Sub' $P9446 = "614_1306916577.75068" 
    $P9444."add_method"($P9445, "known_sym", $P9446)
    .const 'Sub' $P9447 = "436_1306916577.75068" 
    $P9448 = $P9447."get_lexinfo"()
    nqp_get_sc_object $P9449, "1306916558.44963", 394
    $P9448."set_static_lexpad_value"("$?PACKAGE", $P9449)
    .const 'Sub' $P9450 = "436_1306916577.75068" 
    $P9451 = $P9450."get_lexinfo"()
    $P9451."finish_static_lexpad"()
    .const 'Sub' $P9452 = "436_1306916577.75068" 
    $P9453 = $P9452."get_lexinfo"()
    nqp_get_sc_object $P9454, "1306916558.44963", 394
    $P9453."set_static_lexpad_value"("$?CLASS", $P9454)
    .const 'Sub' $P9455 = "436_1306916577.75068" 
    $P9456 = $P9455."get_lexinfo"()
    $P9456."finish_static_lexpad"()
    nqp_get_sc_object $P9457, "1306916558.44963", 394
    get_how $P9458, $P9457
    nqp_get_sc_object $P9459, "1306916558.44963", 394
    nqp_get_sc_object $P9460, "1306916536.11825", 105
    $P9458."add_parent"($P9459, $P9460)
    nqp_get_sc_object $P9461, "1306916558.44963", 394
    get_how $P9462, $P9461
    nqp_get_sc_object $P9463, "1306916558.44963", 394
    $P9462."compose"($P9463)
    nqp_get_sc_object $P9464, "1306916525.99765", 41
    $P9465 = $P9464."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P9465, cur_sc
    nqp_set_sc_object "1306916558.44963", 506, $P9465
    nqp_get_sc_object $P9466, "1306916558.44963", 506
    nqp_get_sc_object $P9467, "1306916558.44963", 0
    nqp_get_package_through_who $P9468, $P9467, "NQP"
    get_who $P9469, $P9468
    set $P9469["RegexActions"], $P9466
    nqp_get_sc_object $P9470, "1306916558.44963", 506
    get_how $P9471, $P9470
    nqp_get_sc_object $P9472, "1306916558.44963", 506
    .const 'Sub' $P9473 = "617_1306916577.75068" 
    $P9471."add_method"($P9472, "metachar:sym<:my>", $P9473)
    nqp_get_sc_object $P9474, "1306916558.44963", 506
    get_how $P9475, $P9474
    nqp_get_sc_object $P9476, "1306916558.44963", 506
    .const 'Sub' $P9477 = "618_1306916577.75068" 
    $P9475."add_method"($P9476, "metachar:sym<{ }>", $P9477)
    nqp_get_sc_object $P9478, "1306916558.44963", 506
    get_how $P9479, $P9478
    nqp_get_sc_object $P9480, "1306916558.44963", 506
    .const 'Sub' $P9481 = "619_1306916577.75068" 
    $P9479."add_method"($P9480, "metachar:sym<nqpvar>", $P9481)
    nqp_get_sc_object $P9482, "1306916558.44963", 506
    get_how $P9483, $P9482
    nqp_get_sc_object $P9484, "1306916558.44963", 506
    .const 'Sub' $P9485 = "620_1306916577.75068" 
    $P9483."add_method"($P9484, "assertion:sym<{ }>", $P9485)
    nqp_get_sc_object $P9486, "1306916558.44963", 506
    get_how $P9487, $P9486
    nqp_get_sc_object $P9488, "1306916558.44963", 506
    .const 'Sub' $P9489 = "621_1306916577.75068" 
    $P9487."add_method"($P9488, "assertion:sym<?{ }>", $P9489)
    nqp_get_sc_object $P9490, "1306916558.44963", 506
    get_how $P9491, $P9490
    nqp_get_sc_object $P9492, "1306916558.44963", 506
    .const 'Sub' $P9493 = "622_1306916577.75068" 
    $P9491."add_method"($P9492, "assertion:sym<var>", $P9493)
    nqp_get_sc_object $P9494, "1306916558.44963", 506
    get_how $P9495, $P9494
    nqp_get_sc_object $P9496, "1306916558.44963", 506
    .const 'Sub' $P9497 = "623_1306916577.75068" 
    $P9495."add_method"($P9496, "codeblock", $P9497)
    .const 'Sub' $P9498 = "616_1306916577.75068" 
    $P9499 = $P9498."get_lexinfo"()
    nqp_get_sc_object $P9500, "1306916558.44963", 506
    $P9499."set_static_lexpad_value"("$?PACKAGE", $P9500)
    .const 'Sub' $P9501 = "616_1306916577.75068" 
    $P9502 = $P9501."get_lexinfo"()
    $P9502."finish_static_lexpad"()
    .const 'Sub' $P9503 = "616_1306916577.75068" 
    $P9504 = $P9503."get_lexinfo"()
    nqp_get_sc_object $P9505, "1306916558.44963", 506
    $P9504."set_static_lexpad_value"("$?CLASS", $P9505)
    .const 'Sub' $P9506 = "616_1306916577.75068" 
    $P9507 = $P9506."get_lexinfo"()
    $P9507."finish_static_lexpad"()
    nqp_get_sc_object $P9508, "1306916558.44963", 506
    get_how $P9509, $P9508
    nqp_get_sc_object $P9510, "1306916558.44963", 506
    nqp_get_sc_object $P9511, "1306916549.32795", 145
    $P9509."add_parent"($P9510, $P9511)
    nqp_get_sc_object $P9512, "1306916558.44963", 506
    get_how $P9513, $P9512
    nqp_get_sc_object $P9514, "1306916558.44963", 506
    $P9513."compose"($P9514)
    nqp_get_sc_object $P9515, "1306916525.99765", 41
    $P9516 = $P9515."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P9516, cur_sc
    nqp_set_sc_object "1306916558.44963", 514, $P9516
    nqp_get_sc_object $P9517, "1306916558.44963", 514
    nqp_get_sc_object $P9518, "1306916558.44963", 0
    nqp_get_package_through_who $P9519, $P9518, "NQP"
    get_who $P9520, $P9519
    set $P9520["Compiler"], $P9517
    .const 'Sub' $P9521 = "624_1306916577.75068" 
    $P9522 = $P9521."get_lexinfo"()
    nqp_get_sc_object $P9523, "1306916558.44963", 514
    $P9522."set_static_lexpad_value"("$?PACKAGE", $P9523)
    .const 'Sub' $P9524 = "624_1306916577.75068" 
    $P9525 = $P9524."get_lexinfo"()
    $P9525."finish_static_lexpad"()
    .const 'Sub' $P9526 = "624_1306916577.75068" 
    $P9527 = $P9526."get_lexinfo"()
    nqp_get_sc_object $P9528, "1306916558.44963", 514
    $P9527."set_static_lexpad_value"("$?CLASS", $P9528)
    .const 'Sub' $P9529 = "624_1306916577.75068" 
    $P9530 = $P9529."get_lexinfo"()
    $P9530."finish_static_lexpad"()
    nqp_get_sc_object $P9531, "1306916558.44963", 514
    get_how $P9532, $P9531
    nqp_get_sc_object $P9533, "1306916558.44963", 514
    nqp_get_sc_object $P9534, "1306916536.11825", 138
    $P9532."add_parent"($P9533, $P9534)
    nqp_get_sc_object $P9535, "1306916558.44963", 514
    get_how $P9536, $P9535
    nqp_get_sc_object $P9537, "1306916558.44963", 514
    $P9536."compose"($P9537)
  if_7343_end:
    nqp_get_sc_object $P10624, "1306916558.44963", 0
    set_hll_global "GLOBAL", $P10624
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1306916577.75068") :outer("10_1306916577.75068")
    .param pmc param_17
.annotate 'line', 2758
    .lex "@ARGS", param_17
.annotate 'line', 2760
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2767
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2760
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2761
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_627
    new $P25, "Undef"
  vivify_627:
    $P25."language"("nqp")
.annotate 'line', 2762
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_628
    new $P26, "Undef"
  vivify_628:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2763
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_629
    new $P31, "Undef"
  vivify_629:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2764
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_630
    new $P36, "Undef"
  vivify_630:
    $P37 = $P36."config"()
    "hll-config"($P37)
.annotate 'line', 2767
    find_lex $P38, "$nqpcomp"
    unless_null $P38, vivify_631
    new $P38, "Undef"
  vivify_631:
    $P39 = $P38."commandline_options"()
    store_lex "@clo", $P39
.annotate 'line', 2768
    find_lex $P40, "@clo"
    unless_null $P40, vivify_632
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_632:
    $P40."push"("parsetrace")
.annotate 'line', 2769
    find_lex $P41, "@clo"
    unless_null $P41, vivify_633
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_633:
    $P41."push"("setting=s")
.annotate 'line', 2770
    find_lex $P42, "@clo"
    unless_null $P42, vivify_634
    $P42 = root_new ['parrot';'ResizablePMCArray']
  vivify_634:
    $P42."push"("setting-path=s")
.annotate 'line', 2771
    find_lex $P43, "@clo"
    unless_null $P43, vivify_635
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_635:
    $P43."push"("module-path=s")
.annotate 'line', 2772
    find_lex $P44, "@clo"
    unless_null $P44, vivify_636
    $P44 = root_new ['parrot';'ResizablePMCArray']
  vivify_636:
    $P44."push"("vmlibs=s")
.annotate 'line', 2775
    find_lex $P45, "$nqpcomp"
    unless_null $P45, vivify_637
    new $P45, "Undef"
  vivify_637:
    find_lex $P46, "@ARGS"
    unless_null $P46, vivify_638
    $P46 = root_new ['parrot';'ResizablePMCArray']
  vivify_638:
    $P47 = $P45."command_line"($P46, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2758
    .return ($P47)
.end


.HLL "nqp"

.namespace []
.sub "hll-config"  :subid("12_1306916577.75068") :outer("10_1306916577.75068")
    .param pmc param_50
.annotate 'line', 2779
    .lex "$config", param_50
.annotate 'line', 2780
    new $P51, "String"
    assign $P51, "2011.05-2-g35337e6"
    find_lex $P52, "$config"
    unless_null $P52, vivify_639
    $P52 = root_new ['parrot';'Hash']
    store_lex "$config", $P52
  vivify_639:
    set $P52["version"], $P51
.annotate 'line', 2781
    new $P53, "String"
    assign $P53, "2011-06-01T08:22:38Z"
    find_lex $P54, "$config"
    unless_null $P54, vivify_640
    $P54 = root_new ['parrot';'Hash']
    store_lex "$config", $P54
  vivify_640:
    set $P54["build-date"], $P53
.annotate 'line', 2779
    .return ($P53)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block56"  :subid("13_1306916577.75068") :outer("10_1306916577.75068")
.annotate 'line', 9
    .const 'Sub' $P875 = "38_1306916577.75068" 
    capture_lex $P875
    .const 'Sub' $P851 = "37_1306916577.75068" 
    capture_lex $P851
    .const 'Sub' $P821 = "36_1306916577.75068" 
    capture_lex $P821
    .const 'Sub' $P788 = "35_1306916577.75068" 
    capture_lex $P788
    .const 'Sub' $P673 = "30_1306916577.75068" 
    capture_lex $P673
    .const 'Sub' $P626 = "29_1306916577.75068" 
    capture_lex $P626
    .const 'Sub' $P498 = "26_1306916577.75068" 
    capture_lex $P498
    .const 'Sub' $P413 = "23_1306916577.75068" 
    capture_lex $P413
    .const 'Sub' $P336 = "22_1306916577.75068" 
    capture_lex $P336
    .const 'Sub' $P300 = "21_1306916577.75068" 
    capture_lex $P300
    .const 'Sub' $P237 = "20_1306916577.75068" 
    capture_lex $P237
    .const 'Sub' $P161 = "17_1306916577.75068" 
    capture_lex $P161
    .const 'Sub' $P120 = "16_1306916577.75068" 
    capture_lex $P120
    .const 'Sub' $P62 = "14_1306916577.75068" 
    capture_lex $P62
.annotate 'line', 14
    new $P58, "Undef"
    .lex "$loader", $P58
    .lex "$?PACKAGE", $P59
    .lex "$?CLASS", $P60
    get_hll_global $P61, "ModuleLoader"
    store_lex "$loader", $P61
.annotate 'line', 401
    .const 'Sub' $P875 = "38_1306916577.75068" 
    newclosure $P984, $P875
.annotate 'line', 9
    .return ($P984)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_setting" :anon :subid("14_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_65
    .param pmc param_66
.annotate 'line', 17
    .const 'Sub' $P73 = "15_1306916577.75068" 
    capture_lex $P73
    new $P64, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P64, control_63
    push_eh $P64
    .lex "self", param_65
    .lex "$setting_name", param_66
.annotate 'line', 19
    find_lex $P69, "$setting_name"
    unless_null $P69, vivify_641
    new $P69, "Undef"
  vivify_641:
    set $S70, $P69
    isne $I71, $S70, "NULL"
    if $I71, if_68
    new $P67, 'Integer'
    set $P67, $I71
    goto if_68_end
  if_68:
    .const 'Sub' $P73 = "15_1306916577.75068" 
    capture_lex $P73
    $P118 = $P73()
    set $P67, $P118
  if_68_end:
.annotate 'line', 17
    .return ($P67)
  control_63:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P119, exception, "payload"
    .return ($P119)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block72"  :anon :subid("15_1306916577.75068") :outer("14_1306916577.75068")
.annotate 'line', 23
    new $P74, "Undef"
    .lex "$setting", $P74
.annotate 'line', 24
    find_lex $P75, "$loader"
    unless_null $P75, vivify_642
    new $P75, "Undef"
  vivify_642:
    find_lex $P76, "$setting_name"
    unless_null $P76, vivify_643
    new $P76, "Undef"
  vivify_643:
    $P77 = $P75."load_setting"($P76)
    find_dynamic_lex $P80, "%*COMPILING"
    unless_null $P80, vivify_644
    get_hll_global $P78, "GLOBAL"
    get_who $P79, $P78
    set $P80, $P79["%COMPILING"]
    unless_null $P80, vivify_645
    die "Contextual %*COMPILING not found"
  vivify_645:
    store_dynamic_lex "%*COMPILING", $P80
  vivify_644:
    set $P81, $P80["%?OPTIONS"]
    unless_null $P81, vivify_646
    $P81 = root_new ['parrot';'Hash']
    set $P80["%?OPTIONS"], $P81
  vivify_646:
    set $P81["outer_ctx"], $P77
    store_lex "$setting", $P77
.annotate 'line', 27
    find_lex $P82, "self"
    get_hll_global $P83, "GLOBAL"
    nqp_get_package_through_who $P84, $P83, "PAST"
    get_who $P85, $P84
    set $P86, $P85["Stmts"]
.annotate 'line', 28
    get_hll_global $P87, "GLOBAL"
    nqp_get_package_through_who $P88, $P87, "PAST"
    get_who $P89, $P88
    set $P90, $P89["Op"]
    $P91 = $P90."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 31
    get_hll_global $P92, "GLOBAL"
    nqp_get_package_through_who $P93, $P92, "PAST"
    get_who $P94, $P93
    set $P95, $P94["Op"]
.annotate 'line', 33
    get_hll_global $P96, "GLOBAL"
    nqp_get_package_through_who $P97, $P96, "PAST"
    get_who $P98, $P97
    set $P99, $P98["Var"]
    $P100 = $P99."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 34
    get_hll_global $P101, "GLOBAL"
    nqp_get_package_through_who $P102, $P101, "PAST"
    get_who $P103, $P102
    set $P104, $P103["Op"]
.annotate 'line', 36
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Var"]
    new $P109, "ResizablePMCArray"
    $P110 = $P108."new"("ModuleLoader" :named("name"), $P109 :named("namespace"), "package" :named("scope"))
    find_lex $P111, "$setting_name"
    unless_null $P111, vivify_647
    new $P111, "Undef"
  vivify_647:
    $P112 = $P104."new"($P110, $P111, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 34
    $P113 = $P95."new"($P100, $P112, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 31
    $P114 = $P86."new"($P91, $P113)
.annotate 'line', 27
    $P82."add_event"($P114 :named("deserialize_past"))
.annotate 'line', 42
    new $P115, "Exception"
    set $P115['type'], .CONTROL_RETURN
    find_lex $P116, "$setting"
    unless_null $P116, vivify_648
    new $P116, "Undef"
  vivify_648:
    getattribute $P117, $P116, "lex_pad"
    setattribute $P115, 'payload', $P117
    throw $P115
.annotate 'line', 19
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_module" :anon :subid("16_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_123
    .param pmc param_124
    .param pmc param_125
.annotate 'line', 48
    new $P122, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P122, control_121
    push_eh $P122
    .lex "self", param_123
    .lex "$module_name", param_124
    .lex "$cur_GLOBALish", param_125
.annotate 'line', 50
    new $P126, "Undef"
    .lex "$module", $P126
    find_lex $P127, "$loader"
    unless_null $P127, vivify_649
    new $P127, "Undef"
  vivify_649:
    find_lex $P128, "$module_name"
    unless_null $P128, vivify_650
    new $P128, "Undef"
  vivify_650:
    find_lex $P129, "$cur_GLOBALish"
    unless_null $P129, vivify_651
    new $P129, "Undef"
  vivify_651:
    $P130 = $P127."load_module"($P128, $P129)
    store_lex "$module", $P130
.annotate 'line', 53
    find_lex $P131, "self"
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Stmts"]
.annotate 'line', 54
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
    $P140 = $P139."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 57
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Op"]
.annotate 'line', 59
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Var"]
    new $P149, "ResizablePMCArray"
    $P150 = $P148."new"("ModuleLoader" :named("name"), $P149 :named("namespace"), "package" :named("scope"))
    find_lex $P151, "$module_name"
    unless_null $P151, vivify_652
    new $P151, "Undef"
  vivify_652:
.annotate 'line', 61
    find_lex $P152, "self"
    find_lex $P153, "$cur_GLOBALish"
    unless_null $P153, vivify_653
    new $P153, "Undef"
  vivify_653:
    $P154 = $P152."get_slot_past_for_object"($P153)
    $P155 = $P144."new"($P150, $P151, $P154, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 57
    $P156 = $P135."new"($P140, $P155)
.annotate 'line', 53
    $P131."add_event"($P156 :named("deserialize_past"))
.annotate 'line', 64
    new $P157, "Exception"
    set $P157['type'], .CONTROL_RETURN
    find_lex $P158, "$module"
    unless_null $P158, vivify_654
    new $P158, "Undef"
  vivify_654:
    getattribute $P159, $P158, "lex_pad"
    setattribute $P157, 'payload', $P159
    throw $P157
.annotate 'line', 48
    .return ()
  control_121:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P160, exception, "payload"
    .return ($P160)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "install_package_symbol" :anon :subid("17_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_162
    .param pmc param_163
    .param pmc param_164
    .param pmc param_165
.annotate 'line', 69
    .const 'Sub' $P202 = "19_1306916577.75068" 
    capture_lex $P202
    .const 'Sub' $P181 = "18_1306916577.75068" 
    capture_lex $P181
    .lex "self", param_162
    .lex "$package", param_163
    .lex "@sym", param_164
    .lex "$obj", param_165
.annotate 'line', 71
    new $P166, "Undef"
    .lex "$name", $P166
.annotate 'line', 74
    new $P167, "Undef"
    .lex "$target", $P167
.annotate 'line', 81
    new $P168, "Undef"
    .lex "$path", $P168
.annotate 'line', 70
    find_lex $P169, "@sym"
    unless_null $P169, vivify_655
    $P169 = root_new ['parrot';'ResizablePMCArray']
  vivify_655:
    clone $P170, $P169
    store_lex "@sym", $P170
.annotate 'line', 71
    find_lex $P171, "@sym"
    unless_null $P171, vivify_656
    $P171 = root_new ['parrot';'ResizablePMCArray']
  vivify_656:
    $P172 = $P171."pop"()
    set $S173, $P172
    new $P174, 'String'
    set $P174, $S173
    store_lex "$name", $P174
.annotate 'line', 74
    find_lex $P175, "$package"
    unless_null $P175, vivify_657
    new $P175, "Undef"
  vivify_657:
    store_lex "$target", $P175
.annotate 'line', 75
    find_lex $P177, "@sym"
    unless_null $P177, vivify_658
    $P177 = root_new ['parrot';'ResizablePMCArray']
  vivify_658:
    defined $I178, $P177
    unless $I178, for_undef_659
    iter $P176, $P177
    new $P188, 'ExceptionHandler'
    set_label $P188, loop187_handler
    $P188."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P188
  loop187_test:
    unless $P176, loop187_done
    shift $P179, $P176
  loop187_redo:
    .const 'Sub' $P181 = "18_1306916577.75068" 
    capture_lex $P181
    $P181($P179)
  loop187_next:
    goto loop187_test
  loop187_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P189, exception, 'type'
    eq $P189, .CONTROL_LOOP_NEXT, loop187_next
    eq $P189, .CONTROL_LOOP_REDO, loop187_redo
  loop187_done:
    pop_eh 
  for_undef_659:
.annotate 'line', 78
    find_lex $P190, "$obj"
    unless_null $P190, vivify_662
    new $P190, "Undef"
  vivify_662:
    find_lex $P191, "$name"
    unless_null $P191, vivify_663
    new $P191, "Undef"
  vivify_663:
    find_lex $P192, "$target"
    unless_null $P192, vivify_664
    new $P192, "Undef"
    store_lex "$target", $P192
  vivify_664:
    get_who $P193, $P192
    set $P193[$P191], $P190
.annotate 'line', 81
    find_lex $P194, "self"
    find_lex $P195, "$package"
    unless_null $P195, vivify_665
    new $P195, "Undef"
  vivify_665:
    $P196 = $P194."get_slot_past_for_object"($P195)
    store_lex "$path", $P196
.annotate 'line', 82
    find_lex $P198, "@sym"
    unless_null $P198, vivify_666
    $P198 = root_new ['parrot';'ResizablePMCArray']
  vivify_666:
    defined $I199, $P198
    unless $I199, for_undef_667
    iter $P197, $P198
    new $P213, 'ExceptionHandler'
    set_label $P213, loop212_handler
    $P213."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P213
  loop212_test:
    unless $P197, loop212_done
    shift $P200, $P197
  loop212_redo:
    .const 'Sub' $P202 = "19_1306916577.75068" 
    capture_lex $P202
    $P202($P200)
  loop212_next:
    goto loop212_test
  loop212_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P214, exception, 'type'
    eq $P214, .CONTROL_LOOP_NEXT, loop212_next
    eq $P214, .CONTROL_LOOP_REDO, loop212_redo
  loop212_done:
    pop_eh 
  for_undef_667:
.annotate 'line', 85
    find_lex $P215, "self"
    get_hll_global $P216, "GLOBAL"
    nqp_get_package_through_who $P217, $P216, "PAST"
    get_who $P218, $P217
    set $P219, $P218["Op"]
.annotate 'line', 87
    get_hll_global $P220, "GLOBAL"
    nqp_get_package_through_who $P221, $P220, "PAST"
    get_who $P222, $P221
    set $P223, $P222["Var"]
.annotate 'line', 89
    get_hll_global $P224, "GLOBAL"
    nqp_get_package_through_who $P225, $P224, "PAST"
    get_who $P226, $P225
    set $P227, $P226["Op"]
    find_lex $P228, "$path"
    unless_null $P228, vivify_670
    new $P228, "Undef"
  vivify_670:
    $P229 = $P227."new"($P228, "get_who PP" :named("pirop"))
    find_lex $P230, "$name"
    unless_null $P230, vivify_671
    new $P230, "Undef"
  vivify_671:
    $P231 = $P223."new"($P229, $P230, "keyed" :named("scope"))
.annotate 'line', 92
    find_lex $P232, "self"
    find_lex $P233, "$obj"
    unless_null $P233, vivify_672
    new $P233, "Undef"
  vivify_672:
    $P234 = $P232."get_slot_past_for_object"($P233)
    $P235 = $P219."new"($P231, $P234, "bind" :named("pasttype"))
.annotate 'line', 85
    $P236 = $P215."add_event"($P235 :named("deserialize_past"))
.annotate 'line', 69
    .return ($P236)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block180"  :anon :subid("18_1306916577.75068") :outer("17_1306916577.75068")
    .param pmc param_182
.annotate 'line', 75
    .lex "$_", param_182
.annotate 'line', 76
    find_lex $P183, "$target"
    unless_null $P183, vivify_660
    new $P183, "Undef"
  vivify_660:
    find_lex $P184, "$_"
    unless_null $P184, vivify_661
    new $P184, "Undef"
  vivify_661:
    set $S185, $P184
    nqp_get_package_through_who $P186, $P183, $S185
    store_lex "$target", $P186
.annotate 'line', 75
    .return ($P186)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block201"  :anon :subid("19_1306916577.75068") :outer("17_1306916577.75068")
    .param pmc param_203
.annotate 'line', 82
    .lex "$_", param_203
.annotate 'line', 83
    get_hll_global $P204, "GLOBAL"
    nqp_get_package_through_who $P205, $P204, "PAST"
    get_who $P206, $P205
    set $P207, $P206["Op"]
    find_lex $P208, "$path"
    unless_null $P208, vivify_668
    new $P208, "Undef"
  vivify_668:
    find_lex $P209, "$_"
    unless_null $P209, vivify_669
    new $P209, "Undef"
  vivify_669:
    set $S210, $P209
    $P211 = $P207."new"($P208, $S210, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P211
.annotate 'line', 82
    .return ($P211)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_lexical_symbol" :anon :subid("20_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_238
    .param pmc param_239
    .param pmc param_240
    .param pmc param_241
.annotate 'line', 100
    .lex "self", param_238
    .lex "$block", param_239
    .lex "$name", param_240
    .lex "$obj", param_241
.annotate 'line', 106
    new $P242, "Undef"
    .lex "$fixup", $P242
.annotate 'line', 102
    find_lex $P243, "$block"
    unless_null $P243, vivify_673
    new $P243, "Undef"
  vivify_673:
    find_lex $P244, "$name"
    unless_null $P244, vivify_674
    new $P244, "Undef"
  vivify_674:
    find_lex $P245, "$obj"
    unless_null $P245, vivify_675
    new $P245, "Undef"
  vivify_675:
    $P243."symbol"($P244, "lexical" :named("scope"), $P245 :named("value"))
.annotate 'line', 103
    find_lex $P246, "$block"
    unless_null $P246, vivify_676
    $P246 = root_new ['parrot';'ResizablePMCArray']
  vivify_676:
    set $P247, $P246[0]
    unless_null $P247, vivify_677
    new $P247, "Undef"
  vivify_677:
    get_hll_global $P248, "GLOBAL"
    nqp_get_package_through_who $P249, $P248, "PAST"
    get_who $P250, $P249
    set $P251, $P250["Var"]
    find_lex $P252, "$name"
    unless_null $P252, vivify_678
    new $P252, "Undef"
  vivify_678:
    $P253 = $P251."new"("lexical" :named("scope"), $P252 :named("name"), 1 :named("isdecl"))
    $P247."push"($P253)
.annotate 'line', 106
    get_hll_global $P254, "GLOBAL"
    nqp_get_package_through_who $P255, $P254, "PAST"
    get_who $P256, $P255
    set $P257, $P256["Stmts"]
.annotate 'line', 107
    get_hll_global $P258, "GLOBAL"
    nqp_get_package_through_who $P259, $P258, "PAST"
    get_who $P260, $P259
    set $P261, $P260["Op"]
.annotate 'line', 109
    get_hll_global $P262, "GLOBAL"
    nqp_get_package_through_who $P263, $P262, "PAST"
    get_who $P264, $P263
    set $P265, $P264["Op"]
.annotate 'line', 111
    get_hll_global $P266, "GLOBAL"
    nqp_get_package_through_who $P267, $P266, "PAST"
    get_who $P268, $P267
    set $P269, $P268["Val"]
    find_lex $P270, "$block"
    unless_null $P270, vivify_679
    new $P270, "Undef"
  vivify_679:
    $P271 = $P269."new"($P270 :named("value"))
    $P272 = $P265."new"($P271, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 113
    find_lex $P273, "$name"
    unless_null $P273, vivify_680
    new $P273, "Undef"
  vivify_680:
    set $S274, $P273
    find_lex $P275, "self"
    find_lex $P276, "$obj"
    unless_null $P276, vivify_681
    new $P276, "Undef"
  vivify_681:
    $P277 = $P275."get_slot_past_for_object"($P276)
    $P278 = $P261."new"($P272, $S274, $P277, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 117
    get_hll_global $P279, "GLOBAL"
    nqp_get_package_through_who $P280, $P279, "PAST"
    get_who $P281, $P280
    set $P282, $P281["Op"]
.annotate 'line', 119
    get_hll_global $P283, "GLOBAL"
    nqp_get_package_through_who $P284, $P283, "PAST"
    get_who $P285, $P284
    set $P286, $P285["Op"]
.annotate 'line', 121
    get_hll_global $P287, "GLOBAL"
    nqp_get_package_through_who $P288, $P287, "PAST"
    get_who $P289, $P288
    set $P290, $P289["Val"]
    find_lex $P291, "$block"
    unless_null $P291, vivify_682
    new $P291, "Undef"
  vivify_682:
    $P292 = $P290."new"($P291 :named("value"))
    $P293 = $P286."new"($P292, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 119
    $P294 = $P282."new"($P293, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 117
    $P295 = $P257."new"($P278, $P294)
.annotate 'line', 106
    store_lex "$fixup", $P295
.annotate 'line', 125
    find_lex $P296, "self"
    find_lex $P297, "$fixup"
    unless_null $P297, vivify_683
    new $P297, "Undef"
  vivify_683:
    find_lex $P298, "$fixup"
    unless_null $P298, vivify_684
    new $P298, "Undef"
  vivify_684:
    $P299 = $P296."add_event"($P297 :named("deserialize_past"), $P298 :named("fixup_past"))
.annotate 'line', 100
    .return ($P299)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_package_routine" :anon :subid("21_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_301
    .param pmc param_302
    .param pmc param_303
    .param pmc param_304
.annotate 'line', 130
    .lex "self", param_301
    .lex "$package", param_302
    .lex "$name", param_303
    .lex "$past_block", param_304
.annotate 'line', 131
    new $P305, "Undef"
    .lex "$fixup", $P305
    get_hll_global $P306, "GLOBAL"
    nqp_get_package_through_who $P307, $P306, "PAST"
    get_who $P308, $P307
    set $P309, $P308["Op"]
.annotate 'line', 133
    get_hll_global $P310, "GLOBAL"
    nqp_get_package_through_who $P311, $P310, "PAST"
    get_who $P312, $P311
    set $P313, $P312["Var"]
.annotate 'line', 135
    get_hll_global $P314, "GLOBAL"
    nqp_get_package_through_who $P315, $P314, "PAST"
    get_who $P316, $P315
    set $P317, $P316["Op"]
    find_lex $P318, "self"
    find_lex $P319, "$package"
    unless_null $P319, vivify_685
    new $P319, "Undef"
  vivify_685:
    $P320 = $P318."get_slot_past_for_object"($P319)
    $P321 = $P317."new"($P320, "get_who PP" :named("pirop"))
.annotate 'line', 136
    find_lex $P322, "$name"
    unless_null $P322, vivify_686
    new $P322, "Undef"
  vivify_686:
    set $S323, $P322
    $P324 = $P313."new"($P321, $S323, "keyed" :named("scope"))
.annotate 'line', 138
    get_hll_global $P325, "GLOBAL"
    nqp_get_package_through_who $P326, $P325, "PAST"
    get_who $P327, $P326
    set $P328, $P327["Val"]
    find_lex $P329, "$past_block"
    unless_null $P329, vivify_687
    new $P329, "Undef"
  vivify_687:
    $P330 = $P328."new"($P329 :named("value"))
    $P331 = $P309."new"($P324, $P330, "bind" :named("pasttype"))
.annotate 'line', 131
    store_lex "$fixup", $P331
.annotate 'line', 140
    find_lex $P332, "self"
    find_lex $P333, "$fixup"
    unless_null $P333, vivify_688
    new $P333, "Undef"
  vivify_688:
    find_lex $P334, "$fixup"
    unless_null $P334, vivify_689
    new $P334, "Undef"
  vivify_689:
    $P335 = $P332."add_event"($P333 :named("deserialize_past"), $P334 :named("fixup_past"))
.annotate 'line', 130
    .return ($P335)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_create_mo" :anon :subid("22_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_339
    .param pmc param_340
    .param pmc param_341 :optional :named("name")
    .param int has_param_341 :opt_flag
    .param pmc param_343 :optional :named("repr")
    .param int has_param_343 :opt_flag
.annotate 'line', 145
    new $P338, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P338, control_337
    push_eh $P338
    .lex "self", param_339
    .lex "$how", param_340
    if has_param_341, optparam_690
    new $P342, "Undef"
    set param_341, $P342
  optparam_690:
    .lex "$name", param_341
    if has_param_343, optparam_691
    new $P344, "Undef"
    set param_343, $P344
  optparam_691:
    .lex "$repr", param_343
.annotate 'line', 147
    $P345 = root_new ['parrot';'Hash']
    .lex "%args", $P345
.annotate 'line', 150
    new $P346, "Undef"
    .lex "$mo", $P346
.annotate 'line', 151
    new $P347, "Undef"
    .lex "$slot", $P347
.annotate 'line', 155
    $P348 = root_new ['parrot';'ResizablePMCArray']
    .lex "@how_ns", $P348
.annotate 'line', 156
    new $P349, "Undef"
    .lex "$how_name", $P349
.annotate 'line', 157
    new $P350, "Undef"
    .lex "$setup_call", $P350
.annotate 'line', 145
    find_lex $P351, "%args"
    unless_null $P351, vivify_692
    $P351 = root_new ['parrot';'Hash']
  vivify_692:
.annotate 'line', 148
    find_lex $P353, "$name"
    unless_null $P353, vivify_693
    new $P353, "Undef"
  vivify_693:
    defined $I354, $P353
    unless $I354, if_352_end
    find_lex $P355, "$name"
    unless_null $P355, vivify_694
    new $P355, "Undef"
  vivify_694:
    find_lex $P356, "%args"
    unless_null $P356, vivify_695
    $P356 = root_new ['parrot';'Hash']
    store_lex "%args", $P356
  vivify_695:
    set $P356["name"], $P355
  if_352_end:
.annotate 'line', 149
    find_lex $P358, "$repr"
    unless_null $P358, vivify_696
    new $P358, "Undef"
  vivify_696:
    defined $I359, $P358
    unless $I359, if_357_end
    find_lex $P360, "$repr"
    unless_null $P360, vivify_697
    new $P360, "Undef"
  vivify_697:
    find_lex $P361, "%args"
    unless_null $P361, vivify_698
    $P361 = root_new ['parrot';'Hash']
    store_lex "%args", $P361
  vivify_698:
    set $P361["repr"], $P360
  if_357_end:
.annotate 'line', 150
    find_lex $P362, "$how"
    unless_null $P362, vivify_699
    new $P362, "Undef"
  vivify_699:
    find_lex $P363, "%args"
    unless_null $P363, vivify_700
    $P363 = root_new ['parrot';'Hash']
  vivify_700:
    $P364 = $P362."new_type"($P363 :flat)
    store_lex "$mo", $P364
.annotate 'line', 151
    find_lex $P365, "self"
    find_lex $P366, "$mo"
    unless_null $P366, vivify_701
    new $P366, "Undef"
  vivify_701:
    $P367 = $P365."add_object"($P366)
    store_lex "$slot", $P367
.annotate 'line', 155
    find_lex $P368, "$how"
    unless_null $P368, vivify_702
    new $P368, "Undef"
  vivify_702:
    get_how $P369, $P368
    find_lex $P370, "$how"
    unless_null $P370, vivify_703
    new $P370, "Undef"
  vivify_703:
    $S371 = $P369."name"($P370)
    split $P372, "::", $S371
    store_lex "@how_ns", $P372
.annotate 'line', 156
    find_lex $P373, "@how_ns"
    unless_null $P373, vivify_704
    $P373 = root_new ['parrot';'ResizablePMCArray']
  vivify_704:
    $P374 = $P373."pop"()
    store_lex "$how_name", $P374
.annotate 'line', 157
    get_hll_global $P375, "GLOBAL"
    nqp_get_package_through_who $P376, $P375, "PAST"
    get_who $P377, $P376
    set $P378, $P377["Op"]
.annotate 'line', 159
    find_lex $P379, "self"
    find_lex $P380, "$how"
    unless_null $P380, vivify_705
    new $P380, "Undef"
  vivify_705:
    $P381 = $P379."get_object_sc_ref_past"($P380)
    $P382 = $P378."new"($P381, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 157
    store_lex "$setup_call", $P382
.annotate 'line', 161
    find_lex $P384, "$name"
    unless_null $P384, vivify_706
    new $P384, "Undef"
  vivify_706:
    defined $I385, $P384
    unless $I385, if_383_end
.annotate 'line', 162
    find_lex $P386, "$setup_call"
    unless_null $P386, vivify_707
    new $P386, "Undef"
  vivify_707:
    get_hll_global $P387, "GLOBAL"
    nqp_get_package_through_who $P388, $P387, "PAST"
    get_who $P389, $P388
    set $P390, $P389["Val"]
    find_lex $P391, "$name"
    unless_null $P391, vivify_708
    new $P391, "Undef"
  vivify_708:
    $P392 = $P390."new"($P391 :named("value"), "name" :named("named"))
    $P386."push"($P392)
  if_383_end:
.annotate 'line', 164
    find_lex $P394, "$repr"
    unless_null $P394, vivify_709
    new $P394, "Undef"
  vivify_709:
    defined $I395, $P394
    unless $I395, if_393_end
.annotate 'line', 165
    find_lex $P396, "$setup_call"
    unless_null $P396, vivify_710
    new $P396, "Undef"
  vivify_710:
    get_hll_global $P397, "GLOBAL"
    nqp_get_package_through_who $P398, $P397, "PAST"
    get_who $P399, $P398
    set $P400, $P399["Val"]
    find_lex $P401, "$repr"
    unless_null $P401, vivify_711
    new $P401, "Undef"
  vivify_711:
    $P402 = $P400."new"($P401 :named("value"), "repr" :named("named"))
    $P396."push"($P402)
  if_393_end:
.annotate 'line', 167
    find_lex $P403, "self"
.annotate 'line', 168
    find_lex $P404, "self"
    find_lex $P405, "$slot"
    unless_null $P405, vivify_712
    new $P405, "Undef"
  vivify_712:
    find_lex $P406, "self"
    find_lex $P407, "$setup_call"
    unless_null $P407, vivify_713
    new $P407, "Undef"
  vivify_713:
    $P408 = $P406."set_cur_sc"($P407)
    $P409 = $P404."set_slot_past"($P405, $P408)
    $P403."add_event"($P409 :named("deserialize_past"))
.annotate 'line', 171
    new $P410, "Exception"
    set $P410['type'], .CONTROL_RETURN
    find_lex $P411, "$mo"
    unless_null $P411, vivify_714
    new $P411, "Undef"
  vivify_714:
    setattribute $P410, 'payload', $P411
    throw $P410
.annotate 'line', 145
    .return ()
  control_337:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P412, exception, "payload"
    .return ($P412)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_add_attribute" :anon :subid("23_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_414
    .param pmc param_415
    .param pmc param_416
    .param pmc param_417
    .param pmc param_418
.annotate 'line', 179
    .const 'Sub' $P464 = "25_1306916577.75068" 
    capture_lex $P464
    .const 'Sub' $P443 = "24_1306916577.75068" 
    capture_lex $P443
    .lex "self", param_414
    .lex "$obj", param_415
    .lex "$meta_attr", param_416
    .lex "%lit_args", param_417
    .lex "%obj_args", param_418
.annotate 'line', 181
    new $P419, "Undef"
    .lex "$attr", $P419
.annotate 'line', 185
    new $P420, "Undef"
    .lex "$create_call", $P420
.annotate 'line', 197
    new $P421, "Undef"
    .lex "$obj_slot_past", $P421
.annotate 'line', 181
    find_lex $P422, "$meta_attr"
    unless_null $P422, vivify_715
    new $P422, "Undef"
  vivify_715:
    find_lex $P423, "%lit_args"
    unless_null $P423, vivify_716
    $P423 = root_new ['parrot';'Hash']
  vivify_716:
    find_lex $P424, "%obj_args"
    unless_null $P424, vivify_717
    $P424 = root_new ['parrot';'Hash']
  vivify_717:
    $P425 = $P422."new"($P423 :flat, $P424 :flat)
    store_lex "$attr", $P425
.annotate 'line', 182
    find_lex $P426, "$obj"
    unless_null $P426, vivify_718
    new $P426, "Undef"
  vivify_718:
    get_how $P427, $P426
    find_lex $P428, "$obj"
    unless_null $P428, vivify_719
    new $P428, "Undef"
  vivify_719:
    find_lex $P429, "$attr"
    unless_null $P429, vivify_720
    new $P429, "Undef"
  vivify_720:
    $P427."add_attribute"($P428, $P429)
.annotate 'line', 185
    get_hll_global $P430, "GLOBAL"
    nqp_get_package_through_who $P431, $P430, "PAST"
    get_who $P432, $P431
    set $P433, $P432["Op"]
.annotate 'line', 187
    find_lex $P434, "self"
    find_lex $P435, "$meta_attr"
    unless_null $P435, vivify_721
    new $P435, "Undef"
  vivify_721:
    $P436 = $P434."get_object_sc_ref_past"($P435)
    $P437 = $P433."new"($P436, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 185
    store_lex "$create_call", $P437
.annotate 'line', 189
    find_lex $P439, "%lit_args"
    unless_null $P439, vivify_722
    $P439 = root_new ['parrot';'Hash']
  vivify_722:
    defined $I440, $P439
    unless $I440, for_undef_723
    iter $P438, $P439
    new $P457, 'ExceptionHandler'
    set_label $P457, loop456_handler
    $P457."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P457
  loop456_test:
    unless $P438, loop456_done
    shift $P441, $P438
  loop456_redo:
    .const 'Sub' $P443 = "24_1306916577.75068" 
    capture_lex $P443
    $P443($P441)
  loop456_next:
    goto loop456_test
  loop456_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P458, exception, 'type'
    eq $P458, .CONTROL_LOOP_NEXT, loop456_next
    eq $P458, .CONTROL_LOOP_REDO, loop456_redo
  loop456_done:
    pop_eh 
  for_undef_723:
.annotate 'line', 192
    find_lex $P460, "%obj_args"
    unless_null $P460, vivify_727
    $P460 = root_new ['parrot';'Hash']
  vivify_727:
    defined $I461, $P460
    unless $I461, for_undef_728
    iter $P459, $P460
    new $P478, 'ExceptionHandler'
    set_label $P478, loop477_handler
    $P478."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P478
  loop477_test:
    unless $P459, loop477_done
    shift $P462, $P459
  loop477_redo:
    .const 'Sub' $P464 = "25_1306916577.75068" 
    capture_lex $P464
    $P464($P462)
  loop477_next:
    goto loop477_test
  loop477_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P479, exception, 'type'
    eq $P479, .CONTROL_LOOP_NEXT, loop477_next
    eq $P479, .CONTROL_LOOP_REDO, loop477_redo
  loop477_done:
    pop_eh 
  for_undef_728:
.annotate 'line', 197
    find_lex $P480, "self"
    find_lex $P481, "$obj"
    unless_null $P481, vivify_734
    new $P481, "Undef"
  vivify_734:
    $P482 = $P480."get_slot_past_for_object"($P481)
    store_lex "$obj_slot_past", $P482
.annotate 'line', 198
    find_lex $P483, "self"
    get_hll_global $P484, "GLOBAL"
    nqp_get_package_through_who $P485, $P484, "PAST"
    get_who $P486, $P485
    set $P487, $P486["Op"]
.annotate 'line', 200
    get_hll_global $P488, "GLOBAL"
    nqp_get_package_through_who $P489, $P488, "PAST"
    get_who $P490, $P489
    set $P491, $P490["Op"]
    find_lex $P492, "$obj_slot_past"
    unless_null $P492, vivify_735
    new $P492, "Undef"
  vivify_735:
    $P493 = $P491."new"($P492, "get_how PP" :named("pirop"))
    find_lex $P494, "$obj_slot_past"
    unless_null $P494, vivify_736
    new $P494, "Undef"
  vivify_736:
    find_lex $P495, "$create_call"
    unless_null $P495, vivify_737
    new $P495, "Undef"
  vivify_737:
    $P496 = $P487."new"($P493, $P494, $P495, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 198
    $P497 = $P483."add_event"($P496 :named("deserialize_past"))
.annotate 'line', 179
    .return ($P497)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block442"  :anon :subid("24_1306916577.75068") :outer("23_1306916577.75068")
    .param pmc param_444
.annotate 'line', 189
    .lex "$_", param_444
.annotate 'line', 190
    find_lex $P445, "$create_call"
    unless_null $P445, vivify_724
    new $P445, "Undef"
  vivify_724:
    get_hll_global $P446, "GLOBAL"
    nqp_get_package_through_who $P447, $P446, "PAST"
    get_who $P448, $P447
    set $P449, $P448["Val"]
    find_lex $P450, "$_"
    unless_null $P450, vivify_725
    new $P450, "Undef"
  vivify_725:
    $P451 = $P450."value"()
    find_lex $P452, "$_"
    unless_null $P452, vivify_726
    new $P452, "Undef"
  vivify_726:
    $P453 = $P452."key"()
    $P454 = $P449."new"($P451 :named("value"), $P453 :named("named"))
    $P455 = $P445."push"($P454)
.annotate 'line', 189
    .return ($P455)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block463"  :anon :subid("25_1306916577.75068") :outer("23_1306916577.75068")
    .param pmc param_466
.annotate 'line', 193
    new $P465, "Undef"
    .lex "$lookup", $P465
    .lex "$_", param_466
    find_lex $P467, "self"
    find_lex $P468, "$_"
    unless_null $P468, vivify_729
    new $P468, "Undef"
  vivify_729:
    $P469 = $P468."value"()
    $P470 = $P467."get_object_sc_ref_past"($P469)
    store_lex "$lookup", $P470
.annotate 'line', 194
    find_lex $P471, "$lookup"
    unless_null $P471, vivify_730
    new $P471, "Undef"
  vivify_730:
    find_lex $P472, "$_"
    unless_null $P472, vivify_731
    new $P472, "Undef"
  vivify_731:
    $P473 = $P472."key"()
    $P471."named"($P473)
.annotate 'line', 195
    find_lex $P474, "$create_call"
    unless_null $P474, vivify_732
    new $P474, "Undef"
  vivify_732:
    find_lex $P475, "$lookup"
    unless_null $P475, vivify_733
    new $P475, "Undef"
  vivify_733:
    $P476 = $P474."push"($P475)
.annotate 'line', 192
    .return ($P476)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_method" :anon :subid("26_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_499
    .param pmc param_500
    .param pmc param_501
    .param pmc param_502
    .param pmc param_503
    .param pmc param_504
.annotate 'line', 209
    .const 'Sub' $P544 = "28_1306916577.75068" 
    capture_lex $P544
    .const 'Sub' $P510 = "27_1306916577.75068" 
    capture_lex $P510
    .lex "self", param_499
    .lex "$obj", param_500
    .lex "$meta_method_name", param_501
    .lex "$name", param_502
    .lex "$method_past", param_503
    .lex "$is_dispatcher", param_504
.annotate 'line', 215
    new $P505, "Undef"
    .lex "$stub_code", $P505
.annotate 'line', 221
    new $P506, "Undef"
    .lex "$fixups", $P506
.annotate 'line', 222
    new $P507, "Undef"
    .lex "$dummy", $P507
.annotate 'line', 267
    new $P508, "Undef"
    .lex "$slot_past", $P508
.annotate 'line', 215
    .const 'Sub' $P510 = "27_1306916577.75068" 
    newclosure $P524, $P510
    store_lex "$stub_code", $P524
.annotate 'line', 221
    get_hll_global $P525, "GLOBAL"
    nqp_get_package_through_who $P526, $P525, "PAST"
    get_who $P527, $P526
    set $P528, $P527["Stmts"]
    $P529 = $P528."new"()
    store_lex "$fixups", $P529
    find_lex $P530, "$dummy"
    unless_null $P530, vivify_742
    new $P530, "Undef"
  vivify_742:
.annotate 'line', 223
    find_lex $P532, "$method_past"
    unless_null $P532, vivify_743
    $P532 = root_new ['parrot';'Hash']
  vivify_743:
    set $P533, $P532["compile_time_dummy"]
    unless_null $P533, vivify_744
    new $P533, "Undef"
  vivify_744:
    defined $I534, $P533
    if $I534, if_531
.annotate 'line', 230
    find_lex $P538, "$is_dispatcher"
    unless_null $P538, vivify_745
    new $P538, "Undef"
  vivify_745:
    if $P538, if_537
.annotate 'line', 246
    find_lex $P567, "$stub_code"
    unless_null $P567, vivify_746
    new $P567, "Undef"
  vivify_746:
    clone $P568, $P567
    store_lex "$dummy", $P568
.annotate 'line', 245
    goto if_537_end
  if_537:
.annotate 'line', 231
    find_lex $P539, "$method_past"
    unless_null $P539, vivify_747
    new $P539, "Undef"
  vivify_747:
    $P539."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 232
    new $P540, "DispatcherSub"
    find_lex $P541, "$stub_code"
    unless_null $P541, vivify_748
    new $P541, "Undef"
  vivify_748:
    assign $P540, $P541
    store_lex "$dummy", $P540
.annotate 'line', 236
    find_lex $P542, "$dummy"
    unless_null $P542, vivify_749
    new $P542, "Undef"
  vivify_749:
    .const 'Sub' $P544 = "28_1306916577.75068" 
    newclosure $P566, $P544
    setprop $P542, "CLONE_CALLBACK", $P566
  if_537_end:
.annotate 'line', 248
    find_lex $P569, "$dummy"
    unless_null $P569, vivify_754
    new $P569, "Undef"
  vivify_754:
    find_lex $P570, "$name"
    unless_null $P570, vivify_755
    new $P570, "Undef"
  vivify_755:
    set $S571, $P570
    assign $P569, $S571
.annotate 'line', 249
    find_lex $P572, "self"
    find_lex $P573, "$dummy"
    unless_null $P573, vivify_756
    new $P573, "Undef"
  vivify_756:
    $P572."add_code"($P573)
.annotate 'line', 250
    find_lex $P574, "$dummy"
    unless_null $P574, vivify_757
    new $P574, "Undef"
  vivify_757:
    find_lex $P575, "$method_past"
    unless_null $P575, vivify_758
    $P575 = root_new ['parrot';'Hash']
    store_lex "$method_past", $P575
  vivify_758:
    set $P575["compile_time_dummy"], $P574
.annotate 'line', 226
    goto if_531_end
  if_531:
.annotate 'line', 224
    find_lex $P535, "$method_past"
    unless_null $P535, vivify_759
    $P535 = root_new ['parrot';'Hash']
  vivify_759:
    set $P536, $P535["compile_time_dummy"]
    unless_null $P536, vivify_760
    new $P536, "Undef"
  vivify_760:
    store_lex "$dummy", $P536
  if_531_end:
.annotate 'line', 254
    find_lex $P576, "$dummy"
    unless_null $P576, vivify_761
    new $P576, "Undef"
  vivify_761:
    find_lex $P577, "$method_past"
    unless_null $P577, vivify_762
    new $P577, "Undef"
  vivify_762:
    setprop $P576, "PAST", $P577
.annotate 'line', 257
    find_lex $P578, "$obj"
    unless_null $P578, vivify_763
    new $P578, "Undef"
  vivify_763:
    get_how $P579, $P578
    find_lex $P580, "$obj"
    unless_null $P580, vivify_764
    new $P580, "Undef"
  vivify_764:
    find_lex $P581, "$name"
    unless_null $P581, vivify_765
    new $P581, "Undef"
  vivify_765:
    find_lex $P582, "$dummy"
    unless_null $P582, vivify_766
    new $P582, "Undef"
  vivify_766:
    find_lex $P583, "$meta_method_name"
    unless_null $P583, vivify_767
    new $P583, "Undef"
  vivify_767:
    set $S584, $P583
    $P579.$S584($P580, $P581, $P582)
.annotate 'line', 262
    find_lex $P585, "$fixups"
    unless_null $P585, vivify_768
    new $P585, "Undef"
  vivify_768:
    get_hll_global $P586, "GLOBAL"
    nqp_get_package_through_who $P587, $P586, "PAST"
    get_who $P588, $P587
    set $P589, $P588["Op"]
.annotate 'line', 264
    find_lex $P590, "self"
    find_lex $P591, "$dummy"
    unless_null $P591, vivify_769
    new $P591, "Undef"
  vivify_769:
    $P592 = $P590."get_slot_past_for_object"($P591)
.annotate 'line', 265
    get_hll_global $P593, "GLOBAL"
    nqp_get_package_through_who $P594, $P593, "PAST"
    get_who $P595, $P594
    set $P596, $P595["Val"]
    find_lex $P597, "$method_past"
    unless_null $P597, vivify_770
    new $P597, "Undef"
  vivify_770:
    $P598 = $P596."new"($P597 :named("value"))
    $P599 = $P589."new"($P592, $P598, "assign vPP" :named("pirop"))
.annotate 'line', 262
    $P585."push"($P599)
.annotate 'line', 267
    find_lex $P600, "self"
    find_lex $P601, "$obj"
    unless_null $P601, vivify_771
    new $P601, "Undef"
  vivify_771:
    $P602 = $P600."get_slot_past_for_object"($P601)
    store_lex "$slot_past", $P602
.annotate 'line', 268
    find_lex $P603, "self"
.annotate 'line', 269
    get_hll_global $P604, "GLOBAL"
    nqp_get_package_through_who $P605, $P604, "PAST"
    get_who $P606, $P605
    set $P607, $P606["Op"]
    find_lex $P608, "$meta_method_name"
    unless_null $P608, vivify_772
    new $P608, "Undef"
  vivify_772:
.annotate 'line', 271
    get_hll_global $P609, "GLOBAL"
    nqp_get_package_through_who $P610, $P609, "PAST"
    get_who $P611, $P610
    set $P612, $P611["Op"]
    find_lex $P613, "$slot_past"
    unless_null $P613, vivify_773
    new $P613, "Undef"
  vivify_773:
    $P614 = $P612."new"($P613, "get_how PP" :named("pirop"))
    find_lex $P615, "$slot_past"
    unless_null $P615, vivify_774
    new $P615, "Undef"
  vivify_774:
    find_lex $P616, "$name"
    unless_null $P616, vivify_775
    new $P616, "Undef"
  vivify_775:
.annotate 'line', 274
    get_hll_global $P617, "GLOBAL"
    nqp_get_package_through_who $P618, $P617, "PAST"
    get_who $P619, $P618
    set $P620, $P619["Val"]
    find_lex $P621, "$method_past"
    unless_null $P621, vivify_776
    new $P621, "Undef"
  vivify_776:
    $P622 = $P620."new"($P621 :named("value"))
    $P623 = $P607."new"($P614, $P615, $P616, $P622, "callmethod" :named("pasttype"), $P608 :named("name"))
.annotate 'line', 269
    find_lex $P624, "$fixups"
    unless_null $P624, vivify_777
    new $P624, "Undef"
  vivify_777:
    $P625 = $P603."add_event"($P623 :named("deserialize_past"), $P624 :named("fixup_past"))
.annotate 'line', 209
    .return ($P625)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block509"  :anon :subid("27_1306916577.75068") :outer("26_1306916577.75068")
    .param pmc param_511 :slurpy
    .param pmc param_512 :slurpy :named
.annotate 'line', 215
    .lex "@args", param_511
    .lex "%named", param_512
.annotate 'line', 216
    new $P513, "Undef"
    .lex "$compiled", $P513
    get_hll_global $P514, "GLOBAL"
    nqp_get_package_through_who $P515, $P514, "PAST"
    get_who $P516, $P515
    set $P517, $P516["Compiler"]
    find_lex $P518, "$method_past"
    unless_null $P518, vivify_738
    new $P518, "Undef"
  vivify_738:
    $P519 = $P517."compile"($P518)
    store_lex "$compiled", $P519
.annotate 'line', 217
    find_lex $P520, "$compiled"
    unless_null $P520, vivify_739
    new $P520, "Undef"
  vivify_739:
    find_lex $P521, "@args"
    unless_null $P521, vivify_740
    $P521 = root_new ['parrot';'ResizablePMCArray']
  vivify_740:
    find_lex $P522, "%named"
    unless_null $P522, vivify_741
    $P522 = root_new ['parrot';'Hash']
  vivify_741:
    $P523 = $P520($P521 :flat, $P522 :flat)
.annotate 'line', 215
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block543"  :anon :subid("28_1306916577.75068") :outer("26_1306916577.75068")
    .param pmc param_545
    .param pmc param_546
.annotate 'line', 236
    .lex "$orig", param_545
    .lex "$clone", param_546
.annotate 'line', 237
    find_lex $P547, "self"
    find_lex $P548, "$clone"
    unless_null $P548, vivify_750
    new $P548, "Undef"
  vivify_750:
    $P547."add_code"($P548)
.annotate 'line', 238
    find_lex $P549, "$fixups"
    unless_null $P549, vivify_751
    new $P549, "Undef"
  vivify_751:
    get_hll_global $P550, "GLOBAL"
    nqp_get_package_through_who $P551, $P550, "PAST"
    get_who $P552, $P551
    set $P553, $P552["Op"]
.annotate 'line', 240
    find_lex $P554, "self"
    find_lex $P555, "$clone"
    unless_null $P555, vivify_752
    new $P555, "Undef"
  vivify_752:
    $P556 = $P554."get_slot_past_for_object"($P555)
.annotate 'line', 241
    get_hll_global $P557, "GLOBAL"
    nqp_get_package_through_who $P558, $P557, "PAST"
    get_who $P559, $P558
    set $P560, $P559["Val"]
    find_lex $P561, "$orig"
    unless_null $P561, vivify_753
    new $P561, "Undef"
  vivify_753:
    getprop $P562, "PAST", $P561
    $P563 = $P560."new"($P562 :named("value"))
    $P564 = $P553."new"($P556, $P563, "assign vPP" :named("pirop"))
.annotate 'line', 238
    $P565 = $P549."push"($P564)
.annotate 'line', 236
    .return ($P565)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "set_routine_signature" :anon :subid("29_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_627
    .param pmc param_628
    .param pmc param_629
    .param pmc param_630
.annotate 'line', 280
    .lex "self", param_627
    .lex "$routine", param_628
    .lex "$types", param_629
    .lex "$definednesses", param_630
.annotate 'line', 283
    new $P631, "Undef"
    .lex "$fixup", $P631
.annotate 'line', 290
    new $P632, "Undef"
    .lex "$des", $P632
.annotate 'line', 283
    get_hll_global $P633, "GLOBAL"
    nqp_get_package_through_who $P634, $P633, "PAST"
    get_who $P635, $P634
    set $P636, $P635["Op"]
    find_lex $P637, "$types"
    unless_null $P637, vivify_778
    new $P637, "Undef"
  vivify_778:
    find_lex $P638, "$definednesses"
    unless_null $P638, vivify_779
    new $P638, "Undef"
  vivify_779:
    $P639 = $P636."new"($P637, $P638, "set_sub_multisig vPPP" :named("pirop"))
    store_lex "$fixup", $P639
.annotate 'line', 284
    find_lex $P641, "$routine"
    unless_null $P641, vivify_780
    $P641 = root_new ['parrot';'Hash']
  vivify_780:
    set $P642, $P641["compile_time_dummy"]
    unless_null $P642, vivify_781
    new $P642, "Undef"
  vivify_781:
    defined $I643, $P642
    if $I643, if_640
.annotate 'line', 288
    find_lex $P649, "$fixup"
    unless_null $P649, vivify_782
    new $P649, "Undef"
  vivify_782:
    get_hll_global $P650, "GLOBAL"
    nqp_get_package_through_who $P651, $P650, "PAST"
    get_who $P652, $P651
    set $P653, $P652["Val"]
    find_lex $P654, "$routine"
    unless_null $P654, vivify_783
    new $P654, "Undef"
  vivify_783:
    $P655 = $P653."new"($P654 :named("value"))
    $P649."unshift"($P655)
.annotate 'line', 287
    goto if_640_end
  if_640:
.annotate 'line', 285
    find_lex $P644, "$fixup"
    unless_null $P644, vivify_784
    new $P644, "Undef"
  vivify_784:
    find_lex $P645, "self"
    find_lex $P646, "$routine"
    unless_null $P646, vivify_785
    $P646 = root_new ['parrot';'Hash']
  vivify_785:
    set $P647, $P646["compile_time_dummy"]
    unless_null $P647, vivify_786
    new $P647, "Undef"
  vivify_786:
    $P648 = $P645."get_slot_past_for_object"($P647)
    $P644."unshift"($P648)
  if_640_end:
.annotate 'line', 290
    get_hll_global $P656, "GLOBAL"
    nqp_get_package_through_who $P657, $P656, "PAST"
    get_who $P658, $P657
    set $P659, $P658["Op"]
.annotate 'line', 291
    get_hll_global $P660, "GLOBAL"
    nqp_get_package_through_who $P661, $P660, "PAST"
    get_who $P662, $P661
    set $P663, $P662["Val"]
    find_lex $P664, "$routine"
    unless_null $P664, vivify_787
    new $P664, "Undef"
  vivify_787:
    $P665 = $P663."new"($P664 :named("value"))
    find_lex $P666, "$types"
    unless_null $P666, vivify_788
    new $P666, "Undef"
  vivify_788:
    find_lex $P667, "$definednesses"
    unless_null $P667, vivify_789
    new $P667, "Undef"
  vivify_789:
    $P668 = $P659."new"($P665, $P666, $P667, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 290
    store_lex "$des", $P668
.annotate 'line', 293
    find_lex $P669, "self"
    find_lex $P670, "$des"
    unless_null $P670, vivify_790
    new $P670, "Undef"
  vivify_790:
    find_lex $P671, "$fixup"
    unless_null $P671, vivify_791
    new $P671, "Undef"
  vivify_791:
    $P672 = $P669."add_event"($P670 :named("deserialize_past"), $P671 :named("fixup_past"))
.annotate 'line', 280
    .return ($P672)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_set_body_block" :anon :subid("30_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_674
    .param pmc param_675
    .param pmc param_676
.annotate 'line', 297
    .const 'Sub' $P687 = "31_1306916577.75068" 
    capture_lex $P687
    .lex "self", param_674
    .lex "$obj", param_675
    .lex "$body_past", param_676
.annotate 'line', 308
    new $P677, "Undef"
    .lex "$fixups", $P677
.annotate 'line', 309
    new $P678, "Undef"
    .lex "$dummy", $P678
.annotate 'line', 344
    new $P679, "Undef"
    .lex "$slot_past", $P679
.annotate 'line', 345
    new $P680, "Undef"
    .lex "$des", $P680
.annotate 'line', 308
    get_hll_global $P681, "GLOBAL"
    nqp_get_package_through_who $P682, $P681, "PAST"
    get_who $P683, $P682
    set $P684, $P683["Stmts"]
    $P685 = $P684."new"()
    store_lex "$fixups", $P685
.annotate 'line', 309
    .const 'Sub' $P687 = "31_1306916577.75068" 
    newclosure $P758, $P687
    store_lex "$dummy", $P758
.annotate 'line', 341
    find_lex $P759, "$obj"
    unless_null $P759, vivify_809
    new $P759, "Undef"
  vivify_809:
    get_how $P760, $P759
    find_lex $P761, "$obj"
    unless_null $P761, vivify_810
    new $P761, "Undef"
  vivify_810:
    find_lex $P762, "$dummy"
    unless_null $P762, vivify_811
    new $P762, "Undef"
  vivify_811:
    $P760."set_body_block"($P761, $P762)
.annotate 'line', 344
    find_lex $P763, "self"
    find_lex $P764, "$obj"
    unless_null $P764, vivify_812
    new $P764, "Undef"
  vivify_812:
    $P765 = $P763."get_slot_past_for_object"($P764)
    store_lex "$slot_past", $P765
.annotate 'line', 345
    get_hll_global $P766, "GLOBAL"
    nqp_get_package_through_who $P767, $P766, "PAST"
    get_who $P768, $P767
    set $P769, $P768["Op"]
.annotate 'line', 347
    get_hll_global $P770, "GLOBAL"
    nqp_get_package_through_who $P771, $P770, "PAST"
    get_who $P772, $P771
    set $P773, $P772["Op"]
    find_lex $P774, "$slot_past"
    unless_null $P774, vivify_813
    new $P774, "Undef"
  vivify_813:
    $P775 = $P773."new"($P774, "get_how PP" :named("pirop"))
    find_lex $P776, "$slot_past"
    unless_null $P776, vivify_814
    new $P776, "Undef"
  vivify_814:
.annotate 'line', 349
    get_hll_global $P777, "GLOBAL"
    nqp_get_package_through_who $P778, $P777, "PAST"
    get_who $P779, $P778
    set $P780, $P779["Val"]
    find_lex $P781, "$body_past"
    unless_null $P781, vivify_815
    new $P781, "Undef"
  vivify_815:
    $P782 = $P780."new"($P781 :named("value"))
    $P783 = $P769."new"($P775, $P776, $P782, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 345
    store_lex "$des", $P783
.annotate 'line', 352
    find_lex $P784, "self"
    find_lex $P785, "$des"
    unless_null $P785, vivify_816
    new $P785, "Undef"
  vivify_816:
    find_lex $P786, "$fixups"
    unless_null $P786, vivify_817
    new $P786, "Undef"
  vivify_817:
    $P787 = $P784."add_event"($P785 :named("deserialize_past"), $P786 :named("fixup_past"))
.annotate 'line', 297
    .return ($P787)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block686"  :anon :subid("31_1306916577.75068") :outer("30_1306916577.75068")
    .param pmc param_688 :slurpy
.annotate 'line', 309
    .const 'Sub' $P726 = "33_1306916577.75068" 
    capture_lex $P726
    .const 'Sub' $P706 = "32_1306916577.75068" 
    capture_lex $P706
    .lex "@type_args", param_688
.annotate 'line', 311
    new $P689, "Undef"
    .lex "$invoke_body", $P689
    get_hll_global $P690, "GLOBAL"
    nqp_get_package_through_who $P691, $P690, "PAST"
    get_who $P692, $P691
    set $P693, $P692["Op"]
.annotate 'line', 313
    get_hll_global $P694, "GLOBAL"
    nqp_get_package_through_who $P695, $P694, "PAST"
    get_who $P696, $P695
    set $P697, $P696["Val"]
    find_lex $P698, "$body_past"
    unless_null $P698, vivify_792
    new $P698, "Undef"
  vivify_792:
    $P699 = $P697."new"($P698 :named("value"))
    $P700 = $P693."new"($P699, "call" :named("pasttype"))
.annotate 'line', 311
    store_lex "$invoke_body", $P700
.annotate 'line', 315
    find_lex $P702, "@type_args"
    unless_null $P702, vivify_793
    $P702 = root_new ['parrot';'ResizablePMCArray']
  vivify_793:
    defined $I703, $P702
    unless $I703, for_undef_794
    iter $P701, $P702
    new $P714, 'ExceptionHandler'
    set_label $P714, loop713_handler
    $P714."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P714
  loop713_test:
    unless $P701, loop713_done
    shift $P704, $P701
  loop713_redo:
    .const 'Sub' $P706 = "32_1306916577.75068" 
    capture_lex $P706
    $P706($P704)
  loop713_next:
    goto loop713_test
  loop713_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P715, exception, 'type'
    eq $P715, .CONTROL_LOOP_NEXT, loop713_next
    eq $P715, .CONTROL_LOOP_REDO, loop713_redo
  loop713_done:
    pop_eh 
  for_undef_794:
.annotate 'line', 318
    find_lex $P716, "$fixups"
    unless_null $P716, vivify_797
    new $P716, "Undef"
  vivify_797:
    find_lex $P717, "$invoke_body"
    unless_null $P717, vivify_798
    new $P717, "Undef"
  vivify_798:
    $P716."push"($P717)
.annotate 'line', 321
    find_lex $P719, "$obj"
    unless_null $P719, vivify_799
    new $P719, "Undef"
  vivify_799:
    get_how $P720, $P719
    find_lex $P721, "$obj"
    unless_null $P721, vivify_800
    new $P721, "Undef"
  vivify_800:
    $P722 = $P720."methods"($P721, 1 :named("local"))
    defined $I723, $P722
    unless $I723, for_undef_801
    iter $P718, $P722
    new $P756, 'ExceptionHandler'
    set_label $P756, loop755_handler
    $P756."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P756
  loop755_test:
    unless $P718, loop755_done
    shift $P724, $P718
  loop755_redo:
    .const 'Sub' $P726 = "33_1306916577.75068" 
    capture_lex $P726
    $P726($P724)
  loop755_next:
    goto loop755_test
  loop755_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P757, exception, 'type'
    eq $P757, .CONTROL_LOOP_NEXT, loop755_next
    eq $P757, .CONTROL_LOOP_REDO, loop755_redo
  loop755_done:
    pop_eh 
  for_undef_801:
.annotate 'line', 309
    .return ($P718)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block705"  :anon :subid("32_1306916577.75068") :outer("31_1306916577.75068")
    .param pmc param_707
.annotate 'line', 315
    .lex "$_", param_707
.annotate 'line', 316
    find_lex $P708, "$invoke_body"
    unless_null $P708, vivify_795
    new $P708, "Undef"
  vivify_795:
    find_lex $P709, "self"
    find_lex $P710, "$_"
    unless_null $P710, vivify_796
    new $P710, "Undef"
  vivify_796:
    $P711 = $P709."get_slot_past_for_object"($P710)
    $P712 = $P708."push"($P711)
.annotate 'line', 315
    .return ($P712)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block725"  :anon :subid("33_1306916577.75068") :outer("31_1306916577.75068")
    .param pmc param_727
.annotate 'line', 321
    .const 'Sub' $P730 = "34_1306916577.75068" 
    capture_lex $P730
    .lex "$_", param_727
.annotate 'line', 322
    find_lex $P728, "$_"
    unless_null $P728, vivify_802
    new $P728, "Undef"
  vivify_802:
    .const 'Sub' $P730 = "34_1306916577.75068" 
    newclosure $P754, $P730
    setprop $P728, "REIFY_CALLBACK", $P754
.annotate 'line', 321
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block729"  :anon :subid("34_1306916577.75068") :outer("33_1306916577.75068")
    .param pmc param_731
.annotate 'line', 322
    .lex "$meth", param_731
.annotate 'line', 324
    new $P732, "Undef"
    .lex "$clone", $P732
    find_lex $P733, "$meth"
    unless_null $P733, vivify_803
    new $P733, "Undef"
  vivify_803:
    clone $P734, $P733
    store_lex "$clone", $P734
.annotate 'line', 325
    find_lex $P735, "self"
    find_lex $P736, "$clone"
    unless_null $P736, vivify_804
    new $P736, "Undef"
  vivify_804:
    $P735."add_code"($P736)
.annotate 'line', 328
    find_lex $P737, "$fixups"
    unless_null $P737, vivify_805
    new $P737, "Undef"
  vivify_805:
    get_hll_global $P738, "GLOBAL"
    nqp_get_package_through_who $P739, $P738, "PAST"
    get_who $P740, $P739
    set $P741, $P740["Op"]
.annotate 'line', 330
    find_lex $P742, "self"
    find_lex $P743, "$clone"
    unless_null $P743, vivify_806
    new $P743, "Undef"
  vivify_806:
    $P744 = $P742."get_slot_past_for_object"($P743)
.annotate 'line', 331
    get_hll_global $P745, "GLOBAL"
    nqp_get_package_through_who $P746, $P745, "PAST"
    get_who $P747, $P746
    set $P748, $P747["Val"]
    find_lex $P749, "$meth"
    unless_null $P749, vivify_807
    new $P749, "Undef"
  vivify_807:
    getprop $P750, "PAST", $P749
    $P751 = $P748."new"($P750 :named("value"))
    $P752 = $P741."new"($P744, $P751, "assign vPP" :named("pirop"))
.annotate 'line', 328
    $P737."push"($P752)
    find_lex $P753, "$clone"
    unless_null $P753, vivify_808
    new $P753, "Undef"
  vivify_808:
.annotate 'line', 322
    .return ($P753)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parent_or_role" :anon :subid("35_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_789
    .param pmc param_790
    .param pmc param_791
    .param pmc param_792
.annotate 'line', 357
    .lex "self", param_789
    .lex "$obj", param_790
    .lex "$meta_method_name", param_791
    .lex "$to_add", param_792
.annotate 'line', 362
    new $P793, "Undef"
    .lex "$slot_past", $P793
.annotate 'line', 359
    find_lex $P794, "$obj"
    unless_null $P794, vivify_818
    new $P794, "Undef"
  vivify_818:
    get_how $P795, $P794
    find_lex $P796, "$obj"
    unless_null $P796, vivify_819
    new $P796, "Undef"
  vivify_819:
    find_lex $P797, "$to_add"
    unless_null $P797, vivify_820
    new $P797, "Undef"
  vivify_820:
    find_lex $P798, "$meta_method_name"
    unless_null $P798, vivify_821
    new $P798, "Undef"
  vivify_821:
    set $S799, $P798
    $P795.$S799($P796, $P797)
.annotate 'line', 362
    find_lex $P800, "self"
    find_lex $P801, "$obj"
    unless_null $P801, vivify_822
    new $P801, "Undef"
  vivify_822:
    $P802 = $P800."get_slot_past_for_object"($P801)
    store_lex "$slot_past", $P802
.annotate 'line', 363
    find_lex $P803, "self"
    get_hll_global $P804, "GLOBAL"
    nqp_get_package_through_who $P805, $P804, "PAST"
    get_who $P806, $P805
    set $P807, $P806["Op"]
    find_lex $P808, "$meta_method_name"
    unless_null $P808, vivify_823
    new $P808, "Undef"
  vivify_823:
.annotate 'line', 365
    get_hll_global $P809, "GLOBAL"
    nqp_get_package_through_who $P810, $P809, "PAST"
    get_who $P811, $P810
    set $P812, $P811["Op"]
    find_lex $P813, "$slot_past"
    unless_null $P813, vivify_824
    new $P813, "Undef"
  vivify_824:
    $P814 = $P812."new"($P813, "get_how PP" :named("pirop"))
    find_lex $P815, "$slot_past"
    unless_null $P815, vivify_825
    new $P815, "Undef"
  vivify_825:
.annotate 'line', 367
    find_lex $P816, "self"
    find_lex $P817, "$to_add"
    unless_null $P817, vivify_826
    new $P817, "Undef"
  vivify_826:
    $P818 = $P816."get_object_sc_ref_past"($P817)
    $P819 = $P807."new"($P814, $P815, $P818, "callmethod" :named("pasttype"), $P808 :named("name"))
.annotate 'line', 363
    $P820 = $P803."add_event"($P819 :named("deserialize_past"))
.annotate 'line', 357
    .return ($P820)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parrot_vtable_handler_mapping" :anon :subid("36_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_822
    .param pmc param_823
    .param pmc param_824
    .param pmc param_825
.annotate 'line', 371
    .lex "self", param_822
    .lex "$obj", param_823
    .lex "$name", param_824
    .lex "$att_name", param_825
.annotate 'line', 376
    new $P826, "Undef"
    .lex "$slot_past", $P826
.annotate 'line', 373
    find_lex $P827, "$obj"
    unless_null $P827, vivify_827
    new $P827, "Undef"
  vivify_827:
    get_how $P828, $P827
    find_lex $P829, "$obj"
    unless_null $P829, vivify_828
    new $P829, "Undef"
  vivify_828:
    find_lex $P830, "$name"
    unless_null $P830, vivify_829
    new $P830, "Undef"
  vivify_829:
    find_lex $P831, "$att_name"
    unless_null $P831, vivify_830
    new $P831, "Undef"
  vivify_830:
    $P828."add_parrot_vtable_handler_mapping"($P829, $P830, $P831)
.annotate 'line', 376
    find_lex $P832, "self"
    find_lex $P833, "$obj"
    unless_null $P833, vivify_831
    new $P833, "Undef"
  vivify_831:
    $P834 = $P832."get_slot_past_for_object"($P833)
    store_lex "$slot_past", $P834
.annotate 'line', 377
    find_lex $P835, "self"
    get_hll_global $P836, "GLOBAL"
    nqp_get_package_through_who $P837, $P836, "PAST"
    get_who $P838, $P837
    set $P839, $P838["Op"]
.annotate 'line', 379
    get_hll_global $P840, "GLOBAL"
    nqp_get_package_through_who $P841, $P840, "PAST"
    get_who $P842, $P841
    set $P843, $P842["Op"]
    find_lex $P844, "$slot_past"
    unless_null $P844, vivify_832
    new $P844, "Undef"
  vivify_832:
    $P845 = $P843."new"($P844, "get_how PP" :named("pirop"))
    find_lex $P846, "$slot_past"
    unless_null $P846, vivify_833
    new $P846, "Undef"
  vivify_833:
    find_lex $P847, "$name"
    unless_null $P847, vivify_834
    new $P847, "Undef"
  vivify_834:
    find_lex $P848, "$att_name"
    unless_null $P848, vivify_835
    new $P848, "Undef"
  vivify_835:
    $P849 = $P839."new"($P845, $P846, $P847, $P848, "callmethod" :named("pasttype"), "add_parrot_vtable_handler_mapping" :named("name"))
.annotate 'line', 377
    $P850 = $P835."add_event"($P849 :named("deserialize_past"))
.annotate 'line', 371
    .return ($P850)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_compose" :anon :subid("37_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_852
    .param pmc param_853
.annotate 'line', 386
    .lex "self", param_852
    .lex "$obj", param_853
.annotate 'line', 391
    new $P854, "Undef"
    .lex "$slot_past", $P854
.annotate 'line', 388
    find_lex $P855, "$obj"
    unless_null $P855, vivify_836
    new $P855, "Undef"
  vivify_836:
    get_how $P856, $P855
    find_lex $P857, "$obj"
    unless_null $P857, vivify_837
    new $P857, "Undef"
  vivify_837:
    $P856."compose"($P857)
.annotate 'line', 391
    find_lex $P858, "self"
    find_lex $P859, "$obj"
    unless_null $P859, vivify_838
    new $P859, "Undef"
  vivify_838:
    $P860 = $P858."get_slot_past_for_object"($P859)
    store_lex "$slot_past", $P860
.annotate 'line', 392
    find_lex $P861, "self"
    get_hll_global $P862, "GLOBAL"
    nqp_get_package_through_who $P863, $P862, "PAST"
    get_who $P864, $P863
    set $P865, $P864["Op"]
.annotate 'line', 394
    get_hll_global $P866, "GLOBAL"
    nqp_get_package_through_who $P867, $P866, "PAST"
    get_who $P868, $P867
    set $P869, $P868["Op"]
    find_lex $P870, "$slot_past"
    unless_null $P870, vivify_839
    new $P870, "Undef"
  vivify_839:
    $P871 = $P869."new"($P870, "get_how PP" :named("pirop"))
    find_lex $P872, "$slot_past"
    unless_null $P872, vivify_840
    new $P872, "Undef"
  vivify_840:
    $P873 = $P865."new"($P871, $P872, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 392
    $P874 = $P861."add_event"($P873 :named("deserialize_past"))
.annotate 'line', 386
    .return ($P874)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "to_past" :anon :subid("38_1306916577.75068") :outer("13_1306916577.75068")
    .param pmc param_876
.annotate 'line', 401
    .const 'Sub' $P895 = "39_1306916577.75068" 
    capture_lex $P895
    .lex "self", param_876
.annotate 'line', 402
    new $P877, "Undef"
    .lex "$des", $P877
.annotate 'line', 403
    new $P878, "Undef"
    .lex "$fix", $P878
.annotate 'line', 402
    get_hll_global $P879, "GLOBAL"
    nqp_get_package_through_who $P880, $P879, "PAST"
    get_who $P881, $P880
    set $P882, $P881["Stmts"]
    $P883 = $P882."new"()
    store_lex "$des", $P883
.annotate 'line', 403
    get_hll_global $P884, "GLOBAL"
    nqp_get_package_through_who $P885, $P884, "PAST"
    get_who $P886, $P885
    set $P887, $P886["Stmts"]
    $P888 = $P887."new"()
    store_lex "$fix", $P888
.annotate 'line', 404
    find_lex $P890, "self"
    $P891 = $P890."event_stream"()
    defined $I892, $P891
    unless $I892, for_undef_841
    iter $P889, $P891
    new $P914, 'ExceptionHandler'
    set_label $P914, loop913_handler
    $P914."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P914
  loop913_test:
    unless $P889, loop913_done
    shift $P893, $P889
  loop913_redo:
    .const 'Sub' $P895 = "39_1306916577.75068" 
    capture_lex $P895
    $P895($P893)
  loop913_next:
    goto loop913_test
  loop913_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P915, exception, 'type'
    eq $P915, .CONTROL_LOOP_NEXT, loop913_next
    eq $P915, .CONTROL_LOOP_REDO, loop913_redo
  loop913_done:
    pop_eh 
  for_undef_841:
.annotate 'line', 408
    find_dynamic_lex $P916, "$/"
    get_hll_global $P917, "GLOBAL"
    nqp_get_package_through_who $P918, $P917, "PAST"
    get_who $P919, $P918
    set $P920, $P919["Op"]
.annotate 'line', 410
    get_hll_global $P921, "GLOBAL"
    nqp_get_package_through_who $P922, $P921, "PAST"
    get_who $P923, $P922
    set $P924, $P923["Op"]
.annotate 'line', 412
    get_hll_global $P925, "GLOBAL"
    nqp_get_package_through_who $P926, $P925, "PAST"
    get_who $P927, $P926
    set $P928, $P927["Op"]
    find_lex $P929, "self"
    $P930 = $P929."handle"()
    $P931 = $P928."new"($P930, "nqp_get_sc Ps" :named("pirop"))
    $P932 = $P924."new"($P931, "isnull IP" :named("pirop"))
.annotate 'line', 414
    get_hll_global $P933, "GLOBAL"
    nqp_get_package_through_who $P934, $P933, "PAST"
    get_who $P935, $P934
    set $P936, $P935["Stmts"]
.annotate 'line', 415
    get_hll_global $P937, "GLOBAL"
    nqp_get_package_through_who $P938, $P937, "PAST"
    get_who $P939, $P938
    set $P940, $P939["Op"]
    $P941 = $P940."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 416
    get_hll_global $P942, "GLOBAL"
    nqp_get_package_through_who $P943, $P942, "PAST"
    get_who $P944, $P943
    set $P945, $P944["Op"]
.annotate 'line', 418
    get_hll_global $P946, "GLOBAL"
    nqp_get_package_through_who $P947, $P946, "PAST"
    get_who $P948, $P947
    set $P949, $P948["Op"]
    $P950 = $P949."new"("getinterp P" :named("pirop"))
.annotate 'line', 419
    get_hll_global $P951, "GLOBAL"
    nqp_get_package_through_who $P952, $P951, "PAST"
    get_who $P953, $P952
    set $P954, $P953["Op"]
    $P955 = $P954."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 420
    get_hll_global $P956, "GLOBAL"
    nqp_get_package_through_who $P957, $P956, "PAST"
    get_who $P958, $P957
    set $P959, $P958["Op"]
    $P960 = $P959."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P961 = $P945."new"($P950, $P955, $P960, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 422
    get_hll_global $P962, "GLOBAL"
    nqp_get_package_through_who $P963, $P962, "PAST"
    get_who $P964, $P963
    set $P965, $P964["Op"]
.annotate 'line', 424
    get_hll_global $P966, "GLOBAL"
    nqp_get_package_through_who $P967, $P966, "PAST"
    get_who $P968, $P967
    set $P969, $P968["Var"]
    $P970 = $P969."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 425
    get_hll_global $P971, "GLOBAL"
    nqp_get_package_through_who $P972, $P971, "PAST"
    get_who $P973, $P972
    set $P974, $P973["Op"]
    find_lex $P975, "self"
    $P976 = $P975."handle"()
    $P977 = $P974."new"($P976, "nqp_create_sc Ps" :named("pirop"))
    $P978 = $P965."new"($P970, $P977, "bind" :named("pasttype"))
.annotate 'line', 422
    find_lex $P979, "$des"
    unless_null $P979, vivify_848
    new $P979, "Undef"
  vivify_848:
    $P980 = $P936."new"($P941, $P961, $P978, $P979)
.annotate 'line', 414
    find_lex $P981, "$fix"
    unless_null $P981, vivify_849
    new $P981, "Undef"
  vivify_849:
    $P982 = $P920."new"($P932, $P980, $P981, "if" :named("pasttype"))
.annotate 'line', 408
    $P983 = $P916."!make"($P982)
.annotate 'line', 401
    .return ($P983)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block894"  :anon :subid("39_1306916577.75068") :outer("38_1306916577.75068")
    .param pmc param_896
.annotate 'line', 404
    .lex "$_", param_896
.annotate 'line', 405
    find_lex $P898, "$_"
    unless_null $P898, vivify_842
    new $P898, "Undef"
  vivify_842:
    $P899 = $P898."deserialize_past"()
    defined $I900, $P899
    unless $I900, if_897_end
    find_lex $P901, "$des"
    unless_null $P901, vivify_843
    new $P901, "Undef"
  vivify_843:
    find_lex $P902, "$_"
    unless_null $P902, vivify_844
    new $P902, "Undef"
  vivify_844:
    $P903 = $P902."deserialize_past"()
    $P901."push"($P903)
  if_897_end:
.annotate 'line', 406
    find_lex $P906, "$_"
    unless_null $P906, vivify_845
    new $P906, "Undef"
  vivify_845:
    $P907 = $P906."fixup_past"()
    defined $I908, $P907
    if $I908, if_905
    new $P904, 'Integer'
    set $P904, $I908
    goto if_905_end
  if_905:
    find_lex $P909, "$fix"
    unless_null $P909, vivify_846
    new $P909, "Undef"
  vivify_846:
    find_lex $P910, "$_"
    unless_null $P910, vivify_847
    new $P910, "Undef"
  vivify_847:
    $P911 = $P910."fixup_past"()
    $P912 = $P909."push"($P911)
    set $P904, $P912
  if_905_end:
.annotate 'line', 404
    .return ($P904)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block985"  :subid("40_1306916577.75068") :outer("10_1306916577.75068")
.annotate 'line', 435
    .const 'Sub' $P2857 = "414_1306916577.75068" 
    capture_lex $P2857
    .const 'Sub' $P2855 = "413_1306916577.75068" 
    capture_lex $P2855
    .const 'Sub' $P2851 = "412_1306916577.75068" 
    capture_lex $P2851
    .const 'Sub' $P2849 = "411_1306916577.75068" 
    capture_lex $P2849
    .const 'Sub' $P2845 = "410_1306916577.75068" 
    capture_lex $P2845
    .const 'Sub' $P2843 = "409_1306916577.75068" 
    capture_lex $P2843
    .const 'Sub' $P2839 = "408_1306916577.75068" 
    capture_lex $P2839
    .const 'Sub' $P2837 = "407_1306916577.75068" 
    capture_lex $P2837
    .const 'Sub' $P2833 = "406_1306916577.75068" 
    capture_lex $P2833
    .const 'Sub' $P2831 = "405_1306916577.75068" 
    capture_lex $P2831
    .const 'Sub' $P2821 = "403_1306916577.75068" 
    capture_lex $P2821
    .const 'Sub' $P2818 = "402_1306916577.75068" 
    capture_lex $P2818
    .const 'Sub' $P2814 = "401_1306916577.75068" 
    capture_lex $P2814
    .const 'Sub' $P2811 = "400_1306916577.75068" 
    capture_lex $P2811
    .const 'Sub' $P2807 = "399_1306916577.75068" 
    capture_lex $P2807
    .const 'Sub' $P2804 = "398_1306916577.75068" 
    capture_lex $P2804
    .const 'Sub' $P2800 = "397_1306916577.75068" 
    capture_lex $P2800
    .const 'Sub' $P2797 = "396_1306916577.75068" 
    capture_lex $P2797
    .const 'Sub' $P2793 = "395_1306916577.75068" 
    capture_lex $P2793
    .const 'Sub' $P2790 = "394_1306916577.75068" 
    capture_lex $P2790
    .const 'Sub' $P2787 = "393_1306916577.75068" 
    capture_lex $P2787
    .const 'Sub' $P2784 = "392_1306916577.75068" 
    capture_lex $P2784
    .const 'Sub' $P2780 = "391_1306916577.75068" 
    capture_lex $P2780
    .const 'Sub' $P2777 = "390_1306916577.75068" 
    capture_lex $P2777
    .const 'Sub' $P2773 = "389_1306916577.75068" 
    capture_lex $P2773
    .const 'Sub' $P2770 = "388_1306916577.75068" 
    capture_lex $P2770
    .const 'Sub' $P2766 = "387_1306916577.75068" 
    capture_lex $P2766
    .const 'Sub' $P2763 = "386_1306916577.75068" 
    capture_lex $P2763
    .const 'Sub' $P2759 = "385_1306916577.75068" 
    capture_lex $P2759
    .const 'Sub' $P2756 = "384_1306916577.75068" 
    capture_lex $P2756
    .const 'Sub' $P2752 = "383_1306916577.75068" 
    capture_lex $P2752
    .const 'Sub' $P2749 = "382_1306916577.75068" 
    capture_lex $P2749
    .const 'Sub' $P2745 = "381_1306916577.75068" 
    capture_lex $P2745
    .const 'Sub' $P2742 = "380_1306916577.75068" 
    capture_lex $P2742
    .const 'Sub' $P2738 = "379_1306916577.75068" 
    capture_lex $P2738
    .const 'Sub' $P2735 = "378_1306916577.75068" 
    capture_lex $P2735
    .const 'Sub' $P2731 = "377_1306916577.75068" 
    capture_lex $P2731
    .const 'Sub' $P2728 = "376_1306916577.75068" 
    capture_lex $P2728
    .const 'Sub' $P2724 = "375_1306916577.75068" 
    capture_lex $P2724
    .const 'Sub' $P2721 = "374_1306916577.75068" 
    capture_lex $P2721
    .const 'Sub' $P2717 = "373_1306916577.75068" 
    capture_lex $P2717
    .const 'Sub' $P2714 = "372_1306916577.75068" 
    capture_lex $P2714
    .const 'Sub' $P2710 = "371_1306916577.75068" 
    capture_lex $P2710
    .const 'Sub' $P2707 = "370_1306916577.75068" 
    capture_lex $P2707
    .const 'Sub' $P2703 = "369_1306916577.75068" 
    capture_lex $P2703
    .const 'Sub' $P2700 = "368_1306916577.75068" 
    capture_lex $P2700
    .const 'Sub' $P2696 = "367_1306916577.75068" 
    capture_lex $P2696
    .const 'Sub' $P2693 = "366_1306916577.75068" 
    capture_lex $P2693
    .const 'Sub' $P2689 = "365_1306916577.75068" 
    capture_lex $P2689
    .const 'Sub' $P2686 = "364_1306916577.75068" 
    capture_lex $P2686
    .const 'Sub' $P2682 = "363_1306916577.75068" 
    capture_lex $P2682
    .const 'Sub' $P2679 = "362_1306916577.75068" 
    capture_lex $P2679
    .const 'Sub' $P2675 = "361_1306916577.75068" 
    capture_lex $P2675
    .const 'Sub' $P2672 = "360_1306916577.75068" 
    capture_lex $P2672
    .const 'Sub' $P2668 = "359_1306916577.75068" 
    capture_lex $P2668
    .const 'Sub' $P2665 = "358_1306916577.75068" 
    capture_lex $P2665
    .const 'Sub' $P2661 = "357_1306916577.75068" 
    capture_lex $P2661
    .const 'Sub' $P2658 = "356_1306916577.75068" 
    capture_lex $P2658
    .const 'Sub' $P2654 = "355_1306916577.75068" 
    capture_lex $P2654
    .const 'Sub' $P2651 = "354_1306916577.75068" 
    capture_lex $P2651
    .const 'Sub' $P2647 = "353_1306916577.75068" 
    capture_lex $P2647
    .const 'Sub' $P2644 = "352_1306916577.75068" 
    capture_lex $P2644
    .const 'Sub' $P2640 = "351_1306916577.75068" 
    capture_lex $P2640
    .const 'Sub' $P2637 = "350_1306916577.75068" 
    capture_lex $P2637
    .const 'Sub' $P2633 = "349_1306916577.75068" 
    capture_lex $P2633
    .const 'Sub' $P2630 = "348_1306916577.75068" 
    capture_lex $P2630
    .const 'Sub' $P2626 = "347_1306916577.75068" 
    capture_lex $P2626
    .const 'Sub' $P2623 = "346_1306916577.75068" 
    capture_lex $P2623
    .const 'Sub' $P2619 = "345_1306916577.75068" 
    capture_lex $P2619
    .const 'Sub' $P2616 = "344_1306916577.75068" 
    capture_lex $P2616
    .const 'Sub' $P2612 = "343_1306916577.75068" 
    capture_lex $P2612
    .const 'Sub' $P2609 = "342_1306916577.75068" 
    capture_lex $P2609
    .const 'Sub' $P2605 = "341_1306916577.75068" 
    capture_lex $P2605
    .const 'Sub' $P2602 = "340_1306916577.75068" 
    capture_lex $P2602
    .const 'Sub' $P2598 = "339_1306916577.75068" 
    capture_lex $P2598
    .const 'Sub' $P2595 = "338_1306916577.75068" 
    capture_lex $P2595
    .const 'Sub' $P2591 = "337_1306916577.75068" 
    capture_lex $P2591
    .const 'Sub' $P2588 = "336_1306916577.75068" 
    capture_lex $P2588
    .const 'Sub' $P2584 = "335_1306916577.75068" 
    capture_lex $P2584
    .const 'Sub' $P2582 = "334_1306916577.75068" 
    capture_lex $P2582
    .const 'Sub' $P2578 = "333_1306916577.75068" 
    capture_lex $P2578
    .const 'Sub' $P2575 = "332_1306916577.75068" 
    capture_lex $P2575
    .const 'Sub' $P2571 = "331_1306916577.75068" 
    capture_lex $P2571
    .const 'Sub' $P2568 = "330_1306916577.75068" 
    capture_lex $P2568
    .const 'Sub' $P2564 = "329_1306916577.75068" 
    capture_lex $P2564
    .const 'Sub' $P2561 = "328_1306916577.75068" 
    capture_lex $P2561
    .const 'Sub' $P2557 = "327_1306916577.75068" 
    capture_lex $P2557
    .const 'Sub' $P2554 = "326_1306916577.75068" 
    capture_lex $P2554
    .const 'Sub' $P2550 = "325_1306916577.75068" 
    capture_lex $P2550
    .const 'Sub' $P2547 = "324_1306916577.75068" 
    capture_lex $P2547
    .const 'Sub' $P2543 = "323_1306916577.75068" 
    capture_lex $P2543
    .const 'Sub' $P2540 = "322_1306916577.75068" 
    capture_lex $P2540
    .const 'Sub' $P2536 = "321_1306916577.75068" 
    capture_lex $P2536
    .const 'Sub' $P2533 = "320_1306916577.75068" 
    capture_lex $P2533
    .const 'Sub' $P2529 = "319_1306916577.75068" 
    capture_lex $P2529
    .const 'Sub' $P2526 = "318_1306916577.75068" 
    capture_lex $P2526
    .const 'Sub' $P2523 = "317_1306916577.75068" 
    capture_lex $P2523
    .const 'Sub' $P2520 = "316_1306916577.75068" 
    capture_lex $P2520
    .const 'Sub' $P2517 = "315_1306916577.75068" 
    capture_lex $P2517
    .const 'Sub' $P2515 = "314_1306916577.75068" 
    capture_lex $P2515
    .const 'Sub' $P2512 = "313_1306916577.75068" 
    capture_lex $P2512
    .const 'Sub' $P2509 = "312_1306916577.75068" 
    capture_lex $P2509
    .const 'Sub' $P2506 = "311_1306916577.75068" 
    capture_lex $P2506
    .const 'Sub' $P2503 = "310_1306916577.75068" 
    capture_lex $P2503
    .const 'Sub' $P2500 = "309_1306916577.75068" 
    capture_lex $P2500
    .const 'Sub' $P2498 = "308_1306916577.75068" 
    capture_lex $P2498
    .const 'Sub' $P2495 = "307_1306916577.75068" 
    capture_lex $P2495
    .const 'Sub' $P2493 = "306_1306916577.75068" 
    capture_lex $P2493
    .const 'Sub' $P2490 = "305_1306916577.75068" 
    capture_lex $P2490
    .const 'Sub' $P2487 = "304_1306916577.75068" 
    capture_lex $P2487
    .const 'Sub' $P2482 = "303_1306916577.75068" 
    capture_lex $P2482
    .const 'Sub' $P2479 = "302_1306916577.75068" 
    capture_lex $P2479
    .const 'Sub' $P2473 = "301_1306916577.75068" 
    capture_lex $P2473
    .const 'Sub' $P2471 = "300_1306916577.75068" 
    capture_lex $P2471
    .const 'Sub' $P2468 = "299_1306916577.75068" 
    capture_lex $P2468
    .const 'Sub' $P2466 = "298_1306916577.75068" 
    capture_lex $P2466
    .const 'Sub' $P2463 = "297_1306916577.75068" 
    capture_lex $P2463
    .const 'Sub' $P2461 = "296_1306916577.75068" 
    capture_lex $P2461
    .const 'Sub' $P2458 = "295_1306916577.75068" 
    capture_lex $P2458
    .const 'Sub' $P2455 = "294_1306916577.75068" 
    capture_lex $P2455
    .const 'Sub' $P2450 = "293_1306916577.75068" 
    capture_lex $P2450
    .const 'Sub' $P2447 = "292_1306916577.75068" 
    capture_lex $P2447
    .const 'Sub' $P2442 = "291_1306916577.75068" 
    capture_lex $P2442
    .const 'Sub' $P2440 = "290_1306916577.75068" 
    capture_lex $P2440
    .const 'Sub' $P2437 = "289_1306916577.75068" 
    capture_lex $P2437
    .const 'Sub' $P2435 = "288_1306916577.75068" 
    capture_lex $P2435
    .const 'Sub' $P2432 = "287_1306916577.75068" 
    capture_lex $P2432
    .const 'Sub' $P2430 = "286_1306916577.75068" 
    capture_lex $P2430
    .const 'Sub' $P2427 = "285_1306916577.75068" 
    capture_lex $P2427
    .const 'Sub' $P2424 = "284_1306916577.75068" 
    capture_lex $P2424
    .const 'Sub' $P2421 = "283_1306916577.75068" 
    capture_lex $P2421
    .const 'Sub' $P2418 = "282_1306916577.75068" 
    capture_lex $P2418
    .const 'Sub' $P2414 = "281_1306916577.75068" 
    capture_lex $P2414
    .const 'Sub' $P2411 = "280_1306916577.75068" 
    capture_lex $P2411
    .const 'Sub' $P2407 = "279_1306916577.75068" 
    capture_lex $P2407
    .const 'Sub' $P2404 = "278_1306916577.75068" 
    capture_lex $P2404
    .const 'Sub' $P2400 = "277_1306916577.75068" 
    capture_lex $P2400
    .const 'Sub' $P2397 = "276_1306916577.75068" 
    capture_lex $P2397
    .const 'Sub' $P2393 = "275_1306916577.75068" 
    capture_lex $P2393
    .const 'Sub' $P2391 = "274_1306916577.75068" 
    capture_lex $P2391
    .const 'Sub' $P2388 = "273_1306916577.75068" 
    capture_lex $P2388
    .const 'Sub' $P2386 = "272_1306916577.75068" 
    capture_lex $P2386
    .const 'Sub' $P2383 = "271_1306916577.75068" 
    capture_lex $P2383
    .const 'Sub' $P2375 = "268_1306916577.75068" 
    capture_lex $P2375
    .const 'Sub' $P2369 = "267_1306916577.75068" 
    capture_lex $P2369
    .const 'Sub' $P2365 = "266_1306916577.75068" 
    capture_lex $P2365
    .const 'Sub' $P2361 = "265_1306916577.75068" 
    capture_lex $P2361
    .const 'Sub' $P2358 = "264_1306916577.75068" 
    capture_lex $P2358
    .const 'Sub' $P2355 = "263_1306916577.75068" 
    capture_lex $P2355
    .const 'Sub' $P2352 = "262_1306916577.75068" 
    capture_lex $P2352
    .const 'Sub' $P2348 = "261_1306916577.75068" 
    capture_lex $P2348
    .const 'Sub' $P2345 = "260_1306916577.75068" 
    capture_lex $P2345
    .const 'Sub' $P2342 = "259_1306916577.75068" 
    capture_lex $P2342
    .const 'Sub' $P2340 = "258_1306916577.75068" 
    capture_lex $P2340
    .const 'Sub' $P2326 = "256_1306916577.75068" 
    capture_lex $P2326
    .const 'Sub' $P2324 = "255_1306916577.75068" 
    capture_lex $P2324
    .const 'Sub' $P2318 = "254_1306916577.75068" 
    capture_lex $P2318
    .const 'Sub' $P2315 = "253_1306916577.75068" 
    capture_lex $P2315
    .const 'Sub' $P2310 = "252_1306916577.75068" 
    capture_lex $P2310
    .const 'Sub' $P2307 = "251_1306916577.75068" 
    capture_lex $P2307
    .const 'Sub' $P2304 = "250_1306916577.75068" 
    capture_lex $P2304
    .const 'Sub' $P2302 = "249_1306916577.75068" 
    capture_lex $P2302
    .const 'Sub' $P2298 = "248_1306916577.75068" 
    capture_lex $P2298
    .const 'Sub' $P2289 = "245_1306916577.75068" 
    capture_lex $P2289
    .const 'Sub' $P2282 = "244_1306916577.75068" 
    capture_lex $P2282
    .const 'Sub' $P2279 = "243_1306916577.75068" 
    capture_lex $P2279
    .const 'Sub' $P2241 = "242_1306916577.75068" 
    capture_lex $P2241
    .const 'Sub' $P2238 = "241_1306916577.75068" 
    capture_lex $P2238
    .const 'Sub' $P2230 = "240_1306916577.75068" 
    capture_lex $P2230
    .const 'Sub' $P2221 = "237_1306916577.75068" 
    capture_lex $P2221
    .const 'Sub' $P2216 = "236_1306916577.75068" 
    capture_lex $P2216
    .const 'Sub' $P2213 = "235_1306916577.75068" 
    capture_lex $P2213
    .const 'Sub' $P2207 = "234_1306916577.75068" 
    capture_lex $P2207
    .const 'Sub' $P2204 = "233_1306916577.75068" 
    capture_lex $P2204
    .const 'Sub' $P2201 = "232_1306916577.75068" 
    capture_lex $P2201
    .const 'Sub' $P2198 = "231_1306916577.75068" 
    capture_lex $P2198
    .const 'Sub' $P2191 = "230_1306916577.75068" 
    capture_lex $P2191
    .const 'Sub' $P2189 = "229_1306916577.75068" 
    capture_lex $P2189
    .const 'Sub' $P2176 = "228_1306916577.75068" 
    capture_lex $P2176
    .const 'Sub' $P2174 = "227_1306916577.75068" 
    capture_lex $P2174
    .const 'Sub' $P2160 = "225_1306916577.75068" 
    capture_lex $P2160
    .const 'Sub' $P2157 = "224_1306916577.75068" 
    capture_lex $P2157
    .const 'Sub' $P2152 = "223_1306916577.75068" 
    capture_lex $P2152
    .const 'Sub' $P2149 = "222_1306916577.75068" 
    capture_lex $P2149
    .const 'Sub' $P2142 = "221_1306916577.75068" 
    capture_lex $P2142
    .const 'Sub' $P2139 = "220_1306916577.75068" 
    capture_lex $P2139
    .const 'Sub' $P2132 = "219_1306916577.75068" 
    capture_lex $P2132
    .const 'Sub' $P2124 = "216_1306916577.75068" 
    capture_lex $P2124
    .const 'Sub' $P2111 = "214_1306916577.75068" 
    capture_lex $P2111
    .const 'Sub' $P2108 = "213_1306916577.75068" 
    capture_lex $P2108
    .const 'Sub' $P2067 = "211_1306916577.75068" 
    capture_lex $P2067
    .const 'Sub' $P2064 = "210_1306916577.75068" 
    capture_lex $P2064
    .const 'Sub' $P2033 = "209_1306916577.75068" 
    capture_lex $P2033
    .const 'Sub' $P2030 = "208_1306916577.75068" 
    capture_lex $P2030
    .const 'Sub' $P2026 = "207_1306916577.75068" 
    capture_lex $P2026
    .const 'Sub' $P2023 = "206_1306916577.75068" 
    capture_lex $P2023
    .const 'Sub' $P2019 = "205_1306916577.75068" 
    capture_lex $P2019
    .const 'Sub' $P2010 = "202_1306916577.75068" 
    capture_lex $P2010
    .const 'Sub' $P1989 = "200_1306916577.75068" 
    capture_lex $P1989
    .const 'Sub' $P1985 = "199_1306916577.75068" 
    capture_lex $P1985
    .const 'Sub' $P1981 = "198_1306916577.75068" 
    capture_lex $P1981
    .const 'Sub' $P1978 = "197_1306916577.75068" 
    capture_lex $P1978
    .const 'Sub' $P1962 = "195_1306916577.75068" 
    capture_lex $P1962
    .const 'Sub' $P1957 = "194_1306916577.75068" 
    capture_lex $P1957
    .const 'Sub' $P1946 = "193_1306916577.75068" 
    capture_lex $P1946
    .const 'Sub' $P1943 = "192_1306916577.75068" 
    capture_lex $P1943
    .const 'Sub' $P1939 = "191_1306916577.75068" 
    capture_lex $P1939
    .const 'Sub' $P1936 = "190_1306916577.75068" 
    capture_lex $P1936
    .const 'Sub' $P1932 = "189_1306916577.75068" 
    capture_lex $P1932
    .const 'Sub' $P1929 = "188_1306916577.75068" 
    capture_lex $P1929
    .const 'Sub' $P1925 = "187_1306916577.75068" 
    capture_lex $P1925
    .const 'Sub' $P1916 = "184_1306916577.75068" 
    capture_lex $P1916
    .const 'Sub' $P1752 = "182_1306916577.75068" 
    capture_lex $P1752
    .const 'Sub' $P1749 = "181_1306916577.75068" 
    capture_lex $P1749
    .const 'Sub' $P1729 = "180_1306916577.75068" 
    capture_lex $P1729
    .const 'Sub' $P1726 = "179_1306916577.75068" 
    capture_lex $P1726
    .const 'Sub' $P1716 = "178_1306916577.75068" 
    capture_lex $P1716
    .const 'Sub' $P1713 = "177_1306916577.75068" 
    capture_lex $P1713
    .const 'Sub' $P1703 = "176_1306916577.75068" 
    capture_lex $P1703
    .const 'Sub' $P1700 = "175_1306916577.75068" 
    capture_lex $P1700
    .const 'Sub' $P1690 = "174_1306916577.75068" 
    capture_lex $P1690
    .const 'Sub' $P1687 = "173_1306916577.75068" 
    capture_lex $P1687
    .const 'Sub' $P1677 = "172_1306916577.75068" 
    capture_lex $P1677
    .const 'Sub' $P1674 = "171_1306916577.75068" 
    capture_lex $P1674
    .const 'Sub' $P1664 = "170_1306916577.75068" 
    capture_lex $P1664
    .const 'Sub' $P1661 = "169_1306916577.75068" 
    capture_lex $P1661
    .const 'Sub' $P1651 = "168_1306916577.75068" 
    capture_lex $P1651
    .const 'Sub' $P1643 = "165_1306916577.75068" 
    capture_lex $P1643
    .const 'Sub' $P1640 = "164_1306916577.75068" 
    capture_lex $P1640
    .const 'Sub' $P1638 = "163_1306916577.75068" 
    capture_lex $P1638
    .const 'Sub' $P1635 = "162_1306916577.75068" 
    capture_lex $P1635
    .const 'Sub' $P1631 = "161_1306916577.75068" 
    capture_lex $P1631
    .const 'Sub' $P1623 = "160_1306916577.75068" 
    capture_lex $P1623
    .const 'Sub' $P1618 = "159_1306916577.75068" 
    capture_lex $P1618
    .const 'Sub' $P1611 = "158_1306916577.75068" 
    capture_lex $P1611
    .const 'Sub' $P1608 = "157_1306916577.75068" 
    capture_lex $P1608
    .const 'Sub' $P1604 = "156_1306916577.75068" 
    capture_lex $P1604
    .const 'Sub' $P1602 = "155_1306916577.75068" 
    capture_lex $P1602
    .const 'Sub' $P1599 = "154_1306916577.75068" 
    capture_lex $P1599
    .const 'Sub' $P1596 = "153_1306916577.75068" 
    capture_lex $P1596
    .const 'Sub' $P1593 = "152_1306916577.75068" 
    capture_lex $P1593
    .const 'Sub' $P1590 = "151_1306916577.75068" 
    capture_lex $P1590
    .const 'Sub' $P1587 = "150_1306916577.75068" 
    capture_lex $P1587
    .const 'Sub' $P1585 = "149_1306916577.75068" 
    capture_lex $P1585
    .const 'Sub' $P1572 = "146_1306916577.75068" 
    capture_lex $P1572
    .const 'Sub' $P1569 = "145_1306916577.75068" 
    capture_lex $P1569
    .const 'Sub' $P1566 = "144_1306916577.75068" 
    capture_lex $P1566
    .const 'Sub' $P1563 = "143_1306916577.75068" 
    capture_lex $P1563
    .const 'Sub' $P1560 = "142_1306916577.75068" 
    capture_lex $P1560
    .const 'Sub' $P1557 = "141_1306916577.75068" 
    capture_lex $P1557
    .const 'Sub' $P1554 = "140_1306916577.75068" 
    capture_lex $P1554
    .const 'Sub' $P1551 = "139_1306916577.75068" 
    capture_lex $P1551
    .const 'Sub' $P1548 = "138_1306916577.75068" 
    capture_lex $P1548
    .const 'Sub' $P1545 = "137_1306916577.75068" 
    capture_lex $P1545
    .const 'Sub' $P1542 = "136_1306916577.75068" 
    capture_lex $P1542
    .const 'Sub' $P1539 = "135_1306916577.75068" 
    capture_lex $P1539
    .const 'Sub' $P1536 = "134_1306916577.75068" 
    capture_lex $P1536
    .const 'Sub' $P1533 = "133_1306916577.75068" 
    capture_lex $P1533
    .const 'Sub' $P1527 = "132_1306916577.75068" 
    capture_lex $P1527
    .const 'Sub' $P1524 = "131_1306916577.75068" 
    capture_lex $P1524
    .const 'Sub' $P1518 = "130_1306916577.75068" 
    capture_lex $P1518
    .const 'Sub' $P1515 = "129_1306916577.75068" 
    capture_lex $P1515
    .const 'Sub' $P1509 = "128_1306916577.75068" 
    capture_lex $P1509
    .const 'Sub' $P1500 = "125_1306916577.75068" 
    capture_lex $P1500
    .const 'Sub' $P1494 = "124_1306916577.75068" 
    capture_lex $P1494
    .const 'Sub' $P1491 = "123_1306916577.75068" 
    capture_lex $P1491
    .const 'Sub' $P1485 = "122_1306916577.75068" 
    capture_lex $P1485
    .const 'Sub' $P1477 = "119_1306916577.75068" 
    capture_lex $P1477
    .const 'Sub' $P1473 = "118_1306916577.75068" 
    capture_lex $P1473
    .const 'Sub' $P1470 = "117_1306916577.75068" 
    capture_lex $P1470
    .const 'Sub' $P1466 = "116_1306916577.75068" 
    capture_lex $P1466
    .const 'Sub' $P1463 = "115_1306916577.75068" 
    capture_lex $P1463
    .const 'Sub' $P1459 = "114_1306916577.75068" 
    capture_lex $P1459
    .const 'Sub' $P1451 = "111_1306916577.75068" 
    capture_lex $P1451
    .const 'Sub' $P1445 = "110_1306916577.75068" 
    capture_lex $P1445
    .const 'Sub' $P1443 = "109_1306916577.75068" 
    capture_lex $P1443
    .const 'Sub' $P1437 = "108_1306916577.75068" 
    capture_lex $P1437
    .const 'Sub' $P1435 = "107_1306916577.75068" 
    capture_lex $P1435
    .const 'Sub' $P1429 = "106_1306916577.75068" 
    capture_lex $P1429
    .const 'Sub' $P1427 = "105_1306916577.75068" 
    capture_lex $P1427
    .const 'Sub' $P1409 = "104_1306916577.75068" 
    capture_lex $P1409
    .const 'Sub' $P1407 = "103_1306916577.75068" 
    capture_lex $P1407
    .const 'Sub' $P1400 = "102_1306916577.75068" 
    capture_lex $P1400
    .const 'Sub' $P1398 = "101_1306916577.75068" 
    capture_lex $P1398
    .const 'Sub' $P1382 = "99_1306916577.75068" 
    capture_lex $P1382
    .const 'Sub' $P1380 = "98_1306916577.75068" 
    capture_lex $P1380
    .const 'Sub' $P1364 = "97_1306916577.75068" 
    capture_lex $P1364
    .const 'Sub' $P1362 = "96_1306916577.75068" 
    capture_lex $P1362
    .const 'Sub' $P1356 = "95_1306916577.75068" 
    capture_lex $P1356
    .const 'Sub' $P1348 = "92_1306916577.75068" 
    capture_lex $P1348
    .const 'Sub' $P1345 = "91_1306916577.75068" 
    capture_lex $P1345
    .const 'Sub' $P1343 = "90_1306916577.75068" 
    capture_lex $P1343
    .const 'Sub' $P1340 = "89_1306916577.75068" 
    capture_lex $P1340
    .const 'Sub' $P1332 = "86_1306916577.75068" 
    capture_lex $P1332
    .const 'Sub' $P1329 = "85_1306916577.75068" 
    capture_lex $P1329
    .const 'Sub' $P1327 = "84_1306916577.75068" 
    capture_lex $P1327
    .const 'Sub' $P1324 = "83_1306916577.75068" 
    capture_lex $P1324
    .const 'Sub' $P1322 = "82_1306916577.75068" 
    capture_lex $P1322
    .const 'Sub' $P1319 = "81_1306916577.75068" 
    capture_lex $P1319
    .const 'Sub' $P1317 = "80_1306916577.75068" 
    capture_lex $P1317
    .const 'Sub' $P1314 = "79_1306916577.75068" 
    capture_lex $P1314
    .const 'Sub' $P1312 = "78_1306916577.75068" 
    capture_lex $P1312
    .const 'Sub' $P1309 = "77_1306916577.75068" 
    capture_lex $P1309
    .const 'Sub' $P1306 = "76_1306916577.75068" 
    capture_lex $P1306
    .const 'Sub' $P1299 = "75_1306916577.75068" 
    capture_lex $P1299
    .const 'Sub' $P1296 = "74_1306916577.75068" 
    capture_lex $P1296
    .const 'Sub' $P1292 = "73_1306916577.75068" 
    capture_lex $P1292
    .const 'Sub' $P1290 = "72_1306916577.75068" 
    capture_lex $P1290
    .const 'Sub' $P1286 = "71_1306916577.75068" 
    capture_lex $P1286
    .const 'Sub' $P1282 = "70_1306916577.75068" 
    capture_lex $P1282
    .const 'Sub' $P1278 = "69_1306916577.75068" 
    capture_lex $P1278
    .const 'Sub' $P1275 = "68_1306916577.75068" 
    capture_lex $P1275
    .const 'Sub' $P1272 = "67_1306916577.75068" 
    capture_lex $P1272
    .const 'Sub' $P1270 = "66_1306916577.75068" 
    capture_lex $P1270
    .const 'Sub' $P1266 = "65_1306916577.75068" 
    capture_lex $P1266
    .const 'Sub' $P1264 = "64_1306916577.75068" 
    capture_lex $P1264
    .const 'Sub' $P1251 = "62_1306916577.75068" 
    capture_lex $P1251
    .const 'Sub' $P1247 = "61_1306916577.75068" 
    capture_lex $P1247
    .const 'Sub' $P1237 = "60_1306916577.75068" 
    capture_lex $P1237
    .const 'Sub' $P1234 = "59_1306916577.75068" 
    capture_lex $P1234
    .const 'Sub' $P1214 = "58_1306916577.75068" 
    capture_lex $P1214
    .const 'Sub' $P1212 = "57_1306916577.75068" 
    capture_lex $P1212
    .const 'Sub' $P1175 = "55_1306916577.75068" 
    capture_lex $P1175
    .const 'Sub' $P1173 = "54_1306916577.75068" 
    capture_lex $P1173
    .const 'Sub' $P1160 = "52_1306916577.75068" 
    capture_lex $P1160
    .const 'Sub' $P1158 = "51_1306916577.75068" 
    capture_lex $P1158
    .const 'Sub' $P1149 = "50_1306916577.75068" 
    capture_lex $P1149
    .const 'Sub' $P1147 = "49_1306916577.75068" 
    capture_lex $P1147
    .const 'Sub' $P1137 = "48_1306916577.75068" 
    capture_lex $P1137
    .const 'Sub' $P1134 = "47_1306916577.75068" 
    capture_lex $P1134
    .const 'Sub' $P1129 = "46_1306916577.75068" 
    capture_lex $P1129
    .const 'Sub' $P1127 = "45_1306916577.75068" 
    capture_lex $P1127
    .const 'Sub' $P1122 = "44_1306916577.75068" 
    capture_lex $P1122
    .const 'Sub' $P1119 = "43_1306916577.75068" 
    capture_lex $P1119
    .const 'Sub' $P1115 = "42_1306916577.75068" 
    capture_lex $P1115
    .const 'Sub' $P1049 = "41_1306916577.75068" 
    capture_lex $P1049
    .lex "$?PACKAGE", $P987
    .lex "$?CLASS", $P988
.annotate 'line', 1039
    get_hll_global $P989, "GLOBAL"
    nqp_get_package_through_who $P990, $P989, "NQP"
    get_who $P991, $P990
    set $P992, $P991["Grammar"]
    $P992."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1040
    get_hll_global $P993, "GLOBAL"
    nqp_get_package_through_who $P994, $P993, "NQP"
    get_who $P995, $P994
    set $P996, $P995["Grammar"]
    $P996."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1041
    get_hll_global $P997, "GLOBAL"
    nqp_get_package_through_who $P998, $P997, "NQP"
    get_who $P999, $P998
    set $P1000, $P999["Grammar"]
    $P1000."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1042
    get_hll_global $P1001, "GLOBAL"
    nqp_get_package_through_who $P1002, $P1001, "NQP"
    get_who $P1003, $P1002
    set $P1004, $P1003["Grammar"]
    $P1004."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1043
    get_hll_global $P1005, "GLOBAL"
    nqp_get_package_through_who $P1006, $P1005, "NQP"
    get_who $P1007, $P1006
    set $P1008, $P1007["Grammar"]
    $P1008."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1044
    get_hll_global $P1009, "GLOBAL"
    nqp_get_package_through_who $P1010, $P1009, "NQP"
    get_who $P1011, $P1010
    set $P1012, $P1011["Grammar"]
    $P1012."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1045
    get_hll_global $P1013, "GLOBAL"
    nqp_get_package_through_who $P1014, $P1013, "NQP"
    get_who $P1015, $P1014
    set $P1016, $P1015["Grammar"]
    $P1016."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1046
    get_hll_global $P1017, "GLOBAL"
    nqp_get_package_through_who $P1018, $P1017, "NQP"
    get_who $P1019, $P1018
    set $P1020, $P1019["Grammar"]
    $P1020."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1047
    get_hll_global $P1021, "GLOBAL"
    nqp_get_package_through_who $P1022, $P1021, "NQP"
    get_who $P1023, $P1022
    set $P1024, $P1023["Grammar"]
    $P1024."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1048
    get_hll_global $P1025, "GLOBAL"
    nqp_get_package_through_who $P1026, $P1025, "NQP"
    get_who $P1027, $P1026
    set $P1028, $P1027["Grammar"]
    $P1028."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1049
    get_hll_global $P1029, "GLOBAL"
    nqp_get_package_through_who $P1030, $P1029, "NQP"
    get_who $P1031, $P1030
    set $P1032, $P1031["Grammar"]
    $P1032."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1050
    get_hll_global $P1033, "GLOBAL"
    nqp_get_package_through_who $P1034, $P1033, "NQP"
    get_who $P1035, $P1034
    set $P1036, $P1035["Grammar"]
    $P1036."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1051
    get_hll_global $P1037, "GLOBAL"
    nqp_get_package_through_who $P1038, $P1037, "NQP"
    get_who $P1039, $P1038
    set $P1040, $P1039["Grammar"]
    $P1040."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1052
    get_hll_global $P1041, "GLOBAL"
    nqp_get_package_through_who $P1042, $P1041, "NQP"
    get_who $P1043, $P1042
    set $P1044, $P1043["Grammar"]
    $P1044."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1053
    get_hll_global $P1045, "GLOBAL"
    nqp_get_package_through_who $P1046, $P1045, "NQP"
    get_who $P1047, $P1046
    set $P1048, $P1047["Grammar"]
    $P1048."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1152
    .const 'Sub' $P2857 = "414_1306916577.75068" 
    newclosure $P2868, $P2857
.annotate 'line', 435
    .return ($P2868)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP" :anon :subid("41_1306916577.75068") :outer("40_1306916577.75068")
    .param pmc param_1050
.annotate 'line', 436
    .lex "self", param_1050
.annotate 'line', 438
    $P1051 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P1051
.annotate 'line', 447
    $P1052 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P1052
.annotate 'line', 454
    new $P1053, "Undef"
    .lex "$*SC", $P1053
.annotate 'line', 458
    new $P1054, "Undef"
    .lex "$*SCOPE", $P1054
.annotate 'line', 459
    new $P1055, "Undef"
    .lex "$*MULTINESS", $P1055
.annotate 'line', 460
    new $P1056, "Undef"
    .lex "$*PKGDECL", $P1056
.annotate 'line', 461
    new $P1057, "Undef"
    .lex "$*INVOCANT_OK", $P1057
.annotate 'line', 462
    new $P1058, "Undef"
    .lex "$*RETURN_USED", $P1058
.annotate 'line', 436
    find_lex $P1061, "%*LANG"
    unless_null $P1061, vivify_850
    get_hll_global $P1059, "GLOBAL"
    get_who $P1060, $P1059
    set $P1061, $P1060["%LANG"]
    unless_null $P1061, vivify_851
    die "Contextual %*LANG not found"
  vivify_851:
  vivify_850:
.annotate 'line', 439
    get_hll_global $P1062, "GLOBAL"
    nqp_get_package_through_who $P1063, $P1062, "NQP"
    get_who $P1064, $P1063
    set $P1065, $P1064["Regex"]
    find_lex $P1068, "%*LANG"
    unless_null $P1068, vivify_852
    get_hll_global $P1066, "GLOBAL"
    get_who $P1067, $P1066
    set $P1068, $P1067["%LANG"]
    unless_null $P1068, vivify_853
    die "Contextual %*LANG not found"
  vivify_853:
    store_lex "%*LANG", $P1068
  vivify_852:
    set $P1068["Regex"], $P1065
.annotate 'line', 440
    get_hll_global $P1069, "GLOBAL"
    nqp_get_package_through_who $P1070, $P1069, "NQP"
    get_who $P1071, $P1070
    set $P1072, $P1071["RegexActions"]
    find_lex $P1075, "%*LANG"
    unless_null $P1075, vivify_854
    get_hll_global $P1073, "GLOBAL"
    get_who $P1074, $P1073
    set $P1075, $P1074["%LANG"]
    unless_null $P1075, vivify_855
    die "Contextual %*LANG not found"
  vivify_855:
    store_lex "%*LANG", $P1075
  vivify_854:
    set $P1075["Regex-actions"], $P1072
.annotate 'line', 441
    get_hll_global $P1076, "GLOBAL"
    nqp_get_package_through_who $P1077, $P1076, "NQP"
    get_who $P1078, $P1077
    set $P1079, $P1078["Grammar"]
    find_lex $P1082, "%*LANG"
    unless_null $P1082, vivify_856
    get_hll_global $P1080, "GLOBAL"
    get_who $P1081, $P1080
    set $P1082, $P1081["%LANG"]
    unless_null $P1082, vivify_857
    die "Contextual %*LANG not found"
  vivify_857:
    store_lex "%*LANG", $P1082
  vivify_856:
    set $P1082["MAIN"], $P1079
.annotate 'line', 442
    get_hll_global $P1083, "GLOBAL"
    nqp_get_package_through_who $P1084, $P1083, "NQP"
    get_who $P1085, $P1084
    set $P1086, $P1085["Actions"]
    find_lex $P1089, "%*LANG"
    unless_null $P1089, vivify_858
    get_hll_global $P1087, "GLOBAL"
    get_who $P1088, $P1087
    set $P1089, $P1088["%LANG"]
    unless_null $P1089, vivify_859
    die "Contextual %*LANG not found"
  vivify_859:
    store_lex "%*LANG", $P1089
  vivify_858:
    set $P1089["MAIN-actions"], $P1086
    find_lex $P1092, "%*HOW"
    unless_null $P1092, vivify_860
    get_hll_global $P1090, "GLOBAL"
    get_who $P1091, $P1090
    set $P1092, $P1091["%HOW"]
    unless_null $P1092, vivify_861
    die "Contextual %*HOW not found"
  vivify_861:
  vivify_860:
.annotate 'line', 448
    get_knowhow $P1093
    find_lex $P1096, "%*HOW"
    unless_null $P1096, vivify_862
    get_hll_global $P1094, "GLOBAL"
    get_who $P1095, $P1094
    set $P1096, $P1095["%HOW"]
    unless_null $P1096, vivify_863
    die "Contextual %*HOW not found"
  vivify_863:
    store_lex "%*HOW", $P1096
  vivify_862:
    set $P1096["knowhow"], $P1093
.annotate 'line', 449
    get_knowhow_attribute $P1097
    find_lex $P1100, "%*HOW"
    unless_null $P1100, vivify_864
    get_hll_global $P1098, "GLOBAL"
    get_who $P1099, $P1098
    set $P1100, $P1099["%HOW"]
    unless_null $P1100, vivify_865
    die "Contextual %*HOW not found"
  vivify_865:
    store_lex "%*HOW", $P1100
  vivify_864:
    set $P1100["knowhow-attr"], $P1097
.annotate 'line', 454
    get_hll_global $P1101, "GLOBAL"
    nqp_get_package_through_who $P1102, $P1101, "NQP"
    get_who $P1103, $P1102
    set $P1104, $P1103["SymbolTable"]
.annotate 'line', 456
    time $N1105
    set $S1106, $N1105
    $P1107 = $P1104."new"($S1106 :named("handle"))
.annotate 'line', 454
    store_lex "$*SC", $P1107
.annotate 'line', 458
    new $P1108, "String"
    assign $P1108, ""
    store_lex "$*SCOPE", $P1108
.annotate 'line', 459
    new $P1109, "String"
    assign $P1109, ""
    store_lex "$*MULTINESS", $P1109
.annotate 'line', 460
    new $P1110, "String"
    assign $P1110, ""
    store_lex "$*PKGDECL", $P1110
.annotate 'line', 461
    new $P1111, "Integer"
    assign $P1111, 0
    store_lex "$*INVOCANT_OK", $P1111
.annotate 'line', 462
    new $P1112, "Integer"
    assign $P1112, 0
    store_lex "$*RETURN_USED", $P1112
.annotate 'line', 463
    find_lex $P1113, "self"
    $P1114 = $P1113."comp_unit"()
.annotate 'line', 436
    .return ($P1114)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("42_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1116_tgt
    .local int rx1116_pos
    .local int rx1116_off
    .local int rx1116_eos
    .local int rx1116_rep
    .local pmc rx1116_cur
    .local pmc rx1116_debug
    (rx1116_cur, rx1116_pos, rx1116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1116_cur
    .local pmc match
    .lex "$/", match
    length rx1116_eos, rx1116_tgt
    gt rx1116_pos, rx1116_eos, rx1116_done
    set rx1116_off, 0
    lt rx1116_pos, 2, rx1116_start
    sub rx1116_off, rx1116_pos, 1
    substr rx1116_tgt, rx1116_tgt, rx1116_off
  rx1116_start:
    eq $I10, 1, rx1116_restart
    if_null rx1116_debug, debug_866
    rx1116_cur."!cursor_debug"("START", "identifier")
  debug_866:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1117_done
    goto rxscan1117_scan
  rxscan1117_loop:
    (rx1116_pos) = rx1116_cur."from"()
    inc rx1116_pos
    rx1116_cur."!cursor_from"(rx1116_pos)
    ge rx1116_pos, rx1116_eos, rxscan1117_done
  rxscan1117_scan:
    set_addr $I10, rxscan1117_loop
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  rxscan1117_done:
.annotate 'line', 468
  # rx subrule "ident" subtype=method negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."ident"()
    unless $P10, rx1116_fail
    rx1116_pos = $P10."pos"()
  # rx rxquantr1118 ** 0..*
    set_addr $I10, rxquantr1118_done
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  rxquantr1118_loop:
  # rx enumcharlist negate=0 
    ge rx1116_pos, rx1116_eos, rx1116_fail
    sub $I10, rx1116_pos, rx1116_off
    substr $S10, rx1116_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1116_fail
    inc rx1116_pos
  # rx subrule "ident" subtype=method negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."ident"()
    unless $P10, rx1116_fail
    rx1116_pos = $P10."pos"()
    set_addr $I10, rxquantr1118_done
    (rx1116_rep) = rx1116_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1118_done
    rx1116_cur."!mark_push"(rx1116_rep, rx1116_pos, $I10)
    goto rxquantr1118_loop
  rxquantr1118_done:
  # rx pass
    rx1116_cur."!cursor_pass"(rx1116_pos, "identifier")
    if_null rx1116_debug, debug_867
    rx1116_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1116_pos)
  debug_867:
    .return (rx1116_cur)
  rx1116_restart:
.annotate 'line', 436
    if_null rx1116_debug, debug_868
    rx1116_cur."!cursor_debug"("NEXT", "identifier")
  debug_868:
  rx1116_fail:
    (rx1116_rep, rx1116_pos, $I10, $P10) = rx1116_cur."!mark_fail"(0)
    lt rx1116_pos, -1, rx1116_done
    eq rx1116_pos, -1, rx1116_fail
    jump $I10
  rx1116_done:
    rx1116_cur."!cursor_fail"()
    if_null rx1116_debug, debug_869
    rx1116_cur."!cursor_debug"("FAIL", "identifier")
  debug_869:
    .return (rx1116_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("43_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1120 = self."!PREFIX__!subrule"("ident", "")
    new $P1121, "ResizablePMCArray"
    push $P1121, $P1120
    .return ($P1121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("44_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1123_tgt
    .local int rx1123_pos
    .local int rx1123_off
    .local int rx1123_eos
    .local int rx1123_rep
    .local pmc rx1123_cur
    .local pmc rx1123_debug
    (rx1123_cur, rx1123_pos, rx1123_tgt, $I10) = self."!cursor_start"()
    rx1123_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1123_cur
    .local pmc match
    .lex "$/", match
    length rx1123_eos, rx1123_tgt
    gt rx1123_pos, rx1123_eos, rx1123_done
    set rx1123_off, 0
    lt rx1123_pos, 2, rx1123_start
    sub rx1123_off, rx1123_pos, 1
    substr rx1123_tgt, rx1123_tgt, rx1123_off
  rx1123_start:
    eq $I10, 1, rx1123_restart
    if_null rx1123_debug, debug_870
    rx1123_cur."!cursor_debug"("START", "name")
  debug_870:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1124_done
    goto rxscan1124_scan
  rxscan1124_loop:
    (rx1123_pos) = rx1123_cur."from"()
    inc rx1123_pos
    rx1123_cur."!cursor_from"(rx1123_pos)
    ge rx1123_pos, rx1123_eos, rxscan1124_done
  rxscan1124_scan:
    set_addr $I10, rxscan1124_loop
    rx1123_cur."!mark_push"(0, rx1123_pos, $I10)
  rxscan1124_done:
.annotate 'line', 470
  # rx rxquantr1125 ** 1..*
    set_addr $I10, rxquantr1125_done
    rx1123_cur."!mark_push"(0, -1, $I10)
  rxquantr1125_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1123_cur."!cursor_pos"(rx1123_pos)
    $P10 = rx1123_cur."identifier"()
    unless $P10, rx1123_fail
    goto rxsubrule1126_pass
  rxsubrule1126_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1123_fail
  rxsubrule1126_pass:
    set_addr $I10, rxsubrule1126_back
    rx1123_cur."!mark_push"(0, rx1123_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1123_pos = $P10."pos"()
    set_addr $I10, rxquantr1125_done
    (rx1123_rep) = rx1123_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1125_done
    rx1123_cur."!mark_push"(rx1123_rep, rx1123_pos, $I10)
  # rx literal  "::"
    add $I11, rx1123_pos, 2
    gt $I11, rx1123_eos, rx1123_fail
    sub $I11, rx1123_pos, rx1123_off
    substr $S10, rx1123_tgt, $I11, 2
    ne $S10, "::", rx1123_fail
    add rx1123_pos, 2
    goto rxquantr1125_loop
  rxquantr1125_done:
  # rx pass
    rx1123_cur."!cursor_pass"(rx1123_pos, "name")
    if_null rx1123_debug, debug_871
    rx1123_cur."!cursor_debug"("PASS", "name", " at pos=", rx1123_pos)
  debug_871:
    .return (rx1123_cur)
  rx1123_restart:
.annotate 'line', 436
    if_null rx1123_debug, debug_872
    rx1123_cur."!cursor_debug"("NEXT", "name")
  debug_872:
  rx1123_fail:
    (rx1123_rep, rx1123_pos, $I10, $P10) = rx1123_cur."!mark_fail"(0)
    lt rx1123_pos, -1, rx1123_done
    eq rx1123_pos, -1, rx1123_fail
    jump $I10
  rx1123_done:
    rx1123_cur."!cursor_fail"()
    if_null rx1123_debug, debug_873
    rx1123_cur."!cursor_debug"("FAIL", "name")
  debug_873:
    .return (rx1123_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("45_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1128, "ResizablePMCArray"
    push $P1128, ""
    .return ($P1128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("46_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    rx1130_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_874
    rx1130_cur."!cursor_debug"("START", "deflongname")
  debug_874:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1131_done
    goto rxscan1131_scan
  rxscan1131_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1131_done
  rxscan1131_scan:
    set_addr $I10, rxscan1131_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1131_done:
.annotate 'line', 473
  # rx subrule "identifier" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."identifier"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1130_pos = $P10."pos"()
  # rx rxquantr1132 ** 0..1
    set_addr $I10, rxquantr1132_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1132_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."colonpair"()
    unless $P10, rx1130_fail
    goto rxsubrule1133_pass
  rxsubrule1133_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1133_pass:
    set_addr $I10, rxsubrule1133_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1132_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1132_done:
.annotate 'line', 472
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "deflongname")
    if_null rx1130_debug, debug_875
    rx1130_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1130_pos)
  debug_875:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 436
    if_null rx1130_debug, debug_876
    rx1130_cur."!cursor_debug"("NEXT", "deflongname")
  debug_876:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_877
    rx1130_cur."!cursor_debug"("FAIL", "deflongname")
  debug_877:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("47_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1135 = self."!PREFIX__!subrule"("identifier", "")
    new $P1136, "ResizablePMCArray"
    push $P1136, $P1135
    .return ($P1136)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("48_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1138_tgt
    .local int rx1138_pos
    .local int rx1138_off
    .local int rx1138_eos
    .local int rx1138_rep
    .local pmc rx1138_cur
    .local pmc rx1138_debug
    (rx1138_cur, rx1138_pos, rx1138_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1138_cur
    .local pmc match
    .lex "$/", match
    length rx1138_eos, rx1138_tgt
    gt rx1138_pos, rx1138_eos, rx1138_done
    set rx1138_off, 0
    lt rx1138_pos, 2, rx1138_start
    sub rx1138_off, rx1138_pos, 1
    substr rx1138_tgt, rx1138_tgt, rx1138_off
  rx1138_start:
    eq $I10, 1, rx1138_restart
    if_null rx1138_debug, debug_878
    rx1138_cur."!cursor_debug"("START", "ENDSTMT")
  debug_878:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1139_done
    goto rxscan1139_scan
  rxscan1139_loop:
    (rx1138_pos) = rx1138_cur."from"()
    inc rx1138_pos
    rx1138_cur."!cursor_from"(rx1138_pos)
    ge rx1138_pos, rx1138_eos, rxscan1139_done
  rxscan1139_scan:
    set_addr $I10, rxscan1139_loop
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
  rxscan1139_done:
.annotate 'line', 480
  # rx rxquantr1140 ** 0..1
    set_addr $I10, rxquantr1140_done
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
  rxquantr1140_loop:
  alt1141_0:
.annotate 'line', 477
    set_addr $I10, alt1141_1
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
.annotate 'line', 478
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1138_pos, rx1138_off
    set rx1138_rep, 0
    sub $I12, rx1138_eos, rx1138_pos
  rxenumcharlistq1142_loop:
    le $I12, 0, rxenumcharlistq1142_done
    substr $S10, rx1138_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1142_done
    inc rx1138_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1142_loop
  rxenumcharlistq1142_done:
    add rx1138_pos, rx1138_pos, rx1138_rep
  # rxanchor eol
    sub $I10, rx1138_pos, rx1138_off
    is_cclass $I11, 4096, rx1138_tgt, $I10
    if $I11, rxanchor1143_done
    ne rx1138_pos, rx1138_eos, rx1138_fail
    eq rx1138_pos, 0, rxanchor1143_done
    dec $I10
    is_cclass $I11, 4096, rx1138_tgt, $I10
    if $I11, rx1138_fail
  rxanchor1143_done:
  # rx subrule "ws" subtype=method negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."ws"()
    unless $P10, rx1138_fail
    rx1138_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."MARKER"("endstmt")
    unless $P10, rx1138_fail
    goto alt1141_end
  alt1141_1:
.annotate 'line', 479
  # rx rxquantr1144 ** 0..1
    set_addr $I10, rxquantr1144_done
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
  rxquantr1144_loop:
  # rx subrule "unv" subtype=method negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."unv"()
    unless $P10, rx1138_fail
    goto rxsubrule1145_pass
  rxsubrule1145_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1138_fail
  rxsubrule1145_pass:
    set_addr $I10, rxsubrule1145_back
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10, $P10)
    rx1138_pos = $P10."pos"()
    set_addr $I10, rxquantr1144_done
    (rx1138_rep) = rx1138_cur."!mark_commit"($I10)
  rxquantr1144_done:
  # rxanchor eol
    sub $I10, rx1138_pos, rx1138_off
    is_cclass $I11, 4096, rx1138_tgt, $I10
    if $I11, rxanchor1146_done
    ne rx1138_pos, rx1138_eos, rx1138_fail
    eq rx1138_pos, 0, rxanchor1146_done
    dec $I10
    is_cclass $I11, 4096, rx1138_tgt, $I10
    if $I11, rx1138_fail
  rxanchor1146_done:
  # rx subrule "ws" subtype=method negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."ws"()
    unless $P10, rx1138_fail
    rx1138_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."MARKER"("endstmt")
    unless $P10, rx1138_fail
  alt1141_end:
.annotate 'line', 480
    set_addr $I10, rxquantr1140_done
    (rx1138_rep) = rx1138_cur."!mark_commit"($I10)
  rxquantr1140_done:
.annotate 'line', 476
  # rx pass
    rx1138_cur."!cursor_pass"(rx1138_pos, "ENDSTMT")
    if_null rx1138_debug, debug_879
    rx1138_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1138_pos)
  debug_879:
    .return (rx1138_cur)
  rx1138_restart:
.annotate 'line', 436
    if_null rx1138_debug, debug_880
    rx1138_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_880:
  rx1138_fail:
    (rx1138_rep, rx1138_pos, $I10, $P10) = rx1138_cur."!mark_fail"(0)
    lt rx1138_pos, -1, rx1138_done
    eq rx1138_pos, -1, rx1138_fail
    jump $I10
  rx1138_done:
    rx1138_cur."!cursor_fail"()
    if_null rx1138_debug, debug_881
    rx1138_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_881:
    .return (rx1138_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("49_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1148, "ResizablePMCArray"
    push $P1148, ""
    .return ($P1148)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("50_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1150_tgt
    .local int rx1150_pos
    .local int rx1150_off
    .local int rx1150_eos
    .local int rx1150_rep
    .local pmc rx1150_cur
    .local pmc rx1150_debug
    (rx1150_cur, rx1150_pos, rx1150_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1150_cur
    .local pmc match
    .lex "$/", match
    length rx1150_eos, rx1150_tgt
    gt rx1150_pos, rx1150_eos, rx1150_done
    set rx1150_off, 0
    lt rx1150_pos, 2, rx1150_start
    sub rx1150_off, rx1150_pos, 1
    substr rx1150_tgt, rx1150_tgt, rx1150_off
  rx1150_start:
    eq $I10, 1, rx1150_restart
    if_null rx1150_debug, debug_882
    rx1150_cur."!cursor_debug"("START", "ws")
  debug_882:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1151_done
    goto rxscan1151_scan
  rxscan1151_loop:
    (rx1150_pos) = rx1150_cur."from"()
    inc rx1150_pos
    rx1150_cur."!cursor_from"(rx1150_pos)
    ge rx1150_pos, rx1150_eos, rxscan1151_done
  rxscan1151_scan:
    set_addr $I10, rxscan1151_loop
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
  rxscan1151_done:
  alt1152_0:
.annotate 'line', 483
    set_addr $I10, alt1152_1
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
.annotate 'line', 484
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."MARKED"("ws")
    unless $P10, rx1150_fail
    goto alt1152_end
  alt1152_1:
.annotate 'line', 485
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."ww"()
    if $P10, rx1150_fail
.annotate 'line', 490
  # rx rxquantr1153 ** 0..*
    set_addr $I10, rxquantr1153_done
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
  rxquantr1153_loop:
  alt1154_0:
.annotate 'line', 486
    set_addr $I10, alt1154_1
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1150_pos, rx1150_off
    set rx1150_rep, 0
    sub $I12, rx1150_eos, rx1150_pos
  rxenumcharlistq1155_loop:
    le $I12, 0, rxenumcharlistq1155_done
    substr $S10, rx1150_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1155_done
    inc rx1150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1155_loop
  rxenumcharlistq1155_done:
    lt rx1150_rep, 1, rx1150_fail
    add rx1150_pos, rx1150_pos, rx1150_rep
    goto alt1154_end
  alt1154_1:
    set_addr $I10, alt1154_2
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
.annotate 'line', 487
  # rx literal  "#"
    add $I11, rx1150_pos, 1
    gt $I11, rx1150_eos, rx1150_fail
    sub $I11, rx1150_pos, rx1150_off
    ord $I11, rx1150_tgt, $I11
    ne $I11, 35, rx1150_fail
    add rx1150_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1150_pos, rx1150_off
    find_cclass $I11, 4096, rx1150_tgt, $I10, rx1150_eos
    add rx1150_pos, rx1150_off, $I11
    goto alt1154_end
  alt1154_2:
    set_addr $I10, alt1154_3
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
.annotate 'line', 488
  # rxanchor bol
    eq rx1150_pos, 0, rxanchor1156_done
    ge rx1150_pos, rx1150_eos, rx1150_fail
    sub $I10, rx1150_pos, rx1150_off
    dec $I10
    is_cclass $I11, 4096, rx1150_tgt, $I10
    unless $I11, rx1150_fail
  rxanchor1156_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."pod_comment"()
    unless $P10, rx1150_fail
    rx1150_pos = $P10."pos"()
    goto alt1154_end
  alt1154_3:
.annotate 'line', 489
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1150_pos, rx1150_off
    set rx1150_rep, 0
    sub $I12, rx1150_eos, rx1150_pos
  rxenumcharlistq1157_loop:
    le $I12, 0, rxenumcharlistq1157_done
    substr $S10, rx1150_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1157_done
    inc rx1150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1157_loop
  rxenumcharlistq1157_done:
    lt rx1150_rep, 1, rx1150_fail
    add rx1150_pos, rx1150_pos, rx1150_rep
  alt1154_end:
.annotate 'line', 490
    set_addr $I10, rxquantr1153_done
    (rx1150_rep) = rx1150_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1153_done
    rx1150_cur."!mark_push"(rx1150_rep, rx1150_pos, $I10)
    goto rxquantr1153_loop
  rxquantr1153_done:
.annotate 'line', 491
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."MARKER"("ws")
    unless $P10, rx1150_fail
  alt1152_end:
.annotate 'line', 483
  # rx pass
    rx1150_cur."!cursor_pass"(rx1150_pos, "ws")
    if_null rx1150_debug, debug_883
    rx1150_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1150_pos)
  debug_883:
    .return (rx1150_cur)
  rx1150_restart:
.annotate 'line', 436
    if_null rx1150_debug, debug_884
    rx1150_cur."!cursor_debug"("NEXT", "ws")
  debug_884:
  rx1150_fail:
    (rx1150_rep, rx1150_pos, $I10, $P10) = rx1150_cur."!mark_fail"(0)
    lt rx1150_pos, -1, rx1150_done
    eq rx1150_pos, -1, rx1150_fail
    jump $I10
  rx1150_done:
    rx1150_cur."!cursor_fail"()
    if_null rx1150_debug, debug_885
    rx1150_cur."!cursor_debug"("FAIL", "ws")
  debug_885:
    .return (rx1150_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("51_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1159, "ResizablePMCArray"
    push $P1159, ""
    push $P1159, ""
    .return ($P1159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("52_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P1166 = "53_1306916577.75068" 
    capture_lex $P1166
    .local string rx1161_tgt
    .local int rx1161_pos
    .local int rx1161_off
    .local int rx1161_eos
    .local int rx1161_rep
    .local pmc rx1161_cur
    .local pmc rx1161_debug
    (rx1161_cur, rx1161_pos, rx1161_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1161_cur
    .local pmc match
    .lex "$/", match
    length rx1161_eos, rx1161_tgt
    gt rx1161_pos, rx1161_eos, rx1161_done
    set rx1161_off, 0
    lt rx1161_pos, 2, rx1161_start
    sub rx1161_off, rx1161_pos, 1
    substr rx1161_tgt, rx1161_tgt, rx1161_off
  rx1161_start:
    eq $I10, 1, rx1161_restart
    if_null rx1161_debug, debug_886
    rx1161_cur."!cursor_debug"("START", "unv")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1162_done
    goto rxscan1162_scan
  rxscan1162_loop:
    (rx1161_pos) = rx1161_cur."from"()
    inc rx1161_pos
    rx1161_cur."!cursor_from"(rx1161_pos)
    ge rx1161_pos, rx1161_eos, rxscan1162_done
  rxscan1162_scan:
    set_addr $I10, rxscan1162_loop
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
  rxscan1162_done:
  alt1163_0:
.annotate 'line', 496
    set_addr $I10, alt1163_1
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
.annotate 'line', 497
  # rxanchor bol
    eq rx1161_pos, 0, rxanchor1164_done
    ge rx1161_pos, rx1161_eos, rx1161_fail
    sub $I10, rx1161_pos, rx1161_off
    dec $I10
    is_cclass $I11, 4096, rx1161_tgt, $I10
    unless $I11, rx1161_fail
  rxanchor1164_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    .const 'Sub' $P1166 = "53_1306916577.75068" 
    capture_lex $P1166
    $P10 = rx1161_cur."before"($P1166)
    unless $P10, rx1161_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    $P10 = rx1161_cur."pod_comment"()
    unless $P10, rx1161_fail
    rx1161_pos = $P10."pos"()
    goto alt1163_end
  alt1163_1:
    set_addr $I10, alt1163_2
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
.annotate 'line', 498
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1161_pos, rx1161_off
    set rx1161_rep, 0
    sub $I12, rx1161_eos, rx1161_pos
  rxenumcharlistq1171_loop:
    le $I12, 0, rxenumcharlistq1171_done
    substr $S10, rx1161_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1171_done
    inc rx1161_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1171_loop
  rxenumcharlistq1171_done:
    add rx1161_pos, rx1161_pos, rx1161_rep
  # rx literal  "#"
    add $I11, rx1161_pos, 1
    gt $I11, rx1161_eos, rx1161_fail
    sub $I11, rx1161_pos, rx1161_off
    ord $I11, rx1161_tgt, $I11
    ne $I11, 35, rx1161_fail
    add rx1161_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1161_pos, rx1161_off
    find_cclass $I11, 4096, rx1161_tgt, $I10, rx1161_eos
    add rx1161_pos, rx1161_off, $I11
    goto alt1163_end
  alt1163_2:
.annotate 'line', 499
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1161_pos, rx1161_off
    set rx1161_rep, 0
    sub $I12, rx1161_eos, rx1161_pos
  rxenumcharlistq1172_loop:
    le $I12, 0, rxenumcharlistq1172_done
    substr $S10, rx1161_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1172_done
    inc rx1161_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1172_loop
  rxenumcharlistq1172_done:
    lt rx1161_rep, 1, rx1161_fail
    add rx1161_pos, rx1161_pos, rx1161_rep
  alt1163_end:
.annotate 'line', 494
  # rx pass
    rx1161_cur."!cursor_pass"(rx1161_pos, "unv")
    if_null rx1161_debug, debug_891
    rx1161_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1161_pos)
  debug_891:
    .return (rx1161_cur)
  rx1161_restart:
.annotate 'line', 436
    if_null rx1161_debug, debug_892
    rx1161_cur."!cursor_debug"("NEXT", "unv")
  debug_892:
  rx1161_fail:
    (rx1161_rep, rx1161_pos, $I10, $P10) = rx1161_cur."!mark_fail"(0)
    lt rx1161_pos, -1, rx1161_done
    eq rx1161_pos, -1, rx1161_fail
    jump $I10
  rx1161_done:
    rx1161_cur."!cursor_fail"()
    if_null rx1161_debug, debug_893
    rx1161_cur."!cursor_debug"("FAIL", "unv")
  debug_893:
    .return (rx1161_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1165"  :anon :subid("53_1306916577.75068") :method :outer("52_1306916577.75068")
.annotate 'line', 497
    .local string rx1167_tgt
    .local int rx1167_pos
    .local int rx1167_off
    .local int rx1167_eos
    .local int rx1167_rep
    .local pmc rx1167_cur
    .local pmc rx1167_debug
    (rx1167_cur, rx1167_pos, rx1167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1167_cur
    .local pmc match
    .lex "$/", match
    length rx1167_eos, rx1167_tgt
    gt rx1167_pos, rx1167_eos, rx1167_done
    set rx1167_off, 0
    lt rx1167_pos, 2, rx1167_start
    sub rx1167_off, rx1167_pos, 1
    substr rx1167_tgt, rx1167_tgt, rx1167_off
  rx1167_start:
    eq $I10, 1, rx1167_restart
    if_null rx1167_debug, debug_887
    rx1167_cur."!cursor_debug"("START", "")
  debug_887:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1168_done
    goto rxscan1168_scan
  rxscan1168_loop:
    (rx1167_pos) = rx1167_cur."from"()
    inc rx1167_pos
    rx1167_cur."!cursor_from"(rx1167_pos)
    ge rx1167_pos, rx1167_eos, rxscan1168_done
  rxscan1168_scan:
    set_addr $I10, rxscan1168_loop
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  rxscan1168_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1167_pos, rx1167_off
    set rx1167_rep, 0
    sub $I12, rx1167_eos, rx1167_pos
  rxenumcharlistq1169_loop:
    le $I12, 0, rxenumcharlistq1169_done
    substr $S10, rx1167_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1169_done
    inc rx1167_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1169_loop
  rxenumcharlistq1169_done:
    add rx1167_pos, rx1167_pos, rx1167_rep
  # rx literal  "="
    add $I11, rx1167_pos, 1
    gt $I11, rx1167_eos, rx1167_fail
    sub $I11, rx1167_pos, rx1167_off
    ord $I11, rx1167_tgt, $I11
    ne $I11, 61, rx1167_fail
    add rx1167_pos, 1
  alt1170_0:
    set_addr $I10, alt1170_1
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx charclass w
    ge rx1167_pos, rx1167_eos, rx1167_fail
    sub $I10, rx1167_pos, rx1167_off
    is_cclass $I11, 8192, rx1167_tgt, $I10
    unless $I11, rx1167_fail
    inc rx1167_pos
    goto alt1170_end
  alt1170_1:
  # rx literal  "\\"
    add $I11, rx1167_pos, 1
    gt $I11, rx1167_eos, rx1167_fail
    sub $I11, rx1167_pos, rx1167_off
    ord $I11, rx1167_tgt, $I11
    ne $I11, 92, rx1167_fail
    add rx1167_pos, 1
  alt1170_end:
  # rx pass
    rx1167_cur."!cursor_pass"(rx1167_pos, "")
    if_null rx1167_debug, debug_888
    rx1167_cur."!cursor_debug"("PASS", "", " at pos=", rx1167_pos)
  debug_888:
    .return (rx1167_cur)
  rx1167_restart:
    if_null rx1167_debug, debug_889
    rx1167_cur."!cursor_debug"("NEXT", "")
  debug_889:
  rx1167_fail:
    (rx1167_rep, rx1167_pos, $I10, $P10) = rx1167_cur."!mark_fail"(0)
    lt rx1167_pos, -1, rx1167_done
    eq rx1167_pos, -1, rx1167_fail
    jump $I10
  rx1167_done:
    rx1167_cur."!cursor_fail"()
    if_null rx1167_debug, debug_890
    rx1167_cur."!cursor_debug"("FAIL", "")
  debug_890:
    .return (rx1167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("54_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1174, "ResizablePMCArray"
    push $P1174, ""
    push $P1174, ""
    push $P1174, ""
    .return ($P1174)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("55_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P1205 = "56_1306916577.75068" 
    capture_lex $P1205
    .local string rx1176_tgt
    .local int rx1176_pos
    .local int rx1176_off
    .local int rx1176_eos
    .local int rx1176_rep
    .local pmc rx1176_cur
    .local pmc rx1176_debug
    (rx1176_cur, rx1176_pos, rx1176_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1176_cur
    .local pmc match
    .lex "$/", match
    length rx1176_eos, rx1176_tgt
    gt rx1176_pos, rx1176_eos, rx1176_done
    set rx1176_off, 0
    lt rx1176_pos, 2, rx1176_start
    sub rx1176_off, rx1176_pos, 1
    substr rx1176_tgt, rx1176_tgt, rx1176_off
  rx1176_start:
    eq $I10, 1, rx1176_restart
    if_null rx1176_debug, debug_894
    rx1176_cur."!cursor_debug"("START", "pod_comment")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1177_done
    goto rxscan1177_scan
  rxscan1177_loop:
    (rx1176_pos) = rx1176_cur."from"()
    inc rx1176_pos
    rx1176_cur."!cursor_from"(rx1176_pos)
    ge rx1176_pos, rx1176_eos, rxscan1177_done
  rxscan1177_scan:
    set_addr $I10, rxscan1177_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  rxscan1177_done:
.annotate 'line', 504
  # rxanchor bol
    eq rx1176_pos, 0, rxanchor1178_done
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    dec $I10
    is_cclass $I11, 4096, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  rxanchor1178_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1179_loop:
    le $I12, 0, rxenumcharlistq1179_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1179_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1179_loop
  rxenumcharlistq1179_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "="
    add $I11, rx1176_pos, 1
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    ord $I11, rx1176_tgt, $I11
    ne $I11, 61, rx1176_fail
    add rx1176_pos, 1
  alt1180_0:
.annotate 'line', 505
    set_addr $I10, alt1180_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 506
  # rx literal  "begin"
    add $I11, rx1176_pos, 5
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 5
    ne $S10, "begin", rx1176_fail
    add rx1176_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1181_loop:
    le $I12, 0, rxenumcharlistq1181_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1181_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1181_loop
  rxenumcharlistq1181_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "END"
    add $I11, rx1176_pos, 3
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 3
    ne $S10, "END", rx1176_fail
    add rx1176_pos, 3
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 8192, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, 8192, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  alt1182_0:
.annotate 'line', 507
    set_addr $I10, alt1182_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx rxquantf1183 ** 0..*
    set_addr $I10, rxquantf1183_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1183_done
  rxquantf1183_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1183_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1183_done:
  # rx charclass nl
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 4096, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    substr $S10, rx1176_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1176_pos, $I11
    inc rx1176_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1185_loop:
    le $I12, 0, rxenumcharlistq1185_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1185_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1185_loop
  rxenumcharlistq1185_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "=end"
    add $I11, rx1176_pos, 4
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 4
    ne $S10, "=end", rx1176_fail
    add rx1176_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1186_loop:
    le $I12, 0, rxenumcharlistq1186_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1186_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1186_loop
  rxenumcharlistq1186_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "END"
    add $I11, rx1176_pos, 3
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 3
    ne $S10, "END", rx1176_fail
    add rx1176_pos, 3
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 8192, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, 8192, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, 4096, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
    goto alt1182_end
  alt1182_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_not_cclass $I11, 65535, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
  alt1182_end:
.annotate 'line', 506
    goto alt1180_end
  alt1180_1:
    set_addr $I10, alt1180_2
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 508
  # rx literal  "begin"
    add $I11, rx1176_pos, 5
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 5
    ne $S10, "begin", rx1176_fail
    add rx1176_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1187_loop:
    le $I12, 0, rxenumcharlistq1187_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1187_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1187_loop
  rxenumcharlistq1187_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."identifier"()
    unless $P10, rx1176_fail
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1176_pos = $P10."pos"()
  alt1188_0:
.annotate 'line', 509
    set_addr $I10, alt1188_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 510
  # rx rxquantf1189 ** 0..*
    set_addr $I10, rxquantf1189_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1189_done
  rxquantf1189_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1189_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1189_done:
  # rx charclass nl
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 4096, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    substr $S10, rx1176_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1176_pos, $I11
    inc rx1176_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1191_loop:
    le $I12, 0, rxenumcharlistq1191_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1191_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1191_loop
  rxenumcharlistq1191_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "=end"
    add $I11, rx1176_pos, 4
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 4
    ne $S10, "=end", rx1176_fail
    add rx1176_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1192_loop:
    le $I12, 0, rxenumcharlistq1192_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1192_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1192_loop
  rxenumcharlistq1192_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."!BACKREF"("identifier")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 8192, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, 8192, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, 4096, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
    goto alt1188_end
  alt1188_1:
.annotate 'line', 511
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("=begin without matching =end")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1188_end:
.annotate 'line', 508
    goto alt1180_end
  alt1180_2:
    set_addr $I10, alt1180_3
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 513
  # rx literal  "begin"
    add $I11, rx1176_pos, 5
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 5
    ne $S10, "begin", rx1176_fail
    add rx1176_pos, 5
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 8192, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, 8192, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1194_loop:
    le $I12, 0, rxenumcharlistq1194_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1194_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1194_loop
  rxenumcharlistq1194_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  alt1195_0:
.annotate 'line', 514
    set_addr $I10, alt1195_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rxanchor eol
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 4096, rx1176_tgt, $I10
    if $I11, rxanchor1196_done
    ne rx1176_pos, rx1176_eos, rx1176_fail
    eq rx1176_pos, 0, rxanchor1196_done
    dec $I10
    is_cclass $I11, 4096, rx1176_tgt, $I10
    if $I11, rx1176_fail
  rxanchor1196_done:
    goto alt1195_end
  alt1195_1:
    set_addr $I10, alt1195_2
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx literal  "#"
    add $I11, rx1176_pos, 1
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    ord $I11, rx1176_tgt, $I11
    ne $I11, 35, rx1176_fail
    add rx1176_pos, 1
    goto alt1195_end
  alt1195_2:
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1195_end:
  alt1197_0:
.annotate 'line', 515
    set_addr $I10, alt1197_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 516
  # rx rxquantf1198 ** 0..*
    set_addr $I10, rxquantf1198_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1198_done
  rxquantf1198_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1198_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1198_done:
  # rx charclass nl
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 4096, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    substr $S10, rx1176_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1176_pos, $I11
    inc rx1176_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1200_loop:
    le $I12, 0, rxenumcharlistq1200_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1200_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1200_loop
  rxenumcharlistq1200_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "=end"
    add $I11, rx1176_pos, 4
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 4
    ne $S10, "=end", rx1176_fail
    add rx1176_pos, 4
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 8192, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, 8192, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, 4096, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
    goto alt1197_end
  alt1197_1:
.annotate 'line', 517
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("=begin without matching =end")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1197_end:
.annotate 'line', 513
    goto alt1180_end
  alt1180_3:
    set_addr $I10, alt1180_4
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 519
  # rx subrule "identifier" subtype=capture negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."identifier"()
    unless $P10, rx1176_fail
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1176_pos = $P10."pos"()
.annotate 'line', 520
  # rx rxquantf1201 ** 0..*
    set_addr $I10, rxquantf1201_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1201_done
  rxquantf1201_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1201_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1201_done:
  # rxanchor bol
    eq rx1176_pos, 0, rxanchor1203_done
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    dec $I10
    is_cclass $I11, 4096, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  rxanchor1203_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    .const 'Sub' $P1205 = "56_1306916577.75068" 
    capture_lex $P1205
    $P10 = rx1176_cur."before"($P1205)
    unless $P10, rx1176_fail
.annotate 'line', 519
    goto alt1180_end
  alt1180_4:
  alt1211_0:
.annotate 'line', 526
    set_addr $I10, alt1211_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx charclass s
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, 32, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    inc rx1176_pos
    goto alt1211_end
  alt1211_1:
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("Illegal pod directive")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1211_end:
.annotate 'line', 527
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, 4096, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
  alt1180_end:
.annotate 'line', 503
  # rx pass
    rx1176_cur."!cursor_pass"(rx1176_pos, "pod_comment")
    if_null rx1176_debug, debug_899
    rx1176_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1176_pos)
  debug_899:
    .return (rx1176_cur)
  rx1176_restart:
.annotate 'line', 436
    if_null rx1176_debug, debug_900
    rx1176_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_900:
  rx1176_fail:
    (rx1176_rep, rx1176_pos, $I10, $P10) = rx1176_cur."!mark_fail"(0)
    lt rx1176_pos, -1, rx1176_done
    eq rx1176_pos, -1, rx1176_fail
    jump $I10
  rx1176_done:
    rx1176_cur."!cursor_fail"()
    if_null rx1176_debug, debug_901
    rx1176_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_901:
    .return (rx1176_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1204"  :anon :subid("56_1306916577.75068") :method :outer("55_1306916577.75068")
.annotate 'line', 520
    .local string rx1206_tgt
    .local int rx1206_pos
    .local int rx1206_off
    .local int rx1206_eos
    .local int rx1206_rep
    .local pmc rx1206_cur
    .local pmc rx1206_debug
    (rx1206_cur, rx1206_pos, rx1206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1206_cur
    .local pmc match
    .lex "$/", match
    length rx1206_eos, rx1206_tgt
    gt rx1206_pos, rx1206_eos, rx1206_done
    set rx1206_off, 0
    lt rx1206_pos, 2, rx1206_start
    sub rx1206_off, rx1206_pos, 1
    substr rx1206_tgt, rx1206_tgt, rx1206_off
  rx1206_start:
    eq $I10, 1, rx1206_restart
    if_null rx1206_debug, debug_895
    rx1206_cur."!cursor_debug"("START", "")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1206_pos) = rx1206_cur."from"()
    inc rx1206_pos
    rx1206_cur."!cursor_from"(rx1206_pos)
    ge rx1206_pos, rx1206_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxscan1207_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1206_pos, rx1206_off
    set rx1206_rep, 0
    sub $I12, rx1206_eos, rx1206_pos
  rxenumcharlistq1208_loop:
    le $I12, 0, rxenumcharlistq1208_done
    substr $S10, rx1206_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1208_done
    inc rx1206_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1208_loop
  rxenumcharlistq1208_done:
    add rx1206_pos, rx1206_pos, rx1206_rep
  alt1209_0:
    set_addr $I10, alt1209_1
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
.annotate 'line', 521
  # rx literal  "="
    add $I11, rx1206_pos, 1
    gt $I11, rx1206_eos, rx1206_fail
    sub $I11, rx1206_pos, rx1206_off
    ord $I11, rx1206_tgt, $I11
    ne $I11, 61, rx1206_fail
    add rx1206_pos, 1
.annotate 'line', 523
  # rx rxquantr1210 ** 0..1
    set_addr $I10, rxquantr1210_done
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxquantr1210_loop:
.annotate 'line', 522
  # rx literal  "cut"
    add $I11, rx1206_pos, 3
    gt $I11, rx1206_eos, rx1206_fail
    sub $I11, rx1206_pos, rx1206_off
    substr $S10, rx1206_tgt, $I11, 3
    ne $S10, "cut", rx1206_fail
    add rx1206_pos, 3
  # rxanchor rwb
    le rx1206_pos, 0, rx1206_fail
    sub $I10, rx1206_pos, rx1206_off
    is_cclass $I11, 8192, rx1206_tgt, $I10
    if $I11, rx1206_fail
    dec $I10
    is_cclass $I11, 8192, rx1206_tgt, $I10
    unless $I11, rx1206_fail
.annotate 'line', 523
  # rx subrule "panic" subtype=method negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1206_fail
    rx1206_pos = $P10."pos"()
    set_addr $I10, rxquantr1210_done
    (rx1206_rep) = rx1206_cur."!mark_commit"($I10)
  rxquantr1210_done:
.annotate 'line', 520
    goto alt1209_end
  alt1209_1:
.annotate 'line', 524
  # rx charclass nl
    ge rx1206_pos, rx1206_eos, rx1206_fail
    sub $I10, rx1206_pos, rx1206_off
    is_cclass $I11, 4096, rx1206_tgt, $I10
    unless $I11, rx1206_fail
    substr $S10, rx1206_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1206_pos, $I11
    inc rx1206_pos
  alt1209_end:
.annotate 'line', 520
  # rx pass
    rx1206_cur."!cursor_pass"(rx1206_pos, "")
    if_null rx1206_debug, debug_896
    rx1206_cur."!cursor_debug"("PASS", "", " at pos=", rx1206_pos)
  debug_896:
    .return (rx1206_cur)
  rx1206_restart:
    if_null rx1206_debug, debug_897
    rx1206_cur."!cursor_debug"("NEXT", "")
  debug_897:
  rx1206_fail:
    (rx1206_rep, rx1206_pos, $I10, $P10) = rx1206_cur."!mark_fail"(0)
    lt rx1206_pos, -1, rx1206_done
    eq rx1206_pos, -1, rx1206_fail
    jump $I10
  rx1206_done:
    rx1206_cur."!cursor_fail"()
    if_null rx1206_debug, debug_898
    rx1206_cur."!cursor_debug"("FAIL", "")
  debug_898:
    .return (rx1206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("57_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1213, "ResizablePMCArray"
    push $P1213, ""
    .return ($P1213)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("58_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 535
    new $P1215, "Undef"
    .lex "$*IN_DECL", $P1215
.annotate 'line', 537
    new $P1216, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P1216
.annotate 'line', 538
    new $P1217, "Undef"
    .lex "$*MAIN_SUB", $P1217
.annotate 'line', 541
    new $P1218, "Undef"
    .lex "$*PACKAGE", $P1218
.annotate 'line', 542
    new $P1219, "Undef"
    .lex "$*GLOBALish", $P1219
.annotate 'line', 436
    .local string rx1220_tgt
    .local int rx1220_pos
    .local int rx1220_off
    .local int rx1220_eos
    .local int rx1220_rep
    .local pmc rx1220_cur
    .local pmc rx1220_debug
    (rx1220_cur, rx1220_pos, rx1220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1220_cur
    .local pmc match
    .lex "$/", match
    length rx1220_eos, rx1220_tgt
    gt rx1220_pos, rx1220_eos, rx1220_done
    set rx1220_off, 0
    lt rx1220_pos, 2, rx1220_start
    sub rx1220_off, rx1220_pos, 1
    substr rx1220_tgt, rx1220_tgt, rx1220_off
  rx1220_start:
    eq $I10, 1, rx1220_restart
    if_null rx1220_debug, debug_902
    rx1220_cur."!cursor_debug"("START", "comp_unit")
  debug_902:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1221_done
    goto rxscan1221_scan
  rxscan1221_loop:
    (rx1220_pos) = rx1220_cur."from"()
    inc rx1220_pos
    rx1220_cur."!cursor_from"(rx1220_pos)
    ge rx1220_pos, rx1220_eos, rxscan1221_done
  rxscan1221_scan:
    set_addr $I10, rxscan1221_loop
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxscan1221_done:
.annotate 'line', 535
    rx1220_cur."!cursor_pos"(rx1220_pos)
    new $P1222, "String"
    assign $P1222, ""
    store_lex "$*IN_DECL", $P1222
.annotate 'line', 537
    rx1220_cur."!cursor_pos"(rx1220_pos)
    new $P1223, "Integer"
    assign $P1223, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P1223
.annotate 'line', 538
    rx1220_cur."!cursor_pos"(rx1220_pos)
    find_lex $P1226, "$*MAIN_SUB"
    unless_null $P1226, vivify_903
    get_hll_global $P1224, "GLOBAL"
    get_who $P1225, $P1224
    set $P1226, $P1225["$MAIN_SUB"]
    unless_null $P1226, vivify_904
    die "Contextual $*MAIN_SUB not found"
  vivify_904:
  vivify_903:
.annotate 'line', 539
  # rx subrule "newpad" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."newpad"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
.annotate 'line', 541
    rx1220_cur."!cursor_pos"(rx1220_pos)
    find_lex $P1229, "$*PACKAGE"
    unless_null $P1229, vivify_905
    get_hll_global $P1227, "GLOBAL"
    get_who $P1228, $P1227
    set $P1229, $P1228["$PACKAGE"]
    unless_null $P1229, vivify_906
    die "Contextual $*PACKAGE not found"
  vivify_906:
  vivify_905:
.annotate 'line', 542
    rx1220_cur."!cursor_pos"(rx1220_pos)
    find_lex $P1232, "$*GLOBALish"
    unless_null $P1232, vivify_907
    get_hll_global $P1230, "GLOBAL"
    get_who $P1231, $P1230
    set $P1232, $P1231["$GLOBALish"]
    unless_null $P1232, vivify_908
    die "Contextual $*GLOBALish not found"
  vivify_908:
  vivify_907:
.annotate 'line', 543
  # rx subrule "GLOBALish" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."GLOBALish"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
.annotate 'line', 545
  # rx subrule "outerctx" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."outerctx"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
.annotate 'line', 547
  # rx subrule "statementlist" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."statementlist"()
    unless $P10, rx1220_fail
    rx1220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1220_pos = $P10."pos"()
  alt1233_0:
.annotate 'line', 548
    set_addr $I10, alt1233_1
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  # rxanchor eos
    ne rx1220_pos, rx1220_eos, rx1220_fail
    goto alt1233_end
  alt1233_1:
  # rx subrule "panic" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."panic"("Confused")
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
  alt1233_end:
.annotate 'line', 534
  # rx pass
    rx1220_cur."!cursor_pass"(rx1220_pos, "comp_unit")
    if_null rx1220_debug, debug_909
    rx1220_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1220_pos)
  debug_909:
    .return (rx1220_cur)
  rx1220_restart:
.annotate 'line', 436
    if_null rx1220_debug, debug_910
    rx1220_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_910:
  rx1220_fail:
    (rx1220_rep, rx1220_pos, $I10, $P10) = rx1220_cur."!mark_fail"(0)
    lt rx1220_pos, -1, rx1220_done
    eq rx1220_pos, -1, rx1220_fail
    jump $I10
  rx1220_done:
    rx1220_cur."!cursor_fail"()
    if_null rx1220_debug, debug_911
    rx1220_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_911:
    .return (rx1220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("59_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1235 = self."!PREFIX__!subrule"("newpad", "")
    new $P1236, "ResizablePMCArray"
    push $P1236, $P1235
    .return ($P1236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("60_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1238_tgt
    .local int rx1238_pos
    .local int rx1238_off
    .local int rx1238_eos
    .local int rx1238_rep
    .local pmc rx1238_cur
    .local pmc rx1238_debug
    (rx1238_cur, rx1238_pos, rx1238_tgt, $I10) = self."!cursor_start"()
    rx1238_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1238_cur
    .local pmc match
    .lex "$/", match
    length rx1238_eos, rx1238_tgt
    gt rx1238_pos, rx1238_eos, rx1238_done
    set rx1238_off, 0
    lt rx1238_pos, 2, rx1238_start
    sub rx1238_off, rx1238_pos, 1
    substr rx1238_tgt, rx1238_tgt, rx1238_off
  rx1238_start:
    eq $I10, 1, rx1238_restart
    if_null rx1238_debug, debug_912
    rx1238_cur."!cursor_debug"("START", "statementlist")
  debug_912:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1239_done
    goto rxscan1239_scan
  rxscan1239_loop:
    (rx1238_pos) = rx1238_cur."from"()
    inc rx1238_pos
    rx1238_cur."!cursor_from"(rx1238_pos)
    ge rx1238_pos, rx1238_eos, rxscan1239_done
  rxscan1239_scan:
    set_addr $I10, rxscan1239_loop
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxscan1239_done:
  alt1240_0:
.annotate 'line', 551
    set_addr $I10, alt1240_1
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
.annotate 'line', 552
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rxanchor eos
    ne rx1238_pos, rx1238_eos, rx1238_fail
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
    goto alt1240_end
  alt1240_1:
.annotate 'line', 553
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rx rxquantr1244 ** 0..*
    set_addr $I10, rxquantr1244_done
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxquantr1244_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."statement"()
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1238_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."eat_terminator"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
    set_addr $I10, rxquantr1244_done
    (rx1238_rep) = rx1238_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1244_done
    rx1238_cur."!mark_push"(rx1238_rep, rx1238_pos, $I10)
    goto rxquantr1244_loop
  rxquantr1244_done:
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  alt1240_end:
.annotate 'line', 551
  # rx pass
    rx1238_cur."!cursor_pass"(rx1238_pos, "statementlist")
    if_null rx1238_debug, debug_913
    rx1238_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1238_pos)
  debug_913:
    .return (rx1238_cur)
  rx1238_restart:
.annotate 'line', 436
    if_null rx1238_debug, debug_914
    rx1238_cur."!cursor_debug"("NEXT", "statementlist")
  debug_914:
  rx1238_fail:
    (rx1238_rep, rx1238_pos, $I10, $P10) = rx1238_cur."!mark_fail"(0)
    lt rx1238_pos, -1, rx1238_done
    eq rx1238_pos, -1, rx1238_fail
    jump $I10
  rx1238_done:
    rx1238_cur."!cursor_fail"()
    if_null rx1238_debug, debug_915
    rx1238_cur."!cursor_debug"("FAIL", "statementlist")
  debug_915:
    .return (rx1238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("61_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1248 = self."!PREFIX__!subrule"("ws", "")
    $P1249 = self."!PREFIX__!subrule"("ws", "")
    new $P1250, "ResizablePMCArray"
    push $P1250, $P1248
    push $P1250, $P1249
    .return ($P1250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("62_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P1255 = "63_1306916577.75068" 
    capture_lex $P1255
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    rx1252_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_916
    rx1252_cur."!cursor_debug"("START", "statement")
  debug_916:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1253_done
    goto rxscan1253_scan
  rxscan1253_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1253_done
  rxscan1253_scan:
    set_addr $I10, rxscan1253_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1253_done:
.annotate 'line', 557
  # rx subrule "before" subtype=zerowidth negate=1
    rx1252_cur."!cursor_pos"(rx1252_pos)
    .const 'Sub' $P1255 = "63_1306916577.75068" 
    capture_lex $P1255
    $P10 = rx1252_cur."before"($P1255)
    if $P10, rx1252_fail
  alt1259_0:
.annotate 'line', 558
    set_addr $I10, alt1259_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
.annotate 'line', 559
  # rx subrule "statement_control" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_control"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1252_pos = $P10."pos"()
    goto alt1259_end
  alt1259_1:
.annotate 'line', 560
  # rx subrule "EXPR" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."EXPR"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1252_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."ws"()
    unless $P10, rx1252_fail
    rx1252_pos = $P10."pos"()
.annotate 'line', 565
  # rx rxquantr1260 ** 0..1
    set_addr $I10, rxquantr1260_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1260_loop:
  alt1261_0:
.annotate 'line', 561
    set_addr $I10, alt1261_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
.annotate 'line', 562
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."MARKED"("endstmt")
    unless $P10, rx1252_fail
    goto alt1261_end
  alt1261_1:
    set_addr $I10, alt1261_2
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
.annotate 'line', 563
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_mod_cond"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1252_pos = $P10."pos"()
  # rx rxquantr1262 ** 0..1
    set_addr $I10, rxquantr1262_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1262_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_mod_loop"()
    unless $P10, rx1252_fail
    goto rxsubrule1263_pass
  rxsubrule1263_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1252_fail
  rxsubrule1263_pass:
    set_addr $I10, rxsubrule1263_back
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1252_pos = $P10."pos"()
    set_addr $I10, rxquantr1262_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1262_done:
    goto alt1261_end
  alt1261_2:
.annotate 'line', 564
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_mod_loop"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1252_pos = $P10."pos"()
  alt1261_end:
.annotate 'line', 565
    set_addr $I10, rxquantr1260_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1260_done:
  alt1259_end:
.annotate 'line', 556
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "statement")
    if_null rx1252_debug, debug_921
    rx1252_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1252_pos)
  debug_921:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 436
    if_null rx1252_debug, debug_922
    rx1252_cur."!cursor_debug"("NEXT", "statement")
  debug_922:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_923
    rx1252_cur."!cursor_debug"("FAIL", "statement")
  debug_923:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1254"  :anon :subid("63_1306916577.75068") :method :outer("62_1306916577.75068")
.annotate 'line', 557
    .local string rx1256_tgt
    .local int rx1256_pos
    .local int rx1256_off
    .local int rx1256_eos
    .local int rx1256_rep
    .local pmc rx1256_cur
    .local pmc rx1256_debug
    (rx1256_cur, rx1256_pos, rx1256_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1256_cur
    .local pmc match
    .lex "$/", match
    length rx1256_eos, rx1256_tgt
    gt rx1256_pos, rx1256_eos, rx1256_done
    set rx1256_off, 0
    lt rx1256_pos, 2, rx1256_start
    sub rx1256_off, rx1256_pos, 1
    substr rx1256_tgt, rx1256_tgt, rx1256_off
  rx1256_start:
    eq $I10, 1, rx1256_restart
    if_null rx1256_debug, debug_917
    rx1256_cur."!cursor_debug"("START", "")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1257_done
    goto rxscan1257_scan
  rxscan1257_loop:
    (rx1256_pos) = rx1256_cur."from"()
    inc rx1256_pos
    rx1256_cur."!cursor_from"(rx1256_pos)
    ge rx1256_pos, rx1256_eos, rxscan1257_done
  rxscan1257_scan:
    set_addr $I10, rxscan1257_loop
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxscan1257_done:
  alt1258_0:
    set_addr $I10, alt1258_1
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1256_pos, rx1256_eos, rx1256_fail
    sub $I10, rx1256_pos, rx1256_off
    substr $S10, rx1256_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1256_fail
    inc rx1256_pos
    goto alt1258_end
  alt1258_1:
  # rxanchor eos
    ne rx1256_pos, rx1256_eos, rx1256_fail
  alt1258_end:
  # rx pass
    rx1256_cur."!cursor_pass"(rx1256_pos, "")
    if_null rx1256_debug, debug_918
    rx1256_cur."!cursor_debug"("PASS", "", " at pos=", rx1256_pos)
  debug_918:
    .return (rx1256_cur)
  rx1256_restart:
    if_null rx1256_debug, debug_919
    rx1256_cur."!cursor_debug"("NEXT", "")
  debug_919:
  rx1256_fail:
    (rx1256_rep, rx1256_pos, $I10, $P10) = rx1256_cur."!mark_fail"(0)
    lt rx1256_pos, -1, rx1256_done
    eq rx1256_pos, -1, rx1256_fail
    jump $I10
  rx1256_done:
    rx1256_cur."!cursor_fail"()
    if_null rx1256_debug, debug_920
    rx1256_cur."!cursor_debug"("FAIL", "")
  debug_920:
    .return (rx1256_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("64_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1265, "ResizablePMCArray"
    push $P1265, ""
    .return ($P1265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("65_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_924
    rx1267_cur."!cursor_debug"("START", "eat_terminator")
  debug_924:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1268_done
    goto rxscan1268_scan
  rxscan1268_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1268_done
  rxscan1268_scan:
    set_addr $I10, rxscan1268_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1268_done:
  alt1269_0:
.annotate 'line', 569
    set_addr $I10, alt1269_1
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
.annotate 'line', 570
  # rx literal  ";"
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 59, rx1267_fail
    add rx1267_pos, 1
    goto alt1269_end
  alt1269_1:
    set_addr $I10, alt1269_2
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
.annotate 'line', 571
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."MARKED"("endstmt")
    unless $P10, rx1267_fail
    goto alt1269_end
  alt1269_2:
    set_addr $I10, alt1269_3
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
.annotate 'line', 572
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."terminator"()
    unless $P10, rx1267_fail
    goto alt1269_end
  alt1269_3:
.annotate 'line', 573
  # rxanchor eos
    ne rx1267_pos, rx1267_eos, rx1267_fail
  alt1269_end:
.annotate 'line', 569
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "eat_terminator")
    if_null rx1267_debug, debug_925
    rx1267_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1267_pos)
  debug_925:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 436
    if_null rx1267_debug, debug_926
    rx1267_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_926:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_927
    rx1267_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_927:
    .return (rx1267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("66_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1271, "ResizablePMCArray"
    push $P1271, ""
    push $P1271, ""
    push $P1271, ""
    push $P1271, ";"
    .return ($P1271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("67_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1273_tgt
    .local int rx1273_pos
    .local int rx1273_off
    .local int rx1273_eos
    .local int rx1273_rep
    .local pmc rx1273_cur
    .local pmc rx1273_debug
    (rx1273_cur, rx1273_pos, rx1273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1273_cur
    .local pmc match
    .lex "$/", match
    length rx1273_eos, rx1273_tgt
    gt rx1273_pos, rx1273_eos, rx1273_done
    set rx1273_off, 0
    lt rx1273_pos, 2, rx1273_start
    sub rx1273_off, rx1273_pos, 1
    substr rx1273_tgt, rx1273_tgt, rx1273_off
  rx1273_start:
    eq $I10, 1, rx1273_restart
    if_null rx1273_debug, debug_928
    rx1273_cur."!cursor_debug"("START", "xblock")
  debug_928:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1274_done
    goto rxscan1274_scan
  rxscan1274_loop:
    (rx1273_pos) = rx1273_cur."from"()
    inc rx1273_pos
    rx1273_cur."!cursor_from"(rx1273_pos)
    ge rx1273_pos, rx1273_eos, rxscan1274_done
  rxscan1274_scan:
    set_addr $I10, rxscan1274_loop
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  rxscan1274_done:
.annotate 'line', 577
  # rx subrule "EXPR" subtype=capture negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."EXPR"()
    unless $P10, rx1273_fail
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1273_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."ws"()
    unless $P10, rx1273_fail
    rx1273_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."pblock"()
    unless $P10, rx1273_fail
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1273_pos = $P10."pos"()
.annotate 'line', 576
  # rx pass
    rx1273_cur."!cursor_pass"(rx1273_pos, "xblock")
    if_null rx1273_debug, debug_929
    rx1273_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1273_pos)
  debug_929:
    .return (rx1273_cur)
  rx1273_restart:
.annotate 'line', 436
    if_null rx1273_debug, debug_930
    rx1273_cur."!cursor_debug"("NEXT", "xblock")
  debug_930:
  rx1273_fail:
    (rx1273_rep, rx1273_pos, $I10, $P10) = rx1273_cur."!mark_fail"(0)
    lt rx1273_pos, -1, rx1273_done
    eq rx1273_pos, -1, rx1273_fail
    jump $I10
  rx1273_done:
    rx1273_cur."!cursor_fail"()
    if_null rx1273_debug, debug_931
    rx1273_cur."!cursor_debug"("FAIL", "xblock")
  debug_931:
    .return (rx1273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("68_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1276 = self."!PREFIX__!subrule"("EXPR", "")
    new $P1277, "ResizablePMCArray"
    push $P1277, $P1276
    .return ($P1277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("69_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_932
    rx1279_cur."!cursor_debug"("START", "pblock")
  debug_932:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1279_pos) = rx1279_cur."from"()
    inc rx1279_pos
    rx1279_cur."!cursor_from"(rx1279_pos)
    ge rx1279_pos, rx1279_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1280_done:
  alt1281_0:
.annotate 'line', 580
    set_addr $I10, alt1281_1
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
.annotate 'line', 581
  # rx subrule "lambda" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."lambda"()
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
.annotate 'line', 582
  # rx subrule "newpad" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."newpad"()
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
.annotate 'line', 583
  # rx subrule "signature" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."signature"()
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1279_pos = $P10."pos"()
.annotate 'line', 584
  # rx subrule "blockoid" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."blockoid"()
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1279_pos = $P10."pos"()
.annotate 'line', 581
    goto alt1281_end
  alt1281_1:
    set_addr $I10, alt1281_2
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
.annotate 'line', 585
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1279_pos, rx1279_off
    substr $S10, rx1279_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1279_fail
.annotate 'line', 586
  # rx subrule "newpad" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."newpad"()
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
.annotate 'line', 587
  # rx subrule "blockoid" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."blockoid"()
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1279_pos = $P10."pos"()
.annotate 'line', 585
    goto alt1281_end
  alt1281_2:
.annotate 'line', 588
  # rx subrule "panic" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."panic"("Missing block")
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
  alt1281_end:
.annotate 'line', 580
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "pblock")
    if_null rx1279_debug, debug_933
    rx1279_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1279_pos)
  debug_933:
    .return (rx1279_cur)
  rx1279_restart:
.annotate 'line', 436
    if_null rx1279_debug, debug_934
    rx1279_cur."!cursor_debug"("NEXT", "pblock")
  debug_934:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_935
    rx1279_cur."!cursor_debug"("FAIL", "pblock")
  debug_935:
    .return (rx1279_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("70_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1283 = self."!PREFIX__!subrule"("panic", "")
    $P1284 = self."!PREFIX__!subrule"("lambda", "")
    new $P1285, "ResizablePMCArray"
    push $P1285, $P1283
    push $P1285, "{"
    push $P1285, $P1284
    .return ($P1285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("71_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1287_tgt
    .local int rx1287_pos
    .local int rx1287_off
    .local int rx1287_eos
    .local int rx1287_rep
    .local pmc rx1287_cur
    .local pmc rx1287_debug
    (rx1287_cur, rx1287_pos, rx1287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1287_cur
    .local pmc match
    .lex "$/", match
    length rx1287_eos, rx1287_tgt
    gt rx1287_pos, rx1287_eos, rx1287_done
    set rx1287_off, 0
    lt rx1287_pos, 2, rx1287_start
    sub rx1287_off, rx1287_pos, 1
    substr rx1287_tgt, rx1287_tgt, rx1287_off
  rx1287_start:
    eq $I10, 1, rx1287_restart
    if_null rx1287_debug, debug_936
    rx1287_cur."!cursor_debug"("START", "lambda")
  debug_936:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1288_done
    goto rxscan1288_scan
  rxscan1288_loop:
    (rx1287_pos) = rx1287_cur."from"()
    inc rx1287_pos
    rx1287_cur."!cursor_from"(rx1287_pos)
    ge rx1287_pos, rx1287_eos, rxscan1288_done
  rxscan1288_scan:
    set_addr $I10, rxscan1288_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxscan1288_done:
  alt1289_0:
.annotate 'line', 591
    set_addr $I10, alt1289_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rx literal  "->"
    add $I11, rx1287_pos, 2
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 2
    ne $S10, "->", rx1287_fail
    add rx1287_pos, 2
    goto alt1289_end
  alt1289_1:
  # rx literal  "<->"
    add $I11, rx1287_pos, 3
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 3
    ne $S10, "<->", rx1287_fail
    add rx1287_pos, 3
  alt1289_end:
  # rx pass
    rx1287_cur."!cursor_pass"(rx1287_pos, "lambda")
    if_null rx1287_debug, debug_937
    rx1287_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1287_pos)
  debug_937:
    .return (rx1287_cur)
  rx1287_restart:
.annotate 'line', 436
    if_null rx1287_debug, debug_938
    rx1287_cur."!cursor_debug"("NEXT", "lambda")
  debug_938:
  rx1287_fail:
    (rx1287_rep, rx1287_pos, $I10, $P10) = rx1287_cur."!mark_fail"(0)
    lt rx1287_pos, -1, rx1287_done
    eq rx1287_pos, -1, rx1287_fail
    jump $I10
  rx1287_done:
    rx1287_cur."!cursor_fail"()
    if_null rx1287_debug, debug_939
    rx1287_cur."!cursor_debug"("FAIL", "lambda")
  debug_939:
    .return (rx1287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("72_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1291, "ResizablePMCArray"
    push $P1291, "<->"
    push $P1291, "->"
    .return ($P1291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("73_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1293_tgt
    .local int rx1293_pos
    .local int rx1293_off
    .local int rx1293_eos
    .local int rx1293_rep
    .local pmc rx1293_cur
    .local pmc rx1293_debug
    (rx1293_cur, rx1293_pos, rx1293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1293_cur
    .local pmc match
    .lex "$/", match
    length rx1293_eos, rx1293_tgt
    gt rx1293_pos, rx1293_eos, rx1293_done
    set rx1293_off, 0
    lt rx1293_pos, 2, rx1293_start
    sub rx1293_off, rx1293_pos, 1
    substr rx1293_tgt, rx1293_tgt, rx1293_off
  rx1293_start:
    eq $I10, 1, rx1293_restart
    if_null rx1293_debug, debug_940
    rx1293_cur."!cursor_debug"("START", "block")
  debug_940:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1294_done
    goto rxscan1294_scan
  rxscan1294_loop:
    (rx1293_pos) = rx1293_cur."from"()
    inc rx1293_pos
    rx1293_cur."!cursor_from"(rx1293_pos)
    ge rx1293_pos, rx1293_eos, rxscan1294_done
  rxscan1294_scan:
    set_addr $I10, rxscan1294_loop
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  rxscan1294_done:
  alt1295_0:
.annotate 'line', 594
    set_addr $I10, alt1295_1
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1293_pos, rx1293_off
    substr $S10, rx1293_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1293_fail
    goto alt1295_end
  alt1295_1:
  # rx subrule "panic" subtype=method negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."panic"("Missing block")
    unless $P10, rx1293_fail
    rx1293_pos = $P10."pos"()
  alt1295_end:
.annotate 'line', 595
  # rx subrule "newpad" subtype=method negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."newpad"()
    unless $P10, rx1293_fail
    rx1293_pos = $P10."pos"()
.annotate 'line', 596
  # rx subrule "blockoid" subtype=capture negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."blockoid"()
    unless $P10, rx1293_fail
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1293_pos = $P10."pos"()
.annotate 'line', 593
  # rx pass
    rx1293_cur."!cursor_pass"(rx1293_pos, "block")
    if_null rx1293_debug, debug_941
    rx1293_cur."!cursor_debug"("PASS", "block", " at pos=", rx1293_pos)
  debug_941:
    .return (rx1293_cur)
  rx1293_restart:
.annotate 'line', 436
    if_null rx1293_debug, debug_942
    rx1293_cur."!cursor_debug"("NEXT", "block")
  debug_942:
  rx1293_fail:
    (rx1293_rep, rx1293_pos, $I10, $P10) = rx1293_cur."!mark_fail"(0)
    lt rx1293_pos, -1, rx1293_done
    eq rx1293_pos, -1, rx1293_fail
    jump $I10
  rx1293_done:
    rx1293_cur."!cursor_fail"()
    if_null rx1293_debug, debug_943
    rx1293_cur."!cursor_debug"("FAIL", "block")
  debug_943:
    .return (rx1293_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("74_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1297 = self."!PREFIX__!subrule"("panic", "")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    push $P1298, "{"
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("75_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1300_tgt
    .local int rx1300_pos
    .local int rx1300_off
    .local int rx1300_eos
    .local int rx1300_rep
    .local pmc rx1300_cur
    .local pmc rx1300_debug
    (rx1300_cur, rx1300_pos, rx1300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1300_cur
    .local pmc match
    .lex "$/", match
    length rx1300_eos, rx1300_tgt
    gt rx1300_pos, rx1300_eos, rx1300_done
    set rx1300_off, 0
    lt rx1300_pos, 2, rx1300_start
    sub rx1300_off, rx1300_pos, 1
    substr rx1300_tgt, rx1300_tgt, rx1300_off
  rx1300_start:
    eq $I10, 1, rx1300_restart
    if_null rx1300_debug, debug_944
    rx1300_cur."!cursor_debug"("START", "blockoid")
  debug_944:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1301_done
    goto rxscan1301_scan
  rxscan1301_loop:
    (rx1300_pos) = rx1300_cur."from"()
    inc rx1300_pos
    rx1300_cur."!cursor_from"(rx1300_pos)
    ge rx1300_pos, rx1300_eos, rxscan1301_done
  rxscan1301_scan:
    set_addr $I10, rxscan1301_loop
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  rxscan1301_done:
.annotate 'line', 600
  # rx subrule "finishpad" subtype=method negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."finishpad"()
    unless $P10, rx1300_fail
    rx1300_pos = $P10."pos"()
  alt1302_0:
.annotate 'line', 601
    set_addr $I10, alt1302_1
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
.annotate 'line', 602
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1300_pos, 14
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    substr $S10, rx1300_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1300_fail
    add rx1300_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."you_are_here"()
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1300_pos = $P10."pos"()
    goto alt1302_end
  alt1302_1:
.annotate 'line', 603
  # rx literal  "{"
    add $I11, rx1300_pos, 1
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    ord $I11, rx1300_tgt, $I11
    ne $I11, 123, rx1300_fail
    add rx1300_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."statementlist"()
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1300_pos = $P10."pos"()
  alt1303_0:
    set_addr $I10, alt1303_1
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  # rx literal  "}"
    add $I11, rx1300_pos, 1
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    ord $I11, rx1300_tgt, $I11
    ne $I11, 125, rx1300_fail
    add rx1300_pos, 1
    goto alt1303_end
  alt1303_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."FAILGOAL"("'}'")
    unless $P10, rx1300_fail
    goto rxsubrule1305_pass
  rxsubrule1305_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1300_fail
  rxsubrule1305_pass:
    set_addr $I10, rxsubrule1305_back
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10, $P10)
    rx1300_pos = $P10."pos"()
  alt1303_end:
  alt1302_end:
.annotate 'line', 605
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."ENDSTMT"()
    unless $P10, rx1300_fail
.annotate 'line', 599
  # rx pass
    rx1300_cur."!cursor_pass"(rx1300_pos, "blockoid")
    if_null rx1300_debug, debug_945
    rx1300_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1300_pos)
  debug_945:
    .return (rx1300_cur)
  rx1300_restart:
.annotate 'line', 436
    if_null rx1300_debug, debug_946
    rx1300_cur."!cursor_debug"("NEXT", "blockoid")
  debug_946:
  rx1300_fail:
    (rx1300_rep, rx1300_pos, $I10, $P10) = rx1300_cur."!mark_fail"(0)
    lt rx1300_pos, -1, rx1300_done
    eq rx1300_pos, -1, rx1300_fail
    jump $I10
  rx1300_done:
    rx1300_cur."!cursor_fail"()
    if_null rx1300_debug, debug_947
    rx1300_cur."!cursor_debug"("FAIL", "blockoid")
  debug_947:
    .return (rx1300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("76_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1307 = self."!PREFIX__!subrule"("finishpad", "")
    new $P1308, "ResizablePMCArray"
    push $P1308, $P1307
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("77_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_948
    rx1310_cur."!cursor_debug"("START", "newpad")
  debug_948:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1311_done:
.annotate 'line', 608
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "newpad")
    if_null rx1310_debug, debug_949
    rx1310_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1310_pos)
  debug_949:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 436
    if_null rx1310_debug, debug_950
    rx1310_cur."!cursor_debug"("NEXT", "newpad")
  debug_950:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_951
    rx1310_cur."!cursor_debug"("FAIL", "newpad")
  debug_951:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("78_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1313, "ResizablePMCArray"
    push $P1313, ""
    .return ($P1313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("79_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1315_tgt
    .local int rx1315_pos
    .local int rx1315_off
    .local int rx1315_eos
    .local int rx1315_rep
    .local pmc rx1315_cur
    .local pmc rx1315_debug
    (rx1315_cur, rx1315_pos, rx1315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1315_cur
    .local pmc match
    .lex "$/", match
    length rx1315_eos, rx1315_tgt
    gt rx1315_pos, rx1315_eos, rx1315_done
    set rx1315_off, 0
    lt rx1315_pos, 2, rx1315_start
    sub rx1315_off, rx1315_pos, 1
    substr rx1315_tgt, rx1315_tgt, rx1315_off
  rx1315_start:
    eq $I10, 1, rx1315_restart
    if_null rx1315_debug, debug_952
    rx1315_cur."!cursor_debug"("START", "outerctx")
  debug_952:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1316_done
    goto rxscan1316_scan
  rxscan1316_loop:
    (rx1315_pos) = rx1315_cur."from"()
    inc rx1315_pos
    rx1315_cur."!cursor_from"(rx1315_pos)
    ge rx1315_pos, rx1315_eos, rxscan1316_done
  rxscan1316_scan:
    set_addr $I10, rxscan1316_loop
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  rxscan1316_done:
.annotate 'line', 609
  # rx pass
    rx1315_cur."!cursor_pass"(rx1315_pos, "outerctx")
    if_null rx1315_debug, debug_953
    rx1315_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1315_pos)
  debug_953:
    .return (rx1315_cur)
  rx1315_restart:
.annotate 'line', 436
    if_null rx1315_debug, debug_954
    rx1315_cur."!cursor_debug"("NEXT", "outerctx")
  debug_954:
  rx1315_fail:
    (rx1315_rep, rx1315_pos, $I10, $P10) = rx1315_cur."!mark_fail"(0)
    lt rx1315_pos, -1, rx1315_done
    eq rx1315_pos, -1, rx1315_fail
    jump $I10
  rx1315_done:
    rx1315_cur."!cursor_fail"()
    if_null rx1315_debug, debug_955
    rx1315_cur."!cursor_debug"("FAIL", "outerctx")
  debug_955:
    .return (rx1315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("80_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1318, "ResizablePMCArray"
    push $P1318, ""
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("81_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1320_tgt
    .local int rx1320_pos
    .local int rx1320_off
    .local int rx1320_eos
    .local int rx1320_rep
    .local pmc rx1320_cur
    .local pmc rx1320_debug
    (rx1320_cur, rx1320_pos, rx1320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1320_cur
    .local pmc match
    .lex "$/", match
    length rx1320_eos, rx1320_tgt
    gt rx1320_pos, rx1320_eos, rx1320_done
    set rx1320_off, 0
    lt rx1320_pos, 2, rx1320_start
    sub rx1320_off, rx1320_pos, 1
    substr rx1320_tgt, rx1320_tgt, rx1320_off
  rx1320_start:
    eq $I10, 1, rx1320_restart
    if_null rx1320_debug, debug_956
    rx1320_cur."!cursor_debug"("START", "GLOBALish")
  debug_956:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1320_pos) = rx1320_cur."from"()
    inc rx1320_pos
    rx1320_cur."!cursor_from"(rx1320_pos)
    ge rx1320_pos, rx1320_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  rxscan1321_done:
.annotate 'line', 610
  # rx pass
    rx1320_cur."!cursor_pass"(rx1320_pos, "GLOBALish")
    if_null rx1320_debug, debug_957
    rx1320_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1320_pos)
  debug_957:
    .return (rx1320_cur)
  rx1320_restart:
.annotate 'line', 436
    if_null rx1320_debug, debug_958
    rx1320_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_958:
  rx1320_fail:
    (rx1320_rep, rx1320_pos, $I10, $P10) = rx1320_cur."!mark_fail"(0)
    lt rx1320_pos, -1, rx1320_done
    eq rx1320_pos, -1, rx1320_fail
    jump $I10
  rx1320_done:
    rx1320_cur."!cursor_fail"()
    if_null rx1320_debug, debug_959
    rx1320_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_959:
    .return (rx1320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("82_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1323, "ResizablePMCArray"
    push $P1323, ""
    .return ($P1323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("83_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1325_tgt
    .local int rx1325_pos
    .local int rx1325_off
    .local int rx1325_eos
    .local int rx1325_rep
    .local pmc rx1325_cur
    .local pmc rx1325_debug
    (rx1325_cur, rx1325_pos, rx1325_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1325_cur
    .local pmc match
    .lex "$/", match
    length rx1325_eos, rx1325_tgt
    gt rx1325_pos, rx1325_eos, rx1325_done
    set rx1325_off, 0
    lt rx1325_pos, 2, rx1325_start
    sub rx1325_off, rx1325_pos, 1
    substr rx1325_tgt, rx1325_tgt, rx1325_off
  rx1325_start:
    eq $I10, 1, rx1325_restart
    if_null rx1325_debug, debug_960
    rx1325_cur."!cursor_debug"("START", "finishpad")
  debug_960:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1325_pos) = rx1325_cur."from"()
    inc rx1325_pos
    rx1325_cur."!cursor_from"(rx1325_pos)
    ge rx1325_pos, rx1325_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1325_cur."!mark_push"(0, rx1325_pos, $I10)
  rxscan1326_done:
.annotate 'line', 611
  # rx pass
    rx1325_cur."!cursor_pass"(rx1325_pos, "finishpad")
    if_null rx1325_debug, debug_961
    rx1325_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1325_pos)
  debug_961:
    .return (rx1325_cur)
  rx1325_restart:
.annotate 'line', 436
    if_null rx1325_debug, debug_962
    rx1325_cur."!cursor_debug"("NEXT", "finishpad")
  debug_962:
  rx1325_fail:
    (rx1325_rep, rx1325_pos, $I10, $P10) = rx1325_cur."!mark_fail"(0)
    lt rx1325_pos, -1, rx1325_done
    eq rx1325_pos, -1, rx1325_fail
    jump $I10
  rx1325_done:
    rx1325_cur."!cursor_fail"()
    if_null rx1325_debug, debug_963
    rx1325_cur."!cursor_debug"("FAIL", "finishpad")
  debug_963:
    .return (rx1325_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("84_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1328, "ResizablePMCArray"
    push $P1328, ""
    .return ($P1328)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("85_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1330_tgt
    .local int rx1330_pos
    .local int rx1330_off
    .local int rx1330_eos
    .local int rx1330_rep
    .local pmc rx1330_cur
    .local pmc rx1330_debug
    (rx1330_cur, rx1330_pos, rx1330_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1330_cur
    .local pmc match
    .lex "$/", match
    length rx1330_eos, rx1330_tgt
    gt rx1330_pos, rx1330_eos, rx1330_done
    set rx1330_off, 0
    lt rx1330_pos, 2, rx1330_start
    sub rx1330_off, rx1330_pos, 1
    substr rx1330_tgt, rx1330_tgt, rx1330_off
  rx1330_start:
    eq $I10, 1, rx1330_restart
    if_null rx1330_debug, debug_964
    rx1330_cur."!cursor_debug"("START", "you_are_here")
  debug_964:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1331_done
    goto rxscan1331_scan
  rxscan1331_loop:
    (rx1330_pos) = rx1330_cur."from"()
    inc rx1330_pos
    rx1330_cur."!cursor_from"(rx1330_pos)
    ge rx1330_pos, rx1330_eos, rxscan1331_done
  rxscan1331_scan:
    set_addr $I10, rxscan1331_loop
    rx1330_cur."!mark_push"(0, rx1330_pos, $I10)
  rxscan1331_done:
.annotate 'line', 612
  # rx pass
    rx1330_cur."!cursor_pass"(rx1330_pos, "you_are_here")
    if_null rx1330_debug, debug_965
    rx1330_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1330_pos)
  debug_965:
    .return (rx1330_cur)
  rx1330_restart:
.annotate 'line', 436
    if_null rx1330_debug, debug_966
    rx1330_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_966:
  rx1330_fail:
    (rx1330_rep, rx1330_pos, $I10, $P10) = rx1330_cur."!mark_fail"(0)
    lt rx1330_pos, -1, rx1330_done
    eq rx1330_pos, -1, rx1330_fail
    jump $I10
  rx1330_done:
    rx1330_cur."!cursor_fail"()
    if_null rx1330_debug, debug_967
    rx1330_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_967:
    .return (rx1330_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("86_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1333, "ResizablePMCArray"
    push $P1333, ""
    .return ($P1333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("87_1306916577.75068")
    .param pmc param_1335
.annotate 'line', 614
    .lex "self", param_1335
    $P1336 = param_1335."!protoregex"("terminator")
    .return ($P1336)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("88_1306916577.75068")
    .param pmc param_1338
.annotate 'line', 614
    .lex "self", param_1338
    $P1339 = param_1338."!PREFIX__!protoregex"("terminator")
    .return ($P1339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("89_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1341_tgt
    .local int rx1341_pos
    .local int rx1341_off
    .local int rx1341_eos
    .local int rx1341_rep
    .local pmc rx1341_cur
    .local pmc rx1341_debug
    (rx1341_cur, rx1341_pos, rx1341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1341_cur
    .local pmc match
    .lex "$/", match
    length rx1341_eos, rx1341_tgt
    gt rx1341_pos, rx1341_eos, rx1341_done
    set rx1341_off, 0
    lt rx1341_pos, 2, rx1341_start
    sub rx1341_off, rx1341_pos, 1
    substr rx1341_tgt, rx1341_tgt, rx1341_off
  rx1341_start:
    eq $I10, 1, rx1341_restart
    if_null rx1341_debug, debug_968
    rx1341_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_968:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1342_done
    goto rxscan1342_scan
  rxscan1342_loop:
    (rx1341_pos) = rx1341_cur."from"()
    inc rx1341_pos
    rx1341_cur."!cursor_from"(rx1341_pos)
    ge rx1341_pos, rx1341_eos, rxscan1342_done
  rxscan1342_scan:
    set_addr $I10, rxscan1342_loop
    rx1341_cur."!mark_push"(0, rx1341_pos, $I10)
  rxscan1342_done:
.annotate 'line', 616
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1341_pos, rx1341_off
    substr $S10, rx1341_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1341_fail
  # rx pass
    rx1341_cur."!cursor_pass"(rx1341_pos, "terminator:sym<;>")
    if_null rx1341_debug, debug_969
    rx1341_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1341_pos)
  debug_969:
    .return (rx1341_cur)
  rx1341_restart:
.annotate 'line', 436
    if_null rx1341_debug, debug_970
    rx1341_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_970:
  rx1341_fail:
    (rx1341_rep, rx1341_pos, $I10, $P10) = rx1341_cur."!mark_fail"(0)
    lt rx1341_pos, -1, rx1341_done
    eq rx1341_pos, -1, rx1341_fail
    jump $I10
  rx1341_done:
    rx1341_cur."!cursor_fail"()
    if_null rx1341_debug, debug_971
    rx1341_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_971:
    .return (rx1341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("90_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1344, "ResizablePMCArray"
    push $P1344, ";"
    .return ($P1344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("91_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1346_tgt
    .local int rx1346_pos
    .local int rx1346_off
    .local int rx1346_eos
    .local int rx1346_rep
    .local pmc rx1346_cur
    .local pmc rx1346_debug
    (rx1346_cur, rx1346_pos, rx1346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1346_cur
    .local pmc match
    .lex "$/", match
    length rx1346_eos, rx1346_tgt
    gt rx1346_pos, rx1346_eos, rx1346_done
    set rx1346_off, 0
    lt rx1346_pos, 2, rx1346_start
    sub rx1346_off, rx1346_pos, 1
    substr rx1346_tgt, rx1346_tgt, rx1346_off
  rx1346_start:
    eq $I10, 1, rx1346_restart
    if_null rx1346_debug, debug_972
    rx1346_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_972:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1346_pos) = rx1346_cur."from"()
    inc rx1346_pos
    rx1346_cur."!cursor_from"(rx1346_pos)
    ge rx1346_pos, rx1346_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1346_cur."!mark_push"(0, rx1346_pos, $I10)
  rxscan1347_done:
.annotate 'line', 617
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1346_pos, rx1346_off
    substr $S10, rx1346_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1346_fail
  # rx pass
    rx1346_cur."!cursor_pass"(rx1346_pos, "terminator:sym<}>")
    if_null rx1346_debug, debug_973
    rx1346_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1346_pos)
  debug_973:
    .return (rx1346_cur)
  rx1346_restart:
.annotate 'line', 436
    if_null rx1346_debug, debug_974
    rx1346_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_974:
  rx1346_fail:
    (rx1346_rep, rx1346_pos, $I10, $P10) = rx1346_cur."!mark_fail"(0)
    lt rx1346_pos, -1, rx1346_done
    eq rx1346_pos, -1, rx1346_fail
    jump $I10
  rx1346_done:
    rx1346_cur."!cursor_fail"()
    if_null rx1346_debug, debug_975
    rx1346_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_975:
    .return (rx1346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("92_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1349, "ResizablePMCArray"
    push $P1349, "}"
    .return ($P1349)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("93_1306916577.75068")
    .param pmc param_1351
.annotate 'line', 621
    .lex "self", param_1351
    $P1352 = param_1351."!protoregex"("statement_control")
    .return ($P1352)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("94_1306916577.75068")
    .param pmc param_1354
.annotate 'line', 621
    .lex "self", param_1354
    $P1355 = param_1354."!PREFIX__!protoregex"("statement_control")
    .return ($P1355)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("95_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1357_tgt
    .local int rx1357_pos
    .local int rx1357_off
    .local int rx1357_eos
    .local int rx1357_rep
    .local pmc rx1357_cur
    .local pmc rx1357_debug
    (rx1357_cur, rx1357_pos, rx1357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1357_cur
    .local pmc match
    .lex "$/", match
    length rx1357_eos, rx1357_tgt
    gt rx1357_pos, rx1357_eos, rx1357_done
    set rx1357_off, 0
    lt rx1357_pos, 2, rx1357_start
    sub rx1357_off, rx1357_pos, 1
    substr rx1357_tgt, rx1357_tgt, rx1357_off
  rx1357_start:
    eq $I10, 1, rx1357_restart
    if_null rx1357_debug, debug_976
    rx1357_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_976:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1357_pos) = rx1357_cur."from"()
    inc rx1357_pos
    rx1357_cur."!cursor_from"(rx1357_pos)
    ge rx1357_pos, rx1357_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  rxscan1358_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1359_fail
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  # rx literal  "use"
    add $I11, rx1357_pos, 3
    gt $I11, rx1357_eos, rx1357_fail
    sub $I11, rx1357_pos, rx1357_off
    substr $S10, rx1357_tgt, $I11, 3
    ne $S10, "use", rx1357_fail
    add rx1357_pos, 3
    set_addr $I10, rxcap_1359_fail
    ($I12, $I11) = rx1357_cur."!mark_peek"($I10)
    rx1357_cur."!cursor_pos"($I11)
    ($P10) = rx1357_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1357_pos, "")
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1359_done
  rxcap_1359_fail:
    goto rx1357_fail
  rxcap_1359_done:
  # rx charclass s
    ge rx1357_pos, rx1357_eos, rx1357_fail
    sub $I10, rx1357_pos, rx1357_off
    is_cclass $I11, 32, rx1357_tgt, $I10
    unless $I11, rx1357_fail
    inc rx1357_pos
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."name"()
    unless $P10, rx1357_fail
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1357_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
.annotate 'line', 623
  # rx pass
    rx1357_cur."!cursor_pass"(rx1357_pos, "statement_control:sym<use>")
    if_null rx1357_debug, debug_977
    rx1357_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1357_pos)
  debug_977:
    .return (rx1357_cur)
  rx1357_restart:
.annotate 'line', 436
    if_null rx1357_debug, debug_978
    rx1357_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_978:
  rx1357_fail:
    (rx1357_rep, rx1357_pos, $I10, $P10) = rx1357_cur."!mark_fail"(0)
    lt rx1357_pos, -1, rx1357_done
    eq rx1357_pos, -1, rx1357_fail
    jump $I10
  rx1357_done:
    rx1357_cur."!cursor_fail"()
    if_null rx1357_debug, debug_979
    rx1357_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_979:
    .return (rx1357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("96_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1363, "ResizablePMCArray"
    push $P1363, "use"
    .return ($P1363)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("97_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    rx1365_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_980
    rx1365_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_980:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1366_done
    goto rxscan1366_scan
  rxscan1366_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1366_done
  rxscan1366_scan:
    set_addr $I10, rxscan1366_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1366_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1367_fail
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  # rx literal  "if"
    add $I11, rx1365_pos, 2
    gt $I11, rx1365_eos, rx1365_fail
    sub $I11, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I11, 2
    ne $S10, "if", rx1365_fail
    add rx1365_pos, 2
    set_addr $I10, rxcap_1367_fail
    ($I12, $I11) = rx1365_cur."!mark_peek"($I10)
    rx1365_cur."!cursor_pos"($I11)
    ($P10) = rx1365_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1365_pos, "")
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1367_done
  rxcap_1367_fail:
    goto rx1365_fail
  rxcap_1367_done:
  # rx charclass s
    ge rx1365_pos, rx1365_eos, rx1365_fail
    sub $I10, rx1365_pos, rx1365_off
    is_cclass $I11, 32, rx1365_tgt, $I10
    unless $I11, rx1365_fail
    inc rx1365_pos
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 629
  # rx subrule "xblock" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."xblock"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 630
  # rx rxquantr1370 ** 0..*
    set_addr $I10, rxquantr1370_done
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxquantr1370_loop:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1365_pos, 5
    gt $I11, rx1365_eos, rx1365_fail
    sub $I11, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I11, 5
    ne $S10, "elsif", rx1365_fail
    add rx1365_pos, 5
  # rx charclass s
    ge rx1365_pos, rx1365_eos, rx1365_fail
    sub $I10, rx1365_pos, rx1365_off
    is_cclass $I11, 32, rx1365_tgt, $I10
    unless $I11, rx1365_fail
    inc rx1365_pos
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."xblock"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
    set_addr $I10, rxquantr1370_done
    (rx1365_rep) = rx1365_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1370_done
    rx1365_cur."!mark_push"(rx1365_rep, rx1365_pos, $I10)
    goto rxquantr1370_loop
  rxquantr1370_done:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 631
  # rx rxquantr1375 ** 0..1
    set_addr $I10, rxquantr1375_done
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxquantr1375_loop:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1365_pos, 4
    gt $I11, rx1365_eos, rx1365_fail
    sub $I11, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I11, 4
    ne $S10, "else", rx1365_fail
    add rx1365_pos, 4
  # rx charclass s
    ge rx1365_pos, rx1365_eos, rx1365_fail
    sub $I10, rx1365_pos, rx1365_off
    is_cclass $I11, 32, rx1365_tgt, $I10
    unless $I11, rx1365_fail
    inc rx1365_pos
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."pblock"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
    set_addr $I10, rxquantr1375_done
    (rx1365_rep) = rx1365_cur."!mark_commit"($I10)
  rxquantr1375_done:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 627
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, "statement_control:sym<if>")
    if_null rx1365_debug, debug_981
    rx1365_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1365_pos)
  debug_981:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 436
    if_null rx1365_debug, debug_982
    rx1365_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_982:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_983
    rx1365_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_983:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("98_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1381, "ResizablePMCArray"
    push $P1381, "if"
    .return ($P1381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("99_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P1391 = "100_1306916577.75068" 
    capture_lex $P1391
    .local string rx1383_tgt
    .local int rx1383_pos
    .local int rx1383_off
    .local int rx1383_eos
    .local int rx1383_rep
    .local pmc rx1383_cur
    .local pmc rx1383_debug
    (rx1383_cur, rx1383_pos, rx1383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1383_cur
    .local pmc match
    .lex "$/", match
    length rx1383_eos, rx1383_tgt
    gt rx1383_pos, rx1383_eos, rx1383_done
    set rx1383_off, 0
    lt rx1383_pos, 2, rx1383_start
    sub rx1383_off, rx1383_pos, 1
    substr rx1383_tgt, rx1383_tgt, rx1383_off
  rx1383_start:
    eq $I10, 1, rx1383_restart
    if_null rx1383_debug, debug_984
    rx1383_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_984:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1384_done
    goto rxscan1384_scan
  rxscan1384_loop:
    (rx1383_pos) = rx1383_cur."from"()
    inc rx1383_pos
    rx1383_cur."!cursor_from"(rx1383_pos)
    ge rx1383_pos, rx1383_eos, rxscan1384_done
  rxscan1384_scan:
    set_addr $I10, rxscan1384_loop
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  rxscan1384_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1385_fail
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1383_pos, 6
    gt $I11, rx1383_eos, rx1383_fail
    sub $I11, rx1383_pos, rx1383_off
    substr $S10, rx1383_tgt, $I11, 6
    ne $S10, "unless", rx1383_fail
    add rx1383_pos, 6
    set_addr $I10, rxcap_1385_fail
    ($I12, $I11) = rx1383_cur."!mark_peek"($I10)
    rx1383_cur."!cursor_pos"($I11)
    ($P10) = rx1383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1383_pos, "")
    rx1383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1385_done
  rxcap_1385_fail:
    goto rx1383_fail
  rxcap_1385_done:
  # rx charclass s
    ge rx1383_pos, rx1383_eos, rx1383_fail
    sub $I10, rx1383_pos, rx1383_off
    is_cclass $I11, 32, rx1383_tgt, $I10
    unless $I11, rx1383_fail
    inc rx1383_pos
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
.annotate 'line', 636
  # rx subrule "xblock" subtype=capture negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."xblock"()
    unless $P10, rx1383_fail
    rx1383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  alt1388_0:
.annotate 'line', 637
    set_addr $I10, alt1388_1
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1383_cur."!cursor_pos"(rx1383_pos)
    .const 'Sub' $P1391 = "100_1306916577.75068" 
    capture_lex $P1391
    $P10 = rx1383_cur."before"($P1391)
    if $P10, rx1383_fail
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
    goto alt1388_end
  alt1388_1:
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  alt1388_end:
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1383_cur."!cursor_pass"(rx1383_pos, "statement_control:sym<unless>")
    if_null rx1383_debug, debug_989
    rx1383_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1383_pos)
  debug_989:
    .return (rx1383_cur)
  rx1383_restart:
.annotate 'line', 436
    if_null rx1383_debug, debug_990
    rx1383_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_990:
  rx1383_fail:
    (rx1383_rep, rx1383_pos, $I10, $P10) = rx1383_cur."!mark_fail"(0)
    lt rx1383_pos, -1, rx1383_done
    eq rx1383_pos, -1, rx1383_fail
    jump $I10
  rx1383_done:
    rx1383_cur."!cursor_fail"()
    if_null rx1383_debug, debug_991
    rx1383_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_991:
    .return (rx1383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1390"  :anon :subid("100_1306916577.75068") :method :outer("99_1306916577.75068")
.annotate 'line', 637
    .local string rx1392_tgt
    .local int rx1392_pos
    .local int rx1392_off
    .local int rx1392_eos
    .local int rx1392_rep
    .local pmc rx1392_cur
    .local pmc rx1392_debug
    (rx1392_cur, rx1392_pos, rx1392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1392_cur
    .local pmc match
    .lex "$/", match
    length rx1392_eos, rx1392_tgt
    gt rx1392_pos, rx1392_eos, rx1392_done
    set rx1392_off, 0
    lt rx1392_pos, 2, rx1392_start
    sub rx1392_off, rx1392_pos, 1
    substr rx1392_tgt, rx1392_tgt, rx1392_off
  rx1392_start:
    eq $I10, 1, rx1392_restart
    if_null rx1392_debug, debug_985
    rx1392_cur."!cursor_debug"("START", "")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1393_done
    goto rxscan1393_scan
  rxscan1393_loop:
    (rx1392_pos) = rx1392_cur."from"()
    inc rx1392_pos
    rx1392_cur."!cursor_from"(rx1392_pos)
    ge rx1392_pos, rx1392_eos, rxscan1393_done
  rxscan1393_scan:
    set_addr $I10, rxscan1393_loop
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  rxscan1393_done:
  # rx literal  "else"
    add $I11, rx1392_pos, 4
    gt $I11, rx1392_eos, rx1392_fail
    sub $I11, rx1392_pos, rx1392_off
    substr $S10, rx1392_tgt, $I11, 4
    ne $S10, "else", rx1392_fail
    add rx1392_pos, 4
  # rx pass
    rx1392_cur."!cursor_pass"(rx1392_pos, "")
    if_null rx1392_debug, debug_986
    rx1392_cur."!cursor_debug"("PASS", "", " at pos=", rx1392_pos)
  debug_986:
    .return (rx1392_cur)
  rx1392_restart:
    if_null rx1392_debug, debug_987
    rx1392_cur."!cursor_debug"("NEXT", "")
  debug_987:
  rx1392_fail:
    (rx1392_rep, rx1392_pos, $I10, $P10) = rx1392_cur."!mark_fail"(0)
    lt rx1392_pos, -1, rx1392_done
    eq rx1392_pos, -1, rx1392_fail
    jump $I10
  rx1392_done:
    rx1392_cur."!cursor_fail"()
    if_null rx1392_debug, debug_988
    rx1392_cur."!cursor_debug"("FAIL", "")
  debug_988:
    .return (rx1392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("101_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1399, "ResizablePMCArray"
    push $P1399, "unless"
    .return ($P1399)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("102_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1401_tgt
    .local int rx1401_pos
    .local int rx1401_off
    .local int rx1401_eos
    .local int rx1401_rep
    .local pmc rx1401_cur
    .local pmc rx1401_debug
    (rx1401_cur, rx1401_pos, rx1401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1401_cur
    .local pmc match
    .lex "$/", match
    length rx1401_eos, rx1401_tgt
    gt rx1401_pos, rx1401_eos, rx1401_done
    set rx1401_off, 0
    lt rx1401_pos, 2, rx1401_start
    sub rx1401_off, rx1401_pos, 1
    substr rx1401_tgt, rx1401_tgt, rx1401_off
  rx1401_start:
    eq $I10, 1, rx1401_restart
    if_null rx1401_debug, debug_992
    rx1401_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_992:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    (rx1401_pos) = rx1401_cur."from"()
    inc rx1401_pos
    rx1401_cur."!cursor_from"(rx1401_pos)
    ge rx1401_pos, rx1401_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  rxscan1402_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1404_fail
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  alt1403_0:
    set_addr $I10, alt1403_1
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  # rx literal  "while"
    add $I11, rx1401_pos, 5
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    substr $S10, rx1401_tgt, $I11, 5
    ne $S10, "while", rx1401_fail
    add rx1401_pos, 5
    goto alt1403_end
  alt1403_1:
  # rx literal  "until"
    add $I11, rx1401_pos, 5
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    substr $S10, rx1401_tgt, $I11, 5
    ne $S10, "until", rx1401_fail
    add rx1401_pos, 5
  alt1403_end:
    set_addr $I10, rxcap_1404_fail
    ($I12, $I11) = rx1401_cur."!mark_peek"($I10)
    rx1401_cur."!cursor_pos"($I11)
    ($P10) = rx1401_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1401_pos, "")
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1404_done
  rxcap_1404_fail:
    goto rx1401_fail
  rxcap_1404_done:
  # rx charclass s
    ge rx1401_pos, rx1401_eos, rx1401_fail
    sub $I10, rx1401_pos, rx1401_off
    is_cclass $I11, 32, rx1401_tgt, $I10
    unless $I11, rx1401_fail
    inc rx1401_pos
  # rx subrule "ws" subtype=method negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."ws"()
    unless $P10, rx1401_fail
    rx1401_pos = $P10."pos"()
.annotate 'line', 642
  # rx subrule "xblock" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."xblock"()
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1401_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."ws"()
    unless $P10, rx1401_fail
    rx1401_pos = $P10."pos"()
.annotate 'line', 640
  # rx pass
    rx1401_cur."!cursor_pass"(rx1401_pos, "statement_control:sym<while>")
    if_null rx1401_debug, debug_993
    rx1401_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1401_pos)
  debug_993:
    .return (rx1401_cur)
  rx1401_restart:
.annotate 'line', 436
    if_null rx1401_debug, debug_994
    rx1401_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_994:
  rx1401_fail:
    (rx1401_rep, rx1401_pos, $I10, $P10) = rx1401_cur."!mark_fail"(0)
    lt rx1401_pos, -1, rx1401_done
    eq rx1401_pos, -1, rx1401_fail
    jump $I10
  rx1401_done:
    rx1401_cur."!cursor_fail"()
    if_null rx1401_debug, debug_995
    rx1401_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_995:
    .return (rx1401_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("103_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1408, "ResizablePMCArray"
    push $P1408, "until"
    push $P1408, "while"
    .return ($P1408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("104_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1410_tgt
    .local int rx1410_pos
    .local int rx1410_off
    .local int rx1410_eos
    .local int rx1410_rep
    .local pmc rx1410_cur
    .local pmc rx1410_debug
    (rx1410_cur, rx1410_pos, rx1410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1410_cur
    .local pmc match
    .lex "$/", match
    length rx1410_eos, rx1410_tgt
    gt rx1410_pos, rx1410_eos, rx1410_done
    set rx1410_off, 0
    lt rx1410_pos, 2, rx1410_start
    sub rx1410_off, rx1410_pos, 1
    substr rx1410_tgt, rx1410_tgt, rx1410_off
  rx1410_start:
    eq $I10, 1, rx1410_restart
    if_null rx1410_debug, debug_996
    rx1410_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_996:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1411_done
    goto rxscan1411_scan
  rxscan1411_loop:
    (rx1410_pos) = rx1410_cur."from"()
    inc rx1410_pos
    rx1410_cur."!cursor_from"(rx1410_pos)
    ge rx1410_pos, rx1410_eos, rxscan1411_done
  rxscan1411_scan:
    set_addr $I10, rxscan1411_loop
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  rxscan1411_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1412_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1410_pos, 6
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 6
    ne $S10, "repeat", rx1410_fail
    add rx1410_pos, 6
    set_addr $I10, rxcap_1412_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1412_done
  rxcap_1412_fail:
    goto rx1410_fail
  rxcap_1412_done:
  # rx charclass s
    ge rx1410_pos, rx1410_eos, rx1410_fail
    sub $I10, rx1410_pos, rx1410_off
    is_cclass $I11, 32, rx1410_tgt, $I10
    unless $I11, rx1410_fail
    inc rx1410_pos
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  alt1414_0:
.annotate 'line', 647
    set_addr $I10, alt1414_1
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
.annotate 'line', 648
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1417_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  alt1416_0:
    set_addr $I10, alt1416_1
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "while"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "while", rx1410_fail
    add rx1410_pos, 5
    goto alt1416_end
  alt1416_1:
  # rx literal  "until"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "until", rx1410_fail
    add rx1410_pos, 5
  alt1416_end:
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1410_fail
  rxcap_1417_done:
  # rx charclass s
    ge rx1410_pos, rx1410_eos, rx1410_fail
    sub $I10, rx1410_pos, rx1410_off
    is_cclass $I11, 32, rx1410_tgt, $I10
    unless $I11, rx1410_fail
    inc rx1410_pos
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."xblock"()
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
    goto alt1414_end
  alt1414_1:
.annotate 'line', 649
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."pblock"()
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1423_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  alt1422_0:
    set_addr $I10, alt1422_1
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "while"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "while", rx1410_fail
    add rx1410_pos, 5
    goto alt1422_end
  alt1422_1:
  # rx literal  "until"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "until", rx1410_fail
    add rx1410_pos, 5
  alt1422_end:
    set_addr $I10, rxcap_1423_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1423_done
  rxcap_1423_fail:
    goto rx1410_fail
  rxcap_1423_done:
  # rx charclass s
    ge rx1410_pos, rx1410_eos, rx1410_fail
    sub $I10, rx1410_pos, rx1410_off
    is_cclass $I11, 32, rx1410_tgt, $I10
    unless $I11, rx1410_fail
    inc rx1410_pos
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."EXPR"()
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  alt1414_end:
.annotate 'line', 650
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
.annotate 'line', 645
  # rx pass
    rx1410_cur."!cursor_pass"(rx1410_pos, "statement_control:sym<repeat>")
    if_null rx1410_debug, debug_997
    rx1410_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1410_pos)
  debug_997:
    .return (rx1410_cur)
  rx1410_restart:
.annotate 'line', 436
    if_null rx1410_debug, debug_998
    rx1410_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_998:
  rx1410_fail:
    (rx1410_rep, rx1410_pos, $I10, $P10) = rx1410_cur."!mark_fail"(0)
    lt rx1410_pos, -1, rx1410_done
    eq rx1410_pos, -1, rx1410_fail
    jump $I10
  rx1410_done:
    rx1410_cur."!cursor_fail"()
    if_null rx1410_debug, debug_999
    rx1410_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_999:
    .return (rx1410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("105_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1428, "ResizablePMCArray"
    push $P1428, "repeat"
    .return ($P1428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("106_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1000
    rx1430_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_1000:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1431_done
    goto rxscan1431_scan
  rxscan1431_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1431_done
  rxscan1431_scan:
    set_addr $I10, rxscan1431_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1431_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1432_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx literal  "for"
    add $I11, rx1430_pos, 3
    gt $I11, rx1430_eos, rx1430_fail
    sub $I11, rx1430_pos, rx1430_off
    substr $S10, rx1430_tgt, $I11, 3
    ne $S10, "for", rx1430_fail
    add rx1430_pos, 3
    set_addr $I10, rxcap_1432_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1432_done
  rxcap_1432_fail:
    goto rx1430_fail
  rxcap_1432_done:
  # rx charclass s
    ge rx1430_pos, rx1430_eos, rx1430_fail
    sub $I10, rx1430_pos, rx1430_off
    is_cclass $I11, 32, rx1430_tgt, $I10
    unless $I11, rx1430_fail
    inc rx1430_pos
  # rx subrule "ws" subtype=method negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."ws"()
    unless $P10, rx1430_fail
    rx1430_pos = $P10."pos"()
.annotate 'line', 655
  # rx subrule "xblock" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."xblock"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1430_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."ws"()
    unless $P10, rx1430_fail
    rx1430_pos = $P10."pos"()
.annotate 'line', 653
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "statement_control:sym<for>")
    if_null rx1430_debug, debug_1001
    rx1430_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1430_pos)
  debug_1001:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 436
    if_null rx1430_debug, debug_1002
    rx1430_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_1002:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1003
    rx1430_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_1003:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("107_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1436, "ResizablePMCArray"
    push $P1436, "for"
    .return ($P1436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("108_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1438_tgt
    .local int rx1438_pos
    .local int rx1438_off
    .local int rx1438_eos
    .local int rx1438_rep
    .local pmc rx1438_cur
    .local pmc rx1438_debug
    (rx1438_cur, rx1438_pos, rx1438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1438_cur
    .local pmc match
    .lex "$/", match
    length rx1438_eos, rx1438_tgt
    gt rx1438_pos, rx1438_eos, rx1438_done
    set rx1438_off, 0
    lt rx1438_pos, 2, rx1438_start
    sub rx1438_off, rx1438_pos, 1
    substr rx1438_tgt, rx1438_tgt, rx1438_off
  rx1438_start:
    eq $I10, 1, rx1438_restart
    if_null rx1438_debug, debug_1004
    rx1438_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_1004:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1439_done
    goto rxscan1439_scan
  rxscan1439_loop:
    (rx1438_pos) = rx1438_cur."from"()
    inc rx1438_pos
    rx1438_cur."!cursor_from"(rx1438_pos)
    ge rx1438_pos, rx1438_eos, rxscan1439_done
  rxscan1439_scan:
    set_addr $I10, rxscan1439_loop
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  rxscan1439_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1440_fail
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1438_pos, 5
    gt $I11, rx1438_eos, rx1438_fail
    sub $I11, rx1438_pos, rx1438_off
    substr $S10, rx1438_tgt, $I11, 5
    ne $S10, "CATCH", rx1438_fail
    add rx1438_pos, 5
    set_addr $I10, rxcap_1440_fail
    ($I12, $I11) = rx1438_cur."!mark_peek"($I10)
    rx1438_cur."!cursor_pos"($I11)
    ($P10) = rx1438_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1438_pos, "")
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1440_done
  rxcap_1440_fail:
    goto rx1438_fail
  rxcap_1440_done:
  # rx charclass s
    ge rx1438_pos, rx1438_eos, rx1438_fail
    sub $I10, rx1438_pos, rx1438_off
    is_cclass $I11, 32, rx1438_tgt, $I10
    unless $I11, rx1438_fail
    inc rx1438_pos
  # rx subrule "ws" subtype=method negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."ws"()
    unless $P10, rx1438_fail
    rx1438_pos = $P10."pos"()
.annotate 'line', 660
  # rx subrule "block" subtype=capture negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."block"()
    unless $P10, rx1438_fail
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1438_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."ws"()
    unless $P10, rx1438_fail
    rx1438_pos = $P10."pos"()
.annotate 'line', 658
  # rx pass
    rx1438_cur."!cursor_pass"(rx1438_pos, "statement_control:sym<CATCH>")
    if_null rx1438_debug, debug_1005
    rx1438_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1438_pos)
  debug_1005:
    .return (rx1438_cur)
  rx1438_restart:
.annotate 'line', 436
    if_null rx1438_debug, debug_1006
    rx1438_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_1006:
  rx1438_fail:
    (rx1438_rep, rx1438_pos, $I10, $P10) = rx1438_cur."!mark_fail"(0)
    lt rx1438_pos, -1, rx1438_done
    eq rx1438_pos, -1, rx1438_fail
    jump $I10
  rx1438_done:
    rx1438_cur."!cursor_fail"()
    if_null rx1438_debug, debug_1007
    rx1438_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_1007:
    .return (rx1438_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("109_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1444, "ResizablePMCArray"
    push $P1444, "CATCH"
    .return ($P1444)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("110_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1446_tgt
    .local int rx1446_pos
    .local int rx1446_off
    .local int rx1446_eos
    .local int rx1446_rep
    .local pmc rx1446_cur
    .local pmc rx1446_debug
    (rx1446_cur, rx1446_pos, rx1446_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1446_cur
    .local pmc match
    .lex "$/", match
    length rx1446_eos, rx1446_tgt
    gt rx1446_pos, rx1446_eos, rx1446_done
    set rx1446_off, 0
    lt rx1446_pos, 2, rx1446_start
    sub rx1446_off, rx1446_pos, 1
    substr rx1446_tgt, rx1446_tgt, rx1446_off
  rx1446_start:
    eq $I10, 1, rx1446_restart
    if_null rx1446_debug, debug_1008
    rx1446_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_1008:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1447_done
    goto rxscan1447_scan
  rxscan1447_loop:
    (rx1446_pos) = rx1446_cur."from"()
    inc rx1446_pos
    rx1446_cur."!cursor_from"(rx1446_pos)
    ge rx1446_pos, rx1446_eos, rxscan1447_done
  rxscan1447_scan:
    set_addr $I10, rxscan1447_loop
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  rxscan1447_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1448_fail
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1446_pos, 7
    gt $I11, rx1446_eos, rx1446_fail
    sub $I11, rx1446_pos, rx1446_off
    substr $S10, rx1446_tgt, $I11, 7
    ne $S10, "CONTROL", rx1446_fail
    add rx1446_pos, 7
    set_addr $I10, rxcap_1448_fail
    ($I12, $I11) = rx1446_cur."!mark_peek"($I10)
    rx1446_cur."!cursor_pos"($I11)
    ($P10) = rx1446_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1446_pos, "")
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1448_done
  rxcap_1448_fail:
    goto rx1446_fail
  rxcap_1448_done:
  # rx charclass s
    ge rx1446_pos, rx1446_eos, rx1446_fail
    sub $I10, rx1446_pos, rx1446_off
    is_cclass $I11, 32, rx1446_tgt, $I10
    unless $I11, rx1446_fail
    inc rx1446_pos
  # rx subrule "ws" subtype=method negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."ws"()
    unless $P10, rx1446_fail
    rx1446_pos = $P10."pos"()
.annotate 'line', 665
  # rx subrule "block" subtype=capture negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."block"()
    unless $P10, rx1446_fail
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1446_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."ws"()
    unless $P10, rx1446_fail
    rx1446_pos = $P10."pos"()
.annotate 'line', 663
  # rx pass
    rx1446_cur."!cursor_pass"(rx1446_pos, "statement_control:sym<CONTROL>")
    if_null rx1446_debug, debug_1009
    rx1446_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1446_pos)
  debug_1009:
    .return (rx1446_cur)
  rx1446_restart:
.annotate 'line', 436
    if_null rx1446_debug, debug_1010
    rx1446_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_1010:
  rx1446_fail:
    (rx1446_rep, rx1446_pos, $I10, $P10) = rx1446_cur."!mark_fail"(0)
    lt rx1446_pos, -1, rx1446_done
    eq rx1446_pos, -1, rx1446_fail
    jump $I10
  rx1446_done:
    rx1446_cur."!cursor_fail"()
    if_null rx1446_debug, debug_1011
    rx1446_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_1011:
    .return (rx1446_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("111_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1452, "ResizablePMCArray"
    push $P1452, "CONTROL"
    .return ($P1452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("112_1306916577.75068")
    .param pmc param_1454
.annotate 'line', 668
    .lex "self", param_1454
    $P1455 = param_1454."!protoregex"("statement_prefix")
    .return ($P1455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("113_1306916577.75068")
    .param pmc param_1457
.annotate 'line', 668
    .lex "self", param_1457
    $P1458 = param_1457."!PREFIX__!protoregex"("statement_prefix")
    .return ($P1458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("114_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1460_tgt
    .local int rx1460_pos
    .local int rx1460_off
    .local int rx1460_eos
    .local int rx1460_rep
    .local pmc rx1460_cur
    .local pmc rx1460_debug
    (rx1460_cur, rx1460_pos, rx1460_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1460_cur
    .local pmc match
    .lex "$/", match
    length rx1460_eos, rx1460_tgt
    gt rx1460_pos, rx1460_eos, rx1460_done
    set rx1460_off, 0
    lt rx1460_pos, 2, rx1460_start
    sub rx1460_off, rx1460_pos, 1
    substr rx1460_tgt, rx1460_tgt, rx1460_off
  rx1460_start:
    eq $I10, 1, rx1460_restart
    if_null rx1460_debug, debug_1012
    rx1460_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_1012:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1461_done
    goto rxscan1461_scan
  rxscan1461_loop:
    (rx1460_pos) = rx1460_cur."from"()
    inc rx1460_pos
    rx1460_cur."!cursor_from"(rx1460_pos)
    ge rx1460_pos, rx1460_eos, rxscan1461_done
  rxscan1461_scan:
    set_addr $I10, rxscan1461_loop
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  rxscan1461_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1462_fail
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1460_pos, 4
    gt $I11, rx1460_eos, rx1460_fail
    sub $I11, rx1460_pos, rx1460_off
    substr $S10, rx1460_tgt, $I11, 4
    ne $S10, "INIT", rx1460_fail
    add rx1460_pos, 4
    set_addr $I10, rxcap_1462_fail
    ($I12, $I11) = rx1460_cur."!mark_peek"($I10)
    rx1460_cur."!cursor_pos"($I11)
    ($P10) = rx1460_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1460_pos, "")
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1462_done
  rxcap_1462_fail:
    goto rx1460_fail
  rxcap_1462_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."blorst"()
    unless $P10, rx1460_fail
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1460_pos = $P10."pos"()
  # rx pass
    rx1460_cur."!cursor_pass"(rx1460_pos, "statement_prefix:sym<INIT>")
    if_null rx1460_debug, debug_1013
    rx1460_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1460_pos)
  debug_1013:
    .return (rx1460_cur)
  rx1460_restart:
.annotate 'line', 436
    if_null rx1460_debug, debug_1014
    rx1460_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_1014:
  rx1460_fail:
    (rx1460_rep, rx1460_pos, $I10, $P10) = rx1460_cur."!mark_fail"(0)
    lt rx1460_pos, -1, rx1460_done
    eq rx1460_pos, -1, rx1460_fail
    jump $I10
  rx1460_done:
    rx1460_cur."!cursor_fail"()
    if_null rx1460_debug, debug_1015
    rx1460_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_1015:
    .return (rx1460_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("115_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1464 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P1465, "ResizablePMCArray"
    push $P1465, $P1464
    .return ($P1465)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("116_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1467_tgt
    .local int rx1467_pos
    .local int rx1467_off
    .local int rx1467_eos
    .local int rx1467_rep
    .local pmc rx1467_cur
    .local pmc rx1467_debug
    (rx1467_cur, rx1467_pos, rx1467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1467_cur
    .local pmc match
    .lex "$/", match
    length rx1467_eos, rx1467_tgt
    gt rx1467_pos, rx1467_eos, rx1467_done
    set rx1467_off, 0
    lt rx1467_pos, 2, rx1467_start
    sub rx1467_off, rx1467_pos, 1
    substr rx1467_tgt, rx1467_tgt, rx1467_off
  rx1467_start:
    eq $I10, 1, rx1467_restart
    if_null rx1467_debug, debug_1016
    rx1467_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_1016:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1468_done
    goto rxscan1468_scan
  rxscan1468_loop:
    (rx1467_pos) = rx1467_cur."from"()
    inc rx1467_pos
    rx1467_cur."!cursor_from"(rx1467_pos)
    ge rx1467_pos, rx1467_eos, rxscan1468_done
  rxscan1468_scan:
    set_addr $I10, rxscan1468_loop
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  rxscan1468_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1469_fail
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  # rx literal  "try"
    add $I11, rx1467_pos, 3
    gt $I11, rx1467_eos, rx1467_fail
    sub $I11, rx1467_pos, rx1467_off
    substr $S10, rx1467_tgt, $I11, 3
    ne $S10, "try", rx1467_fail
    add rx1467_pos, 3
    set_addr $I10, rxcap_1469_fail
    ($I12, $I11) = rx1467_cur."!mark_peek"($I10)
    rx1467_cur."!cursor_pos"($I11)
    ($P10) = rx1467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1467_pos, "")
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1469_done
  rxcap_1469_fail:
    goto rx1467_fail
  rxcap_1469_done:
.annotate 'line', 673
  # rx subrule "blorst" subtype=capture negate=
    rx1467_cur."!cursor_pos"(rx1467_pos)
    $P10 = rx1467_cur."blorst"()
    unless $P10, rx1467_fail
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1467_pos = $P10."pos"()
.annotate 'line', 671
  # rx pass
    rx1467_cur."!cursor_pass"(rx1467_pos, "statement_prefix:sym<try>")
    if_null rx1467_debug, debug_1017
    rx1467_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1467_pos)
  debug_1017:
    .return (rx1467_cur)
  rx1467_restart:
.annotate 'line', 436
    if_null rx1467_debug, debug_1018
    rx1467_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_1018:
  rx1467_fail:
    (rx1467_rep, rx1467_pos, $I10, $P10) = rx1467_cur."!mark_fail"(0)
    lt rx1467_pos, -1, rx1467_done
    eq rx1467_pos, -1, rx1467_fail
    jump $I10
  rx1467_done:
    rx1467_cur."!cursor_fail"()
    if_null rx1467_debug, debug_1019
    rx1467_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_1019:
    .return (rx1467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("117_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1471 = self."!PREFIX__!subrule"("blorst", "try")
    new $P1472, "ResizablePMCArray"
    push $P1472, $P1471
    .return ($P1472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("118_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1020
    rx1474_cur."!cursor_debug"("START", "blorst")
  debug_1020:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1475_done
    goto rxscan1475_scan
  rxscan1475_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1475_done
  rxscan1475_scan:
    set_addr $I10, rxscan1475_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1475_done:
.annotate 'line', 677
  # rx charclass s
    ge rx1474_pos, rx1474_eos, rx1474_fail
    sub $I10, rx1474_pos, rx1474_off
    is_cclass $I11, 32, rx1474_tgt, $I10
    unless $I11, rx1474_fail
    inc rx1474_pos
  # rx subrule "ws" subtype=method negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."ws"()
    unless $P10, rx1474_fail
    rx1474_pos = $P10."pos"()
  alt1476_0:
    set_addr $I10, alt1476_1
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1474_pos, rx1474_off
    substr $S10, rx1474_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1474_fail
  # rx subrule "block" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."block"()
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1474_pos = $P10."pos"()
    goto alt1476_end
  alt1476_1:
  # rx subrule "statement" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."statement"()
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1474_pos = $P10."pos"()
  alt1476_end:
.annotate 'line', 676
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "blorst")
    if_null rx1474_debug, debug_1021
    rx1474_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1474_pos)
  debug_1021:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 436
    if_null rx1474_debug, debug_1022
    rx1474_cur."!cursor_debug"("NEXT", "blorst")
  debug_1022:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1023
    rx1474_cur."!cursor_debug"("FAIL", "blorst")
  debug_1023:
    .return (rx1474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("119_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1478, "ResizablePMCArray"
    push $P1478, ""
    .return ($P1478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("120_1306916577.75068")
    .param pmc param_1480
.annotate 'line', 682
    .lex "self", param_1480
    $P1481 = param_1480."!protoregex"("statement_mod_cond")
    .return ($P1481)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("121_1306916577.75068")
    .param pmc param_1483
.annotate 'line', 682
    .lex "self", param_1483
    $P1484 = param_1483."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P1484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("122_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1024
    rx1486_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1487_done
    goto rxscan1487_scan
  rxscan1487_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1487_done
  rxscan1487_scan:
    set_addr $I10, rxscan1487_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1487_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1488_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "if"
    add $I11, rx1486_pos, 2
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    substr $S10, rx1486_tgt, $I11, 2
    ne $S10, "if", rx1486_fail
    add rx1486_pos, 2
    set_addr $I10, rxcap_1488_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1488_done
  rxcap_1488_fail:
    goto rx1486_fail
  rxcap_1488_done:
  # rx subrule "ws" subtype=method negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."ws"()
    unless $P10, rx1486_fail
    rx1486_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."EXPR"()
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1486_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."ws"()
    unless $P10, rx1486_fail
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "statement_mod_cond:sym<if>")
    if_null rx1486_debug, debug_1025
    rx1486_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1486_pos)
  debug_1025:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 436
    if_null rx1486_debug, debug_1026
    rx1486_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1026:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1027
    rx1486_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1027:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("123_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1492 = self."!PREFIX__!subrule"("ws", "if")
    new $P1493, "ResizablePMCArray"
    push $P1493, $P1492
    .return ($P1493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("124_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1495_tgt
    .local int rx1495_pos
    .local int rx1495_off
    .local int rx1495_eos
    .local int rx1495_rep
    .local pmc rx1495_cur
    .local pmc rx1495_debug
    (rx1495_cur, rx1495_pos, rx1495_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1495_cur
    .local pmc match
    .lex "$/", match
    length rx1495_eos, rx1495_tgt
    gt rx1495_pos, rx1495_eos, rx1495_done
    set rx1495_off, 0
    lt rx1495_pos, 2, rx1495_start
    sub rx1495_off, rx1495_pos, 1
    substr rx1495_tgt, rx1495_tgt, rx1495_off
  rx1495_start:
    eq $I10, 1, rx1495_restart
    if_null rx1495_debug, debug_1028
    rx1495_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1496_done
    goto rxscan1496_scan
  rxscan1496_loop:
    (rx1495_pos) = rx1495_cur."from"()
    inc rx1495_pos
    rx1495_cur."!cursor_from"(rx1495_pos)
    ge rx1495_pos, rx1495_eos, rxscan1496_done
  rxscan1496_scan:
    set_addr $I10, rxscan1496_loop
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  rxscan1496_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1497_fail
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1495_pos, 6
    gt $I11, rx1495_eos, rx1495_fail
    sub $I11, rx1495_pos, rx1495_off
    substr $S10, rx1495_tgt, $I11, 6
    ne $S10, "unless", rx1495_fail
    add rx1495_pos, 6
    set_addr $I10, rxcap_1497_fail
    ($I12, $I11) = rx1495_cur."!mark_peek"($I10)
    rx1495_cur."!cursor_pos"($I11)
    ($P10) = rx1495_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1495_pos, "")
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1497_done
  rxcap_1497_fail:
    goto rx1495_fail
  rxcap_1497_done:
  # rx subrule "ws" subtype=method negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."ws"()
    unless $P10, rx1495_fail
    rx1495_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."EXPR"()
    unless $P10, rx1495_fail
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1495_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."ws"()
    unless $P10, rx1495_fail
    rx1495_pos = $P10."pos"()
  # rx pass
    rx1495_cur."!cursor_pass"(rx1495_pos, "statement_mod_cond:sym<unless>")
    if_null rx1495_debug, debug_1029
    rx1495_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1495_pos)
  debug_1029:
    .return (rx1495_cur)
  rx1495_restart:
.annotate 'line', 436
    if_null rx1495_debug, debug_1030
    rx1495_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1030:
  rx1495_fail:
    (rx1495_rep, rx1495_pos, $I10, $P10) = rx1495_cur."!mark_fail"(0)
    lt rx1495_pos, -1, rx1495_done
    eq rx1495_pos, -1, rx1495_fail
    jump $I10
  rx1495_done:
    rx1495_cur."!cursor_fail"()
    if_null rx1495_debug, debug_1031
    rx1495_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1031:
    .return (rx1495_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("125_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1501 = self."!PREFIX__!subrule"("ws", "unless")
    new $P1502, "ResizablePMCArray"
    push $P1502, $P1501
    .return ($P1502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("126_1306916577.75068")
    .param pmc param_1504
.annotate 'line', 687
    .lex "self", param_1504
    $P1505 = param_1504."!protoregex"("statement_mod_loop")
    .return ($P1505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("127_1306916577.75068")
    .param pmc param_1507
.annotate 'line', 687
    .lex "self", param_1507
    $P1508 = param_1507."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("128_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1032
    rx1510_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1032:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1511_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  # rx literal  "while"
    add $I11, rx1510_pos, 5
    gt $I11, rx1510_eos, rx1510_fail
    sub $I11, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I11, 5
    ne $S10, "while", rx1510_fail
    add rx1510_pos, 5
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1510_cur."!mark_peek"($I10)
    rx1510_cur."!cursor_pos"($I11)
    ($P10) = rx1510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1510_pos, "")
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1510_fail
  rxcap_1512_done:
  # rx subrule "ws" subtype=method negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."ws"()
    unless $P10, rx1510_fail
    rx1510_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."EXPR"()
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1510_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."ws"()
    unless $P10, rx1510_fail
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "statement_mod_loop:sym<while>")
    if_null rx1510_debug, debug_1033
    rx1510_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1510_pos)
  debug_1033:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 436
    if_null rx1510_debug, debug_1034
    rx1510_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1034:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1035
    rx1510_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1035:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("129_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1516 = self."!PREFIX__!subrule"("ws", "while")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("130_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1036
    rx1519_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1036:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1520_done
    goto rxscan1520_scan
  rxscan1520_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1520_done
  rxscan1520_scan:
    set_addr $I10, rxscan1520_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1520_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1521_fail
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  # rx literal  "until"
    add $I11, rx1519_pos, 5
    gt $I11, rx1519_eos, rx1519_fail
    sub $I11, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I11, 5
    ne $S10, "until", rx1519_fail
    add rx1519_pos, 5
    set_addr $I10, rxcap_1521_fail
    ($I12, $I11) = rx1519_cur."!mark_peek"($I10)
    rx1519_cur."!cursor_pos"($I11)
    ($P10) = rx1519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1519_pos, "")
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1521_done
  rxcap_1521_fail:
    goto rx1519_fail
  rxcap_1521_done:
  # rx subrule "ws" subtype=method negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."ws"()
    unless $P10, rx1519_fail
    rx1519_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."EXPR"()
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1519_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."ws"()
    unless $P10, rx1519_fail
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "statement_mod_loop:sym<until>")
    if_null rx1519_debug, debug_1037
    rx1519_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1519_pos)
  debug_1037:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 436
    if_null rx1519_debug, debug_1038
    rx1519_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1038:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1039
    rx1519_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1039:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("131_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1525 = self."!PREFIX__!subrule"("ws", "until")
    new $P1526, "ResizablePMCArray"
    push $P1526, $P1525
    .return ($P1526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("132_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1040
    rx1528_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1040:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1529_done
    goto rxscan1529_scan
  rxscan1529_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1529_done
  rxscan1529_scan:
    set_addr $I10, rxscan1529_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1529_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1530_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "for"
    add $I11, rx1528_pos, 3
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 3
    ne $S10, "for", rx1528_fail
    add rx1528_pos, 3
    set_addr $I10, rxcap_1530_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1530_done
  rxcap_1530_fail:
    goto rx1528_fail
  rxcap_1530_done:
  # rx subrule "ws" subtype=method negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."ws"()
    unless $P10, rx1528_fail
    rx1528_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."EXPR"()
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1528_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."ws"()
    unless $P10, rx1528_fail
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "statement_mod_loop:sym<for>")
    if_null rx1528_debug, debug_1041
    rx1528_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1528_pos)
  debug_1041:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 436
    if_null rx1528_debug, debug_1042
    rx1528_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1042:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1043
    rx1528_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1043:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("133_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1534 = self."!PREFIX__!subrule"("ws", "for")
    new $P1535, "ResizablePMCArray"
    push $P1535, $P1534
    .return ($P1535)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("134_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1044
    rx1537_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1044:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1538_done:
.annotate 'line', 695
  # rx subrule "fatarrow" subtype=capture negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."fatarrow"()
    unless $P10, rx1537_fail
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1537_pos = $P10."pos"()
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "term:sym<fatarrow>")
    if_null rx1537_debug, debug_1045
    rx1537_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1537_pos)
  debug_1045:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 436
    if_null rx1537_debug, debug_1046
    rx1537_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1046:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1047
    rx1537_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1047:
    .return (rx1537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("135_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1540 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P1541, "ResizablePMCArray"
    push $P1541, $P1540
    .return ($P1541)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("136_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1048
    rx1543_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1048:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1544_done:
.annotate 'line', 696
  # rx subrule "colonpair" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."colonpair"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "term:sym<colonpair>")
    if_null rx1543_debug, debug_1049
    rx1543_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1543_pos)
  debug_1049:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 436
    if_null rx1543_debug, debug_1050
    rx1543_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1050:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1051
    rx1543_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1051:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("137_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1546 = self."!PREFIX__!subrule"("colonpair", "")
    new $P1547, "ResizablePMCArray"
    push $P1547, $P1546
    .return ($P1547)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("138_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1052
    rx1549_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1052:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1550_done
    goto rxscan1550_scan
  rxscan1550_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1550_done
  rxscan1550_scan:
    set_addr $I10, rxscan1550_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1550_done:
.annotate 'line', 697
  # rx subrule "variable" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."variable"()
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "term:sym<variable>")
    if_null rx1549_debug, debug_1053
    rx1549_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1549_pos)
  debug_1053:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 436
    if_null rx1549_debug, debug_1054
    rx1549_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1054:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1055
    rx1549_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1055:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("139_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1552 = self."!PREFIX__!subrule"("variable", "")
    new $P1553, "ResizablePMCArray"
    push $P1553, $P1552
    .return ($P1553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("140_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1555_tgt
    .local int rx1555_pos
    .local int rx1555_off
    .local int rx1555_eos
    .local int rx1555_rep
    .local pmc rx1555_cur
    .local pmc rx1555_debug
    (rx1555_cur, rx1555_pos, rx1555_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1555_cur
    .local pmc match
    .lex "$/", match
    length rx1555_eos, rx1555_tgt
    gt rx1555_pos, rx1555_eos, rx1555_done
    set rx1555_off, 0
    lt rx1555_pos, 2, rx1555_start
    sub rx1555_off, rx1555_pos, 1
    substr rx1555_tgt, rx1555_tgt, rx1555_off
  rx1555_start:
    eq $I10, 1, rx1555_restart
    if_null rx1555_debug, debug_1056
    rx1555_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1056:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1556_done
    goto rxscan1556_scan
  rxscan1556_loop:
    (rx1555_pos) = rx1555_cur."from"()
    inc rx1555_pos
    rx1555_cur."!cursor_from"(rx1555_pos)
    ge rx1555_pos, rx1555_eos, rxscan1556_done
  rxscan1556_scan:
    set_addr $I10, rxscan1556_loop
    rx1555_cur."!mark_push"(0, rx1555_pos, $I10)
  rxscan1556_done:
.annotate 'line', 698
  # rx subrule "package_declarator" subtype=capture negate=
    rx1555_cur."!cursor_pos"(rx1555_pos)
    $P10 = rx1555_cur."package_declarator"()
    unless $P10, rx1555_fail
    rx1555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1555_pos = $P10."pos"()
  # rx pass
    rx1555_cur."!cursor_pass"(rx1555_pos, "term:sym<package_declarator>")
    if_null rx1555_debug, debug_1057
    rx1555_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1555_pos)
  debug_1057:
    .return (rx1555_cur)
  rx1555_restart:
.annotate 'line', 436
    if_null rx1555_debug, debug_1058
    rx1555_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1058:
  rx1555_fail:
    (rx1555_rep, rx1555_pos, $I10, $P10) = rx1555_cur."!mark_fail"(0)
    lt rx1555_pos, -1, rx1555_done
    eq rx1555_pos, -1, rx1555_fail
    jump $I10
  rx1555_done:
    rx1555_cur."!cursor_fail"()
    if_null rx1555_debug, debug_1059
    rx1555_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1059:
    .return (rx1555_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("141_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1558 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("142_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1060
    rx1561_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1060:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1562_done:
.annotate 'line', 699
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."scope_declarator"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1561_pos = $P10."pos"()
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "term:sym<scope_declarator>")
    if_null rx1561_debug, debug_1061
    rx1561_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1561_pos)
  debug_1061:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 436
    if_null rx1561_debug, debug_1062
    rx1561_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1062:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1063
    rx1561_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1063:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("143_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1564 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P1565, "ResizablePMCArray"
    push $P1565, $P1564
    .return ($P1565)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("144_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1567_tgt
    .local int rx1567_pos
    .local int rx1567_off
    .local int rx1567_eos
    .local int rx1567_rep
    .local pmc rx1567_cur
    .local pmc rx1567_debug
    (rx1567_cur, rx1567_pos, rx1567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1567_cur
    .local pmc match
    .lex "$/", match
    length rx1567_eos, rx1567_tgt
    gt rx1567_pos, rx1567_eos, rx1567_done
    set rx1567_off, 0
    lt rx1567_pos, 2, rx1567_start
    sub rx1567_off, rx1567_pos, 1
    substr rx1567_tgt, rx1567_tgt, rx1567_off
  rx1567_start:
    eq $I10, 1, rx1567_restart
    if_null rx1567_debug, debug_1064
    rx1567_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1064:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1567_pos) = rx1567_cur."from"()
    inc rx1567_pos
    rx1567_cur."!cursor_from"(rx1567_pos)
    ge rx1567_pos, rx1567_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  rxscan1568_done:
.annotate 'line', 700
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."routine_declarator"()
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1567_pos = $P10."pos"()
  # rx pass
    rx1567_cur."!cursor_pass"(rx1567_pos, "term:sym<routine_declarator>")
    if_null rx1567_debug, debug_1065
    rx1567_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1567_pos)
  debug_1065:
    .return (rx1567_cur)
  rx1567_restart:
.annotate 'line', 436
    if_null rx1567_debug, debug_1066
    rx1567_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1066:
  rx1567_fail:
    (rx1567_rep, rx1567_pos, $I10, $P10) = rx1567_cur."!mark_fail"(0)
    lt rx1567_pos, -1, rx1567_done
    eq rx1567_pos, -1, rx1567_fail
    jump $I10
  rx1567_done:
    rx1567_cur."!cursor_fail"()
    if_null rx1567_debug, debug_1067
    rx1567_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1067:
    .return (rx1567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("145_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1570 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P1571, "ResizablePMCArray"
    push $P1571, $P1570
    .return ($P1571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("146_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P1581 = "148_1306916577.75068" 
    capture_lex $P1581
    .const 'Sub' $P1576 = "147_1306916577.75068" 
    capture_lex $P1576
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1068
    rx1573_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1068:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1574_done:
.annotate 'line', 702
  # rx subrule "before" subtype=zerowidth negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    .const 'Sub' $P1576 = "147_1306916577.75068" 
    capture_lex $P1576
    $P10 = rx1573_cur."before"($P1576)
    unless $P10, rx1573_fail
.annotate 'line', 703
  # rx subrule "before" subtype=zerowidth negate=1
    rx1573_cur."!cursor_pos"(rx1573_pos)
    .const 'Sub' $P1581 = "148_1306916577.75068" 
    capture_lex $P1581
    $P10 = rx1573_cur."before"($P1581)
    if $P10, rx1573_fail
.annotate 'line', 704
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."multi_declarator"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1573_pos = $P10."pos"()
.annotate 'line', 701
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "term:sym<multi_declarator>")
    if_null rx1573_debug, debug_1077
    rx1573_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1573_pos)
  debug_1077:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 436
    if_null rx1573_debug, debug_1078
    rx1573_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1078:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1079
    rx1573_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1079:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1575"  :anon :subid("147_1306916577.75068") :method :outer("146_1306916577.75068")
.annotate 'line', 702
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1069
    rx1577_cur."!cursor_debug"("START", "")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1578_done
    goto rxscan1578_scan
  rxscan1578_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1578_done
  rxscan1578_scan:
    set_addr $I10, rxscan1578_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1578_done:
  alt1579_0:
    set_addr $I10, alt1579_1
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1577_pos, 5
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 5
    ne $S10, "multi", rx1577_fail
    add rx1577_pos, 5
    goto alt1579_end
  alt1579_1:
    set_addr $I10, alt1579_2
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1577_pos, 5
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 5
    ne $S10, "proto", rx1577_fail
    add rx1577_pos, 5
    goto alt1579_end
  alt1579_2:
  # rx literal  "only"
    add $I11, rx1577_pos, 4
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 4
    ne $S10, "only", rx1577_fail
    add rx1577_pos, 4
  alt1579_end:
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "")
    if_null rx1577_debug, debug_1070
    rx1577_cur."!cursor_debug"("PASS", "", " at pos=", rx1577_pos)
  debug_1070:
    .return (rx1577_cur)
  rx1577_restart:
    if_null rx1577_debug, debug_1071
    rx1577_cur."!cursor_debug"("NEXT", "")
  debug_1071:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1072
    rx1577_cur."!cursor_debug"("FAIL", "")
  debug_1072:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1580"  :anon :subid("148_1306916577.75068") :method :outer("146_1306916577.75068")
.annotate 'line', 703
    .local string rx1582_tgt
    .local int rx1582_pos
    .local int rx1582_off
    .local int rx1582_eos
    .local int rx1582_rep
    .local pmc rx1582_cur
    .local pmc rx1582_debug
    (rx1582_cur, rx1582_pos, rx1582_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1582_cur
    .local pmc match
    .lex "$/", match
    length rx1582_eos, rx1582_tgt
    gt rx1582_pos, rx1582_eos, rx1582_done
    set rx1582_off, 0
    lt rx1582_pos, 2, rx1582_start
    sub rx1582_off, rx1582_pos, 1
    substr rx1582_tgt, rx1582_tgt, rx1582_off
  rx1582_start:
    eq $I10, 1, rx1582_restart
    if_null rx1582_debug, debug_1073
    rx1582_cur."!cursor_debug"("START", "")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1583_done
    goto rxscan1583_scan
  rxscan1583_loop:
    (rx1582_pos) = rx1582_cur."from"()
    inc rx1582_pos
    rx1582_cur."!cursor_from"(rx1582_pos)
    ge rx1582_pos, rx1582_eos, rxscan1583_done
  rxscan1583_scan:
    set_addr $I10, rxscan1583_loop
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  rxscan1583_done:
  # rx literal  "proto"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "proto", rx1582_fail
    add rx1582_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1582_cur."!cursor_pos"(rx1582_pos)
    $P10 = rx1582_cur."ws"()
    unless $P10, rx1582_fail
    rx1582_pos = $P10."pos"()
  alt1584_0:
    set_addr $I10, alt1584_1
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "regex", rx1582_fail
    add rx1582_pos, 5
    goto alt1584_end
  alt1584_1:
    set_addr $I10, alt1584_2
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  # rx literal  "token"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "token", rx1582_fail
    add rx1582_pos, 5
    goto alt1584_end
  alt1584_2:
  # rx literal  "rule"
    add $I11, rx1582_pos, 4
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 4
    ne $S10, "rule", rx1582_fail
    add rx1582_pos, 4
  alt1584_end:
  # rx pass
    rx1582_cur."!cursor_pass"(rx1582_pos, "")
    if_null rx1582_debug, debug_1074
    rx1582_cur."!cursor_debug"("PASS", "", " at pos=", rx1582_pos)
  debug_1074:
    .return (rx1582_cur)
  rx1582_restart:
    if_null rx1582_debug, debug_1075
    rx1582_cur."!cursor_debug"("NEXT", "")
  debug_1075:
  rx1582_fail:
    (rx1582_rep, rx1582_pos, $I10, $P10) = rx1582_cur."!mark_fail"(0)
    lt rx1582_pos, -1, rx1582_done
    eq rx1582_pos, -1, rx1582_fail
    jump $I10
  rx1582_done:
    rx1582_cur."!cursor_fail"()
    if_null rx1582_debug, debug_1076
    rx1582_cur."!cursor_debug"("FAIL", "")
  debug_1076:
    .return (rx1582_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("149_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1586, "ResizablePMCArray"
    push $P1586, ""
    .return ($P1586)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("150_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1588_tgt
    .local int rx1588_pos
    .local int rx1588_off
    .local int rx1588_eos
    .local int rx1588_rep
    .local pmc rx1588_cur
    .local pmc rx1588_debug
    (rx1588_cur, rx1588_pos, rx1588_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1588_cur
    .local pmc match
    .lex "$/", match
    length rx1588_eos, rx1588_tgt
    gt rx1588_pos, rx1588_eos, rx1588_done
    set rx1588_off, 0
    lt rx1588_pos, 2, rx1588_start
    sub rx1588_off, rx1588_pos, 1
    substr rx1588_tgt, rx1588_tgt, rx1588_off
  rx1588_start:
    eq $I10, 1, rx1588_restart
    if_null rx1588_debug, debug_1080
    rx1588_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1080:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1589_done
    goto rxscan1589_scan
  rxscan1589_loop:
    (rx1588_pos) = rx1588_cur."from"()
    inc rx1588_pos
    rx1588_cur."!cursor_from"(rx1588_pos)
    ge rx1588_pos, rx1588_eos, rxscan1589_done
  rxscan1589_scan:
    set_addr $I10, rxscan1589_loop
    rx1588_cur."!mark_push"(0, rx1588_pos, $I10)
  rxscan1589_done:
.annotate 'line', 706
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1588_cur."!cursor_pos"(rx1588_pos)
    $P10 = rx1588_cur."regex_declarator"()
    unless $P10, rx1588_fail
    rx1588_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1588_pos = $P10."pos"()
  # rx pass
    rx1588_cur."!cursor_pass"(rx1588_pos, "term:sym<regex_declarator>")
    if_null rx1588_debug, debug_1081
    rx1588_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1588_pos)
  debug_1081:
    .return (rx1588_cur)
  rx1588_restart:
.annotate 'line', 436
    if_null rx1588_debug, debug_1082
    rx1588_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1082:
  rx1588_fail:
    (rx1588_rep, rx1588_pos, $I10, $P10) = rx1588_cur."!mark_fail"(0)
    lt rx1588_pos, -1, rx1588_done
    eq rx1588_pos, -1, rx1588_fail
    jump $I10
  rx1588_done:
    rx1588_cur."!cursor_fail"()
    if_null rx1588_debug, debug_1083
    rx1588_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1083:
    .return (rx1588_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("151_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1591 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P1592, "ResizablePMCArray"
    push $P1592, $P1591
    .return ($P1592)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("152_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1594_tgt
    .local int rx1594_pos
    .local int rx1594_off
    .local int rx1594_eos
    .local int rx1594_rep
    .local pmc rx1594_cur
    .local pmc rx1594_debug
    (rx1594_cur, rx1594_pos, rx1594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1594_cur
    .local pmc match
    .lex "$/", match
    length rx1594_eos, rx1594_tgt
    gt rx1594_pos, rx1594_eos, rx1594_done
    set rx1594_off, 0
    lt rx1594_pos, 2, rx1594_start
    sub rx1594_off, rx1594_pos, 1
    substr rx1594_tgt, rx1594_tgt, rx1594_off
  rx1594_start:
    eq $I10, 1, rx1594_restart
    if_null rx1594_debug, debug_1084
    rx1594_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1084:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1594_pos) = rx1594_cur."from"()
    inc rx1594_pos
    rx1594_cur."!cursor_from"(rx1594_pos)
    ge rx1594_pos, rx1594_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1594_cur."!mark_push"(0, rx1594_pos, $I10)
  rxscan1595_done:
.annotate 'line', 707
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1594_cur."!cursor_pos"(rx1594_pos)
    $P10 = rx1594_cur."statement_prefix"()
    unless $P10, rx1594_fail
    rx1594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1594_pos = $P10."pos"()
  # rx pass
    rx1594_cur."!cursor_pass"(rx1594_pos, "term:sym<statement_prefix>")
    if_null rx1594_debug, debug_1085
    rx1594_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1594_pos)
  debug_1085:
    .return (rx1594_cur)
  rx1594_restart:
.annotate 'line', 436
    if_null rx1594_debug, debug_1086
    rx1594_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1086:
  rx1594_fail:
    (rx1594_rep, rx1594_pos, $I10, $P10) = rx1594_cur."!mark_fail"(0)
    lt rx1594_pos, -1, rx1594_done
    eq rx1594_pos, -1, rx1594_fail
    jump $I10
  rx1594_done:
    rx1594_cur."!cursor_fail"()
    if_null rx1594_debug, debug_1087
    rx1594_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1087:
    .return (rx1594_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("153_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1597 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P1598, "ResizablePMCArray"
    push $P1598, $P1597
    .return ($P1598)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("154_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1600_tgt
    .local int rx1600_pos
    .local int rx1600_off
    .local int rx1600_eos
    .local int rx1600_rep
    .local pmc rx1600_cur
    .local pmc rx1600_debug
    (rx1600_cur, rx1600_pos, rx1600_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1600_cur
    .local pmc match
    .lex "$/", match
    length rx1600_eos, rx1600_tgt
    gt rx1600_pos, rx1600_eos, rx1600_done
    set rx1600_off, 0
    lt rx1600_pos, 2, rx1600_start
    sub rx1600_off, rx1600_pos, 1
    substr rx1600_tgt, rx1600_tgt, rx1600_off
  rx1600_start:
    eq $I10, 1, rx1600_restart
    if_null rx1600_debug, debug_1088
    rx1600_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1088:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1600_pos) = rx1600_cur."from"()
    inc rx1600_pos
    rx1600_cur."!cursor_from"(rx1600_pos)
    ge rx1600_pos, rx1600_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  rxscan1601_done:
.annotate 'line', 708
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1600_cur."!cursor_pos"(rx1600_pos)
    $P10 = rx1600_cur."lambda"()
    unless $P10, rx1600_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1600_cur."!cursor_pos"(rx1600_pos)
    $P10 = rx1600_cur."pblock"()
    unless $P10, rx1600_fail
    rx1600_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1600_pos = $P10."pos"()
  # rx pass
    rx1600_cur."!cursor_pass"(rx1600_pos, "term:sym<lambda>")
    if_null rx1600_debug, debug_1089
    rx1600_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1600_pos)
  debug_1089:
    .return (rx1600_cur)
  rx1600_restart:
.annotate 'line', 436
    if_null rx1600_debug, debug_1090
    rx1600_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1090:
  rx1600_fail:
    (rx1600_rep, rx1600_pos, $I10, $P10) = rx1600_cur."!mark_fail"(0)
    lt rx1600_pos, -1, rx1600_done
    eq rx1600_pos, -1, rx1600_fail
    jump $I10
  rx1600_done:
    rx1600_cur."!cursor_fail"()
    if_null rx1600_debug, debug_1091
    rx1600_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1091:
    .return (rx1600_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("155_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1603, "ResizablePMCArray"
    push $P1603, ""
    .return ($P1603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("156_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1605_tgt
    .local int rx1605_pos
    .local int rx1605_off
    .local int rx1605_eos
    .local int rx1605_rep
    .local pmc rx1605_cur
    .local pmc rx1605_debug
    (rx1605_cur, rx1605_pos, rx1605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1605_cur
    .local pmc match
    .lex "$/", match
    length rx1605_eos, rx1605_tgt
    gt rx1605_pos, rx1605_eos, rx1605_done
    set rx1605_off, 0
    lt rx1605_pos, 2, rx1605_start
    sub rx1605_off, rx1605_pos, 1
    substr rx1605_tgt, rx1605_tgt, rx1605_off
  rx1605_start:
    eq $I10, 1, rx1605_restart
    if_null rx1605_debug, debug_1092
    rx1605_cur."!cursor_debug"("START", "fatarrow")
  debug_1092:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1606_done
    goto rxscan1606_scan
  rxscan1606_loop:
    (rx1605_pos) = rx1605_cur."from"()
    inc rx1605_pos
    rx1605_cur."!cursor_from"(rx1605_pos)
    ge rx1605_pos, rx1605_eos, rxscan1606_done
  rxscan1606_scan:
    set_addr $I10, rxscan1606_loop
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  rxscan1606_done:
.annotate 'line', 711
  # rx subrule "identifier" subtype=capture negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."identifier"()
    unless $P10, rx1605_fail
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1605_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1605_pos, rx1605_off
    set rx1605_rep, 0
    sub $I12, rx1605_eos, rx1605_pos
  rxenumcharlistq1607_loop:
    le $I12, 0, rxenumcharlistq1607_done
    substr $S10, rx1605_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1607_done
    inc rx1605_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1607_loop
  rxenumcharlistq1607_done:
    add rx1605_pos, rx1605_pos, rx1605_rep
  # rx literal  "=>"
    add $I11, rx1605_pos, 2
    gt $I11, rx1605_eos, rx1605_fail
    sub $I11, rx1605_pos, rx1605_off
    substr $S10, rx1605_tgt, $I11, 2
    ne $S10, "=>", rx1605_fail
    add rx1605_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."ws"()
    unless $P10, rx1605_fail
    rx1605_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."EXPR"("i=")
    unless $P10, rx1605_fail
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1605_pos = $P10."pos"()
.annotate 'line', 710
  # rx pass
    rx1605_cur."!cursor_pass"(rx1605_pos, "fatarrow")
    if_null rx1605_debug, debug_1093
    rx1605_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1605_pos)
  debug_1093:
    .return (rx1605_cur)
  rx1605_restart:
.annotate 'line', 436
    if_null rx1605_debug, debug_1094
    rx1605_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1094:
  rx1605_fail:
    (rx1605_rep, rx1605_pos, $I10, $P10) = rx1605_cur."!mark_fail"(0)
    lt rx1605_pos, -1, rx1605_done
    eq rx1605_pos, -1, rx1605_fail
    jump $I10
  rx1605_done:
    rx1605_cur."!cursor_fail"()
    if_null rx1605_debug, debug_1095
    rx1605_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1095:
    .return (rx1605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("157_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1609 = self."!PREFIX__!subrule"("identifier", "")
    new $P1610, "ResizablePMCArray"
    push $P1610, $P1609
    .return ($P1610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("158_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1612_tgt
    .local int rx1612_pos
    .local int rx1612_off
    .local int rx1612_eos
    .local int rx1612_rep
    .local pmc rx1612_cur
    .local pmc rx1612_debug
    (rx1612_cur, rx1612_pos, rx1612_tgt, $I10) = self."!cursor_start"()
    rx1612_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1612_cur
    .local pmc match
    .lex "$/", match
    length rx1612_eos, rx1612_tgt
    gt rx1612_pos, rx1612_eos, rx1612_done
    set rx1612_off, 0
    lt rx1612_pos, 2, rx1612_start
    sub rx1612_off, rx1612_pos, 1
    substr rx1612_tgt, rx1612_tgt, rx1612_off
  rx1612_start:
    eq $I10, 1, rx1612_restart
    if_null rx1612_debug, debug_1096
    rx1612_cur."!cursor_debug"("START", "colonpair")
  debug_1096:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1612_pos) = rx1612_cur."from"()
    inc rx1612_pos
    rx1612_cur."!cursor_from"(rx1612_pos)
    ge rx1612_pos, rx1612_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxscan1613_done:
.annotate 'line', 715
  # rx literal  ":"
    add $I11, rx1612_pos, 1
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    ord $I11, rx1612_tgt, $I11
    ne $I11, 58, rx1612_fail
    add rx1612_pos, 1
  alt1614_0:
.annotate 'line', 716
    set_addr $I10, alt1614_1
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
.annotate 'line', 717
  # rx subcapture "not"
    set_addr $I10, rxcap_1615_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx literal  "!"
    add $I11, rx1612_pos, 1
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    ord $I11, rx1612_tgt, $I11
    ne $I11, 33, rx1612_fail
    add rx1612_pos, 1
    set_addr $I10, rxcap_1615_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1615_done
  rxcap_1615_fail:
    goto rx1612_fail
  rxcap_1615_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."identifier"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1612_pos = $P10."pos"()
    goto alt1614_end
  alt1614_1:
    set_addr $I10, alt1614_2
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
.annotate 'line', 718
  # rx subrule "identifier" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."identifier"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1612_pos = $P10."pos"()
  # rx rxquantr1616 ** 0..1
    set_addr $I10, rxquantr1616_done
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxquantr1616_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."circumfix"()
    unless $P10, rx1612_fail
    goto rxsubrule1617_pass
  rxsubrule1617_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1612_fail
  rxsubrule1617_pass:
    set_addr $I10, rxsubrule1617_back
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1612_pos = $P10."pos"()
    set_addr $I10, rxquantr1616_done
    (rx1612_rep) = rx1612_cur."!mark_commit"($I10)
  rxquantr1616_done:
    goto alt1614_end
  alt1614_2:
.annotate 'line', 719
  # rx subrule "circumfix" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."circumfix"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1612_pos = $P10."pos"()
  alt1614_end:
.annotate 'line', 714
  # rx pass
    rx1612_cur."!cursor_pass"(rx1612_pos, "colonpair")
    if_null rx1612_debug, debug_1097
    rx1612_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1612_pos)
  debug_1097:
    .return (rx1612_cur)
  rx1612_restart:
.annotate 'line', 436
    if_null rx1612_debug, debug_1098
    rx1612_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1098:
  rx1612_fail:
    (rx1612_rep, rx1612_pos, $I10, $P10) = rx1612_cur."!mark_fail"(0)
    lt rx1612_pos, -1, rx1612_done
    eq rx1612_pos, -1, rx1612_fail
    jump $I10
  rx1612_done:
    rx1612_cur."!cursor_fail"()
    if_null rx1612_debug, debug_1099
    rx1612_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1099:
    .return (rx1612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("159_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1619 = self."!PREFIX__!subrule"("circumfix", ":")
    $P1620 = self."!PREFIX__!subrule"("identifier", ":")
    $P1621 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P1622, "ResizablePMCArray"
    push $P1622, $P1619
    push $P1622, $P1620
    push $P1622, $P1621
    .return ($P1622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("160_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    rx1624_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1100
    rx1624_cur."!cursor_debug"("START", "variable")
  debug_1100:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1625_done
    goto rxscan1625_scan
  rxscan1625_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1625_done
  rxscan1625_scan:
    set_addr $I10, rxscan1625_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1625_done:
  alt1626_0:
.annotate 'line', 723
    set_addr $I10, alt1626_1
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
.annotate 'line', 724
  # rx subrule "sigil" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."sigil"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1624_pos = $P10."pos"()
  # rx rxquantr1627 ** 0..1
    set_addr $I10, rxquantr1627_done
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxquantr1627_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."twigil"()
    unless $P10, rx1624_fail
    goto rxsubrule1628_pass
  rxsubrule1628_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1624_fail
  rxsubrule1628_pass:
    set_addr $I10, rxsubrule1628_back
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1624_pos = $P10."pos"()
    set_addr $I10, rxquantr1627_done
    (rx1624_rep) = rx1624_cur."!mark_commit"($I10)
  rxquantr1627_done:
  # rx subrule "name" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."name"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1624_pos = $P10."pos"()
    goto alt1626_end
  alt1626_1:
    set_addr $I10, alt1626_2
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
.annotate 'line', 725
  # rx subrule "sigil" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."sigil"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1624_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1624_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."postcircumfix"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1624_pos = $P10."pos"()
    goto alt1626_end
  alt1626_2:
.annotate 'line', 726
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1629_fail
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  # rx literal  "$"
    add $I11, rx1624_pos, 1
    gt $I11, rx1624_eos, rx1624_fail
    sub $I11, rx1624_pos, rx1624_off
    ord $I11, rx1624_tgt, $I11
    ne $I11, 36, rx1624_fail
    add rx1624_pos, 1
    set_addr $I10, rxcap_1629_fail
    ($I12, $I11) = rx1624_cur."!mark_peek"($I10)
    rx1624_cur."!cursor_pos"($I11)
    ($P10) = rx1624_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1624_pos, "")
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1629_done
  rxcap_1629_fail:
    goto rx1624_fail
  rxcap_1629_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1630_fail
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1624_pos, rx1624_eos, rx1624_fail
    sub $I10, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1624_fail
    inc rx1624_pos
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1624_cur."!mark_peek"($I10)
    rx1624_cur."!cursor_pos"($I11)
    ($P10) = rx1624_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1624_pos, "")
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1624_fail
  rxcap_1630_done:
  alt1626_end:
.annotate 'line', 723
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "variable")
    if_null rx1624_debug, debug_1101
    rx1624_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1624_pos)
  debug_1101:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 436
    if_null rx1624_debug, debug_1102
    rx1624_cur."!cursor_debug"("NEXT", "variable")
  debug_1102:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1103
    rx1624_cur."!cursor_debug"("FAIL", "variable")
  debug_1103:
    .return (rx1624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("161_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1632 = self."!PREFIX__!subrule"("sigil", "")
    $P1633 = self."!PREFIX__!subrule"("sigil", "")
    new $P1634, "ResizablePMCArray"
    push $P1634, "/"
    push $P1634, "_"
    push $P1634, "!"
    push $P1634, $P1632
    push $P1634, $P1633
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("162_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1636_tgt
    .local int rx1636_pos
    .local int rx1636_off
    .local int rx1636_eos
    .local int rx1636_rep
    .local pmc rx1636_cur
    .local pmc rx1636_debug
    (rx1636_cur, rx1636_pos, rx1636_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1636_cur
    .local pmc match
    .lex "$/", match
    length rx1636_eos, rx1636_tgt
    gt rx1636_pos, rx1636_eos, rx1636_done
    set rx1636_off, 0
    lt rx1636_pos, 2, rx1636_start
    sub rx1636_off, rx1636_pos, 1
    substr rx1636_tgt, rx1636_tgt, rx1636_off
  rx1636_start:
    eq $I10, 1, rx1636_restart
    if_null rx1636_debug, debug_1104
    rx1636_cur."!cursor_debug"("START", "sigil")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1637_done
    goto rxscan1637_scan
  rxscan1637_loop:
    (rx1636_pos) = rx1636_cur."from"()
    inc rx1636_pos
    rx1636_cur."!cursor_from"(rx1636_pos)
    ge rx1636_pos, rx1636_eos, rxscan1637_done
  rxscan1637_scan:
    set_addr $I10, rxscan1637_loop
    rx1636_cur."!mark_push"(0, rx1636_pos, $I10)
  rxscan1637_done:
.annotate 'line', 729
  # rx enumcharlist negate=0 
    ge rx1636_pos, rx1636_eos, rx1636_fail
    sub $I10, rx1636_pos, rx1636_off
    substr $S10, rx1636_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1636_fail
    inc rx1636_pos
  # rx pass
    rx1636_cur."!cursor_pass"(rx1636_pos, "sigil")
    if_null rx1636_debug, debug_1105
    rx1636_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1636_pos)
  debug_1105:
    .return (rx1636_cur)
  rx1636_restart:
.annotate 'line', 436
    if_null rx1636_debug, debug_1106
    rx1636_cur."!cursor_debug"("NEXT", "sigil")
  debug_1106:
  rx1636_fail:
    (rx1636_rep, rx1636_pos, $I10, $P10) = rx1636_cur."!mark_fail"(0)
    lt rx1636_pos, -1, rx1636_done
    eq rx1636_pos, -1, rx1636_fail
    jump $I10
  rx1636_done:
    rx1636_cur."!cursor_fail"()
    if_null rx1636_debug, debug_1107
    rx1636_cur."!cursor_debug"("FAIL", "sigil")
  debug_1107:
    .return (rx1636_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("163_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1639, "ResizablePMCArray"
    push $P1639, "$"
    push $P1639, "@"
    push $P1639, "%"
    push $P1639, "&"
    .return ($P1639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("164_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1641_tgt
    .local int rx1641_pos
    .local int rx1641_off
    .local int rx1641_eos
    .local int rx1641_rep
    .local pmc rx1641_cur
    .local pmc rx1641_debug
    (rx1641_cur, rx1641_pos, rx1641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1641_cur
    .local pmc match
    .lex "$/", match
    length rx1641_eos, rx1641_tgt
    gt rx1641_pos, rx1641_eos, rx1641_done
    set rx1641_off, 0
    lt rx1641_pos, 2, rx1641_start
    sub rx1641_off, rx1641_pos, 1
    substr rx1641_tgt, rx1641_tgt, rx1641_off
  rx1641_start:
    eq $I10, 1, rx1641_restart
    if_null rx1641_debug, debug_1108
    rx1641_cur."!cursor_debug"("START", "twigil")
  debug_1108:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1641_pos) = rx1641_cur."from"()
    inc rx1641_pos
    rx1641_cur."!cursor_from"(rx1641_pos)
    ge rx1641_pos, rx1641_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  rxscan1642_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 
    ge rx1641_pos, rx1641_eos, rx1641_fail
    sub $I10, rx1641_pos, rx1641_off
    substr $S10, rx1641_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1641_fail
    inc rx1641_pos
  # rx pass
    rx1641_cur."!cursor_pass"(rx1641_pos, "twigil")
    if_null rx1641_debug, debug_1109
    rx1641_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1641_pos)
  debug_1109:
    .return (rx1641_cur)
  rx1641_restart:
.annotate 'line', 436
    if_null rx1641_debug, debug_1110
    rx1641_cur."!cursor_debug"("NEXT", "twigil")
  debug_1110:
  rx1641_fail:
    (rx1641_rep, rx1641_pos, $I10, $P10) = rx1641_cur."!mark_fail"(0)
    lt rx1641_pos, -1, rx1641_done
    eq rx1641_pos, -1, rx1641_fail
    jump $I10
  rx1641_done:
    rx1641_cur."!cursor_fail"()
    if_null rx1641_debug, debug_1111
    rx1641_cur."!cursor_debug"("FAIL", "twigil")
  debug_1111:
    .return (rx1641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("165_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P1644, "ResizablePMCArray"
    push $P1644, "*"
    push $P1644, "!"
    push $P1644, "?"
    .return ($P1644)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("166_1306916577.75068")
    .param pmc param_1646
.annotate 'line', 733
    .lex "self", param_1646
    $P1647 = param_1646."!protoregex"("package_declarator")
    .return ($P1647)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("167_1306916577.75068")
    .param pmc param_1649
.annotate 'line', 733
    .lex "self", param_1649
    $P1650 = param_1649."!PREFIX__!protoregex"("package_declarator")
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("168_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 735
    new $P1652, "Undef"
    .lex "$*OUTERPACKAGE", $P1652
.annotate 'line', 736
    new $P1653, "Undef"
    .lex "$*PKGDECL", $P1653
.annotate 'line', 436
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1112
    rx1654_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1655_done:
.annotate 'line', 735
    rx1654_cur."!cursor_pos"(rx1654_pos)
    find_dynamic_lex $P1658, "$*PACKAGE"
    unless_null $P1658, vivify_1113
    get_hll_global $P1656, "GLOBAL"
    get_who $P1657, $P1656
    set $P1658, $P1657["$PACKAGE"]
    unless_null $P1658, vivify_1114
    die "Contextual $*PACKAGE not found"
  vivify_1114:
  vivify_1113:
    store_lex "$*OUTERPACKAGE", $P1658
.annotate 'line', 736
    rx1654_cur."!cursor_pos"(rx1654_pos)
    new $P1659, "String"
    assign $P1659, "module"
    store_lex "$*PKGDECL", $P1659
.annotate 'line', 737
  # rx subcapture "sym"
    set_addr $I10, rxcap_1660_fail
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  # rx literal  "module"
    add $I11, rx1654_pos, 6
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    substr $S10, rx1654_tgt, $I11, 6
    ne $S10, "module", rx1654_fail
    add rx1654_pos, 6
    set_addr $I10, rxcap_1660_fail
    ($I12, $I11) = rx1654_cur."!mark_peek"($I10)
    rx1654_cur."!cursor_pos"($I11)
    ($P10) = rx1654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1654_pos, "")
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1660_done
  rxcap_1660_fail:
    goto rx1654_fail
  rxcap_1660_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."package_def"()
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1654_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "package_declarator:sym<module>")
    if_null rx1654_debug, debug_1115
    rx1654_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1654_pos)
  debug_1115:
    .return (rx1654_cur)
  rx1654_restart:
.annotate 'line', 436
    if_null rx1654_debug, debug_1116
    rx1654_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1116:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1117
    rx1654_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1117:
    .return (rx1654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("169_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1662 = self."!PREFIX__!subrule"("package_def", "module")
    new $P1663, "ResizablePMCArray"
    push $P1663, $P1662
    .return ($P1663)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("170_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 740
    new $P1665, "Undef"
    .lex "$*OUTERPACKAGE", $P1665
.annotate 'line', 741
    new $P1666, "Undef"
    .lex "$*PKGDECL", $P1666
.annotate 'line', 436
    .local string rx1667_tgt
    .local int rx1667_pos
    .local int rx1667_off
    .local int rx1667_eos
    .local int rx1667_rep
    .local pmc rx1667_cur
    .local pmc rx1667_debug
    (rx1667_cur, rx1667_pos, rx1667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1667_cur
    .local pmc match
    .lex "$/", match
    length rx1667_eos, rx1667_tgt
    gt rx1667_pos, rx1667_eos, rx1667_done
    set rx1667_off, 0
    lt rx1667_pos, 2, rx1667_start
    sub rx1667_off, rx1667_pos, 1
    substr rx1667_tgt, rx1667_tgt, rx1667_off
  rx1667_start:
    eq $I10, 1, rx1667_restart
    if_null rx1667_debug, debug_1118
    rx1667_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1668_done
    goto rxscan1668_scan
  rxscan1668_loop:
    (rx1667_pos) = rx1667_cur."from"()
    inc rx1667_pos
    rx1667_cur."!cursor_from"(rx1667_pos)
    ge rx1667_pos, rx1667_eos, rxscan1668_done
  rxscan1668_scan:
    set_addr $I10, rxscan1668_loop
    rx1667_cur."!mark_push"(0, rx1667_pos, $I10)
  rxscan1668_done:
.annotate 'line', 740
    rx1667_cur."!cursor_pos"(rx1667_pos)
    find_dynamic_lex $P1671, "$*PACKAGE"
    unless_null $P1671, vivify_1119
    get_hll_global $P1669, "GLOBAL"
    get_who $P1670, $P1669
    set $P1671, $P1670["$PACKAGE"]
    unless_null $P1671, vivify_1120
    die "Contextual $*PACKAGE not found"
  vivify_1120:
  vivify_1119:
    store_lex "$*OUTERPACKAGE", $P1671
.annotate 'line', 741
    rx1667_cur."!cursor_pos"(rx1667_pos)
    new $P1672, "String"
    assign $P1672, "knowhow"
    store_lex "$*PKGDECL", $P1672
.annotate 'line', 742
  # rx subcapture "sym"
    set_addr $I10, rxcap_1673_fail
    rx1667_cur."!mark_push"(0, rx1667_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1667_pos, 7
    gt $I11, rx1667_eos, rx1667_fail
    sub $I11, rx1667_pos, rx1667_off
    substr $S10, rx1667_tgt, $I11, 7
    ne $S10, "knowhow", rx1667_fail
    add rx1667_pos, 7
    set_addr $I10, rxcap_1673_fail
    ($I12, $I11) = rx1667_cur."!mark_peek"($I10)
    rx1667_cur."!cursor_pos"($I11)
    ($P10) = rx1667_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1667_pos, "")
    rx1667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1673_done
  rxcap_1673_fail:
    goto rx1667_fail
  rxcap_1673_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1667_cur."!cursor_pos"(rx1667_pos)
    $P10 = rx1667_cur."package_def"()
    unless $P10, rx1667_fail
    rx1667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1667_pos = $P10."pos"()
.annotate 'line', 739
  # rx pass
    rx1667_cur."!cursor_pass"(rx1667_pos, "package_declarator:sym<knowhow>")
    if_null rx1667_debug, debug_1121
    rx1667_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1667_pos)
  debug_1121:
    .return (rx1667_cur)
  rx1667_restart:
.annotate 'line', 436
    if_null rx1667_debug, debug_1122
    rx1667_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1122:
  rx1667_fail:
    (rx1667_rep, rx1667_pos, $I10, $P10) = rx1667_cur."!mark_fail"(0)
    lt rx1667_pos, -1, rx1667_done
    eq rx1667_pos, -1, rx1667_fail
    jump $I10
  rx1667_done:
    rx1667_cur."!cursor_fail"()
    if_null rx1667_debug, debug_1123
    rx1667_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1123:
    .return (rx1667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("171_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1675 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P1676, "ResizablePMCArray"
    push $P1676, $P1675
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("172_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 745
    new $P1678, "Undef"
    .lex "$*OUTERPACKAGE", $P1678
.annotate 'line', 746
    new $P1679, "Undef"
    .lex "$*PKGDECL", $P1679
.annotate 'line', 436
    .local string rx1680_tgt
    .local int rx1680_pos
    .local int rx1680_off
    .local int rx1680_eos
    .local int rx1680_rep
    .local pmc rx1680_cur
    .local pmc rx1680_debug
    (rx1680_cur, rx1680_pos, rx1680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1680_cur
    .local pmc match
    .lex "$/", match
    length rx1680_eos, rx1680_tgt
    gt rx1680_pos, rx1680_eos, rx1680_done
    set rx1680_off, 0
    lt rx1680_pos, 2, rx1680_start
    sub rx1680_off, rx1680_pos, 1
    substr rx1680_tgt, rx1680_tgt, rx1680_off
  rx1680_start:
    eq $I10, 1, rx1680_restart
    if_null rx1680_debug, debug_1124
    rx1680_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1681_done
    goto rxscan1681_scan
  rxscan1681_loop:
    (rx1680_pos) = rx1680_cur."from"()
    inc rx1680_pos
    rx1680_cur."!cursor_from"(rx1680_pos)
    ge rx1680_pos, rx1680_eos, rxscan1681_done
  rxscan1681_scan:
    set_addr $I10, rxscan1681_loop
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  rxscan1681_done:
.annotate 'line', 745
    rx1680_cur."!cursor_pos"(rx1680_pos)
    find_dynamic_lex $P1684, "$*PACKAGE"
    unless_null $P1684, vivify_1125
    get_hll_global $P1682, "GLOBAL"
    get_who $P1683, $P1682
    set $P1684, $P1683["$PACKAGE"]
    unless_null $P1684, vivify_1126
    die "Contextual $*PACKAGE not found"
  vivify_1126:
  vivify_1125:
    store_lex "$*OUTERPACKAGE", $P1684
.annotate 'line', 746
    rx1680_cur."!cursor_pos"(rx1680_pos)
    new $P1685, "String"
    assign $P1685, "class"
    store_lex "$*PKGDECL", $P1685
.annotate 'line', 747
  # rx subcapture "sym"
    set_addr $I10, rxcap_1686_fail
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  # rx literal  "class"
    add $I11, rx1680_pos, 5
    gt $I11, rx1680_eos, rx1680_fail
    sub $I11, rx1680_pos, rx1680_off
    substr $S10, rx1680_tgt, $I11, 5
    ne $S10, "class", rx1680_fail
    add rx1680_pos, 5
    set_addr $I10, rxcap_1686_fail
    ($I12, $I11) = rx1680_cur."!mark_peek"($I10)
    rx1680_cur."!cursor_pos"($I11)
    ($P10) = rx1680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1680_pos, "")
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1686_done
  rxcap_1686_fail:
    goto rx1680_fail
  rxcap_1686_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    $P10 = rx1680_cur."package_def"()
    unless $P10, rx1680_fail
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1680_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx1680_cur."!cursor_pass"(rx1680_pos, "package_declarator:sym<class>")
    if_null rx1680_debug, debug_1127
    rx1680_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1680_pos)
  debug_1127:
    .return (rx1680_cur)
  rx1680_restart:
.annotate 'line', 436
    if_null rx1680_debug, debug_1128
    rx1680_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1128:
  rx1680_fail:
    (rx1680_rep, rx1680_pos, $I10, $P10) = rx1680_cur."!mark_fail"(0)
    lt rx1680_pos, -1, rx1680_done
    eq rx1680_pos, -1, rx1680_fail
    jump $I10
  rx1680_done:
    rx1680_cur."!cursor_fail"()
    if_null rx1680_debug, debug_1129
    rx1680_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1129:
    .return (rx1680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("173_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1688 = self."!PREFIX__!subrule"("package_def", "class")
    new $P1689, "ResizablePMCArray"
    push $P1689, $P1688
    .return ($P1689)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("174_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 750
    new $P1691, "Undef"
    .lex "$*OUTERPACKAGE", $P1691
.annotate 'line', 751
    new $P1692, "Undef"
    .lex "$*PKGDECL", $P1692
.annotate 'line', 436
    .local string rx1693_tgt
    .local int rx1693_pos
    .local int rx1693_off
    .local int rx1693_eos
    .local int rx1693_rep
    .local pmc rx1693_cur
    .local pmc rx1693_debug
    (rx1693_cur, rx1693_pos, rx1693_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1693_cur
    .local pmc match
    .lex "$/", match
    length rx1693_eos, rx1693_tgt
    gt rx1693_pos, rx1693_eos, rx1693_done
    set rx1693_off, 0
    lt rx1693_pos, 2, rx1693_start
    sub rx1693_off, rx1693_pos, 1
    substr rx1693_tgt, rx1693_tgt, rx1693_off
  rx1693_start:
    eq $I10, 1, rx1693_restart
    if_null rx1693_debug, debug_1130
    rx1693_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1694_done
    goto rxscan1694_scan
  rxscan1694_loop:
    (rx1693_pos) = rx1693_cur."from"()
    inc rx1693_pos
    rx1693_cur."!cursor_from"(rx1693_pos)
    ge rx1693_pos, rx1693_eos, rxscan1694_done
  rxscan1694_scan:
    set_addr $I10, rxscan1694_loop
    rx1693_cur."!mark_push"(0, rx1693_pos, $I10)
  rxscan1694_done:
.annotate 'line', 750
    rx1693_cur."!cursor_pos"(rx1693_pos)
    find_dynamic_lex $P1697, "$*PACKAGE"
    unless_null $P1697, vivify_1131
    get_hll_global $P1695, "GLOBAL"
    get_who $P1696, $P1695
    set $P1697, $P1696["$PACKAGE"]
    unless_null $P1697, vivify_1132
    die "Contextual $*PACKAGE not found"
  vivify_1132:
  vivify_1131:
    store_lex "$*OUTERPACKAGE", $P1697
.annotate 'line', 751
    rx1693_cur."!cursor_pos"(rx1693_pos)
    new $P1698, "String"
    assign $P1698, "grammar"
    store_lex "$*PKGDECL", $P1698
.annotate 'line', 752
  # rx subcapture "sym"
    set_addr $I10, rxcap_1699_fail
    rx1693_cur."!mark_push"(0, rx1693_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1693_pos, 7
    gt $I11, rx1693_eos, rx1693_fail
    sub $I11, rx1693_pos, rx1693_off
    substr $S10, rx1693_tgt, $I11, 7
    ne $S10, "grammar", rx1693_fail
    add rx1693_pos, 7
    set_addr $I10, rxcap_1699_fail
    ($I12, $I11) = rx1693_cur."!mark_peek"($I10)
    rx1693_cur."!cursor_pos"($I11)
    ($P10) = rx1693_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1693_pos, "")
    rx1693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1699_done
  rxcap_1699_fail:
    goto rx1693_fail
  rxcap_1699_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1693_cur."!cursor_pos"(rx1693_pos)
    $P10 = rx1693_cur."package_def"()
    unless $P10, rx1693_fail
    rx1693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1693_pos = $P10."pos"()
.annotate 'line', 749
  # rx pass
    rx1693_cur."!cursor_pass"(rx1693_pos, "package_declarator:sym<grammar>")
    if_null rx1693_debug, debug_1133
    rx1693_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1693_pos)
  debug_1133:
    .return (rx1693_cur)
  rx1693_restart:
.annotate 'line', 436
    if_null rx1693_debug, debug_1134
    rx1693_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1134:
  rx1693_fail:
    (rx1693_rep, rx1693_pos, $I10, $P10) = rx1693_cur."!mark_fail"(0)
    lt rx1693_pos, -1, rx1693_done
    eq rx1693_pos, -1, rx1693_fail
    jump $I10
  rx1693_done:
    rx1693_cur."!cursor_fail"()
    if_null rx1693_debug, debug_1135
    rx1693_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1135:
    .return (rx1693_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("175_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1701 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P1702, "ResizablePMCArray"
    push $P1702, $P1701
    .return ($P1702)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("176_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 755
    new $P1704, "Undef"
    .lex "$*OUTERPACKAGE", $P1704
.annotate 'line', 756
    new $P1705, "Undef"
    .lex "$*PKGDECL", $P1705
.annotate 'line', 436
    .local string rx1706_tgt
    .local int rx1706_pos
    .local int rx1706_off
    .local int rx1706_eos
    .local int rx1706_rep
    .local pmc rx1706_cur
    .local pmc rx1706_debug
    (rx1706_cur, rx1706_pos, rx1706_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1706_cur
    .local pmc match
    .lex "$/", match
    length rx1706_eos, rx1706_tgt
    gt rx1706_pos, rx1706_eos, rx1706_done
    set rx1706_off, 0
    lt rx1706_pos, 2, rx1706_start
    sub rx1706_off, rx1706_pos, 1
    substr rx1706_tgt, rx1706_tgt, rx1706_off
  rx1706_start:
    eq $I10, 1, rx1706_restart
    if_null rx1706_debug, debug_1136
    rx1706_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1707_done
    goto rxscan1707_scan
  rxscan1707_loop:
    (rx1706_pos) = rx1706_cur."from"()
    inc rx1706_pos
    rx1706_cur."!cursor_from"(rx1706_pos)
    ge rx1706_pos, rx1706_eos, rxscan1707_done
  rxscan1707_scan:
    set_addr $I10, rxscan1707_loop
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  rxscan1707_done:
.annotate 'line', 755
    rx1706_cur."!cursor_pos"(rx1706_pos)
    find_dynamic_lex $P1710, "$*PACKAGE"
    unless_null $P1710, vivify_1137
    get_hll_global $P1708, "GLOBAL"
    get_who $P1709, $P1708
    set $P1710, $P1709["$PACKAGE"]
    unless_null $P1710, vivify_1138
    die "Contextual $*PACKAGE not found"
  vivify_1138:
  vivify_1137:
    store_lex "$*OUTERPACKAGE", $P1710
.annotate 'line', 756
    rx1706_cur."!cursor_pos"(rx1706_pos)
    new $P1711, "String"
    assign $P1711, "role"
    store_lex "$*PKGDECL", $P1711
.annotate 'line', 757
  # rx subcapture "sym"
    set_addr $I10, rxcap_1712_fail
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  # rx literal  "role"
    add $I11, rx1706_pos, 4
    gt $I11, rx1706_eos, rx1706_fail
    sub $I11, rx1706_pos, rx1706_off
    substr $S10, rx1706_tgt, $I11, 4
    ne $S10, "role", rx1706_fail
    add rx1706_pos, 4
    set_addr $I10, rxcap_1712_fail
    ($I12, $I11) = rx1706_cur."!mark_peek"($I10)
    rx1706_cur."!cursor_pos"($I11)
    ($P10) = rx1706_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1706_pos, "")
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1712_done
  rxcap_1712_fail:
    goto rx1706_fail
  rxcap_1712_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1706_cur."!cursor_pos"(rx1706_pos)
    $P10 = rx1706_cur."package_def"()
    unless $P10, rx1706_fail
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1706_pos = $P10."pos"()
.annotate 'line', 754
  # rx pass
    rx1706_cur."!cursor_pass"(rx1706_pos, "package_declarator:sym<role>")
    if_null rx1706_debug, debug_1139
    rx1706_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1706_pos)
  debug_1139:
    .return (rx1706_cur)
  rx1706_restart:
.annotate 'line', 436
    if_null rx1706_debug, debug_1140
    rx1706_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1140:
  rx1706_fail:
    (rx1706_rep, rx1706_pos, $I10, $P10) = rx1706_cur."!mark_fail"(0)
    lt rx1706_pos, -1, rx1706_done
    eq rx1706_pos, -1, rx1706_fail
    jump $I10
  rx1706_done:
    rx1706_cur."!cursor_fail"()
    if_null rx1706_debug, debug_1141
    rx1706_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1141:
    .return (rx1706_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("177_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1714 = self."!PREFIX__!subrule"("package_def", "role")
    new $P1715, "ResizablePMCArray"
    push $P1715, $P1714
    .return ($P1715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("178_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 760
    new $P1717, "Undef"
    .lex "$*OUTERPACKAGE", $P1717
.annotate 'line', 761
    new $P1718, "Undef"
    .lex "$*PKGDECL", $P1718
.annotate 'line', 436
    .local string rx1719_tgt
    .local int rx1719_pos
    .local int rx1719_off
    .local int rx1719_eos
    .local int rx1719_rep
    .local pmc rx1719_cur
    .local pmc rx1719_debug
    (rx1719_cur, rx1719_pos, rx1719_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1719_cur
    .local pmc match
    .lex "$/", match
    length rx1719_eos, rx1719_tgt
    gt rx1719_pos, rx1719_eos, rx1719_done
    set rx1719_off, 0
    lt rx1719_pos, 2, rx1719_start
    sub rx1719_off, rx1719_pos, 1
    substr rx1719_tgt, rx1719_tgt, rx1719_off
  rx1719_start:
    eq $I10, 1, rx1719_restart
    if_null rx1719_debug, debug_1142
    rx1719_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1720_done
    goto rxscan1720_scan
  rxscan1720_loop:
    (rx1719_pos) = rx1719_cur."from"()
    inc rx1719_pos
    rx1719_cur."!cursor_from"(rx1719_pos)
    ge rx1719_pos, rx1719_eos, rxscan1720_done
  rxscan1720_scan:
    set_addr $I10, rxscan1720_loop
    rx1719_cur."!mark_push"(0, rx1719_pos, $I10)
  rxscan1720_done:
.annotate 'line', 760
    rx1719_cur."!cursor_pos"(rx1719_pos)
    find_dynamic_lex $P1723, "$*PACKAGE"
    unless_null $P1723, vivify_1143
    get_hll_global $P1721, "GLOBAL"
    get_who $P1722, $P1721
    set $P1723, $P1722["$PACKAGE"]
    unless_null $P1723, vivify_1144
    die "Contextual $*PACKAGE not found"
  vivify_1144:
  vivify_1143:
    store_lex "$*OUTERPACKAGE", $P1723
.annotate 'line', 761
    rx1719_cur."!cursor_pos"(rx1719_pos)
    new $P1724, "String"
    assign $P1724, "native"
    store_lex "$*PKGDECL", $P1724
.annotate 'line', 762
  # rx subcapture "sym"
    set_addr $I10, rxcap_1725_fail
    rx1719_cur."!mark_push"(0, rx1719_pos, $I10)
  # rx literal  "native"
    add $I11, rx1719_pos, 6
    gt $I11, rx1719_eos, rx1719_fail
    sub $I11, rx1719_pos, rx1719_off
    substr $S10, rx1719_tgt, $I11, 6
    ne $S10, "native", rx1719_fail
    add rx1719_pos, 6
    set_addr $I10, rxcap_1725_fail
    ($I12, $I11) = rx1719_cur."!mark_peek"($I10)
    rx1719_cur."!cursor_pos"($I11)
    ($P10) = rx1719_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1719_pos, "")
    rx1719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1725_done
  rxcap_1725_fail:
    goto rx1719_fail
  rxcap_1725_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1719_cur."!cursor_pos"(rx1719_pos)
    $P10 = rx1719_cur."package_def"()
    unless $P10, rx1719_fail
    rx1719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1719_pos = $P10."pos"()
.annotate 'line', 759
  # rx pass
    rx1719_cur."!cursor_pass"(rx1719_pos, "package_declarator:sym<native>")
    if_null rx1719_debug, debug_1145
    rx1719_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1719_pos)
  debug_1145:
    .return (rx1719_cur)
  rx1719_restart:
.annotate 'line', 436
    if_null rx1719_debug, debug_1146
    rx1719_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1146:
  rx1719_fail:
    (rx1719_rep, rx1719_pos, $I10, $P10) = rx1719_cur."!mark_fail"(0)
    lt rx1719_pos, -1, rx1719_done
    eq rx1719_pos, -1, rx1719_fail
    jump $I10
  rx1719_done:
    rx1719_cur."!cursor_fail"()
    if_null rx1719_debug, debug_1147
    rx1719_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1147:
    .return (rx1719_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("179_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1727 = self."!PREFIX__!subrule"("package_def", "native")
    new $P1728, "ResizablePMCArray"
    push $P1728, $P1727
    .return ($P1728)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<stub>"  :subid("180_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 765
    new $P1730, "Undef"
    .lex "$*OUTERPACKAGE", $P1730
.annotate 'line', 766
    new $P1731, "Undef"
    .lex "$*PKGDECL", $P1731
.annotate 'line', 436
    .local string rx1732_tgt
    .local int rx1732_pos
    .local int rx1732_off
    .local int rx1732_eos
    .local int rx1732_rep
    .local pmc rx1732_cur
    .local pmc rx1732_debug
    (rx1732_cur, rx1732_pos, rx1732_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1732_cur
    .local pmc match
    .lex "$/", match
    length rx1732_eos, rx1732_tgt
    gt rx1732_pos, rx1732_eos, rx1732_done
    set rx1732_off, 0
    lt rx1732_pos, 2, rx1732_start
    sub rx1732_off, rx1732_pos, 1
    substr rx1732_tgt, rx1732_tgt, rx1732_off
  rx1732_start:
    eq $I10, 1, rx1732_restart
    if_null rx1732_debug, debug_1148
    rx1732_cur."!cursor_debug"("START", "package_declarator:sym<stub>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1733_done
    goto rxscan1733_scan
  rxscan1733_loop:
    (rx1732_pos) = rx1732_cur."from"()
    inc rx1732_pos
    rx1732_cur."!cursor_from"(rx1732_pos)
    ge rx1732_pos, rx1732_eos, rxscan1733_done
  rxscan1733_scan:
    set_addr $I10, rxscan1733_loop
    rx1732_cur."!mark_push"(0, rx1732_pos, $I10)
  rxscan1733_done:
.annotate 'line', 764
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 765
    rx1732_cur."!cursor_pos"(rx1732_pos)
    find_dynamic_lex $P1737, "$*PACKAGE"
    unless_null $P1737, vivify_1149
    get_hll_global $P1735, "GLOBAL"
    get_who $P1736, $P1735
    set $P1737, $P1736["$PACKAGE"]
    unless_null $P1737, vivify_1150
    die "Contextual $*PACKAGE not found"
  vivify_1150:
  vivify_1149:
    store_lex "$*OUTERPACKAGE", $P1737
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 766
    rx1732_cur."!cursor_pos"(rx1732_pos)
    new $P1739, "String"
    assign $P1739, "stub"
    store_lex "$*PKGDECL", $P1739
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 767
  # rx subcapture "sym"
    set_addr $I10, rxcap_1741_fail
    rx1732_cur."!mark_push"(0, rx1732_pos, $I10)
  # rx literal  "stub"
    add $I11, rx1732_pos, 4
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    substr $S10, rx1732_tgt, $I11, 4
    ne $S10, "stub", rx1732_fail
    add rx1732_pos, 4
    set_addr $I10, rxcap_1741_fail
    ($I12, $I11) = rx1732_cur."!mark_peek"($I10)
    rx1732_cur."!cursor_pos"($I11)
    ($P10) = rx1732_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1732_pos, "")
    rx1732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1741_done
  rxcap_1741_fail:
    goto rx1732_fail
  rxcap_1741_done:
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."name"()
    unless $P10, rx1732_fail
    rx1732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1732_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 768
  # rx literal  "metaclass"
    add $I11, rx1732_pos, 9
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    substr $S10, rx1732_tgt, $I11, 9
    ne $S10, "metaclass", rx1732_fail
    add rx1732_pos, 9
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."name"()
    unless $P10, rx1732_fail
    rx1732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("metaclass")
    rx1732_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 769
  # rx literal  "{"
    add $I11, rx1732_pos, 1
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    ord $I11, rx1732_tgt, $I11
    ne $I11, 123, rx1732_fail
    add rx1732_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx literal  "..."
    add $I11, rx1732_pos, 3
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    substr $S10, rx1732_tgt, $I11, 3
    ne $S10, "...", rx1732_fail
    add rx1732_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1732_pos, 1
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    ord $I11, rx1732_tgt, $I11
    ne $I11, 125, rx1732_fail
    add rx1732_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 764
  # rx pass
    rx1732_cur."!cursor_pass"(rx1732_pos, "package_declarator:sym<stub>")
    if_null rx1732_debug, debug_1151
    rx1732_cur."!cursor_debug"("PASS", "package_declarator:sym<stub>", " at pos=", rx1732_pos)
  debug_1151:
    .return (rx1732_cur)
  rx1732_restart:
.annotate 'line', 436
    if_null rx1732_debug, debug_1152
    rx1732_cur."!cursor_debug"("NEXT", "package_declarator:sym<stub>")
  debug_1152:
  rx1732_fail:
    (rx1732_rep, rx1732_pos, $I10, $P10) = rx1732_cur."!mark_fail"(0)
    lt rx1732_pos, -1, rx1732_done
    eq rx1732_pos, -1, rx1732_fail
    jump $I10
  rx1732_done:
    rx1732_cur."!cursor_fail"()
    if_null rx1732_debug, debug_1153
    rx1732_cur."!cursor_debug"("FAIL", "package_declarator:sym<stub>")
  debug_1153:
    .return (rx1732_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<stub>"  :subid("181_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1750 = self."!PREFIX__!subrule"("ws", "")
    new $P1751, "ResizablePMCArray"
    push $P1751, $P1750
    .return ($P1751)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("182_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P1772 = "183_1306916577.75068" 
    capture_lex $P1772
.annotate 'line', 773
    new $P1753, "Undef"
    .lex "$*PACKAGE", $P1753
.annotate 'line', 436
    .local string rx1754_tgt
    .local int rx1754_pos
    .local int rx1754_off
    .local int rx1754_eos
    .local int rx1754_rep
    .local pmc rx1754_cur
    .local pmc rx1754_debug
    (rx1754_cur, rx1754_pos, rx1754_tgt, $I10) = self."!cursor_start"()
    rx1754_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1754_cur
    .local pmc match
    .lex "$/", match
    length rx1754_eos, rx1754_tgt
    gt rx1754_pos, rx1754_eos, rx1754_done
    set rx1754_off, 0
    lt rx1754_pos, 2, rx1754_start
    sub rx1754_off, rx1754_pos, 1
    substr rx1754_tgt, rx1754_tgt, rx1754_off
  rx1754_start:
    eq $I10, 1, rx1754_restart
    if_null rx1754_debug, debug_1154
    rx1754_cur."!cursor_debug"("START", "package_def")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1755_done
    goto rxscan1755_scan
  rxscan1755_loop:
    (rx1754_pos) = rx1754_cur."from"()
    inc rx1754_pos
    rx1754_cur."!cursor_from"(rx1754_pos)
    ge rx1754_pos, rx1754_eos, rxscan1755_done
  rxscan1755_scan:
    set_addr $I10, rxscan1755_loop
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxscan1755_done:
.annotate 'line', 772
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 773
    rx1754_cur."!cursor_pos"(rx1754_pos)
    find_lex $P1759, "$*PACKAGE"
    unless_null $P1759, vivify_1155
    get_hll_global $P1757, "GLOBAL"
    get_who $P1758, $P1757
    set $P1759, $P1758["$PACKAGE"]
    unless_null $P1759, vivify_1156
    die "Contextual $*PACKAGE not found"
  vivify_1156:
  vivify_1155:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 775
  # rx subrule "name" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."name"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 776
  # rx rxquantr1762 ** 0..1
    set_addr $I10, rxquantr1762_done
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxquantr1762_loop:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1754_pos, 2
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 2
    ne $S10, "is", rx1754_fail
    add rx1754_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1754_pos, 5
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 5
    ne $S10, "repr(", rx1754_fail
    add rx1754_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."quote_EXPR"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1754_pos, 1
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    ord $I11, rx1754_tgt, $I11
    ne $I11, 41, rx1754_fail
    add rx1754_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    set_addr $I10, rxquantr1762_done
    (rx1754_rep) = rx1754_cur."!mark_commit"($I10)
  rxquantr1762_done:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 778
    rx1754_cur."!cursor_pos"(rx1754_pos)
    find_lex $P1769, unicode:"$\x{a2}"
    $P1770 = $P1769."MATCH"()
    store_lex "$/", $P1770
    .const 'Sub' $P1772 = "183_1306916577.75068" 
    capture_lex $P1772
    $P1894 = $P1772()
.annotate 'line', 804
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 806
  # rx rxquantr1896 ** 0..1
    set_addr $I10, rxquantr1896_done
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxquantr1896_loop:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1754_pos, 2
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 2
    ne $S10, "is", rx1754_fail
    add rx1754_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."name"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    set_addr $I10, rxquantr1896_done
    (rx1754_rep) = rx1754_cur."!mark_commit"($I10)
  rxquantr1896_done:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 807
  # rx rxquantr1901 ** 0..*
    set_addr $I10, rxquantr1901_done
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxquantr1901_loop:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1754_pos, 4
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 4
    ne $S10, "does", rx1754_fail
    add rx1754_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."name"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    set_addr $I10, rxquantr1901_done
    (rx1754_rep) = rx1754_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1901_done
    rx1754_cur."!mark_push"(rx1754_rep, rx1754_pos, $I10)
    goto rxquantr1901_loop
  rxquantr1901_done:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  alt1906_0:
.annotate 'line', 808
    set_addr $I10, alt1906_1
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
.annotate 'line', 809
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1754_pos, 1
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    ord $I11, rx1754_tgt, $I11
    ne $I11, 59, rx1754_fail
    add rx1754_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."comp_unit"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    goto alt1906_end
  alt1906_1:
    set_addr $I10, alt1906_2
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
.annotate 'line', 810
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1754_fail
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."block"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    goto alt1906_end
  alt1906_2:
.annotate 'line', 811
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."panic"("Malformed package declaration")
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  alt1906_end:
.annotate 'line', 812
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 772
  # rx pass
    rx1754_cur."!cursor_pass"(rx1754_pos, "package_def")
    if_null rx1754_debug, debug_1224
    rx1754_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1754_pos)
  debug_1224:
    .return (rx1754_cur)
  rx1754_restart:
.annotate 'line', 436
    if_null rx1754_debug, debug_1225
    rx1754_cur."!cursor_debug"("NEXT", "package_def")
  debug_1225:
  rx1754_fail:
    (rx1754_rep, rx1754_pos, $I10, $P10) = rx1754_cur."!mark_fail"(0)
    lt rx1754_pos, -1, rx1754_done
    eq rx1754_pos, -1, rx1754_fail
    jump $I10
  rx1754_done:
    rx1754_cur."!cursor_fail"()
    if_null rx1754_debug, debug_1226
    rx1754_cur."!cursor_debug"("FAIL", "package_def")
  debug_1226:
    .return (rx1754_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1771"  :anon :subid("183_1306916577.75068") :outer("182_1306916577.75068")
.annotate 'line', 781
    $P1773 = root_new ['parrot';'Hash']
    .lex "%args", $P1773
.annotate 'line', 778
    find_lex $P1774, "%args"
    unless_null $P1774, vivify_1157
    $P1774 = root_new ['parrot';'Hash']
  vivify_1157:
.annotate 'line', 782
    find_lex $P1775, "$/"
    unless_null $P1775, vivify_1158
    $P1775 = root_new ['parrot';'Hash']
  vivify_1158:
    set $P1776, $P1775["name"]
    unless_null $P1776, vivify_1159
    new $P1776, "Undef"
  vivify_1159:
    set $S1777, $P1776
    new $P1778, 'String'
    set $P1778, $S1777
    find_lex $P1779, "%args"
    unless_null $P1779, vivify_1160
    $P1779 = root_new ['parrot';'Hash']
    store_lex "%args", $P1779
  vivify_1160:
    set $P1779["name"], $P1778
.annotate 'line', 783
    find_lex $P1781, "$/"
    unless_null $P1781, vivify_1161
    $P1781 = root_new ['parrot';'Hash']
  vivify_1161:
    set $P1782, $P1781["repr"]
    unless_null $P1782, vivify_1162
    new $P1782, "Undef"
  vivify_1162:
    unless $P1782, if_1780_end
.annotate 'line', 784
    find_lex $P1783, "$/"
    unless_null $P1783, vivify_1163
    $P1783 = root_new ['parrot';'Hash']
  vivify_1163:
    set $P1784, $P1783["repr"]
    unless_null $P1784, vivify_1164
    $P1784 = root_new ['parrot';'ResizablePMCArray']
  vivify_1164:
    set $P1785, $P1784[0]
    unless_null $P1785, vivify_1165
    $P1785 = root_new ['parrot';'Hash']
  vivify_1165:
    set $P1786, $P1785["quote_delimited"]
    unless_null $P1786, vivify_1166
    $P1786 = root_new ['parrot';'Hash']
  vivify_1166:
    set $P1787, $P1786["quote_atom"]
    unless_null $P1787, vivify_1167
    $P1787 = root_new ['parrot';'ResizablePMCArray']
  vivify_1167:
    set $P1788, $P1787[0]
    unless_null $P1788, vivify_1168
    new $P1788, "Undef"
  vivify_1168:
    set $S1789, $P1788
    new $P1790, 'String'
    set $P1790, $S1789
    find_lex $P1791, "%args"
    unless_null $P1791, vivify_1169
    $P1791 = root_new ['parrot';'Hash']
    store_lex "%args", $P1791
  vivify_1169:
    set $P1791["repr"], $P1790
  if_1780_end:
.annotate 'line', 786
    find_dynamic_lex $P1794, "$*SC"
    unless_null $P1794, vivify_1170
    get_hll_global $P1792, "GLOBAL"
    get_who $P1793, $P1792
    set $P1794, $P1793["$SC"]
    unless_null $P1794, vivify_1171
    die "Contextual $*SC not found"
  vivify_1171:
  vivify_1170:
    find_dynamic_lex $P1797, "$*PKGDECL"
    unless_null $P1797, vivify_1172
    get_hll_global $P1795, "GLOBAL"
    get_who $P1796, $P1795
    set $P1797, $P1796["$PKGDECL"]
    unless_null $P1797, vivify_1173
    die "Contextual $*PKGDECL not found"
  vivify_1173:
  vivify_1172:
    find_dynamic_lex $P1800, "%*HOW"
    unless_null $P1800, vivify_1174
    get_hll_global $P1798, "GLOBAL"
    get_who $P1799, $P1798
    set $P1800, $P1799["%HOW"]
    unless_null $P1800, vivify_1175
    die "Contextual %*HOW not found"
  vivify_1175:
  vivify_1174:
    set $P1801, $P1800[$P1797]
    unless_null $P1801, vivify_1176
    new $P1801, "Undef"
  vivify_1176:
    find_lex $P1802, "%args"
    unless_null $P1802, vivify_1177
    $P1802 = root_new ['parrot';'Hash']
  vivify_1177:
    $P1803 = $P1794."pkg_create_mo"($P1801, $P1802 :flat)
    store_dynamic_lex "$*PACKAGE", $P1803
.annotate 'line', 789
    find_dynamic_lex $P1810, "$*SCOPE"
    unless_null $P1810, vivify_1178
    get_hll_global $P1808, "GLOBAL"
    get_who $P1809, $P1808
    set $P1810, $P1809["$SCOPE"]
    unless_null $P1810, vivify_1179
    die "Contextual $*SCOPE not found"
  vivify_1179:
  vivify_1178:
    set $S1811, $P1810
    iseq $I1812, $S1811, "our"
    unless $I1812, unless_1807
    new $P1806, 'Integer'
    set $P1806, $I1812
    goto unless_1807_end
  unless_1807:
    find_dynamic_lex $P1815, "$*SCOPE"
    unless_null $P1815, vivify_1180
    get_hll_global $P1813, "GLOBAL"
    get_who $P1814, $P1813
    set $P1815, $P1814["$SCOPE"]
    unless_null $P1815, vivify_1181
    die "Contextual $*SCOPE not found"
  vivify_1181:
  vivify_1180:
    set $S1816, $P1815
    iseq $I1817, $S1816, ""
    new $P1806, 'Integer'
    set $P1806, $I1817
  unless_1807_end:
    if $P1806, if_1805
.annotate 'line', 795
    find_dynamic_lex $P1858, "$*SCOPE"
    unless_null $P1858, vivify_1182
    get_hll_global $P1856, "GLOBAL"
    get_who $P1857, $P1856
    set $P1858, $P1857["$SCOPE"]
    unless_null $P1858, vivify_1183
    die "Contextual $*SCOPE not found"
  vivify_1183:
  vivify_1182:
    set $S1859, $P1858
    iseq $I1860, $S1859, "my"
    if $I1860, if_1855
.annotate 'line', 802
    find_lex $P1887, "$/"
    unless_null $P1887, vivify_1184
    new $P1887, "Undef"
  vivify_1184:
    $P1888 = $P1887."CURSOR"()
    find_dynamic_lex $P1891, "$*SCOPE"
    unless_null $P1891, vivify_1185
    get_hll_global $P1889, "GLOBAL"
    get_who $P1890, $P1889
    set $P1891, $P1890["$SCOPE"]
    unless_null $P1891, vivify_1186
    die "Contextual $*SCOPE not found"
  vivify_1186:
  vivify_1185:
    concat $P1892, $P1891, " scoped packages are not supported"
    $P1893 = $P1888."panic"($P1892)
.annotate 'line', 801
    set $P1854, $P1893
.annotate 'line', 795
    goto if_1855_end
  if_1855:
.annotate 'line', 796
    find_lex $P1862, "$/"
    unless_null $P1862, vivify_1187
    $P1862 = root_new ['parrot';'Hash']
  vivify_1187:
    set $P1863, $P1862["name"]
    unless_null $P1863, vivify_1188
    $P1863 = root_new ['parrot';'Hash']
  vivify_1188:
    set $P1864, $P1863["identifier"]
    unless_null $P1864, vivify_1189
    new $P1864, "Undef"
  vivify_1189:
    set $N1865, $P1864
    isne $I1866, $N1865, 1.0
    unless $I1866, if_1861_end
.annotate 'line', 797
    find_lex $P1867, "$/"
    unless_null $P1867, vivify_1190
    $P1867 = root_new ['parrot';'Hash']
  vivify_1190:
    set $P1868, $P1867["name"]
    unless_null $P1868, vivify_1191
    new $P1868, "Undef"
  vivify_1191:
    $P1869 = $P1868."CURSOR"()
    $P1869."panic"("A my scoped package cannot have a multi-part name yet")
  if_1861_end:
.annotate 'line', 799
    find_dynamic_lex $P1872, "$*SC"
    unless_null $P1872, vivify_1192
    get_hll_global $P1870, "GLOBAL"
    get_who $P1871, $P1870
    set $P1872, $P1871["$SC"]
    unless_null $P1872, vivify_1193
    die "Contextual $*SC not found"
  vivify_1193:
  vivify_1192:
    get_hll_global $P1873, "GLOBAL"
    nqp_get_package_through_who $P1874, $P1873, "NQP"
    nqp_get_package_through_who $P1875, $P1874, "Actions"
    get_who $P1876, $P1875
    set $P1877, $P1876["@BLOCK"]
    unless_null $P1877, vivify_1194
    $P1877 = root_new ['parrot';'ResizablePMCArray']
  vivify_1194:
    set $P1878, $P1877[0]
    unless_null $P1878, vivify_1195
    new $P1878, "Undef"
  vivify_1195:
    find_lex $P1879, "$/"
    unless_null $P1879, vivify_1196
    $P1879 = root_new ['parrot';'Hash']
  vivify_1196:
    set $P1880, $P1879["name"]
    unless_null $P1880, vivify_1197
    $P1880 = root_new ['parrot';'Hash']
  vivify_1197:
    set $P1881, $P1880["identifier"]
    unless_null $P1881, vivify_1198
    $P1881 = root_new ['parrot';'ResizablePMCArray']
  vivify_1198:
    set $P1882, $P1881[0]
    unless_null $P1882, vivify_1199
    new $P1882, "Undef"
  vivify_1199:
    find_dynamic_lex $P1885, "$*PACKAGE"
    unless_null $P1885, vivify_1200
    get_hll_global $P1883, "GLOBAL"
    get_who $P1884, $P1883
    set $P1885, $P1884["$PACKAGE"]
    unless_null $P1885, vivify_1201
    die "Contextual $*PACKAGE not found"
  vivify_1201:
  vivify_1200:
    $P1886 = $P1872."install_lexical_symbol"($P1878, $P1882, $P1885)
.annotate 'line', 795
    set $P1854, $P1886
  if_1855_end:
    set $P1804, $P1854
.annotate 'line', 789
    goto if_1805_end
  if_1805:
.annotate 'line', 790
    find_dynamic_lex $P1820, "$*SC"
    unless_null $P1820, vivify_1202
    get_hll_global $P1818, "GLOBAL"
    get_who $P1819, $P1818
    set $P1820, $P1819["$SC"]
    unless_null $P1820, vivify_1203
    die "Contextual $*SC not found"
  vivify_1203:
  vivify_1202:
    find_dynamic_lex $P1823, "$*OUTERPACKAGE"
    unless_null $P1823, vivify_1204
    get_hll_global $P1821, "GLOBAL"
    get_who $P1822, $P1821
    set $P1823, $P1822["$OUTERPACKAGE"]
    unless_null $P1823, vivify_1205
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1205:
  vivify_1204:
    find_lex $P1824, "$/"
    unless_null $P1824, vivify_1206
    $P1824 = root_new ['parrot';'Hash']
  vivify_1206:
    set $P1825, $P1824["name"]
    unless_null $P1825, vivify_1207
    $P1825 = root_new ['parrot';'Hash']
  vivify_1207:
    set $P1826, $P1825["identifier"]
    unless_null $P1826, vivify_1208
    new $P1826, "Undef"
  vivify_1208:
    find_dynamic_lex $P1829, "$*PACKAGE"
    unless_null $P1829, vivify_1209
    get_hll_global $P1827, "GLOBAL"
    get_who $P1828, $P1827
    set $P1829, $P1828["$PACKAGE"]
    unless_null $P1829, vivify_1210
    die "Contextual $*PACKAGE not found"
  vivify_1210:
  vivify_1209:
    $P1820."install_package_symbol"($P1823, $P1826, $P1829)
.annotate 'line', 791
    find_lex $P1832, "$/"
    unless_null $P1832, vivify_1211
    $P1832 = root_new ['parrot';'Hash']
  vivify_1211:
    set $P1833, $P1832["name"]
    unless_null $P1833, vivify_1212
    $P1833 = root_new ['parrot';'Hash']
  vivify_1212:
    set $P1834, $P1833["identifier"]
    unless_null $P1834, vivify_1213
    new $P1834, "Undef"
  vivify_1213:
    set $N1835, $P1834
    iseq $I1836, $N1835, 1.0
    if $I1836, if_1831
    new $P1830, 'Integer'
    set $P1830, $I1836
    goto if_1831_end
  if_1831:
.annotate 'line', 792
    find_dynamic_lex $P1839, "$*SC"
    unless_null $P1839, vivify_1214
    get_hll_global $P1837, "GLOBAL"
    get_who $P1838, $P1837
    set $P1839, $P1838["$SC"]
    unless_null $P1839, vivify_1215
    die "Contextual $*SC not found"
  vivify_1215:
  vivify_1214:
    get_hll_global $P1840, "GLOBAL"
    nqp_get_package_through_who $P1841, $P1840, "NQP"
    nqp_get_package_through_who $P1842, $P1841, "Actions"
    get_who $P1843, $P1842
    set $P1844, $P1843["@BLOCK"]
    unless_null $P1844, vivify_1216
    $P1844 = root_new ['parrot';'ResizablePMCArray']
  vivify_1216:
    set $P1845, $P1844[0]
    unless_null $P1845, vivify_1217
    new $P1845, "Undef"
  vivify_1217:
    find_lex $P1846, "$/"
    unless_null $P1846, vivify_1218
    $P1846 = root_new ['parrot';'Hash']
  vivify_1218:
    set $P1847, $P1846["name"]
    unless_null $P1847, vivify_1219
    $P1847 = root_new ['parrot';'Hash']
  vivify_1219:
    set $P1848, $P1847["identifier"]
    unless_null $P1848, vivify_1220
    $P1848 = root_new ['parrot';'ResizablePMCArray']
  vivify_1220:
    set $P1849, $P1848[0]
    unless_null $P1849, vivify_1221
    new $P1849, "Undef"
  vivify_1221:
    find_dynamic_lex $P1852, "$*PACKAGE"
    unless_null $P1852, vivify_1222
    get_hll_global $P1850, "GLOBAL"
    get_who $P1851, $P1850
    set $P1852, $P1851["$PACKAGE"]
    unless_null $P1852, vivify_1223
    die "Contextual $*PACKAGE not found"
  vivify_1223:
  vivify_1222:
    $P1853 = $P1839."install_lexical_symbol"($P1845, $P1849, $P1852)
.annotate 'line', 791
    set $P1830, $P1853
  if_1831_end:
.annotate 'line', 789
    set $P1804, $P1830
  if_1805_end:
.annotate 'line', 778
    .return ($P1804)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("184_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1917 = self."!PREFIX__!subrule"("ws", "")
    new $P1918, "ResizablePMCArray"
    push $P1918, $P1917
    .return ($P1918)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("185_1306916577.75068")
    .param pmc param_1920
.annotate 'line', 815
    .lex "self", param_1920
    $P1921 = param_1920."!protoregex"("scope_declarator")
    .return ($P1921)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("186_1306916577.75068")
    .param pmc param_1923
.annotate 'line', 815
    .lex "self", param_1923
    $P1924 = param_1923."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1924)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("187_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1926_tgt
    .local int rx1926_pos
    .local int rx1926_off
    .local int rx1926_eos
    .local int rx1926_rep
    .local pmc rx1926_cur
    .local pmc rx1926_debug
    (rx1926_cur, rx1926_pos, rx1926_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1926_cur
    .local pmc match
    .lex "$/", match
    length rx1926_eos, rx1926_tgt
    gt rx1926_pos, rx1926_eos, rx1926_done
    set rx1926_off, 0
    lt rx1926_pos, 2, rx1926_start
    sub rx1926_off, rx1926_pos, 1
    substr rx1926_tgt, rx1926_tgt, rx1926_off
  rx1926_start:
    eq $I10, 1, rx1926_restart
    if_null rx1926_debug, debug_1227
    rx1926_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1927_done
    goto rxscan1927_scan
  rxscan1927_loop:
    (rx1926_pos) = rx1926_cur."from"()
    inc rx1926_pos
    rx1926_cur."!cursor_from"(rx1926_pos)
    ge rx1926_pos, rx1926_eos, rxscan1927_done
  rxscan1927_scan:
    set_addr $I10, rxscan1927_loop
    rx1926_cur."!mark_push"(0, rx1926_pos, $I10)
  rxscan1927_done:
.annotate 'line', 816
  # rx subcapture "sym"
    set_addr $I10, rxcap_1928_fail
    rx1926_cur."!mark_push"(0, rx1926_pos, $I10)
  # rx literal  "my"
    add $I11, rx1926_pos, 2
    gt $I11, rx1926_eos, rx1926_fail
    sub $I11, rx1926_pos, rx1926_off
    substr $S10, rx1926_tgt, $I11, 2
    ne $S10, "my", rx1926_fail
    add rx1926_pos, 2
    set_addr $I10, rxcap_1928_fail
    ($I12, $I11) = rx1926_cur."!mark_peek"($I10)
    rx1926_cur."!cursor_pos"($I11)
    ($P10) = rx1926_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1926_pos, "")
    rx1926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1928_done
  rxcap_1928_fail:
    goto rx1926_fail
  rxcap_1928_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1926_cur."!cursor_pos"(rx1926_pos)
    $P10 = rx1926_cur."scoped"("my")
    unless $P10, rx1926_fail
    rx1926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1926_pos = $P10."pos"()
  # rx pass
    rx1926_cur."!cursor_pass"(rx1926_pos, "scope_declarator:sym<my>")
    if_null rx1926_debug, debug_1228
    rx1926_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1926_pos)
  debug_1228:
    .return (rx1926_cur)
  rx1926_restart:
.annotate 'line', 436
    if_null rx1926_debug, debug_1229
    rx1926_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1229:
  rx1926_fail:
    (rx1926_rep, rx1926_pos, $I10, $P10) = rx1926_cur."!mark_fail"(0)
    lt rx1926_pos, -1, rx1926_done
    eq rx1926_pos, -1, rx1926_fail
    jump $I10
  rx1926_done:
    rx1926_cur."!cursor_fail"()
    if_null rx1926_debug, debug_1230
    rx1926_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1230:
    .return (rx1926_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("188_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1930 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1931, "ResizablePMCArray"
    push $P1931, $P1930
    .return ($P1931)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("189_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1933_tgt
    .local int rx1933_pos
    .local int rx1933_off
    .local int rx1933_eos
    .local int rx1933_rep
    .local pmc rx1933_cur
    .local pmc rx1933_debug
    (rx1933_cur, rx1933_pos, rx1933_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1933_cur
    .local pmc match
    .lex "$/", match
    length rx1933_eos, rx1933_tgt
    gt rx1933_pos, rx1933_eos, rx1933_done
    set rx1933_off, 0
    lt rx1933_pos, 2, rx1933_start
    sub rx1933_off, rx1933_pos, 1
    substr rx1933_tgt, rx1933_tgt, rx1933_off
  rx1933_start:
    eq $I10, 1, rx1933_restart
    if_null rx1933_debug, debug_1231
    rx1933_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1934_done
    goto rxscan1934_scan
  rxscan1934_loop:
    (rx1933_pos) = rx1933_cur."from"()
    inc rx1933_pos
    rx1933_cur."!cursor_from"(rx1933_pos)
    ge rx1933_pos, rx1933_eos, rxscan1934_done
  rxscan1934_scan:
    set_addr $I10, rxscan1934_loop
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  rxscan1934_done:
.annotate 'line', 817
  # rx subcapture "sym"
    set_addr $I10, rxcap_1935_fail
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  # rx literal  "our"
    add $I11, rx1933_pos, 3
    gt $I11, rx1933_eos, rx1933_fail
    sub $I11, rx1933_pos, rx1933_off
    substr $S10, rx1933_tgt, $I11, 3
    ne $S10, "our", rx1933_fail
    add rx1933_pos, 3
    set_addr $I10, rxcap_1935_fail
    ($I12, $I11) = rx1933_cur."!mark_peek"($I10)
    rx1933_cur."!cursor_pos"($I11)
    ($P10) = rx1933_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1933_pos, "")
    rx1933_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1935_done
  rxcap_1935_fail:
    goto rx1933_fail
  rxcap_1935_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1933_cur."!cursor_pos"(rx1933_pos)
    $P10 = rx1933_cur."scoped"("our")
    unless $P10, rx1933_fail
    rx1933_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1933_pos = $P10."pos"()
  # rx pass
    rx1933_cur."!cursor_pass"(rx1933_pos, "scope_declarator:sym<our>")
    if_null rx1933_debug, debug_1232
    rx1933_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1933_pos)
  debug_1232:
    .return (rx1933_cur)
  rx1933_restart:
.annotate 'line', 436
    if_null rx1933_debug, debug_1233
    rx1933_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1233:
  rx1933_fail:
    (rx1933_rep, rx1933_pos, $I10, $P10) = rx1933_cur."!mark_fail"(0)
    lt rx1933_pos, -1, rx1933_done
    eq rx1933_pos, -1, rx1933_fail
    jump $I10
  rx1933_done:
    rx1933_cur."!cursor_fail"()
    if_null rx1933_debug, debug_1234
    rx1933_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1234:
    .return (rx1933_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("190_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1937 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1938, "ResizablePMCArray"
    push $P1938, $P1937
    .return ($P1938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("191_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1940_tgt
    .local int rx1940_pos
    .local int rx1940_off
    .local int rx1940_eos
    .local int rx1940_rep
    .local pmc rx1940_cur
    .local pmc rx1940_debug
    (rx1940_cur, rx1940_pos, rx1940_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1940_cur
    .local pmc match
    .lex "$/", match
    length rx1940_eos, rx1940_tgt
    gt rx1940_pos, rx1940_eos, rx1940_done
    set rx1940_off, 0
    lt rx1940_pos, 2, rx1940_start
    sub rx1940_off, rx1940_pos, 1
    substr rx1940_tgt, rx1940_tgt, rx1940_off
  rx1940_start:
    eq $I10, 1, rx1940_restart
    if_null rx1940_debug, debug_1235
    rx1940_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1941_done
    goto rxscan1941_scan
  rxscan1941_loop:
    (rx1940_pos) = rx1940_cur."from"()
    inc rx1940_pos
    rx1940_cur."!cursor_from"(rx1940_pos)
    ge rx1940_pos, rx1940_eos, rxscan1941_done
  rxscan1941_scan:
    set_addr $I10, rxscan1941_loop
    rx1940_cur."!mark_push"(0, rx1940_pos, $I10)
  rxscan1941_done:
.annotate 'line', 818
  # rx subcapture "sym"
    set_addr $I10, rxcap_1942_fail
    rx1940_cur."!mark_push"(0, rx1940_pos, $I10)
  # rx literal  "has"
    add $I11, rx1940_pos, 3
    gt $I11, rx1940_eos, rx1940_fail
    sub $I11, rx1940_pos, rx1940_off
    substr $S10, rx1940_tgt, $I11, 3
    ne $S10, "has", rx1940_fail
    add rx1940_pos, 3
    set_addr $I10, rxcap_1942_fail
    ($I12, $I11) = rx1940_cur."!mark_peek"($I10)
    rx1940_cur."!cursor_pos"($I11)
    ($P10) = rx1940_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1940_pos, "")
    rx1940_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1942_done
  rxcap_1942_fail:
    goto rx1940_fail
  rxcap_1942_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1940_cur."!cursor_pos"(rx1940_pos)
    $P10 = rx1940_cur."scoped"("has")
    unless $P10, rx1940_fail
    rx1940_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1940_pos = $P10."pos"()
  # rx pass
    rx1940_cur."!cursor_pass"(rx1940_pos, "scope_declarator:sym<has>")
    if_null rx1940_debug, debug_1236
    rx1940_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1940_pos)
  debug_1236:
    .return (rx1940_cur)
  rx1940_restart:
.annotate 'line', 436
    if_null rx1940_debug, debug_1237
    rx1940_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1237:
  rx1940_fail:
    (rx1940_rep, rx1940_pos, $I10, $P10) = rx1940_cur."!mark_fail"(0)
    lt rx1940_pos, -1, rx1940_done
    eq rx1940_pos, -1, rx1940_fail
    jump $I10
  rx1940_done:
    rx1940_cur."!cursor_fail"()
    if_null rx1940_debug, debug_1238
    rx1940_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1238:
    .return (rx1940_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("192_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1944 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1945, "ResizablePMCArray"
    push $P1945, $P1944
    .return ($P1945)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("193_1306916577.75068") :method :outer("40_1306916577.75068")
    .param pmc param_1947
.annotate 'line', 820
    .lex "$*SCOPE", param_1947
.annotate 'line', 436
    .local string rx1948_tgt
    .local int rx1948_pos
    .local int rx1948_off
    .local int rx1948_eos
    .local int rx1948_rep
    .local pmc rx1948_cur
    .local pmc rx1948_debug
    (rx1948_cur, rx1948_pos, rx1948_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1948_cur
    .local pmc match
    .lex "$/", match
    length rx1948_eos, rx1948_tgt
    gt rx1948_pos, rx1948_eos, rx1948_done
    set rx1948_off, 0
    lt rx1948_pos, 2, rx1948_start
    sub rx1948_off, rx1948_pos, 1
    substr rx1948_tgt, rx1948_tgt, rx1948_off
  rx1948_start:
    eq $I10, 1, rx1948_restart
    if_null rx1948_debug, debug_1239
    rx1948_cur."!cursor_debug"("START", "scoped")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1949_done
    goto rxscan1949_scan
  rxscan1949_loop:
    (rx1948_pos) = rx1948_cur."from"()
    inc rx1948_pos
    rx1948_cur."!cursor_from"(rx1948_pos)
    ge rx1948_pos, rx1948_eos, rxscan1949_done
  rxscan1949_scan:
    set_addr $I10, rxscan1949_loop
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
  rxscan1949_done:
  alt1950_0:
.annotate 'line', 820
    set_addr $I10, alt1950_1
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
.annotate 'line', 821
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."declarator"()
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
    goto alt1950_end
  alt1950_1:
    set_addr $I10, alt1950_2
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
.annotate 'line', 822
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."multi_declarator"()
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
    goto alt1950_end
  alt1950_2:
.annotate 'line', 823
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."package_declarator"()
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  alt1950_end:
.annotate 'line', 820
  # rx pass
    rx1948_cur."!cursor_pass"(rx1948_pos, "scoped")
    if_null rx1948_debug, debug_1240
    rx1948_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1948_pos)
  debug_1240:
    .return (rx1948_cur)
  rx1948_restart:
.annotate 'line', 436
    if_null rx1948_debug, debug_1241
    rx1948_cur."!cursor_debug"("NEXT", "scoped")
  debug_1241:
  rx1948_fail:
    (rx1948_rep, rx1948_pos, $I10, $P10) = rx1948_cur."!mark_fail"(0)
    lt rx1948_pos, -1, rx1948_done
    eq rx1948_pos, -1, rx1948_fail
    jump $I10
  rx1948_done:
    rx1948_cur."!cursor_fail"()
    if_null rx1948_debug, debug_1242
    rx1948_cur."!cursor_debug"("FAIL", "scoped")
  debug_1242:
    .return (rx1948_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("194_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1958 = self."!PREFIX__!subrule"("ws", "")
    $P1959 = self."!PREFIX__!subrule"("ws", "")
    $P1960 = self."!PREFIX__!subrule"("ws", "")
    new $P1961, "ResizablePMCArray"
    push $P1961, $P1958
    push $P1961, $P1959
    push $P1961, $P1960
    .return ($P1961)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("195_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P1968 = "196_1306916577.75068" 
    capture_lex $P1968
    .local string rx1963_tgt
    .local int rx1963_pos
    .local int rx1963_off
    .local int rx1963_eos
    .local int rx1963_rep
    .local pmc rx1963_cur
    .local pmc rx1963_debug
    (rx1963_cur, rx1963_pos, rx1963_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1963_cur
    .local pmc match
    .lex "$/", match
    length rx1963_eos, rx1963_tgt
    gt rx1963_pos, rx1963_eos, rx1963_done
    set rx1963_off, 0
    lt rx1963_pos, 2, rx1963_start
    sub rx1963_off, rx1963_pos, 1
    substr rx1963_tgt, rx1963_tgt, rx1963_off
  rx1963_start:
    eq $I10, 1, rx1963_restart
    if_null rx1963_debug, debug_1243
    rx1963_cur."!cursor_debug"("START", "typename")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1964_done
    goto rxscan1964_scan
  rxscan1964_loop:
    (rx1963_pos) = rx1963_cur."from"()
    inc rx1963_pos
    rx1963_cur."!cursor_from"(rx1963_pos)
    ge rx1963_pos, rx1963_eos, rxscan1964_done
  rxscan1964_scan:
    set_addr $I10, rxscan1964_loop
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  rxscan1964_done:
.annotate 'line', 827
  # rx subrule "name" subtype=capture negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."name"()
    unless $P10, rx1963_fail
    rx1963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1963_pos = $P10."pos"()
.annotate 'line', 828
    rx1963_cur."!cursor_pos"(rx1963_pos)
    find_lex $P1965, unicode:"$\x{a2}"
    $P1966 = $P1965."MATCH"()
    store_lex "$/", $P1966
    .const 'Sub' $P1968 = "196_1306916577.75068" 
    capture_lex $P1968
    $P1977 = $P1968()
    unless $P1977, rx1963_fail
.annotate 'line', 826
  # rx pass
    rx1963_cur."!cursor_pass"(rx1963_pos, "typename")
    if_null rx1963_debug, debug_1250
    rx1963_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1963_pos)
  debug_1250:
    .return (rx1963_cur)
  rx1963_restart:
.annotate 'line', 436
    if_null rx1963_debug, debug_1251
    rx1963_cur."!cursor_debug"("NEXT", "typename")
  debug_1251:
  rx1963_fail:
    (rx1963_rep, rx1963_pos, $I10, $P10) = rx1963_cur."!mark_fail"(0)
    lt rx1963_pos, -1, rx1963_done
    eq rx1963_pos, -1, rx1963_fail
    jump $I10
  rx1963_done:
    rx1963_cur."!cursor_fail"()
    if_null rx1963_debug, debug_1252
    rx1963_cur."!cursor_debug"("FAIL", "typename")
  debug_1252:
    .return (rx1963_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1967"  :anon :subid("196_1306916577.75068") :outer("195_1306916577.75068")
.annotate 'line', 828
    find_dynamic_lex $P1971, "$*ACTIONS"
    unless_null $P1971, vivify_1244
    get_hll_global $P1969, "GLOBAL"
    get_who $P1970, $P1969
    set $P1971, $P1970["$ACTIONS"]
    unless_null $P1971, vivify_1245
    die "Contextual $*ACTIONS not found"
  vivify_1245:
  vivify_1244:
    find_lex $P1972, "$/"
    unless_null $P1972, vivify_1246
    new $P1972, "Undef"
  vivify_1246:
    find_lex $P1973, "$/"
    unless_null $P1973, vivify_1247
    $P1973 = root_new ['parrot';'Hash']
  vivify_1247:
    set $P1974, $P1973["name"]
    unless_null $P1974, vivify_1248
    $P1974 = root_new ['parrot';'Hash']
  vivify_1248:
    set $P1975, $P1974["identifier"]
    unless_null $P1975, vivify_1249
    new $P1975, "Undef"
  vivify_1249:
    $P1976 = $P1971."known_sym"($P1972, $P1975)
    .return ($P1976)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("197_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1979 = self."!PREFIX__!subrule"("name", "")
    new $P1980, "ResizablePMCArray"
    push $P1980, $P1979
    .return ($P1980)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("198_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx1982_tgt
    .local int rx1982_pos
    .local int rx1982_off
    .local int rx1982_eos
    .local int rx1982_rep
    .local pmc rx1982_cur
    .local pmc rx1982_debug
    (rx1982_cur, rx1982_pos, rx1982_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1982_cur
    .local pmc match
    .lex "$/", match
    length rx1982_eos, rx1982_tgt
    gt rx1982_pos, rx1982_eos, rx1982_done
    set rx1982_off, 0
    lt rx1982_pos, 2, rx1982_start
    sub rx1982_off, rx1982_pos, 1
    substr rx1982_tgt, rx1982_tgt, rx1982_off
  rx1982_start:
    eq $I10, 1, rx1982_restart
    if_null rx1982_debug, debug_1253
    rx1982_cur."!cursor_debug"("START", "declarator")
  debug_1253:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1983_done
    goto rxscan1983_scan
  rxscan1983_loop:
    (rx1982_pos) = rx1982_cur."from"()
    inc rx1982_pos
    rx1982_cur."!cursor_from"(rx1982_pos)
    ge rx1982_pos, rx1982_eos, rxscan1983_done
  rxscan1983_scan:
    set_addr $I10, rxscan1983_loop
    rx1982_cur."!mark_push"(0, rx1982_pos, $I10)
  rxscan1983_done:
  alt1984_0:
.annotate 'line', 831
    set_addr $I10, alt1984_1
    rx1982_cur."!mark_push"(0, rx1982_pos, $I10)
.annotate 'line', 832
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1982_cur."!cursor_pos"(rx1982_pos)
    $P10 = rx1982_cur."variable_declarator"()
    unless $P10, rx1982_fail
    rx1982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1982_pos = $P10."pos"()
    goto alt1984_end
  alt1984_1:
.annotate 'line', 833
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1982_cur."!cursor_pos"(rx1982_pos)
    $P10 = rx1982_cur."routine_declarator"()
    unless $P10, rx1982_fail
    rx1982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1982_pos = $P10."pos"()
  alt1984_end:
.annotate 'line', 831
  # rx pass
    rx1982_cur."!cursor_pass"(rx1982_pos, "declarator")
    if_null rx1982_debug, debug_1254
    rx1982_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1982_pos)
  debug_1254:
    .return (rx1982_cur)
  rx1982_restart:
.annotate 'line', 436
    if_null rx1982_debug, debug_1255
    rx1982_cur."!cursor_debug"("NEXT", "declarator")
  debug_1255:
  rx1982_fail:
    (rx1982_rep, rx1982_pos, $I10, $P10) = rx1982_cur."!mark_fail"(0)
    lt rx1982_pos, -1, rx1982_done
    eq rx1982_pos, -1, rx1982_fail
    jump $I10
  rx1982_done:
    rx1982_cur."!cursor_fail"()
    if_null rx1982_debug, debug_1256
    rx1982_cur."!cursor_debug"("FAIL", "declarator")
  debug_1256:
    .return (rx1982_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("199_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P1986 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1987 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1988, "ResizablePMCArray"
    push $P1988, $P1986
    push $P1988, $P1987
    .return ($P1988)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("200_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P2003 = "201_1306916577.75068" 
    capture_lex $P2003
.annotate 'line', 838
    new $P1990, "Undef"
    .lex "$*IN_DECL", $P1990
.annotate 'line', 436
    .local string rx1991_tgt
    .local int rx1991_pos
    .local int rx1991_off
    .local int rx1991_eos
    .local int rx1991_rep
    .local pmc rx1991_cur
    .local pmc rx1991_debug
    (rx1991_cur, rx1991_pos, rx1991_tgt, $I10) = self."!cursor_start"()
    rx1991_cur."!cursor_caparray"("typename", "trait")
    .lex unicode:"$\x{a2}", rx1991_cur
    .local pmc match
    .lex "$/", match
    length rx1991_eos, rx1991_tgt
    gt rx1991_pos, rx1991_eos, rx1991_done
    set rx1991_off, 0
    lt rx1991_pos, 2, rx1991_start
    sub rx1991_off, rx1991_pos, 1
    substr rx1991_tgt, rx1991_tgt, rx1991_off
  rx1991_start:
    eq $I10, 1, rx1991_restart
    if_null rx1991_debug, debug_1257
    rx1991_cur."!cursor_debug"("START", "variable_declarator")
  debug_1257:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1992_done
    goto rxscan1992_scan
  rxscan1992_loop:
    (rx1991_pos) = rx1991_cur."from"()
    inc rx1991_pos
    rx1991_cur."!cursor_from"(rx1991_pos)
    ge rx1991_pos, rx1991_eos, rxscan1992_done
  rxscan1992_scan:
    set_addr $I10, rxscan1992_loop
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  rxscan1992_done:
.annotate 'line', 836
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 837
  # rx rxquantr1994 ** 0..1
    set_addr $I10, rxquantr1994_done
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  rxquantr1994_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."typename"()
    unless $P10, rx1991_fail
    goto rxsubrule1995_pass
  rxsubrule1995_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1991_fail
  rxsubrule1995_pass:
    set_addr $I10, rxsubrule1995_back
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1991_pos = $P10."pos"()
    set_addr $I10, rxquantr1994_done
    (rx1991_rep) = rx1991_cur."!mark_commit"($I10)
  rxquantr1994_done:
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 838
    rx1991_cur."!cursor_pos"(rx1991_pos)
    new $P1997, "String"
    assign $P1997, "variable"
    store_lex "$*IN_DECL", $P1997
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 839
  # rx subrule "variable" subtype=capture negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."variable"()
    unless $P10, rx1991_fail
    rx1991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1991_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 840
    rx1991_cur."!cursor_pos"(rx1991_pos)
    find_lex $P2000, unicode:"$\x{a2}"
    $P2001 = $P2000."MATCH"()
    store_lex "$/", $P2001
    .const 'Sub' $P2003 = "201_1306916577.75068" 
    capture_lex $P2003
    $P2005 = $P2003()
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 841
  # rx rxquantr2007 ** 0..*
    set_addr $I10, rxquantr2007_done
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  rxquantr2007_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."trait"()
    unless $P10, rx1991_fail
    goto rxsubrule2008_pass
  rxsubrule2008_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1991_fail
  rxsubrule2008_pass:
    set_addr $I10, rxsubrule2008_back
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1991_pos = $P10."pos"()
    set_addr $I10, rxquantr2007_done
    (rx1991_rep) = rx1991_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2007_done
    rx1991_cur."!mark_push"(rx1991_rep, rx1991_pos, $I10)
    goto rxquantr2007_loop
  rxquantr2007_done:
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 836
  # rx pass
    rx1991_cur."!cursor_pass"(rx1991_pos, "variable_declarator")
    if_null rx1991_debug, debug_1258
    rx1991_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1991_pos)
  debug_1258:
    .return (rx1991_cur)
  rx1991_restart:
.annotate 'line', 436
    if_null rx1991_debug, debug_1259
    rx1991_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1259:
  rx1991_fail:
    (rx1991_rep, rx1991_pos, $I10, $P10) = rx1991_cur."!mark_fail"(0)
    lt rx1991_pos, -1, rx1991_done
    eq rx1991_pos, -1, rx1991_fail
    jump $I10
  rx1991_done:
    rx1991_cur."!cursor_fail"()
    if_null rx1991_debug, debug_1260
    rx1991_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1260:
    .return (rx1991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2002"  :anon :subid("201_1306916577.75068") :outer("200_1306916577.75068")
.annotate 'line', 840
    new $P2004, "Integer"
    assign $P2004, 0
    store_dynamic_lex "$*IN_DECL", $P2004
    .return ($P2004)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("202_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2011 = self."!PREFIX__!subrule"("ws", "")
    new $P2012, "ResizablePMCArray"
    push $P2012, $P2011
    .return ($P2012)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("203_1306916577.75068")
    .param pmc param_2014
.annotate 'line', 844
    .lex "self", param_2014
    $P2015 = param_2014."!protoregex"("routine_declarator")
    .return ($P2015)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("204_1306916577.75068")
    .param pmc param_2017
.annotate 'line', 844
    .lex "self", param_2017
    $P2018 = param_2017."!PREFIX__!protoregex"("routine_declarator")
    .return ($P2018)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("205_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2020_tgt
    .local int rx2020_pos
    .local int rx2020_off
    .local int rx2020_eos
    .local int rx2020_rep
    .local pmc rx2020_cur
    .local pmc rx2020_debug
    (rx2020_cur, rx2020_pos, rx2020_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2020_cur
    .local pmc match
    .lex "$/", match
    length rx2020_eos, rx2020_tgt
    gt rx2020_pos, rx2020_eos, rx2020_done
    set rx2020_off, 0
    lt rx2020_pos, 2, rx2020_start
    sub rx2020_off, rx2020_pos, 1
    substr rx2020_tgt, rx2020_tgt, rx2020_off
  rx2020_start:
    eq $I10, 1, rx2020_restart
    if_null rx2020_debug, debug_1261
    rx2020_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1261:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2021_done
    goto rxscan2021_scan
  rxscan2021_loop:
    (rx2020_pos) = rx2020_cur."from"()
    inc rx2020_pos
    rx2020_cur."!cursor_from"(rx2020_pos)
    ge rx2020_pos, rx2020_eos, rxscan2021_done
  rxscan2021_scan:
    set_addr $I10, rxscan2021_loop
    rx2020_cur."!mark_push"(0, rx2020_pos, $I10)
  rxscan2021_done:
.annotate 'line', 845
  # rx subcapture "sym"
    set_addr $I10, rxcap_2022_fail
    rx2020_cur."!mark_push"(0, rx2020_pos, $I10)
  # rx literal  "sub"
    add $I11, rx2020_pos, 3
    gt $I11, rx2020_eos, rx2020_fail
    sub $I11, rx2020_pos, rx2020_off
    substr $S10, rx2020_tgt, $I11, 3
    ne $S10, "sub", rx2020_fail
    add rx2020_pos, 3
    set_addr $I10, rxcap_2022_fail
    ($I12, $I11) = rx2020_cur."!mark_peek"($I10)
    rx2020_cur."!cursor_pos"($I11)
    ($P10) = rx2020_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2020_pos, "")
    rx2020_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2022_done
  rxcap_2022_fail:
    goto rx2020_fail
  rxcap_2022_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx2020_cur."!cursor_pos"(rx2020_pos)
    $P10 = rx2020_cur."routine_def"()
    unless $P10, rx2020_fail
    rx2020_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2020_pos = $P10."pos"()
  # rx pass
    rx2020_cur."!cursor_pass"(rx2020_pos, "routine_declarator:sym<sub>")
    if_null rx2020_debug, debug_1262
    rx2020_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx2020_pos)
  debug_1262:
    .return (rx2020_cur)
  rx2020_restart:
.annotate 'line', 436
    if_null rx2020_debug, debug_1263
    rx2020_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1263:
  rx2020_fail:
    (rx2020_rep, rx2020_pos, $I10, $P10) = rx2020_cur."!mark_fail"(0)
    lt rx2020_pos, -1, rx2020_done
    eq rx2020_pos, -1, rx2020_fail
    jump $I10
  rx2020_done:
    rx2020_cur."!cursor_fail"()
    if_null rx2020_debug, debug_1264
    rx2020_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1264:
    .return (rx2020_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("206_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2024 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P2025, "ResizablePMCArray"
    push $P2025, $P2024
    .return ($P2025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("207_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2027_tgt
    .local int rx2027_pos
    .local int rx2027_off
    .local int rx2027_eos
    .local int rx2027_rep
    .local pmc rx2027_cur
    .local pmc rx2027_debug
    (rx2027_cur, rx2027_pos, rx2027_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2027_cur
    .local pmc match
    .lex "$/", match
    length rx2027_eos, rx2027_tgt
    gt rx2027_pos, rx2027_eos, rx2027_done
    set rx2027_off, 0
    lt rx2027_pos, 2, rx2027_start
    sub rx2027_off, rx2027_pos, 1
    substr rx2027_tgt, rx2027_tgt, rx2027_off
  rx2027_start:
    eq $I10, 1, rx2027_restart
    if_null rx2027_debug, debug_1265
    rx2027_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1265:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2028_done
    goto rxscan2028_scan
  rxscan2028_loop:
    (rx2027_pos) = rx2027_cur."from"()
    inc rx2027_pos
    rx2027_cur."!cursor_from"(rx2027_pos)
    ge rx2027_pos, rx2027_eos, rxscan2028_done
  rxscan2028_scan:
    set_addr $I10, rxscan2028_loop
    rx2027_cur."!mark_push"(0, rx2027_pos, $I10)
  rxscan2028_done:
.annotate 'line', 846
  # rx subcapture "sym"
    set_addr $I10, rxcap_2029_fail
    rx2027_cur."!mark_push"(0, rx2027_pos, $I10)
  # rx literal  "method"
    add $I11, rx2027_pos, 6
    gt $I11, rx2027_eos, rx2027_fail
    sub $I11, rx2027_pos, rx2027_off
    substr $S10, rx2027_tgt, $I11, 6
    ne $S10, "method", rx2027_fail
    add rx2027_pos, 6
    set_addr $I10, rxcap_2029_fail
    ($I12, $I11) = rx2027_cur."!mark_peek"($I10)
    rx2027_cur."!cursor_pos"($I11)
    ($P10) = rx2027_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2027_pos, "")
    rx2027_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2029_done
  rxcap_2029_fail:
    goto rx2027_fail
  rxcap_2029_done:
  # rx subrule "method_def" subtype=capture negate=
    rx2027_cur."!cursor_pos"(rx2027_pos)
    $P10 = rx2027_cur."method_def"()
    unless $P10, rx2027_fail
    rx2027_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx2027_pos = $P10."pos"()
  # rx pass
    rx2027_cur."!cursor_pass"(rx2027_pos, "routine_declarator:sym<method>")
    if_null rx2027_debug, debug_1266
    rx2027_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx2027_pos)
  debug_1266:
    .return (rx2027_cur)
  rx2027_restart:
.annotate 'line', 436
    if_null rx2027_debug, debug_1267
    rx2027_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1267:
  rx2027_fail:
    (rx2027_rep, rx2027_pos, $I10, $P10) = rx2027_cur."!mark_fail"(0)
    lt rx2027_pos, -1, rx2027_done
    eq rx2027_pos, -1, rx2027_fail
    jump $I10
  rx2027_done:
    rx2027_cur."!cursor_fail"()
    if_null rx2027_debug, debug_1268
    rx2027_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1268:
    .return (rx2027_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("208_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2031 = self."!PREFIX__!subrule"("method_def", "method")
    new $P2032, "ResizablePMCArray"
    push $P2032, $P2031
    .return ($P2032)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("209_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 849
    new $P2034, "Undef"
    .lex "$*RETURN_USED", $P2034
.annotate 'line', 436
    .local string rx2035_tgt
    .local int rx2035_pos
    .local int rx2035_off
    .local int rx2035_eos
    .local int rx2035_rep
    .local pmc rx2035_cur
    .local pmc rx2035_debug
    (rx2035_cur, rx2035_pos, rx2035_tgt, $I10) = self."!cursor_start"()
    rx2035_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx2035_cur
    .local pmc match
    .lex "$/", match
    length rx2035_eos, rx2035_tgt
    gt rx2035_pos, rx2035_eos, rx2035_done
    set rx2035_off, 0
    lt rx2035_pos, 2, rx2035_start
    sub rx2035_off, rx2035_pos, 1
    substr rx2035_tgt, rx2035_tgt, rx2035_off
  rx2035_start:
    eq $I10, 1, rx2035_restart
    if_null rx2035_debug, debug_1269
    rx2035_cur."!cursor_debug"("START", "routine_def")
  debug_1269:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2036_done
    goto rxscan2036_scan
  rxscan2036_loop:
    (rx2035_pos) = rx2035_cur."from"()
    inc rx2035_pos
    rx2035_cur."!cursor_from"(rx2035_pos)
    ge rx2035_pos, rx2035_eos, rxscan2036_done
  rxscan2036_scan:
    set_addr $I10, rxscan2036_loop
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxscan2036_done:
.annotate 'line', 848
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 849
    rx2035_cur."!cursor_pos"(rx2035_pos)
    new $P2038, "Integer"
    assign $P2038, 0
    store_lex "$*RETURN_USED", $P2038
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 850
  # rx rxquantr2040 ** 0..1
    set_addr $I10, rxquantr2040_done
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxquantr2040_loop:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_2043_fail
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  # rx rxquantr2042 ** 0..1
    set_addr $I10, rxquantr2042_done
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxquantr2042_loop:
  # rx literal  "&"
    add $I11, rx2035_pos, 1
    gt $I11, rx2035_eos, rx2035_fail
    sub $I11, rx2035_pos, rx2035_off
    ord $I11, rx2035_tgt, $I11
    ne $I11, 38, rx2035_fail
    add rx2035_pos, 1
    set_addr $I10, rxquantr2042_done
    (rx2035_rep) = rx2035_cur."!mark_commit"($I10)
  rxquantr2042_done:
    set_addr $I10, rxcap_2043_fail
    ($I12, $I11) = rx2035_cur."!mark_peek"($I10)
    rx2035_cur."!cursor_pos"($I11)
    ($P10) = rx2035_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2035_pos, "")
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_2043_done
  rxcap_2043_fail:
    goto rx2035_fail
  rxcap_2043_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."deflongname"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
    set_addr $I10, rxquantr2040_done
    (rx2035_rep) = rx2035_cur."!mark_commit"($I10)
  rxquantr2040_done:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 851
  # rx subrule "newpad" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."newpad"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2047_0:
.annotate 'line', 852
    set_addr $I10, alt2047_1
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2035_pos, 1
    gt $I11, rx2035_eos, rx2035_fail
    sub $I11, rx2035_pos, rx2035_off
    ord $I11, rx2035_tgt, $I11
    ne $I11, 40, rx2035_fail
    add rx2035_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."signature"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2035_pos, 1
    gt $I11, rx2035_eos, rx2035_fail
    sub $I11, rx2035_pos, rx2035_off
    ord $I11, rx2035_tgt, $I11
    ne $I11, 41, rx2035_fail
    add rx2035_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
    goto alt2047_end
  alt2047_1:
.annotate 'line', 853
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2047_end:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 854
  # rx rxquantr2055 ** 0..*
    set_addr $I10, rxquantr2055_done
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxquantr2055_loop:
  # rx subrule "trait" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."trait"()
    unless $P10, rx2035_fail
    goto rxsubrule2056_pass
  rxsubrule2056_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2035_fail
  rxsubrule2056_pass:
    set_addr $I10, rxsubrule2056_back
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx2035_pos = $P10."pos"()
    set_addr $I10, rxquantr2055_done
    (rx2035_rep) = rx2035_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2055_done
    rx2035_cur."!mark_push"(rx2035_rep, rx2035_pos, $I10)
    goto rxquantr2055_loop
  rxquantr2055_done:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2058_0:
.annotate 'line', 855
    set_addr $I10, alt2058_1
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
.annotate 'line', 856
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."onlystar"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
    goto alt2058_end
  alt2058_1:
.annotate 'line', 857
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."blockoid"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2058_end:
.annotate 'line', 858
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 848
  # rx pass
    rx2035_cur."!cursor_pass"(rx2035_pos, "routine_def")
    if_null rx2035_debug, debug_1270
    rx2035_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx2035_pos)
  debug_1270:
    .return (rx2035_cur)
  rx2035_restart:
.annotate 'line', 436
    if_null rx2035_debug, debug_1271
    rx2035_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1271:
  rx2035_fail:
    (rx2035_rep, rx2035_pos, $I10, $P10) = rx2035_cur."!mark_fail"(0)
    lt rx2035_pos, -1, rx2035_done
    eq rx2035_pos, -1, rx2035_fail
    jump $I10
  rx2035_done:
    rx2035_cur."!cursor_fail"()
    if_null rx2035_debug, debug_1272
    rx2035_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1272:
    .return (rx2035_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("210_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2065 = self."!PREFIX__!subrule"("ws", "")
    new $P2066, "ResizablePMCArray"
    push $P2066, $P2065
    .return ($P2066)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("211_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P2095 = "212_1306916577.75068" 
    capture_lex $P2095
.annotate 'line', 862
    new $P2068, "Undef"
    .lex "$*RETURN_USED", $P2068
.annotate 'line', 863
    new $P2069, "Undef"
    .lex "$*INVOCANT_OK", $P2069
.annotate 'line', 436
    .local string rx2070_tgt
    .local int rx2070_pos
    .local int rx2070_off
    .local int rx2070_eos
    .local int rx2070_rep
    .local pmc rx2070_cur
    .local pmc rx2070_debug
    (rx2070_cur, rx2070_pos, rx2070_tgt, $I10) = self."!cursor_start"()
    rx2070_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx2070_cur
    .local pmc match
    .lex "$/", match
    length rx2070_eos, rx2070_tgt
    gt rx2070_pos, rx2070_eos, rx2070_done
    set rx2070_off, 0
    lt rx2070_pos, 2, rx2070_start
    sub rx2070_off, rx2070_pos, 1
    substr rx2070_tgt, rx2070_tgt, rx2070_off
  rx2070_start:
    eq $I10, 1, rx2070_restart
    if_null rx2070_debug, debug_1273
    rx2070_cur."!cursor_debug"("START", "method_def")
  debug_1273:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2071_done
    goto rxscan2071_scan
  rxscan2071_loop:
    (rx2070_pos) = rx2070_cur."from"()
    inc rx2070_pos
    rx2070_cur."!cursor_from"(rx2070_pos)
    ge rx2070_pos, rx2070_eos, rxscan2071_done
  rxscan2071_scan:
    set_addr $I10, rxscan2071_loop
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxscan2071_done:
.annotate 'line', 861
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 862
    rx2070_cur."!cursor_pos"(rx2070_pos)
    new $P2073, "Integer"
    assign $P2073, 0
    store_lex "$*RETURN_USED", $P2073
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 863
    rx2070_cur."!cursor_pos"(rx2070_pos)
    new $P2075, "Integer"
    assign $P2075, 1
    store_lex "$*INVOCANT_OK", $P2075
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 864
  # rx subcapture "private"
    set_addr $I10, rxcap_2078_fail
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  # rx rxquantr2077 ** 0..1
    set_addr $I10, rxquantr2077_done
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxquantr2077_loop:
  # rx literal  "!"
    add $I11, rx2070_pos, 1
    gt $I11, rx2070_eos, rx2070_fail
    sub $I11, rx2070_pos, rx2070_off
    ord $I11, rx2070_tgt, $I11
    ne $I11, 33, rx2070_fail
    add rx2070_pos, 1
    set_addr $I10, rxquantr2077_done
    (rx2070_rep) = rx2070_cur."!mark_commit"($I10)
  rxquantr2077_done:
    set_addr $I10, rxcap_2078_fail
    ($I12, $I11) = rx2070_cur."!mark_peek"($I10)
    rx2070_cur."!cursor_pos"($I11)
    ($P10) = rx2070_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2070_pos, "")
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_2078_done
  rxcap_2078_fail:
    goto rx2070_fail
  rxcap_2078_done:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 865
  # rx rxquantr2080 ** 0..1
    set_addr $I10, rxquantr2080_done
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxquantr2080_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."deflongname"()
    unless $P10, rx2070_fail
    goto rxsubrule2081_pass
  rxsubrule2081_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2070_fail
  rxsubrule2081_pass:
    set_addr $I10, rxsubrule2081_back
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx2070_pos = $P10."pos"()
    set_addr $I10, rxquantr2080_done
    (rx2070_rep) = rx2070_cur."!mark_commit"($I10)
  rxquantr2080_done:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 866
  # rx subrule "newpad" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."newpad"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2084_0:
.annotate 'line', 867
    set_addr $I10, alt2084_1
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2070_pos, 1
    gt $I11, rx2070_eos, rx2070_fail
    sub $I11, rx2070_pos, rx2070_off
    ord $I11, rx2070_tgt, $I11
    ne $I11, 40, rx2070_fail
    add rx2070_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."signature"()
    unless $P10, rx2070_fail
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2070_pos, 1
    gt $I11, rx2070_eos, rx2070_fail
    sub $I11, rx2070_pos, rx2070_off
    ord $I11, rx2070_tgt, $I11
    ne $I11, 41, rx2070_fail
    add rx2070_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
    goto alt2084_end
  alt2084_1:
.annotate 'line', 868
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2084_end:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 869
    rx2070_cur."!cursor_pos"(rx2070_pos)
    find_lex $P2092, unicode:"$\x{a2}"
    $P2093 = $P2092."MATCH"()
    store_lex "$/", $P2093
    .const 'Sub' $P2095 = "212_1306916577.75068" 
    capture_lex $P2095
    $P2097 = $P2095()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 870
  # rx rxquantr2099 ** 0..*
    set_addr $I10, rxquantr2099_done
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxquantr2099_loop:
  # rx subrule "trait" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."trait"()
    unless $P10, rx2070_fail
    goto rxsubrule2100_pass
  rxsubrule2100_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2070_fail
  rxsubrule2100_pass:
    set_addr $I10, rxsubrule2100_back
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx2070_pos = $P10."pos"()
    set_addr $I10, rxquantr2099_done
    (rx2070_rep) = rx2070_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2099_done
    rx2070_cur."!mark_push"(rx2070_rep, rx2070_pos, $I10)
    goto rxquantr2099_loop
  rxquantr2099_done:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2102_0:
.annotate 'line', 871
    set_addr $I10, alt2102_1
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
.annotate 'line', 872
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."onlystar"()
    unless $P10, rx2070_fail
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
    goto alt2102_end
  alt2102_1:
.annotate 'line', 873
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."blockoid"()
    unless $P10, rx2070_fail
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2102_end:
.annotate 'line', 874
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 861
  # rx pass
    rx2070_cur."!cursor_pass"(rx2070_pos, "method_def")
    if_null rx2070_debug, debug_1274
    rx2070_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx2070_pos)
  debug_1274:
    .return (rx2070_cur)
  rx2070_restart:
.annotate 'line', 436
    if_null rx2070_debug, debug_1275
    rx2070_cur."!cursor_debug"("NEXT", "method_def")
  debug_1275:
  rx2070_fail:
    (rx2070_rep, rx2070_pos, $I10, $P10) = rx2070_cur."!mark_fail"(0)
    lt rx2070_pos, -1, rx2070_done
    eq rx2070_pos, -1, rx2070_fail
    jump $I10
  rx2070_done:
    rx2070_cur."!cursor_fail"()
    if_null rx2070_debug, debug_1276
    rx2070_cur."!cursor_debug"("FAIL", "method_def")
  debug_1276:
    .return (rx2070_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2094"  :anon :subid("212_1306916577.75068") :outer("211_1306916577.75068")
.annotate 'line', 869
    new $P2096, "Integer"
    assign $P2096, 0
    store_dynamic_lex "$*INVOCANT_OK", $P2096
    .return ($P2096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("213_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2109 = self."!PREFIX__!subrule"("ws", "")
    new $P2110, "ResizablePMCArray"
    push $P2110, $P2109
    .return ($P2110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("214_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P2117 = "215_1306916577.75068" 
    capture_lex $P2117
    .local string rx2112_tgt
    .local int rx2112_pos
    .local int rx2112_off
    .local int rx2112_eos
    .local int rx2112_rep
    .local pmc rx2112_cur
    .local pmc rx2112_debug
    (rx2112_cur, rx2112_pos, rx2112_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2112_cur
    .local pmc match
    .lex "$/", match
    length rx2112_eos, rx2112_tgt
    gt rx2112_pos, rx2112_eos, rx2112_done
    set rx2112_off, 0
    lt rx2112_pos, 2, rx2112_start
    sub rx2112_off, rx2112_pos, 1
    substr rx2112_tgt, rx2112_tgt, rx2112_off
  rx2112_start:
    eq $I10, 1, rx2112_restart
    if_null rx2112_debug, debug_1277
    rx2112_cur."!cursor_debug"("START", "onlystar")
  debug_1277:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2113_done
    goto rxscan2113_scan
  rxscan2113_loop:
    (rx2112_pos) = rx2112_cur."from"()
    inc rx2112_pos
    rx2112_cur."!cursor_from"(rx2112_pos)
    ge rx2112_pos, rx2112_eos, rxscan2113_done
  rxscan2113_scan:
    set_addr $I10, rxscan2113_loop
    rx2112_cur."!mark_push"(0, rx2112_pos, $I10)
  rxscan2113_done:
.annotate 'line', 878
    rx2112_cur."!cursor_pos"(rx2112_pos)
    find_lex $P2114, unicode:"$\x{a2}"
    $P2115 = $P2114."MATCH"()
    store_lex "$/", $P2115
    .const 'Sub' $P2117 = "215_1306916577.75068" 
    capture_lex $P2117
    $P2123 = $P2117()
    unless $P2123, rx2112_fail
.annotate 'line', 879
  # rx literal  "{"
    add $I11, rx2112_pos, 1
    gt $I11, rx2112_eos, rx2112_fail
    sub $I11, rx2112_pos, rx2112_off
    ord $I11, rx2112_tgt, $I11
    ne $I11, 123, rx2112_fail
    add rx2112_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."ws"()
    unless $P10, rx2112_fail
    rx2112_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx2112_pos, 1
    gt $I11, rx2112_eos, rx2112_fail
    sub $I11, rx2112_pos, rx2112_off
    ord $I11, rx2112_tgt, $I11
    ne $I11, 42, rx2112_fail
    add rx2112_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."ws"()
    unless $P10, rx2112_fail
    rx2112_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2112_pos, 1
    gt $I11, rx2112_eos, rx2112_fail
    sub $I11, rx2112_pos, rx2112_off
    ord $I11, rx2112_tgt, $I11
    ne $I11, 125, rx2112_fail
    add rx2112_pos, 1
.annotate 'line', 880
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."ENDSTMT"()
    unless $P10, rx2112_fail
.annotate 'line', 881
  # rx subrule "finishpad" subtype=method negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."finishpad"()
    unless $P10, rx2112_fail
    rx2112_pos = $P10."pos"()
.annotate 'line', 877
  # rx pass
    rx2112_cur."!cursor_pass"(rx2112_pos, "onlystar")
    if_null rx2112_debug, debug_1280
    rx2112_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx2112_pos)
  debug_1280:
    .return (rx2112_cur)
  rx2112_restart:
.annotate 'line', 436
    if_null rx2112_debug, debug_1281
    rx2112_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1281:
  rx2112_fail:
    (rx2112_rep, rx2112_pos, $I10, $P10) = rx2112_cur."!mark_fail"(0)
    lt rx2112_pos, -1, rx2112_done
    eq rx2112_pos, -1, rx2112_fail
    jump $I10
  rx2112_done:
    rx2112_cur."!cursor_fail"()
    if_null rx2112_debug, debug_1282
    rx2112_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1282:
    .return (rx2112_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2116"  :anon :subid("215_1306916577.75068") :outer("214_1306916577.75068")
.annotate 'line', 878
    find_dynamic_lex $P2120, "$*MULTINESS"
    unless_null $P2120, vivify_1278
    get_hll_global $P2118, "GLOBAL"
    get_who $P2119, $P2118
    set $P2120, $P2119["$MULTINESS"]
    unless_null $P2120, vivify_1279
    die "Contextual $*MULTINESS not found"
  vivify_1279:
  vivify_1278:
    set $S2121, $P2120
    iseq $I2122, $S2121, "proto"
    .return ($I2122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("216_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2125, "ResizablePMCArray"
    push $P2125, ""
    .return ($P2125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("217_1306916577.75068")
    .param pmc param_2127
.annotate 'line', 884
    .lex "self", param_2127
    $P2128 = param_2127."!protoregex"("multi_declarator")
    .return ($P2128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("218_1306916577.75068")
    .param pmc param_2130
.annotate 'line', 884
    .lex "self", param_2130
    $P2131 = param_2130."!PREFIX__!protoregex"("multi_declarator")
    .return ($P2131)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("219_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 886
    new $P2133, "Undef"
    .lex "$*MULTINESS", $P2133
.annotate 'line', 436
    .local string rx2134_tgt
    .local int rx2134_pos
    .local int rx2134_off
    .local int rx2134_eos
    .local int rx2134_rep
    .local pmc rx2134_cur
    .local pmc rx2134_debug
    (rx2134_cur, rx2134_pos, rx2134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2134_cur
    .local pmc match
    .lex "$/", match
    length rx2134_eos, rx2134_tgt
    gt rx2134_pos, rx2134_eos, rx2134_done
    set rx2134_off, 0
    lt rx2134_pos, 2, rx2134_start
    sub rx2134_off, rx2134_pos, 1
    substr rx2134_tgt, rx2134_tgt, rx2134_off
  rx2134_start:
    eq $I10, 1, rx2134_restart
    if_null rx2134_debug, debug_1283
    rx2134_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2135_done
    goto rxscan2135_scan
  rxscan2135_loop:
    (rx2134_pos) = rx2134_cur."from"()
    inc rx2134_pos
    rx2134_cur."!cursor_from"(rx2134_pos)
    ge rx2134_pos, rx2134_eos, rxscan2135_done
  rxscan2135_scan:
    set_addr $I10, rxscan2135_loop
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  rxscan2135_done:
.annotate 'line', 886
    rx2134_cur."!cursor_pos"(rx2134_pos)
    new $P2136, "String"
    assign $P2136, "multi"
    store_lex "$*MULTINESS", $P2136
.annotate 'line', 887
  # rx subcapture "sym"
    set_addr $I10, rxcap_2137_fail
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx literal  "multi"
    add $I11, rx2134_pos, 5
    gt $I11, rx2134_eos, rx2134_fail
    sub $I11, rx2134_pos, rx2134_off
    substr $S10, rx2134_tgt, $I11, 5
    ne $S10, "multi", rx2134_fail
    add rx2134_pos, 5
    set_addr $I10, rxcap_2137_fail
    ($I12, $I11) = rx2134_cur."!mark_peek"($I10)
    rx2134_cur."!cursor_pos"($I11)
    ($P10) = rx2134_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2134_pos, "")
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2137_done
  rxcap_2137_fail:
    goto rx2134_fail
  rxcap_2137_done:
.annotate 'line', 888
  # rx subrule "ws" subtype=method negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."ws"()
    unless $P10, rx2134_fail
    rx2134_pos = $P10."pos"()
  alt2138_0:
    set_addr $I10, alt2138_1
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."declarator"()
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2134_pos = $P10."pos"()
    goto alt2138_end
  alt2138_1:
    set_addr $I10, alt2138_2
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."routine_def"()
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2134_pos = $P10."pos"()
    goto alt2138_end
  alt2138_2:
  # rx subrule "panic" subtype=method negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."panic"("Malformed multi")
    unless $P10, rx2134_fail
    rx2134_pos = $P10."pos"()
  alt2138_end:
.annotate 'line', 885
  # rx pass
    rx2134_cur."!cursor_pass"(rx2134_pos, "multi_declarator:sym<multi>")
    if_null rx2134_debug, debug_1284
    rx2134_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx2134_pos)
  debug_1284:
    .return (rx2134_cur)
  rx2134_restart:
.annotate 'line', 436
    if_null rx2134_debug, debug_1285
    rx2134_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1285:
  rx2134_fail:
    (rx2134_rep, rx2134_pos, $I10, $P10) = rx2134_cur."!mark_fail"(0)
    lt rx2134_pos, -1, rx2134_done
    eq rx2134_pos, -1, rx2134_fail
    jump $I10
  rx2134_done:
    rx2134_cur."!cursor_fail"()
    if_null rx2134_debug, debug_1286
    rx2134_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1286:
    .return (rx2134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("220_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2140 = self."!PREFIX__!subrule"("ws", "multi")
    new $P2141, "ResizablePMCArray"
    push $P2141, $P2140
    .return ($P2141)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("221_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 891
    new $P2143, "Undef"
    .lex "$*MULTINESS", $P2143
.annotate 'line', 436
    .local string rx2144_tgt
    .local int rx2144_pos
    .local int rx2144_off
    .local int rx2144_eos
    .local int rx2144_rep
    .local pmc rx2144_cur
    .local pmc rx2144_debug
    (rx2144_cur, rx2144_pos, rx2144_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2144_cur
    .local pmc match
    .lex "$/", match
    length rx2144_eos, rx2144_tgt
    gt rx2144_pos, rx2144_eos, rx2144_done
    set rx2144_off, 0
    lt rx2144_pos, 2, rx2144_start
    sub rx2144_off, rx2144_pos, 1
    substr rx2144_tgt, rx2144_tgt, rx2144_off
  rx2144_start:
    eq $I10, 1, rx2144_restart
    if_null rx2144_debug, debug_1287
    rx2144_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2145_done
    goto rxscan2145_scan
  rxscan2145_loop:
    (rx2144_pos) = rx2144_cur."from"()
    inc rx2144_pos
    rx2144_cur."!cursor_from"(rx2144_pos)
    ge rx2144_pos, rx2144_eos, rxscan2145_done
  rxscan2145_scan:
    set_addr $I10, rxscan2145_loop
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  rxscan2145_done:
.annotate 'line', 891
    rx2144_cur."!cursor_pos"(rx2144_pos)
    new $P2146, "String"
    assign $P2146, "proto"
    store_lex "$*MULTINESS", $P2146
.annotate 'line', 892
  # rx subcapture "sym"
    set_addr $I10, rxcap_2147_fail
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2144_pos, 5
    gt $I11, rx2144_eos, rx2144_fail
    sub $I11, rx2144_pos, rx2144_off
    substr $S10, rx2144_tgt, $I11, 5
    ne $S10, "proto", rx2144_fail
    add rx2144_pos, 5
    set_addr $I10, rxcap_2147_fail
    ($I12, $I11) = rx2144_cur."!mark_peek"($I10)
    rx2144_cur."!cursor_pos"($I11)
    ($P10) = rx2144_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2144_pos, "")
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2147_done
  rxcap_2147_fail:
    goto rx2144_fail
  rxcap_2147_done:
.annotate 'line', 893
  # rx subrule "ws" subtype=method negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."ws"()
    unless $P10, rx2144_fail
    rx2144_pos = $P10."pos"()
  alt2148_0:
    set_addr $I10, alt2148_1
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."declarator"()
    unless $P10, rx2144_fail
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2144_pos = $P10."pos"()
    goto alt2148_end
  alt2148_1:
    set_addr $I10, alt2148_2
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."routine_def"()
    unless $P10, rx2144_fail
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2144_pos = $P10."pos"()
    goto alt2148_end
  alt2148_2:
  # rx subrule "panic" subtype=method negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."panic"("Malformed proto")
    unless $P10, rx2144_fail
    rx2144_pos = $P10."pos"()
  alt2148_end:
.annotate 'line', 890
  # rx pass
    rx2144_cur."!cursor_pass"(rx2144_pos, "multi_declarator:sym<proto>")
    if_null rx2144_debug, debug_1288
    rx2144_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx2144_pos)
  debug_1288:
    .return (rx2144_cur)
  rx2144_restart:
.annotate 'line', 436
    if_null rx2144_debug, debug_1289
    rx2144_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1289:
  rx2144_fail:
    (rx2144_rep, rx2144_pos, $I10, $P10) = rx2144_cur."!mark_fail"(0)
    lt rx2144_pos, -1, rx2144_done
    eq rx2144_pos, -1, rx2144_fail
    jump $I10
  rx2144_done:
    rx2144_cur."!cursor_fail"()
    if_null rx2144_debug, debug_1290
    rx2144_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1290:
    .return (rx2144_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("222_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2150 = self."!PREFIX__!subrule"("ws", "proto")
    new $P2151, "ResizablePMCArray"
    push $P2151, $P2150
    .return ($P2151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("223_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 896
    new $P2153, "Undef"
    .lex "$*MULTINESS", $P2153
.annotate 'line', 436
    .local string rx2154_tgt
    .local int rx2154_pos
    .local int rx2154_off
    .local int rx2154_eos
    .local int rx2154_rep
    .local pmc rx2154_cur
    .local pmc rx2154_debug
    (rx2154_cur, rx2154_pos, rx2154_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2154_cur
    .local pmc match
    .lex "$/", match
    length rx2154_eos, rx2154_tgt
    gt rx2154_pos, rx2154_eos, rx2154_done
    set rx2154_off, 0
    lt rx2154_pos, 2, rx2154_start
    sub rx2154_off, rx2154_pos, 1
    substr rx2154_tgt, rx2154_tgt, rx2154_off
  rx2154_start:
    eq $I10, 1, rx2154_restart
    if_null rx2154_debug, debug_1291
    rx2154_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2155_done
    goto rxscan2155_scan
  rxscan2155_loop:
    (rx2154_pos) = rx2154_cur."from"()
    inc rx2154_pos
    rx2154_cur."!cursor_from"(rx2154_pos)
    ge rx2154_pos, rx2154_eos, rxscan2155_done
  rxscan2155_scan:
    set_addr $I10, rxscan2155_loop
    rx2154_cur."!mark_push"(0, rx2154_pos, $I10)
  rxscan2155_done:
.annotate 'line', 896
    rx2154_cur."!cursor_pos"(rx2154_pos)
    new $P2156, "String"
    assign $P2156, ""
    store_lex "$*MULTINESS", $P2156
.annotate 'line', 897
  # rx subrule "declarator" subtype=capture negate=
    rx2154_cur."!cursor_pos"(rx2154_pos)
    $P10 = rx2154_cur."declarator"()
    unless $P10, rx2154_fail
    rx2154_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2154_pos = $P10."pos"()
.annotate 'line', 895
  # rx pass
    rx2154_cur."!cursor_pass"(rx2154_pos, "multi_declarator:sym<null>")
    if_null rx2154_debug, debug_1292
    rx2154_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx2154_pos)
  debug_1292:
    .return (rx2154_cur)
  rx2154_restart:
.annotate 'line', 436
    if_null rx2154_debug, debug_1293
    rx2154_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1293:
  rx2154_fail:
    (rx2154_rep, rx2154_pos, $I10, $P10) = rx2154_cur."!mark_fail"(0)
    lt rx2154_pos, -1, rx2154_done
    eq rx2154_pos, -1, rx2154_fail
    jump $I10
  rx2154_done:
    rx2154_cur."!cursor_fail"()
    if_null rx2154_debug, debug_1294
    rx2154_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1294:
    .return (rx2154_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("224_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2158 = self."!PREFIX__!subrule"("declarator", "")
    new $P2159, "ResizablePMCArray"
    push $P2159, $P2158
    .return ($P2159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("225_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P2167 = "226_1306916577.75068" 
    capture_lex $P2167
    .local string rx2161_tgt
    .local int rx2161_pos
    .local int rx2161_off
    .local int rx2161_eos
    .local int rx2161_rep
    .local pmc rx2161_cur
    .local pmc rx2161_debug
    (rx2161_cur, rx2161_pos, rx2161_tgt, $I10) = self."!cursor_start"()
    rx2161_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx2161_cur
    .local pmc match
    .lex "$/", match
    length rx2161_eos, rx2161_tgt
    gt rx2161_pos, rx2161_eos, rx2161_done
    set rx2161_off, 0
    lt rx2161_pos, 2, rx2161_start
    sub rx2161_off, rx2161_pos, 1
    substr rx2161_tgt, rx2161_tgt, rx2161_off
  rx2161_start:
    eq $I10, 1, rx2161_restart
    if_null rx2161_debug, debug_1295
    rx2161_cur."!cursor_debug"("START", "signature")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2162_done
    goto rxscan2162_scan
  rxscan2162_loop:
    (rx2161_pos) = rx2161_cur."from"()
    inc rx2161_pos
    rx2161_cur."!cursor_from"(rx2161_pos)
    ge rx2161_pos, rx2161_eos, rxscan2162_done
  rxscan2162_scan:
    set_addr $I10, rxscan2162_loop
    rx2161_cur."!mark_push"(0, rx2161_pos, $I10)
  rxscan2162_done:
.annotate 'line', 901
  # rx rxquantr2163 ** 0..1
    set_addr $I10, rxquantr2163_done
    rx2161_cur."!mark_push"(0, rx2161_pos, $I10)
  rxquantr2163_loop:
    rx2161_cur."!cursor_pos"(rx2161_pos)
    find_lex $P2164, unicode:"$\x{a2}"
    $P2165 = $P2164."MATCH"()
    store_lex "$/", $P2165
    .const 'Sub' $P2167 = "226_1306916577.75068" 
    capture_lex $P2167
    $P2171 = $P2167()
    unless $P2171, rx2161_fail
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."parameter"()
    unless $P10, rx2161_fail
    rx2161_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx2161_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx2161_pos, 1
    gt $I11, rx2161_eos, rx2161_fail
    sub $I11, rx2161_pos, rx2161_off
    ord $I11, rx2161_tgt, $I11
    ne $I11, 58, rx2161_fail
    add rx2161_pos, 1
    set_addr $I10, rxquantr2163_done
    (rx2161_rep) = rx2161_cur."!mark_commit"($I10)
  rxquantr2163_done:
.annotate 'line', 902
  # rx rxquantr2172 ** 0..1
    set_addr $I10, rxquantr2172_done
    rx2161_cur."!mark_push"(0, rx2161_pos, $I10)
  rxquantr2172_loop:
  # rx rxquantr2173 ** 1..*
    set_addr $I10, rxquantr2173_done
    rx2161_cur."!mark_push"(0, -1, $I10)
  rxquantr2173_loop:
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."parameter"()
    unless $P10, rx2161_fail
    rx2161_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx2161_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
    set_addr $I10, rxquantr2173_done
    (rx2161_rep) = rx2161_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2173_done
    rx2161_cur."!mark_push"(rx2161_rep, rx2161_pos, $I10)
  # rx literal  ","
    add $I11, rx2161_pos, 1
    gt $I11, rx2161_eos, rx2161_fail
    sub $I11, rx2161_pos, rx2161_off
    ord $I11, rx2161_tgt, $I11
    ne $I11, 44, rx2161_fail
    add rx2161_pos, 1
    goto rxquantr2173_loop
  rxquantr2173_done:
    set_addr $I10, rxquantr2172_done
    (rx2161_rep) = rx2161_cur."!mark_commit"($I10)
  rxquantr2172_done:
.annotate 'line', 900
  # rx pass
    rx2161_cur."!cursor_pass"(rx2161_pos, "signature")
    if_null rx2161_debug, debug_1298
    rx2161_cur."!cursor_debug"("PASS", "signature", " at pos=", rx2161_pos)
  debug_1298:
    .return (rx2161_cur)
  rx2161_restart:
.annotate 'line', 436
    if_null rx2161_debug, debug_1299
    rx2161_cur."!cursor_debug"("NEXT", "signature")
  debug_1299:
  rx2161_fail:
    (rx2161_rep, rx2161_pos, $I10, $P10) = rx2161_cur."!mark_fail"(0)
    lt rx2161_pos, -1, rx2161_done
    eq rx2161_pos, -1, rx2161_fail
    jump $I10
  rx2161_done:
    rx2161_cur."!cursor_fail"()
    if_null rx2161_debug, debug_1300
    rx2161_cur."!cursor_debug"("FAIL", "signature")
  debug_1300:
    .return (rx2161_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2166"  :anon :subid("226_1306916577.75068") :outer("225_1306916577.75068")
.annotate 'line', 901
    find_dynamic_lex $P2170, "$*INVOCANT_OK"
    unless_null $P2170, vivify_1296
    get_hll_global $P2168, "GLOBAL"
    get_who $P2169, $P2168
    set $P2170, $P2169["$INVOCANT_OK"]
    unless_null $P2170, vivify_1297
    die "Contextual $*INVOCANT_OK not found"
  vivify_1297:
  vivify_1296:
    .return ($P2170)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("227_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2175, "ResizablePMCArray"
    push $P2175, ""
    .return ($P2175)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("228_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2177_tgt
    .local int rx2177_pos
    .local int rx2177_off
    .local int rx2177_eos
    .local int rx2177_rep
    .local pmc rx2177_cur
    .local pmc rx2177_debug
    (rx2177_cur, rx2177_pos, rx2177_tgt, $I10) = self."!cursor_start"()
    rx2177_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx2177_cur
    .local pmc match
    .lex "$/", match
    length rx2177_eos, rx2177_tgt
    gt rx2177_pos, rx2177_eos, rx2177_done
    set rx2177_off, 0
    lt rx2177_pos, 2, rx2177_start
    sub rx2177_off, rx2177_pos, 1
    substr rx2177_tgt, rx2177_tgt, rx2177_off
  rx2177_start:
    eq $I10, 1, rx2177_restart
    if_null rx2177_debug, debug_1301
    rx2177_cur."!cursor_debug"("START", "parameter")
  debug_1301:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2178_done
    goto rxscan2178_scan
  rxscan2178_loop:
    (rx2177_pos) = rx2177_cur."from"()
    inc rx2177_pos
    rx2177_cur."!cursor_from"(rx2177_pos)
    ge rx2177_pos, rx2177_eos, rxscan2178_done
  rxscan2178_scan:
    set_addr $I10, rxscan2178_loop
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxscan2178_done:
.annotate 'line', 906
  # rx rxquantr2179 ** 0..*
    set_addr $I10, rxquantr2179_done
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxquantr2179_loop:
  # rx subrule "typename" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."typename"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx2177_pos = $P10."pos"()
  # rx rxquantr2180 ** 0..1
    set_addr $I10, rxquantr2180_done
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxquantr2180_loop:
  # rx literal  ":"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 58, rx2177_fail
    add rx2177_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_2181_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2177_pos, rx2177_eos, rx2177_fail
    sub $I10, rx2177_pos, rx2177_off
    substr $S10, rx2177_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx2177_fail
    inc rx2177_pos
    set_addr $I10, rxcap_2181_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_2181_done
  rxcap_2181_fail:
    goto rx2177_fail
  rxcap_2181_done:
    set_addr $I10, rxquantr2180_done
    (rx2177_rep) = rx2177_cur."!mark_commit"($I10)
  rxquantr2180_done:
  # rx subrule "ws" subtype=method negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."ws"()
    unless $P10, rx2177_fail
    rx2177_pos = $P10."pos"()
    set_addr $I10, rxquantr2179_done
    (rx2177_rep) = rx2177_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2179_done
    rx2177_cur."!mark_push"(rx2177_rep, rx2177_pos, $I10)
    goto rxquantr2179_loop
  rxquantr2179_done:
  alt2182_0:
.annotate 'line', 907
    set_addr $I10, alt2182_1
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
.annotate 'line', 908
  # rx subcapture "quant"
    set_addr $I10, rxcap_2183_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  "*"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 42, rx2177_fail
    add rx2177_pos, 1
    set_addr $I10, rxcap_2183_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2183_done
  rxcap_2183_fail:
    goto rx2177_fail
  rxcap_2183_done:
  # rx subrule "param_var" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."param_var"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2177_pos = $P10."pos"()
    goto alt2182_end
  alt2182_1:
  alt2184_0:
.annotate 'line', 909
    set_addr $I10, alt2184_1
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."param_var"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2177_pos = $P10."pos"()
    goto alt2184_end
  alt2184_1:
  # rx subrule "named_param" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."named_param"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx2177_pos = $P10."pos"()
  alt2184_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_2186_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  alt2185_0:
    set_addr $I10, alt2185_1
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  "?"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 63, rx2177_fail
    add rx2177_pos, 1
    goto alt2185_end
  alt2185_1:
    set_addr $I10, alt2185_2
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  "!"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 33, rx2177_fail
    add rx2177_pos, 1
    goto alt2185_end
  alt2185_2:
  alt2185_end:
    set_addr $I10, rxcap_2186_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2186_done
  rxcap_2186_fail:
    goto rx2177_fail
  rxcap_2186_done:
  alt2182_end:
.annotate 'line', 911
  # rx rxquantr2187 ** 0..1
    set_addr $I10, rxquantr2187_done
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxquantr2187_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."default_value"()
    unless $P10, rx2177_fail
    goto rxsubrule2188_pass
  rxsubrule2188_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2177_fail
  rxsubrule2188_pass:
    set_addr $I10, rxsubrule2188_back
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx2177_pos = $P10."pos"()
    set_addr $I10, rxquantr2187_done
    (rx2177_rep) = rx2177_cur."!mark_commit"($I10)
  rxquantr2187_done:
.annotate 'line', 905
  # rx pass
    rx2177_cur."!cursor_pass"(rx2177_pos, "parameter")
    if_null rx2177_debug, debug_1302
    rx2177_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx2177_pos)
  debug_1302:
    .return (rx2177_cur)
  rx2177_restart:
.annotate 'line', 436
    if_null rx2177_debug, debug_1303
    rx2177_cur."!cursor_debug"("NEXT", "parameter")
  debug_1303:
  rx2177_fail:
    (rx2177_rep, rx2177_pos, $I10, $P10) = rx2177_cur."!mark_fail"(0)
    lt rx2177_pos, -1, rx2177_done
    eq rx2177_pos, -1, rx2177_fail
    jump $I10
  rx2177_done:
    rx2177_cur."!cursor_fail"()
    if_null rx2177_debug, debug_1304
    rx2177_cur."!cursor_debug"("FAIL", "parameter")
  debug_1304:
    .return (rx2177_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("229_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2190, "ResizablePMCArray"
    push $P2190, ""
    .return ($P2190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("230_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2192_tgt
    .local int rx2192_pos
    .local int rx2192_off
    .local int rx2192_eos
    .local int rx2192_rep
    .local pmc rx2192_cur
    .local pmc rx2192_debug
    (rx2192_cur, rx2192_pos, rx2192_tgt, $I10) = self."!cursor_start"()
    rx2192_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx2192_cur
    .local pmc match
    .lex "$/", match
    length rx2192_eos, rx2192_tgt
    gt rx2192_pos, rx2192_eos, rx2192_done
    set rx2192_off, 0
    lt rx2192_pos, 2, rx2192_start
    sub rx2192_off, rx2192_pos, 1
    substr rx2192_tgt, rx2192_tgt, rx2192_off
  rx2192_start:
    eq $I10, 1, rx2192_restart
    if_null rx2192_debug, debug_1305
    rx2192_cur."!cursor_debug"("START", "param_var")
  debug_1305:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2193_done
    goto rxscan2193_scan
  rxscan2193_loop:
    (rx2192_pos) = rx2192_cur."from"()
    inc rx2192_pos
    rx2192_cur."!cursor_from"(rx2192_pos)
    ge rx2192_pos, rx2192_eos, rxscan2193_done
  rxscan2193_scan:
    set_addr $I10, rxscan2193_loop
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  rxscan2193_done:
.annotate 'line', 915
  # rx subrule "sigil" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."sigil"()
    unless $P10, rx2192_fail
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2192_pos = $P10."pos"()
  # rx rxquantr2194 ** 0..1
    set_addr $I10, rxquantr2194_done
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  rxquantr2194_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."twigil"()
    unless $P10, rx2192_fail
    goto rxsubrule2195_pass
  rxsubrule2195_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2192_fail
  rxsubrule2195_pass:
    set_addr $I10, rxsubrule2195_back
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx2192_pos = $P10."pos"()
    set_addr $I10, rxquantr2194_done
    (rx2192_rep) = rx2192_cur."!mark_commit"($I10)
  rxquantr2194_done:
  alt2196_0:
.annotate 'line', 916
    set_addr $I10, alt2196_1
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."ident"()
    unless $P10, rx2192_fail
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2192_pos = $P10."pos"()
    goto alt2196_end
  alt2196_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_2197_fail
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2192_pos, rx2192_eos, rx2192_fail
    sub $I10, rx2192_pos, rx2192_off
    substr $S10, rx2192_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx2192_fail
    inc rx2192_pos
    set_addr $I10, rxcap_2197_fail
    ($I12, $I11) = rx2192_cur."!mark_peek"($I10)
    rx2192_cur."!cursor_pos"($I11)
    ($P10) = rx2192_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2192_pos, "")
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_2197_done
  rxcap_2197_fail:
    goto rx2192_fail
  rxcap_2197_done:
  alt2196_end:
.annotate 'line', 914
  # rx pass
    rx2192_cur."!cursor_pass"(rx2192_pos, "param_var")
    if_null rx2192_debug, debug_1306
    rx2192_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx2192_pos)
  debug_1306:
    .return (rx2192_cur)
  rx2192_restart:
.annotate 'line', 436
    if_null rx2192_debug, debug_1307
    rx2192_cur."!cursor_debug"("NEXT", "param_var")
  debug_1307:
  rx2192_fail:
    (rx2192_rep, rx2192_pos, $I10, $P10) = rx2192_cur."!mark_fail"(0)
    lt rx2192_pos, -1, rx2192_done
    eq rx2192_pos, -1, rx2192_fail
    jump $I10
  rx2192_done:
    rx2192_cur."!cursor_fail"()
    if_null rx2192_debug, debug_1308
    rx2192_cur."!cursor_debug"("FAIL", "param_var")
  debug_1308:
    .return (rx2192_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("231_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2199 = self."!PREFIX__!subrule"("sigil", "")
    new $P2200, "ResizablePMCArray"
    push $P2200, $P2199
    .return ($P2200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("232_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2202_tgt
    .local int rx2202_pos
    .local int rx2202_off
    .local int rx2202_eos
    .local int rx2202_rep
    .local pmc rx2202_cur
    .local pmc rx2202_debug
    (rx2202_cur, rx2202_pos, rx2202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2202_cur
    .local pmc match
    .lex "$/", match
    length rx2202_eos, rx2202_tgt
    gt rx2202_pos, rx2202_eos, rx2202_done
    set rx2202_off, 0
    lt rx2202_pos, 2, rx2202_start
    sub rx2202_off, rx2202_pos, 1
    substr rx2202_tgt, rx2202_tgt, rx2202_off
  rx2202_start:
    eq $I10, 1, rx2202_restart
    if_null rx2202_debug, debug_1309
    rx2202_cur."!cursor_debug"("START", "named_param")
  debug_1309:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2203_done
    goto rxscan2203_scan
  rxscan2203_loop:
    (rx2202_pos) = rx2202_cur."from"()
    inc rx2202_pos
    rx2202_cur."!cursor_from"(rx2202_pos)
    ge rx2202_pos, rx2202_eos, rxscan2203_done
  rxscan2203_scan:
    set_addr $I10, rxscan2203_loop
    rx2202_cur."!mark_push"(0, rx2202_pos, $I10)
  rxscan2203_done:
.annotate 'line', 920
  # rx literal  ":"
    add $I11, rx2202_pos, 1
    gt $I11, rx2202_eos, rx2202_fail
    sub $I11, rx2202_pos, rx2202_off
    ord $I11, rx2202_tgt, $I11
    ne $I11, 58, rx2202_fail
    add rx2202_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx2202_cur."!cursor_pos"(rx2202_pos)
    $P10 = rx2202_cur."param_var"()
    unless $P10, rx2202_fail
    rx2202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2202_pos = $P10."pos"()
.annotate 'line', 919
  # rx pass
    rx2202_cur."!cursor_pass"(rx2202_pos, "named_param")
    if_null rx2202_debug, debug_1310
    rx2202_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx2202_pos)
  debug_1310:
    .return (rx2202_cur)
  rx2202_restart:
.annotate 'line', 436
    if_null rx2202_debug, debug_1311
    rx2202_cur."!cursor_debug"("NEXT", "named_param")
  debug_1311:
  rx2202_fail:
    (rx2202_rep, rx2202_pos, $I10, $P10) = rx2202_cur."!mark_fail"(0)
    lt rx2202_pos, -1, rx2202_done
    eq rx2202_pos, -1, rx2202_fail
    jump $I10
  rx2202_done:
    rx2202_cur."!cursor_fail"()
    if_null rx2202_debug, debug_1312
    rx2202_cur."!cursor_debug"("FAIL", "named_param")
  debug_1312:
    .return (rx2202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("233_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2205 = self."!PREFIX__!subrule"("param_var", ":")
    new $P2206, "ResizablePMCArray"
    push $P2206, $P2205
    .return ($P2206)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("234_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2208_tgt
    .local int rx2208_pos
    .local int rx2208_off
    .local int rx2208_eos
    .local int rx2208_rep
    .local pmc rx2208_cur
    .local pmc rx2208_debug
    (rx2208_cur, rx2208_pos, rx2208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2208_cur
    .local pmc match
    .lex "$/", match
    length rx2208_eos, rx2208_tgt
    gt rx2208_pos, rx2208_eos, rx2208_done
    set rx2208_off, 0
    lt rx2208_pos, 2, rx2208_start
    sub rx2208_off, rx2208_pos, 1
    substr rx2208_tgt, rx2208_tgt, rx2208_off
  rx2208_start:
    eq $I10, 1, rx2208_restart
    if_null rx2208_debug, debug_1313
    rx2208_cur."!cursor_debug"("START", "default_value")
  debug_1313:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2209_done
    goto rxscan2209_scan
  rxscan2209_loop:
    (rx2208_pos) = rx2208_cur."from"()
    inc rx2208_pos
    rx2208_cur."!cursor_from"(rx2208_pos)
    ge rx2208_pos, rx2208_eos, rxscan2209_done
  rxscan2209_scan:
    set_addr $I10, rxscan2209_loop
    rx2208_cur."!mark_push"(0, rx2208_pos, $I10)
  rxscan2209_done:
.annotate 'line', 923
  # rx subrule "ws" subtype=method negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."ws"()
    unless $P10, rx2208_fail
    rx2208_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx2208_pos, 1
    gt $I11, rx2208_eos, rx2208_fail
    sub $I11, rx2208_pos, rx2208_off
    ord $I11, rx2208_tgt, $I11
    ne $I11, 61, rx2208_fail
    add rx2208_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."ws"()
    unless $P10, rx2208_fail
    rx2208_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."EXPR"("i=")
    unless $P10, rx2208_fail
    rx2208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2208_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."ws"()
    unless $P10, rx2208_fail
    rx2208_pos = $P10."pos"()
  # rx pass
    rx2208_cur."!cursor_pass"(rx2208_pos, "default_value")
    if_null rx2208_debug, debug_1314
    rx2208_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx2208_pos)
  debug_1314:
    .return (rx2208_cur)
  rx2208_restart:
.annotate 'line', 436
    if_null rx2208_debug, debug_1315
    rx2208_cur."!cursor_debug"("NEXT", "default_value")
  debug_1315:
  rx2208_fail:
    (rx2208_rep, rx2208_pos, $I10, $P10) = rx2208_cur."!mark_fail"(0)
    lt rx2208_pos, -1, rx2208_done
    eq rx2208_pos, -1, rx2208_fail
    jump $I10
  rx2208_done:
    rx2208_cur."!cursor_fail"()
    if_null rx2208_debug, debug_1316
    rx2208_cur."!cursor_debug"("FAIL", "default_value")
  debug_1316:
    .return (rx2208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("235_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2214 = self."!PREFIX__!subrule"("ws", "")
    new $P2215, "ResizablePMCArray"
    push $P2215, $P2214
    .return ($P2215)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("236_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2217_tgt
    .local int rx2217_pos
    .local int rx2217_off
    .local int rx2217_eos
    .local int rx2217_rep
    .local pmc rx2217_cur
    .local pmc rx2217_debug
    (rx2217_cur, rx2217_pos, rx2217_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2217_cur
    .local pmc match
    .lex "$/", match
    length rx2217_eos, rx2217_tgt
    gt rx2217_pos, rx2217_eos, rx2217_done
    set rx2217_off, 0
    lt rx2217_pos, 2, rx2217_start
    sub rx2217_off, rx2217_pos, 1
    substr rx2217_tgt, rx2217_tgt, rx2217_off
  rx2217_start:
    eq $I10, 1, rx2217_restart
    if_null rx2217_debug, debug_1317
    rx2217_cur."!cursor_debug"("START", "trait")
  debug_1317:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2218_done
    goto rxscan2218_scan
  rxscan2218_loop:
    (rx2217_pos) = rx2217_cur."from"()
    inc rx2217_pos
    rx2217_cur."!cursor_from"(rx2217_pos)
    ge rx2217_pos, rx2217_eos, rxscan2218_done
  rxscan2218_scan:
    set_addr $I10, rxscan2218_loop
    rx2217_cur."!mark_push"(0, rx2217_pos, $I10)
  rxscan2218_done:
.annotate 'line', 925
  # rx subrule "ws" subtype=method negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."ws"()
    unless $P10, rx2217_fail
    rx2217_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."trait_mod"()
    unless $P10, rx2217_fail
    rx2217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx2217_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."ws"()
    unless $P10, rx2217_fail
    rx2217_pos = $P10."pos"()
  # rx pass
    rx2217_cur."!cursor_pass"(rx2217_pos, "trait")
    if_null rx2217_debug, debug_1318
    rx2217_cur."!cursor_debug"("PASS", "trait", " at pos=", rx2217_pos)
  debug_1318:
    .return (rx2217_cur)
  rx2217_restart:
.annotate 'line', 436
    if_null rx2217_debug, debug_1319
    rx2217_cur."!cursor_debug"("NEXT", "trait")
  debug_1319:
  rx2217_fail:
    (rx2217_rep, rx2217_pos, $I10, $P10) = rx2217_cur."!mark_fail"(0)
    lt rx2217_pos, -1, rx2217_done
    eq rx2217_pos, -1, rx2217_fail
    jump $I10
  rx2217_done:
    rx2217_cur."!cursor_fail"()
    if_null rx2217_debug, debug_1320
    rx2217_cur."!cursor_debug"("FAIL", "trait")
  debug_1320:
    .return (rx2217_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("237_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2222 = self."!PREFIX__!subrule"("ws", "")
    new $P2223, "ResizablePMCArray"
    push $P2223, $P2222
    .return ($P2223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("238_1306916577.75068")
    .param pmc param_2225
.annotate 'line', 927
    .lex "self", param_2225
    $P2226 = param_2225."!protoregex"("trait_mod")
    .return ($P2226)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("239_1306916577.75068")
    .param pmc param_2228
.annotate 'line', 927
    .lex "self", param_2228
    $P2229 = param_2228."!PREFIX__!protoregex"("trait_mod")
    .return ($P2229)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("240_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2231_tgt
    .local int rx2231_pos
    .local int rx2231_off
    .local int rx2231_eos
    .local int rx2231_rep
    .local pmc rx2231_cur
    .local pmc rx2231_debug
    (rx2231_cur, rx2231_pos, rx2231_tgt, $I10) = self."!cursor_start"()
    rx2231_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx2231_cur
    .local pmc match
    .lex "$/", match
    length rx2231_eos, rx2231_tgt
    gt rx2231_pos, rx2231_eos, rx2231_done
    set rx2231_off, 0
    lt rx2231_pos, 2, rx2231_start
    sub rx2231_off, rx2231_pos, 1
    substr rx2231_tgt, rx2231_tgt, rx2231_off
  rx2231_start:
    eq $I10, 1, rx2231_restart
    if_null rx2231_debug, debug_1321
    rx2231_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1321:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2232_done
    goto rxscan2232_scan
  rxscan2232_loop:
    (rx2231_pos) = rx2231_cur."from"()
    inc rx2231_pos
    rx2231_cur."!cursor_from"(rx2231_pos)
    ge rx2231_pos, rx2231_eos, rxscan2232_done
  rxscan2232_scan:
    set_addr $I10, rxscan2232_loop
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10)
  rxscan2232_done:
.annotate 'line', 928
  # rx subcapture "sym"
    set_addr $I10, rxcap_2233_fail
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10)
  # rx literal  "is"
    add $I11, rx2231_pos, 2
    gt $I11, rx2231_eos, rx2231_fail
    sub $I11, rx2231_pos, rx2231_off
    substr $S10, rx2231_tgt, $I11, 2
    ne $S10, "is", rx2231_fail
    add rx2231_pos, 2
    set_addr $I10, rxcap_2233_fail
    ($I12, $I11) = rx2231_cur."!mark_peek"($I10)
    rx2231_cur."!cursor_pos"($I11)
    ($P10) = rx2231_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2231_pos, "")
    rx2231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2233_done
  rxcap_2233_fail:
    goto rx2231_fail
  rxcap_2233_done:
  # rx subrule "ws" subtype=method negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."ws"()
    unless $P10, rx2231_fail
    rx2231_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."deflongname"()
    unless $P10, rx2231_fail
    rx2231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2231_pos = $P10."pos"()
  # rx rxquantr2235 ** 0..1
    set_addr $I10, rxquantr2235_done
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10)
  rxquantr2235_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."circumfix"()
    unless $P10, rx2231_fail
    goto rxsubrule2236_pass
  rxsubrule2236_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2231_fail
  rxsubrule2236_pass:
    set_addr $I10, rxsubrule2236_back
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx2231_pos = $P10."pos"()
    set_addr $I10, rxquantr2235_done
    (rx2231_rep) = rx2231_cur."!mark_commit"($I10)
  rxquantr2235_done:
  # rx subrule "ws" subtype=method negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."ws"()
    unless $P10, rx2231_fail
    rx2231_pos = $P10."pos"()
  # rx pass
    rx2231_cur."!cursor_pass"(rx2231_pos, "trait_mod:sym<is>")
    if_null rx2231_debug, debug_1322
    rx2231_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx2231_pos)
  debug_1322:
    .return (rx2231_cur)
  rx2231_restart:
.annotate 'line', 436
    if_null rx2231_debug, debug_1323
    rx2231_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1323:
  rx2231_fail:
    (rx2231_rep, rx2231_pos, $I10, $P10) = rx2231_cur."!mark_fail"(0)
    lt rx2231_pos, -1, rx2231_done
    eq rx2231_pos, -1, rx2231_fail
    jump $I10
  rx2231_done:
    rx2231_cur."!cursor_fail"()
    if_null rx2231_debug, debug_1324
    rx2231_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1324:
    .return (rx2231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("241_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2239 = self."!PREFIX__!subrule"("ws", "is")
    new $P2240, "ResizablePMCArray"
    push $P2240, $P2239
    .return ($P2240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("242_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2242_tgt
    .local int rx2242_pos
    .local int rx2242_off
    .local int rx2242_eos
    .local int rx2242_rep
    .local pmc rx2242_cur
    .local pmc rx2242_debug
    (rx2242_cur, rx2242_pos, rx2242_tgt, $I10) = self."!cursor_start"()
    rx2242_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx2242_cur
    .local pmc match
    .lex "$/", match
    length rx2242_eos, rx2242_tgt
    gt rx2242_pos, rx2242_eos, rx2242_done
    set rx2242_off, 0
    lt rx2242_pos, 2, rx2242_start
    sub rx2242_off, rx2242_pos, 1
    substr rx2242_tgt, rx2242_tgt, rx2242_off
  rx2242_start:
    eq $I10, 1, rx2242_restart
    if_null rx2242_debug, debug_1325
    rx2242_cur."!cursor_debug"("START", "regex_declarator")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2243_done
    goto rxscan2243_scan
  rxscan2243_loop:
    (rx2242_pos) = rx2242_cur."from"()
    inc rx2242_pos
    rx2242_cur."!cursor_from"(rx2242_pos)
    ge rx2242_pos, rx2242_eos, rxscan2243_done
  rxscan2243_scan:
    set_addr $I10, rxscan2243_loop
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  rxscan2243_done:
.annotate 'line', 930
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2245_0:
.annotate 'line', 931
    set_addr $I10, alt2245_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
.annotate 'line', 932
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_2247_fail
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "proto", rx2242_fail
    add rx2242_pos, 5
    set_addr $I10, rxcap_2247_fail
    ($I12, $I11) = rx2242_cur."!mark_peek"($I10)
    rx2242_cur."!cursor_pos"($I11)
    ($P10) = rx2242_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2242_pos, "")
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_2247_done
  rxcap_2247_fail:
    goto rx2242_fail
  rxcap_2247_done:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2249_0:
    set_addr $I10, alt2249_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "regex", rx2242_fail
    add rx2242_pos, 5
    goto alt2249_end
  alt2249_1:
    set_addr $I10, alt2249_2
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "token"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "token", rx2242_fail
    add rx2242_pos, 5
    goto alt2249_end
  alt2249_2:
  # rx literal  "rule"
    add $I11, rx2242_pos, 4
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 4
    ne $S10, "rule", rx2242_fail
    add rx2242_pos, 4
  alt2249_end:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 933
  # rx subrule "deflongname" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."deflongname"()
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2252_0:
.annotate 'line', 934
    set_addr $I10, alt2252_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
.annotate 'line', 935
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 123, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "<...>", rx2242_fail
    add rx2242_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 125, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ENDSTMT"()
    unless $P10, rx2242_fail
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
    goto alt2252_end
  alt2252_1:
    set_addr $I10, alt2252_2
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
.annotate 'line', 936
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 123, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx2242_pos, 3
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 3
    ne $S10, "<*>", rx2242_fail
    add rx2242_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 125, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ENDSTMT"()
    unless $P10, rx2242_fail
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
    goto alt2252_end
  alt2252_2:
.annotate 'line', 937
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2252_end:
.annotate 'line', 938
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 932
    goto alt2245_end
  alt2245_1:
.annotate 'line', 939
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_2266_fail
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  alt2265_0:
    set_addr $I10, alt2265_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "regex", rx2242_fail
    add rx2242_pos, 5
    goto alt2265_end
  alt2265_1:
    set_addr $I10, alt2265_2
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "token"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "token", rx2242_fail
    add rx2242_pos, 5
    goto alt2265_end
  alt2265_2:
  # rx literal  "rule"
    add $I11, rx2242_pos, 4
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 4
    ne $S10, "rule", rx2242_fail
    add rx2242_pos, 4
  alt2265_end:
    set_addr $I10, rxcap_2266_fail
    ($I12, $I11) = rx2242_cur."!mark_peek"($I10)
    rx2242_cur."!cursor_pos"($I11)
    ($P10) = rx2242_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2242_pos, "")
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2266_done
  rxcap_2266_fail:
    goto rx2242_fail
  rxcap_2266_done:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 940
  # rx subrule "deflongname" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."deflongname"()
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 941
  # rx subrule "newpad" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."newpad"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 942
  # rx rxquantr2270 ** 0..1
    set_addr $I10, rxquantr2270_done
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  rxquantr2270_loop:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 40, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."signature"()
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 41, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
    set_addr $I10, rxquantr2270_done
    (rx2242_rep) = rx2242_cur."!mark_commit"($I10)
  rxquantr2270_done:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 943
  # rx reduce name="regex_declarator" key="open"
    rx2242_cur."!cursor_pos"(rx2242_pos)
    rx2242_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 944
  # rx literal  "{"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 123, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2242_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 125, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ENDSTMT"()
    unless $P10, rx2242_fail
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2245_end:
.annotate 'line', 945
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 930
  # rx pass
    rx2242_cur."!cursor_pass"(rx2242_pos, "regex_declarator")
    if_null rx2242_debug, debug_1326
    rx2242_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx2242_pos)
  debug_1326:
    .return (rx2242_cur)
  rx2242_restart:
.annotate 'line', 436
    if_null rx2242_debug, debug_1327
    rx2242_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1327:
  rx2242_fail:
    (rx2242_rep, rx2242_pos, $I10, $P10) = rx2242_cur."!mark_fail"(0)
    lt rx2242_pos, -1, rx2242_done
    eq rx2242_pos, -1, rx2242_fail
    jump $I10
  rx2242_done:
    rx2242_cur."!cursor_fail"()
    if_null rx2242_debug, debug_1328
    rx2242_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1328:
    .return (rx2242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("243_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2280 = self."!PREFIX__!subrule"("ws", "")
    new $P2281, "ResizablePMCArray"
    push $P2281, $P2280
    .return ($P2281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("244_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2283_tgt
    .local int rx2283_pos
    .local int rx2283_off
    .local int rx2283_eos
    .local int rx2283_rep
    .local pmc rx2283_cur
    .local pmc rx2283_debug
    (rx2283_cur, rx2283_pos, rx2283_tgt, $I10) = self."!cursor_start"()
    rx2283_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2283_cur
    .local pmc match
    .lex "$/", match
    length rx2283_eos, rx2283_tgt
    gt rx2283_pos, rx2283_eos, rx2283_done
    set rx2283_off, 0
    lt rx2283_pos, 2, rx2283_start
    sub rx2283_off, rx2283_pos, 1
    substr rx2283_tgt, rx2283_tgt, rx2283_off
  rx2283_start:
    eq $I10, 1, rx2283_restart
    if_null rx2283_debug, debug_1329
    rx2283_cur."!cursor_debug"("START", "dotty")
  debug_1329:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2284_done
    goto rxscan2284_scan
  rxscan2284_loop:
    (rx2283_pos) = rx2283_cur."from"()
    inc rx2283_pos
    rx2283_cur."!cursor_from"(rx2283_pos)
    ge rx2283_pos, rx2283_eos, rxscan2284_done
  rxscan2284_scan:
    set_addr $I10, rxscan2284_loop
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  rxscan2284_done:
.annotate 'line', 949
  # rx literal  "."
    add $I11, rx2283_pos, 1
    gt $I11, rx2283_eos, rx2283_fail
    sub $I11, rx2283_pos, rx2283_off
    ord $I11, rx2283_tgt, $I11
    ne $I11, 46, rx2283_fail
    add rx2283_pos, 1
  alt2285_0:
.annotate 'line', 950
    set_addr $I10, alt2285_1
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."deflongname"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx2283_pos = $P10."pos"()
    goto alt2285_end
  alt2285_1:
.annotate 'line', 951
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2283_pos, rx2283_off
    substr $S10, rx2283_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx2283_fail
  # rx subrule "quote" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."quote"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2283_pos = $P10."pos"()
  alt2286_0:
.annotate 'line', 952
    set_addr $I10, alt2286_1
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2283_pos, rx2283_off
    substr $S10, rx2283_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2283_fail
    goto alt2286_end
  alt2286_1:
  # rx subrule "panic" subtype=method negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx2283_fail
    rx2283_pos = $P10."pos"()
  alt2286_end:
  alt2285_end:
.annotate 'line', 958
  # rx rxquantr2287 ** 0..1
    set_addr $I10, rxquantr2287_done
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  rxquantr2287_loop:
  alt2288_0:
.annotate 'line', 955
    set_addr $I10, alt2288_1
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
.annotate 'line', 956
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2283_pos, rx2283_off
    substr $S10, rx2283_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2283_fail
  # rx subrule "args" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."args"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2283_pos = $P10."pos"()
    goto alt2288_end
  alt2288_1:
.annotate 'line', 957
  # rx literal  ":"
    add $I11, rx2283_pos, 1
    gt $I11, rx2283_eos, rx2283_fail
    sub $I11, rx2283_pos, rx2283_off
    ord $I11, rx2283_tgt, $I11
    ne $I11, 58, rx2283_fail
    add rx2283_pos, 1
  # rx charclass s
    ge rx2283_pos, rx2283_eos, rx2283_fail
    sub $I10, rx2283_pos, rx2283_off
    is_cclass $I11, 32, rx2283_tgt, $I10
    unless $I11, rx2283_fail
    inc rx2283_pos
  # rx subrule "arglist" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."arglist"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2283_pos = $P10."pos"()
  alt2288_end:
.annotate 'line', 958
    set_addr $I10, rxquantr2287_done
    (rx2283_rep) = rx2283_cur."!mark_commit"($I10)
  rxquantr2287_done:
.annotate 'line', 948
  # rx pass
    rx2283_cur."!cursor_pass"(rx2283_pos, "dotty")
    if_null rx2283_debug, debug_1330
    rx2283_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx2283_pos)
  debug_1330:
    .return (rx2283_cur)
  rx2283_restart:
.annotate 'line', 436
    if_null rx2283_debug, debug_1331
    rx2283_cur."!cursor_debug"("NEXT", "dotty")
  debug_1331:
  rx2283_fail:
    (rx2283_rep, rx2283_pos, $I10, $P10) = rx2283_cur."!mark_fail"(0)
    lt rx2283_pos, -1, rx2283_done
    eq rx2283_pos, -1, rx2283_fail
    jump $I10
  rx2283_done:
    rx2283_cur."!cursor_fail"()
    if_null rx2283_debug, debug_1332
    rx2283_cur."!cursor_debug"("FAIL", "dotty")
  debug_1332:
    .return (rx2283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("245_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2290 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P2291, "ResizablePMCArray"
    push $P2291, "'"
    push $P2291, "\""
    push $P2291, $P2290
    .return ($P2291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("246_1306916577.75068")
    .param pmc param_2293
.annotate 'line', 962
    .lex "self", param_2293
    $P2294 = param_2293."!protoregex"("term")
    .return ($P2294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("247_1306916577.75068")
    .param pmc param_2296
.annotate 'line', 962
    .lex "self", param_2296
    $P2297 = param_2296."!PREFIX__!protoregex"("term")
    .return ($P2297)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("248_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2299_tgt
    .local int rx2299_pos
    .local int rx2299_off
    .local int rx2299_eos
    .local int rx2299_rep
    .local pmc rx2299_cur
    .local pmc rx2299_debug
    (rx2299_cur, rx2299_pos, rx2299_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2299_cur
    .local pmc match
    .lex "$/", match
    length rx2299_eos, rx2299_tgt
    gt rx2299_pos, rx2299_eos, rx2299_done
    set rx2299_off, 0
    lt rx2299_pos, 2, rx2299_start
    sub rx2299_off, rx2299_pos, 1
    substr rx2299_tgt, rx2299_tgt, rx2299_off
  rx2299_start:
    eq $I10, 1, rx2299_restart
    if_null rx2299_debug, debug_1333
    rx2299_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2300_done
    goto rxscan2300_scan
  rxscan2300_loop:
    (rx2299_pos) = rx2299_cur."from"()
    inc rx2299_pos
    rx2299_cur."!cursor_from"(rx2299_pos)
    ge rx2299_pos, rx2299_eos, rxscan2300_done
  rxscan2300_scan:
    set_addr $I10, rxscan2300_loop
    rx2299_cur."!mark_push"(0, rx2299_pos, $I10)
  rxscan2300_done:
.annotate 'line', 964
  # rx subcapture "sym"
    set_addr $I10, rxcap_2301_fail
    rx2299_cur."!mark_push"(0, rx2299_pos, $I10)
  # rx literal  "self"
    add $I11, rx2299_pos, 4
    gt $I11, rx2299_eos, rx2299_fail
    sub $I11, rx2299_pos, rx2299_off
    substr $S10, rx2299_tgt, $I11, 4
    ne $S10, "self", rx2299_fail
    add rx2299_pos, 4
    set_addr $I10, rxcap_2301_fail
    ($I12, $I11) = rx2299_cur."!mark_peek"($I10)
    rx2299_cur."!cursor_pos"($I11)
    ($P10) = rx2299_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2299_pos, "")
    rx2299_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2301_done
  rxcap_2301_fail:
    goto rx2299_fail
  rxcap_2301_done:
  # rxanchor rwb
    le rx2299_pos, 0, rx2299_fail
    sub $I10, rx2299_pos, rx2299_off
    is_cclass $I11, 8192, rx2299_tgt, $I10
    if $I11, rx2299_fail
    dec $I10
    is_cclass $I11, 8192, rx2299_tgt, $I10
    unless $I11, rx2299_fail
  # rx pass
    rx2299_cur."!cursor_pass"(rx2299_pos, "term:sym<self>")
    if_null rx2299_debug, debug_1334
    rx2299_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx2299_pos)
  debug_1334:
    .return (rx2299_cur)
  rx2299_restart:
.annotate 'line', 436
    if_null rx2299_debug, debug_1335
    rx2299_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1335:
  rx2299_fail:
    (rx2299_rep, rx2299_pos, $I10, $P10) = rx2299_cur."!mark_fail"(0)
    lt rx2299_pos, -1, rx2299_done
    eq rx2299_pos, -1, rx2299_fail
    jump $I10
  rx2299_done:
    rx2299_cur."!cursor_fail"()
    if_null rx2299_debug, debug_1336
    rx2299_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1336:
    .return (rx2299_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("249_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2303, "ResizablePMCArray"
    push $P2303, "self"
    .return ($P2303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("250_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2305_tgt
    .local int rx2305_pos
    .local int rx2305_off
    .local int rx2305_eos
    .local int rx2305_rep
    .local pmc rx2305_cur
    .local pmc rx2305_debug
    (rx2305_cur, rx2305_pos, rx2305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2305_cur
    .local pmc match
    .lex "$/", match
    length rx2305_eos, rx2305_tgt
    gt rx2305_pos, rx2305_eos, rx2305_done
    set rx2305_off, 0
    lt rx2305_pos, 2, rx2305_start
    sub rx2305_off, rx2305_pos, 1
    substr rx2305_tgt, rx2305_tgt, rx2305_off
  rx2305_start:
    eq $I10, 1, rx2305_restart
    if_null rx2305_debug, debug_1337
    rx2305_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2306_done
    goto rxscan2306_scan
  rxscan2306_loop:
    (rx2305_pos) = rx2305_cur."from"()
    inc rx2305_pos
    rx2305_cur."!cursor_from"(rx2305_pos)
    ge rx2305_pos, rx2305_eos, rxscan2306_done
  rxscan2306_scan:
    set_addr $I10, rxscan2306_loop
    rx2305_cur."!mark_push"(0, rx2305_pos, $I10)
  rxscan2306_done:
.annotate 'line', 967
  # rx subrule "deflongname" subtype=capture negate=
    rx2305_cur."!cursor_pos"(rx2305_pos)
    $P10 = rx2305_cur."deflongname"()
    unless $P10, rx2305_fail
    rx2305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2305_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2305_pos, rx2305_off
    substr $S10, rx2305_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2305_fail
  # rx subrule "args" subtype=capture negate=
    rx2305_cur."!cursor_pos"(rx2305_pos)
    $P10 = rx2305_cur."args"()
    unless $P10, rx2305_fail
    rx2305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2305_pos = $P10."pos"()
.annotate 'line', 966
  # rx pass
    rx2305_cur."!cursor_pass"(rx2305_pos, "term:sym<identifier>")
    if_null rx2305_debug, debug_1338
    rx2305_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx2305_pos)
  debug_1338:
    .return (rx2305_cur)
  rx2305_restart:
.annotate 'line', 436
    if_null rx2305_debug, debug_1339
    rx2305_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1339:
  rx2305_fail:
    (rx2305_rep, rx2305_pos, $I10, $P10) = rx2305_cur."!mark_fail"(0)
    lt rx2305_pos, -1, rx2305_done
    eq rx2305_pos, -1, rx2305_fail
    jump $I10
  rx2305_done:
    rx2305_cur."!cursor_fail"()
    if_null rx2305_debug, debug_1340
    rx2305_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1340:
    .return (rx2305_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("251_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2308 = self."!PREFIX__!subrule"("deflongname", "")
    new $P2309, "ResizablePMCArray"
    push $P2309, $P2308
    .return ($P2309)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("252_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2311_tgt
    .local int rx2311_pos
    .local int rx2311_off
    .local int rx2311_eos
    .local int rx2311_rep
    .local pmc rx2311_cur
    .local pmc rx2311_debug
    (rx2311_cur, rx2311_pos, rx2311_tgt, $I10) = self."!cursor_start"()
    rx2311_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2311_cur
    .local pmc match
    .lex "$/", match
    length rx2311_eos, rx2311_tgt
    gt rx2311_pos, rx2311_eos, rx2311_done
    set rx2311_off, 0
    lt rx2311_pos, 2, rx2311_start
    sub rx2311_off, rx2311_pos, 1
    substr rx2311_tgt, rx2311_tgt, rx2311_off
  rx2311_start:
    eq $I10, 1, rx2311_restart
    if_null rx2311_debug, debug_1341
    rx2311_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1341:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2312_done
    goto rxscan2312_scan
  rxscan2312_loop:
    (rx2311_pos) = rx2311_cur."from"()
    inc rx2311_pos
    rx2311_cur."!cursor_from"(rx2311_pos)
    ge rx2311_pos, rx2311_eos, rxscan2312_done
  rxscan2312_scan:
    set_addr $I10, rxscan2312_loop
    rx2311_cur."!mark_push"(0, rx2311_pos, $I10)
  rxscan2312_done:
.annotate 'line', 971
  # rx subrule "name" subtype=capture negate=
    rx2311_cur."!cursor_pos"(rx2311_pos)
    $P10 = rx2311_cur."name"()
    unless $P10, rx2311_fail
    rx2311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2311_pos = $P10."pos"()
  # rx rxquantr2313 ** 0..1
    set_addr $I10, rxquantr2313_done
    rx2311_cur."!mark_push"(0, rx2311_pos, $I10)
  rxquantr2313_loop:
  # rx subrule "args" subtype=capture negate=
    rx2311_cur."!cursor_pos"(rx2311_pos)
    $P10 = rx2311_cur."args"()
    unless $P10, rx2311_fail
    goto rxsubrule2314_pass
  rxsubrule2314_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2311_fail
  rxsubrule2314_pass:
    set_addr $I10, rxsubrule2314_back
    rx2311_cur."!mark_push"(0, rx2311_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2311_pos = $P10."pos"()
    set_addr $I10, rxquantr2313_done
    (rx2311_rep) = rx2311_cur."!mark_commit"($I10)
  rxquantr2313_done:
.annotate 'line', 970
  # rx pass
    rx2311_cur."!cursor_pass"(rx2311_pos, "term:sym<name>")
    if_null rx2311_debug, debug_1342
    rx2311_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx2311_pos)
  debug_1342:
    .return (rx2311_cur)
  rx2311_restart:
.annotate 'line', 436
    if_null rx2311_debug, debug_1343
    rx2311_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1343:
  rx2311_fail:
    (rx2311_rep, rx2311_pos, $I10, $P10) = rx2311_cur."!mark_fail"(0)
    lt rx2311_pos, -1, rx2311_done
    eq rx2311_pos, -1, rx2311_fail
    jump $I10
  rx2311_done:
    rx2311_cur."!cursor_fail"()
    if_null rx2311_debug, debug_1344
    rx2311_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1344:
    .return (rx2311_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("253_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2316 = self."!PREFIX__!subrule"("name", "")
    new $P2317, "ResizablePMCArray"
    push $P2317, $P2316
    .return ($P2317)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("254_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2319_tgt
    .local int rx2319_pos
    .local int rx2319_off
    .local int rx2319_eos
    .local int rx2319_rep
    .local pmc rx2319_cur
    .local pmc rx2319_debug
    (rx2319_cur, rx2319_pos, rx2319_tgt, $I10) = self."!cursor_start"()
    rx2319_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2319_cur
    .local pmc match
    .lex "$/", match
    length rx2319_eos, rx2319_tgt
    gt rx2319_pos, rx2319_eos, rx2319_done
    set rx2319_off, 0
    lt rx2319_pos, 2, rx2319_start
    sub rx2319_off, rx2319_pos, 1
    substr rx2319_tgt, rx2319_tgt, rx2319_off
  rx2319_start:
    eq $I10, 1, rx2319_restart
    if_null rx2319_debug, debug_1345
    rx2319_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2320_done
    goto rxscan2320_scan
  rxscan2320_loop:
    (rx2319_pos) = rx2319_cur."from"()
    inc rx2319_pos
    rx2319_cur."!cursor_from"(rx2319_pos)
    ge rx2319_pos, rx2319_eos, rxscan2320_done
  rxscan2320_scan:
    set_addr $I10, rxscan2320_loop
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10)
  rxscan2320_done:
.annotate 'line', 975
  # rx literal  "pir::"
    add $I11, rx2319_pos, 5
    gt $I11, rx2319_eos, rx2319_fail
    sub $I11, rx2319_pos, rx2319_off
    substr $S10, rx2319_tgt, $I11, 5
    ne $S10, "pir::", rx2319_fail
    add rx2319_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_2321_fail
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx2319_pos, rx2319_off
    find_not_cclass $I11, 8192, rx2319_tgt, $I10, rx2319_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx2319_fail
    add rx2319_pos, rx2319_off, $I11
    set_addr $I10, rxcap_2321_fail
    ($I12, $I11) = rx2319_cur."!mark_peek"($I10)
    rx2319_cur."!cursor_pos"($I11)
    ($P10) = rx2319_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2319_pos, "")
    rx2319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_2321_done
  rxcap_2321_fail:
    goto rx2319_fail
  rxcap_2321_done:
  # rx rxquantr2322 ** 0..1
    set_addr $I10, rxquantr2322_done
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10)
  rxquantr2322_loop:
  # rx subrule "args" subtype=capture negate=
    rx2319_cur."!cursor_pos"(rx2319_pos)
    $P10 = rx2319_cur."args"()
    unless $P10, rx2319_fail
    goto rxsubrule2323_pass
  rxsubrule2323_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2319_fail
  rxsubrule2323_pass:
    set_addr $I10, rxsubrule2323_back
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2319_pos = $P10."pos"()
    set_addr $I10, rxquantr2322_done
    (rx2319_rep) = rx2319_cur."!mark_commit"($I10)
  rxquantr2322_done:
.annotate 'line', 974
  # rx pass
    rx2319_cur."!cursor_pass"(rx2319_pos, "term:sym<pir::op>")
    if_null rx2319_debug, debug_1346
    rx2319_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx2319_pos)
  debug_1346:
    .return (rx2319_cur)
  rx2319_restart:
.annotate 'line', 436
    if_null rx2319_debug, debug_1347
    rx2319_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1347:
  rx2319_fail:
    (rx2319_rep, rx2319_pos, $I10, $P10) = rx2319_cur."!mark_fail"(0)
    lt rx2319_pos, -1, rx2319_done
    eq rx2319_pos, -1, rx2319_fail
    jump $I10
  rx2319_done:
    rx2319_cur."!cursor_fail"()
    if_null rx2319_debug, debug_1348
    rx2319_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1348:
    .return (rx2319_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("255_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2325, "ResizablePMCArray"
    push $P2325, "pir::"
    .return ($P2325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("256_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P2333 = "257_1306916577.75068" 
    capture_lex $P2333
    .local string rx2327_tgt
    .local int rx2327_pos
    .local int rx2327_off
    .local int rx2327_eos
    .local int rx2327_rep
    .local pmc rx2327_cur
    .local pmc rx2327_debug
    (rx2327_cur, rx2327_pos, rx2327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2327_cur
    .local pmc match
    .lex "$/", match
    length rx2327_eos, rx2327_tgt
    gt rx2327_pos, rx2327_eos, rx2327_done
    set rx2327_off, 0
    lt rx2327_pos, 2, rx2327_start
    sub rx2327_off, rx2327_pos, 1
    substr rx2327_tgt, rx2327_tgt, rx2327_off
  rx2327_start:
    eq $I10, 1, rx2327_restart
    if_null rx2327_debug, debug_1349
    rx2327_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2328_done
    goto rxscan2328_scan
  rxscan2328_loop:
    (rx2327_pos) = rx2327_cur."from"()
    inc rx2327_pos
    rx2327_cur."!cursor_from"(rx2327_pos)
    ge rx2327_pos, rx2327_eos, rxscan2328_done
  rxscan2328_scan:
    set_addr $I10, rxscan2328_loop
    rx2327_cur."!mark_push"(0, rx2327_pos, $I10)
  rxscan2328_done:
.annotate 'line', 979
  # rx literal  "{*}"
    add $I11, rx2327_pos, 3
    gt $I11, rx2327_eos, rx2327_fail
    sub $I11, rx2327_pos, rx2327_off
    substr $S10, rx2327_tgt, $I11, 3
    ne $S10, "{*}", rx2327_fail
    add rx2327_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2327_cur."!cursor_pos"(rx2327_pos)
    $P10 = rx2327_cur."ENDSTMT"()
    unless $P10, rx2327_fail
  alt2329_0:
.annotate 'line', 980
    set_addr $I10, alt2329_1
    rx2327_cur."!mark_push"(0, rx2327_pos, $I10)
    rx2327_cur."!cursor_pos"(rx2327_pos)
    find_lex $P2330, unicode:"$\x{a2}"
    $P2331 = $P2330."MATCH"()
    store_lex "$/", $P2331
    .const 'Sub' $P2333 = "257_1306916577.75068" 
    capture_lex $P2333
    $P2339 = $P2333()
    unless $P2339, rx2327_fail
    goto alt2329_end
  alt2329_1:
  # rx subrule "panic" subtype=method negate=
    rx2327_cur."!cursor_pos"(rx2327_pos)
    $P10 = rx2327_cur."panic"("{*} may only appear in proto")
    unless $P10, rx2327_fail
    rx2327_pos = $P10."pos"()
  alt2329_end:
.annotate 'line', 978
  # rx pass
    rx2327_cur."!cursor_pass"(rx2327_pos, "term:sym<onlystar>")
    if_null rx2327_debug, debug_1352
    rx2327_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx2327_pos)
  debug_1352:
    .return (rx2327_cur)
  rx2327_restart:
.annotate 'line', 436
    if_null rx2327_debug, debug_1353
    rx2327_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1353:
  rx2327_fail:
    (rx2327_rep, rx2327_pos, $I10, $P10) = rx2327_cur."!mark_fail"(0)
    lt rx2327_pos, -1, rx2327_done
    eq rx2327_pos, -1, rx2327_fail
    jump $I10
  rx2327_done:
    rx2327_cur."!cursor_fail"()
    if_null rx2327_debug, debug_1354
    rx2327_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1354:
    .return (rx2327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2332"  :anon :subid("257_1306916577.75068") :outer("256_1306916577.75068")
.annotate 'line', 980
    find_dynamic_lex $P2336, "$*MULTINESS"
    unless_null $P2336, vivify_1350
    get_hll_global $P2334, "GLOBAL"
    get_who $P2335, $P2334
    set $P2336, $P2335["$MULTINESS"]
    unless_null $P2336, vivify_1351
    die "Contextual $*MULTINESS not found"
  vivify_1351:
  vivify_1350:
    set $S2337, $P2336
    iseq $I2338, $S2337, "proto"
    .return ($I2338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("258_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2341, "ResizablePMCArray"
    push $P2341, "{*}"
    .return ($P2341)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("259_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2343_tgt
    .local int rx2343_pos
    .local int rx2343_off
    .local int rx2343_eos
    .local int rx2343_rep
    .local pmc rx2343_cur
    .local pmc rx2343_debug
    (rx2343_cur, rx2343_pos, rx2343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2343_cur
    .local pmc match
    .lex "$/", match
    length rx2343_eos, rx2343_tgt
    gt rx2343_pos, rx2343_eos, rx2343_done
    set rx2343_off, 0
    lt rx2343_pos, 2, rx2343_start
    sub rx2343_off, rx2343_pos, 1
    substr rx2343_tgt, rx2343_tgt, rx2343_off
  rx2343_start:
    eq $I10, 1, rx2343_restart
    if_null rx2343_debug, debug_1355
    rx2343_cur."!cursor_debug"("START", "args")
  debug_1355:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2344_done
    goto rxscan2344_scan
  rxscan2344_loop:
    (rx2343_pos) = rx2343_cur."from"()
    inc rx2343_pos
    rx2343_cur."!cursor_from"(rx2343_pos)
    ge rx2343_pos, rx2343_eos, rxscan2344_done
  rxscan2344_scan:
    set_addr $I10, rxscan2344_loop
    rx2343_cur."!mark_push"(0, rx2343_pos, $I10)
  rxscan2344_done:
.annotate 'line', 984
  # rx literal  "("
    add $I11, rx2343_pos, 1
    gt $I11, rx2343_eos, rx2343_fail
    sub $I11, rx2343_pos, rx2343_off
    ord $I11, rx2343_tgt, $I11
    ne $I11, 40, rx2343_fail
    add rx2343_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2343_cur."!cursor_pos"(rx2343_pos)
    $P10 = rx2343_cur."arglist"()
    unless $P10, rx2343_fail
    rx2343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2343_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2343_pos, 1
    gt $I11, rx2343_eos, rx2343_fail
    sub $I11, rx2343_pos, rx2343_off
    ord $I11, rx2343_tgt, $I11
    ne $I11, 41, rx2343_fail
    add rx2343_pos, 1
  # rx pass
    rx2343_cur."!cursor_pass"(rx2343_pos, "args")
    if_null rx2343_debug, debug_1356
    rx2343_cur."!cursor_debug"("PASS", "args", " at pos=", rx2343_pos)
  debug_1356:
    .return (rx2343_cur)
  rx2343_restart:
.annotate 'line', 436
    if_null rx2343_debug, debug_1357
    rx2343_cur."!cursor_debug"("NEXT", "args")
  debug_1357:
  rx2343_fail:
    (rx2343_rep, rx2343_pos, $I10, $P10) = rx2343_cur."!mark_fail"(0)
    lt rx2343_pos, -1, rx2343_done
    eq rx2343_pos, -1, rx2343_fail
    jump $I10
  rx2343_done:
    rx2343_cur."!cursor_fail"()
    if_null rx2343_debug, debug_1358
    rx2343_cur."!cursor_debug"("FAIL", "args")
  debug_1358:
    .return (rx2343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("260_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2346 = self."!PREFIX__!subrule"("arglist", "(")
    new $P2347, "ResizablePMCArray"
    push $P2347, $P2346
    .return ($P2347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("261_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2349_tgt
    .local int rx2349_pos
    .local int rx2349_off
    .local int rx2349_eos
    .local int rx2349_rep
    .local pmc rx2349_cur
    .local pmc rx2349_debug
    (rx2349_cur, rx2349_pos, rx2349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2349_cur
    .local pmc match
    .lex "$/", match
    length rx2349_eos, rx2349_tgt
    gt rx2349_pos, rx2349_eos, rx2349_done
    set rx2349_off, 0
    lt rx2349_pos, 2, rx2349_start
    sub rx2349_off, rx2349_pos, 1
    substr rx2349_tgt, rx2349_tgt, rx2349_off
  rx2349_start:
    eq $I10, 1, rx2349_restart
    if_null rx2349_debug, debug_1359
    rx2349_cur."!cursor_debug"("START", "arglist")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2350_done
    goto rxscan2350_scan
  rxscan2350_loop:
    (rx2349_pos) = rx2349_cur."from"()
    inc rx2349_pos
    rx2349_cur."!cursor_from"(rx2349_pos)
    ge rx2349_pos, rx2349_eos, rxscan2350_done
  rxscan2350_scan:
    set_addr $I10, rxscan2350_loop
    rx2349_cur."!mark_push"(0, rx2349_pos, $I10)
  rxscan2350_done:
.annotate 'line', 988
  # rx subrule "ws" subtype=method negate=
    rx2349_cur."!cursor_pos"(rx2349_pos)
    $P10 = rx2349_cur."ws"()
    unless $P10, rx2349_fail
    rx2349_pos = $P10."pos"()
  alt2351_0:
.annotate 'line', 989
    set_addr $I10, alt2351_1
    rx2349_cur."!mark_push"(0, rx2349_pos, $I10)
.annotate 'line', 990
  # rx subrule "EXPR" subtype=capture negate=
    rx2349_cur."!cursor_pos"(rx2349_pos)
    $P10 = rx2349_cur."EXPR"("f=")
    unless $P10, rx2349_fail
    rx2349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2349_pos = $P10."pos"()
    goto alt2351_end
  alt2351_1:
  alt2351_end:
.annotate 'line', 987
  # rx pass
    rx2349_cur."!cursor_pass"(rx2349_pos, "arglist")
    if_null rx2349_debug, debug_1360
    rx2349_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx2349_pos)
  debug_1360:
    .return (rx2349_cur)
  rx2349_restart:
.annotate 'line', 436
    if_null rx2349_debug, debug_1361
    rx2349_cur."!cursor_debug"("NEXT", "arglist")
  debug_1361:
  rx2349_fail:
    (rx2349_rep, rx2349_pos, $I10, $P10) = rx2349_cur."!mark_fail"(0)
    lt rx2349_pos, -1, rx2349_done
    eq rx2349_pos, -1, rx2349_fail
    jump $I10
  rx2349_done:
    rx2349_cur."!cursor_fail"()
    if_null rx2349_debug, debug_1362
    rx2349_cur."!cursor_debug"("FAIL", "arglist")
  debug_1362:
    .return (rx2349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("262_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2353 = self."!PREFIX__!subrule"("ws", "")
    new $P2354, "ResizablePMCArray"
    push $P2354, $P2353
    .return ($P2354)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("263_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2356_tgt
    .local int rx2356_pos
    .local int rx2356_off
    .local int rx2356_eos
    .local int rx2356_rep
    .local pmc rx2356_cur
    .local pmc rx2356_debug
    (rx2356_cur, rx2356_pos, rx2356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2356_cur
    .local pmc match
    .lex "$/", match
    length rx2356_eos, rx2356_tgt
    gt rx2356_pos, rx2356_eos, rx2356_done
    set rx2356_off, 0
    lt rx2356_pos, 2, rx2356_start
    sub rx2356_off, rx2356_pos, 1
    substr rx2356_tgt, rx2356_tgt, rx2356_off
  rx2356_start:
    eq $I10, 1, rx2356_restart
    if_null rx2356_debug, debug_1363
    rx2356_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1363:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2357_done
    goto rxscan2357_scan
  rxscan2357_loop:
    (rx2356_pos) = rx2356_cur."from"()
    inc rx2356_pos
    rx2356_cur."!cursor_from"(rx2356_pos)
    ge rx2356_pos, rx2356_eos, rxscan2357_done
  rxscan2357_scan:
    set_addr $I10, rxscan2357_loop
    rx2356_cur."!mark_push"(0, rx2356_pos, $I10)
  rxscan2357_done:
.annotate 'line', 996
  # rx subrule "value" subtype=capture negate=
    rx2356_cur."!cursor_pos"(rx2356_pos)
    $P10 = rx2356_cur."value"()
    unless $P10, rx2356_fail
    rx2356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx2356_pos = $P10."pos"()
  # rx pass
    rx2356_cur."!cursor_pass"(rx2356_pos, "term:sym<value>")
    if_null rx2356_debug, debug_1364
    rx2356_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx2356_pos)
  debug_1364:
    .return (rx2356_cur)
  rx2356_restart:
.annotate 'line', 436
    if_null rx2356_debug, debug_1365
    rx2356_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1365:
  rx2356_fail:
    (rx2356_rep, rx2356_pos, $I10, $P10) = rx2356_cur."!mark_fail"(0)
    lt rx2356_pos, -1, rx2356_done
    eq rx2356_pos, -1, rx2356_fail
    jump $I10
  rx2356_done:
    rx2356_cur."!cursor_fail"()
    if_null rx2356_debug, debug_1366
    rx2356_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1366:
    .return (rx2356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("264_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2359 = self."!PREFIX__!subrule"("value", "")
    new $P2360, "ResizablePMCArray"
    push $P2360, $P2359
    .return ($P2360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("265_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2362_tgt
    .local int rx2362_pos
    .local int rx2362_off
    .local int rx2362_eos
    .local int rx2362_rep
    .local pmc rx2362_cur
    .local pmc rx2362_debug
    (rx2362_cur, rx2362_pos, rx2362_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2362_cur
    .local pmc match
    .lex "$/", match
    length rx2362_eos, rx2362_tgt
    gt rx2362_pos, rx2362_eos, rx2362_done
    set rx2362_off, 0
    lt rx2362_pos, 2, rx2362_start
    sub rx2362_off, rx2362_pos, 1
    substr rx2362_tgt, rx2362_tgt, rx2362_off
  rx2362_start:
    eq $I10, 1, rx2362_restart
    if_null rx2362_debug, debug_1367
    rx2362_cur."!cursor_debug"("START", "value")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2363_done
    goto rxscan2363_scan
  rxscan2363_loop:
    (rx2362_pos) = rx2362_cur."from"()
    inc rx2362_pos
    rx2362_cur."!cursor_from"(rx2362_pos)
    ge rx2362_pos, rx2362_eos, rxscan2363_done
  rxscan2363_scan:
    set_addr $I10, rxscan2363_loop
    rx2362_cur."!mark_push"(0, rx2362_pos, $I10)
  rxscan2363_done:
  alt2364_0:
.annotate 'line', 998
    set_addr $I10, alt2364_1
    rx2362_cur."!mark_push"(0, rx2362_pos, $I10)
.annotate 'line', 999
  # rx subrule "quote" subtype=capture negate=
    rx2362_cur."!cursor_pos"(rx2362_pos)
    $P10 = rx2362_cur."quote"()
    unless $P10, rx2362_fail
    rx2362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2362_pos = $P10."pos"()
    goto alt2364_end
  alt2364_1:
.annotate 'line', 1000
  # rx subrule "number" subtype=capture negate=
    rx2362_cur."!cursor_pos"(rx2362_pos)
    $P10 = rx2362_cur."number"()
    unless $P10, rx2362_fail
    rx2362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx2362_pos = $P10."pos"()
  alt2364_end:
.annotate 'line', 998
  # rx pass
    rx2362_cur."!cursor_pass"(rx2362_pos, "value")
    if_null rx2362_debug, debug_1368
    rx2362_cur."!cursor_debug"("PASS", "value", " at pos=", rx2362_pos)
  debug_1368:
    .return (rx2362_cur)
  rx2362_restart:
.annotate 'line', 436
    if_null rx2362_debug, debug_1369
    rx2362_cur."!cursor_debug"("NEXT", "value")
  debug_1369:
  rx2362_fail:
    (rx2362_rep, rx2362_pos, $I10, $P10) = rx2362_cur."!mark_fail"(0)
    lt rx2362_pos, -1, rx2362_done
    eq rx2362_pos, -1, rx2362_fail
    jump $I10
  rx2362_done:
    rx2362_cur."!cursor_fail"()
    if_null rx2362_debug, debug_1370
    rx2362_cur."!cursor_debug"("FAIL", "value")
  debug_1370:
    .return (rx2362_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("266_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2366 = self."!PREFIX__!subrule"("number", "")
    $P2367 = self."!PREFIX__!subrule"("quote", "")
    new $P2368, "ResizablePMCArray"
    push $P2368, $P2366
    push $P2368, $P2367
    .return ($P2368)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("267_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2370_tgt
    .local int rx2370_pos
    .local int rx2370_off
    .local int rx2370_eos
    .local int rx2370_rep
    .local pmc rx2370_cur
    .local pmc rx2370_debug
    (rx2370_cur, rx2370_pos, rx2370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2370_cur
    .local pmc match
    .lex "$/", match
    length rx2370_eos, rx2370_tgt
    gt rx2370_pos, rx2370_eos, rx2370_done
    set rx2370_off, 0
    lt rx2370_pos, 2, rx2370_start
    sub rx2370_off, rx2370_pos, 1
    substr rx2370_tgt, rx2370_tgt, rx2370_off
  rx2370_start:
    eq $I10, 1, rx2370_restart
    if_null rx2370_debug, debug_1371
    rx2370_cur."!cursor_debug"("START", "number")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2371_done
    goto rxscan2371_scan
  rxscan2371_loop:
    (rx2370_pos) = rx2370_cur."from"()
    inc rx2370_pos
    rx2370_cur."!cursor_from"(rx2370_pos)
    ge rx2370_pos, rx2370_eos, rxscan2371_done
  rxscan2371_scan:
    set_addr $I10, rxscan2371_loop
    rx2370_cur."!mark_push"(0, rx2370_pos, $I10)
  rxscan2371_done:
.annotate 'line', 1004
  # rx subcapture "sign"
    set_addr $I10, rxcap_2373_fail
    rx2370_cur."!mark_push"(0, rx2370_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx2370_pos, rx2370_off
    set rx2370_rep, 0
    sub $I12, rx2370_eos, rx2370_pos
    le $I12, 1, rxenumcharlistq2372_loop
    set $I12, 1
  rxenumcharlistq2372_loop:
    le $I12, 0, rxenumcharlistq2372_done
    substr $S10, rx2370_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq2372_done
    inc rx2370_rep
  rxenumcharlistq2372_done:
    add rx2370_pos, rx2370_pos, rx2370_rep
    set_addr $I10, rxcap_2373_fail
    ($I12, $I11) = rx2370_cur."!mark_peek"($I10)
    rx2370_cur."!cursor_pos"($I11)
    ($P10) = rx2370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2370_pos, "")
    rx2370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_2373_done
  rxcap_2373_fail:
    goto rx2370_fail
  rxcap_2373_done:
  alt2374_0:
.annotate 'line', 1005
    set_addr $I10, alt2374_1
    rx2370_cur."!mark_push"(0, rx2370_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx2370_cur."!cursor_pos"(rx2370_pos)
    $P10 = rx2370_cur."dec_number"()
    unless $P10, rx2370_fail
    rx2370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx2370_pos = $P10."pos"()
    goto alt2374_end
  alt2374_1:
  # rx subrule "integer" subtype=capture negate=
    rx2370_cur."!cursor_pos"(rx2370_pos)
    $P10 = rx2370_cur."integer"()
    unless $P10, rx2370_fail
    rx2370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx2370_pos = $P10."pos"()
  alt2374_end:
.annotate 'line', 1003
  # rx pass
    rx2370_cur."!cursor_pass"(rx2370_pos, "number")
    if_null rx2370_debug, debug_1372
    rx2370_cur."!cursor_debug"("PASS", "number", " at pos=", rx2370_pos)
  debug_1372:
    .return (rx2370_cur)
  rx2370_restart:
.annotate 'line', 436
    if_null rx2370_debug, debug_1373
    rx2370_cur."!cursor_debug"("NEXT", "number")
  debug_1373:
  rx2370_fail:
    (rx2370_rep, rx2370_pos, $I10, $P10) = rx2370_cur."!mark_fail"(0)
    lt rx2370_pos, -1, rx2370_done
    eq rx2370_pos, -1, rx2370_fail
    jump $I10
  rx2370_done:
    rx2370_cur."!cursor_fail"()
    if_null rx2370_debug, debug_1374
    rx2370_cur."!cursor_debug"("FAIL", "number")
  debug_1374:
    .return (rx2370_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("268_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2376, "ResizablePMCArray"
    push $P2376, ""
    .return ($P2376)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("269_1306916577.75068")
    .param pmc param_2378
.annotate 'line', 1008
    .lex "self", param_2378
    $P2379 = param_2378."!protoregex"("quote")
    .return ($P2379)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("270_1306916577.75068")
    .param pmc param_2381
.annotate 'line', 1008
    .lex "self", param_2381
    $P2382 = param_2381."!PREFIX__!protoregex"("quote")
    .return ($P2382)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("271_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2384_tgt
    .local int rx2384_pos
    .local int rx2384_off
    .local int rx2384_eos
    .local int rx2384_rep
    .local pmc rx2384_cur
    .local pmc rx2384_debug
    (rx2384_cur, rx2384_pos, rx2384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2384_cur
    .local pmc match
    .lex "$/", match
    length rx2384_eos, rx2384_tgt
    gt rx2384_pos, rx2384_eos, rx2384_done
    set rx2384_off, 0
    lt rx2384_pos, 2, rx2384_start
    sub rx2384_off, rx2384_pos, 1
    substr rx2384_tgt, rx2384_tgt, rx2384_off
  rx2384_start:
    eq $I10, 1, rx2384_restart
    if_null rx2384_debug, debug_1375
    rx2384_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1375:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2385_done
    goto rxscan2385_scan
  rxscan2385_loop:
    (rx2384_pos) = rx2384_cur."from"()
    inc rx2384_pos
    rx2384_cur."!cursor_from"(rx2384_pos)
    ge rx2384_pos, rx2384_eos, rxscan2385_done
  rxscan2385_scan:
    set_addr $I10, rxscan2385_loop
    rx2384_cur."!mark_push"(0, rx2384_pos, $I10)
  rxscan2385_done:
.annotate 'line', 1009
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2384_pos, rx2384_off
    substr $S10, rx2384_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx2384_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2384_cur."!cursor_pos"(rx2384_pos)
    $P10 = rx2384_cur."quote_EXPR"(":q")
    unless $P10, rx2384_fail
    rx2384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2384_pos = $P10."pos"()
  # rx pass
    rx2384_cur."!cursor_pass"(rx2384_pos, "quote:sym<apos>")
    if_null rx2384_debug, debug_1376
    rx2384_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx2384_pos)
  debug_1376:
    .return (rx2384_cur)
  rx2384_restart:
.annotate 'line', 436
    if_null rx2384_debug, debug_1377
    rx2384_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1377:
  rx2384_fail:
    (rx2384_rep, rx2384_pos, $I10, $P10) = rx2384_cur."!mark_fail"(0)
    lt rx2384_pos, -1, rx2384_done
    eq rx2384_pos, -1, rx2384_fail
    jump $I10
  rx2384_done:
    rx2384_cur."!cursor_fail"()
    if_null rx2384_debug, debug_1378
    rx2384_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1378:
    .return (rx2384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("272_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2387, "ResizablePMCArray"
    push $P2387, "'"
    .return ($P2387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("273_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2389_tgt
    .local int rx2389_pos
    .local int rx2389_off
    .local int rx2389_eos
    .local int rx2389_rep
    .local pmc rx2389_cur
    .local pmc rx2389_debug
    (rx2389_cur, rx2389_pos, rx2389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2389_cur
    .local pmc match
    .lex "$/", match
    length rx2389_eos, rx2389_tgt
    gt rx2389_pos, rx2389_eos, rx2389_done
    set rx2389_off, 0
    lt rx2389_pos, 2, rx2389_start
    sub rx2389_off, rx2389_pos, 1
    substr rx2389_tgt, rx2389_tgt, rx2389_off
  rx2389_start:
    eq $I10, 1, rx2389_restart
    if_null rx2389_debug, debug_1379
    rx2389_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2390_done
    goto rxscan2390_scan
  rxscan2390_loop:
    (rx2389_pos) = rx2389_cur."from"()
    inc rx2389_pos
    rx2389_cur."!cursor_from"(rx2389_pos)
    ge rx2389_pos, rx2389_eos, rxscan2390_done
  rxscan2390_scan:
    set_addr $I10, rxscan2390_loop
    rx2389_cur."!mark_push"(0, rx2389_pos, $I10)
  rxscan2390_done:
.annotate 'line', 1010
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2389_pos, rx2389_off
    substr $S10, rx2389_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx2389_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2389_cur."!cursor_pos"(rx2389_pos)
    $P10 = rx2389_cur."quote_EXPR"(":qq")
    unless $P10, rx2389_fail
    rx2389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2389_pos = $P10."pos"()
  # rx pass
    rx2389_cur."!cursor_pass"(rx2389_pos, "quote:sym<dblq>")
    if_null rx2389_debug, debug_1380
    rx2389_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx2389_pos)
  debug_1380:
    .return (rx2389_cur)
  rx2389_restart:
.annotate 'line', 436
    if_null rx2389_debug, debug_1381
    rx2389_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1381:
  rx2389_fail:
    (rx2389_rep, rx2389_pos, $I10, $P10) = rx2389_cur."!mark_fail"(0)
    lt rx2389_pos, -1, rx2389_done
    eq rx2389_pos, -1, rx2389_fail
    jump $I10
  rx2389_done:
    rx2389_cur."!cursor_fail"()
    if_null rx2389_debug, debug_1382
    rx2389_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1382:
    .return (rx2389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("274_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2392, "ResizablePMCArray"
    push $P2392, "\""
    .return ($P2392)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("275_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2394_tgt
    .local int rx2394_pos
    .local int rx2394_off
    .local int rx2394_eos
    .local int rx2394_rep
    .local pmc rx2394_cur
    .local pmc rx2394_debug
    (rx2394_cur, rx2394_pos, rx2394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2394_cur
    .local pmc match
    .lex "$/", match
    length rx2394_eos, rx2394_tgt
    gt rx2394_pos, rx2394_eos, rx2394_done
    set rx2394_off, 0
    lt rx2394_pos, 2, rx2394_start
    sub rx2394_off, rx2394_pos, 1
    substr rx2394_tgt, rx2394_tgt, rx2394_off
  rx2394_start:
    eq $I10, 1, rx2394_restart
    if_null rx2394_debug, debug_1383
    rx2394_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1383:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2395_done
    goto rxscan2395_scan
  rxscan2395_loop:
    (rx2394_pos) = rx2394_cur."from"()
    inc rx2394_pos
    rx2394_cur."!cursor_from"(rx2394_pos)
    ge rx2394_pos, rx2394_eos, rxscan2395_done
  rxscan2395_scan:
    set_addr $I10, rxscan2395_loop
    rx2394_cur."!mark_push"(0, rx2394_pos, $I10)
  rxscan2395_done:
.annotate 'line', 1011
  # rx subcapture "sym"
    set_addr $I10, rxcap_2396_fail
    rx2394_cur."!mark_push"(0, rx2394_pos, $I10)
  # rx literal  "q"
    add $I11, rx2394_pos, 1
    gt $I11, rx2394_eos, rx2394_fail
    sub $I11, rx2394_pos, rx2394_off
    ord $I11, rx2394_tgt, $I11
    ne $I11, 113, rx2394_fail
    add rx2394_pos, 1
    set_addr $I10, rxcap_2396_fail
    ($I12, $I11) = rx2394_cur."!mark_peek"($I10)
    rx2394_cur."!cursor_pos"($I11)
    ($P10) = rx2394_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2394_pos, "")
    rx2394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2396_done
  rxcap_2396_fail:
    goto rx2394_fail
  rxcap_2396_done:
  # rxanchor rwb
    le rx2394_pos, 0, rx2394_fail
    sub $I10, rx2394_pos, rx2394_off
    is_cclass $I11, 8192, rx2394_tgt, $I10
    if $I11, rx2394_fail
    dec $I10
    is_cclass $I11, 8192, rx2394_tgt, $I10
    unless $I11, rx2394_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2394_pos, rx2394_off
    substr $S10, rx2394_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2394_fail
  # rx subrule "ws" subtype=method negate=
    rx2394_cur."!cursor_pos"(rx2394_pos)
    $P10 = rx2394_cur."ws"()
    unless $P10, rx2394_fail
    rx2394_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2394_cur."!cursor_pos"(rx2394_pos)
    $P10 = rx2394_cur."quote_EXPR"(":q")
    unless $P10, rx2394_fail
    rx2394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2394_pos = $P10."pos"()
  # rx pass
    rx2394_cur."!cursor_pass"(rx2394_pos, "quote:sym<q>")
    if_null rx2394_debug, debug_1384
    rx2394_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx2394_pos)
  debug_1384:
    .return (rx2394_cur)
  rx2394_restart:
.annotate 'line', 436
    if_null rx2394_debug, debug_1385
    rx2394_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1385:
  rx2394_fail:
    (rx2394_rep, rx2394_pos, $I10, $P10) = rx2394_cur."!mark_fail"(0)
    lt rx2394_pos, -1, rx2394_done
    eq rx2394_pos, -1, rx2394_fail
    jump $I10
  rx2394_done:
    rx2394_cur."!cursor_fail"()
    if_null rx2394_debug, debug_1386
    rx2394_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1386:
    .return (rx2394_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("276_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2398 = self."!PREFIX__!subrule"("ws", "q")
    new $P2399, "ResizablePMCArray"
    push $P2399, $P2398
    .return ($P2399)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("277_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2401_tgt
    .local int rx2401_pos
    .local int rx2401_off
    .local int rx2401_eos
    .local int rx2401_rep
    .local pmc rx2401_cur
    .local pmc rx2401_debug
    (rx2401_cur, rx2401_pos, rx2401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2401_cur
    .local pmc match
    .lex "$/", match
    length rx2401_eos, rx2401_tgt
    gt rx2401_pos, rx2401_eos, rx2401_done
    set rx2401_off, 0
    lt rx2401_pos, 2, rx2401_start
    sub rx2401_off, rx2401_pos, 1
    substr rx2401_tgt, rx2401_tgt, rx2401_off
  rx2401_start:
    eq $I10, 1, rx2401_restart
    if_null rx2401_debug, debug_1387
    rx2401_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1387:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2402_done
    goto rxscan2402_scan
  rxscan2402_loop:
    (rx2401_pos) = rx2401_cur."from"()
    inc rx2401_pos
    rx2401_cur."!cursor_from"(rx2401_pos)
    ge rx2401_pos, rx2401_eos, rxscan2402_done
  rxscan2402_scan:
    set_addr $I10, rxscan2402_loop
    rx2401_cur."!mark_push"(0, rx2401_pos, $I10)
  rxscan2402_done:
.annotate 'line', 1012
  # rx subcapture "sym"
    set_addr $I10, rxcap_2403_fail
    rx2401_cur."!mark_push"(0, rx2401_pos, $I10)
  # rx literal  "qq"
    add $I11, rx2401_pos, 2
    gt $I11, rx2401_eos, rx2401_fail
    sub $I11, rx2401_pos, rx2401_off
    substr $S10, rx2401_tgt, $I11, 2
    ne $S10, "qq", rx2401_fail
    add rx2401_pos, 2
    set_addr $I10, rxcap_2403_fail
    ($I12, $I11) = rx2401_cur."!mark_peek"($I10)
    rx2401_cur."!cursor_pos"($I11)
    ($P10) = rx2401_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2401_pos, "")
    rx2401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2403_done
  rxcap_2403_fail:
    goto rx2401_fail
  rxcap_2403_done:
  # rxanchor rwb
    le rx2401_pos, 0, rx2401_fail
    sub $I10, rx2401_pos, rx2401_off
    is_cclass $I11, 8192, rx2401_tgt, $I10
    if $I11, rx2401_fail
    dec $I10
    is_cclass $I11, 8192, rx2401_tgt, $I10
    unless $I11, rx2401_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2401_pos, rx2401_off
    substr $S10, rx2401_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2401_fail
  # rx subrule "ws" subtype=method negate=
    rx2401_cur."!cursor_pos"(rx2401_pos)
    $P10 = rx2401_cur."ws"()
    unless $P10, rx2401_fail
    rx2401_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2401_cur."!cursor_pos"(rx2401_pos)
    $P10 = rx2401_cur."quote_EXPR"(":qq")
    unless $P10, rx2401_fail
    rx2401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2401_pos = $P10."pos"()
  # rx pass
    rx2401_cur."!cursor_pass"(rx2401_pos, "quote:sym<qq>")
    if_null rx2401_debug, debug_1388
    rx2401_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx2401_pos)
  debug_1388:
    .return (rx2401_cur)
  rx2401_restart:
.annotate 'line', 436
    if_null rx2401_debug, debug_1389
    rx2401_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1389:
  rx2401_fail:
    (rx2401_rep, rx2401_pos, $I10, $P10) = rx2401_cur."!mark_fail"(0)
    lt rx2401_pos, -1, rx2401_done
    eq rx2401_pos, -1, rx2401_fail
    jump $I10
  rx2401_done:
    rx2401_cur."!cursor_fail"()
    if_null rx2401_debug, debug_1390
    rx2401_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1390:
    .return (rx2401_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("278_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2405 = self."!PREFIX__!subrule"("ws", "qq")
    new $P2406, "ResizablePMCArray"
    push $P2406, $P2405
    .return ($P2406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("279_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2408_tgt
    .local int rx2408_pos
    .local int rx2408_off
    .local int rx2408_eos
    .local int rx2408_rep
    .local pmc rx2408_cur
    .local pmc rx2408_debug
    (rx2408_cur, rx2408_pos, rx2408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2408_cur
    .local pmc match
    .lex "$/", match
    length rx2408_eos, rx2408_tgt
    gt rx2408_pos, rx2408_eos, rx2408_done
    set rx2408_off, 0
    lt rx2408_pos, 2, rx2408_start
    sub rx2408_off, rx2408_pos, 1
    substr rx2408_tgt, rx2408_tgt, rx2408_off
  rx2408_start:
    eq $I10, 1, rx2408_restart
    if_null rx2408_debug, debug_1391
    rx2408_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2409_done
    goto rxscan2409_scan
  rxscan2409_loop:
    (rx2408_pos) = rx2408_cur."from"()
    inc rx2408_pos
    rx2408_cur."!cursor_from"(rx2408_pos)
    ge rx2408_pos, rx2408_eos, rxscan2409_done
  rxscan2409_scan:
    set_addr $I10, rxscan2409_loop
    rx2408_cur."!mark_push"(0, rx2408_pos, $I10)
  rxscan2409_done:
.annotate 'line', 1013
  # rx subcapture "sym"
    set_addr $I10, rxcap_2410_fail
    rx2408_cur."!mark_push"(0, rx2408_pos, $I10)
  # rx literal  "Q"
    add $I11, rx2408_pos, 1
    gt $I11, rx2408_eos, rx2408_fail
    sub $I11, rx2408_pos, rx2408_off
    ord $I11, rx2408_tgt, $I11
    ne $I11, 81, rx2408_fail
    add rx2408_pos, 1
    set_addr $I10, rxcap_2410_fail
    ($I12, $I11) = rx2408_cur."!mark_peek"($I10)
    rx2408_cur."!cursor_pos"($I11)
    ($P10) = rx2408_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2408_pos, "")
    rx2408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2410_done
  rxcap_2410_fail:
    goto rx2408_fail
  rxcap_2410_done:
  # rxanchor rwb
    le rx2408_pos, 0, rx2408_fail
    sub $I10, rx2408_pos, rx2408_off
    is_cclass $I11, 8192, rx2408_tgt, $I10
    if $I11, rx2408_fail
    dec $I10
    is_cclass $I11, 8192, rx2408_tgt, $I10
    unless $I11, rx2408_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2408_pos, rx2408_off
    substr $S10, rx2408_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2408_fail
  # rx subrule "ws" subtype=method negate=
    rx2408_cur."!cursor_pos"(rx2408_pos)
    $P10 = rx2408_cur."ws"()
    unless $P10, rx2408_fail
    rx2408_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2408_cur."!cursor_pos"(rx2408_pos)
    $P10 = rx2408_cur."quote_EXPR"()
    unless $P10, rx2408_fail
    rx2408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2408_pos = $P10."pos"()
  # rx pass
    rx2408_cur."!cursor_pass"(rx2408_pos, "quote:sym<Q>")
    if_null rx2408_debug, debug_1392
    rx2408_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx2408_pos)
  debug_1392:
    .return (rx2408_cur)
  rx2408_restart:
.annotate 'line', 436
    if_null rx2408_debug, debug_1393
    rx2408_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1393:
  rx2408_fail:
    (rx2408_rep, rx2408_pos, $I10, $P10) = rx2408_cur."!mark_fail"(0)
    lt rx2408_pos, -1, rx2408_done
    eq rx2408_pos, -1, rx2408_fail
    jump $I10
  rx2408_done:
    rx2408_cur."!cursor_fail"()
    if_null rx2408_debug, debug_1394
    rx2408_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1394:
    .return (rx2408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("280_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2412 = self."!PREFIX__!subrule"("ws", "Q")
    new $P2413, "ResizablePMCArray"
    push $P2413, $P2412
    .return ($P2413)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("281_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2415_tgt
    .local int rx2415_pos
    .local int rx2415_off
    .local int rx2415_eos
    .local int rx2415_rep
    .local pmc rx2415_cur
    .local pmc rx2415_debug
    (rx2415_cur, rx2415_pos, rx2415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2415_cur
    .local pmc match
    .lex "$/", match
    length rx2415_eos, rx2415_tgt
    gt rx2415_pos, rx2415_eos, rx2415_done
    set rx2415_off, 0
    lt rx2415_pos, 2, rx2415_start
    sub rx2415_off, rx2415_pos, 1
    substr rx2415_tgt, rx2415_tgt, rx2415_off
  rx2415_start:
    eq $I10, 1, rx2415_restart
    if_null rx2415_debug, debug_1395
    rx2415_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1395:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2416_done
    goto rxscan2416_scan
  rxscan2416_loop:
    (rx2415_pos) = rx2415_cur."from"()
    inc rx2415_pos
    rx2415_cur."!cursor_from"(rx2415_pos)
    ge rx2415_pos, rx2415_eos, rxscan2416_done
  rxscan2416_scan:
    set_addr $I10, rxscan2416_loop
    rx2415_cur."!mark_push"(0, rx2415_pos, $I10)
  rxscan2416_done:
.annotate 'line', 1014
  # rx subcapture "sym"
    set_addr $I10, rxcap_2417_fail
    rx2415_cur."!mark_push"(0, rx2415_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx2415_pos, 5
    gt $I11, rx2415_eos, rx2415_fail
    sub $I11, rx2415_pos, rx2415_off
    substr $S10, rx2415_tgt, $I11, 5
    ne $S10, "Q:PIR", rx2415_fail
    add rx2415_pos, 5
    set_addr $I10, rxcap_2417_fail
    ($I12, $I11) = rx2415_cur."!mark_peek"($I10)
    rx2415_cur."!cursor_pos"($I11)
    ($P10) = rx2415_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2415_pos, "")
    rx2415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2417_done
  rxcap_2417_fail:
    goto rx2415_fail
  rxcap_2417_done:
  # rx subrule "ws" subtype=method negate=
    rx2415_cur."!cursor_pos"(rx2415_pos)
    $P10 = rx2415_cur."ws"()
    unless $P10, rx2415_fail
    rx2415_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2415_cur."!cursor_pos"(rx2415_pos)
    $P10 = rx2415_cur."quote_EXPR"()
    unless $P10, rx2415_fail
    rx2415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2415_pos = $P10."pos"()
  # rx pass
    rx2415_cur."!cursor_pass"(rx2415_pos, "quote:sym<Q:PIR>")
    if_null rx2415_debug, debug_1396
    rx2415_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx2415_pos)
  debug_1396:
    .return (rx2415_cur)
  rx2415_restart:
.annotate 'line', 436
    if_null rx2415_debug, debug_1397
    rx2415_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1397:
  rx2415_fail:
    (rx2415_rep, rx2415_pos, $I10, $P10) = rx2415_cur."!mark_fail"(0)
    lt rx2415_pos, -1, rx2415_done
    eq rx2415_pos, -1, rx2415_fail
    jump $I10
  rx2415_done:
    rx2415_cur."!cursor_fail"()
    if_null rx2415_debug, debug_1398
    rx2415_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1398:
    .return (rx2415_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("282_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2419 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P2420, "ResizablePMCArray"
    push $P2420, $P2419
    .return ($P2420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("283_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2422_tgt
    .local int rx2422_pos
    .local int rx2422_off
    .local int rx2422_eos
    .local int rx2422_rep
    .local pmc rx2422_cur
    .local pmc rx2422_debug
    (rx2422_cur, rx2422_pos, rx2422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2422_cur
    .local pmc match
    .lex "$/", match
    length rx2422_eos, rx2422_tgt
    gt rx2422_pos, rx2422_eos, rx2422_done
    set rx2422_off, 0
    lt rx2422_pos, 2, rx2422_start
    sub rx2422_off, rx2422_pos, 1
    substr rx2422_tgt, rx2422_tgt, rx2422_off
  rx2422_start:
    eq $I10, 1, rx2422_restart
    if_null rx2422_debug, debug_1399
    rx2422_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1399:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2423_done
    goto rxscan2423_scan
  rxscan2423_loop:
    (rx2422_pos) = rx2422_cur."from"()
    inc rx2422_pos
    rx2422_cur."!cursor_from"(rx2422_pos)
    ge rx2422_pos, rx2422_eos, rxscan2423_done
  rxscan2423_scan:
    set_addr $I10, rxscan2423_loop
    rx2422_cur."!mark_push"(0, rx2422_pos, $I10)
  rxscan2423_done:
.annotate 'line', 1016
  # rx literal  "/"
    add $I11, rx2422_pos, 1
    gt $I11, rx2422_eos, rx2422_fail
    sub $I11, rx2422_pos, rx2422_off
    ord $I11, rx2422_tgt, $I11
    ne $I11, 47, rx2422_fail
    add rx2422_pos, 1
.annotate 'line', 1017
  # rx subrule "newpad" subtype=method negate=
    rx2422_cur."!cursor_pos"(rx2422_pos)
    $P10 = rx2422_cur."newpad"()
    unless $P10, rx2422_fail
    rx2422_pos = $P10."pos"()
.annotate 'line', 1018
  # rx reduce name="quote:sym</ />" key="open"
    rx2422_cur."!cursor_pos"(rx2422_pos)
    rx2422_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 1019
  # rx subrule "LANG" subtype=capture negate=
    rx2422_cur."!cursor_pos"(rx2422_pos)
    $P10 = rx2422_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2422_fail
    rx2422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2422_pos = $P10."pos"()
.annotate 'line', 1020
  # rx literal  "/"
    add $I11, rx2422_pos, 1
    gt $I11, rx2422_eos, rx2422_fail
    sub $I11, rx2422_pos, rx2422_off
    ord $I11, rx2422_tgt, $I11
    ne $I11, 47, rx2422_fail
    add rx2422_pos, 1
.annotate 'line', 1015
  # rx pass
    rx2422_cur."!cursor_pass"(rx2422_pos, "quote:sym</ />")
    if_null rx2422_debug, debug_1400
    rx2422_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx2422_pos)
  debug_1400:
    .return (rx2422_cur)
  rx2422_restart:
.annotate 'line', 436
    if_null rx2422_debug, debug_1401
    rx2422_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1401:
  rx2422_fail:
    (rx2422_rep, rx2422_pos, $I10, $P10) = rx2422_cur."!mark_fail"(0)
    lt rx2422_pos, -1, rx2422_done
    eq rx2422_pos, -1, rx2422_fail
    jump $I10
  rx2422_done:
    rx2422_cur."!cursor_fail"()
    if_null rx2422_debug, debug_1402
    rx2422_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1402:
    .return (rx2422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("284_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2425 = self."!PREFIX__!subrule"("newpad", "/")
    new $P2426, "ResizablePMCArray"
    push $P2426, $P2425
    .return ($P2426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("285_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2428_tgt
    .local int rx2428_pos
    .local int rx2428_off
    .local int rx2428_eos
    .local int rx2428_rep
    .local pmc rx2428_cur
    .local pmc rx2428_debug
    (rx2428_cur, rx2428_pos, rx2428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2428_cur
    .local pmc match
    .lex "$/", match
    length rx2428_eos, rx2428_tgt
    gt rx2428_pos, rx2428_eos, rx2428_done
    set rx2428_off, 0
    lt rx2428_pos, 2, rx2428_start
    sub rx2428_off, rx2428_pos, 1
    substr rx2428_tgt, rx2428_tgt, rx2428_off
  rx2428_start:
    eq $I10, 1, rx2428_restart
    if_null rx2428_debug, debug_1403
    rx2428_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1403:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2429_done
    goto rxscan2429_scan
  rxscan2429_loop:
    (rx2428_pos) = rx2428_cur."from"()
    inc rx2428_pos
    rx2428_cur."!cursor_from"(rx2428_pos)
    ge rx2428_pos, rx2428_eos, rxscan2429_done
  rxscan2429_scan:
    set_addr $I10, rxscan2429_loop
    rx2428_cur."!mark_push"(0, rx2428_pos, $I10)
  rxscan2429_done:
.annotate 'line', 1023
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2428_pos, rx2428_off
    substr $S10, rx2428_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2428_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2428_cur."!cursor_pos"(rx2428_pos)
    $P10 = rx2428_cur."quotemod_check"("s")
    unless $P10, rx2428_fail
  # rx subrule "variable" subtype=capture negate=
    rx2428_cur."!cursor_pos"(rx2428_pos)
    $P10 = rx2428_cur."variable"()
    unless $P10, rx2428_fail
    rx2428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2428_pos = $P10."pos"()
  # rx pass
    rx2428_cur."!cursor_pass"(rx2428_pos, "quote_escape:sym<$>")
    if_null rx2428_debug, debug_1404
    rx2428_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2428_pos)
  debug_1404:
    .return (rx2428_cur)
  rx2428_restart:
.annotate 'line', 436
    if_null rx2428_debug, debug_1405
    rx2428_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1405:
  rx2428_fail:
    (rx2428_rep, rx2428_pos, $I10, $P10) = rx2428_cur."!mark_fail"(0)
    lt rx2428_pos, -1, rx2428_done
    eq rx2428_pos, -1, rx2428_fail
    jump $I10
  rx2428_done:
    rx2428_cur."!cursor_fail"()
    if_null rx2428_debug, debug_1406
    rx2428_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1406:
    .return (rx2428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("286_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2431, "ResizablePMCArray"
    push $P2431, "$"
    .return ($P2431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("287_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2433_tgt
    .local int rx2433_pos
    .local int rx2433_off
    .local int rx2433_eos
    .local int rx2433_rep
    .local pmc rx2433_cur
    .local pmc rx2433_debug
    (rx2433_cur, rx2433_pos, rx2433_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2433_cur
    .local pmc match
    .lex "$/", match
    length rx2433_eos, rx2433_tgt
    gt rx2433_pos, rx2433_eos, rx2433_done
    set rx2433_off, 0
    lt rx2433_pos, 2, rx2433_start
    sub rx2433_off, rx2433_pos, 1
    substr rx2433_tgt, rx2433_tgt, rx2433_off
  rx2433_start:
    eq $I10, 1, rx2433_restart
    if_null rx2433_debug, debug_1407
    rx2433_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1407:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2434_done
    goto rxscan2434_scan
  rxscan2434_loop:
    (rx2433_pos) = rx2433_cur."from"()
    inc rx2433_pos
    rx2433_cur."!cursor_from"(rx2433_pos)
    ge rx2433_pos, rx2433_eos, rxscan2434_done
  rxscan2434_scan:
    set_addr $I10, rxscan2434_loop
    rx2433_cur."!mark_push"(0, rx2433_pos, $I10)
  rxscan2434_done:
.annotate 'line', 1024
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2433_pos, rx2433_off
    substr $S10, rx2433_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2433_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2433_cur."!cursor_pos"(rx2433_pos)
    $P10 = rx2433_cur."quotemod_check"("c")
    unless $P10, rx2433_fail
  # rx subrule "block" subtype=capture negate=
    rx2433_cur."!cursor_pos"(rx2433_pos)
    $P10 = rx2433_cur."block"()
    unless $P10, rx2433_fail
    rx2433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2433_pos = $P10."pos"()
  # rx pass
    rx2433_cur."!cursor_pass"(rx2433_pos, "quote_escape:sym<{ }>")
    if_null rx2433_debug, debug_1408
    rx2433_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2433_pos)
  debug_1408:
    .return (rx2433_cur)
  rx2433_restart:
.annotate 'line', 436
    if_null rx2433_debug, debug_1409
    rx2433_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1409:
  rx2433_fail:
    (rx2433_rep, rx2433_pos, $I10, $P10) = rx2433_cur."!mark_fail"(0)
    lt rx2433_pos, -1, rx2433_done
    eq rx2433_pos, -1, rx2433_fail
    jump $I10
  rx2433_done:
    rx2433_cur."!cursor_fail"()
    if_null rx2433_debug, debug_1410
    rx2433_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1410:
    .return (rx2433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("288_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2436, "ResizablePMCArray"
    push $P2436, "{"
    .return ($P2436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("289_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2438_tgt
    .local int rx2438_pos
    .local int rx2438_off
    .local int rx2438_eos
    .local int rx2438_rep
    .local pmc rx2438_cur
    .local pmc rx2438_debug
    (rx2438_cur, rx2438_pos, rx2438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2438_cur
    .local pmc match
    .lex "$/", match
    length rx2438_eos, rx2438_tgt
    gt rx2438_pos, rx2438_eos, rx2438_done
    set rx2438_off, 0
    lt rx2438_pos, 2, rx2438_start
    sub rx2438_off, rx2438_pos, 1
    substr rx2438_tgt, rx2438_tgt, rx2438_off
  rx2438_start:
    eq $I10, 1, rx2438_restart
    if_null rx2438_debug, debug_1411
    rx2438_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1411:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2439_done
    goto rxscan2439_scan
  rxscan2439_loop:
    (rx2438_pos) = rx2438_cur."from"()
    inc rx2438_pos
    rx2438_cur."!cursor_from"(rx2438_pos)
    ge rx2438_pos, rx2438_eos, rxscan2439_done
  rxscan2439_scan:
    set_addr $I10, rxscan2439_loop
    rx2438_cur."!mark_push"(0, rx2438_pos, $I10)
  rxscan2439_done:
.annotate 'line', 1025
  # rx literal  "\\e"
    add $I11, rx2438_pos, 2
    gt $I11, rx2438_eos, rx2438_fail
    sub $I11, rx2438_pos, rx2438_off
    substr $S10, rx2438_tgt, $I11, 2
    ne $S10, "\\e", rx2438_fail
    add rx2438_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2438_cur."!cursor_pos"(rx2438_pos)
    $P10 = rx2438_cur."quotemod_check"("b")
    unless $P10, rx2438_fail
  # rx pass
    rx2438_cur."!cursor_pass"(rx2438_pos, "quote_escape:sym<esc>")
    if_null rx2438_debug, debug_1412
    rx2438_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2438_pos)
  debug_1412:
    .return (rx2438_cur)
  rx2438_restart:
.annotate 'line', 436
    if_null rx2438_debug, debug_1413
    rx2438_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1413:
  rx2438_fail:
    (rx2438_rep, rx2438_pos, $I10, $P10) = rx2438_cur."!mark_fail"(0)
    lt rx2438_pos, -1, rx2438_done
    eq rx2438_pos, -1, rx2438_fail
    jump $I10
  rx2438_done:
    rx2438_cur."!cursor_fail"()
    if_null rx2438_debug, debug_1414
    rx2438_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1414:
    .return (rx2438_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("290_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2441, "ResizablePMCArray"
    push $P2441, "\\e"
    .return ($P2441)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("291_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2443_tgt
    .local int rx2443_pos
    .local int rx2443_off
    .local int rx2443_eos
    .local int rx2443_rep
    .local pmc rx2443_cur
    .local pmc rx2443_debug
    (rx2443_cur, rx2443_pos, rx2443_tgt, $I10) = self."!cursor_start"()
    rx2443_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2443_cur
    .local pmc match
    .lex "$/", match
    length rx2443_eos, rx2443_tgt
    gt rx2443_pos, rx2443_eos, rx2443_done
    set rx2443_off, 0
    lt rx2443_pos, 2, rx2443_start
    sub rx2443_off, rx2443_pos, 1
    substr rx2443_tgt, rx2443_tgt, rx2443_off
  rx2443_start:
    eq $I10, 1, rx2443_restart
    if_null rx2443_debug, debug_1415
    rx2443_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1415:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2444_done
    goto rxscan2444_scan
  rxscan2444_loop:
    (rx2443_pos) = rx2443_cur."from"()
    inc rx2443_pos
    rx2443_cur."!cursor_from"(rx2443_pos)
    ge rx2443_pos, rx2443_eos, rxscan2444_done
  rxscan2444_scan:
    set_addr $I10, rxscan2444_loop
    rx2443_cur."!mark_push"(0, rx2443_pos, $I10)
  rxscan2444_done:
.annotate 'line', 1027
  # rx literal  "("
    add $I11, rx2443_pos, 1
    gt $I11, rx2443_eos, rx2443_fail
    sub $I11, rx2443_pos, rx2443_off
    ord $I11, rx2443_tgt, $I11
    ne $I11, 40, rx2443_fail
    add rx2443_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2443_cur."!cursor_pos"(rx2443_pos)
    $P10 = rx2443_cur."ws"()
    unless $P10, rx2443_fail
    rx2443_pos = $P10."pos"()
  # rx rxquantr2445 ** 0..1
    set_addr $I10, rxquantr2445_done
    rx2443_cur."!mark_push"(0, rx2443_pos, $I10)
  rxquantr2445_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2443_cur."!cursor_pos"(rx2443_pos)
    $P10 = rx2443_cur."EXPR"()
    unless $P10, rx2443_fail
    goto rxsubrule2446_pass
  rxsubrule2446_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2443_fail
  rxsubrule2446_pass:
    set_addr $I10, rxsubrule2446_back
    rx2443_cur."!mark_push"(0, rx2443_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2443_pos = $P10."pos"()
    set_addr $I10, rxquantr2445_done
    (rx2443_rep) = rx2443_cur."!mark_commit"($I10)
  rxquantr2445_done:
  # rx literal  ")"
    add $I11, rx2443_pos, 1
    gt $I11, rx2443_eos, rx2443_fail
    sub $I11, rx2443_pos, rx2443_off
    ord $I11, rx2443_tgt, $I11
    ne $I11, 41, rx2443_fail
    add rx2443_pos, 1
  # rx pass
    rx2443_cur."!cursor_pass"(rx2443_pos, "circumfix:sym<( )>")
    if_null rx2443_debug, debug_1416
    rx2443_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2443_pos)
  debug_1416:
    .return (rx2443_cur)
  rx2443_restart:
.annotate 'line', 436
    if_null rx2443_debug, debug_1417
    rx2443_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1417:
  rx2443_fail:
    (rx2443_rep, rx2443_pos, $I10, $P10) = rx2443_cur."!mark_fail"(0)
    lt rx2443_pos, -1, rx2443_done
    eq rx2443_pos, -1, rx2443_fail
    jump $I10
  rx2443_done:
    rx2443_cur."!cursor_fail"()
    if_null rx2443_debug, debug_1418
    rx2443_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1418:
    .return (rx2443_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("292_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2448 = self."!PREFIX__!subrule"("ws", "(")
    new $P2449, "ResizablePMCArray"
    push $P2449, $P2448
    .return ($P2449)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("293_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2451_tgt
    .local int rx2451_pos
    .local int rx2451_off
    .local int rx2451_eos
    .local int rx2451_rep
    .local pmc rx2451_cur
    .local pmc rx2451_debug
    (rx2451_cur, rx2451_pos, rx2451_tgt, $I10) = self."!cursor_start"()
    rx2451_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2451_cur
    .local pmc match
    .lex "$/", match
    length rx2451_eos, rx2451_tgt
    gt rx2451_pos, rx2451_eos, rx2451_done
    set rx2451_off, 0
    lt rx2451_pos, 2, rx2451_start
    sub rx2451_off, rx2451_pos, 1
    substr rx2451_tgt, rx2451_tgt, rx2451_off
  rx2451_start:
    eq $I10, 1, rx2451_restart
    if_null rx2451_debug, debug_1419
    rx2451_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1419:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2452_done
    goto rxscan2452_scan
  rxscan2452_loop:
    (rx2451_pos) = rx2451_cur."from"()
    inc rx2451_pos
    rx2451_cur."!cursor_from"(rx2451_pos)
    ge rx2451_pos, rx2451_eos, rxscan2452_done
  rxscan2452_scan:
    set_addr $I10, rxscan2452_loop
    rx2451_cur."!mark_push"(0, rx2451_pos, $I10)
  rxscan2452_done:
.annotate 'line', 1028
  # rx literal  "["
    add $I11, rx2451_pos, 1
    gt $I11, rx2451_eos, rx2451_fail
    sub $I11, rx2451_pos, rx2451_off
    ord $I11, rx2451_tgt, $I11
    ne $I11, 91, rx2451_fail
    add rx2451_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2451_cur."!cursor_pos"(rx2451_pos)
    $P10 = rx2451_cur."ws"()
    unless $P10, rx2451_fail
    rx2451_pos = $P10."pos"()
  # rx rxquantr2453 ** 0..1
    set_addr $I10, rxquantr2453_done
    rx2451_cur."!mark_push"(0, rx2451_pos, $I10)
  rxquantr2453_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2451_cur."!cursor_pos"(rx2451_pos)
    $P10 = rx2451_cur."EXPR"()
    unless $P10, rx2451_fail
    goto rxsubrule2454_pass
  rxsubrule2454_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2451_fail
  rxsubrule2454_pass:
    set_addr $I10, rxsubrule2454_back
    rx2451_cur."!mark_push"(0, rx2451_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2451_pos = $P10."pos"()
    set_addr $I10, rxquantr2453_done
    (rx2451_rep) = rx2451_cur."!mark_commit"($I10)
  rxquantr2453_done:
  # rx literal  "]"
    add $I11, rx2451_pos, 1
    gt $I11, rx2451_eos, rx2451_fail
    sub $I11, rx2451_pos, rx2451_off
    ord $I11, rx2451_tgt, $I11
    ne $I11, 93, rx2451_fail
    add rx2451_pos, 1
  # rx pass
    rx2451_cur."!cursor_pass"(rx2451_pos, "circumfix:sym<[ ]>")
    if_null rx2451_debug, debug_1420
    rx2451_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2451_pos)
  debug_1420:
    .return (rx2451_cur)
  rx2451_restart:
.annotate 'line', 436
    if_null rx2451_debug, debug_1421
    rx2451_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1421:
  rx2451_fail:
    (rx2451_rep, rx2451_pos, $I10, $P10) = rx2451_cur."!mark_fail"(0)
    lt rx2451_pos, -1, rx2451_done
    eq rx2451_pos, -1, rx2451_fail
    jump $I10
  rx2451_done:
    rx2451_cur."!cursor_fail"()
    if_null rx2451_debug, debug_1422
    rx2451_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1422:
    .return (rx2451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("294_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2456 = self."!PREFIX__!subrule"("ws", "[")
    new $P2457, "ResizablePMCArray"
    push $P2457, $P2456
    .return ($P2457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("295_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2459_tgt
    .local int rx2459_pos
    .local int rx2459_off
    .local int rx2459_eos
    .local int rx2459_rep
    .local pmc rx2459_cur
    .local pmc rx2459_debug
    (rx2459_cur, rx2459_pos, rx2459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2459_cur
    .local pmc match
    .lex "$/", match
    length rx2459_eos, rx2459_tgt
    gt rx2459_pos, rx2459_eos, rx2459_done
    set rx2459_off, 0
    lt rx2459_pos, 2, rx2459_start
    sub rx2459_off, rx2459_pos, 1
    substr rx2459_tgt, rx2459_tgt, rx2459_off
  rx2459_start:
    eq $I10, 1, rx2459_restart
    if_null rx2459_debug, debug_1423
    rx2459_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1423:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2460_done
    goto rxscan2460_scan
  rxscan2460_loop:
    (rx2459_pos) = rx2459_cur."from"()
    inc rx2459_pos
    rx2459_cur."!cursor_from"(rx2459_pos)
    ge rx2459_pos, rx2459_eos, rxscan2460_done
  rxscan2460_scan:
    set_addr $I10, rxscan2460_loop
    rx2459_cur."!mark_push"(0, rx2459_pos, $I10)
  rxscan2460_done:
.annotate 'line', 1029
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2459_pos, rx2459_off
    substr $S10, rx2459_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2459_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2459_cur."!cursor_pos"(rx2459_pos)
    $P10 = rx2459_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2459_fail
    rx2459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2459_pos = $P10."pos"()
  # rx pass
    rx2459_cur."!cursor_pass"(rx2459_pos, "circumfix:sym<ang>")
    if_null rx2459_debug, debug_1424
    rx2459_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2459_pos)
  debug_1424:
    .return (rx2459_cur)
  rx2459_restart:
.annotate 'line', 436
    if_null rx2459_debug, debug_1425
    rx2459_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1425:
  rx2459_fail:
    (rx2459_rep, rx2459_pos, $I10, $P10) = rx2459_cur."!mark_fail"(0)
    lt rx2459_pos, -1, rx2459_done
    eq rx2459_pos, -1, rx2459_fail
    jump $I10
  rx2459_done:
    rx2459_cur."!cursor_fail"()
    if_null rx2459_debug, debug_1426
    rx2459_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1426:
    .return (rx2459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("296_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2462, "ResizablePMCArray"
    push $P2462, "<"
    .return ($P2462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("297_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2464_tgt
    .local int rx2464_pos
    .local int rx2464_off
    .local int rx2464_eos
    .local int rx2464_rep
    .local pmc rx2464_cur
    .local pmc rx2464_debug
    (rx2464_cur, rx2464_pos, rx2464_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2464_cur
    .local pmc match
    .lex "$/", match
    length rx2464_eos, rx2464_tgt
    gt rx2464_pos, rx2464_eos, rx2464_done
    set rx2464_off, 0
    lt rx2464_pos, 2, rx2464_start
    sub rx2464_off, rx2464_pos, 1
    substr rx2464_tgt, rx2464_tgt, rx2464_off
  rx2464_start:
    eq $I10, 1, rx2464_restart
    if_null rx2464_debug, debug_1427
    rx2464_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1427:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2465_done
    goto rxscan2465_scan
  rxscan2465_loop:
    (rx2464_pos) = rx2464_cur."from"()
    inc rx2464_pos
    rx2464_cur."!cursor_from"(rx2464_pos)
    ge rx2464_pos, rx2464_eos, rxscan2465_done
  rxscan2465_scan:
    set_addr $I10, rxscan2465_loop
    rx2464_cur."!mark_push"(0, rx2464_pos, $I10)
  rxscan2465_done:
.annotate 'line', 1030
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2464_pos, rx2464_off
    substr $S10, rx2464_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2464_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2464_cur."!cursor_pos"(rx2464_pos)
    $P10 = rx2464_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2464_fail
    rx2464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2464_pos = $P10."pos"()
  # rx pass
    rx2464_cur."!cursor_pass"(rx2464_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2464_debug, debug_1428
    rx2464_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2464_pos)
  debug_1428:
    .return (rx2464_cur)
  rx2464_restart:
.annotate 'line', 436
    if_null rx2464_debug, debug_1429
    rx2464_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1429:
  rx2464_fail:
    (rx2464_rep, rx2464_pos, $I10, $P10) = rx2464_cur."!mark_fail"(0)
    lt rx2464_pos, -1, rx2464_done
    eq rx2464_pos, -1, rx2464_fail
    jump $I10
  rx2464_done:
    rx2464_cur."!cursor_fail"()
    if_null rx2464_debug, debug_1430
    rx2464_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1430:
    .return (rx2464_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("298_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2467, "ResizablePMCArray"
    push $P2467, unicode:"\x{ab}"
    .return ($P2467)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("299_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2469_tgt
    .local int rx2469_pos
    .local int rx2469_off
    .local int rx2469_eos
    .local int rx2469_rep
    .local pmc rx2469_cur
    .local pmc rx2469_debug
    (rx2469_cur, rx2469_pos, rx2469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2469_cur
    .local pmc match
    .lex "$/", match
    length rx2469_eos, rx2469_tgt
    gt rx2469_pos, rx2469_eos, rx2469_done
    set rx2469_off, 0
    lt rx2469_pos, 2, rx2469_start
    sub rx2469_off, rx2469_pos, 1
    substr rx2469_tgt, rx2469_tgt, rx2469_off
  rx2469_start:
    eq $I10, 1, rx2469_restart
    if_null rx2469_debug, debug_1431
    rx2469_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1431:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2470_done
    goto rxscan2470_scan
  rxscan2470_loop:
    (rx2469_pos) = rx2469_cur."from"()
    inc rx2469_pos
    rx2469_cur."!cursor_from"(rx2469_pos)
    ge rx2469_pos, rx2469_eos, rxscan2470_done
  rxscan2470_scan:
    set_addr $I10, rxscan2470_loop
    rx2469_cur."!mark_push"(0, rx2469_pos, $I10)
  rxscan2470_done:
.annotate 'line', 1031
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2469_pos, rx2469_off
    substr $S10, rx2469_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2469_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2469_cur."!cursor_pos"(rx2469_pos)
    $P10 = rx2469_cur."pblock"()
    unless $P10, rx2469_fail
    rx2469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2469_pos = $P10."pos"()
  # rx pass
    rx2469_cur."!cursor_pass"(rx2469_pos, "circumfix:sym<{ }>")
    if_null rx2469_debug, debug_1432
    rx2469_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2469_pos)
  debug_1432:
    .return (rx2469_cur)
  rx2469_restart:
.annotate 'line', 436
    if_null rx2469_debug, debug_1433
    rx2469_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1433:
  rx2469_fail:
    (rx2469_rep, rx2469_pos, $I10, $P10) = rx2469_cur."!mark_fail"(0)
    lt rx2469_pos, -1, rx2469_done
    eq rx2469_pos, -1, rx2469_fail
    jump $I10
  rx2469_done:
    rx2469_cur."!cursor_fail"()
    if_null rx2469_debug, debug_1434
    rx2469_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1434:
    .return (rx2469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("300_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2472, "ResizablePMCArray"
    push $P2472, "{"
    .return ($P2472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("301_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2474_tgt
    .local int rx2474_pos
    .local int rx2474_off
    .local int rx2474_eos
    .local int rx2474_rep
    .local pmc rx2474_cur
    .local pmc rx2474_debug
    (rx2474_cur, rx2474_pos, rx2474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2474_cur
    .local pmc match
    .lex "$/", match
    length rx2474_eos, rx2474_tgt
    gt rx2474_pos, rx2474_eos, rx2474_done
    set rx2474_off, 0
    lt rx2474_pos, 2, rx2474_start
    sub rx2474_off, rx2474_pos, 1
    substr rx2474_tgt, rx2474_tgt, rx2474_off
  rx2474_start:
    eq $I10, 1, rx2474_restart
    if_null rx2474_debug, debug_1435
    rx2474_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1435:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2475_done
    goto rxscan2475_scan
  rxscan2475_loop:
    (rx2474_pos) = rx2474_cur."from"()
    inc rx2474_pos
    rx2474_cur."!cursor_from"(rx2474_pos)
    ge rx2474_pos, rx2474_eos, rxscan2475_done
  rxscan2475_scan:
    set_addr $I10, rxscan2475_loop
    rx2474_cur."!mark_push"(0, rx2474_pos, $I10)
  rxscan2475_done:
.annotate 'line', 1032
  # rx subrule "sigil" subtype=capture negate=
    rx2474_cur."!cursor_pos"(rx2474_pos)
    $P10 = rx2474_cur."sigil"()
    unless $P10, rx2474_fail
    rx2474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2474_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2474_pos, 1
    gt $I11, rx2474_eos, rx2474_fail
    sub $I11, rx2474_pos, rx2474_off
    ord $I11, rx2474_tgt, $I11
    ne $I11, 40, rx2474_fail
    add rx2474_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2474_cur."!cursor_pos"(rx2474_pos)
    $P10 = rx2474_cur."semilist"()
    unless $P10, rx2474_fail
    rx2474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2474_pos = $P10."pos"()
  alt2476_0:
    set_addr $I10, alt2476_1
    rx2474_cur."!mark_push"(0, rx2474_pos, $I10)
  # rx literal  ")"
    add $I11, rx2474_pos, 1
    gt $I11, rx2474_eos, rx2474_fail
    sub $I11, rx2474_pos, rx2474_off
    ord $I11, rx2474_tgt, $I11
    ne $I11, 41, rx2474_fail
    add rx2474_pos, 1
    goto alt2476_end
  alt2476_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2474_cur."!cursor_pos"(rx2474_pos)
    $P10 = rx2474_cur."FAILGOAL"("')'")
    unless $P10, rx2474_fail
    goto rxsubrule2478_pass
  rxsubrule2478_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2474_fail
  rxsubrule2478_pass:
    set_addr $I10, rxsubrule2478_back
    rx2474_cur."!mark_push"(0, rx2474_pos, $I10, $P10)
    rx2474_pos = $P10."pos"()
  alt2476_end:
  # rx pass
    rx2474_cur."!cursor_pass"(rx2474_pos, "circumfix:sym<sigil>")
    if_null rx2474_debug, debug_1436
    rx2474_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2474_pos)
  debug_1436:
    .return (rx2474_cur)
  rx2474_restart:
.annotate 'line', 436
    if_null rx2474_debug, debug_1437
    rx2474_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1437:
  rx2474_fail:
    (rx2474_rep, rx2474_pos, $I10, $P10) = rx2474_cur."!mark_fail"(0)
    lt rx2474_pos, -1, rx2474_done
    eq rx2474_pos, -1, rx2474_fail
    jump $I10
  rx2474_done:
    rx2474_cur."!cursor_fail"()
    if_null rx2474_debug, debug_1438
    rx2474_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1438:
    .return (rx2474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("302_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2480 = self."!PREFIX__!subrule"("sigil", "")
    new $P2481, "ResizablePMCArray"
    push $P2481, $P2480
    .return ($P2481)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("303_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2483_tgt
    .local int rx2483_pos
    .local int rx2483_off
    .local int rx2483_eos
    .local int rx2483_rep
    .local pmc rx2483_cur
    .local pmc rx2483_debug
    (rx2483_cur, rx2483_pos, rx2483_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2483_cur
    .local pmc match
    .lex "$/", match
    length rx2483_eos, rx2483_tgt
    gt rx2483_pos, rx2483_eos, rx2483_done
    set rx2483_off, 0
    lt rx2483_pos, 2, rx2483_start
    sub rx2483_off, rx2483_pos, 1
    substr rx2483_tgt, rx2483_tgt, rx2483_off
  rx2483_start:
    eq $I10, 1, rx2483_restart
    if_null rx2483_debug, debug_1439
    rx2483_cur."!cursor_debug"("START", "semilist")
  debug_1439:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2484_done
    goto rxscan2484_scan
  rxscan2484_loop:
    (rx2483_pos) = rx2483_cur."from"()
    inc rx2483_pos
    rx2483_cur."!cursor_from"(rx2483_pos)
    ge rx2483_pos, rx2483_eos, rxscan2484_done
  rxscan2484_scan:
    set_addr $I10, rxscan2484_loop
    rx2483_cur."!mark_push"(0, rx2483_pos, $I10)
  rxscan2484_done:
.annotate 'line', 1034
  # rx subrule "ws" subtype=method negate=
    rx2483_cur."!cursor_pos"(rx2483_pos)
    $P10 = rx2483_cur."ws"()
    unless $P10, rx2483_fail
    rx2483_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2483_cur."!cursor_pos"(rx2483_pos)
    $P10 = rx2483_cur."statement"()
    unless $P10, rx2483_fail
    rx2483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2483_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2483_cur."!cursor_pos"(rx2483_pos)
    $P10 = rx2483_cur."ws"()
    unless $P10, rx2483_fail
    rx2483_pos = $P10."pos"()
  # rx pass
    rx2483_cur."!cursor_pass"(rx2483_pos, "semilist")
    if_null rx2483_debug, debug_1440
    rx2483_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2483_pos)
  debug_1440:
    .return (rx2483_cur)
  rx2483_restart:
.annotate 'line', 436
    if_null rx2483_debug, debug_1441
    rx2483_cur."!cursor_debug"("NEXT", "semilist")
  debug_1441:
  rx2483_fail:
    (rx2483_rep, rx2483_pos, $I10, $P10) = rx2483_cur."!mark_fail"(0)
    lt rx2483_pos, -1, rx2483_done
    eq rx2483_pos, -1, rx2483_fail
    jump $I10
  rx2483_done:
    rx2483_cur."!cursor_fail"()
    if_null rx2483_debug, debug_1442
    rx2483_cur."!cursor_debug"("FAIL", "semilist")
  debug_1442:
    .return (rx2483_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("304_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2488 = self."!PREFIX__!subrule"("ws", "")
    new $P2489, "ResizablePMCArray"
    push $P2489, $P2488
    .return ($P2489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("305_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2491_tgt
    .local int rx2491_pos
    .local int rx2491_off
    .local int rx2491_eos
    .local int rx2491_rep
    .local pmc rx2491_cur
    .local pmc rx2491_debug
    (rx2491_cur, rx2491_pos, rx2491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2491_cur
    .local pmc match
    .lex "$/", match
    length rx2491_eos, rx2491_tgt
    gt rx2491_pos, rx2491_eos, rx2491_done
    set rx2491_off, 0
    lt rx2491_pos, 2, rx2491_start
    sub rx2491_off, rx2491_pos, 1
    substr rx2491_tgt, rx2491_tgt, rx2491_off
  rx2491_start:
    eq $I10, 1, rx2491_restart
    if_null rx2491_debug, debug_1443
    rx2491_cur."!cursor_debug"("START", "infixish")
  debug_1443:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2492_done
    goto rxscan2492_scan
  rxscan2492_loop:
    (rx2491_pos) = rx2491_cur."from"()
    inc rx2491_pos
    rx2491_cur."!cursor_from"(rx2491_pos)
    ge rx2491_pos, rx2491_eos, rxscan2492_done
  rxscan2492_scan:
    set_addr $I10, rxscan2492_loop
    rx2491_cur."!mark_push"(0, rx2491_pos, $I10)
  rxscan2492_done:
.annotate 'line', 1057
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2491_cur."!cursor_pos"(rx2491_pos)
    $P10 = rx2491_cur."infixstopper"()
    if $P10, rx2491_fail
  # rx subrule "infix" subtype=capture negate=
    rx2491_cur."!cursor_pos"(rx2491_pos)
    $P10 = rx2491_cur."infix"()
    unless $P10, rx2491_fail
    rx2491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2491_pos = $P10."pos"()
  # rx pass
    rx2491_cur."!cursor_pass"(rx2491_pos, "infixish")
    if_null rx2491_debug, debug_1444
    rx2491_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2491_pos)
  debug_1444:
    .return (rx2491_cur)
  rx2491_restart:
.annotate 'line', 436
    if_null rx2491_debug, debug_1445
    rx2491_cur."!cursor_debug"("NEXT", "infixish")
  debug_1445:
  rx2491_fail:
    (rx2491_rep, rx2491_pos, $I10, $P10) = rx2491_cur."!mark_fail"(0)
    lt rx2491_pos, -1, rx2491_done
    eq rx2491_pos, -1, rx2491_fail
    jump $I10
  rx2491_done:
    rx2491_cur."!cursor_fail"()
    if_null rx2491_debug, debug_1446
    rx2491_cur."!cursor_debug"("FAIL", "infixish")
  debug_1446:
    .return (rx2491_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("306_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2494, "ResizablePMCArray"
    push $P2494, ""
    .return ($P2494)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("307_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2496_tgt
    .local int rx2496_pos
    .local int rx2496_off
    .local int rx2496_eos
    .local int rx2496_rep
    .local pmc rx2496_cur
    .local pmc rx2496_debug
    (rx2496_cur, rx2496_pos, rx2496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2496_cur
    .local pmc match
    .lex "$/", match
    length rx2496_eos, rx2496_tgt
    gt rx2496_pos, rx2496_eos, rx2496_done
    set rx2496_off, 0
    lt rx2496_pos, 2, rx2496_start
    sub rx2496_off, rx2496_pos, 1
    substr rx2496_tgt, rx2496_tgt, rx2496_off
  rx2496_start:
    eq $I10, 1, rx2496_restart
    if_null rx2496_debug, debug_1447
    rx2496_cur."!cursor_debug"("START", "infixstopper")
  debug_1447:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2497_done
    goto rxscan2497_scan
  rxscan2497_loop:
    (rx2496_pos) = rx2496_cur."from"()
    inc rx2496_pos
    rx2496_cur."!cursor_from"(rx2496_pos)
    ge rx2496_pos, rx2496_eos, rxscan2497_done
  rxscan2497_scan:
    set_addr $I10, rxscan2497_loop
    rx2496_cur."!mark_push"(0, rx2496_pos, $I10)
  rxscan2497_done:
.annotate 'line', 1058
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2496_cur."!cursor_pos"(rx2496_pos)
    $P10 = rx2496_cur."lambda"()
    unless $P10, rx2496_fail
  # rx pass
    rx2496_cur."!cursor_pass"(rx2496_pos, "infixstopper")
    if_null rx2496_debug, debug_1448
    rx2496_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2496_pos)
  debug_1448:
    .return (rx2496_cur)
  rx2496_restart:
.annotate 'line', 436
    if_null rx2496_debug, debug_1449
    rx2496_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1449:
  rx2496_fail:
    (rx2496_rep, rx2496_pos, $I10, $P10) = rx2496_cur."!mark_fail"(0)
    lt rx2496_pos, -1, rx2496_done
    eq rx2496_pos, -1, rx2496_fail
    jump $I10
  rx2496_done:
    rx2496_cur."!cursor_fail"()
    if_null rx2496_debug, debug_1450
    rx2496_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1450:
    .return (rx2496_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("308_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2499, "ResizablePMCArray"
    push $P2499, ""
    .return ($P2499)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("309_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2501_tgt
    .local int rx2501_pos
    .local int rx2501_off
    .local int rx2501_eos
    .local int rx2501_rep
    .local pmc rx2501_cur
    .local pmc rx2501_debug
    (rx2501_cur, rx2501_pos, rx2501_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2501_cur
    .local pmc match
    .lex "$/", match
    length rx2501_eos, rx2501_tgt
    gt rx2501_pos, rx2501_eos, rx2501_done
    set rx2501_off, 0
    lt rx2501_pos, 2, rx2501_start
    sub rx2501_off, rx2501_pos, 1
    substr rx2501_tgt, rx2501_tgt, rx2501_off
  rx2501_start:
    eq $I10, 1, rx2501_restart
    if_null rx2501_debug, debug_1451
    rx2501_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1451:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2502_done
    goto rxscan2502_scan
  rxscan2502_loop:
    (rx2501_pos) = rx2501_cur."from"()
    inc rx2501_pos
    rx2501_cur."!cursor_from"(rx2501_pos)
    ge rx2501_pos, rx2501_eos, rxscan2502_done
  rxscan2502_scan:
    set_addr $I10, rxscan2502_loop
    rx2501_cur."!mark_push"(0, rx2501_pos, $I10)
  rxscan2502_done:
.annotate 'line', 1061
  # rx literal  "["
    add $I11, rx2501_pos, 1
    gt $I11, rx2501_eos, rx2501_fail
    sub $I11, rx2501_pos, rx2501_off
    ord $I11, rx2501_tgt, $I11
    ne $I11, 91, rx2501_fail
    add rx2501_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2501_cur."!cursor_pos"(rx2501_pos)
    $P10 = rx2501_cur."ws"()
    unless $P10, rx2501_fail
    rx2501_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2501_cur."!cursor_pos"(rx2501_pos)
    $P10 = rx2501_cur."EXPR"()
    unless $P10, rx2501_fail
    rx2501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2501_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2501_pos, 1
    gt $I11, rx2501_eos, rx2501_fail
    sub $I11, rx2501_pos, rx2501_off
    ord $I11, rx2501_tgt, $I11
    ne $I11, 93, rx2501_fail
    add rx2501_pos, 1
.annotate 'line', 1062
  # rx subrule "O" subtype=capture negate=
    rx2501_cur."!cursor_pos"(rx2501_pos)
    $P10 = rx2501_cur."O"("%methodop")
    unless $P10, rx2501_fail
    rx2501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2501_pos = $P10."pos"()
.annotate 'line', 1060
  # rx pass
    rx2501_cur."!cursor_pass"(rx2501_pos, "postcircumfix:sym<[ ]>")
    if_null rx2501_debug, debug_1452
    rx2501_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2501_pos)
  debug_1452:
    .return (rx2501_cur)
  rx2501_restart:
.annotate 'line', 436
    if_null rx2501_debug, debug_1453
    rx2501_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1453:
  rx2501_fail:
    (rx2501_rep, rx2501_pos, $I10, $P10) = rx2501_cur."!mark_fail"(0)
    lt rx2501_pos, -1, rx2501_done
    eq rx2501_pos, -1, rx2501_fail
    jump $I10
  rx2501_done:
    rx2501_cur."!cursor_fail"()
    if_null rx2501_debug, debug_1454
    rx2501_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1454:
    .return (rx2501_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("310_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2504 = self."!PREFIX__!subrule"("ws", "[")
    new $P2505, "ResizablePMCArray"
    push $P2505, $P2504
    .return ($P2505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("311_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2507_tgt
    .local int rx2507_pos
    .local int rx2507_off
    .local int rx2507_eos
    .local int rx2507_rep
    .local pmc rx2507_cur
    .local pmc rx2507_debug
    (rx2507_cur, rx2507_pos, rx2507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2507_cur
    .local pmc match
    .lex "$/", match
    length rx2507_eos, rx2507_tgt
    gt rx2507_pos, rx2507_eos, rx2507_done
    set rx2507_off, 0
    lt rx2507_pos, 2, rx2507_start
    sub rx2507_off, rx2507_pos, 1
    substr rx2507_tgt, rx2507_tgt, rx2507_off
  rx2507_start:
    eq $I10, 1, rx2507_restart
    if_null rx2507_debug, debug_1455
    rx2507_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2508_done
    goto rxscan2508_scan
  rxscan2508_loop:
    (rx2507_pos) = rx2507_cur."from"()
    inc rx2507_pos
    rx2507_cur."!cursor_from"(rx2507_pos)
    ge rx2507_pos, rx2507_eos, rxscan2508_done
  rxscan2508_scan:
    set_addr $I10, rxscan2508_loop
    rx2507_cur."!mark_push"(0, rx2507_pos, $I10)
  rxscan2508_done:
.annotate 'line', 1066
  # rx literal  "{"
    add $I11, rx2507_pos, 1
    gt $I11, rx2507_eos, rx2507_fail
    sub $I11, rx2507_pos, rx2507_off
    ord $I11, rx2507_tgt, $I11
    ne $I11, 123, rx2507_fail
    add rx2507_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."ws"()
    unless $P10, rx2507_fail
    rx2507_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."EXPR"()
    unless $P10, rx2507_fail
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2507_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2507_pos, 1
    gt $I11, rx2507_eos, rx2507_fail
    sub $I11, rx2507_pos, rx2507_off
    ord $I11, rx2507_tgt, $I11
    ne $I11, 125, rx2507_fail
    add rx2507_pos, 1
.annotate 'line', 1067
  # rx subrule "O" subtype=capture negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."O"("%methodop")
    unless $P10, rx2507_fail
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2507_pos = $P10."pos"()
.annotate 'line', 1065
  # rx pass
    rx2507_cur."!cursor_pass"(rx2507_pos, "postcircumfix:sym<{ }>")
    if_null rx2507_debug, debug_1456
    rx2507_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2507_pos)
  debug_1456:
    .return (rx2507_cur)
  rx2507_restart:
.annotate 'line', 436
    if_null rx2507_debug, debug_1457
    rx2507_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1457:
  rx2507_fail:
    (rx2507_rep, rx2507_pos, $I10, $P10) = rx2507_cur."!mark_fail"(0)
    lt rx2507_pos, -1, rx2507_done
    eq rx2507_pos, -1, rx2507_fail
    jump $I10
  rx2507_done:
    rx2507_cur."!cursor_fail"()
    if_null rx2507_debug, debug_1458
    rx2507_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1458:
    .return (rx2507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("312_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2510 = self."!PREFIX__!subrule"("ws", "{")
    new $P2511, "ResizablePMCArray"
    push $P2511, $P2510
    .return ($P2511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("313_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2513_tgt
    .local int rx2513_pos
    .local int rx2513_off
    .local int rx2513_eos
    .local int rx2513_rep
    .local pmc rx2513_cur
    .local pmc rx2513_debug
    (rx2513_cur, rx2513_pos, rx2513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2513_cur
    .local pmc match
    .lex "$/", match
    length rx2513_eos, rx2513_tgt
    gt rx2513_pos, rx2513_eos, rx2513_done
    set rx2513_off, 0
    lt rx2513_pos, 2, rx2513_start
    sub rx2513_off, rx2513_pos, 1
    substr rx2513_tgt, rx2513_tgt, rx2513_off
  rx2513_start:
    eq $I10, 1, rx2513_restart
    if_null rx2513_debug, debug_1459
    rx2513_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1459:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2514_done
    goto rxscan2514_scan
  rxscan2514_loop:
    (rx2513_pos) = rx2513_cur."from"()
    inc rx2513_pos
    rx2513_cur."!cursor_from"(rx2513_pos)
    ge rx2513_pos, rx2513_eos, rxscan2514_done
  rxscan2514_scan:
    set_addr $I10, rxscan2514_loop
    rx2513_cur."!mark_push"(0, rx2513_pos, $I10)
  rxscan2514_done:
.annotate 'line', 1071
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2513_pos, rx2513_off
    substr $S10, rx2513_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2513_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    $P10 = rx2513_cur."quote_EXPR"(":q")
    unless $P10, rx2513_fail
    rx2513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2513_pos = $P10."pos"()
.annotate 'line', 1072
  # rx subrule "O" subtype=capture negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    $P10 = rx2513_cur."O"("%methodop")
    unless $P10, rx2513_fail
    rx2513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2513_pos = $P10."pos"()
.annotate 'line', 1070
  # rx pass
    rx2513_cur."!cursor_pass"(rx2513_pos, "postcircumfix:sym<ang>")
    if_null rx2513_debug, debug_1460
    rx2513_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2513_pos)
  debug_1460:
    .return (rx2513_cur)
  rx2513_restart:
.annotate 'line', 436
    if_null rx2513_debug, debug_1461
    rx2513_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1461:
  rx2513_fail:
    (rx2513_rep, rx2513_pos, $I10, $P10) = rx2513_cur."!mark_fail"(0)
    lt rx2513_pos, -1, rx2513_done
    eq rx2513_pos, -1, rx2513_fail
    jump $I10
  rx2513_done:
    rx2513_cur."!cursor_fail"()
    if_null rx2513_debug, debug_1462
    rx2513_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1462:
    .return (rx2513_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("314_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2516, "ResizablePMCArray"
    push $P2516, "<"
    .return ($P2516)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("315_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2518_tgt
    .local int rx2518_pos
    .local int rx2518_off
    .local int rx2518_eos
    .local int rx2518_rep
    .local pmc rx2518_cur
    .local pmc rx2518_debug
    (rx2518_cur, rx2518_pos, rx2518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2518_cur
    .local pmc match
    .lex "$/", match
    length rx2518_eos, rx2518_tgt
    gt rx2518_pos, rx2518_eos, rx2518_done
    set rx2518_off, 0
    lt rx2518_pos, 2, rx2518_start
    sub rx2518_off, rx2518_pos, 1
    substr rx2518_tgt, rx2518_tgt, rx2518_off
  rx2518_start:
    eq $I10, 1, rx2518_restart
    if_null rx2518_debug, debug_1463
    rx2518_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1463:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2519_done
    goto rxscan2519_scan
  rxscan2519_loop:
    (rx2518_pos) = rx2518_cur."from"()
    inc rx2518_pos
    rx2518_cur."!cursor_from"(rx2518_pos)
    ge rx2518_pos, rx2518_eos, rxscan2519_done
  rxscan2519_scan:
    set_addr $I10, rxscan2519_loop
    rx2518_cur."!mark_push"(0, rx2518_pos, $I10)
  rxscan2519_done:
.annotate 'line', 1076
  # rx literal  "("
    add $I11, rx2518_pos, 1
    gt $I11, rx2518_eos, rx2518_fail
    sub $I11, rx2518_pos, rx2518_off
    ord $I11, rx2518_tgt, $I11
    ne $I11, 40, rx2518_fail
    add rx2518_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2518_cur."!cursor_pos"(rx2518_pos)
    $P10 = rx2518_cur."ws"()
    unless $P10, rx2518_fail
    rx2518_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2518_cur."!cursor_pos"(rx2518_pos)
    $P10 = rx2518_cur."arglist"()
    unless $P10, rx2518_fail
    rx2518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2518_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2518_pos, 1
    gt $I11, rx2518_eos, rx2518_fail
    sub $I11, rx2518_pos, rx2518_off
    ord $I11, rx2518_tgt, $I11
    ne $I11, 41, rx2518_fail
    add rx2518_pos, 1
.annotate 'line', 1077
  # rx subrule "O" subtype=capture negate=
    rx2518_cur."!cursor_pos"(rx2518_pos)
    $P10 = rx2518_cur."O"("%methodop")
    unless $P10, rx2518_fail
    rx2518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2518_pos = $P10."pos"()
.annotate 'line', 1075
  # rx pass
    rx2518_cur."!cursor_pass"(rx2518_pos, "postcircumfix:sym<( )>")
    if_null rx2518_debug, debug_1464
    rx2518_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2518_pos)
  debug_1464:
    .return (rx2518_cur)
  rx2518_restart:
.annotate 'line', 436
    if_null rx2518_debug, debug_1465
    rx2518_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1465:
  rx2518_fail:
    (rx2518_rep, rx2518_pos, $I10, $P10) = rx2518_cur."!mark_fail"(0)
    lt rx2518_pos, -1, rx2518_done
    eq rx2518_pos, -1, rx2518_fail
    jump $I10
  rx2518_done:
    rx2518_cur."!cursor_fail"()
    if_null rx2518_debug, debug_1466
    rx2518_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1466:
    .return (rx2518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("316_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2521 = self."!PREFIX__!subrule"("ws", "(")
    new $P2522, "ResizablePMCArray"
    push $P2522, $P2521
    .return ($P2522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("317_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2524_tgt
    .local int rx2524_pos
    .local int rx2524_off
    .local int rx2524_eos
    .local int rx2524_rep
    .local pmc rx2524_cur
    .local pmc rx2524_debug
    (rx2524_cur, rx2524_pos, rx2524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2524_cur
    .local pmc match
    .lex "$/", match
    length rx2524_eos, rx2524_tgt
    gt rx2524_pos, rx2524_eos, rx2524_done
    set rx2524_off, 0
    lt rx2524_pos, 2, rx2524_start
    sub rx2524_off, rx2524_pos, 1
    substr rx2524_tgt, rx2524_tgt, rx2524_off
  rx2524_start:
    eq $I10, 1, rx2524_restart
    if_null rx2524_debug, debug_1467
    rx2524_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1467:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2525_done
    goto rxscan2525_scan
  rxscan2525_loop:
    (rx2524_pos) = rx2524_cur."from"()
    inc rx2524_pos
    rx2524_cur."!cursor_from"(rx2524_pos)
    ge rx2524_pos, rx2524_eos, rxscan2525_done
  rxscan2525_scan:
    set_addr $I10, rxscan2525_loop
    rx2524_cur."!mark_push"(0, rx2524_pos, $I10)
  rxscan2525_done:
.annotate 'line', 1080
  # rx subrule "dotty" subtype=capture negate=
    rx2524_cur."!cursor_pos"(rx2524_pos)
    $P10 = rx2524_cur."dotty"()
    unless $P10, rx2524_fail
    rx2524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2524_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2524_cur."!cursor_pos"(rx2524_pos)
    $P10 = rx2524_cur."O"("%methodop")
    unless $P10, rx2524_fail
    rx2524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2524_pos = $P10."pos"()
  # rx pass
    rx2524_cur."!cursor_pass"(rx2524_pos, "postfix:sym<.>")
    if_null rx2524_debug, debug_1468
    rx2524_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2524_pos)
  debug_1468:
    .return (rx2524_cur)
  rx2524_restart:
.annotate 'line', 436
    if_null rx2524_debug, debug_1469
    rx2524_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1469:
  rx2524_fail:
    (rx2524_rep, rx2524_pos, $I10, $P10) = rx2524_cur."!mark_fail"(0)
    lt rx2524_pos, -1, rx2524_done
    eq rx2524_pos, -1, rx2524_fail
    jump $I10
  rx2524_done:
    rx2524_cur."!cursor_fail"()
    if_null rx2524_debug, debug_1470
    rx2524_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1470:
    .return (rx2524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("318_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2527 = self."!PREFIX__!subrule"("dotty", "")
    new $P2528, "ResizablePMCArray"
    push $P2528, $P2527
    .return ($P2528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("319_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2530_tgt
    .local int rx2530_pos
    .local int rx2530_off
    .local int rx2530_eos
    .local int rx2530_rep
    .local pmc rx2530_cur
    .local pmc rx2530_debug
    (rx2530_cur, rx2530_pos, rx2530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2530_cur
    .local pmc match
    .lex "$/", match
    length rx2530_eos, rx2530_tgt
    gt rx2530_pos, rx2530_eos, rx2530_done
    set rx2530_off, 0
    lt rx2530_pos, 2, rx2530_start
    sub rx2530_off, rx2530_pos, 1
    substr rx2530_tgt, rx2530_tgt, rx2530_off
  rx2530_start:
    eq $I10, 1, rx2530_restart
    if_null rx2530_debug, debug_1471
    rx2530_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1471:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2531_done
    goto rxscan2531_scan
  rxscan2531_loop:
    (rx2530_pos) = rx2530_cur."from"()
    inc rx2530_pos
    rx2530_cur."!cursor_from"(rx2530_pos)
    ge rx2530_pos, rx2530_eos, rxscan2531_done
  rxscan2531_scan:
    set_addr $I10, rxscan2531_loop
    rx2530_cur."!mark_push"(0, rx2530_pos, $I10)
  rxscan2531_done:
.annotate 'line', 1082
  # rx subcapture "sym"
    set_addr $I10, rxcap_2532_fail
    rx2530_cur."!mark_push"(0, rx2530_pos, $I10)
  # rx literal  "++"
    add $I11, rx2530_pos, 2
    gt $I11, rx2530_eos, rx2530_fail
    sub $I11, rx2530_pos, rx2530_off
    substr $S10, rx2530_tgt, $I11, 2
    ne $S10, "++", rx2530_fail
    add rx2530_pos, 2
    set_addr $I10, rxcap_2532_fail
    ($I12, $I11) = rx2530_cur."!mark_peek"($I10)
    rx2530_cur."!cursor_pos"($I11)
    ($P10) = rx2530_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2530_pos, "")
    rx2530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2532_done
  rxcap_2532_fail:
    goto rx2530_fail
  rxcap_2532_done:
  # rx subrule "O" subtype=capture negate=
    rx2530_cur."!cursor_pos"(rx2530_pos)
    $P10 = rx2530_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2530_fail
    rx2530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2530_pos = $P10."pos"()
  # rx pass
    rx2530_cur."!cursor_pass"(rx2530_pos, "prefix:sym<++>")
    if_null rx2530_debug, debug_1472
    rx2530_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2530_pos)
  debug_1472:
    .return (rx2530_cur)
  rx2530_restart:
.annotate 'line', 436
    if_null rx2530_debug, debug_1473
    rx2530_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1473:
  rx2530_fail:
    (rx2530_rep, rx2530_pos, $I10, $P10) = rx2530_cur."!mark_fail"(0)
    lt rx2530_pos, -1, rx2530_done
    eq rx2530_pos, -1, rx2530_fail
    jump $I10
  rx2530_done:
    rx2530_cur."!cursor_fail"()
    if_null rx2530_debug, debug_1474
    rx2530_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1474:
    .return (rx2530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("320_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2534 = self."!PREFIX__!subrule"("O", "++")
    new $P2535, "ResizablePMCArray"
    push $P2535, $P2534
    .return ($P2535)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("321_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2537_tgt
    .local int rx2537_pos
    .local int rx2537_off
    .local int rx2537_eos
    .local int rx2537_rep
    .local pmc rx2537_cur
    .local pmc rx2537_debug
    (rx2537_cur, rx2537_pos, rx2537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2537_cur
    .local pmc match
    .lex "$/", match
    length rx2537_eos, rx2537_tgt
    gt rx2537_pos, rx2537_eos, rx2537_done
    set rx2537_off, 0
    lt rx2537_pos, 2, rx2537_start
    sub rx2537_off, rx2537_pos, 1
    substr rx2537_tgt, rx2537_tgt, rx2537_off
  rx2537_start:
    eq $I10, 1, rx2537_restart
    if_null rx2537_debug, debug_1475
    rx2537_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1475:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2538_done
    goto rxscan2538_scan
  rxscan2538_loop:
    (rx2537_pos) = rx2537_cur."from"()
    inc rx2537_pos
    rx2537_cur."!cursor_from"(rx2537_pos)
    ge rx2537_pos, rx2537_eos, rxscan2538_done
  rxscan2538_scan:
    set_addr $I10, rxscan2538_loop
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
  rxscan2538_done:
.annotate 'line', 1083
  # rx subcapture "sym"
    set_addr $I10, rxcap_2539_fail
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
  # rx literal  "--"
    add $I11, rx2537_pos, 2
    gt $I11, rx2537_eos, rx2537_fail
    sub $I11, rx2537_pos, rx2537_off
    substr $S10, rx2537_tgt, $I11, 2
    ne $S10, "--", rx2537_fail
    add rx2537_pos, 2
    set_addr $I10, rxcap_2539_fail
    ($I12, $I11) = rx2537_cur."!mark_peek"($I10)
    rx2537_cur."!cursor_pos"($I11)
    ($P10) = rx2537_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2537_pos, "")
    rx2537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2539_done
  rxcap_2539_fail:
    goto rx2537_fail
  rxcap_2539_done:
  # rx subrule "O" subtype=capture negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    $P10 = rx2537_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2537_fail
    rx2537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2537_pos = $P10."pos"()
  # rx pass
    rx2537_cur."!cursor_pass"(rx2537_pos, "prefix:sym<-->")
    if_null rx2537_debug, debug_1476
    rx2537_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2537_pos)
  debug_1476:
    .return (rx2537_cur)
  rx2537_restart:
.annotate 'line', 436
    if_null rx2537_debug, debug_1477
    rx2537_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1477:
  rx2537_fail:
    (rx2537_rep, rx2537_pos, $I10, $P10) = rx2537_cur."!mark_fail"(0)
    lt rx2537_pos, -1, rx2537_done
    eq rx2537_pos, -1, rx2537_fail
    jump $I10
  rx2537_done:
    rx2537_cur."!cursor_fail"()
    if_null rx2537_debug, debug_1478
    rx2537_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1478:
    .return (rx2537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("322_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2541 = self."!PREFIX__!subrule"("O", "--")
    new $P2542, "ResizablePMCArray"
    push $P2542, $P2541
    .return ($P2542)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("323_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2544_tgt
    .local int rx2544_pos
    .local int rx2544_off
    .local int rx2544_eos
    .local int rx2544_rep
    .local pmc rx2544_cur
    .local pmc rx2544_debug
    (rx2544_cur, rx2544_pos, rx2544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2544_cur
    .local pmc match
    .lex "$/", match
    length rx2544_eos, rx2544_tgt
    gt rx2544_pos, rx2544_eos, rx2544_done
    set rx2544_off, 0
    lt rx2544_pos, 2, rx2544_start
    sub rx2544_off, rx2544_pos, 1
    substr rx2544_tgt, rx2544_tgt, rx2544_off
  rx2544_start:
    eq $I10, 1, rx2544_restart
    if_null rx2544_debug, debug_1479
    rx2544_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2545_done
    goto rxscan2545_scan
  rxscan2545_loop:
    (rx2544_pos) = rx2544_cur."from"()
    inc rx2544_pos
    rx2544_cur."!cursor_from"(rx2544_pos)
    ge rx2544_pos, rx2544_eos, rxscan2545_done
  rxscan2545_scan:
    set_addr $I10, rxscan2545_loop
    rx2544_cur."!mark_push"(0, rx2544_pos, $I10)
  rxscan2545_done:
.annotate 'line', 1086
  # rx subcapture "sym"
    set_addr $I10, rxcap_2546_fail
    rx2544_cur."!mark_push"(0, rx2544_pos, $I10)
  # rx literal  "++"
    add $I11, rx2544_pos, 2
    gt $I11, rx2544_eos, rx2544_fail
    sub $I11, rx2544_pos, rx2544_off
    substr $S10, rx2544_tgt, $I11, 2
    ne $S10, "++", rx2544_fail
    add rx2544_pos, 2
    set_addr $I10, rxcap_2546_fail
    ($I12, $I11) = rx2544_cur."!mark_peek"($I10)
    rx2544_cur."!cursor_pos"($I11)
    ($P10) = rx2544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2544_pos, "")
    rx2544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2546_done
  rxcap_2546_fail:
    goto rx2544_fail
  rxcap_2546_done:
  # rx subrule "O" subtype=capture negate=
    rx2544_cur."!cursor_pos"(rx2544_pos)
    $P10 = rx2544_cur."O"("%autoincrement")
    unless $P10, rx2544_fail
    rx2544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2544_pos = $P10."pos"()
  # rx pass
    rx2544_cur."!cursor_pass"(rx2544_pos, "postfix:sym<++>")
    if_null rx2544_debug, debug_1480
    rx2544_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2544_pos)
  debug_1480:
    .return (rx2544_cur)
  rx2544_restart:
.annotate 'line', 436
    if_null rx2544_debug, debug_1481
    rx2544_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1481:
  rx2544_fail:
    (rx2544_rep, rx2544_pos, $I10, $P10) = rx2544_cur."!mark_fail"(0)
    lt rx2544_pos, -1, rx2544_done
    eq rx2544_pos, -1, rx2544_fail
    jump $I10
  rx2544_done:
    rx2544_cur."!cursor_fail"()
    if_null rx2544_debug, debug_1482
    rx2544_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1482:
    .return (rx2544_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("324_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2548 = self."!PREFIX__!subrule"("O", "++")
    new $P2549, "ResizablePMCArray"
    push $P2549, $P2548
    .return ($P2549)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("325_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2551_tgt
    .local int rx2551_pos
    .local int rx2551_off
    .local int rx2551_eos
    .local int rx2551_rep
    .local pmc rx2551_cur
    .local pmc rx2551_debug
    (rx2551_cur, rx2551_pos, rx2551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2551_cur
    .local pmc match
    .lex "$/", match
    length rx2551_eos, rx2551_tgt
    gt rx2551_pos, rx2551_eos, rx2551_done
    set rx2551_off, 0
    lt rx2551_pos, 2, rx2551_start
    sub rx2551_off, rx2551_pos, 1
    substr rx2551_tgt, rx2551_tgt, rx2551_off
  rx2551_start:
    eq $I10, 1, rx2551_restart
    if_null rx2551_debug, debug_1483
    rx2551_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1483:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2552_done
    goto rxscan2552_scan
  rxscan2552_loop:
    (rx2551_pos) = rx2551_cur."from"()
    inc rx2551_pos
    rx2551_cur."!cursor_from"(rx2551_pos)
    ge rx2551_pos, rx2551_eos, rxscan2552_done
  rxscan2552_scan:
    set_addr $I10, rxscan2552_loop
    rx2551_cur."!mark_push"(0, rx2551_pos, $I10)
  rxscan2552_done:
.annotate 'line', 1087
  # rx subcapture "sym"
    set_addr $I10, rxcap_2553_fail
    rx2551_cur."!mark_push"(0, rx2551_pos, $I10)
  # rx literal  "--"
    add $I11, rx2551_pos, 2
    gt $I11, rx2551_eos, rx2551_fail
    sub $I11, rx2551_pos, rx2551_off
    substr $S10, rx2551_tgt, $I11, 2
    ne $S10, "--", rx2551_fail
    add rx2551_pos, 2
    set_addr $I10, rxcap_2553_fail
    ($I12, $I11) = rx2551_cur."!mark_peek"($I10)
    rx2551_cur."!cursor_pos"($I11)
    ($P10) = rx2551_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2551_pos, "")
    rx2551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2553_done
  rxcap_2553_fail:
    goto rx2551_fail
  rxcap_2553_done:
  # rx subrule "O" subtype=capture negate=
    rx2551_cur."!cursor_pos"(rx2551_pos)
    $P10 = rx2551_cur."O"("%autoincrement")
    unless $P10, rx2551_fail
    rx2551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2551_pos = $P10."pos"()
  # rx pass
    rx2551_cur."!cursor_pass"(rx2551_pos, "postfix:sym<-->")
    if_null rx2551_debug, debug_1484
    rx2551_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2551_pos)
  debug_1484:
    .return (rx2551_cur)
  rx2551_restart:
.annotate 'line', 436
    if_null rx2551_debug, debug_1485
    rx2551_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1485:
  rx2551_fail:
    (rx2551_rep, rx2551_pos, $I10, $P10) = rx2551_cur."!mark_fail"(0)
    lt rx2551_pos, -1, rx2551_done
    eq rx2551_pos, -1, rx2551_fail
    jump $I10
  rx2551_done:
    rx2551_cur."!cursor_fail"()
    if_null rx2551_debug, debug_1486
    rx2551_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1486:
    .return (rx2551_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("326_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2555 = self."!PREFIX__!subrule"("O", "--")
    new $P2556, "ResizablePMCArray"
    push $P2556, $P2555
    .return ($P2556)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("327_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2558_tgt
    .local int rx2558_pos
    .local int rx2558_off
    .local int rx2558_eos
    .local int rx2558_rep
    .local pmc rx2558_cur
    .local pmc rx2558_debug
    (rx2558_cur, rx2558_pos, rx2558_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2558_cur
    .local pmc match
    .lex "$/", match
    length rx2558_eos, rx2558_tgt
    gt rx2558_pos, rx2558_eos, rx2558_done
    set rx2558_off, 0
    lt rx2558_pos, 2, rx2558_start
    sub rx2558_off, rx2558_pos, 1
    substr rx2558_tgt, rx2558_tgt, rx2558_off
  rx2558_start:
    eq $I10, 1, rx2558_restart
    if_null rx2558_debug, debug_1487
    rx2558_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1487:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2559_done
    goto rxscan2559_scan
  rxscan2559_loop:
    (rx2558_pos) = rx2558_cur."from"()
    inc rx2558_pos
    rx2558_cur."!cursor_from"(rx2558_pos)
    ge rx2558_pos, rx2558_eos, rxscan2559_done
  rxscan2559_scan:
    set_addr $I10, rxscan2559_loop
    rx2558_cur."!mark_push"(0, rx2558_pos, $I10)
  rxscan2559_done:
.annotate 'line', 1089
  # rx subcapture "sym"
    set_addr $I10, rxcap_2560_fail
    rx2558_cur."!mark_push"(0, rx2558_pos, $I10)
  # rx literal  "**"
    add $I11, rx2558_pos, 2
    gt $I11, rx2558_eos, rx2558_fail
    sub $I11, rx2558_pos, rx2558_off
    substr $S10, rx2558_tgt, $I11, 2
    ne $S10, "**", rx2558_fail
    add rx2558_pos, 2
    set_addr $I10, rxcap_2560_fail
    ($I12, $I11) = rx2558_cur."!mark_peek"($I10)
    rx2558_cur."!cursor_pos"($I11)
    ($P10) = rx2558_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2558_pos, "")
    rx2558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2560_done
  rxcap_2560_fail:
    goto rx2558_fail
  rxcap_2560_done:
  # rx subrule "O" subtype=capture negate=
    rx2558_cur."!cursor_pos"(rx2558_pos)
    $P10 = rx2558_cur."O"("%exponentiation, :pirop<pow__NNN>")
    unless $P10, rx2558_fail
    rx2558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2558_pos = $P10."pos"()
  # rx pass
    rx2558_cur."!cursor_pass"(rx2558_pos, "infix:sym<**>")
    if_null rx2558_debug, debug_1488
    rx2558_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2558_pos)
  debug_1488:
    .return (rx2558_cur)
  rx2558_restart:
.annotate 'line', 436
    if_null rx2558_debug, debug_1489
    rx2558_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1489:
  rx2558_fail:
    (rx2558_rep, rx2558_pos, $I10, $P10) = rx2558_cur."!mark_fail"(0)
    lt rx2558_pos, -1, rx2558_done
    eq rx2558_pos, -1, rx2558_fail
    jump $I10
  rx2558_done:
    rx2558_cur."!cursor_fail"()
    if_null rx2558_debug, debug_1490
    rx2558_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1490:
    .return (rx2558_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("328_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2562 = self."!PREFIX__!subrule"("O", "**")
    new $P2563, "ResizablePMCArray"
    push $P2563, $P2562
    .return ($P2563)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("329_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2565_tgt
    .local int rx2565_pos
    .local int rx2565_off
    .local int rx2565_eos
    .local int rx2565_rep
    .local pmc rx2565_cur
    .local pmc rx2565_debug
    (rx2565_cur, rx2565_pos, rx2565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2565_cur
    .local pmc match
    .lex "$/", match
    length rx2565_eos, rx2565_tgt
    gt rx2565_pos, rx2565_eos, rx2565_done
    set rx2565_off, 0
    lt rx2565_pos, 2, rx2565_start
    sub rx2565_off, rx2565_pos, 1
    substr rx2565_tgt, rx2565_tgt, rx2565_off
  rx2565_start:
    eq $I10, 1, rx2565_restart
    if_null rx2565_debug, debug_1491
    rx2565_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1491:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2566_done
    goto rxscan2566_scan
  rxscan2566_loop:
    (rx2565_pos) = rx2565_cur."from"()
    inc rx2565_pos
    rx2565_cur."!cursor_from"(rx2565_pos)
    ge rx2565_pos, rx2565_eos, rxscan2566_done
  rxscan2566_scan:
    set_addr $I10, rxscan2566_loop
    rx2565_cur."!mark_push"(0, rx2565_pos, $I10)
  rxscan2566_done:
.annotate 'line', 1091
  # rx subcapture "sym"
    set_addr $I10, rxcap_2567_fail
    rx2565_cur."!mark_push"(0, rx2565_pos, $I10)
  # rx literal  "+"
    add $I11, rx2565_pos, 1
    gt $I11, rx2565_eos, rx2565_fail
    sub $I11, rx2565_pos, rx2565_off
    ord $I11, rx2565_tgt, $I11
    ne $I11, 43, rx2565_fail
    add rx2565_pos, 1
    set_addr $I10, rxcap_2567_fail
    ($I12, $I11) = rx2565_cur."!mark_peek"($I10)
    rx2565_cur."!cursor_pos"($I11)
    ($P10) = rx2565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2565_pos, "")
    rx2565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2567_done
  rxcap_2567_fail:
    goto rx2565_fail
  rxcap_2567_done:
  # rx subrule "O" subtype=capture negate=
    rx2565_cur."!cursor_pos"(rx2565_pos)
    $P10 = rx2565_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2565_fail
    rx2565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2565_pos = $P10."pos"()
  # rx pass
    rx2565_cur."!cursor_pass"(rx2565_pos, "prefix:sym<+>")
    if_null rx2565_debug, debug_1492
    rx2565_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2565_pos)
  debug_1492:
    .return (rx2565_cur)
  rx2565_restart:
.annotate 'line', 436
    if_null rx2565_debug, debug_1493
    rx2565_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1493:
  rx2565_fail:
    (rx2565_rep, rx2565_pos, $I10, $P10) = rx2565_cur."!mark_fail"(0)
    lt rx2565_pos, -1, rx2565_done
    eq rx2565_pos, -1, rx2565_fail
    jump $I10
  rx2565_done:
    rx2565_cur."!cursor_fail"()
    if_null rx2565_debug, debug_1494
    rx2565_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1494:
    .return (rx2565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("330_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2569 = self."!PREFIX__!subrule"("O", "+")
    new $P2570, "ResizablePMCArray"
    push $P2570, $P2569
    .return ($P2570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("331_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2572_tgt
    .local int rx2572_pos
    .local int rx2572_off
    .local int rx2572_eos
    .local int rx2572_rep
    .local pmc rx2572_cur
    .local pmc rx2572_debug
    (rx2572_cur, rx2572_pos, rx2572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2572_cur
    .local pmc match
    .lex "$/", match
    length rx2572_eos, rx2572_tgt
    gt rx2572_pos, rx2572_eos, rx2572_done
    set rx2572_off, 0
    lt rx2572_pos, 2, rx2572_start
    sub rx2572_off, rx2572_pos, 1
    substr rx2572_tgt, rx2572_tgt, rx2572_off
  rx2572_start:
    eq $I10, 1, rx2572_restart
    if_null rx2572_debug, debug_1495
    rx2572_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1495:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2573_done
    goto rxscan2573_scan
  rxscan2573_loop:
    (rx2572_pos) = rx2572_cur."from"()
    inc rx2572_pos
    rx2572_cur."!cursor_from"(rx2572_pos)
    ge rx2572_pos, rx2572_eos, rxscan2573_done
  rxscan2573_scan:
    set_addr $I10, rxscan2573_loop
    rx2572_cur."!mark_push"(0, rx2572_pos, $I10)
  rxscan2573_done:
.annotate 'line', 1092
  # rx subcapture "sym"
    set_addr $I10, rxcap_2574_fail
    rx2572_cur."!mark_push"(0, rx2572_pos, $I10)
  # rx literal  "~"
    add $I11, rx2572_pos, 1
    gt $I11, rx2572_eos, rx2572_fail
    sub $I11, rx2572_pos, rx2572_off
    ord $I11, rx2572_tgt, $I11
    ne $I11, 126, rx2572_fail
    add rx2572_pos, 1
    set_addr $I10, rxcap_2574_fail
    ($I12, $I11) = rx2572_cur."!mark_peek"($I10)
    rx2572_cur."!cursor_pos"($I11)
    ($P10) = rx2572_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2572_pos, "")
    rx2572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2574_done
  rxcap_2574_fail:
    goto rx2572_fail
  rxcap_2574_done:
  # rx subrule "O" subtype=capture negate=
    rx2572_cur."!cursor_pos"(rx2572_pos)
    $P10 = rx2572_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2572_fail
    rx2572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2572_pos = $P10."pos"()
  # rx pass
    rx2572_cur."!cursor_pass"(rx2572_pos, "prefix:sym<~>")
    if_null rx2572_debug, debug_1496
    rx2572_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2572_pos)
  debug_1496:
    .return (rx2572_cur)
  rx2572_restart:
.annotate 'line', 436
    if_null rx2572_debug, debug_1497
    rx2572_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1497:
  rx2572_fail:
    (rx2572_rep, rx2572_pos, $I10, $P10) = rx2572_cur."!mark_fail"(0)
    lt rx2572_pos, -1, rx2572_done
    eq rx2572_pos, -1, rx2572_fail
    jump $I10
  rx2572_done:
    rx2572_cur."!cursor_fail"()
    if_null rx2572_debug, debug_1498
    rx2572_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1498:
    .return (rx2572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("332_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2576 = self."!PREFIX__!subrule"("O", "~")
    new $P2577, "ResizablePMCArray"
    push $P2577, $P2576
    .return ($P2577)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("333_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2579_tgt
    .local int rx2579_pos
    .local int rx2579_off
    .local int rx2579_eos
    .local int rx2579_rep
    .local pmc rx2579_cur
    .local pmc rx2579_debug
    (rx2579_cur, rx2579_pos, rx2579_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2579_cur
    .local pmc match
    .lex "$/", match
    length rx2579_eos, rx2579_tgt
    gt rx2579_pos, rx2579_eos, rx2579_done
    set rx2579_off, 0
    lt rx2579_pos, 2, rx2579_start
    sub rx2579_off, rx2579_pos, 1
    substr rx2579_tgt, rx2579_tgt, rx2579_off
  rx2579_start:
    eq $I10, 1, rx2579_restart
    if_null rx2579_debug, debug_1499
    rx2579_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1499:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2580_done
    goto rxscan2580_scan
  rxscan2580_loop:
    (rx2579_pos) = rx2579_cur."from"()
    inc rx2579_pos
    rx2579_cur."!cursor_from"(rx2579_pos)
    ge rx2579_pos, rx2579_eos, rxscan2580_done
  rxscan2580_scan:
    set_addr $I10, rxscan2580_loop
    rx2579_cur."!mark_push"(0, rx2579_pos, $I10)
  rxscan2580_done:
.annotate 'line', 1093
  # rx subcapture "sym"
    set_addr $I10, rxcap_2581_fail
    rx2579_cur."!mark_push"(0, rx2579_pos, $I10)
  # rx literal  "-"
    add $I11, rx2579_pos, 1
    gt $I11, rx2579_eos, rx2579_fail
    sub $I11, rx2579_pos, rx2579_off
    ord $I11, rx2579_tgt, $I11
    ne $I11, 45, rx2579_fail
    add rx2579_pos, 1
    set_addr $I10, rxcap_2581_fail
    ($I12, $I11) = rx2579_cur."!mark_peek"($I10)
    rx2579_cur."!cursor_pos"($I11)
    ($P10) = rx2579_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2579_pos, "")
    rx2579_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2581_done
  rxcap_2581_fail:
    goto rx2579_fail
  rxcap_2581_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2579_pos, rx2579_off
    substr $S10, rx2579_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2579_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2579_cur."!cursor_pos"(rx2579_pos)
    $P10 = rx2579_cur."number"()
    if $P10, rx2579_fail
  # rx subrule "O" subtype=capture negate=
    rx2579_cur."!cursor_pos"(rx2579_pos)
    $P10 = rx2579_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2579_fail
    rx2579_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2579_pos = $P10."pos"()
  # rx pass
    rx2579_cur."!cursor_pass"(rx2579_pos, "prefix:sym<->")
    if_null rx2579_debug, debug_1500
    rx2579_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2579_pos)
  debug_1500:
    .return (rx2579_cur)
  rx2579_restart:
.annotate 'line', 436
    if_null rx2579_debug, debug_1501
    rx2579_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1501:
  rx2579_fail:
    (rx2579_rep, rx2579_pos, $I10, $P10) = rx2579_cur."!mark_fail"(0)
    lt rx2579_pos, -1, rx2579_done
    eq rx2579_pos, -1, rx2579_fail
    jump $I10
  rx2579_done:
    rx2579_cur."!cursor_fail"()
    if_null rx2579_debug, debug_1502
    rx2579_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1502:
    .return (rx2579_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("334_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2583, "ResizablePMCArray"
    push $P2583, "-"
    .return ($P2583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("335_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2585_tgt
    .local int rx2585_pos
    .local int rx2585_off
    .local int rx2585_eos
    .local int rx2585_rep
    .local pmc rx2585_cur
    .local pmc rx2585_debug
    (rx2585_cur, rx2585_pos, rx2585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2585_cur
    .local pmc match
    .lex "$/", match
    length rx2585_eos, rx2585_tgt
    gt rx2585_pos, rx2585_eos, rx2585_done
    set rx2585_off, 0
    lt rx2585_pos, 2, rx2585_start
    sub rx2585_off, rx2585_pos, 1
    substr rx2585_tgt, rx2585_tgt, rx2585_off
  rx2585_start:
    eq $I10, 1, rx2585_restart
    if_null rx2585_debug, debug_1503
    rx2585_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1503:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2586_done
    goto rxscan2586_scan
  rxscan2586_loop:
    (rx2585_pos) = rx2585_cur."from"()
    inc rx2585_pos
    rx2585_cur."!cursor_from"(rx2585_pos)
    ge rx2585_pos, rx2585_eos, rxscan2586_done
  rxscan2586_scan:
    set_addr $I10, rxscan2586_loop
    rx2585_cur."!mark_push"(0, rx2585_pos, $I10)
  rxscan2586_done:
.annotate 'line', 1094
  # rx subcapture "sym"
    set_addr $I10, rxcap_2587_fail
    rx2585_cur."!mark_push"(0, rx2585_pos, $I10)
  # rx literal  "?"
    add $I11, rx2585_pos, 1
    gt $I11, rx2585_eos, rx2585_fail
    sub $I11, rx2585_pos, rx2585_off
    ord $I11, rx2585_tgt, $I11
    ne $I11, 63, rx2585_fail
    add rx2585_pos, 1
    set_addr $I10, rxcap_2587_fail
    ($I12, $I11) = rx2585_cur."!mark_peek"($I10)
    rx2585_cur."!cursor_pos"($I11)
    ($P10) = rx2585_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2585_pos, "")
    rx2585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2587_done
  rxcap_2587_fail:
    goto rx2585_fail
  rxcap_2587_done:
  # rx subrule "O" subtype=capture negate=
    rx2585_cur."!cursor_pos"(rx2585_pos)
    $P10 = rx2585_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2585_fail
    rx2585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2585_pos = $P10."pos"()
  # rx pass
    rx2585_cur."!cursor_pass"(rx2585_pos, "prefix:sym<?>")
    if_null rx2585_debug, debug_1504
    rx2585_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2585_pos)
  debug_1504:
    .return (rx2585_cur)
  rx2585_restart:
.annotate 'line', 436
    if_null rx2585_debug, debug_1505
    rx2585_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1505:
  rx2585_fail:
    (rx2585_rep, rx2585_pos, $I10, $P10) = rx2585_cur."!mark_fail"(0)
    lt rx2585_pos, -1, rx2585_done
    eq rx2585_pos, -1, rx2585_fail
    jump $I10
  rx2585_done:
    rx2585_cur."!cursor_fail"()
    if_null rx2585_debug, debug_1506
    rx2585_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1506:
    .return (rx2585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("336_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2589 = self."!PREFIX__!subrule"("O", "?")
    new $P2590, "ResizablePMCArray"
    push $P2590, $P2589
    .return ($P2590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("337_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2592_tgt
    .local int rx2592_pos
    .local int rx2592_off
    .local int rx2592_eos
    .local int rx2592_rep
    .local pmc rx2592_cur
    .local pmc rx2592_debug
    (rx2592_cur, rx2592_pos, rx2592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2592_cur
    .local pmc match
    .lex "$/", match
    length rx2592_eos, rx2592_tgt
    gt rx2592_pos, rx2592_eos, rx2592_done
    set rx2592_off, 0
    lt rx2592_pos, 2, rx2592_start
    sub rx2592_off, rx2592_pos, 1
    substr rx2592_tgt, rx2592_tgt, rx2592_off
  rx2592_start:
    eq $I10, 1, rx2592_restart
    if_null rx2592_debug, debug_1507
    rx2592_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1507:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2593_done
    goto rxscan2593_scan
  rxscan2593_loop:
    (rx2592_pos) = rx2592_cur."from"()
    inc rx2592_pos
    rx2592_cur."!cursor_from"(rx2592_pos)
    ge rx2592_pos, rx2592_eos, rxscan2593_done
  rxscan2593_scan:
    set_addr $I10, rxscan2593_loop
    rx2592_cur."!mark_push"(0, rx2592_pos, $I10)
  rxscan2593_done:
.annotate 'line', 1095
  # rx subcapture "sym"
    set_addr $I10, rxcap_2594_fail
    rx2592_cur."!mark_push"(0, rx2592_pos, $I10)
  # rx literal  "!"
    add $I11, rx2592_pos, 1
    gt $I11, rx2592_eos, rx2592_fail
    sub $I11, rx2592_pos, rx2592_off
    ord $I11, rx2592_tgt, $I11
    ne $I11, 33, rx2592_fail
    add rx2592_pos, 1
    set_addr $I10, rxcap_2594_fail
    ($I12, $I11) = rx2592_cur."!mark_peek"($I10)
    rx2592_cur."!cursor_pos"($I11)
    ($P10) = rx2592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2592_pos, "")
    rx2592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2594_done
  rxcap_2594_fail:
    goto rx2592_fail
  rxcap_2594_done:
  # rx subrule "O" subtype=capture negate=
    rx2592_cur."!cursor_pos"(rx2592_pos)
    $P10 = rx2592_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2592_fail
    rx2592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2592_pos = $P10."pos"()
  # rx pass
    rx2592_cur."!cursor_pass"(rx2592_pos, "prefix:sym<!>")
    if_null rx2592_debug, debug_1508
    rx2592_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2592_pos)
  debug_1508:
    .return (rx2592_cur)
  rx2592_restart:
.annotate 'line', 436
    if_null rx2592_debug, debug_1509
    rx2592_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1509:
  rx2592_fail:
    (rx2592_rep, rx2592_pos, $I10, $P10) = rx2592_cur."!mark_fail"(0)
    lt rx2592_pos, -1, rx2592_done
    eq rx2592_pos, -1, rx2592_fail
    jump $I10
  rx2592_done:
    rx2592_cur."!cursor_fail"()
    if_null rx2592_debug, debug_1510
    rx2592_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1510:
    .return (rx2592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("338_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2596 = self."!PREFIX__!subrule"("O", "!")
    new $P2597, "ResizablePMCArray"
    push $P2597, $P2596
    .return ($P2597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("339_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2599_tgt
    .local int rx2599_pos
    .local int rx2599_off
    .local int rx2599_eos
    .local int rx2599_rep
    .local pmc rx2599_cur
    .local pmc rx2599_debug
    (rx2599_cur, rx2599_pos, rx2599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2599_cur
    .local pmc match
    .lex "$/", match
    length rx2599_eos, rx2599_tgt
    gt rx2599_pos, rx2599_eos, rx2599_done
    set rx2599_off, 0
    lt rx2599_pos, 2, rx2599_start
    sub rx2599_off, rx2599_pos, 1
    substr rx2599_tgt, rx2599_tgt, rx2599_off
  rx2599_start:
    eq $I10, 1, rx2599_restart
    if_null rx2599_debug, debug_1511
    rx2599_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1511:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2600_done
    goto rxscan2600_scan
  rxscan2600_loop:
    (rx2599_pos) = rx2599_cur."from"()
    inc rx2599_pos
    rx2599_cur."!cursor_from"(rx2599_pos)
    ge rx2599_pos, rx2599_eos, rxscan2600_done
  rxscan2600_scan:
    set_addr $I10, rxscan2600_loop
    rx2599_cur."!mark_push"(0, rx2599_pos, $I10)
  rxscan2600_done:
.annotate 'line', 1096
  # rx subcapture "sym"
    set_addr $I10, rxcap_2601_fail
    rx2599_cur."!mark_push"(0, rx2599_pos, $I10)
  # rx literal  "|"
    add $I11, rx2599_pos, 1
    gt $I11, rx2599_eos, rx2599_fail
    sub $I11, rx2599_pos, rx2599_off
    ord $I11, rx2599_tgt, $I11
    ne $I11, 124, rx2599_fail
    add rx2599_pos, 1
    set_addr $I10, rxcap_2601_fail
    ($I12, $I11) = rx2599_cur."!mark_peek"($I10)
    rx2599_cur."!cursor_pos"($I11)
    ($P10) = rx2599_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2599_pos, "")
    rx2599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2601_done
  rxcap_2601_fail:
    goto rx2599_fail
  rxcap_2601_done:
  # rx subrule "O" subtype=capture negate=
    rx2599_cur."!cursor_pos"(rx2599_pos)
    $P10 = rx2599_cur."O"("%symbolic_unary")
    unless $P10, rx2599_fail
    rx2599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2599_pos = $P10."pos"()
  # rx pass
    rx2599_cur."!cursor_pass"(rx2599_pos, "prefix:sym<|>")
    if_null rx2599_debug, debug_1512
    rx2599_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2599_pos)
  debug_1512:
    .return (rx2599_cur)
  rx2599_restart:
.annotate 'line', 436
    if_null rx2599_debug, debug_1513
    rx2599_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1513:
  rx2599_fail:
    (rx2599_rep, rx2599_pos, $I10, $P10) = rx2599_cur."!mark_fail"(0)
    lt rx2599_pos, -1, rx2599_done
    eq rx2599_pos, -1, rx2599_fail
    jump $I10
  rx2599_done:
    rx2599_cur."!cursor_fail"()
    if_null rx2599_debug, debug_1514
    rx2599_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1514:
    .return (rx2599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("340_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2603 = self."!PREFIX__!subrule"("O", "|")
    new $P2604, "ResizablePMCArray"
    push $P2604, $P2603
    .return ($P2604)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("341_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2606_tgt
    .local int rx2606_pos
    .local int rx2606_off
    .local int rx2606_eos
    .local int rx2606_rep
    .local pmc rx2606_cur
    .local pmc rx2606_debug
    (rx2606_cur, rx2606_pos, rx2606_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2606_cur
    .local pmc match
    .lex "$/", match
    length rx2606_eos, rx2606_tgt
    gt rx2606_pos, rx2606_eos, rx2606_done
    set rx2606_off, 0
    lt rx2606_pos, 2, rx2606_start
    sub rx2606_off, rx2606_pos, 1
    substr rx2606_tgt, rx2606_tgt, rx2606_off
  rx2606_start:
    eq $I10, 1, rx2606_restart
    if_null rx2606_debug, debug_1515
    rx2606_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1515:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2607_done
    goto rxscan2607_scan
  rxscan2607_loop:
    (rx2606_pos) = rx2606_cur."from"()
    inc rx2606_pos
    rx2606_cur."!cursor_from"(rx2606_pos)
    ge rx2606_pos, rx2606_eos, rxscan2607_done
  rxscan2607_scan:
    set_addr $I10, rxscan2607_loop
    rx2606_cur."!mark_push"(0, rx2606_pos, $I10)
  rxscan2607_done:
.annotate 'line', 1098
  # rx subcapture "sym"
    set_addr $I10, rxcap_2608_fail
    rx2606_cur."!mark_push"(0, rx2606_pos, $I10)
  # rx literal  "*"
    add $I11, rx2606_pos, 1
    gt $I11, rx2606_eos, rx2606_fail
    sub $I11, rx2606_pos, rx2606_off
    ord $I11, rx2606_tgt, $I11
    ne $I11, 42, rx2606_fail
    add rx2606_pos, 1
    set_addr $I10, rxcap_2608_fail
    ($I12, $I11) = rx2606_cur."!mark_peek"($I10)
    rx2606_cur."!cursor_pos"($I11)
    ($P10) = rx2606_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2606_pos, "")
    rx2606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2608_done
  rxcap_2608_fail:
    goto rx2606_fail
  rxcap_2608_done:
  # rx subrule "O" subtype=capture negate=
    rx2606_cur."!cursor_pos"(rx2606_pos)
    $P10 = rx2606_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2606_fail
    rx2606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2606_pos = $P10."pos"()
  # rx pass
    rx2606_cur."!cursor_pass"(rx2606_pos, "infix:sym<*>")
    if_null rx2606_debug, debug_1516
    rx2606_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2606_pos)
  debug_1516:
    .return (rx2606_cur)
  rx2606_restart:
.annotate 'line', 436
    if_null rx2606_debug, debug_1517
    rx2606_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1517:
  rx2606_fail:
    (rx2606_rep, rx2606_pos, $I10, $P10) = rx2606_cur."!mark_fail"(0)
    lt rx2606_pos, -1, rx2606_done
    eq rx2606_pos, -1, rx2606_fail
    jump $I10
  rx2606_done:
    rx2606_cur."!cursor_fail"()
    if_null rx2606_debug, debug_1518
    rx2606_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1518:
    .return (rx2606_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("342_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2610 = self."!PREFIX__!subrule"("O", "*")
    new $P2611, "ResizablePMCArray"
    push $P2611, $P2610
    .return ($P2611)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("343_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2613_tgt
    .local int rx2613_pos
    .local int rx2613_off
    .local int rx2613_eos
    .local int rx2613_rep
    .local pmc rx2613_cur
    .local pmc rx2613_debug
    (rx2613_cur, rx2613_pos, rx2613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2613_cur
    .local pmc match
    .lex "$/", match
    length rx2613_eos, rx2613_tgt
    gt rx2613_pos, rx2613_eos, rx2613_done
    set rx2613_off, 0
    lt rx2613_pos, 2, rx2613_start
    sub rx2613_off, rx2613_pos, 1
    substr rx2613_tgt, rx2613_tgt, rx2613_off
  rx2613_start:
    eq $I10, 1, rx2613_restart
    if_null rx2613_debug, debug_1519
    rx2613_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1519:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2614_done
    goto rxscan2614_scan
  rxscan2614_loop:
    (rx2613_pos) = rx2613_cur."from"()
    inc rx2613_pos
    rx2613_cur."!cursor_from"(rx2613_pos)
    ge rx2613_pos, rx2613_eos, rxscan2614_done
  rxscan2614_scan:
    set_addr $I10, rxscan2614_loop
    rx2613_cur."!mark_push"(0, rx2613_pos, $I10)
  rxscan2614_done:
.annotate 'line', 1099
  # rx subcapture "sym"
    set_addr $I10, rxcap_2615_fail
    rx2613_cur."!mark_push"(0, rx2613_pos, $I10)
  # rx literal  "/"
    add $I11, rx2613_pos, 1
    gt $I11, rx2613_eos, rx2613_fail
    sub $I11, rx2613_pos, rx2613_off
    ord $I11, rx2613_tgt, $I11
    ne $I11, 47, rx2613_fail
    add rx2613_pos, 1
    set_addr $I10, rxcap_2615_fail
    ($I12, $I11) = rx2613_cur."!mark_peek"($I10)
    rx2613_cur."!cursor_pos"($I11)
    ($P10) = rx2613_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2613_pos, "")
    rx2613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2615_done
  rxcap_2615_fail:
    goto rx2613_fail
  rxcap_2615_done:
  # rx subrule "O" subtype=capture negate=
    rx2613_cur."!cursor_pos"(rx2613_pos)
    $P10 = rx2613_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2613_fail
    rx2613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2613_pos = $P10."pos"()
  # rx pass
    rx2613_cur."!cursor_pass"(rx2613_pos, "infix:sym</>")
    if_null rx2613_debug, debug_1520
    rx2613_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2613_pos)
  debug_1520:
    .return (rx2613_cur)
  rx2613_restart:
.annotate 'line', 436
    if_null rx2613_debug, debug_1521
    rx2613_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1521:
  rx2613_fail:
    (rx2613_rep, rx2613_pos, $I10, $P10) = rx2613_cur."!mark_fail"(0)
    lt rx2613_pos, -1, rx2613_done
    eq rx2613_pos, -1, rx2613_fail
    jump $I10
  rx2613_done:
    rx2613_cur."!cursor_fail"()
    if_null rx2613_debug, debug_1522
    rx2613_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1522:
    .return (rx2613_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("344_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2617 = self."!PREFIX__!subrule"("O", "/")
    new $P2618, "ResizablePMCArray"
    push $P2618, $P2617
    .return ($P2618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("345_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2620_tgt
    .local int rx2620_pos
    .local int rx2620_off
    .local int rx2620_eos
    .local int rx2620_rep
    .local pmc rx2620_cur
    .local pmc rx2620_debug
    (rx2620_cur, rx2620_pos, rx2620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2620_cur
    .local pmc match
    .lex "$/", match
    length rx2620_eos, rx2620_tgt
    gt rx2620_pos, rx2620_eos, rx2620_done
    set rx2620_off, 0
    lt rx2620_pos, 2, rx2620_start
    sub rx2620_off, rx2620_pos, 1
    substr rx2620_tgt, rx2620_tgt, rx2620_off
  rx2620_start:
    eq $I10, 1, rx2620_restart
    if_null rx2620_debug, debug_1523
    rx2620_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1523:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2621_done
    goto rxscan2621_scan
  rxscan2621_loop:
    (rx2620_pos) = rx2620_cur."from"()
    inc rx2620_pos
    rx2620_cur."!cursor_from"(rx2620_pos)
    ge rx2620_pos, rx2620_eos, rxscan2621_done
  rxscan2621_scan:
    set_addr $I10, rxscan2621_loop
    rx2620_cur."!mark_push"(0, rx2620_pos, $I10)
  rxscan2621_done:
.annotate 'line', 1100
  # rx subcapture "sym"
    set_addr $I10, rxcap_2622_fail
    rx2620_cur."!mark_push"(0, rx2620_pos, $I10)
  # rx literal  "%"
    add $I11, rx2620_pos, 1
    gt $I11, rx2620_eos, rx2620_fail
    sub $I11, rx2620_pos, rx2620_off
    ord $I11, rx2620_tgt, $I11
    ne $I11, 37, rx2620_fail
    add rx2620_pos, 1
    set_addr $I10, rxcap_2622_fail
    ($I12, $I11) = rx2620_cur."!mark_peek"($I10)
    rx2620_cur."!cursor_pos"($I11)
    ($P10) = rx2620_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2620_pos, "")
    rx2620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2622_done
  rxcap_2622_fail:
    goto rx2620_fail
  rxcap_2622_done:
  # rx subrule "O" subtype=capture negate=
    rx2620_cur."!cursor_pos"(rx2620_pos)
    $P10 = rx2620_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2620_fail
    rx2620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2620_pos = $P10."pos"()
  # rx pass
    rx2620_cur."!cursor_pass"(rx2620_pos, "infix:sym<%>")
    if_null rx2620_debug, debug_1524
    rx2620_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2620_pos)
  debug_1524:
    .return (rx2620_cur)
  rx2620_restart:
.annotate 'line', 436
    if_null rx2620_debug, debug_1525
    rx2620_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1525:
  rx2620_fail:
    (rx2620_rep, rx2620_pos, $I10, $P10) = rx2620_cur."!mark_fail"(0)
    lt rx2620_pos, -1, rx2620_done
    eq rx2620_pos, -1, rx2620_fail
    jump $I10
  rx2620_done:
    rx2620_cur."!cursor_fail"()
    if_null rx2620_debug, debug_1526
    rx2620_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1526:
    .return (rx2620_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("346_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2624 = self."!PREFIX__!subrule"("O", "%")
    new $P2625, "ResizablePMCArray"
    push $P2625, $P2624
    .return ($P2625)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("347_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2627_tgt
    .local int rx2627_pos
    .local int rx2627_off
    .local int rx2627_eos
    .local int rx2627_rep
    .local pmc rx2627_cur
    .local pmc rx2627_debug
    (rx2627_cur, rx2627_pos, rx2627_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2627_cur
    .local pmc match
    .lex "$/", match
    length rx2627_eos, rx2627_tgt
    gt rx2627_pos, rx2627_eos, rx2627_done
    set rx2627_off, 0
    lt rx2627_pos, 2, rx2627_start
    sub rx2627_off, rx2627_pos, 1
    substr rx2627_tgt, rx2627_tgt, rx2627_off
  rx2627_start:
    eq $I10, 1, rx2627_restart
    if_null rx2627_debug, debug_1527
    rx2627_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1527:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2628_done
    goto rxscan2628_scan
  rxscan2628_loop:
    (rx2627_pos) = rx2627_cur."from"()
    inc rx2627_pos
    rx2627_cur."!cursor_from"(rx2627_pos)
    ge rx2627_pos, rx2627_eos, rxscan2628_done
  rxscan2628_scan:
    set_addr $I10, rxscan2628_loop
    rx2627_cur."!mark_push"(0, rx2627_pos, $I10)
  rxscan2628_done:
.annotate 'line', 1101
  # rx subcapture "sym"
    set_addr $I10, rxcap_2629_fail
    rx2627_cur."!mark_push"(0, rx2627_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2627_pos, 2
    gt $I11, rx2627_eos, rx2627_fail
    sub $I11, rx2627_pos, rx2627_off
    substr $S10, rx2627_tgt, $I11, 2
    ne $S10, "+&", rx2627_fail
    add rx2627_pos, 2
    set_addr $I10, rxcap_2629_fail
    ($I12, $I11) = rx2627_cur."!mark_peek"($I10)
    rx2627_cur."!cursor_pos"($I11)
    ($P10) = rx2627_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2627_pos, "")
    rx2627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2629_done
  rxcap_2629_fail:
    goto rx2627_fail
  rxcap_2629_done:
  # rx subrule "O" subtype=capture negate=
    rx2627_cur."!cursor_pos"(rx2627_pos)
    $P10 = rx2627_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2627_fail
    rx2627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2627_pos = $P10."pos"()
  # rx pass
    rx2627_cur."!cursor_pass"(rx2627_pos, "infix:sym<+&>")
    if_null rx2627_debug, debug_1528
    rx2627_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2627_pos)
  debug_1528:
    .return (rx2627_cur)
  rx2627_restart:
.annotate 'line', 436
    if_null rx2627_debug, debug_1529
    rx2627_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1529:
  rx2627_fail:
    (rx2627_rep, rx2627_pos, $I10, $P10) = rx2627_cur."!mark_fail"(0)
    lt rx2627_pos, -1, rx2627_done
    eq rx2627_pos, -1, rx2627_fail
    jump $I10
  rx2627_done:
    rx2627_cur."!cursor_fail"()
    if_null rx2627_debug, debug_1530
    rx2627_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1530:
    .return (rx2627_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("348_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2631 = self."!PREFIX__!subrule"("O", "+&")
    new $P2632, "ResizablePMCArray"
    push $P2632, $P2631
    .return ($P2632)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("349_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2634_tgt
    .local int rx2634_pos
    .local int rx2634_off
    .local int rx2634_eos
    .local int rx2634_rep
    .local pmc rx2634_cur
    .local pmc rx2634_debug
    (rx2634_cur, rx2634_pos, rx2634_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2634_cur
    .local pmc match
    .lex "$/", match
    length rx2634_eos, rx2634_tgt
    gt rx2634_pos, rx2634_eos, rx2634_done
    set rx2634_off, 0
    lt rx2634_pos, 2, rx2634_start
    sub rx2634_off, rx2634_pos, 1
    substr rx2634_tgt, rx2634_tgt, rx2634_off
  rx2634_start:
    eq $I10, 1, rx2634_restart
    if_null rx2634_debug, debug_1531
    rx2634_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1531:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2635_done
    goto rxscan2635_scan
  rxscan2635_loop:
    (rx2634_pos) = rx2634_cur."from"()
    inc rx2634_pos
    rx2634_cur."!cursor_from"(rx2634_pos)
    ge rx2634_pos, rx2634_eos, rxscan2635_done
  rxscan2635_scan:
    set_addr $I10, rxscan2635_loop
    rx2634_cur."!mark_push"(0, rx2634_pos, $I10)
  rxscan2635_done:
.annotate 'line', 1103
  # rx subcapture "sym"
    set_addr $I10, rxcap_2636_fail
    rx2634_cur."!mark_push"(0, rx2634_pos, $I10)
  # rx literal  "+"
    add $I11, rx2634_pos, 1
    gt $I11, rx2634_eos, rx2634_fail
    sub $I11, rx2634_pos, rx2634_off
    ord $I11, rx2634_tgt, $I11
    ne $I11, 43, rx2634_fail
    add rx2634_pos, 1
    set_addr $I10, rxcap_2636_fail
    ($I12, $I11) = rx2634_cur."!mark_peek"($I10)
    rx2634_cur."!cursor_pos"($I11)
    ($P10) = rx2634_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2634_pos, "")
    rx2634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2636_done
  rxcap_2636_fail:
    goto rx2634_fail
  rxcap_2636_done:
  # rx subrule "O" subtype=capture negate=
    rx2634_cur."!cursor_pos"(rx2634_pos)
    $P10 = rx2634_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2634_fail
    rx2634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2634_pos = $P10."pos"()
  # rx pass
    rx2634_cur."!cursor_pass"(rx2634_pos, "infix:sym<+>")
    if_null rx2634_debug, debug_1532
    rx2634_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2634_pos)
  debug_1532:
    .return (rx2634_cur)
  rx2634_restart:
.annotate 'line', 436
    if_null rx2634_debug, debug_1533
    rx2634_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1533:
  rx2634_fail:
    (rx2634_rep, rx2634_pos, $I10, $P10) = rx2634_cur."!mark_fail"(0)
    lt rx2634_pos, -1, rx2634_done
    eq rx2634_pos, -1, rx2634_fail
    jump $I10
  rx2634_done:
    rx2634_cur."!cursor_fail"()
    if_null rx2634_debug, debug_1534
    rx2634_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1534:
    .return (rx2634_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("350_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2638 = self."!PREFIX__!subrule"("O", "+")
    new $P2639, "ResizablePMCArray"
    push $P2639, $P2638
    .return ($P2639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("351_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2641_tgt
    .local int rx2641_pos
    .local int rx2641_off
    .local int rx2641_eos
    .local int rx2641_rep
    .local pmc rx2641_cur
    .local pmc rx2641_debug
    (rx2641_cur, rx2641_pos, rx2641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2641_cur
    .local pmc match
    .lex "$/", match
    length rx2641_eos, rx2641_tgt
    gt rx2641_pos, rx2641_eos, rx2641_done
    set rx2641_off, 0
    lt rx2641_pos, 2, rx2641_start
    sub rx2641_off, rx2641_pos, 1
    substr rx2641_tgt, rx2641_tgt, rx2641_off
  rx2641_start:
    eq $I10, 1, rx2641_restart
    if_null rx2641_debug, debug_1535
    rx2641_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1535:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2642_done
    goto rxscan2642_scan
  rxscan2642_loop:
    (rx2641_pos) = rx2641_cur."from"()
    inc rx2641_pos
    rx2641_cur."!cursor_from"(rx2641_pos)
    ge rx2641_pos, rx2641_eos, rxscan2642_done
  rxscan2642_scan:
    set_addr $I10, rxscan2642_loop
    rx2641_cur."!mark_push"(0, rx2641_pos, $I10)
  rxscan2642_done:
.annotate 'line', 1104
  # rx subcapture "sym"
    set_addr $I10, rxcap_2643_fail
    rx2641_cur."!mark_push"(0, rx2641_pos, $I10)
  # rx literal  "-"
    add $I11, rx2641_pos, 1
    gt $I11, rx2641_eos, rx2641_fail
    sub $I11, rx2641_pos, rx2641_off
    ord $I11, rx2641_tgt, $I11
    ne $I11, 45, rx2641_fail
    add rx2641_pos, 1
    set_addr $I10, rxcap_2643_fail
    ($I12, $I11) = rx2641_cur."!mark_peek"($I10)
    rx2641_cur."!cursor_pos"($I11)
    ($P10) = rx2641_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2641_pos, "")
    rx2641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2643_done
  rxcap_2643_fail:
    goto rx2641_fail
  rxcap_2643_done:
  # rx subrule "O" subtype=capture negate=
    rx2641_cur."!cursor_pos"(rx2641_pos)
    $P10 = rx2641_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2641_fail
    rx2641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2641_pos = $P10."pos"()
  # rx pass
    rx2641_cur."!cursor_pass"(rx2641_pos, "infix:sym<->")
    if_null rx2641_debug, debug_1536
    rx2641_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2641_pos)
  debug_1536:
    .return (rx2641_cur)
  rx2641_restart:
.annotate 'line', 436
    if_null rx2641_debug, debug_1537
    rx2641_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1537:
  rx2641_fail:
    (rx2641_rep, rx2641_pos, $I10, $P10) = rx2641_cur."!mark_fail"(0)
    lt rx2641_pos, -1, rx2641_done
    eq rx2641_pos, -1, rx2641_fail
    jump $I10
  rx2641_done:
    rx2641_cur."!cursor_fail"()
    if_null rx2641_debug, debug_1538
    rx2641_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1538:
    .return (rx2641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("352_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2645 = self."!PREFIX__!subrule"("O", "-")
    new $P2646, "ResizablePMCArray"
    push $P2646, $P2645
    .return ($P2646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("353_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2648_tgt
    .local int rx2648_pos
    .local int rx2648_off
    .local int rx2648_eos
    .local int rx2648_rep
    .local pmc rx2648_cur
    .local pmc rx2648_debug
    (rx2648_cur, rx2648_pos, rx2648_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2648_cur
    .local pmc match
    .lex "$/", match
    length rx2648_eos, rx2648_tgt
    gt rx2648_pos, rx2648_eos, rx2648_done
    set rx2648_off, 0
    lt rx2648_pos, 2, rx2648_start
    sub rx2648_off, rx2648_pos, 1
    substr rx2648_tgt, rx2648_tgt, rx2648_off
  rx2648_start:
    eq $I10, 1, rx2648_restart
    if_null rx2648_debug, debug_1539
    rx2648_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2649_done
    goto rxscan2649_scan
  rxscan2649_loop:
    (rx2648_pos) = rx2648_cur."from"()
    inc rx2648_pos
    rx2648_cur."!cursor_from"(rx2648_pos)
    ge rx2648_pos, rx2648_eos, rxscan2649_done
  rxscan2649_scan:
    set_addr $I10, rxscan2649_loop
    rx2648_cur."!mark_push"(0, rx2648_pos, $I10)
  rxscan2649_done:
.annotate 'line', 1105
  # rx subcapture "sym"
    set_addr $I10, rxcap_2650_fail
    rx2648_cur."!mark_push"(0, rx2648_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2648_pos, 2
    gt $I11, rx2648_eos, rx2648_fail
    sub $I11, rx2648_pos, rx2648_off
    substr $S10, rx2648_tgt, $I11, 2
    ne $S10, "+|", rx2648_fail
    add rx2648_pos, 2
    set_addr $I10, rxcap_2650_fail
    ($I12, $I11) = rx2648_cur."!mark_peek"($I10)
    rx2648_cur."!cursor_pos"($I11)
    ($P10) = rx2648_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2648_pos, "")
    rx2648_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2650_done
  rxcap_2650_fail:
    goto rx2648_fail
  rxcap_2650_done:
  # rx subrule "O" subtype=capture negate=
    rx2648_cur."!cursor_pos"(rx2648_pos)
    $P10 = rx2648_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2648_fail
    rx2648_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2648_pos = $P10."pos"()
  # rx pass
    rx2648_cur."!cursor_pass"(rx2648_pos, "infix:sym<+|>")
    if_null rx2648_debug, debug_1540
    rx2648_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2648_pos)
  debug_1540:
    .return (rx2648_cur)
  rx2648_restart:
.annotate 'line', 436
    if_null rx2648_debug, debug_1541
    rx2648_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1541:
  rx2648_fail:
    (rx2648_rep, rx2648_pos, $I10, $P10) = rx2648_cur."!mark_fail"(0)
    lt rx2648_pos, -1, rx2648_done
    eq rx2648_pos, -1, rx2648_fail
    jump $I10
  rx2648_done:
    rx2648_cur."!cursor_fail"()
    if_null rx2648_debug, debug_1542
    rx2648_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1542:
    .return (rx2648_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("354_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2652 = self."!PREFIX__!subrule"("O", "+|")
    new $P2653, "ResizablePMCArray"
    push $P2653, $P2652
    .return ($P2653)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("355_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2655_tgt
    .local int rx2655_pos
    .local int rx2655_off
    .local int rx2655_eos
    .local int rx2655_rep
    .local pmc rx2655_cur
    .local pmc rx2655_debug
    (rx2655_cur, rx2655_pos, rx2655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2655_cur
    .local pmc match
    .lex "$/", match
    length rx2655_eos, rx2655_tgt
    gt rx2655_pos, rx2655_eos, rx2655_done
    set rx2655_off, 0
    lt rx2655_pos, 2, rx2655_start
    sub rx2655_off, rx2655_pos, 1
    substr rx2655_tgt, rx2655_tgt, rx2655_off
  rx2655_start:
    eq $I10, 1, rx2655_restart
    if_null rx2655_debug, debug_1543
    rx2655_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1543:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2656_done
    goto rxscan2656_scan
  rxscan2656_loop:
    (rx2655_pos) = rx2655_cur."from"()
    inc rx2655_pos
    rx2655_cur."!cursor_from"(rx2655_pos)
    ge rx2655_pos, rx2655_eos, rxscan2656_done
  rxscan2656_scan:
    set_addr $I10, rxscan2656_loop
    rx2655_cur."!mark_push"(0, rx2655_pos, $I10)
  rxscan2656_done:
.annotate 'line', 1106
  # rx subcapture "sym"
    set_addr $I10, rxcap_2657_fail
    rx2655_cur."!mark_push"(0, rx2655_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2655_pos, 2
    gt $I11, rx2655_eos, rx2655_fail
    sub $I11, rx2655_pos, rx2655_off
    substr $S10, rx2655_tgt, $I11, 2
    ne $S10, "+^", rx2655_fail
    add rx2655_pos, 2
    set_addr $I10, rxcap_2657_fail
    ($I12, $I11) = rx2655_cur."!mark_peek"($I10)
    rx2655_cur."!cursor_pos"($I11)
    ($P10) = rx2655_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2655_pos, "")
    rx2655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2657_done
  rxcap_2657_fail:
    goto rx2655_fail
  rxcap_2657_done:
  # rx subrule "O" subtype=capture negate=
    rx2655_cur."!cursor_pos"(rx2655_pos)
    $P10 = rx2655_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2655_fail
    rx2655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2655_pos = $P10."pos"()
  # rx pass
    rx2655_cur."!cursor_pass"(rx2655_pos, "infix:sym<+^>")
    if_null rx2655_debug, debug_1544
    rx2655_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2655_pos)
  debug_1544:
    .return (rx2655_cur)
  rx2655_restart:
.annotate 'line', 436
    if_null rx2655_debug, debug_1545
    rx2655_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1545:
  rx2655_fail:
    (rx2655_rep, rx2655_pos, $I10, $P10) = rx2655_cur."!mark_fail"(0)
    lt rx2655_pos, -1, rx2655_done
    eq rx2655_pos, -1, rx2655_fail
    jump $I10
  rx2655_done:
    rx2655_cur."!cursor_fail"()
    if_null rx2655_debug, debug_1546
    rx2655_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1546:
    .return (rx2655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("356_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2659 = self."!PREFIX__!subrule"("O", "+^")
    new $P2660, "ResizablePMCArray"
    push $P2660, $P2659
    .return ($P2660)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("357_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2662_tgt
    .local int rx2662_pos
    .local int rx2662_off
    .local int rx2662_eos
    .local int rx2662_rep
    .local pmc rx2662_cur
    .local pmc rx2662_debug
    (rx2662_cur, rx2662_pos, rx2662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2662_cur
    .local pmc match
    .lex "$/", match
    length rx2662_eos, rx2662_tgt
    gt rx2662_pos, rx2662_eos, rx2662_done
    set rx2662_off, 0
    lt rx2662_pos, 2, rx2662_start
    sub rx2662_off, rx2662_pos, 1
    substr rx2662_tgt, rx2662_tgt, rx2662_off
  rx2662_start:
    eq $I10, 1, rx2662_restart
    if_null rx2662_debug, debug_1547
    rx2662_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1547:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2663_done
    goto rxscan2663_scan
  rxscan2663_loop:
    (rx2662_pos) = rx2662_cur."from"()
    inc rx2662_pos
    rx2662_cur."!cursor_from"(rx2662_pos)
    ge rx2662_pos, rx2662_eos, rxscan2663_done
  rxscan2663_scan:
    set_addr $I10, rxscan2663_loop
    rx2662_cur."!mark_push"(0, rx2662_pos, $I10)
  rxscan2663_done:
.annotate 'line', 1108
  # rx subcapture "sym"
    set_addr $I10, rxcap_2664_fail
    rx2662_cur."!mark_push"(0, rx2662_pos, $I10)
  # rx literal  "~"
    add $I11, rx2662_pos, 1
    gt $I11, rx2662_eos, rx2662_fail
    sub $I11, rx2662_pos, rx2662_off
    ord $I11, rx2662_tgt, $I11
    ne $I11, 126, rx2662_fail
    add rx2662_pos, 1
    set_addr $I10, rxcap_2664_fail
    ($I12, $I11) = rx2662_cur."!mark_peek"($I10)
    rx2662_cur."!cursor_pos"($I11)
    ($P10) = rx2662_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2662_pos, "")
    rx2662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2664_done
  rxcap_2664_fail:
    goto rx2662_fail
  rxcap_2664_done:
  # rx subrule "O" subtype=capture negate=
    rx2662_cur."!cursor_pos"(rx2662_pos)
    $P10 = rx2662_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2662_fail
    rx2662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2662_pos = $P10."pos"()
  # rx pass
    rx2662_cur."!cursor_pass"(rx2662_pos, "infix:sym<~>")
    if_null rx2662_debug, debug_1548
    rx2662_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2662_pos)
  debug_1548:
    .return (rx2662_cur)
  rx2662_restart:
.annotate 'line', 436
    if_null rx2662_debug, debug_1549
    rx2662_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1549:
  rx2662_fail:
    (rx2662_rep, rx2662_pos, $I10, $P10) = rx2662_cur."!mark_fail"(0)
    lt rx2662_pos, -1, rx2662_done
    eq rx2662_pos, -1, rx2662_fail
    jump $I10
  rx2662_done:
    rx2662_cur."!cursor_fail"()
    if_null rx2662_debug, debug_1550
    rx2662_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1550:
    .return (rx2662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("358_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2666 = self."!PREFIX__!subrule"("O", "~")
    new $P2667, "ResizablePMCArray"
    push $P2667, $P2666
    .return ($P2667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("359_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2669_tgt
    .local int rx2669_pos
    .local int rx2669_off
    .local int rx2669_eos
    .local int rx2669_rep
    .local pmc rx2669_cur
    .local pmc rx2669_debug
    (rx2669_cur, rx2669_pos, rx2669_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2669_cur
    .local pmc match
    .lex "$/", match
    length rx2669_eos, rx2669_tgt
    gt rx2669_pos, rx2669_eos, rx2669_done
    set rx2669_off, 0
    lt rx2669_pos, 2, rx2669_start
    sub rx2669_off, rx2669_pos, 1
    substr rx2669_tgt, rx2669_tgt, rx2669_off
  rx2669_start:
    eq $I10, 1, rx2669_restart
    if_null rx2669_debug, debug_1551
    rx2669_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1551:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2670_done
    goto rxscan2670_scan
  rxscan2670_loop:
    (rx2669_pos) = rx2669_cur."from"()
    inc rx2669_pos
    rx2669_cur."!cursor_from"(rx2669_pos)
    ge rx2669_pos, rx2669_eos, rxscan2670_done
  rxscan2670_scan:
    set_addr $I10, rxscan2670_loop
    rx2669_cur."!mark_push"(0, rx2669_pos, $I10)
  rxscan2670_done:
.annotate 'line', 1110
  # rx subcapture "sym"
    set_addr $I10, rxcap_2671_fail
    rx2669_cur."!mark_push"(0, rx2669_pos, $I10)
  # rx literal  "=="
    add $I11, rx2669_pos, 2
    gt $I11, rx2669_eos, rx2669_fail
    sub $I11, rx2669_pos, rx2669_off
    substr $S10, rx2669_tgt, $I11, 2
    ne $S10, "==", rx2669_fail
    add rx2669_pos, 2
    set_addr $I10, rxcap_2671_fail
    ($I12, $I11) = rx2669_cur."!mark_peek"($I10)
    rx2669_cur."!cursor_pos"($I11)
    ($P10) = rx2669_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2669_pos, "")
    rx2669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2671_done
  rxcap_2671_fail:
    goto rx2669_fail
  rxcap_2671_done:
  # rx subrule "O" subtype=capture negate=
    rx2669_cur."!cursor_pos"(rx2669_pos)
    $P10 = rx2669_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2669_fail
    rx2669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2669_pos = $P10."pos"()
  # rx pass
    rx2669_cur."!cursor_pass"(rx2669_pos, "infix:sym<==>")
    if_null rx2669_debug, debug_1552
    rx2669_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2669_pos)
  debug_1552:
    .return (rx2669_cur)
  rx2669_restart:
.annotate 'line', 436
    if_null rx2669_debug, debug_1553
    rx2669_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1553:
  rx2669_fail:
    (rx2669_rep, rx2669_pos, $I10, $P10) = rx2669_cur."!mark_fail"(0)
    lt rx2669_pos, -1, rx2669_done
    eq rx2669_pos, -1, rx2669_fail
    jump $I10
  rx2669_done:
    rx2669_cur."!cursor_fail"()
    if_null rx2669_debug, debug_1554
    rx2669_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1554:
    .return (rx2669_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("360_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2673 = self."!PREFIX__!subrule"("O", "==")
    new $P2674, "ResizablePMCArray"
    push $P2674, $P2673
    .return ($P2674)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("361_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2676_tgt
    .local int rx2676_pos
    .local int rx2676_off
    .local int rx2676_eos
    .local int rx2676_rep
    .local pmc rx2676_cur
    .local pmc rx2676_debug
    (rx2676_cur, rx2676_pos, rx2676_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2676_cur
    .local pmc match
    .lex "$/", match
    length rx2676_eos, rx2676_tgt
    gt rx2676_pos, rx2676_eos, rx2676_done
    set rx2676_off, 0
    lt rx2676_pos, 2, rx2676_start
    sub rx2676_off, rx2676_pos, 1
    substr rx2676_tgt, rx2676_tgt, rx2676_off
  rx2676_start:
    eq $I10, 1, rx2676_restart
    if_null rx2676_debug, debug_1555
    rx2676_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1555:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2677_done
    goto rxscan2677_scan
  rxscan2677_loop:
    (rx2676_pos) = rx2676_cur."from"()
    inc rx2676_pos
    rx2676_cur."!cursor_from"(rx2676_pos)
    ge rx2676_pos, rx2676_eos, rxscan2677_done
  rxscan2677_scan:
    set_addr $I10, rxscan2677_loop
    rx2676_cur."!mark_push"(0, rx2676_pos, $I10)
  rxscan2677_done:
.annotate 'line', 1111
  # rx subcapture "sym"
    set_addr $I10, rxcap_2678_fail
    rx2676_cur."!mark_push"(0, rx2676_pos, $I10)
  # rx literal  "!="
    add $I11, rx2676_pos, 2
    gt $I11, rx2676_eos, rx2676_fail
    sub $I11, rx2676_pos, rx2676_off
    substr $S10, rx2676_tgt, $I11, 2
    ne $S10, "!=", rx2676_fail
    add rx2676_pos, 2
    set_addr $I10, rxcap_2678_fail
    ($I12, $I11) = rx2676_cur."!mark_peek"($I10)
    rx2676_cur."!cursor_pos"($I11)
    ($P10) = rx2676_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2676_pos, "")
    rx2676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2678_done
  rxcap_2678_fail:
    goto rx2676_fail
  rxcap_2678_done:
  # rx subrule "O" subtype=capture negate=
    rx2676_cur."!cursor_pos"(rx2676_pos)
    $P10 = rx2676_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2676_fail
    rx2676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2676_pos = $P10."pos"()
  # rx pass
    rx2676_cur."!cursor_pass"(rx2676_pos, "infix:sym<!=>")
    if_null rx2676_debug, debug_1556
    rx2676_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2676_pos)
  debug_1556:
    .return (rx2676_cur)
  rx2676_restart:
.annotate 'line', 436
    if_null rx2676_debug, debug_1557
    rx2676_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1557:
  rx2676_fail:
    (rx2676_rep, rx2676_pos, $I10, $P10) = rx2676_cur."!mark_fail"(0)
    lt rx2676_pos, -1, rx2676_done
    eq rx2676_pos, -1, rx2676_fail
    jump $I10
  rx2676_done:
    rx2676_cur."!cursor_fail"()
    if_null rx2676_debug, debug_1558
    rx2676_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1558:
    .return (rx2676_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("362_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2680 = self."!PREFIX__!subrule"("O", "!=")
    new $P2681, "ResizablePMCArray"
    push $P2681, $P2680
    .return ($P2681)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("363_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2683_tgt
    .local int rx2683_pos
    .local int rx2683_off
    .local int rx2683_eos
    .local int rx2683_rep
    .local pmc rx2683_cur
    .local pmc rx2683_debug
    (rx2683_cur, rx2683_pos, rx2683_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2683_cur
    .local pmc match
    .lex "$/", match
    length rx2683_eos, rx2683_tgt
    gt rx2683_pos, rx2683_eos, rx2683_done
    set rx2683_off, 0
    lt rx2683_pos, 2, rx2683_start
    sub rx2683_off, rx2683_pos, 1
    substr rx2683_tgt, rx2683_tgt, rx2683_off
  rx2683_start:
    eq $I10, 1, rx2683_restart
    if_null rx2683_debug, debug_1559
    rx2683_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1559:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2684_done
    goto rxscan2684_scan
  rxscan2684_loop:
    (rx2683_pos) = rx2683_cur."from"()
    inc rx2683_pos
    rx2683_cur."!cursor_from"(rx2683_pos)
    ge rx2683_pos, rx2683_eos, rxscan2684_done
  rxscan2684_scan:
    set_addr $I10, rxscan2684_loop
    rx2683_cur."!mark_push"(0, rx2683_pos, $I10)
  rxscan2684_done:
.annotate 'line', 1112
  # rx subcapture "sym"
    set_addr $I10, rxcap_2685_fail
    rx2683_cur."!mark_push"(0, rx2683_pos, $I10)
  # rx literal  "<="
    add $I11, rx2683_pos, 2
    gt $I11, rx2683_eos, rx2683_fail
    sub $I11, rx2683_pos, rx2683_off
    substr $S10, rx2683_tgt, $I11, 2
    ne $S10, "<=", rx2683_fail
    add rx2683_pos, 2
    set_addr $I10, rxcap_2685_fail
    ($I12, $I11) = rx2683_cur."!mark_peek"($I10)
    rx2683_cur."!cursor_pos"($I11)
    ($P10) = rx2683_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2683_pos, "")
    rx2683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2685_done
  rxcap_2685_fail:
    goto rx2683_fail
  rxcap_2685_done:
  # rx subrule "O" subtype=capture negate=
    rx2683_cur."!cursor_pos"(rx2683_pos)
    $P10 = rx2683_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2683_fail
    rx2683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2683_pos = $P10."pos"()
  # rx pass
    rx2683_cur."!cursor_pass"(rx2683_pos, "infix:sym<<=>")
    if_null rx2683_debug, debug_1560
    rx2683_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2683_pos)
  debug_1560:
    .return (rx2683_cur)
  rx2683_restart:
.annotate 'line', 436
    if_null rx2683_debug, debug_1561
    rx2683_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1561:
  rx2683_fail:
    (rx2683_rep, rx2683_pos, $I10, $P10) = rx2683_cur."!mark_fail"(0)
    lt rx2683_pos, -1, rx2683_done
    eq rx2683_pos, -1, rx2683_fail
    jump $I10
  rx2683_done:
    rx2683_cur."!cursor_fail"()
    if_null rx2683_debug, debug_1562
    rx2683_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1562:
    .return (rx2683_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("364_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2687 = self."!PREFIX__!subrule"("O", "<=")
    new $P2688, "ResizablePMCArray"
    push $P2688, $P2687
    .return ($P2688)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("365_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2690_tgt
    .local int rx2690_pos
    .local int rx2690_off
    .local int rx2690_eos
    .local int rx2690_rep
    .local pmc rx2690_cur
    .local pmc rx2690_debug
    (rx2690_cur, rx2690_pos, rx2690_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2690_cur
    .local pmc match
    .lex "$/", match
    length rx2690_eos, rx2690_tgt
    gt rx2690_pos, rx2690_eos, rx2690_done
    set rx2690_off, 0
    lt rx2690_pos, 2, rx2690_start
    sub rx2690_off, rx2690_pos, 1
    substr rx2690_tgt, rx2690_tgt, rx2690_off
  rx2690_start:
    eq $I10, 1, rx2690_restart
    if_null rx2690_debug, debug_1563
    rx2690_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1563:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2691_done
    goto rxscan2691_scan
  rxscan2691_loop:
    (rx2690_pos) = rx2690_cur."from"()
    inc rx2690_pos
    rx2690_cur."!cursor_from"(rx2690_pos)
    ge rx2690_pos, rx2690_eos, rxscan2691_done
  rxscan2691_scan:
    set_addr $I10, rxscan2691_loop
    rx2690_cur."!mark_push"(0, rx2690_pos, $I10)
  rxscan2691_done:
.annotate 'line', 1113
  # rx subcapture "sym"
    set_addr $I10, rxcap_2692_fail
    rx2690_cur."!mark_push"(0, rx2690_pos, $I10)
  # rx literal  ">="
    add $I11, rx2690_pos, 2
    gt $I11, rx2690_eos, rx2690_fail
    sub $I11, rx2690_pos, rx2690_off
    substr $S10, rx2690_tgt, $I11, 2
    ne $S10, ">=", rx2690_fail
    add rx2690_pos, 2
    set_addr $I10, rxcap_2692_fail
    ($I12, $I11) = rx2690_cur."!mark_peek"($I10)
    rx2690_cur."!cursor_pos"($I11)
    ($P10) = rx2690_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2690_pos, "")
    rx2690_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2692_done
  rxcap_2692_fail:
    goto rx2690_fail
  rxcap_2692_done:
  # rx subrule "O" subtype=capture negate=
    rx2690_cur."!cursor_pos"(rx2690_pos)
    $P10 = rx2690_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2690_fail
    rx2690_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2690_pos = $P10."pos"()
  # rx pass
    rx2690_cur."!cursor_pass"(rx2690_pos, "infix:sym<>=>")
    if_null rx2690_debug, debug_1564
    rx2690_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2690_pos)
  debug_1564:
    .return (rx2690_cur)
  rx2690_restart:
.annotate 'line', 436
    if_null rx2690_debug, debug_1565
    rx2690_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1565:
  rx2690_fail:
    (rx2690_rep, rx2690_pos, $I10, $P10) = rx2690_cur."!mark_fail"(0)
    lt rx2690_pos, -1, rx2690_done
    eq rx2690_pos, -1, rx2690_fail
    jump $I10
  rx2690_done:
    rx2690_cur."!cursor_fail"()
    if_null rx2690_debug, debug_1566
    rx2690_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1566:
    .return (rx2690_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("366_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2694 = self."!PREFIX__!subrule"("O", ">=")
    new $P2695, "ResizablePMCArray"
    push $P2695, $P2694
    .return ($P2695)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("367_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2697_tgt
    .local int rx2697_pos
    .local int rx2697_off
    .local int rx2697_eos
    .local int rx2697_rep
    .local pmc rx2697_cur
    .local pmc rx2697_debug
    (rx2697_cur, rx2697_pos, rx2697_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2697_cur
    .local pmc match
    .lex "$/", match
    length rx2697_eos, rx2697_tgt
    gt rx2697_pos, rx2697_eos, rx2697_done
    set rx2697_off, 0
    lt rx2697_pos, 2, rx2697_start
    sub rx2697_off, rx2697_pos, 1
    substr rx2697_tgt, rx2697_tgt, rx2697_off
  rx2697_start:
    eq $I10, 1, rx2697_restart
    if_null rx2697_debug, debug_1567
    rx2697_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1567:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2698_done
    goto rxscan2698_scan
  rxscan2698_loop:
    (rx2697_pos) = rx2697_cur."from"()
    inc rx2697_pos
    rx2697_cur."!cursor_from"(rx2697_pos)
    ge rx2697_pos, rx2697_eos, rxscan2698_done
  rxscan2698_scan:
    set_addr $I10, rxscan2698_loop
    rx2697_cur."!mark_push"(0, rx2697_pos, $I10)
  rxscan2698_done:
.annotate 'line', 1114
  # rx subcapture "sym"
    set_addr $I10, rxcap_2699_fail
    rx2697_cur."!mark_push"(0, rx2697_pos, $I10)
  # rx literal  "<"
    add $I11, rx2697_pos, 1
    gt $I11, rx2697_eos, rx2697_fail
    sub $I11, rx2697_pos, rx2697_off
    ord $I11, rx2697_tgt, $I11
    ne $I11, 60, rx2697_fail
    add rx2697_pos, 1
    set_addr $I10, rxcap_2699_fail
    ($I12, $I11) = rx2697_cur."!mark_peek"($I10)
    rx2697_cur."!cursor_pos"($I11)
    ($P10) = rx2697_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2697_pos, "")
    rx2697_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2699_done
  rxcap_2699_fail:
    goto rx2697_fail
  rxcap_2699_done:
  # rx subrule "O" subtype=capture negate=
    rx2697_cur."!cursor_pos"(rx2697_pos)
    $P10 = rx2697_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2697_fail
    rx2697_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2697_pos = $P10."pos"()
  # rx pass
    rx2697_cur."!cursor_pass"(rx2697_pos, "infix:sym<<>")
    if_null rx2697_debug, debug_1568
    rx2697_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2697_pos)
  debug_1568:
    .return (rx2697_cur)
  rx2697_restart:
.annotate 'line', 436
    if_null rx2697_debug, debug_1569
    rx2697_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1569:
  rx2697_fail:
    (rx2697_rep, rx2697_pos, $I10, $P10) = rx2697_cur."!mark_fail"(0)
    lt rx2697_pos, -1, rx2697_done
    eq rx2697_pos, -1, rx2697_fail
    jump $I10
  rx2697_done:
    rx2697_cur."!cursor_fail"()
    if_null rx2697_debug, debug_1570
    rx2697_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1570:
    .return (rx2697_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("368_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2701 = self."!PREFIX__!subrule"("O", "<")
    new $P2702, "ResizablePMCArray"
    push $P2702, $P2701
    .return ($P2702)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("369_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2704_tgt
    .local int rx2704_pos
    .local int rx2704_off
    .local int rx2704_eos
    .local int rx2704_rep
    .local pmc rx2704_cur
    .local pmc rx2704_debug
    (rx2704_cur, rx2704_pos, rx2704_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2704_cur
    .local pmc match
    .lex "$/", match
    length rx2704_eos, rx2704_tgt
    gt rx2704_pos, rx2704_eos, rx2704_done
    set rx2704_off, 0
    lt rx2704_pos, 2, rx2704_start
    sub rx2704_off, rx2704_pos, 1
    substr rx2704_tgt, rx2704_tgt, rx2704_off
  rx2704_start:
    eq $I10, 1, rx2704_restart
    if_null rx2704_debug, debug_1571
    rx2704_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1571:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2705_done
    goto rxscan2705_scan
  rxscan2705_loop:
    (rx2704_pos) = rx2704_cur."from"()
    inc rx2704_pos
    rx2704_cur."!cursor_from"(rx2704_pos)
    ge rx2704_pos, rx2704_eos, rxscan2705_done
  rxscan2705_scan:
    set_addr $I10, rxscan2705_loop
    rx2704_cur."!mark_push"(0, rx2704_pos, $I10)
  rxscan2705_done:
.annotate 'line', 1115
  # rx subcapture "sym"
    set_addr $I10, rxcap_2706_fail
    rx2704_cur."!mark_push"(0, rx2704_pos, $I10)
  # rx literal  ">"
    add $I11, rx2704_pos, 1
    gt $I11, rx2704_eos, rx2704_fail
    sub $I11, rx2704_pos, rx2704_off
    ord $I11, rx2704_tgt, $I11
    ne $I11, 62, rx2704_fail
    add rx2704_pos, 1
    set_addr $I10, rxcap_2706_fail
    ($I12, $I11) = rx2704_cur."!mark_peek"($I10)
    rx2704_cur."!cursor_pos"($I11)
    ($P10) = rx2704_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2704_pos, "")
    rx2704_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2706_done
  rxcap_2706_fail:
    goto rx2704_fail
  rxcap_2706_done:
  # rx subrule "O" subtype=capture negate=
    rx2704_cur."!cursor_pos"(rx2704_pos)
    $P10 = rx2704_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2704_fail
    rx2704_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2704_pos = $P10."pos"()
  # rx pass
    rx2704_cur."!cursor_pass"(rx2704_pos, "infix:sym<>>")
    if_null rx2704_debug, debug_1572
    rx2704_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2704_pos)
  debug_1572:
    .return (rx2704_cur)
  rx2704_restart:
.annotate 'line', 436
    if_null rx2704_debug, debug_1573
    rx2704_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1573:
  rx2704_fail:
    (rx2704_rep, rx2704_pos, $I10, $P10) = rx2704_cur."!mark_fail"(0)
    lt rx2704_pos, -1, rx2704_done
    eq rx2704_pos, -1, rx2704_fail
    jump $I10
  rx2704_done:
    rx2704_cur."!cursor_fail"()
    if_null rx2704_debug, debug_1574
    rx2704_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1574:
    .return (rx2704_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("370_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2708 = self."!PREFIX__!subrule"("O", ">")
    new $P2709, "ResizablePMCArray"
    push $P2709, $P2708
    .return ($P2709)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("371_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2711_tgt
    .local int rx2711_pos
    .local int rx2711_off
    .local int rx2711_eos
    .local int rx2711_rep
    .local pmc rx2711_cur
    .local pmc rx2711_debug
    (rx2711_cur, rx2711_pos, rx2711_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2711_cur
    .local pmc match
    .lex "$/", match
    length rx2711_eos, rx2711_tgt
    gt rx2711_pos, rx2711_eos, rx2711_done
    set rx2711_off, 0
    lt rx2711_pos, 2, rx2711_start
    sub rx2711_off, rx2711_pos, 1
    substr rx2711_tgt, rx2711_tgt, rx2711_off
  rx2711_start:
    eq $I10, 1, rx2711_restart
    if_null rx2711_debug, debug_1575
    rx2711_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1575:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2712_done
    goto rxscan2712_scan
  rxscan2712_loop:
    (rx2711_pos) = rx2711_cur."from"()
    inc rx2711_pos
    rx2711_cur."!cursor_from"(rx2711_pos)
    ge rx2711_pos, rx2711_eos, rxscan2712_done
  rxscan2712_scan:
    set_addr $I10, rxscan2712_loop
    rx2711_cur."!mark_push"(0, rx2711_pos, $I10)
  rxscan2712_done:
.annotate 'line', 1116
  # rx subcapture "sym"
    set_addr $I10, rxcap_2713_fail
    rx2711_cur."!mark_push"(0, rx2711_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2711_pos, 2
    gt $I11, rx2711_eos, rx2711_fail
    sub $I11, rx2711_pos, rx2711_off
    substr $S10, rx2711_tgt, $I11, 2
    ne $S10, "eq", rx2711_fail
    add rx2711_pos, 2
    set_addr $I10, rxcap_2713_fail
    ($I12, $I11) = rx2711_cur."!mark_peek"($I10)
    rx2711_cur."!cursor_pos"($I11)
    ($P10) = rx2711_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2711_pos, "")
    rx2711_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2713_done
  rxcap_2713_fail:
    goto rx2711_fail
  rxcap_2713_done:
  # rx subrule "O" subtype=capture negate=
    rx2711_cur."!cursor_pos"(rx2711_pos)
    $P10 = rx2711_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2711_fail
    rx2711_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2711_pos = $P10."pos"()
  # rx pass
    rx2711_cur."!cursor_pass"(rx2711_pos, "infix:sym<eq>")
    if_null rx2711_debug, debug_1576
    rx2711_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2711_pos)
  debug_1576:
    .return (rx2711_cur)
  rx2711_restart:
.annotate 'line', 436
    if_null rx2711_debug, debug_1577
    rx2711_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1577:
  rx2711_fail:
    (rx2711_rep, rx2711_pos, $I10, $P10) = rx2711_cur."!mark_fail"(0)
    lt rx2711_pos, -1, rx2711_done
    eq rx2711_pos, -1, rx2711_fail
    jump $I10
  rx2711_done:
    rx2711_cur."!cursor_fail"()
    if_null rx2711_debug, debug_1578
    rx2711_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1578:
    .return (rx2711_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("372_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2715 = self."!PREFIX__!subrule"("O", "eq")
    new $P2716, "ResizablePMCArray"
    push $P2716, $P2715
    .return ($P2716)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("373_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2718_tgt
    .local int rx2718_pos
    .local int rx2718_off
    .local int rx2718_eos
    .local int rx2718_rep
    .local pmc rx2718_cur
    .local pmc rx2718_debug
    (rx2718_cur, rx2718_pos, rx2718_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2718_cur
    .local pmc match
    .lex "$/", match
    length rx2718_eos, rx2718_tgt
    gt rx2718_pos, rx2718_eos, rx2718_done
    set rx2718_off, 0
    lt rx2718_pos, 2, rx2718_start
    sub rx2718_off, rx2718_pos, 1
    substr rx2718_tgt, rx2718_tgt, rx2718_off
  rx2718_start:
    eq $I10, 1, rx2718_restart
    if_null rx2718_debug, debug_1579
    rx2718_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1579:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2719_done
    goto rxscan2719_scan
  rxscan2719_loop:
    (rx2718_pos) = rx2718_cur."from"()
    inc rx2718_pos
    rx2718_cur."!cursor_from"(rx2718_pos)
    ge rx2718_pos, rx2718_eos, rxscan2719_done
  rxscan2719_scan:
    set_addr $I10, rxscan2719_loop
    rx2718_cur."!mark_push"(0, rx2718_pos, $I10)
  rxscan2719_done:
.annotate 'line', 1117
  # rx subcapture "sym"
    set_addr $I10, rxcap_2720_fail
    rx2718_cur."!mark_push"(0, rx2718_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2718_pos, 2
    gt $I11, rx2718_eos, rx2718_fail
    sub $I11, rx2718_pos, rx2718_off
    substr $S10, rx2718_tgt, $I11, 2
    ne $S10, "ne", rx2718_fail
    add rx2718_pos, 2
    set_addr $I10, rxcap_2720_fail
    ($I12, $I11) = rx2718_cur."!mark_peek"($I10)
    rx2718_cur."!cursor_pos"($I11)
    ($P10) = rx2718_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2718_pos, "")
    rx2718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2720_done
  rxcap_2720_fail:
    goto rx2718_fail
  rxcap_2720_done:
  # rx subrule "O" subtype=capture negate=
    rx2718_cur."!cursor_pos"(rx2718_pos)
    $P10 = rx2718_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2718_fail
    rx2718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2718_pos = $P10."pos"()
  # rx pass
    rx2718_cur."!cursor_pass"(rx2718_pos, "infix:sym<ne>")
    if_null rx2718_debug, debug_1580
    rx2718_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2718_pos)
  debug_1580:
    .return (rx2718_cur)
  rx2718_restart:
.annotate 'line', 436
    if_null rx2718_debug, debug_1581
    rx2718_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1581:
  rx2718_fail:
    (rx2718_rep, rx2718_pos, $I10, $P10) = rx2718_cur."!mark_fail"(0)
    lt rx2718_pos, -1, rx2718_done
    eq rx2718_pos, -1, rx2718_fail
    jump $I10
  rx2718_done:
    rx2718_cur."!cursor_fail"()
    if_null rx2718_debug, debug_1582
    rx2718_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1582:
    .return (rx2718_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("374_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2722 = self."!PREFIX__!subrule"("O", "ne")
    new $P2723, "ResizablePMCArray"
    push $P2723, $P2722
    .return ($P2723)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("375_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2725_tgt
    .local int rx2725_pos
    .local int rx2725_off
    .local int rx2725_eos
    .local int rx2725_rep
    .local pmc rx2725_cur
    .local pmc rx2725_debug
    (rx2725_cur, rx2725_pos, rx2725_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2725_cur
    .local pmc match
    .lex "$/", match
    length rx2725_eos, rx2725_tgt
    gt rx2725_pos, rx2725_eos, rx2725_done
    set rx2725_off, 0
    lt rx2725_pos, 2, rx2725_start
    sub rx2725_off, rx2725_pos, 1
    substr rx2725_tgt, rx2725_tgt, rx2725_off
  rx2725_start:
    eq $I10, 1, rx2725_restart
    if_null rx2725_debug, debug_1583
    rx2725_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1583:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2726_done
    goto rxscan2726_scan
  rxscan2726_loop:
    (rx2725_pos) = rx2725_cur."from"()
    inc rx2725_pos
    rx2725_cur."!cursor_from"(rx2725_pos)
    ge rx2725_pos, rx2725_eos, rxscan2726_done
  rxscan2726_scan:
    set_addr $I10, rxscan2726_loop
    rx2725_cur."!mark_push"(0, rx2725_pos, $I10)
  rxscan2726_done:
.annotate 'line', 1118
  # rx subcapture "sym"
    set_addr $I10, rxcap_2727_fail
    rx2725_cur."!mark_push"(0, rx2725_pos, $I10)
  # rx literal  "le"
    add $I11, rx2725_pos, 2
    gt $I11, rx2725_eos, rx2725_fail
    sub $I11, rx2725_pos, rx2725_off
    substr $S10, rx2725_tgt, $I11, 2
    ne $S10, "le", rx2725_fail
    add rx2725_pos, 2
    set_addr $I10, rxcap_2727_fail
    ($I12, $I11) = rx2725_cur."!mark_peek"($I10)
    rx2725_cur."!cursor_pos"($I11)
    ($P10) = rx2725_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2725_pos, "")
    rx2725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2727_done
  rxcap_2727_fail:
    goto rx2725_fail
  rxcap_2727_done:
  # rx subrule "O" subtype=capture negate=
    rx2725_cur."!cursor_pos"(rx2725_pos)
    $P10 = rx2725_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2725_fail
    rx2725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2725_pos = $P10."pos"()
  # rx pass
    rx2725_cur."!cursor_pass"(rx2725_pos, "infix:sym<le>")
    if_null rx2725_debug, debug_1584
    rx2725_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2725_pos)
  debug_1584:
    .return (rx2725_cur)
  rx2725_restart:
.annotate 'line', 436
    if_null rx2725_debug, debug_1585
    rx2725_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1585:
  rx2725_fail:
    (rx2725_rep, rx2725_pos, $I10, $P10) = rx2725_cur."!mark_fail"(0)
    lt rx2725_pos, -1, rx2725_done
    eq rx2725_pos, -1, rx2725_fail
    jump $I10
  rx2725_done:
    rx2725_cur."!cursor_fail"()
    if_null rx2725_debug, debug_1586
    rx2725_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1586:
    .return (rx2725_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("376_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2729 = self."!PREFIX__!subrule"("O", "le")
    new $P2730, "ResizablePMCArray"
    push $P2730, $P2729
    .return ($P2730)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("377_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2732_tgt
    .local int rx2732_pos
    .local int rx2732_off
    .local int rx2732_eos
    .local int rx2732_rep
    .local pmc rx2732_cur
    .local pmc rx2732_debug
    (rx2732_cur, rx2732_pos, rx2732_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2732_cur
    .local pmc match
    .lex "$/", match
    length rx2732_eos, rx2732_tgt
    gt rx2732_pos, rx2732_eos, rx2732_done
    set rx2732_off, 0
    lt rx2732_pos, 2, rx2732_start
    sub rx2732_off, rx2732_pos, 1
    substr rx2732_tgt, rx2732_tgt, rx2732_off
  rx2732_start:
    eq $I10, 1, rx2732_restart
    if_null rx2732_debug, debug_1587
    rx2732_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1587:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2733_done
    goto rxscan2733_scan
  rxscan2733_loop:
    (rx2732_pos) = rx2732_cur."from"()
    inc rx2732_pos
    rx2732_cur."!cursor_from"(rx2732_pos)
    ge rx2732_pos, rx2732_eos, rxscan2733_done
  rxscan2733_scan:
    set_addr $I10, rxscan2733_loop
    rx2732_cur."!mark_push"(0, rx2732_pos, $I10)
  rxscan2733_done:
.annotate 'line', 1119
  # rx subcapture "sym"
    set_addr $I10, rxcap_2734_fail
    rx2732_cur."!mark_push"(0, rx2732_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2732_pos, 2
    gt $I11, rx2732_eos, rx2732_fail
    sub $I11, rx2732_pos, rx2732_off
    substr $S10, rx2732_tgt, $I11, 2
    ne $S10, "ge", rx2732_fail
    add rx2732_pos, 2
    set_addr $I10, rxcap_2734_fail
    ($I12, $I11) = rx2732_cur."!mark_peek"($I10)
    rx2732_cur."!cursor_pos"($I11)
    ($P10) = rx2732_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2732_pos, "")
    rx2732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2734_done
  rxcap_2734_fail:
    goto rx2732_fail
  rxcap_2734_done:
  # rx subrule "O" subtype=capture negate=
    rx2732_cur."!cursor_pos"(rx2732_pos)
    $P10 = rx2732_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2732_fail
    rx2732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2732_pos = $P10."pos"()
  # rx pass
    rx2732_cur."!cursor_pass"(rx2732_pos, "infix:sym<ge>")
    if_null rx2732_debug, debug_1588
    rx2732_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2732_pos)
  debug_1588:
    .return (rx2732_cur)
  rx2732_restart:
.annotate 'line', 436
    if_null rx2732_debug, debug_1589
    rx2732_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1589:
  rx2732_fail:
    (rx2732_rep, rx2732_pos, $I10, $P10) = rx2732_cur."!mark_fail"(0)
    lt rx2732_pos, -1, rx2732_done
    eq rx2732_pos, -1, rx2732_fail
    jump $I10
  rx2732_done:
    rx2732_cur."!cursor_fail"()
    if_null rx2732_debug, debug_1590
    rx2732_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1590:
    .return (rx2732_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("378_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2736 = self."!PREFIX__!subrule"("O", "ge")
    new $P2737, "ResizablePMCArray"
    push $P2737, $P2736
    .return ($P2737)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("379_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2739_tgt
    .local int rx2739_pos
    .local int rx2739_off
    .local int rx2739_eos
    .local int rx2739_rep
    .local pmc rx2739_cur
    .local pmc rx2739_debug
    (rx2739_cur, rx2739_pos, rx2739_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2739_cur
    .local pmc match
    .lex "$/", match
    length rx2739_eos, rx2739_tgt
    gt rx2739_pos, rx2739_eos, rx2739_done
    set rx2739_off, 0
    lt rx2739_pos, 2, rx2739_start
    sub rx2739_off, rx2739_pos, 1
    substr rx2739_tgt, rx2739_tgt, rx2739_off
  rx2739_start:
    eq $I10, 1, rx2739_restart
    if_null rx2739_debug, debug_1591
    rx2739_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1591:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2740_done
    goto rxscan2740_scan
  rxscan2740_loop:
    (rx2739_pos) = rx2739_cur."from"()
    inc rx2739_pos
    rx2739_cur."!cursor_from"(rx2739_pos)
    ge rx2739_pos, rx2739_eos, rxscan2740_done
  rxscan2740_scan:
    set_addr $I10, rxscan2740_loop
    rx2739_cur."!mark_push"(0, rx2739_pos, $I10)
  rxscan2740_done:
.annotate 'line', 1120
  # rx subcapture "sym"
    set_addr $I10, rxcap_2741_fail
    rx2739_cur."!mark_push"(0, rx2739_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2739_pos, 2
    gt $I11, rx2739_eos, rx2739_fail
    sub $I11, rx2739_pos, rx2739_off
    substr $S10, rx2739_tgt, $I11, 2
    ne $S10, "lt", rx2739_fail
    add rx2739_pos, 2
    set_addr $I10, rxcap_2741_fail
    ($I12, $I11) = rx2739_cur."!mark_peek"($I10)
    rx2739_cur."!cursor_pos"($I11)
    ($P10) = rx2739_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2739_pos, "")
    rx2739_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2741_done
  rxcap_2741_fail:
    goto rx2739_fail
  rxcap_2741_done:
  # rx subrule "O" subtype=capture negate=
    rx2739_cur."!cursor_pos"(rx2739_pos)
    $P10 = rx2739_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2739_fail
    rx2739_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2739_pos = $P10."pos"()
  # rx pass
    rx2739_cur."!cursor_pass"(rx2739_pos, "infix:sym<lt>")
    if_null rx2739_debug, debug_1592
    rx2739_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2739_pos)
  debug_1592:
    .return (rx2739_cur)
  rx2739_restart:
.annotate 'line', 436
    if_null rx2739_debug, debug_1593
    rx2739_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1593:
  rx2739_fail:
    (rx2739_rep, rx2739_pos, $I10, $P10) = rx2739_cur."!mark_fail"(0)
    lt rx2739_pos, -1, rx2739_done
    eq rx2739_pos, -1, rx2739_fail
    jump $I10
  rx2739_done:
    rx2739_cur."!cursor_fail"()
    if_null rx2739_debug, debug_1594
    rx2739_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1594:
    .return (rx2739_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("380_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2743 = self."!PREFIX__!subrule"("O", "lt")
    new $P2744, "ResizablePMCArray"
    push $P2744, $P2743
    .return ($P2744)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("381_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2746_tgt
    .local int rx2746_pos
    .local int rx2746_off
    .local int rx2746_eos
    .local int rx2746_rep
    .local pmc rx2746_cur
    .local pmc rx2746_debug
    (rx2746_cur, rx2746_pos, rx2746_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2746_cur
    .local pmc match
    .lex "$/", match
    length rx2746_eos, rx2746_tgt
    gt rx2746_pos, rx2746_eos, rx2746_done
    set rx2746_off, 0
    lt rx2746_pos, 2, rx2746_start
    sub rx2746_off, rx2746_pos, 1
    substr rx2746_tgt, rx2746_tgt, rx2746_off
  rx2746_start:
    eq $I10, 1, rx2746_restart
    if_null rx2746_debug, debug_1595
    rx2746_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1595:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2747_done
    goto rxscan2747_scan
  rxscan2747_loop:
    (rx2746_pos) = rx2746_cur."from"()
    inc rx2746_pos
    rx2746_cur."!cursor_from"(rx2746_pos)
    ge rx2746_pos, rx2746_eos, rxscan2747_done
  rxscan2747_scan:
    set_addr $I10, rxscan2747_loop
    rx2746_cur."!mark_push"(0, rx2746_pos, $I10)
  rxscan2747_done:
.annotate 'line', 1121
  # rx subcapture "sym"
    set_addr $I10, rxcap_2748_fail
    rx2746_cur."!mark_push"(0, rx2746_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2746_pos, 2
    gt $I11, rx2746_eos, rx2746_fail
    sub $I11, rx2746_pos, rx2746_off
    substr $S10, rx2746_tgt, $I11, 2
    ne $S10, "gt", rx2746_fail
    add rx2746_pos, 2
    set_addr $I10, rxcap_2748_fail
    ($I12, $I11) = rx2746_cur."!mark_peek"($I10)
    rx2746_cur."!cursor_pos"($I11)
    ($P10) = rx2746_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2746_pos, "")
    rx2746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2748_done
  rxcap_2748_fail:
    goto rx2746_fail
  rxcap_2748_done:
  # rx subrule "O" subtype=capture negate=
    rx2746_cur."!cursor_pos"(rx2746_pos)
    $P10 = rx2746_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2746_fail
    rx2746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2746_pos = $P10."pos"()
  # rx pass
    rx2746_cur."!cursor_pass"(rx2746_pos, "infix:sym<gt>")
    if_null rx2746_debug, debug_1596
    rx2746_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2746_pos)
  debug_1596:
    .return (rx2746_cur)
  rx2746_restart:
.annotate 'line', 436
    if_null rx2746_debug, debug_1597
    rx2746_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1597:
  rx2746_fail:
    (rx2746_rep, rx2746_pos, $I10, $P10) = rx2746_cur."!mark_fail"(0)
    lt rx2746_pos, -1, rx2746_done
    eq rx2746_pos, -1, rx2746_fail
    jump $I10
  rx2746_done:
    rx2746_cur."!cursor_fail"()
    if_null rx2746_debug, debug_1598
    rx2746_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1598:
    .return (rx2746_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("382_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2750 = self."!PREFIX__!subrule"("O", "gt")
    new $P2751, "ResizablePMCArray"
    push $P2751, $P2750
    .return ($P2751)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("383_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2753_tgt
    .local int rx2753_pos
    .local int rx2753_off
    .local int rx2753_eos
    .local int rx2753_rep
    .local pmc rx2753_cur
    .local pmc rx2753_debug
    (rx2753_cur, rx2753_pos, rx2753_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2753_cur
    .local pmc match
    .lex "$/", match
    length rx2753_eos, rx2753_tgt
    gt rx2753_pos, rx2753_eos, rx2753_done
    set rx2753_off, 0
    lt rx2753_pos, 2, rx2753_start
    sub rx2753_off, rx2753_pos, 1
    substr rx2753_tgt, rx2753_tgt, rx2753_off
  rx2753_start:
    eq $I10, 1, rx2753_restart
    if_null rx2753_debug, debug_1599
    rx2753_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1599:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2754_done
    goto rxscan2754_scan
  rxscan2754_loop:
    (rx2753_pos) = rx2753_cur."from"()
    inc rx2753_pos
    rx2753_cur."!cursor_from"(rx2753_pos)
    ge rx2753_pos, rx2753_eos, rxscan2754_done
  rxscan2754_scan:
    set_addr $I10, rxscan2754_loop
    rx2753_cur."!mark_push"(0, rx2753_pos, $I10)
  rxscan2754_done:
.annotate 'line', 1122
  # rx subcapture "sym"
    set_addr $I10, rxcap_2755_fail
    rx2753_cur."!mark_push"(0, rx2753_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2753_pos, 3
    gt $I11, rx2753_eos, rx2753_fail
    sub $I11, rx2753_pos, rx2753_off
    substr $S10, rx2753_tgt, $I11, 3
    ne $S10, "=:=", rx2753_fail
    add rx2753_pos, 3
    set_addr $I10, rxcap_2755_fail
    ($I12, $I11) = rx2753_cur."!mark_peek"($I10)
    rx2753_cur."!cursor_pos"($I11)
    ($P10) = rx2753_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2753_pos, "")
    rx2753_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2755_done
  rxcap_2755_fail:
    goto rx2753_fail
  rxcap_2755_done:
  # rx subrule "O" subtype=capture negate=
    rx2753_cur."!cursor_pos"(rx2753_pos)
    $P10 = rx2753_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2753_fail
    rx2753_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2753_pos = $P10."pos"()
  # rx pass
    rx2753_cur."!cursor_pass"(rx2753_pos, "infix:sym<=:=>")
    if_null rx2753_debug, debug_1600
    rx2753_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2753_pos)
  debug_1600:
    .return (rx2753_cur)
  rx2753_restart:
.annotate 'line', 436
    if_null rx2753_debug, debug_1601
    rx2753_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1601:
  rx2753_fail:
    (rx2753_rep, rx2753_pos, $I10, $P10) = rx2753_cur."!mark_fail"(0)
    lt rx2753_pos, -1, rx2753_done
    eq rx2753_pos, -1, rx2753_fail
    jump $I10
  rx2753_done:
    rx2753_cur."!cursor_fail"()
    if_null rx2753_debug, debug_1602
    rx2753_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1602:
    .return (rx2753_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("384_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2757 = self."!PREFIX__!subrule"("O", "=:=")
    new $P2758, "ResizablePMCArray"
    push $P2758, $P2757
    .return ($P2758)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("385_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2760_tgt
    .local int rx2760_pos
    .local int rx2760_off
    .local int rx2760_eos
    .local int rx2760_rep
    .local pmc rx2760_cur
    .local pmc rx2760_debug
    (rx2760_cur, rx2760_pos, rx2760_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2760_cur
    .local pmc match
    .lex "$/", match
    length rx2760_eos, rx2760_tgt
    gt rx2760_pos, rx2760_eos, rx2760_done
    set rx2760_off, 0
    lt rx2760_pos, 2, rx2760_start
    sub rx2760_off, rx2760_pos, 1
    substr rx2760_tgt, rx2760_tgt, rx2760_off
  rx2760_start:
    eq $I10, 1, rx2760_restart
    if_null rx2760_debug, debug_1603
    rx2760_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1603:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2761_done
    goto rxscan2761_scan
  rxscan2761_loop:
    (rx2760_pos) = rx2760_cur."from"()
    inc rx2760_pos
    rx2760_cur."!cursor_from"(rx2760_pos)
    ge rx2760_pos, rx2760_eos, rxscan2761_done
  rxscan2761_scan:
    set_addr $I10, rxscan2761_loop
    rx2760_cur."!mark_push"(0, rx2760_pos, $I10)
  rxscan2761_done:
.annotate 'line', 1123
  # rx subcapture "sym"
    set_addr $I10, rxcap_2762_fail
    rx2760_cur."!mark_push"(0, rx2760_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2760_pos, 2
    gt $I11, rx2760_eos, rx2760_fail
    sub $I11, rx2760_pos, rx2760_off
    substr $S10, rx2760_tgt, $I11, 2
    ne $S10, "~~", rx2760_fail
    add rx2760_pos, 2
    set_addr $I10, rxcap_2762_fail
    ($I12, $I11) = rx2760_cur."!mark_peek"($I10)
    rx2760_cur."!cursor_pos"($I11)
    ($P10) = rx2760_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2760_pos, "")
    rx2760_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2762_done
  rxcap_2762_fail:
    goto rx2760_fail
  rxcap_2762_done:
  # rx subrule "O" subtype=capture negate=
    rx2760_cur."!cursor_pos"(rx2760_pos)
    $P10 = rx2760_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2760_fail
    rx2760_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2760_pos = $P10."pos"()
  # rx pass
    rx2760_cur."!cursor_pass"(rx2760_pos, "infix:sym<~~>")
    if_null rx2760_debug, debug_1604
    rx2760_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2760_pos)
  debug_1604:
    .return (rx2760_cur)
  rx2760_restart:
.annotate 'line', 436
    if_null rx2760_debug, debug_1605
    rx2760_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1605:
  rx2760_fail:
    (rx2760_rep, rx2760_pos, $I10, $P10) = rx2760_cur."!mark_fail"(0)
    lt rx2760_pos, -1, rx2760_done
    eq rx2760_pos, -1, rx2760_fail
    jump $I10
  rx2760_done:
    rx2760_cur."!cursor_fail"()
    if_null rx2760_debug, debug_1606
    rx2760_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1606:
    .return (rx2760_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("386_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2764 = self."!PREFIX__!subrule"("O", "~~")
    new $P2765, "ResizablePMCArray"
    push $P2765, $P2764
    .return ($P2765)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("387_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2767_tgt
    .local int rx2767_pos
    .local int rx2767_off
    .local int rx2767_eos
    .local int rx2767_rep
    .local pmc rx2767_cur
    .local pmc rx2767_debug
    (rx2767_cur, rx2767_pos, rx2767_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2767_cur
    .local pmc match
    .lex "$/", match
    length rx2767_eos, rx2767_tgt
    gt rx2767_pos, rx2767_eos, rx2767_done
    set rx2767_off, 0
    lt rx2767_pos, 2, rx2767_start
    sub rx2767_off, rx2767_pos, 1
    substr rx2767_tgt, rx2767_tgt, rx2767_off
  rx2767_start:
    eq $I10, 1, rx2767_restart
    if_null rx2767_debug, debug_1607
    rx2767_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1607:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2768_done
    goto rxscan2768_scan
  rxscan2768_loop:
    (rx2767_pos) = rx2767_cur."from"()
    inc rx2767_pos
    rx2767_cur."!cursor_from"(rx2767_pos)
    ge rx2767_pos, rx2767_eos, rxscan2768_done
  rxscan2768_scan:
    set_addr $I10, rxscan2768_loop
    rx2767_cur."!mark_push"(0, rx2767_pos, $I10)
  rxscan2768_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2769_fail
    rx2767_cur."!mark_push"(0, rx2767_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2767_pos, 2
    gt $I11, rx2767_eos, rx2767_fail
    sub $I11, rx2767_pos, rx2767_off
    substr $S10, rx2767_tgt, $I11, 2
    ne $S10, "&&", rx2767_fail
    add rx2767_pos, 2
    set_addr $I10, rxcap_2769_fail
    ($I12, $I11) = rx2767_cur."!mark_peek"($I10)
    rx2767_cur."!cursor_pos"($I11)
    ($P10) = rx2767_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2767_pos, "")
    rx2767_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2769_done
  rxcap_2769_fail:
    goto rx2767_fail
  rxcap_2769_done:
  # rx subrule "O" subtype=capture negate=
    rx2767_cur."!cursor_pos"(rx2767_pos)
    $P10 = rx2767_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2767_fail
    rx2767_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2767_pos = $P10."pos"()
  # rx pass
    rx2767_cur."!cursor_pass"(rx2767_pos, "infix:sym<&&>")
    if_null rx2767_debug, debug_1608
    rx2767_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2767_pos)
  debug_1608:
    .return (rx2767_cur)
  rx2767_restart:
.annotate 'line', 436
    if_null rx2767_debug, debug_1609
    rx2767_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1609:
  rx2767_fail:
    (rx2767_rep, rx2767_pos, $I10, $P10) = rx2767_cur."!mark_fail"(0)
    lt rx2767_pos, -1, rx2767_done
    eq rx2767_pos, -1, rx2767_fail
    jump $I10
  rx2767_done:
    rx2767_cur."!cursor_fail"()
    if_null rx2767_debug, debug_1610
    rx2767_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1610:
    .return (rx2767_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("388_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2771 = self."!PREFIX__!subrule"("O", "&&")
    new $P2772, "ResizablePMCArray"
    push $P2772, $P2771
    .return ($P2772)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("389_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2774_tgt
    .local int rx2774_pos
    .local int rx2774_off
    .local int rx2774_eos
    .local int rx2774_rep
    .local pmc rx2774_cur
    .local pmc rx2774_debug
    (rx2774_cur, rx2774_pos, rx2774_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2774_cur
    .local pmc match
    .lex "$/", match
    length rx2774_eos, rx2774_tgt
    gt rx2774_pos, rx2774_eos, rx2774_done
    set rx2774_off, 0
    lt rx2774_pos, 2, rx2774_start
    sub rx2774_off, rx2774_pos, 1
    substr rx2774_tgt, rx2774_tgt, rx2774_off
  rx2774_start:
    eq $I10, 1, rx2774_restart
    if_null rx2774_debug, debug_1611
    rx2774_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1611:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2775_done
    goto rxscan2775_scan
  rxscan2775_loop:
    (rx2774_pos) = rx2774_cur."from"()
    inc rx2774_pos
    rx2774_cur."!cursor_from"(rx2774_pos)
    ge rx2774_pos, rx2774_eos, rxscan2775_done
  rxscan2775_scan:
    set_addr $I10, rxscan2775_loop
    rx2774_cur."!mark_push"(0, rx2774_pos, $I10)
  rxscan2775_done:
.annotate 'line', 1127
  # rx subcapture "sym"
    set_addr $I10, rxcap_2776_fail
    rx2774_cur."!mark_push"(0, rx2774_pos, $I10)
  # rx literal  "||"
    add $I11, rx2774_pos, 2
    gt $I11, rx2774_eos, rx2774_fail
    sub $I11, rx2774_pos, rx2774_off
    substr $S10, rx2774_tgt, $I11, 2
    ne $S10, "||", rx2774_fail
    add rx2774_pos, 2
    set_addr $I10, rxcap_2776_fail
    ($I12, $I11) = rx2774_cur."!mark_peek"($I10)
    rx2774_cur."!cursor_pos"($I11)
    ($P10) = rx2774_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2774_pos, "")
    rx2774_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2776_done
  rxcap_2776_fail:
    goto rx2774_fail
  rxcap_2776_done:
  # rx subrule "O" subtype=capture negate=
    rx2774_cur."!cursor_pos"(rx2774_pos)
    $P10 = rx2774_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2774_fail
    rx2774_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2774_pos = $P10."pos"()
  # rx pass
    rx2774_cur."!cursor_pass"(rx2774_pos, "infix:sym<||>")
    if_null rx2774_debug, debug_1612
    rx2774_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2774_pos)
  debug_1612:
    .return (rx2774_cur)
  rx2774_restart:
.annotate 'line', 436
    if_null rx2774_debug, debug_1613
    rx2774_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1613:
  rx2774_fail:
    (rx2774_rep, rx2774_pos, $I10, $P10) = rx2774_cur."!mark_fail"(0)
    lt rx2774_pos, -1, rx2774_done
    eq rx2774_pos, -1, rx2774_fail
    jump $I10
  rx2774_done:
    rx2774_cur."!cursor_fail"()
    if_null rx2774_debug, debug_1614
    rx2774_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1614:
    .return (rx2774_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("390_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2778 = self."!PREFIX__!subrule"("O", "||")
    new $P2779, "ResizablePMCArray"
    push $P2779, $P2778
    .return ($P2779)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("391_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2781_tgt
    .local int rx2781_pos
    .local int rx2781_off
    .local int rx2781_eos
    .local int rx2781_rep
    .local pmc rx2781_cur
    .local pmc rx2781_debug
    (rx2781_cur, rx2781_pos, rx2781_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2781_cur
    .local pmc match
    .lex "$/", match
    length rx2781_eos, rx2781_tgt
    gt rx2781_pos, rx2781_eos, rx2781_done
    set rx2781_off, 0
    lt rx2781_pos, 2, rx2781_start
    sub rx2781_off, rx2781_pos, 1
    substr rx2781_tgt, rx2781_tgt, rx2781_off
  rx2781_start:
    eq $I10, 1, rx2781_restart
    if_null rx2781_debug, debug_1615
    rx2781_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1615:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2782_done
    goto rxscan2782_scan
  rxscan2782_loop:
    (rx2781_pos) = rx2781_cur."from"()
    inc rx2781_pos
    rx2781_cur."!cursor_from"(rx2781_pos)
    ge rx2781_pos, rx2781_eos, rxscan2782_done
  rxscan2782_scan:
    set_addr $I10, rxscan2782_loop
    rx2781_cur."!mark_push"(0, rx2781_pos, $I10)
  rxscan2782_done:
.annotate 'line', 1128
  # rx subcapture "sym"
    set_addr $I10, rxcap_2783_fail
    rx2781_cur."!mark_push"(0, rx2781_pos, $I10)
  # rx literal  "//"
    add $I11, rx2781_pos, 2
    gt $I11, rx2781_eos, rx2781_fail
    sub $I11, rx2781_pos, rx2781_off
    substr $S10, rx2781_tgt, $I11, 2
    ne $S10, "//", rx2781_fail
    add rx2781_pos, 2
    set_addr $I10, rxcap_2783_fail
    ($I12, $I11) = rx2781_cur."!mark_peek"($I10)
    rx2781_cur."!cursor_pos"($I11)
    ($P10) = rx2781_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2781_pos, "")
    rx2781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2783_done
  rxcap_2783_fail:
    goto rx2781_fail
  rxcap_2783_done:
  # rx subrule "O" subtype=capture negate=
    rx2781_cur."!cursor_pos"(rx2781_pos)
    $P10 = rx2781_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2781_fail
    rx2781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2781_pos = $P10."pos"()
  # rx pass
    rx2781_cur."!cursor_pass"(rx2781_pos, "infix:sym<//>")
    if_null rx2781_debug, debug_1616
    rx2781_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2781_pos)
  debug_1616:
    .return (rx2781_cur)
  rx2781_restart:
.annotate 'line', 436
    if_null rx2781_debug, debug_1617
    rx2781_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1617:
  rx2781_fail:
    (rx2781_rep, rx2781_pos, $I10, $P10) = rx2781_cur."!mark_fail"(0)
    lt rx2781_pos, -1, rx2781_done
    eq rx2781_pos, -1, rx2781_fail
    jump $I10
  rx2781_done:
    rx2781_cur."!cursor_fail"()
    if_null rx2781_debug, debug_1618
    rx2781_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1618:
    .return (rx2781_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("392_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2785 = self."!PREFIX__!subrule"("O", "//")
    new $P2786, "ResizablePMCArray"
    push $P2786, $P2785
    .return ($P2786)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("393_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2788_tgt
    .local int rx2788_pos
    .local int rx2788_off
    .local int rx2788_eos
    .local int rx2788_rep
    .local pmc rx2788_cur
    .local pmc rx2788_debug
    (rx2788_cur, rx2788_pos, rx2788_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2788_cur
    .local pmc match
    .lex "$/", match
    length rx2788_eos, rx2788_tgt
    gt rx2788_pos, rx2788_eos, rx2788_done
    set rx2788_off, 0
    lt rx2788_pos, 2, rx2788_start
    sub rx2788_off, rx2788_pos, 1
    substr rx2788_tgt, rx2788_tgt, rx2788_off
  rx2788_start:
    eq $I10, 1, rx2788_restart
    if_null rx2788_debug, debug_1619
    rx2788_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1619:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2789_done
    goto rxscan2789_scan
  rxscan2789_loop:
    (rx2788_pos) = rx2788_cur."from"()
    inc rx2788_pos
    rx2788_cur."!cursor_from"(rx2788_pos)
    ge rx2788_pos, rx2788_eos, rxscan2789_done
  rxscan2789_scan:
    set_addr $I10, rxscan2789_loop
    rx2788_cur."!mark_push"(0, rx2788_pos, $I10)
  rxscan2789_done:
.annotate 'line', 1131
  # rx literal  "??"
    add $I11, rx2788_pos, 2
    gt $I11, rx2788_eos, rx2788_fail
    sub $I11, rx2788_pos, rx2788_off
    substr $S10, rx2788_tgt, $I11, 2
    ne $S10, "??", rx2788_fail
    add rx2788_pos, 2
.annotate 'line', 1132
  # rx subrule "ws" subtype=method negate=
    rx2788_cur."!cursor_pos"(rx2788_pos)
    $P10 = rx2788_cur."ws"()
    unless $P10, rx2788_fail
    rx2788_pos = $P10."pos"()
.annotate 'line', 1133
  # rx subrule "EXPR" subtype=capture negate=
    rx2788_cur."!cursor_pos"(rx2788_pos)
    $P10 = rx2788_cur."EXPR"("i=")
    unless $P10, rx2788_fail
    rx2788_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2788_pos = $P10."pos"()
.annotate 'line', 1134
  # rx literal  "!!"
    add $I11, rx2788_pos, 2
    gt $I11, rx2788_eos, rx2788_fail
    sub $I11, rx2788_pos, rx2788_off
    substr $S10, rx2788_tgt, $I11, 2
    ne $S10, "!!", rx2788_fail
    add rx2788_pos, 2
.annotate 'line', 1135
  # rx subrule "O" subtype=capture negate=
    rx2788_cur."!cursor_pos"(rx2788_pos)
    $P10 = rx2788_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2788_fail
    rx2788_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2788_pos = $P10."pos"()
.annotate 'line', 1130
  # rx pass
    rx2788_cur."!cursor_pass"(rx2788_pos, "infix:sym<?? !!>")
    if_null rx2788_debug, debug_1620
    rx2788_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2788_pos)
  debug_1620:
    .return (rx2788_cur)
  rx2788_restart:
.annotate 'line', 436
    if_null rx2788_debug, debug_1621
    rx2788_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1621:
  rx2788_fail:
    (rx2788_rep, rx2788_pos, $I10, $P10) = rx2788_cur."!mark_fail"(0)
    lt rx2788_pos, -1, rx2788_done
    eq rx2788_pos, -1, rx2788_fail
    jump $I10
  rx2788_done:
    rx2788_cur."!cursor_fail"()
    if_null rx2788_debug, debug_1622
    rx2788_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1622:
    .return (rx2788_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("394_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2791 = self."!PREFIX__!subrule"("ws", "??")
    new $P2792, "ResizablePMCArray"
    push $P2792, $P2791
    .return ($P2792)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("395_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2794_tgt
    .local int rx2794_pos
    .local int rx2794_off
    .local int rx2794_eos
    .local int rx2794_rep
    .local pmc rx2794_cur
    .local pmc rx2794_debug
    (rx2794_cur, rx2794_pos, rx2794_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2794_cur
    .local pmc match
    .lex "$/", match
    length rx2794_eos, rx2794_tgt
    gt rx2794_pos, rx2794_eos, rx2794_done
    set rx2794_off, 0
    lt rx2794_pos, 2, rx2794_start
    sub rx2794_off, rx2794_pos, 1
    substr rx2794_tgt, rx2794_tgt, rx2794_off
  rx2794_start:
    eq $I10, 1, rx2794_restart
    if_null rx2794_debug, debug_1623
    rx2794_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2795_done
    goto rxscan2795_scan
  rxscan2795_loop:
    (rx2794_pos) = rx2794_cur."from"()
    inc rx2794_pos
    rx2794_cur."!cursor_from"(rx2794_pos)
    ge rx2794_pos, rx2794_eos, rxscan2795_done
  rxscan2795_scan:
    set_addr $I10, rxscan2795_loop
    rx2794_cur."!mark_push"(0, rx2794_pos, $I10)
  rxscan2795_done:
.annotate 'line', 1139
  # rx subcapture "sym"
    set_addr $I10, rxcap_2796_fail
    rx2794_cur."!mark_push"(0, rx2794_pos, $I10)
  # rx literal  "="
    add $I11, rx2794_pos, 1
    gt $I11, rx2794_eos, rx2794_fail
    sub $I11, rx2794_pos, rx2794_off
    ord $I11, rx2794_tgt, $I11
    ne $I11, 61, rx2794_fail
    add rx2794_pos, 1
    set_addr $I10, rxcap_2796_fail
    ($I12, $I11) = rx2794_cur."!mark_peek"($I10)
    rx2794_cur."!cursor_pos"($I11)
    ($P10) = rx2794_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2794_pos, "")
    rx2794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2796_done
  rxcap_2796_fail:
    goto rx2794_fail
  rxcap_2796_done:
  # rx subrule "panic" subtype=method negate=
    rx2794_cur."!cursor_pos"(rx2794_pos)
    $P10 = rx2794_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2794_fail
    rx2794_pos = $P10."pos"()
.annotate 'line', 1138
  # rx pass
    rx2794_cur."!cursor_pass"(rx2794_pos, "infix:sym<=>")
    if_null rx2794_debug, debug_1624
    rx2794_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2794_pos)
  debug_1624:
    .return (rx2794_cur)
  rx2794_restart:
.annotate 'line', 436
    if_null rx2794_debug, debug_1625
    rx2794_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1625:
  rx2794_fail:
    (rx2794_rep, rx2794_pos, $I10, $P10) = rx2794_cur."!mark_fail"(0)
    lt rx2794_pos, -1, rx2794_done
    eq rx2794_pos, -1, rx2794_fail
    jump $I10
  rx2794_done:
    rx2794_cur."!cursor_fail"()
    if_null rx2794_debug, debug_1626
    rx2794_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1626:
    .return (rx2794_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("396_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2798 = self."!PREFIX__!subrule"("panic", "=")
    new $P2799, "ResizablePMCArray"
    push $P2799, $P2798
    .return ($P2799)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("397_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2801_tgt
    .local int rx2801_pos
    .local int rx2801_off
    .local int rx2801_eos
    .local int rx2801_rep
    .local pmc rx2801_cur
    .local pmc rx2801_debug
    (rx2801_cur, rx2801_pos, rx2801_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2801_cur
    .local pmc match
    .lex "$/", match
    length rx2801_eos, rx2801_tgt
    gt rx2801_pos, rx2801_eos, rx2801_done
    set rx2801_off, 0
    lt rx2801_pos, 2, rx2801_start
    sub rx2801_off, rx2801_pos, 1
    substr rx2801_tgt, rx2801_tgt, rx2801_off
  rx2801_start:
    eq $I10, 1, rx2801_restart
    if_null rx2801_debug, debug_1627
    rx2801_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2802_done
    goto rxscan2802_scan
  rxscan2802_loop:
    (rx2801_pos) = rx2801_cur."from"()
    inc rx2801_pos
    rx2801_cur."!cursor_from"(rx2801_pos)
    ge rx2801_pos, rx2801_eos, rxscan2802_done
  rxscan2802_scan:
    set_addr $I10, rxscan2802_loop
    rx2801_cur."!mark_push"(0, rx2801_pos, $I10)
  rxscan2802_done:
.annotate 'line', 1141
  # rx subcapture "sym"
    set_addr $I10, rxcap_2803_fail
    rx2801_cur."!mark_push"(0, rx2801_pos, $I10)
  # rx literal  ":="
    add $I11, rx2801_pos, 2
    gt $I11, rx2801_eos, rx2801_fail
    sub $I11, rx2801_pos, rx2801_off
    substr $S10, rx2801_tgt, $I11, 2
    ne $S10, ":=", rx2801_fail
    add rx2801_pos, 2
    set_addr $I10, rxcap_2803_fail
    ($I12, $I11) = rx2801_cur."!mark_peek"($I10)
    rx2801_cur."!cursor_pos"($I11)
    ($P10) = rx2801_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2801_pos, "")
    rx2801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2803_done
  rxcap_2803_fail:
    goto rx2801_fail
  rxcap_2803_done:
  # rx subrule "O" subtype=capture negate=
    rx2801_cur."!cursor_pos"(rx2801_pos)
    $P10 = rx2801_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2801_fail
    rx2801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2801_pos = $P10."pos"()
  # rx pass
    rx2801_cur."!cursor_pass"(rx2801_pos, "infix:sym<:=>")
    if_null rx2801_debug, debug_1628
    rx2801_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2801_pos)
  debug_1628:
    .return (rx2801_cur)
  rx2801_restart:
.annotate 'line', 436
    if_null rx2801_debug, debug_1629
    rx2801_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1629:
  rx2801_fail:
    (rx2801_rep, rx2801_pos, $I10, $P10) = rx2801_cur."!mark_fail"(0)
    lt rx2801_pos, -1, rx2801_done
    eq rx2801_pos, -1, rx2801_fail
    jump $I10
  rx2801_done:
    rx2801_cur."!cursor_fail"()
    if_null rx2801_debug, debug_1630
    rx2801_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1630:
    .return (rx2801_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("398_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2805 = self."!PREFIX__!subrule"("O", ":=")
    new $P2806, "ResizablePMCArray"
    push $P2806, $P2805
    .return ($P2806)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("399_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2808_tgt
    .local int rx2808_pos
    .local int rx2808_off
    .local int rx2808_eos
    .local int rx2808_rep
    .local pmc rx2808_cur
    .local pmc rx2808_debug
    (rx2808_cur, rx2808_pos, rx2808_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2808_cur
    .local pmc match
    .lex "$/", match
    length rx2808_eos, rx2808_tgt
    gt rx2808_pos, rx2808_eos, rx2808_done
    set rx2808_off, 0
    lt rx2808_pos, 2, rx2808_start
    sub rx2808_off, rx2808_pos, 1
    substr rx2808_tgt, rx2808_tgt, rx2808_off
  rx2808_start:
    eq $I10, 1, rx2808_restart
    if_null rx2808_debug, debug_1631
    rx2808_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2809_done
    goto rxscan2809_scan
  rxscan2809_loop:
    (rx2808_pos) = rx2808_cur."from"()
    inc rx2808_pos
    rx2808_cur."!cursor_from"(rx2808_pos)
    ge rx2808_pos, rx2808_eos, rxscan2809_done
  rxscan2809_scan:
    set_addr $I10, rxscan2809_loop
    rx2808_cur."!mark_push"(0, rx2808_pos, $I10)
  rxscan2809_done:
.annotate 'line', 1142
  # rx subcapture "sym"
    set_addr $I10, rxcap_2810_fail
    rx2808_cur."!mark_push"(0, rx2808_pos, $I10)
  # rx literal  "::="
    add $I11, rx2808_pos, 3
    gt $I11, rx2808_eos, rx2808_fail
    sub $I11, rx2808_pos, rx2808_off
    substr $S10, rx2808_tgt, $I11, 3
    ne $S10, "::=", rx2808_fail
    add rx2808_pos, 3
    set_addr $I10, rxcap_2810_fail
    ($I12, $I11) = rx2808_cur."!mark_peek"($I10)
    rx2808_cur."!cursor_pos"($I11)
    ($P10) = rx2808_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2808_pos, "")
    rx2808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2810_done
  rxcap_2810_fail:
    goto rx2808_fail
  rxcap_2810_done:
  # rx subrule "O" subtype=capture negate=
    rx2808_cur."!cursor_pos"(rx2808_pos)
    $P10 = rx2808_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2808_fail
    rx2808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2808_pos = $P10."pos"()
  # rx pass
    rx2808_cur."!cursor_pass"(rx2808_pos, "infix:sym<::=>")
    if_null rx2808_debug, debug_1632
    rx2808_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2808_pos)
  debug_1632:
    .return (rx2808_cur)
  rx2808_restart:
.annotate 'line', 436
    if_null rx2808_debug, debug_1633
    rx2808_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1633:
  rx2808_fail:
    (rx2808_rep, rx2808_pos, $I10, $P10) = rx2808_cur."!mark_fail"(0)
    lt rx2808_pos, -1, rx2808_done
    eq rx2808_pos, -1, rx2808_fail
    jump $I10
  rx2808_done:
    rx2808_cur."!cursor_fail"()
    if_null rx2808_debug, debug_1634
    rx2808_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1634:
    .return (rx2808_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("400_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2812 = self."!PREFIX__!subrule"("O", "::=")
    new $P2813, "ResizablePMCArray"
    push $P2813, $P2812
    .return ($P2813)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("401_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2815_tgt
    .local int rx2815_pos
    .local int rx2815_off
    .local int rx2815_eos
    .local int rx2815_rep
    .local pmc rx2815_cur
    .local pmc rx2815_debug
    (rx2815_cur, rx2815_pos, rx2815_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2815_cur
    .local pmc match
    .lex "$/", match
    length rx2815_eos, rx2815_tgt
    gt rx2815_pos, rx2815_eos, rx2815_done
    set rx2815_off, 0
    lt rx2815_pos, 2, rx2815_start
    sub rx2815_off, rx2815_pos, 1
    substr rx2815_tgt, rx2815_tgt, rx2815_off
  rx2815_start:
    eq $I10, 1, rx2815_restart
    if_null rx2815_debug, debug_1635
    rx2815_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2816_done
    goto rxscan2816_scan
  rxscan2816_loop:
    (rx2815_pos) = rx2815_cur."from"()
    inc rx2815_pos
    rx2815_cur."!cursor_from"(rx2815_pos)
    ge rx2815_pos, rx2815_eos, rxscan2816_done
  rxscan2816_scan:
    set_addr $I10, rxscan2816_loop
    rx2815_cur."!mark_push"(0, rx2815_pos, $I10)
  rxscan2816_done:
.annotate 'line', 1144
  # rx subcapture "sym"
    set_addr $I10, rxcap_2817_fail
    rx2815_cur."!mark_push"(0, rx2815_pos, $I10)
  # rx literal  ","
    add $I11, rx2815_pos, 1
    gt $I11, rx2815_eos, rx2815_fail
    sub $I11, rx2815_pos, rx2815_off
    ord $I11, rx2815_tgt, $I11
    ne $I11, 44, rx2815_fail
    add rx2815_pos, 1
    set_addr $I10, rxcap_2817_fail
    ($I12, $I11) = rx2815_cur."!mark_peek"($I10)
    rx2815_cur."!cursor_pos"($I11)
    ($P10) = rx2815_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2815_pos, "")
    rx2815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2817_done
  rxcap_2817_fail:
    goto rx2815_fail
  rxcap_2817_done:
  # rx subrule "O" subtype=capture negate=
    rx2815_cur."!cursor_pos"(rx2815_pos)
    $P10 = rx2815_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2815_fail
    rx2815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2815_pos = $P10."pos"()
  # rx pass
    rx2815_cur."!cursor_pass"(rx2815_pos, "infix:sym<,>")
    if_null rx2815_debug, debug_1636
    rx2815_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2815_pos)
  debug_1636:
    .return (rx2815_cur)
  rx2815_restart:
.annotate 'line', 436
    if_null rx2815_debug, debug_1637
    rx2815_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1637:
  rx2815_fail:
    (rx2815_rep, rx2815_pos, $I10, $P10) = rx2815_cur."!mark_fail"(0)
    lt rx2815_pos, -1, rx2815_done
    eq rx2815_pos, -1, rx2815_fail
    jump $I10
  rx2815_done:
    rx2815_cur."!cursor_fail"()
    if_null rx2815_debug, debug_1638
    rx2815_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1638:
    .return (rx2815_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("402_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    $P2819 = self."!PREFIX__!subrule"("O", ",")
    new $P2820, "ResizablePMCArray"
    push $P2820, $P2819
    .return ($P2820)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("403_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .const 'Sub' $P2828 = "404_1306916577.75068" 
    capture_lex $P2828
    .local string rx2822_tgt
    .local int rx2822_pos
    .local int rx2822_off
    .local int rx2822_eos
    .local int rx2822_rep
    .local pmc rx2822_cur
    .local pmc rx2822_debug
    (rx2822_cur, rx2822_pos, rx2822_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2822_cur
    .local pmc match
    .lex "$/", match
    length rx2822_eos, rx2822_tgt
    gt rx2822_pos, rx2822_eos, rx2822_done
    set rx2822_off, 0
    lt rx2822_pos, 2, rx2822_start
    sub rx2822_off, rx2822_pos, 1
    substr rx2822_tgt, rx2822_tgt, rx2822_off
  rx2822_start:
    eq $I10, 1, rx2822_restart
    if_null rx2822_debug, debug_1639
    rx2822_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1639:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2823_done
    goto rxscan2823_scan
  rxscan2823_loop:
    (rx2822_pos) = rx2822_cur."from"()
    inc rx2822_pos
    rx2822_cur."!cursor_from"(rx2822_pos)
    ge rx2822_pos, rx2822_eos, rxscan2823_done
  rxscan2823_scan:
    set_addr $I10, rxscan2823_loop
    rx2822_cur."!mark_push"(0, rx2822_pos, $I10)
  rxscan2823_done:
.annotate 'line', 1146
  # rx subcapture "sym"
    set_addr $I10, rxcap_2824_fail
    rx2822_cur."!mark_push"(0, rx2822_pos, $I10)
  # rx literal  "return"
    add $I11, rx2822_pos, 6
    gt $I11, rx2822_eos, rx2822_fail
    sub $I11, rx2822_pos, rx2822_off
    substr $S10, rx2822_tgt, $I11, 6
    ne $S10, "return", rx2822_fail
    add rx2822_pos, 6
    set_addr $I10, rxcap_2824_fail
    ($I12, $I11) = rx2822_cur."!mark_peek"($I10)
    rx2822_cur."!cursor_pos"($I11)
    ($P10) = rx2822_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2822_pos, "")
    rx2822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2824_done
  rxcap_2824_fail:
    goto rx2822_fail
  rxcap_2824_done:
  # rx charclass s
    ge rx2822_pos, rx2822_eos, rx2822_fail
    sub $I10, rx2822_pos, rx2822_off
    is_cclass $I11, 32, rx2822_tgt, $I10
    unless $I11, rx2822_fail
    inc rx2822_pos
  # rx subrule "O" subtype=capture negate=
    rx2822_cur."!cursor_pos"(rx2822_pos)
    $P10 = rx2822_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2822_fail
    rx2822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2822_pos = $P10."pos"()
    rx2822_cur."!cursor_pos"(rx2822_pos)
    find_lex $P2825, unicode:"$\x{a2}"
    $P2826 = $P2825."MATCH"()
    store_lex "$/", $P2826
    .const 'Sub' $P2828 = "404_1306916577.75068" 
    capture_lex $P2828
    $P2830 = $P2828()
  # rx pass
    rx2822_cur."!cursor_pass"(rx2822_pos, "prefix:sym<return>")
    if_null rx2822_debug, debug_1640
    rx2822_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2822_pos)
  debug_1640:
    .return (rx2822_cur)
  rx2822_restart:
.annotate 'line', 436
    if_null rx2822_debug, debug_1641
    rx2822_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1641:
  rx2822_fail:
    (rx2822_rep, rx2822_pos, $I10, $P10) = rx2822_cur."!mark_fail"(0)
    lt rx2822_pos, -1, rx2822_done
    eq rx2822_pos, -1, rx2822_fail
    jump $I10
  rx2822_done:
    rx2822_cur."!cursor_fail"()
    if_null rx2822_debug, debug_1642
    rx2822_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1642:
    .return (rx2822_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2827"  :anon :subid("404_1306916577.75068") :outer("403_1306916577.75068")
.annotate 'line', 1146
    new $P2829, "Integer"
    assign $P2829, 1
    store_dynamic_lex "$*RETURN_USED", $P2829
    .return ($P2829)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("405_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2832, "ResizablePMCArray"
    push $P2832, "return"
    .return ($P2832)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("406_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2834_tgt
    .local int rx2834_pos
    .local int rx2834_off
    .local int rx2834_eos
    .local int rx2834_rep
    .local pmc rx2834_cur
    .local pmc rx2834_debug
    (rx2834_cur, rx2834_pos, rx2834_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2834_cur
    .local pmc match
    .lex "$/", match
    length rx2834_eos, rx2834_tgt
    gt rx2834_pos, rx2834_eos, rx2834_done
    set rx2834_off, 0
    lt rx2834_pos, 2, rx2834_start
    sub rx2834_off, rx2834_pos, 1
    substr rx2834_tgt, rx2834_tgt, rx2834_off
  rx2834_start:
    eq $I10, 1, rx2834_restart
    if_null rx2834_debug, debug_1643
    rx2834_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2835_done
    goto rxscan2835_scan
  rxscan2835_loop:
    (rx2834_pos) = rx2834_cur."from"()
    inc rx2834_pos
    rx2834_cur."!cursor_from"(rx2834_pos)
    ge rx2834_pos, rx2834_eos, rxscan2835_done
  rxscan2835_scan:
    set_addr $I10, rxscan2835_loop
    rx2834_cur."!mark_push"(0, rx2834_pos, $I10)
  rxscan2835_done:
.annotate 'line', 1147
  # rx subcapture "sym"
    set_addr $I10, rxcap_2836_fail
    rx2834_cur."!mark_push"(0, rx2834_pos, $I10)
  # rx literal  "make"
    add $I11, rx2834_pos, 4
    gt $I11, rx2834_eos, rx2834_fail
    sub $I11, rx2834_pos, rx2834_off
    substr $S10, rx2834_tgt, $I11, 4
    ne $S10, "make", rx2834_fail
    add rx2834_pos, 4
    set_addr $I10, rxcap_2836_fail
    ($I12, $I11) = rx2834_cur."!mark_peek"($I10)
    rx2834_cur."!cursor_pos"($I11)
    ($P10) = rx2834_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2834_pos, "")
    rx2834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2836_done
  rxcap_2836_fail:
    goto rx2834_fail
  rxcap_2836_done:
  # rx charclass s
    ge rx2834_pos, rx2834_eos, rx2834_fail
    sub $I10, rx2834_pos, rx2834_off
    is_cclass $I11, 32, rx2834_tgt, $I10
    unless $I11, rx2834_fail
    inc rx2834_pos
  # rx subrule "O" subtype=capture negate=
    rx2834_cur."!cursor_pos"(rx2834_pos)
    $P10 = rx2834_cur."O"("%list_prefix")
    unless $P10, rx2834_fail
    rx2834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2834_pos = $P10."pos"()
  # rx pass
    rx2834_cur."!cursor_pass"(rx2834_pos, "prefix:sym<make>")
    if_null rx2834_debug, debug_1644
    rx2834_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2834_pos)
  debug_1644:
    .return (rx2834_cur)
  rx2834_restart:
.annotate 'line', 436
    if_null rx2834_debug, debug_1645
    rx2834_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1645:
  rx2834_fail:
    (rx2834_rep, rx2834_pos, $I10, $P10) = rx2834_cur."!mark_fail"(0)
    lt rx2834_pos, -1, rx2834_done
    eq rx2834_pos, -1, rx2834_fail
    jump $I10
  rx2834_done:
    rx2834_cur."!cursor_fail"()
    if_null rx2834_debug, debug_1646
    rx2834_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1646:
    .return (rx2834_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("407_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2838, "ResizablePMCArray"
    push $P2838, "make"
    .return ($P2838)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("408_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2840_tgt
    .local int rx2840_pos
    .local int rx2840_off
    .local int rx2840_eos
    .local int rx2840_rep
    .local pmc rx2840_cur
    .local pmc rx2840_debug
    (rx2840_cur, rx2840_pos, rx2840_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2840_cur
    .local pmc match
    .lex "$/", match
    length rx2840_eos, rx2840_tgt
    gt rx2840_pos, rx2840_eos, rx2840_done
    set rx2840_off, 0
    lt rx2840_pos, 2, rx2840_start
    sub rx2840_off, rx2840_pos, 1
    substr rx2840_tgt, rx2840_tgt, rx2840_off
  rx2840_start:
    eq $I10, 1, rx2840_restart
    if_null rx2840_debug, debug_1647
    rx2840_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1647:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2841_done
    goto rxscan2841_scan
  rxscan2841_loop:
    (rx2840_pos) = rx2840_cur."from"()
    inc rx2840_pos
    rx2840_cur."!cursor_from"(rx2840_pos)
    ge rx2840_pos, rx2840_eos, rxscan2841_done
  rxscan2841_scan:
    set_addr $I10, rxscan2841_loop
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
  rxscan2841_done:
.annotate 'line', 1148
  # rx subcapture "sym"
    set_addr $I10, rxcap_2842_fail
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
  # rx literal  "last"
    add $I11, rx2840_pos, 4
    gt $I11, rx2840_eos, rx2840_fail
    sub $I11, rx2840_pos, rx2840_off
    substr $S10, rx2840_tgt, $I11, 4
    ne $S10, "last", rx2840_fail
    add rx2840_pos, 4
    set_addr $I10, rxcap_2842_fail
    ($I12, $I11) = rx2840_cur."!mark_peek"($I10)
    rx2840_cur."!cursor_pos"($I11)
    ($P10) = rx2840_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2840_pos, "")
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2842_done
  rxcap_2842_fail:
    goto rx2840_fail
  rxcap_2842_done:
  # rx pass
    rx2840_cur."!cursor_pass"(rx2840_pos, "term:sym<last>")
    if_null rx2840_debug, debug_1648
    rx2840_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2840_pos)
  debug_1648:
    .return (rx2840_cur)
  rx2840_restart:
.annotate 'line', 436
    if_null rx2840_debug, debug_1649
    rx2840_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1649:
  rx2840_fail:
    (rx2840_rep, rx2840_pos, $I10, $P10) = rx2840_cur."!mark_fail"(0)
    lt rx2840_pos, -1, rx2840_done
    eq rx2840_pos, -1, rx2840_fail
    jump $I10
  rx2840_done:
    rx2840_cur."!cursor_fail"()
    if_null rx2840_debug, debug_1650
    rx2840_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1650:
    .return (rx2840_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("409_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2844, "ResizablePMCArray"
    push $P2844, "last"
    .return ($P2844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("410_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2846_tgt
    .local int rx2846_pos
    .local int rx2846_off
    .local int rx2846_eos
    .local int rx2846_rep
    .local pmc rx2846_cur
    .local pmc rx2846_debug
    (rx2846_cur, rx2846_pos, rx2846_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2846_cur
    .local pmc match
    .lex "$/", match
    length rx2846_eos, rx2846_tgt
    gt rx2846_pos, rx2846_eos, rx2846_done
    set rx2846_off, 0
    lt rx2846_pos, 2, rx2846_start
    sub rx2846_off, rx2846_pos, 1
    substr rx2846_tgt, rx2846_tgt, rx2846_off
  rx2846_start:
    eq $I10, 1, rx2846_restart
    if_null rx2846_debug, debug_1651
    rx2846_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1651:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2847_done
    goto rxscan2847_scan
  rxscan2847_loop:
    (rx2846_pos) = rx2846_cur."from"()
    inc rx2846_pos
    rx2846_cur."!cursor_from"(rx2846_pos)
    ge rx2846_pos, rx2846_eos, rxscan2847_done
  rxscan2847_scan:
    set_addr $I10, rxscan2847_loop
    rx2846_cur."!mark_push"(0, rx2846_pos, $I10)
  rxscan2847_done:
.annotate 'line', 1149
  # rx subcapture "sym"
    set_addr $I10, rxcap_2848_fail
    rx2846_cur."!mark_push"(0, rx2846_pos, $I10)
  # rx literal  "next"
    add $I11, rx2846_pos, 4
    gt $I11, rx2846_eos, rx2846_fail
    sub $I11, rx2846_pos, rx2846_off
    substr $S10, rx2846_tgt, $I11, 4
    ne $S10, "next", rx2846_fail
    add rx2846_pos, 4
    set_addr $I10, rxcap_2848_fail
    ($I12, $I11) = rx2846_cur."!mark_peek"($I10)
    rx2846_cur."!cursor_pos"($I11)
    ($P10) = rx2846_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2846_pos, "")
    rx2846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2848_done
  rxcap_2848_fail:
    goto rx2846_fail
  rxcap_2848_done:
  # rx pass
    rx2846_cur."!cursor_pass"(rx2846_pos, "term:sym<next>")
    if_null rx2846_debug, debug_1652
    rx2846_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2846_pos)
  debug_1652:
    .return (rx2846_cur)
  rx2846_restart:
.annotate 'line', 436
    if_null rx2846_debug, debug_1653
    rx2846_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1653:
  rx2846_fail:
    (rx2846_rep, rx2846_pos, $I10, $P10) = rx2846_cur."!mark_fail"(0)
    lt rx2846_pos, -1, rx2846_done
    eq rx2846_pos, -1, rx2846_fail
    jump $I10
  rx2846_done:
    rx2846_cur."!cursor_fail"()
    if_null rx2846_debug, debug_1654
    rx2846_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1654:
    .return (rx2846_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("411_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2850, "ResizablePMCArray"
    push $P2850, "next"
    .return ($P2850)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("412_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    .local string rx2852_tgt
    .local int rx2852_pos
    .local int rx2852_off
    .local int rx2852_eos
    .local int rx2852_rep
    .local pmc rx2852_cur
    .local pmc rx2852_debug
    (rx2852_cur, rx2852_pos, rx2852_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2852_cur
    .local pmc match
    .lex "$/", match
    length rx2852_eos, rx2852_tgt
    gt rx2852_pos, rx2852_eos, rx2852_done
    set rx2852_off, 0
    lt rx2852_pos, 2, rx2852_start
    sub rx2852_off, rx2852_pos, 1
    substr rx2852_tgt, rx2852_tgt, rx2852_off
  rx2852_start:
    eq $I10, 1, rx2852_restart
    if_null rx2852_debug, debug_1655
    rx2852_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1655:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2853_done
    goto rxscan2853_scan
  rxscan2853_loop:
    (rx2852_pos) = rx2852_cur."from"()
    inc rx2852_pos
    rx2852_cur."!cursor_from"(rx2852_pos)
    ge rx2852_pos, rx2852_eos, rxscan2853_done
  rxscan2853_scan:
    set_addr $I10, rxscan2853_loop
    rx2852_cur."!mark_push"(0, rx2852_pos, $I10)
  rxscan2853_done:
.annotate 'line', 1150
  # rx subcapture "sym"
    set_addr $I10, rxcap_2854_fail
    rx2852_cur."!mark_push"(0, rx2852_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2852_pos, 4
    gt $I11, rx2852_eos, rx2852_fail
    sub $I11, rx2852_pos, rx2852_off
    substr $S10, rx2852_tgt, $I11, 4
    ne $S10, "redo", rx2852_fail
    add rx2852_pos, 4
    set_addr $I10, rxcap_2854_fail
    ($I12, $I11) = rx2852_cur."!mark_peek"($I10)
    rx2852_cur."!cursor_pos"($I11)
    ($P10) = rx2852_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2852_pos, "")
    rx2852_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2854_done
  rxcap_2854_fail:
    goto rx2852_fail
  rxcap_2854_done:
  # rx pass
    rx2852_cur."!cursor_pass"(rx2852_pos, "term:sym<redo>")
    if_null rx2852_debug, debug_1656
    rx2852_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2852_pos)
  debug_1656:
    .return (rx2852_cur)
  rx2852_restart:
.annotate 'line', 436
    if_null rx2852_debug, debug_1657
    rx2852_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1657:
  rx2852_fail:
    (rx2852_rep, rx2852_pos, $I10, $P10) = rx2852_cur."!mark_fail"(0)
    lt rx2852_pos, -1, rx2852_done
    eq rx2852_pos, -1, rx2852_fail
    jump $I10
  rx2852_done:
    rx2852_cur."!cursor_fail"()
    if_null rx2852_debug, debug_1658
    rx2852_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1658:
    .return (rx2852_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("413_1306916577.75068") :method :outer("40_1306916577.75068")
.annotate 'line', 436
    new $P2856, "ResizablePMCArray"
    push $P2856, "redo"
    .return ($P2856)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch" :anon :subid("414_1306916577.75068") :outer("40_1306916577.75068")
    .param pmc param_2858
    .param pmc param_2859
.annotate 'line', 1152
    .lex "self", param_2858
    .lex "$/", param_2859
.annotate 'line', 1154
    new $P2860, "Undef"
    .lex "$t", $P2860
    find_lex $P2861, "$/"
    unless_null $P2861, vivify_1659
    $P2861 = root_new ['parrot';'ResizablePMCArray']
  vivify_1659:
    set $P2862, $P2861[0]
    unless_null $P2862, vivify_1660
    new $P2862, "Undef"
  vivify_1660:
    store_lex "$t", $P2862
    find_lex $P2863, "$/"
    unless_null $P2863, vivify_1661
    $P2863 = root_new ['parrot';'ResizablePMCArray']
  vivify_1661:
    set $P2864, $P2863[1]
    unless_null $P2864, vivify_1662
    new $P2864, "Undef"
  vivify_1662:
    find_lex $P2865, "$/"
    unless_null $P2865, vivify_1663
    $P2865 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2865
  vivify_1663:
    set $P2865[0], $P2864
    find_lex $P2866, "$t"
    unless_null $P2866, vivify_1664
    new $P2866, "Undef"
  vivify_1664:
    find_lex $P2867, "$/"
    unless_null $P2867, vivify_1665
    $P2867 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2867
  vivify_1665:
    set $P2867[1], $P2866
.annotate 'line', 1152
    .return ($P2866)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2869"  :subid("415_1306916577.75068") :outer("10_1306916577.75068")
.annotate 'line', 1158
    .const 'Sub' $P2931 = "435_1306916577.75068" 
    capture_lex $P2931
    .const 'Sub' $P2928 = "434_1306916577.75068" 
    capture_lex $P2928
    .const 'Sub' $P2926 = "433_1306916577.75068" 
    capture_lex $P2926
    .const 'Sub' $P2923 = "432_1306916577.75068" 
    capture_lex $P2923
    .const 'Sub' $P2920 = "431_1306916577.75068" 
    capture_lex $P2920
    .const 'Sub' $P2911 = "429_1306916577.75068" 
    capture_lex $P2911
    .const 'Sub' $P2909 = "428_1306916577.75068" 
    capture_lex $P2909
    .const 'Sub' $P2901 = "426_1306916577.75068" 
    capture_lex $P2901
    .const 'Sub' $P2899 = "425_1306916577.75068" 
    capture_lex $P2899
    .const 'Sub' $P2896 = "424_1306916577.75068" 
    capture_lex $P2896
    .const 'Sub' $P2894 = "423_1306916577.75068" 
    capture_lex $P2894
    .const 'Sub' $P2887 = "421_1306916577.75068" 
    capture_lex $P2887
    .const 'Sub' $P2885 = "420_1306916577.75068" 
    capture_lex $P2885
    .const 'Sub' $P2882 = "419_1306916577.75068" 
    capture_lex $P2882
    .const 'Sub' $P2880 = "418_1306916577.75068" 
    capture_lex $P2880
    .const 'Sub' $P2873 = "416_1306916577.75068" 
    capture_lex $P2873
    .lex "$?PACKAGE", $P2871
    .lex "$?CLASS", $P2872
    .const 'Sub' $P2931 = "435_1306916577.75068" 
    capture_lex $P2931
    .return ($P2931)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("416_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .const 'Sub' $P2877 = "417_1306916577.75068" 
    capture_lex $P2877
    .local string rx2874_tgt
    .local int rx2874_pos
    .local int rx2874_off
    .local int rx2874_eos
    .local int rx2874_rep
    .local pmc rx2874_cur
    .local pmc rx2874_debug
    (rx2874_cur, rx2874_pos, rx2874_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2874_cur
    .local pmc match
    .lex "$/", match
    length rx2874_eos, rx2874_tgt
    gt rx2874_pos, rx2874_eos, rx2874_done
    set rx2874_off, 0
    lt rx2874_pos, 2, rx2874_start
    sub rx2874_off, rx2874_pos, 1
    substr rx2874_tgt, rx2874_tgt, rx2874_off
  rx2874_start:
    eq $I10, 1, rx2874_restart
    if_null rx2874_debug, debug_1666
    rx2874_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2875_done
    goto rxscan2875_scan
  rxscan2875_loop:
    (rx2874_pos) = rx2874_cur."from"()
    inc rx2874_pos
    rx2874_cur."!cursor_from"(rx2874_pos)
    ge rx2874_pos, rx2874_eos, rxscan2875_done
  rxscan2875_scan:
    set_addr $I10, rxscan2875_loop
    rx2874_cur."!mark_push"(0, rx2874_pos, $I10)
  rxscan2875_done:
.annotate 'line', 1160
  # rx literal  ":"
    add $I11, rx2874_pos, 1
    gt $I11, rx2874_eos, rx2874_fail
    sub $I11, rx2874_pos, rx2874_off
    ord $I11, rx2874_tgt, $I11
    ne $I11, 58, rx2874_fail
    add rx2874_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2874_cur."!cursor_pos"(rx2874_pos)
    .const 'Sub' $P2877 = "417_1306916577.75068" 
    capture_lex $P2877
    $P10 = rx2874_cur."before"($P2877)
    unless $P10, rx2874_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2874_cur."!cursor_pos"(rx2874_pos)
    $P10 = rx2874_cur."LANG"("MAIN", "statement")
    unless $P10, rx2874_fail
    rx2874_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2874_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2874_cur."!cursor_pos"(rx2874_pos)
    $P10 = rx2874_cur."ws"()
    unless $P10, rx2874_fail
    rx2874_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2874_pos, 1
    gt $I11, rx2874_eos, rx2874_fail
    sub $I11, rx2874_pos, rx2874_off
    ord $I11, rx2874_tgt, $I11
    ne $I11, 59, rx2874_fail
    add rx2874_pos, 1
.annotate 'line', 1159
  # rx pass
    rx2874_cur."!cursor_pass"(rx2874_pos, "metachar:sym<:my>")
    if_null rx2874_debug, debug_1671
    rx2874_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2874_pos)
  debug_1671:
    .return (rx2874_cur)
  rx2874_restart:
.annotate 'line', 1158
    if_null rx2874_debug, debug_1672
    rx2874_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1672:
  rx2874_fail:
    (rx2874_rep, rx2874_pos, $I10, $P10) = rx2874_cur."!mark_fail"(0)
    lt rx2874_pos, -1, rx2874_done
    eq rx2874_pos, -1, rx2874_fail
    jump $I10
  rx2874_done:
    rx2874_cur."!cursor_fail"()
    if_null rx2874_debug, debug_1673
    rx2874_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1673:
    .return (rx2874_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2876"  :anon :subid("417_1306916577.75068") :method :outer("416_1306916577.75068")
.annotate 'line', 1160
    .local string rx2878_tgt
    .local int rx2878_pos
    .local int rx2878_off
    .local int rx2878_eos
    .local int rx2878_rep
    .local pmc rx2878_cur
    .local pmc rx2878_debug
    (rx2878_cur, rx2878_pos, rx2878_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2878_cur
    .local pmc match
    .lex "$/", match
    length rx2878_eos, rx2878_tgt
    gt rx2878_pos, rx2878_eos, rx2878_done
    set rx2878_off, 0
    lt rx2878_pos, 2, rx2878_start
    sub rx2878_off, rx2878_pos, 1
    substr rx2878_tgt, rx2878_tgt, rx2878_off
  rx2878_start:
    eq $I10, 1, rx2878_restart
    if_null rx2878_debug, debug_1667
    rx2878_cur."!cursor_debug"("START", "")
  debug_1667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2879_done
    goto rxscan2879_scan
  rxscan2879_loop:
    (rx2878_pos) = rx2878_cur."from"()
    inc rx2878_pos
    rx2878_cur."!cursor_from"(rx2878_pos)
    ge rx2878_pos, rx2878_eos, rxscan2879_done
  rxscan2879_scan:
    set_addr $I10, rxscan2879_loop
    rx2878_cur."!mark_push"(0, rx2878_pos, $I10)
  rxscan2879_done:
  # rx literal  "my"
    add $I11, rx2878_pos, 2
    gt $I11, rx2878_eos, rx2878_fail
    sub $I11, rx2878_pos, rx2878_off
    substr $S10, rx2878_tgt, $I11, 2
    ne $S10, "my", rx2878_fail
    add rx2878_pos, 2
  # rx pass
    rx2878_cur."!cursor_pass"(rx2878_pos, "")
    if_null rx2878_debug, debug_1668
    rx2878_cur."!cursor_debug"("PASS", "", " at pos=", rx2878_pos)
  debug_1668:
    .return (rx2878_cur)
  rx2878_restart:
    if_null rx2878_debug, debug_1669
    rx2878_cur."!cursor_debug"("NEXT", "")
  debug_1669:
  rx2878_fail:
    (rx2878_rep, rx2878_pos, $I10, $P10) = rx2878_cur."!mark_fail"(0)
    lt rx2878_pos, -1, rx2878_done
    eq rx2878_pos, -1, rx2878_fail
    jump $I10
  rx2878_done:
    rx2878_cur."!cursor_fail"()
    if_null rx2878_debug, debug_1670
    rx2878_cur."!cursor_debug"("FAIL", "")
  debug_1670:
    .return (rx2878_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("418_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    new $P2881, "ResizablePMCArray"
    push $P2881, ":"
    .return ($P2881)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("419_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .local string rx2883_tgt
    .local int rx2883_pos
    .local int rx2883_off
    .local int rx2883_eos
    .local int rx2883_rep
    .local pmc rx2883_cur
    .local pmc rx2883_debug
    (rx2883_cur, rx2883_pos, rx2883_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2883_cur
    .local pmc match
    .lex "$/", match
    length rx2883_eos, rx2883_tgt
    gt rx2883_pos, rx2883_eos, rx2883_done
    set rx2883_off, 0
    lt rx2883_pos, 2, rx2883_start
    sub rx2883_off, rx2883_pos, 1
    substr rx2883_tgt, rx2883_tgt, rx2883_off
  rx2883_start:
    eq $I10, 1, rx2883_restart
    if_null rx2883_debug, debug_1674
    rx2883_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2884_done
    goto rxscan2884_scan
  rxscan2884_loop:
    (rx2883_pos) = rx2883_cur."from"()
    inc rx2883_pos
    rx2883_cur."!cursor_from"(rx2883_pos)
    ge rx2883_pos, rx2883_eos, rxscan2884_done
  rxscan2884_scan:
    set_addr $I10, rxscan2884_loop
    rx2883_cur."!mark_push"(0, rx2883_pos, $I10)
  rxscan2884_done:
.annotate 'line', 1164
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2883_pos, rx2883_off
    substr $S10, rx2883_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2883_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2883_cur."!cursor_pos"(rx2883_pos)
    $P10 = rx2883_cur."codeblock"()
    unless $P10, rx2883_fail
    rx2883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2883_pos = $P10."pos"()
.annotate 'line', 1163
  # rx pass
    rx2883_cur."!cursor_pass"(rx2883_pos, "metachar:sym<{ }>")
    if_null rx2883_debug, debug_1675
    rx2883_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2883_pos)
  debug_1675:
    .return (rx2883_cur)
  rx2883_restart:
.annotate 'line', 1158
    if_null rx2883_debug, debug_1676
    rx2883_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1676:
  rx2883_fail:
    (rx2883_rep, rx2883_pos, $I10, $P10) = rx2883_cur."!mark_fail"(0)
    lt rx2883_pos, -1, rx2883_done
    eq rx2883_pos, -1, rx2883_fail
    jump $I10
  rx2883_done:
    rx2883_cur."!cursor_fail"()
    if_null rx2883_debug, debug_1677
    rx2883_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1677:
    .return (rx2883_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("420_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    new $P2886, "ResizablePMCArray"
    push $P2886, "{"
    .return ($P2886)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("421_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .const 'Sub' $P2891 = "422_1306916577.75068" 
    capture_lex $P2891
    .local string rx2888_tgt
    .local int rx2888_pos
    .local int rx2888_off
    .local int rx2888_eos
    .local int rx2888_rep
    .local pmc rx2888_cur
    .local pmc rx2888_debug
    (rx2888_cur, rx2888_pos, rx2888_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2888_cur
    .local pmc match
    .lex "$/", match
    length rx2888_eos, rx2888_tgt
    gt rx2888_pos, rx2888_eos, rx2888_done
    set rx2888_off, 0
    lt rx2888_pos, 2, rx2888_start
    sub rx2888_off, rx2888_pos, 1
    substr rx2888_tgt, rx2888_tgt, rx2888_off
  rx2888_start:
    eq $I10, 1, rx2888_restart
    if_null rx2888_debug, debug_1678
    rx2888_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2889_done
    goto rxscan2889_scan
  rxscan2889_loop:
    (rx2888_pos) = rx2888_cur."from"()
    inc rx2888_pos
    rx2888_cur."!cursor_from"(rx2888_pos)
    ge rx2888_pos, rx2888_eos, rxscan2889_done
  rxscan2889_scan:
    set_addr $I10, rxscan2889_loop
    rx2888_cur."!mark_push"(0, rx2888_pos, $I10)
  rxscan2889_done:
.annotate 'line', 1168
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2888_pos, rx2888_off
    substr $S10, rx2888_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2888_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2888_cur."!cursor_pos"(rx2888_pos)
    .const 'Sub' $P2891 = "422_1306916577.75068" 
    capture_lex $P2891
    $P10 = rx2888_cur."before"($P2891)
    unless $P10, rx2888_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2888_cur."!cursor_pos"(rx2888_pos)
    $P10 = rx2888_cur."LANG"("MAIN", "variable")
    unless $P10, rx2888_fail
    rx2888_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2888_pos = $P10."pos"()
.annotate 'line', 1167
  # rx pass
    rx2888_cur."!cursor_pass"(rx2888_pos, "metachar:sym<nqpvar>")
    if_null rx2888_debug, debug_1683
    rx2888_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2888_pos)
  debug_1683:
    .return (rx2888_cur)
  rx2888_restart:
.annotate 'line', 1158
    if_null rx2888_debug, debug_1684
    rx2888_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1684:
  rx2888_fail:
    (rx2888_rep, rx2888_pos, $I10, $P10) = rx2888_cur."!mark_fail"(0)
    lt rx2888_pos, -1, rx2888_done
    eq rx2888_pos, -1, rx2888_fail
    jump $I10
  rx2888_done:
    rx2888_cur."!cursor_fail"()
    if_null rx2888_debug, debug_1685
    rx2888_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1685:
    .return (rx2888_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2890"  :anon :subid("422_1306916577.75068") :method :outer("421_1306916577.75068")
.annotate 'line', 1168
    .local string rx2892_tgt
    .local int rx2892_pos
    .local int rx2892_off
    .local int rx2892_eos
    .local int rx2892_rep
    .local pmc rx2892_cur
    .local pmc rx2892_debug
    (rx2892_cur, rx2892_pos, rx2892_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2892_cur
    .local pmc match
    .lex "$/", match
    length rx2892_eos, rx2892_tgt
    gt rx2892_pos, rx2892_eos, rx2892_done
    set rx2892_off, 0
    lt rx2892_pos, 2, rx2892_start
    sub rx2892_off, rx2892_pos, 1
    substr rx2892_tgt, rx2892_tgt, rx2892_off
  rx2892_start:
    eq $I10, 1, rx2892_restart
    if_null rx2892_debug, debug_1679
    rx2892_cur."!cursor_debug"("START", "")
  debug_1679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2893_done
    goto rxscan2893_scan
  rxscan2893_loop:
    (rx2892_pos) = rx2892_cur."from"()
    inc rx2892_pos
    rx2892_cur."!cursor_from"(rx2892_pos)
    ge rx2892_pos, rx2892_eos, rxscan2893_done
  rxscan2893_scan:
    set_addr $I10, rxscan2893_loop
    rx2892_cur."!mark_push"(0, rx2892_pos, $I10)
  rxscan2893_done:
  # rx charclass .
    ge rx2892_pos, rx2892_eos, rx2892_fail
    inc rx2892_pos
  # rx charclass w
    ge rx2892_pos, rx2892_eos, rx2892_fail
    sub $I10, rx2892_pos, rx2892_off
    is_cclass $I11, 8192, rx2892_tgt, $I10
    unless $I11, rx2892_fail
    inc rx2892_pos
  # rx pass
    rx2892_cur."!cursor_pass"(rx2892_pos, "")
    if_null rx2892_debug, debug_1680
    rx2892_cur."!cursor_debug"("PASS", "", " at pos=", rx2892_pos)
  debug_1680:
    .return (rx2892_cur)
  rx2892_restart:
    if_null rx2892_debug, debug_1681
    rx2892_cur."!cursor_debug"("NEXT", "")
  debug_1681:
  rx2892_fail:
    (rx2892_rep, rx2892_pos, $I10, $P10) = rx2892_cur."!mark_fail"(0)
    lt rx2892_pos, -1, rx2892_done
    eq rx2892_pos, -1, rx2892_fail
    jump $I10
  rx2892_done:
    rx2892_cur."!cursor_fail"()
    if_null rx2892_debug, debug_1682
    rx2892_cur."!cursor_debug"("FAIL", "")
  debug_1682:
    .return (rx2892_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("423_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    new $P2895, "ResizablePMCArray"
    push $P2895, "$"
    push $P2895, "@"
    .return ($P2895)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("424_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .local string rx2897_tgt
    .local int rx2897_pos
    .local int rx2897_off
    .local int rx2897_eos
    .local int rx2897_rep
    .local pmc rx2897_cur
    .local pmc rx2897_debug
    (rx2897_cur, rx2897_pos, rx2897_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2897_cur
    .local pmc match
    .lex "$/", match
    length rx2897_eos, rx2897_tgt
    gt rx2897_pos, rx2897_eos, rx2897_done
    set rx2897_off, 0
    lt rx2897_pos, 2, rx2897_start
    sub rx2897_off, rx2897_pos, 1
    substr rx2897_tgt, rx2897_tgt, rx2897_off
  rx2897_start:
    eq $I10, 1, rx2897_restart
    if_null rx2897_debug, debug_1686
    rx2897_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2898_done
    goto rxscan2898_scan
  rxscan2898_loop:
    (rx2897_pos) = rx2897_cur."from"()
    inc rx2897_pos
    rx2897_cur."!cursor_from"(rx2897_pos)
    ge rx2897_pos, rx2897_eos, rxscan2898_done
  rxscan2898_scan:
    set_addr $I10, rxscan2898_loop
    rx2897_cur."!mark_push"(0, rx2897_pos, $I10)
  rxscan2898_done:
.annotate 'line', 1172
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2897_pos, rx2897_off
    substr $S10, rx2897_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2897_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2897_cur."!cursor_pos"(rx2897_pos)
    $P10 = rx2897_cur."codeblock"()
    unless $P10, rx2897_fail
    rx2897_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2897_pos = $P10."pos"()
.annotate 'line', 1171
  # rx pass
    rx2897_cur."!cursor_pass"(rx2897_pos, "assertion:sym<{ }>")
    if_null rx2897_debug, debug_1687
    rx2897_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2897_pos)
  debug_1687:
    .return (rx2897_cur)
  rx2897_restart:
.annotate 'line', 1158
    if_null rx2897_debug, debug_1688
    rx2897_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1688:
  rx2897_fail:
    (rx2897_rep, rx2897_pos, $I10, $P10) = rx2897_cur."!mark_fail"(0)
    lt rx2897_pos, -1, rx2897_done
    eq rx2897_pos, -1, rx2897_fail
    jump $I10
  rx2897_done:
    rx2897_cur."!cursor_fail"()
    if_null rx2897_debug, debug_1689
    rx2897_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1689:
    .return (rx2897_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("425_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    new $P2900, "ResizablePMCArray"
    push $P2900, "{"
    .return ($P2900)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("426_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .const 'Sub' $P2905 = "427_1306916577.75068" 
    capture_lex $P2905
    .local string rx2902_tgt
    .local int rx2902_pos
    .local int rx2902_off
    .local int rx2902_eos
    .local int rx2902_rep
    .local pmc rx2902_cur
    .local pmc rx2902_debug
    (rx2902_cur, rx2902_pos, rx2902_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2902_cur
    .local pmc match
    .lex "$/", match
    length rx2902_eos, rx2902_tgt
    gt rx2902_pos, rx2902_eos, rx2902_done
    set rx2902_off, 0
    lt rx2902_pos, 2, rx2902_start
    sub rx2902_off, rx2902_pos, 1
    substr rx2902_tgt, rx2902_tgt, rx2902_off
  rx2902_start:
    eq $I10, 1, rx2902_restart
    if_null rx2902_debug, debug_1690
    rx2902_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2903_done
    goto rxscan2903_scan
  rxscan2903_loop:
    (rx2902_pos) = rx2902_cur."from"()
    inc rx2902_pos
    rx2902_cur."!cursor_from"(rx2902_pos)
    ge rx2902_pos, rx2902_eos, rxscan2903_done
  rxscan2903_scan:
    set_addr $I10, rxscan2903_loop
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
  rxscan2903_done:
.annotate 'line', 1176
  # rx subcapture "zw"
    set_addr $I10, rxcap_2908_fail
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2902_pos, rx2902_eos, rx2902_fail
    sub $I10, rx2902_pos, rx2902_off
    substr $S10, rx2902_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2902_fail
    inc rx2902_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    .const 'Sub' $P2905 = "427_1306916577.75068" 
    capture_lex $P2905
    $P10 = rx2902_cur."before"($P2905)
    unless $P10, rx2902_fail
    set_addr $I10, rxcap_2908_fail
    ($I12, $I11) = rx2902_cur."!mark_peek"($I10)
    rx2902_cur."!cursor_pos"($I11)
    ($P10) = rx2902_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2902_pos, "")
    rx2902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2908_done
  rxcap_2908_fail:
    goto rx2902_fail
  rxcap_2908_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    $P10 = rx2902_cur."codeblock"()
    unless $P10, rx2902_fail
    rx2902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2902_pos = $P10."pos"()
.annotate 'line', 1175
  # rx pass
    rx2902_cur."!cursor_pass"(rx2902_pos, "assertion:sym<?{ }>")
    if_null rx2902_debug, debug_1695
    rx2902_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2902_pos)
  debug_1695:
    .return (rx2902_cur)
  rx2902_restart:
.annotate 'line', 1158
    if_null rx2902_debug, debug_1696
    rx2902_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1696:
  rx2902_fail:
    (rx2902_rep, rx2902_pos, $I10, $P10) = rx2902_cur."!mark_fail"(0)
    lt rx2902_pos, -1, rx2902_done
    eq rx2902_pos, -1, rx2902_fail
    jump $I10
  rx2902_done:
    rx2902_cur."!cursor_fail"()
    if_null rx2902_debug, debug_1697
    rx2902_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1697:
    .return (rx2902_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2904"  :anon :subid("427_1306916577.75068") :method :outer("426_1306916577.75068")
.annotate 'line', 1176
    .local string rx2906_tgt
    .local int rx2906_pos
    .local int rx2906_off
    .local int rx2906_eos
    .local int rx2906_rep
    .local pmc rx2906_cur
    .local pmc rx2906_debug
    (rx2906_cur, rx2906_pos, rx2906_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2906_cur
    .local pmc match
    .lex "$/", match
    length rx2906_eos, rx2906_tgt
    gt rx2906_pos, rx2906_eos, rx2906_done
    set rx2906_off, 0
    lt rx2906_pos, 2, rx2906_start
    sub rx2906_off, rx2906_pos, 1
    substr rx2906_tgt, rx2906_tgt, rx2906_off
  rx2906_start:
    eq $I10, 1, rx2906_restart
    if_null rx2906_debug, debug_1691
    rx2906_cur."!cursor_debug"("START", "")
  debug_1691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2907_done
    goto rxscan2907_scan
  rxscan2907_loop:
    (rx2906_pos) = rx2906_cur."from"()
    inc rx2906_pos
    rx2906_cur."!cursor_from"(rx2906_pos)
    ge rx2906_pos, rx2906_eos, rxscan2907_done
  rxscan2907_scan:
    set_addr $I10, rxscan2907_loop
    rx2906_cur."!mark_push"(0, rx2906_pos, $I10)
  rxscan2907_done:
  # rx literal  "{"
    add $I11, rx2906_pos, 1
    gt $I11, rx2906_eos, rx2906_fail
    sub $I11, rx2906_pos, rx2906_off
    ord $I11, rx2906_tgt, $I11
    ne $I11, 123, rx2906_fail
    add rx2906_pos, 1
  # rx pass
    rx2906_cur."!cursor_pass"(rx2906_pos, "")
    if_null rx2906_debug, debug_1692
    rx2906_cur."!cursor_debug"("PASS", "", " at pos=", rx2906_pos)
  debug_1692:
    .return (rx2906_cur)
  rx2906_restart:
    if_null rx2906_debug, debug_1693
    rx2906_cur."!cursor_debug"("NEXT", "")
  debug_1693:
  rx2906_fail:
    (rx2906_rep, rx2906_pos, $I10, $P10) = rx2906_cur."!mark_fail"(0)
    lt rx2906_pos, -1, rx2906_done
    eq rx2906_pos, -1, rx2906_fail
    jump $I10
  rx2906_done:
    rx2906_cur."!cursor_fail"()
    if_null rx2906_debug, debug_1694
    rx2906_cur."!cursor_debug"("FAIL", "")
  debug_1694:
    .return (rx2906_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("428_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    new $P2910, "ResizablePMCArray"
    push $P2910, "!"
    push $P2910, "?"
    .return ($P2910)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("429_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .const 'Sub' $P2917 = "430_1306916577.75068" 
    capture_lex $P2917
    .local string rx2912_tgt
    .local int rx2912_pos
    .local int rx2912_off
    .local int rx2912_eos
    .local int rx2912_rep
    .local pmc rx2912_cur
    .local pmc rx2912_debug
    (rx2912_cur, rx2912_pos, rx2912_tgt, $I10) = self."!cursor_start"()
    rx2912_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2912_cur
    .local pmc match
    .lex "$/", match
    length rx2912_eos, rx2912_tgt
    gt rx2912_pos, rx2912_eos, rx2912_done
    set rx2912_off, 0
    lt rx2912_pos, 2, rx2912_start
    sub rx2912_off, rx2912_pos, 1
    substr rx2912_tgt, rx2912_tgt, rx2912_off
  rx2912_start:
    eq $I10, 1, rx2912_restart
    if_null rx2912_debug, debug_1698
    rx2912_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2913_done
    goto rxscan2913_scan
  rxscan2913_loop:
    (rx2912_pos) = rx2912_cur."from"()
    inc rx2912_pos
    rx2912_cur."!cursor_from"(rx2912_pos)
    ge rx2912_pos, rx2912_eos, rxscan2913_done
  rxscan2913_scan:
    set_addr $I10, rxscan2913_loop
    rx2912_cur."!mark_push"(0, rx2912_pos, $I10)
  rxscan2913_done:
.annotate 'line', 1180
  # rx subrule "identifier" subtype=capture negate=
    rx2912_cur."!cursor_pos"(rx2912_pos)
    $P10 = rx2912_cur."identifier"()
    unless $P10, rx2912_fail
    rx2912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2912_pos = $P10."pos"()
.annotate 'line', 1187
  # rx rxquantr2914 ** 0..1
    set_addr $I10, rxquantr2914_done
    rx2912_cur."!mark_push"(0, rx2912_pos, $I10)
  rxquantr2914_loop:
  alt2915_0:
.annotate 'line', 1181
    set_addr $I10, alt2915_1
    rx2912_cur."!mark_push"(0, rx2912_pos, $I10)
.annotate 'line', 1182
  # rx subrule "before" subtype=zerowidth negate=
    rx2912_cur."!cursor_pos"(rx2912_pos)
    .const 'Sub' $P2917 = "430_1306916577.75068" 
    capture_lex $P2917
    $P10 = rx2912_cur."before"($P2917)
    unless $P10, rx2912_fail
    goto alt2915_end
  alt2915_1:
    set_addr $I10, alt2915_2
    rx2912_cur."!mark_push"(0, rx2912_pos, $I10)
.annotate 'line', 1183
  # rx literal  "="
    add $I11, rx2912_pos, 1
    gt $I11, rx2912_eos, rx2912_fail
    sub $I11, rx2912_pos, rx2912_off
    ord $I11, rx2912_tgt, $I11
    ne $I11, 61, rx2912_fail
    add rx2912_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2912_cur."!cursor_pos"(rx2912_pos)
    $P10 = rx2912_cur."assertion"()
    unless $P10, rx2912_fail
    rx2912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2912_pos = $P10."pos"()
    goto alt2915_end
  alt2915_2:
    set_addr $I10, alt2915_3
    rx2912_cur."!mark_push"(0, rx2912_pos, $I10)
.annotate 'line', 1184
  # rx literal  ":"
    add $I11, rx2912_pos, 1
    gt $I11, rx2912_eos, rx2912_fail
    sub $I11, rx2912_pos, rx2912_off
    ord $I11, rx2912_tgt, $I11
    ne $I11, 58, rx2912_fail
    add rx2912_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2912_cur."!cursor_pos"(rx2912_pos)
    $P10 = rx2912_cur."arglist"()
    unless $P10, rx2912_fail
    rx2912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2912_pos = $P10."pos"()
    goto alt2915_end
  alt2915_3:
    set_addr $I10, alt2915_4
    rx2912_cur."!mark_push"(0, rx2912_pos, $I10)
.annotate 'line', 1185
  # rx literal  "("
    add $I11, rx2912_pos, 1
    gt $I11, rx2912_eos, rx2912_fail
    sub $I11, rx2912_pos, rx2912_off
    ord $I11, rx2912_tgt, $I11
    ne $I11, 40, rx2912_fail
    add rx2912_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2912_cur."!cursor_pos"(rx2912_pos)
    $P10 = rx2912_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2912_fail
    rx2912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2912_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2912_pos, 1
    gt $I11, rx2912_eos, rx2912_fail
    sub $I11, rx2912_pos, rx2912_off
    ord $I11, rx2912_tgt, $I11
    ne $I11, 41, rx2912_fail
    add rx2912_pos, 1
    goto alt2915_end
  alt2915_4:
.annotate 'line', 1186
  # rx subrule "normspace" subtype=method negate=
    rx2912_cur."!cursor_pos"(rx2912_pos)
    $P10 = rx2912_cur."normspace"()
    unless $P10, rx2912_fail
    rx2912_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2912_cur."!cursor_pos"(rx2912_pos)
    $P10 = rx2912_cur."nibbler"()
    unless $P10, rx2912_fail
    rx2912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2912_pos = $P10."pos"()
  alt2915_end:
.annotate 'line', 1187
    set_addr $I10, rxquantr2914_done
    (rx2912_rep) = rx2912_cur."!mark_commit"($I10)
  rxquantr2914_done:
.annotate 'line', 1179
  # rx pass
    rx2912_cur."!cursor_pass"(rx2912_pos, "assertion:sym<name>")
    if_null rx2912_debug, debug_1703
    rx2912_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2912_pos)
  debug_1703:
    .return (rx2912_cur)
  rx2912_restart:
.annotate 'line', 1158
    if_null rx2912_debug, debug_1704
    rx2912_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1704:
  rx2912_fail:
    (rx2912_rep, rx2912_pos, $I10, $P10) = rx2912_cur."!mark_fail"(0)
    lt rx2912_pos, -1, rx2912_done
    eq rx2912_pos, -1, rx2912_fail
    jump $I10
  rx2912_done:
    rx2912_cur."!cursor_fail"()
    if_null rx2912_debug, debug_1705
    rx2912_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1705:
    .return (rx2912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2916"  :anon :subid("430_1306916577.75068") :method :outer("429_1306916577.75068")
.annotate 'line', 1182
    .local string rx2918_tgt
    .local int rx2918_pos
    .local int rx2918_off
    .local int rx2918_eos
    .local int rx2918_rep
    .local pmc rx2918_cur
    .local pmc rx2918_debug
    (rx2918_cur, rx2918_pos, rx2918_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2918_cur
    .local pmc match
    .lex "$/", match
    length rx2918_eos, rx2918_tgt
    gt rx2918_pos, rx2918_eos, rx2918_done
    set rx2918_off, 0
    lt rx2918_pos, 2, rx2918_start
    sub rx2918_off, rx2918_pos, 1
    substr rx2918_tgt, rx2918_tgt, rx2918_off
  rx2918_start:
    eq $I10, 1, rx2918_restart
    if_null rx2918_debug, debug_1699
    rx2918_cur."!cursor_debug"("START", "")
  debug_1699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2919_done
    goto rxscan2919_scan
  rxscan2919_loop:
    (rx2918_pos) = rx2918_cur."from"()
    inc rx2918_pos
    rx2918_cur."!cursor_from"(rx2918_pos)
    ge rx2918_pos, rx2918_eos, rxscan2919_done
  rxscan2919_scan:
    set_addr $I10, rxscan2919_loop
    rx2918_cur."!mark_push"(0, rx2918_pos, $I10)
  rxscan2919_done:
  # rx literal  ">"
    add $I11, rx2918_pos, 1
    gt $I11, rx2918_eos, rx2918_fail
    sub $I11, rx2918_pos, rx2918_off
    ord $I11, rx2918_tgt, $I11
    ne $I11, 62, rx2918_fail
    add rx2918_pos, 1
  # rx pass
    rx2918_cur."!cursor_pass"(rx2918_pos, "")
    if_null rx2918_debug, debug_1700
    rx2918_cur."!cursor_debug"("PASS", "", " at pos=", rx2918_pos)
  debug_1700:
    .return (rx2918_cur)
  rx2918_restart:
    if_null rx2918_debug, debug_1701
    rx2918_cur."!cursor_debug"("NEXT", "")
  debug_1701:
  rx2918_fail:
    (rx2918_rep, rx2918_pos, $I10, $P10) = rx2918_cur."!mark_fail"(0)
    lt rx2918_pos, -1, rx2918_done
    eq rx2918_pos, -1, rx2918_fail
    jump $I10
  rx2918_done:
    rx2918_cur."!cursor_fail"()
    if_null rx2918_debug, debug_1702
    rx2918_cur."!cursor_debug"("FAIL", "")
  debug_1702:
    .return (rx2918_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("431_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    $P2921 = self."!PREFIX__!subrule"("identifier", "")
    new $P2922, "ResizablePMCArray"
    push $P2922, $P2921
    .return ($P2922)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("432_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .local string rx2924_tgt
    .local int rx2924_pos
    .local int rx2924_off
    .local int rx2924_eos
    .local int rx2924_rep
    .local pmc rx2924_cur
    .local pmc rx2924_debug
    (rx2924_cur, rx2924_pos, rx2924_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2924_cur
    .local pmc match
    .lex "$/", match
    length rx2924_eos, rx2924_tgt
    gt rx2924_pos, rx2924_eos, rx2924_done
    set rx2924_off, 0
    lt rx2924_pos, 2, rx2924_start
    sub rx2924_off, rx2924_pos, 1
    substr rx2924_tgt, rx2924_tgt, rx2924_off
  rx2924_start:
    eq $I10, 1, rx2924_restart
    if_null rx2924_debug, debug_1706
    rx2924_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2925_done
    goto rxscan2925_scan
  rxscan2925_loop:
    (rx2924_pos) = rx2924_cur."from"()
    inc rx2924_pos
    rx2924_cur."!cursor_from"(rx2924_pos)
    ge rx2924_pos, rx2924_eos, rxscan2925_done
  rxscan2925_scan:
    set_addr $I10, rxscan2925_loop
    rx2924_cur."!mark_push"(0, rx2924_pos, $I10)
  rxscan2925_done:
.annotate 'line', 1191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2924_pos, rx2924_off
    substr $S10, rx2924_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2924_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2924_cur."!cursor_pos"(rx2924_pos)
    $P10 = rx2924_cur."LANG"("MAIN", "variable")
    unless $P10, rx2924_fail
    rx2924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2924_pos = $P10."pos"()
.annotate 'line', 1190
  # rx pass
    rx2924_cur."!cursor_pass"(rx2924_pos, "assertion:sym<var>")
    if_null rx2924_debug, debug_1707
    rx2924_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2924_pos)
  debug_1707:
    .return (rx2924_cur)
  rx2924_restart:
.annotate 'line', 1158
    if_null rx2924_debug, debug_1708
    rx2924_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1708:
  rx2924_fail:
    (rx2924_rep, rx2924_pos, $I10, $P10) = rx2924_cur."!mark_fail"(0)
    lt rx2924_pos, -1, rx2924_done
    eq rx2924_pos, -1, rx2924_fail
    jump $I10
  rx2924_done:
    rx2924_cur."!cursor_fail"()
    if_null rx2924_debug, debug_1709
    rx2924_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1709:
    .return (rx2924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("433_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    new $P2927, "ResizablePMCArray"
    push $P2927, "$"
    push $P2927, "@"
    .return ($P2927)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("434_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    .local string rx2929_tgt
    .local int rx2929_pos
    .local int rx2929_off
    .local int rx2929_eos
    .local int rx2929_rep
    .local pmc rx2929_cur
    .local pmc rx2929_debug
    (rx2929_cur, rx2929_pos, rx2929_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2929_cur
    .local pmc match
    .lex "$/", match
    length rx2929_eos, rx2929_tgt
    gt rx2929_pos, rx2929_eos, rx2929_done
    set rx2929_off, 0
    lt rx2929_pos, 2, rx2929_start
    sub rx2929_off, rx2929_pos, 1
    substr rx2929_tgt, rx2929_tgt, rx2929_off
  rx2929_start:
    eq $I10, 1, rx2929_restart
    if_null rx2929_debug, debug_1710
    rx2929_cur."!cursor_debug"("START", "codeblock")
  debug_1710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2930_done
    goto rxscan2930_scan
  rxscan2930_loop:
    (rx2929_pos) = rx2929_cur."from"()
    inc rx2929_pos
    rx2929_cur."!cursor_from"(rx2929_pos)
    ge rx2929_pos, rx2929_eos, rxscan2930_done
  rxscan2930_scan:
    set_addr $I10, rxscan2930_loop
    rx2929_cur."!mark_push"(0, rx2929_pos, $I10)
  rxscan2930_done:
.annotate 'line', 1195
  # rx subrule "LANG" subtype=capture negate=
    rx2929_cur."!cursor_pos"(rx2929_pos)
    $P10 = rx2929_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2929_fail
    rx2929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2929_pos = $P10."pos"()
.annotate 'line', 1194
  # rx pass
    rx2929_cur."!cursor_pass"(rx2929_pos, "codeblock")
    if_null rx2929_debug, debug_1711
    rx2929_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2929_pos)
  debug_1711:
    .return (rx2929_cur)
  rx2929_restart:
.annotate 'line', 1158
    if_null rx2929_debug, debug_1712
    rx2929_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1712:
  rx2929_fail:
    (rx2929_rep, rx2929_pos, $I10, $P10) = rx2929_cur."!mark_fail"(0)
    lt rx2929_pos, -1, rx2929_done
    eq rx2929_pos, -1, rx2929_fail
    jump $I10
  rx2929_done:
    rx2929_cur."!cursor_fail"()
    if_null rx2929_debug, debug_1713
    rx2929_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1713:
    .return (rx2929_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("435_1306916577.75068") :method :outer("415_1306916577.75068")
.annotate 'line', 1158
    $P2932 = self."!PREFIX__!subrule"("LANG", "")
    new $P2933, "ResizablePMCArray"
    push $P2933, $P2932
    .return ($P2933)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2934"  :subid("436_1306916577.75068") :outer("10_1306916577.75068")
.annotate 'line', 1201
    .const 'Sub' $P7171 = "614_1306916577.75068" 
    capture_lex $P7171
    .const 'Sub' $P7156 = "613_1306916577.75068" 
    capture_lex $P7156
    .const 'Sub' $P7151 = "612_1306916577.75068" 
    capture_lex $P7151
    .const 'Sub' $P7146 = "611_1306916577.75068" 
    capture_lex $P7146
    .const 'Sub' $P7141 = "610_1306916577.75068" 
    capture_lex $P7141
    .const 'Sub' $P7124 = "609_1306916577.75068" 
    capture_lex $P7124
    .const 'Sub' $P7113 = "608_1306916577.75068" 
    capture_lex $P7113
    .const 'Sub' $P7102 = "607_1306916577.75068" 
    capture_lex $P7102
    .const 'Sub' $P7094 = "606_1306916577.75068" 
    capture_lex $P7094
    .const 'Sub' $P7089 = "605_1306916577.75068" 
    capture_lex $P7089
    .const 'Sub' $P7074 = "604_1306916577.75068" 
    capture_lex $P7074
    .const 'Sub' $P7066 = "603_1306916577.75068" 
    capture_lex $P7066
    .const 'Sub' $P7008 = "602_1306916577.75068" 
    capture_lex $P7008
    .const 'Sub' $P6993 = "601_1306916577.75068" 
    capture_lex $P6993
    .const 'Sub' $P6985 = "600_1306916577.75068" 
    capture_lex $P6985
    .const 'Sub' $P6977 = "599_1306916577.75068" 
    capture_lex $P6977
    .const 'Sub' $P6969 = "598_1306916577.75068" 
    capture_lex $P6969
    .const 'Sub' $P6961 = "597_1306916577.75068" 
    capture_lex $P6961
    .const 'Sub' $P6953 = "596_1306916577.75068" 
    capture_lex $P6953
    .const 'Sub' $P6924 = "595_1306916577.75068" 
    capture_lex $P6924
    .const 'Sub' $P6909 = "594_1306916577.75068" 
    capture_lex $P6909
    .const 'Sub' $P6901 = "593_1306916577.75068" 
    capture_lex $P6901
    .const 'Sub' $P6887 = "592_1306916577.75068" 
    capture_lex $P6887
    .const 'Sub' $P6873 = "591_1306916577.75068" 
    capture_lex $P6873
    .const 'Sub' $P6859 = "590_1306916577.75068" 
    capture_lex $P6859
    .const 'Sub' $P6851 = "589_1306916577.75068" 
    capture_lex $P6851
    .const 'Sub' $P6821 = "588_1306916577.75068" 
    capture_lex $P6821
    .const 'Sub' $P6783 = "586_1306916577.75068" 
    capture_lex $P6783
    .const 'Sub' $P6775 = "585_1306916577.75068" 
    capture_lex $P6775
    .const 'Sub' $P6767 = "584_1306916577.75068" 
    capture_lex $P6767
    .const 'Sub' $P6736 = "583_1306916577.75068" 
    capture_lex $P6736
    .const 'Sub' $P6717 = "582_1306916577.75068" 
    capture_lex $P6717
    .const 'Sub' $P6709 = "581_1306916577.75068" 
    capture_lex $P6709
    .const 'Sub' $P6701 = "580_1306916577.75068" 
    capture_lex $P6701
    .const 'Sub' $P6593 = "577_1306916577.75068" 
    capture_lex $P6593
    .const 'Sub' $P6585 = "576_1306916577.75068" 
    capture_lex $P6585
    .const 'Sub' $P6575 = "575_1306916577.75068" 
    capture_lex $P6575
    .const 'Sub' $P6541 = "574_1306916577.75068" 
    capture_lex $P6541
    .const 'Sub' $P6499 = "572_1306916577.75068" 
    capture_lex $P6499
    .const 'Sub' $P6485 = "571_1306916577.75068" 
    capture_lex $P6485
    .const 'Sub' $P6475 = "570_1306916577.75068" 
    capture_lex $P6475
    .const 'Sub' $P6423 = "569_1306916577.75068" 
    capture_lex $P6423
    .const 'Sub' $P6194 = "564_1306916577.75068" 
    capture_lex $P6194
    .const 'Sub' $P6076 = "559_1306916577.75068" 
    capture_lex $P6076
    .const 'Sub' $P6068 = "558_1306916577.75068" 
    capture_lex $P6068
    .const 'Sub' $P6024 = "556_1306916577.75068" 
    capture_lex $P6024
    .const 'Sub' $P6009 = "555_1306916577.75068" 
    capture_lex $P6009
    .const 'Sub' $P5986 = "554_1306916577.75068" 
    capture_lex $P5986
    .const 'Sub' $P5883 = "553_1306916577.75068" 
    capture_lex $P5883
    .const 'Sub' $P5829 = "550_1306916577.75068" 
    capture_lex $P5829
    .const 'Sub' $P5687 = "547_1306916577.75068" 
    capture_lex $P5687
    .const 'Sub' $P5360 = "540_1306916577.75068" 
    capture_lex $P5360
    .const 'Sub' $P5352 = "539_1306916577.75068" 
    capture_lex $P5352
    .const 'Sub' $P5344 = "538_1306916577.75068" 
    capture_lex $P5344
    .const 'Sub' $P5201 = "535_1306916577.75068" 
    capture_lex $P5201
    .const 'Sub' $P5193 = "534_1306916577.75068" 
    capture_lex $P5193
    .const 'Sub' $P5178 = "533_1306916577.75068" 
    capture_lex $P5178
    .const 'Sub' $P5163 = "532_1306916577.75068" 
    capture_lex $P5163
    .const 'Sub' $P5148 = "531_1306916577.75068" 
    capture_lex $P5148
    .const 'Sub' $P5126 = "530_1306916577.75068" 
    capture_lex $P5126
    .const 'Sub' $P5118 = "529_1306916577.75068" 
    capture_lex $P5118
    .const 'Sub' $P5110 = "528_1306916577.75068" 
    capture_lex $P5110
    .const 'Sub' $P5102 = "527_1306916577.75068" 
    capture_lex $P5102
    .const 'Sub' $P4868 = "521_1306916577.75068" 
    capture_lex $P4868
    .const 'Sub' $P4769 = "520_1306916577.75068" 
    capture_lex $P4769
    .const 'Sub' $P4761 = "519_1306916577.75068" 
    capture_lex $P4761
    .const 'Sub' $P4753 = "518_1306916577.75068" 
    capture_lex $P4753
    .const 'Sub' $P4745 = "517_1306916577.75068" 
    capture_lex $P4745
    .const 'Sub' $P4737 = "516_1306916577.75068" 
    capture_lex $P4737
    .const 'Sub' $P4729 = "515_1306916577.75068" 
    capture_lex $P4729
    .const 'Sub' $P4721 = "514_1306916577.75068" 
    capture_lex $P4721
    .const 'Sub' $P4518 = "508_1306916577.75068" 
    capture_lex $P4518
    .const 'Sub' $P4491 = "507_1306916577.75068" 
    capture_lex $P4491
    .const 'Sub' $P4477 = "506_1306916577.75068" 
    capture_lex $P4477
    .const 'Sub' $P4469 = "505_1306916577.75068" 
    capture_lex $P4469
    .const 'Sub' $P4461 = "504_1306916577.75068" 
    capture_lex $P4461
    .const 'Sub' $P4453 = "503_1306916577.75068" 
    capture_lex $P4453
    .const 'Sub' $P4445 = "502_1306916577.75068" 
    capture_lex $P4445
    .const 'Sub' $P4437 = "501_1306916577.75068" 
    capture_lex $P4437
    .const 'Sub' $P4429 = "500_1306916577.75068" 
    capture_lex $P4429
    .const 'Sub' $P4421 = "499_1306916577.75068" 
    capture_lex $P4421
    .const 'Sub' $P4413 = "498_1306916577.75068" 
    capture_lex $P4413
    .const 'Sub' $P4405 = "497_1306916577.75068" 
    capture_lex $P4405
    .const 'Sub' $P4397 = "496_1306916577.75068" 
    capture_lex $P4397
    .const 'Sub' $P4389 = "495_1306916577.75068" 
    capture_lex $P4389
    .const 'Sub' $P4381 = "494_1306916577.75068" 
    capture_lex $P4381
    .const 'Sub' $P4373 = "493_1306916577.75068" 
    capture_lex $P4373
    .const 'Sub' $P4357 = "492_1306916577.75068" 
    capture_lex $P4357
    .const 'Sub' $P4303 = "491_1306916577.75068" 
    capture_lex $P4303
    .const 'Sub' $P4286 = "490_1306916577.75068" 
    capture_lex $P4286
    .const 'Sub' $P4262 = "489_1306916577.75068" 
    capture_lex $P4262
    .const 'Sub' $P4239 = "488_1306916577.75068" 
    capture_lex $P4239
    .const 'Sub' $P4212 = "487_1306916577.75068" 
    capture_lex $P4212
    .const 'Sub' $P4175 = "486_1306916577.75068" 
    capture_lex $P4175
    .const 'Sub' $P4160 = "485_1306916577.75068" 
    capture_lex $P4160
    .const 'Sub' $P4148 = "484_1306916577.75068" 
    capture_lex $P4148
    .const 'Sub' $P4097 = "482_1306916577.75068" 
    capture_lex $P4097
    .const 'Sub' $P4072 = "481_1306916577.75068" 
    capture_lex $P4072
    .const 'Sub' $P4065 = "480_1306916577.75068" 
    capture_lex $P4065
    .const 'Sub' $P4023 = "479_1306916577.75068" 
    capture_lex $P4023
    .const 'Sub' $P3973 = "477_1306916577.75068" 
    capture_lex $P3973
    .const 'Sub' $P3956 = "476_1306916577.75068" 
    capture_lex $P3956
    .const 'Sub' $P3917 = "474_1306916577.75068" 
    capture_lex $P3917
    .const 'Sub' $P3909 = "473_1306916577.75068" 
    capture_lex $P3909
    .const 'Sub' $P3901 = "472_1306916577.75068" 
    capture_lex $P3901
    .const 'Sub' $P3884 = "471_1306916577.75068" 
    capture_lex $P3884
    .const 'Sub' $P3788 = "469_1306916577.75068" 
    capture_lex $P3788
    .const 'Sub' $P3744 = "467_1306916577.75068" 
    capture_lex $P3744
    .const 'Sub' $P3567 = "465_1306916577.75068" 
    capture_lex $P3567
    .const 'Sub' $P3536 = "464_1306916577.75068" 
    capture_lex $P3536
    .const 'Sub' $P3528 = "463_1306916577.75068" 
    capture_lex $P3528
    .const 'Sub' $P3399 = "457_1306916577.75068" 
    capture_lex $P3399
    .const 'Sub' $P3364 = "455_1306916577.75068" 
    capture_lex $P3364
    .const 'Sub' $P3359 = "454_1306916577.75068" 
    capture_lex $P3359
    .const 'Sub' $P3354 = "453_1306916577.75068" 
    capture_lex $P3354
    .const 'Sub' $P3241 = "450_1306916577.75068" 
    capture_lex $P3241
    .const 'Sub' $P3223 = "449_1306916577.75068" 
    capture_lex $P3223
    .const 'Sub' $P3148 = "447_1306916577.75068" 
    capture_lex $P3148
    .const 'Sub' $P3133 = "446_1306916577.75068" 
    capture_lex $P3133
    .const 'Sub' $P3046 = "445_1306916577.75068" 
    capture_lex $P3046
    .const 'Sub' $P3020 = "443_1306916577.75068" 
    capture_lex $P3020
    .const 'Sub' $P3004 = "442_1306916577.75068" 
    capture_lex $P3004
    .const 'Sub' $P2980 = "441_1306916577.75068" 
    capture_lex $P2980
    .const 'Sub' $P2944 = "438_1306916577.75068" 
    capture_lex $P2944
    .const 'Sub' $P2936 = "437_1306916577.75068" 
    capture_lex $P2936
.annotate 'line', 1205
    .const 'Sub' $P2936 = "437_1306916577.75068" 
    newclosure $P2943, $P2936
    .lex "xblock_immediate", $P2943
.annotate 'line', 1210
    .const 'Sub' $P2944 = "438_1306916577.75068" 
    newclosure $P2979, $P2944
    .lex "block_immediate", $P2979
.annotate 'line', 1220
    .const 'Sub' $P2980 = "441_1306916577.75068" 
    newclosure $P3003, $P2980
    .lex "vivitype", $P3003
.annotate 'line', 1239
    .const 'Sub' $P3004 = "442_1306916577.75068" 
    newclosure $P3019, $P3004
    .lex "colonpair_str", $P3019
.annotate 'line', 1418
    .const 'Sub' $P3020 = "443_1306916577.75068" 
    newclosure $P3045, $P3020
    .lex "import_HOW_exports", $P3045
.annotate 'line', 1523
    .const 'Sub' $P3046 = "445_1306916577.75068" 
    newclosure $P3132, $P3046
    .lex "push_block_handler", $P3132
.annotate 'line', 2068
    .const 'Sub' $P3133 = "446_1306916577.75068" 
    newclosure $P3147, $P3133
    .lex "only_star_block", $P3147
.annotate 'line', 2077
    .const 'Sub' $P3148 = "447_1306916577.75068" 
    newclosure $P3222, $P3148
    .lex "attach_multi_signature", $P3222
.annotate 'line', 2540
    .const 'Sub' $P3223 = "449_1306916577.75068" 
    newclosure $P3240, $P3223
    .lex "control", $P3240
.annotate 'line', 2559
    .const 'Sub' $P3241 = "450_1306916577.75068" 
    newclosure $P3353, $P3241
    .lex "lexical_package_lookup", $P3353
.annotate 'line', 2608
    .const 'Sub' $P3354 = "453_1306916577.75068" 
    newclosure $P3358, $P3354
    .lex "is_lexical", $P3358
.annotate 'line', 2614
    .const 'Sub' $P3359 = "454_1306916577.75068" 
    newclosure $P3363, $P3359
    .lex "is_package", $P3363
.annotate 'line', 2620
    .const 'Sub' $P3364 = "455_1306916577.75068" 
    newclosure $P3398, $P3364
    .lex "is_scope", $P3398
.annotate 'line', 2643
    .const 'Sub' $P3399 = "457_1306916577.75068" 
    newclosure $P3519, $P3399
    .lex "find_sym", $P3519
.annotate 'line', 1201
    .lex "$?PACKAGE", $P3520
    .lex "$?CLASS", $P3521
.annotate 'line', 1203
    new $P3522, "ResizablePMCArray"
    find_lex $P3523, "$?PACKAGE"
    get_who $P3524, $P3523
    set $P3524["@BLOCK"], $P3522
    find_lex $P3525, "xblock_immediate"
    find_lex $P3526, "block_immediate"
    find_lex $P3527, "vivitype"
.annotate 'line', 1231
    find_lex $P3566, "colonpair_str"
.annotate 'line', 1401
    find_lex $P4022, "import_HOW_exports"
.annotate 'line', 1516
    find_lex $P4285, "push_block_handler"
.annotate 'line', 2009
    find_lex $P5827, "only_star_block"
    find_lex $P5828, "attach_multi_signature"
.annotate 'line', 2531
    find_lex $P7140, "control"
.annotate 'line', 2553
    find_lex $P7167, "lexical_package_lookup"
    find_lex $P7168, "is_lexical"
    find_lex $P7169, "is_package"
    find_lex $P7170, "is_scope"
.annotate 'line', 2631
    find_lex $P7190, "find_sym"
.annotate 'line', 1201
    .return ($P7190)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("437_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_2937
.annotate 'line', 1205
    .lex "$xblock", param_2937
.annotate 'line', 1206
    find_lex $P2938, "$xblock"
    unless_null $P2938, vivify_1714
    $P2938 = root_new ['parrot';'ResizablePMCArray']
  vivify_1714:
    set $P2939, $P2938[1]
    unless_null $P2939, vivify_1715
    new $P2939, "Undef"
  vivify_1715:
    $P2940 = "block_immediate"($P2939)
    find_lex $P2941, "$xblock"
    unless_null $P2941, vivify_1716
    $P2941 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2941
  vivify_1716:
    set $P2941[1], $P2940
    find_lex $P2942, "$xblock"
    unless_null $P2942, vivify_1717
    new $P2942, "Undef"
  vivify_1717:
.annotate 'line', 1205
    .return ($P2942)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("438_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_2945
.annotate 'line', 1210
    .const 'Sub' $P2955 = "439_1306916577.75068" 
    capture_lex $P2955
    .lex "$block", param_2945
.annotate 'line', 1211
    find_lex $P2946, "$block"
    unless_null $P2946, vivify_1718
    new $P2946, "Undef"
  vivify_1718:
    $P2946."blocktype"("immediate")
.annotate 'line', 1212
    find_lex $P2950, "$block"
    unless_null $P2950, vivify_1719
    new $P2950, "Undef"
  vivify_1719:
    $P2951 = $P2950."symtable"()
    unless $P2951, unless_2949
    set $P2948, $P2951
    goto unless_2949_end
  unless_2949:
    find_lex $P2952, "$block"
    unless_null $P2952, vivify_1720
    new $P2952, "Undef"
  vivify_1720:
    $P2953 = $P2952."handlers"()
    set $P2948, $P2953
  unless_2949_end:
    if $P2948, unless_2947_end
    .const 'Sub' $P2955 = "439_1306916577.75068" 
    capture_lex $P2955
    $P2955()
  unless_2947_end:
    find_lex $P2978, "$block"
    unless_null $P2978, vivify_1727
    new $P2978, "Undef"
  vivify_1727:
.annotate 'line', 1210
    .return ($P2978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2954"  :anon :subid("439_1306916577.75068") :outer("438_1306916577.75068")
.annotate 'line', 1212
    .const 'Sub' $P2969 = "440_1306916577.75068" 
    capture_lex $P2969
.annotate 'line', 1213
    new $P2956, "Undef"
    .lex "$stmts", $P2956
    get_hll_global $P2957, "GLOBAL"
    nqp_get_package_through_who $P2958, $P2957, "PAST"
    get_who $P2959, $P2958
    set $P2960, $P2959["Stmts"]
    find_lex $P2961, "$block"
    unless_null $P2961, vivify_1721
    new $P2961, "Undef"
  vivify_1721:
    $P2962 = $P2960."new"($P2961 :named("node"))
    store_lex "$stmts", $P2962
.annotate 'line', 1214
    find_lex $P2964, "$block"
    unless_null $P2964, vivify_1722
    new $P2964, "Undef"
  vivify_1722:
    $P2965 = $P2964."list"()
    defined $I2966, $P2965
    unless $I2966, for_undef_1723
    iter $P2963, $P2965
    new $P2975, 'ExceptionHandler'
    set_label $P2975, loop2974_handler
    $P2975."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2975
  loop2974_test:
    unless $P2963, loop2974_done
    shift $P2967, $P2963
  loop2974_redo:
    .const 'Sub' $P2969 = "440_1306916577.75068" 
    capture_lex $P2969
    $P2969($P2967)
  loop2974_next:
    goto loop2974_test
  loop2974_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2976, exception, 'type'
    eq $P2976, .CONTROL_LOOP_NEXT, loop2974_next
    eq $P2976, .CONTROL_LOOP_REDO, loop2974_redo
  loop2974_done:
    pop_eh 
  for_undef_1723:
.annotate 'line', 1215
    find_lex $P2977, "$stmts"
    unless_null $P2977, vivify_1726
    new $P2977, "Undef"
  vivify_1726:
    store_lex "$block", $P2977
.annotate 'line', 1212
    .return ($P2977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2968"  :anon :subid("440_1306916577.75068") :outer("439_1306916577.75068")
    .param pmc param_2970
.annotate 'line', 1214
    .lex "$_", param_2970
    find_lex $P2971, "$stmts"
    unless_null $P2971, vivify_1724
    new $P2971, "Undef"
  vivify_1724:
    find_lex $P2972, "$_"
    unless_null $P2972, vivify_1725
    new $P2972, "Undef"
  vivify_1725:
    $P2973 = $P2971."push"($P2972)
    .return ($P2973)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("441_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_2981
.annotate 'line', 1220
    .lex "$sigil", param_2981
.annotate 'line', 1221
    find_lex $P2984, "$sigil"
    unless_null $P2984, vivify_1728
    new $P2984, "Undef"
  vivify_1728:
    set $S2985, $P2984
    iseq $I2986, $S2985, "%"
    if $I2986, if_2983
.annotate 'line', 1223
    find_lex $P2994, "$sigil"
    unless_null $P2994, vivify_1729
    new $P2994, "Undef"
  vivify_1729:
    set $S2995, $P2994
    iseq $I2996, $S2995, "@"
    if $I2996, if_2993
    new $P3002, "String"
    assign $P3002, "Undef"
    set $P2992, $P3002
    goto if_2993_end
  if_2993:
.annotate 'line', 1224
    get_hll_global $P2997, "GLOBAL"
    nqp_get_package_through_who $P2998, $P2997, "PAST"
    get_who $P2999, $P2998
    set $P3000, $P2999["Op"]
    $P3001 = $P3000."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2992, $P3001
  if_2993_end:
    set $P2982, $P2992
.annotate 'line', 1221
    goto if_2983_end
  if_2983:
.annotate 'line', 1222
    get_hll_global $P2987, "GLOBAL"
    nqp_get_package_through_who $P2988, $P2987, "PAST"
    get_who $P2989, $P2988
    set $P2990, $P2989["Op"]
    $P2991 = $P2990."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2982, $P2991
  if_2983_end:
.annotate 'line', 1220
    .return ($P2982)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("442_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3005
.annotate 'line', 1239
    .lex "$ast", param_3005
.annotate 'line', 1240
    get_hll_global $P3008, "GLOBAL"
    nqp_get_package_through_who $P3009, $P3008, "PAST"
    get_who $P3010, $P3009
    set $P3011, $P3010["Op"]
    find_lex $P3012, "$ast"
    unless_null $P3012, vivify_1730
    new $P3012, "Undef"
  vivify_1730:
    $P3013 = $P3011."ACCEPTS"($P3012)
    if $P3013, if_3007
.annotate 'line', 1242
    find_lex $P3017, "$ast"
    unless_null $P3017, vivify_1731
    new $P3017, "Undef"
  vivify_1731:
    $P3018 = $P3017."value"()
    set $P3006, $P3018
.annotate 'line', 1240
    goto if_3007_end
  if_3007:
.annotate 'line', 1241
    find_lex $P3014, "$ast"
    unless_null $P3014, vivify_1732
    new $P3014, "Undef"
  vivify_1732:
    $P3015 = $P3014."list"()
    join $S3016, " ", $P3015
    new $P3006, 'String'
    set $P3006, $S3016
  if_3007_end:
.annotate 'line', 1239
    .return ($P3006)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("443_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3021
.annotate 'line', 1418
    .const 'Sub' $P3033 = "444_1306916577.75068" 
    capture_lex $P3033
    .lex "$UNIT", param_3021
.annotate 'line', 1420
    find_lex $P3024, "$UNIT"
    unless_null $P3024, vivify_1733
    new $P3024, "Undef"
  vivify_1733:
    exists $I3025, $P3024["EXPORTHOW"]
    if $I3025, if_3023
    new $P3022, 'Integer'
    set $P3022, $I3025
    goto if_3023_end
  if_3023:
.annotate 'line', 1421
    find_lex $P3027, "$UNIT"
    unless_null $P3027, vivify_1734
    $P3027 = root_new ['parrot';'Hash']
  vivify_1734:
    set $P3028, $P3027["EXPORTHOW"]
    unless_null $P3028, vivify_1735
    new $P3028, "Undef"
  vivify_1735:
    get_who $P3029, $P3028
    defined $I3030, $P3029
    unless $I3030, for_undef_1736
    iter $P3026, $P3029
    new $P3043, 'ExceptionHandler'
    set_label $P3043, loop3042_handler
    $P3043."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3043
  loop3042_test:
    unless $P3026, loop3042_done
    shift $P3031, $P3026
  loop3042_redo:
    .const 'Sub' $P3033 = "444_1306916577.75068" 
    capture_lex $P3033
    $P3033($P3031)
  loop3042_next:
    goto loop3042_test
  loop3042_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3044, exception, 'type'
    eq $P3044, .CONTROL_LOOP_NEXT, loop3042_next
    eq $P3044, .CONTROL_LOOP_REDO, loop3042_redo
  loop3042_done:
    pop_eh 
  for_undef_1736:
.annotate 'line', 1420
    set $P3022, $P3026
  if_3023_end:
.annotate 'line', 1418
    .return ($P3022)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3032"  :anon :subid("444_1306916577.75068") :outer("443_1306916577.75068")
    .param pmc param_3034
.annotate 'line', 1421
    .lex "$_", param_3034
.annotate 'line', 1422
    find_lex $P3035, "$_"
    unless_null $P3035, vivify_1737
    new $P3035, "Undef"
  vivify_1737:
    $P3036 = $P3035."value"()
    find_lex $P3037, "$_"
    unless_null $P3037, vivify_1738
    new $P3037, "Undef"
  vivify_1738:
    $P3038 = $P3037."key"()
    find_dynamic_lex $P3041, "%*HOW"
    unless_null $P3041, vivify_1739
    get_hll_global $P3039, "GLOBAL"
    get_who $P3040, $P3039
    set $P3041, $P3040["%HOW"]
    unless_null $P3041, vivify_1740
    die "Contextual %*HOW not found"
  vivify_1740:
    store_dynamic_lex "%*HOW", $P3041
  vivify_1739:
    set $P3041[$P3038], $P3036
.annotate 'line', 1421
    .return ($P3036)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("445_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3047
    .param pmc param_3048
.annotate 'line', 1523
    .lex "$/", param_3047
    .lex "$block", param_3048
.annotate 'line', 1524
    find_lex $P3050, "$?PACKAGE"
    get_who $P3051, $P3050
    set $P3052, $P3051["@BLOCK"]
    unless_null $P3052, vivify_1741
    $P3052 = root_new ['parrot';'ResizablePMCArray']
  vivify_1741:
    set $P3053, $P3052[0]
    unless_null $P3053, vivify_1742
    new $P3053, "Undef"
  vivify_1742:
    $P3054 = $P3053."handlers"()
    if $P3054, unless_3049_end
.annotate 'line', 1525
    find_lex $P3055, "$?PACKAGE"
    get_who $P3056, $P3055
    set $P3057, $P3056["@BLOCK"]
    unless_null $P3057, vivify_1743
    $P3057 = root_new ['parrot';'ResizablePMCArray']
  vivify_1743:
    set $P3058, $P3057[0]
    unless_null $P3058, vivify_1744
    new $P3058, "Undef"
  vivify_1744:
    new $P3059, "ResizablePMCArray"
    $P3058."handlers"($P3059)
  unless_3049_end:
.annotate 'line', 1527
    find_lex $P3061, "$block"
    unless_null $P3061, vivify_1745
    new $P3061, "Undef"
  vivify_1745:
    $P3062 = $P3061."arity"()
    if $P3062, unless_3060_end
.annotate 'line', 1528
    find_lex $P3063, "$block"
    unless_null $P3063, vivify_1746
    new $P3063, "Undef"
  vivify_1746:
.annotate 'line', 1529
    get_hll_global $P3064, "GLOBAL"
    nqp_get_package_through_who $P3065, $P3064, "PAST"
    get_who $P3066, $P3065
    set $P3067, $P3066["Op"]
.annotate 'line', 1530
    get_hll_global $P3068, "GLOBAL"
    nqp_get_package_through_who $P3069, $P3068, "PAST"
    get_who $P3070, $P3069
    set $P3071, $P3070["Var"]
    $P3072 = $P3071."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1531
    get_hll_global $P3073, "GLOBAL"
    nqp_get_package_through_who $P3074, $P3073, "PAST"
    get_who $P3075, $P3074
    set $P3076, $P3075["Var"]
    $P3077 = $P3076."new"("lexical" :named("scope"), "$_" :named("name"))
    $P3078 = $P3067."new"($P3072, $P3077, "bind" :named("pasttype"))
.annotate 'line', 1529
    $P3063."unshift"($P3078)
.annotate 'line', 1534
    find_lex $P3079, "$block"
    unless_null $P3079, vivify_1747
    new $P3079, "Undef"
  vivify_1747:
    get_hll_global $P3080, "GLOBAL"
    nqp_get_package_through_who $P3081, $P3080, "PAST"
    get_who $P3082, $P3081
    set $P3083, $P3082["Var"]
    $P3084 = $P3083."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3079."unshift"($P3084)
.annotate 'line', 1535
    find_lex $P3085, "$block"
    unless_null $P3085, vivify_1748
    new $P3085, "Undef"
  vivify_1748:
    $P3085."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1536
    find_lex $P3086, "$block"
    unless_null $P3086, vivify_1749
    new $P3086, "Undef"
  vivify_1749:
    $P3086."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1537
    find_lex $P3087, "$block"
    unless_null $P3087, vivify_1750
    new $P3087, "Undef"
  vivify_1750:
    $P3087."arity"(1)
  unless_3060_end:
.annotate 'line', 1539
    find_lex $P3088, "$block"
    unless_null $P3088, vivify_1751
    new $P3088, "Undef"
  vivify_1751:
    $P3088."blocktype"("declaration")
.annotate 'line', 1540
    find_lex $P3089, "$?PACKAGE"
    get_who $P3090, $P3089
    set $P3091, $P3090["@BLOCK"]
    unless_null $P3091, vivify_1752
    $P3091 = root_new ['parrot';'ResizablePMCArray']
  vivify_1752:
    set $P3092, $P3091[0]
    unless_null $P3092, vivify_1753
    new $P3092, "Undef"
  vivify_1753:
    $P3093 = $P3092."handlers"()
.annotate 'line', 1541
    get_hll_global $P3094, "GLOBAL"
    nqp_get_package_through_who $P3095, $P3094, "PAST"
    get_who $P3096, $P3095
    set $P3097, $P3096["Control"]
    find_lex $P3098, "$/"
    unless_null $P3098, vivify_1754
    new $P3098, "Undef"
  vivify_1754:
.annotate 'line', 1543
    get_hll_global $P3099, "GLOBAL"
    nqp_get_package_through_who $P3100, $P3099, "PAST"
    get_who $P3101, $P3100
    set $P3102, $P3101["Stmts"]
.annotate 'line', 1544
    get_hll_global $P3103, "GLOBAL"
    nqp_get_package_through_who $P3104, $P3103, "PAST"
    get_who $P3105, $P3104
    set $P3106, $P3105["Op"]
    find_lex $P3107, "$block"
    unless_null $P3107, vivify_1755
    new $P3107, "Undef"
  vivify_1755:
.annotate 'line', 1546
    get_hll_global $P3108, "GLOBAL"
    nqp_get_package_through_who $P3109, $P3108, "PAST"
    get_who $P3110, $P3109
    set $P3111, $P3110["Var"]
    $P3112 = $P3111."new"("register" :named("scope"), "exception" :named("name"))
    $P3113 = $P3106."new"($P3107, $P3112, "call" :named("pasttype"))
.annotate 'line', 1548
    get_hll_global $P3114, "GLOBAL"
    nqp_get_package_through_who $P3115, $P3114, "PAST"
    get_who $P3116, $P3115
    set $P3117, $P3116["Op"]
.annotate 'line', 1549
    get_hll_global $P3118, "GLOBAL"
    nqp_get_package_through_who $P3119, $P3118, "PAST"
    get_who $P3120, $P3119
    set $P3121, $P3120["Var"]
.annotate 'line', 1550
    get_hll_global $P3122, "GLOBAL"
    nqp_get_package_through_who $P3123, $P3122, "PAST"
    get_who $P3124, $P3123
    set $P3125, $P3124["Var"]
    $P3126 = $P3125."new"("register" :named("scope"), "exception" :named("name"))
    $P3127 = $P3121."new"($P3126, "handled", "keyed" :named("scope"))
.annotate 'line', 1549
    $P3128 = $P3117."new"($P3127, 1, "bind" :named("pasttype"))
.annotate 'line', 1548
    $P3129 = $P3102."new"($P3113, $P3128)
.annotate 'line', 1543
    $P3130 = $P3097."new"($P3129, $P3098 :named("node"))
.annotate 'line', 1541
    $P3131 = $P3093."unshift"($P3130)
.annotate 'line', 1523
    .return ($P3131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("446_1306916577.75068") :outer("436_1306916577.75068")
.annotate 'line', 2069
    new $P3134, "Undef"
    .lex "$past", $P3134
    find_lex $P3135, "$?PACKAGE"
    get_who $P3136, $P3135
    set $P3137, $P3136["@BLOCK"]
    unless_null $P3137, vivify_1756
    $P3137 = root_new ['parrot';'ResizablePMCArray']
  vivify_1756:
    $P3138 = $P3137."shift"()
    store_lex "$past", $P3138
.annotate 'line', 2070
    find_lex $P3139, "$past"
    unless_null $P3139, vivify_1757
    new $P3139, "Undef"
  vivify_1757:
    $P3139."closure"(1)
.annotate 'line', 2071
    find_lex $P3140, "$past"
    unless_null $P3140, vivify_1758
    new $P3140, "Undef"
  vivify_1758:
    get_hll_global $P3141, "GLOBAL"
    nqp_get_package_through_who $P3142, $P3141, "PAST"
    get_who $P3143, $P3142
    set $P3144, $P3143["Op"]
    $P3145 = $P3144."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P3140."push"($P3145)
    find_lex $P3146, "$past"
    unless_null $P3146, vivify_1759
    new $P3146, "Undef"
  vivify_1759:
.annotate 'line', 2068
    .return ($P3146)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("447_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3149
.annotate 'line', 2077
    .const 'Sub' $P3169 = "448_1306916577.75068" 
    capture_lex $P3169
    .lex "$routine", param_3149
.annotate 'line', 2081
    new $P3150, "Undef"
    .lex "$types", $P3150
.annotate 'line', 2082
    new $P3151, "Undef"
    .lex "$definednesses", $P3151
.annotate 'line', 2081
    get_hll_global $P3152, "GLOBAL"
    nqp_get_package_through_who $P3153, $P3152, "PAST"
    get_who $P3154, $P3153
    set $P3155, $P3154["Op"]
    $P3156 = $P3155."new"("list" :named("pasttype"))
    store_lex "$types", $P3156
.annotate 'line', 2082
    get_hll_global $P3157, "GLOBAL"
    nqp_get_package_through_who $P3158, $P3157, "PAST"
    get_who $P3159, $P3158
    set $P3160, $P3159["Op"]
    $P3161 = $P3160."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P3161
.annotate 'line', 2083
    find_lex $P3163, "$routine"
    unless_null $P3163, vivify_1760
    $P3163 = root_new ['parrot';'ResizablePMCArray']
  vivify_1760:
    set $P3164, $P3163[0]
    unless_null $P3164, vivify_1761
    new $P3164, "Undef"
  vivify_1761:
    $P3165 = $P3164."list"()
    defined $I3166, $P3165
    unless $I3166, for_undef_1762
    iter $P3162, $P3165
    new $P3213, 'ExceptionHandler'
    set_label $P3213, loop3212_handler
    $P3213."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3213
  loop3212_test:
    unless $P3162, loop3212_done
    shift $P3167, $P3162
  loop3212_redo:
    .const 'Sub' $P3169 = "448_1306916577.75068" 
    capture_lex $P3169
    $P3169($P3167)
  loop3212_next:
    goto loop3212_test
  loop3212_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3214, exception, 'type'
    eq $P3214, .CONTROL_LOOP_NEXT, loop3212_next
    eq $P3214, .CONTROL_LOOP_REDO, loop3212_redo
  loop3212_done:
    pop_eh 
  for_undef_1762:
.annotate 'line', 2090
    find_dynamic_lex $P3217, "$*SC"
    unless_null $P3217, vivify_1772
    get_hll_global $P3215, "GLOBAL"
    get_who $P3216, $P3215
    set $P3217, $P3216["$SC"]
    unless_null $P3217, vivify_1773
    die "Contextual $*SC not found"
  vivify_1773:
  vivify_1772:
    find_lex $P3218, "$routine"
    unless_null $P3218, vivify_1774
    new $P3218, "Undef"
  vivify_1774:
    find_lex $P3219, "$types"
    unless_null $P3219, vivify_1775
    new $P3219, "Undef"
  vivify_1775:
    find_lex $P3220, "$definednesses"
    unless_null $P3220, vivify_1776
    new $P3220, "Undef"
  vivify_1776:
    $P3221 = $P3217."set_routine_signature"($P3218, $P3219, $P3220)
.annotate 'line', 2077
    .return ($P3221)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3168"  :anon :subid("448_1306916577.75068") :outer("447_1306916577.75068")
    .param pmc param_3170
.annotate 'line', 2083
    .lex "$_", param_3170
.annotate 'line', 2084
    get_hll_global $P3175, "GLOBAL"
    nqp_get_package_through_who $P3176, $P3175, "PAST"
    get_who $P3177, $P3176
    set $P3178, $P3177["Var"]
    find_lex $P3179, "$_"
    unless_null $P3179, vivify_1763
    new $P3179, "Undef"
  vivify_1763:
    $P3180 = $P3178."ACCEPTS"($P3179)
    if $P3180, if_3174
    set $P3173, $P3180
    goto if_3174_end
  if_3174:
    find_lex $P3181, "$_"
    unless_null $P3181, vivify_1764
    new $P3181, "Undef"
  vivify_1764:
    $S3182 = $P3181."scope"()
    iseq $I3183, $S3182, "parameter"
    new $P3173, 'Integer'
    set $P3173, $I3183
  if_3174_end:
    if $P3173, if_3172
    set $P3171, $P3173
    goto if_3172_end
  if_3172:
.annotate 'line', 2085
    find_lex $P3184, "$types"
    unless_null $P3184, vivify_1765
    new $P3184, "Undef"
  vivify_1765:
    find_lex $P3186, "$_"
    unless_null $P3186, vivify_1766
    new $P3186, "Undef"
  vivify_1766:
    $P3187 = $P3186."multitype"()
    set $P3185, $P3187
    defined $I3189, $P3185
    if $I3189, default_3188
    get_hll_global $P3190, "GLOBAL"
    nqp_get_package_through_who $P3191, $P3190, "PAST"
    get_who $P3192, $P3191
    set $P3193, $P3192["Op"]
    $P3194 = $P3193."new"("null P" :named("pirop"))
    set $P3185, $P3194
  default_3188:
    $P3184."push"($P3185)
.annotate 'line', 2086
    find_lex $P3195, "$definednesses"
    unless_null $P3195, vivify_1767
    new $P3195, "Undef"
  vivify_1767:
    find_lex $P3198, "$_"
    unless_null $P3198, vivify_1768
    $P3198 = root_new ['parrot';'Hash']
  vivify_1768:
    set $P3199, $P3198["definedness"]
    unless_null $P3199, vivify_1769
    new $P3199, "Undef"
  vivify_1769:
    set $S3200, $P3199
    iseq $I3201, $S3200, "D"
    if $I3201, if_3197
.annotate 'line', 2087
    find_lex $P3205, "$_"
    unless_null $P3205, vivify_1770
    $P3205 = root_new ['parrot';'Hash']
  vivify_1770:
    set $P3206, $P3205["definedness"]
    unless_null $P3206, vivify_1771
    new $P3206, "Undef"
  vivify_1771:
    set $S3207, $P3206
    iseq $I3208, $S3207, "U"
    if $I3208, if_3204
    new $P3210, "Integer"
    assign $P3210, 0
    set $P3203, $P3210
    goto if_3204_end
  if_3204:
    new $P3209, "Integer"
    assign $P3209, 2
    set $P3203, $P3209
  if_3204_end:
    set $P3196, $P3203
.annotate 'line', 2086
    goto if_3197_end
  if_3197:
    new $P3202, "Integer"
    assign $P3202, 1
    set $P3196, $P3202
  if_3197_end:
    $P3211 = $P3195."push"($P3196)
.annotate 'line', 2084
    set $P3171, $P3211
  if_3172_end:
.annotate 'line', 2083
    .return ($P3171)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("449_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3224
    .param pmc param_3225
.annotate 'line', 2540
    .lex "$/", param_3224
    .lex "$type", param_3225
.annotate 'line', 2541
    find_lex $P3226, "$/"
    get_hll_global $P3227, "GLOBAL"
    nqp_get_package_through_who $P3228, $P3227, "PAST"
    get_who $P3229, $P3228
    set $P3230, $P3229["Op"]
    find_lex $P3231, "$/"
    unless_null $P3231, vivify_1777
    new $P3231, "Undef"
  vivify_1777:
.annotate 'line', 2545
    get_hll_global $P3232, "GLOBAL"
    nqp_get_package_through_who $P3233, $P3232, "PAST"
    get_who $P3234, $P3233
    set $P3235, $P3234["Val"]
    find_lex $P3236, "$type"
    unless_null $P3236, vivify_1778
    new $P3236, "Undef"
  vivify_1778:
    $P3237 = $P3235."new"($P3236 :named("value"), "!except_types" :named("returns"))
    $P3238 = $P3230."new"(0, $P3237, $P3231 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2541
    $P3239 = $P3226."!make"($P3238)
.annotate 'line', 2540
    .return ($P3239)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("450_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3244
    .param pmc param_3245
.annotate 'line', 2559
    .const 'Sub' $P3298 = "451_1306916577.75068" 
    capture_lex $P3298
    new $P3243, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3243, control_3242
    push_eh $P3243
    .lex "@name", param_3244
    .lex "$/", param_3245
.annotate 'line', 2565
    new $P3246, "Undef"
    .lex "$final_name", $P3246
.annotate 'line', 2566
    new $P3247, "Undef"
    .lex "$lookup", $P3247
.annotate 'line', 2561
    find_lex $P3249, "@name"
    unless_null $P3249, vivify_1779
    $P3249 = root_new ['parrot';'ResizablePMCArray']
  vivify_1779:
    set $N3250, $P3249
    iseq $I3251, $N3250, 0.0
    unless $I3251, if_3248_end
    find_lex $P3252, "$/"
    unless_null $P3252, vivify_1780
    new $P3252, "Undef"
  vivify_1780:
    $P3253 = $P3252."CURSOR"()
    $P3253."panic"("Cannot compile empty name")
  if_3248_end:
.annotate 'line', 2565
    find_lex $P3254, "@name"
    unless_null $P3254, vivify_1781
    $P3254 = root_new ['parrot';'ResizablePMCArray']
  vivify_1781:
    $P3255 = $P3254."pop"()
    store_lex "$final_name", $P3255
.annotate 'line', 2566
    get_hll_global $P3256, "GLOBAL"
    nqp_get_package_through_who $P3257, $P3256, "PAST"
    get_who $P3258, $P3257
    set $P3259, $P3258["Var"]
    find_lex $P3260, "$final_name"
    unless_null $P3260, vivify_1782
    new $P3260, "Undef"
  vivify_1782:
    set $S3261, $P3260
    $P3262 = $P3259."new"($S3261, "keyed" :named("scope"))
    store_lex "$lookup", $P3262
.annotate 'line', 2570
    find_lex $P3264, "@name"
    unless_null $P3264, vivify_1783
    $P3264 = root_new ['parrot';'ResizablePMCArray']
  vivify_1783:
    set $N3265, $P3264
    iseq $I3266, $N3265, 0.0
    if $I3266, if_3263
.annotate 'line', 2588
    .const 'Sub' $P3298 = "451_1306916577.75068" 
    capture_lex $P3298
    $P3298()
    goto if_3263_end
  if_3263:
.annotate 'line', 2571
    find_lex $P3267, "$lookup"
    unless_null $P3267, vivify_1796
    new $P3267, "Undef"
  vivify_1796:
    get_hll_global $P3268, "GLOBAL"
    nqp_get_package_through_who $P3269, $P3268, "PAST"
    get_who $P3270, $P3269
    set $P3271, $P3270["Op"]
.annotate 'line', 2573
    get_hll_global $P3272, "GLOBAL"
    nqp_get_package_through_who $P3273, $P3272, "PAST"
    get_who $P3274, $P3273
    set $P3275, $P3274["Var"]
    $P3276 = $P3275."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3277 = $P3271."new"($P3276, "get_who PP" :named("pirop"))
.annotate 'line', 2571
    $P3267."unshift"($P3277)
.annotate 'line', 2575
    find_lex $P3278, "$lookup"
    unless_null $P3278, vivify_1797
    new $P3278, "Undef"
  vivify_1797:
    get_hll_global $P3279, "GLOBAL"
    nqp_get_package_through_who $P3280, $P3279, "PAST"
    get_who $P3281, $P3280
    set $P3282, $P3281["Var"]
.annotate 'line', 2577
    get_hll_global $P3283, "GLOBAL"
    nqp_get_package_through_who $P3284, $P3283, "PAST"
    get_who $P3285, $P3284
    set $P3286, $P3285["Op"]
.annotate 'line', 2579
    get_hll_global $P3287, "GLOBAL"
    nqp_get_package_through_who $P3288, $P3287, "PAST"
    get_who $P3289, $P3288
    set $P3290, $P3289["Var"]
    new $P3291, "ResizablePMCArray"
    $P3292 = $P3290."new"("GLOBAL" :named("name"), $P3291 :named("namespace"), "package" :named("scope"))
    $P3293 = $P3286."new"($P3292, "get_who PP" :named("pirop"))
.annotate 'line', 2581
    find_lex $P3294, "$final_name"
    unless_null $P3294, vivify_1798
    new $P3294, "Undef"
  vivify_1798:
    set $S3295, $P3294
    $P3296 = $P3282."new"($P3293, $S3295, "keyed" :named("scope"))
.annotate 'line', 2575
    $P3278."viviself"($P3296)
  if_3263_end:
.annotate 'line', 2603
    new $P3350, "Exception"
    set $P3350['type'], .CONTROL_RETURN
    find_lex $P3351, "$lookup"
    unless_null $P3351, vivify_1799
    new $P3351, "Undef"
  vivify_1799:
    setattribute $P3350, 'payload', $P3351
    throw $P3350
.annotate 'line', 2559
    .return ()
  control_3242:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3352, exception, "payload"
    .return ($P3352)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3297"  :anon :subid("451_1306916577.75068") :outer("450_1306916577.75068")
.annotate 'line', 2588
    .const 'Sub' $P3329 = "452_1306916577.75068" 
    capture_lex $P3329
.annotate 'line', 2589
    new $P3299, "Undef"
    .lex "$path", $P3299
    find_lex $P3302, "@name"
    unless_null $P3302, vivify_1784
    $P3302 = root_new ['parrot';'ResizablePMCArray']
  vivify_1784:
    set $P3303, $P3302[0]
    unless_null $P3303, vivify_1785
    new $P3303, "Undef"
  vivify_1785:
    $P3304 = "is_lexical"($P3303)
    if $P3304, if_3301
.annotate 'line', 2591
    get_hll_global $P3312, "GLOBAL"
    nqp_get_package_through_who $P3313, $P3312, "PAST"
    get_who $P3314, $P3313
    set $P3315, $P3314["Var"]
    new $P3316, "ResizablePMCArray"
    $P3317 = $P3315."new"("GLOBAL" :named("name"), $P3316 :named("namespace"), "package" :named("scope"))
    set $P3300, $P3317
.annotate 'line', 2589
    goto if_3301_end
  if_3301:
.annotate 'line', 2590
    get_hll_global $P3305, "GLOBAL"
    nqp_get_package_through_who $P3306, $P3305, "PAST"
    get_who $P3307, $P3306
    set $P3308, $P3307["Var"]
    find_lex $P3309, "@name"
    unless_null $P3309, vivify_1786
    $P3309 = root_new ['parrot';'ResizablePMCArray']
  vivify_1786:
    $P3310 = $P3309."shift"()
    $P3311 = $P3308."new"($P3310 :named("name"), "lexical" :named("scope"))
    set $P3300, $P3311
  if_3301_end:
.annotate 'line', 2589
    store_lex "$path", $P3300
.annotate 'line', 2592
    find_lex $P3319, "@name"
    unless_null $P3319, vivify_1787
    $P3319 = root_new ['parrot';'ResizablePMCArray']
  vivify_1787:
    set $P3320, $P3319[0]
    unless_null $P3320, vivify_1788
    new $P3320, "Undef"
  vivify_1788:
    set $S3321, $P3320
    iseq $I3322, $S3321, "GLOBAL"
    unless $I3322, if_3318_end
.annotate 'line', 2593
    find_lex $P3323, "@name"
    unless_null $P3323, vivify_1789
    $P3323 = root_new ['parrot';'ResizablePMCArray']
  vivify_1789:
    $P3323."shift"()
  if_3318_end:
.annotate 'line', 2595
    find_lex $P3325, "@name"
    unless_null $P3325, vivify_1790
    $P3325 = root_new ['parrot';'ResizablePMCArray']
  vivify_1790:
    defined $I3326, $P3325
    unless $I3326, for_undef_1791
    iter $P3324, $P3325
    new $P3340, 'ExceptionHandler'
    set_label $P3340, loop3339_handler
    $P3340."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3340
  loop3339_test:
    unless $P3324, loop3339_done
    shift $P3327, $P3324
  loop3339_redo:
    .const 'Sub' $P3329 = "452_1306916577.75068" 
    capture_lex $P3329
    $P3329($P3327)
  loop3339_next:
    goto loop3339_test
  loop3339_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3341, exception, 'type'
    eq $P3341, .CONTROL_LOOP_NEXT, loop3339_next
    eq $P3341, .CONTROL_LOOP_REDO, loop3339_redo
  loop3339_done:
    pop_eh 
  for_undef_1791:
.annotate 'line', 2600
    find_lex $P3342, "$lookup"
    unless_null $P3342, vivify_1794
    new $P3342, "Undef"
  vivify_1794:
    get_hll_global $P3343, "GLOBAL"
    nqp_get_package_through_who $P3344, $P3343, "PAST"
    get_who $P3345, $P3344
    set $P3346, $P3345["Op"]
    find_lex $P3347, "$path"
    unless_null $P3347, vivify_1795
    new $P3347, "Undef"
  vivify_1795:
    $P3348 = $P3346."new"($P3347, "get_who PP" :named("pirop"))
    $P3349 = $P3342."unshift"($P3348)
.annotate 'line', 2588
    .return ($P3349)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3328"  :anon :subid("452_1306916577.75068") :outer("451_1306916577.75068")
    .param pmc param_3330
.annotate 'line', 2595
    .lex "$_", param_3330
.annotate 'line', 2596
    get_hll_global $P3331, "GLOBAL"
    nqp_get_package_through_who $P3332, $P3331, "PAST"
    get_who $P3333, $P3332
    set $P3334, $P3333["Op"]
    find_lex $P3335, "$path"
    unless_null $P3335, vivify_1792
    new $P3335, "Undef"
  vivify_1792:
.annotate 'line', 2598
    find_lex $P3336, "$_"
    unless_null $P3336, vivify_1793
    new $P3336, "Undef"
  vivify_1793:
    set $S3337, $P3336
    $P3338 = $P3334."new"($P3335, $S3337, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2596
    store_lex "$path", $P3338
.annotate 'line', 2595
    .return ($P3338)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("453_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3355
.annotate 'line', 2608
    .lex "$name", param_3355
.annotate 'line', 2609
    find_lex $P3356, "$name"
    unless_null $P3356, vivify_1800
    new $P3356, "Undef"
  vivify_1800:
    $P3357 = "is_scope"($P3356, "lexical")
.annotate 'line', 2608
    .return ($P3357)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("454_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3360
.annotate 'line', 2614
    .lex "$name", param_3360
.annotate 'line', 2615
    find_lex $P3361, "$name"
    unless_null $P3361, vivify_1801
    new $P3361, "Undef"
  vivify_1801:
    $P3362 = "is_scope"($P3361, "package")
.annotate 'line', 2614
    .return ($P3362)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("455_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3367
    .param pmc param_3368
.annotate 'line', 2620
    .const 'Sub' $P3376 = "456_1306916577.75068" 
    capture_lex $P3376
    new $P3366, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3366, control_3365
    push_eh $P3366
    .lex "$name", param_3367
    .lex "$wanted_scope", param_3368
.annotate 'line', 2621
    find_lex $P3370, "$?PACKAGE"
    get_who $P3371, $P3370
    set $P3372, $P3371["@BLOCK"]
    unless_null $P3372, vivify_1802
    $P3372 = root_new ['parrot';'ResizablePMCArray']
  vivify_1802:
    defined $I3373, $P3372
    unless $I3373, for_undef_1803
    iter $P3369, $P3372
    new $P3395, 'ExceptionHandler'
    set_label $P3395, loop3394_handler
    $P3395."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3395
  loop3394_test:
    unless $P3369, loop3394_done
    shift $P3374, $P3369
  loop3394_redo:
    .const 'Sub' $P3376 = "456_1306916577.75068" 
    capture_lex $P3376
    $P3376($P3374)
  loop3394_next:
    goto loop3394_test
  loop3394_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3396, exception, 'type'
    eq $P3396, .CONTROL_LOOP_NEXT, loop3394_next
    eq $P3396, .CONTROL_LOOP_REDO, loop3394_redo
  loop3394_done:
    pop_eh 
  for_undef_1803:
.annotate 'line', 2620
    .return (0)
  control_3365:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3397, exception, "payload"
    .return ($P3397)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3375"  :anon :subid("456_1306916577.75068") :outer("455_1306916577.75068")
    .param pmc param_3378
.annotate 'line', 2622
    $P3377 = root_new ['parrot';'Hash']
    .lex "%sym", $P3377
    .lex "$_", param_3378
    find_lex $P3379, "$_"
    unless_null $P3379, vivify_1804
    new $P3379, "Undef"
  vivify_1804:
    find_lex $P3380, "$name"
    unless_null $P3380, vivify_1805
    new $P3380, "Undef"
  vivify_1805:
    $P3381 = $P3379."symbol"($P3380)
    store_lex "%sym", $P3381
.annotate 'line', 2623
    find_lex $P3384, "%sym"
    unless_null $P3384, vivify_1806
    $P3384 = root_new ['parrot';'Hash']
  vivify_1806:
    set $N3385, $P3384
    if $N3385, if_3383
    new $P3382, 'Float'
    set $P3382, $N3385
    goto if_3383_end
  if_3383:
.annotate 'line', 2624
    new $P3386, "Exception"
    set $P3386['type'], .CONTROL_RETURN
    find_lex $P3387, "%sym"
    unless_null $P3387, vivify_1807
    $P3387 = root_new ['parrot';'Hash']
  vivify_1807:
    set $P3388, $P3387["scope"]
    unless_null $P3388, vivify_1808
    new $P3388, "Undef"
  vivify_1808:
    set $S3389, $P3388
    find_lex $P3390, "$wanted_scope"
    unless_null $P3390, vivify_1809
    new $P3390, "Undef"
  vivify_1809:
    set $S3391, $P3390
    iseq $I3392, $S3389, $S3391
    new $P3393, 'Integer'
    set $P3393, $I3392
    setattribute $P3386, 'payload', $P3393
    throw $P3386
  if_3383_end:
.annotate 'line', 2621
    .return ($P3382)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("457_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3402
    .param pmc param_3403
.annotate 'line', 2643
    .const 'Sub' $P3497 = "462_1306916577.75068" 
    capture_lex $P3497
    .const 'Sub' $P3457 = "460_1306916577.75068" 
    capture_lex $P3457
    .const 'Sub' $P3415 = "458_1306916577.75068" 
    capture_lex $P3415
    new $P3401, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3401, control_3400
    push_eh $P3401
    .lex "@name", param_3402
    .lex "$/", param_3403
.annotate 'line', 2667
    new $P3404, "Undef"
    .lex "$result", $P3404
.annotate 'line', 2645
    find_lex $P3406, "@name"
    unless_null $P3406, vivify_1810
    $P3406 = root_new ['parrot';'ResizablePMCArray']
  vivify_1810:
    set $N3407, $P3406
    if $N3407, unless_3405_end
    find_lex $P3408, "$/"
    unless_null $P3408, vivify_1811
    new $P3408, "Undef"
  vivify_1811:
    $P3409 = $P3408."CURSOR"()
    $P3409."panic"("Cannot look up empty name")
  unless_3405_end:
.annotate 'line', 2649
    find_lex $P3411, "@name"
    unless_null $P3411, vivify_1812
    $P3411 = root_new ['parrot';'ResizablePMCArray']
  vivify_1812:
    set $N3412, $P3411
    iseq $I3413, $N3412, 1.0
    unless $I3413, if_3410_end
    .const 'Sub' $P3415 = "458_1306916577.75068" 
    capture_lex $P3415
    $P3415()
  if_3410_end:
.annotate 'line', 2667
    find_dynamic_lex $P3451, "$*GLOBALish"
    unless_null $P3451, vivify_1824
    get_hll_global $P3449, "GLOBAL"
    get_who $P3450, $P3449
    set $P3451, $P3450["$GLOBALish"]
    unless_null $P3451, vivify_1825
    die "Contextual $*GLOBALish not found"
  vivify_1825:
  vivify_1824:
    store_lex "$result", $P3451
.annotate 'line', 2668
    find_lex $P3453, "@name"
    unless_null $P3453, vivify_1826
    $P3453 = root_new ['parrot';'ResizablePMCArray']
  vivify_1826:
    set $N3454, $P3453
    isge $I3455, $N3454, 2.0
    unless $I3455, if_3452_end
    .const 'Sub' $P3457 = "460_1306916577.75068" 
    capture_lex $P3457
    $P3457()
  if_3452_end:
.annotate 'line', 2686
    find_lex $P3493, "@name"
    unless_null $P3493, vivify_1839
    $P3493 = root_new ['parrot';'ResizablePMCArray']
  vivify_1839:
    defined $I3494, $P3493
    unless $I3494, for_undef_1840
    iter $P3492, $P3493
    new $P3515, 'ExceptionHandler'
    set_label $P3515, loop3514_handler
    $P3515."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3515
  loop3514_test:
    unless $P3492, loop3514_done
    shift $P3495, $P3492
  loop3514_redo:
    .const 'Sub' $P3497 = "462_1306916577.75068" 
    capture_lex $P3497
    $P3497($P3495)
  loop3514_next:
    goto loop3514_test
  loop3514_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3516, exception, 'type'
    eq $P3516, .CONTROL_LOOP_NEXT, loop3514_next
    eq $P3516, .CONTROL_LOOP_REDO, loop3514_redo
  loop3514_done:
    pop_eh 
  for_undef_1840:
    find_lex $P3517, "$result"
    unless_null $P3517, vivify_1847
    new $P3517, "Undef"
  vivify_1847:
.annotate 'line', 2643
    .return ($P3517)
  control_3400:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3518, exception, "payload"
    .return ($P3518)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3414"  :anon :subid("458_1306916577.75068") :outer("457_1306916577.75068")
.annotate 'line', 2649
    .const 'Sub' $P3426 = "459_1306916577.75068" 
    capture_lex $P3426
.annotate 'line', 2650
    new $P3416, "Undef"
    .lex "$final_name", $P3416
    find_lex $P3417, "@name"
    unless_null $P3417, vivify_1813
    $P3417 = root_new ['parrot';'ResizablePMCArray']
  vivify_1813:
    set $P3418, $P3417[0]
    unless_null $P3418, vivify_1814
    new $P3418, "Undef"
  vivify_1814:
    store_lex "$final_name", $P3418
.annotate 'line', 2651
    find_lex $P3420, "$?PACKAGE"
    get_who $P3421, $P3420
    set $P3422, $P3421["@BLOCK"]
    unless_null $P3422, vivify_1815
    $P3422 = root_new ['parrot';'ResizablePMCArray']
  vivify_1815:
    defined $I3423, $P3422
    unless $I3423, for_undef_1816
    iter $P3419, $P3422
    new $P3447, 'ExceptionHandler'
    set_label $P3447, loop3446_handler
    $P3447."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3447
  loop3446_test:
    unless $P3419, loop3446_done
    shift $P3424, $P3419
  loop3446_redo:
    .const 'Sub' $P3426 = "459_1306916577.75068" 
    capture_lex $P3426
    $P3426($P3424)
  loop3446_next:
    goto loop3446_test
  loop3446_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3448, exception, 'type'
    eq $P3448, .CONTROL_LOOP_NEXT, loop3446_next
    eq $P3448, .CONTROL_LOOP_REDO, loop3446_redo
  loop3446_done:
    pop_eh 
  for_undef_1816:
.annotate 'line', 2649
    .return ($P3419)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3425"  :anon :subid("459_1306916577.75068") :outer("458_1306916577.75068")
    .param pmc param_3428
.annotate 'line', 2652
    $P3427 = root_new ['parrot';'Hash']
    .lex "%sym", $P3427
    .lex "$_", param_3428
    find_lex $P3429, "$_"
    unless_null $P3429, vivify_1817
    new $P3429, "Undef"
  vivify_1817:
    find_lex $P3430, "$final_name"
    unless_null $P3430, vivify_1818
    new $P3430, "Undef"
  vivify_1818:
    $P3431 = $P3429."symbol"($P3430)
    store_lex "%sym", $P3431
.annotate 'line', 2653
    find_lex $P3434, "%sym"
    unless_null $P3434, vivify_1819
    $P3434 = root_new ['parrot';'Hash']
  vivify_1819:
    set $N3435, $P3434
    if $N3435, if_3433
    new $P3432, 'Float'
    set $P3432, $N3435
    goto if_3433_end
  if_3433:
.annotate 'line', 2654
    find_lex $P3438, "%sym"
    unless_null $P3438, vivify_1820
    $P3438 = root_new ['parrot';'Hash']
  vivify_1820:
    exists $I3439, $P3438["value"]
    if $I3439, if_3437
.annotate 'line', 2658
    new $P3443, 'String'
    set $P3443, "No compile-time value for "
    find_lex $P3444, "$final_name"
    unless_null $P3444, vivify_1821
    new $P3444, "Undef"
  vivify_1821:
    concat $P3445, $P3443, $P3444
    die $P3445
.annotate 'line', 2657
    goto if_3437_end
  if_3437:
.annotate 'line', 2655
    new $P3440, "Exception"
    set $P3440['type'], .CONTROL_RETURN
    find_lex $P3441, "%sym"
    unless_null $P3441, vivify_1822
    $P3441 = root_new ['parrot';'Hash']
  vivify_1822:
    set $P3442, $P3441["value"]
    unless_null $P3442, vivify_1823
    new $P3442, "Undef"
  vivify_1823:
    setattribute $P3440, 'payload', $P3442
    throw $P3440
  if_3437_end:
.annotate 'line', 2653
    set $P3432, $P3436
  if_3433_end:
.annotate 'line', 2651
    .return ($P3432)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3456"  :anon :subid("460_1306916577.75068") :outer("457_1306916577.75068")
.annotate 'line', 2668
    .const 'Sub' $P3468 = "461_1306916577.75068" 
    capture_lex $P3468
.annotate 'line', 2669
    new $P3458, "Undef"
    .lex "$first", $P3458
    find_lex $P3459, "@name"
    unless_null $P3459, vivify_1827
    $P3459 = root_new ['parrot';'ResizablePMCArray']
  vivify_1827:
    set $P3460, $P3459[0]
    unless_null $P3460, vivify_1828
    new $P3460, "Undef"
  vivify_1828:
    store_lex "$first", $P3460
.annotate 'line', 2670
    find_lex $P3462, "$?PACKAGE"
    get_who $P3463, $P3462
    set $P3464, $P3463["@BLOCK"]
    unless_null $P3464, vivify_1829
    $P3464 = root_new ['parrot';'ResizablePMCArray']
  vivify_1829:
    defined $I3465, $P3464
    unless $I3465, for_undef_1830
    iter $P3461, $P3464
    new $P3490, 'ExceptionHandler'
    set_label $P3490, loop3489_handler
    $P3490."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3490
  loop3489_test:
    unless $P3461, loop3489_done
    shift $P3466, $P3461
  loop3489_redo:
    .const 'Sub' $P3468 = "461_1306916577.75068" 
    capture_lex $P3468
    $P3468($P3466)
  loop3489_next:
    goto loop3489_test
  loop3489_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3491, exception, 'type'
    eq $P3491, .CONTROL_LOOP_NEXT, loop3489_next
    eq $P3491, .CONTROL_LOOP_REDO, loop3489_redo
  loop3489_done:
    pop_eh 
  for_undef_1830:
.annotate 'line', 2668
    .return ($P3461)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3467"  :anon :subid("461_1306916577.75068") :outer("460_1306916577.75068")
    .param pmc param_3470
.annotate 'line', 2671
    $P3469 = root_new ['parrot';'Hash']
    .lex "%sym", $P3469
    .lex "$_", param_3470
    find_lex $P3471, "$_"
    unless_null $P3471, vivify_1831
    new $P3471, "Undef"
  vivify_1831:
    find_lex $P3472, "$first"
    unless_null $P3472, vivify_1832
    new $P3472, "Undef"
  vivify_1832:
    $P3473 = $P3471."symbol"($P3472)
    store_lex "%sym", $P3473
.annotate 'line', 2672
    find_lex $P3476, "%sym"
    unless_null $P3476, vivify_1833
    $P3476 = root_new ['parrot';'Hash']
  vivify_1833:
    set $N3477, $P3476
    if $N3477, if_3475
    new $P3474, 'Float'
    set $P3474, $N3477
    goto if_3475_end
  if_3475:
.annotate 'line', 2673
    find_lex $P3480, "%sym"
    unless_null $P3480, vivify_1834
    $P3480 = root_new ['parrot';'Hash']
  vivify_1834:
    exists $I3481, $P3480["value"]
    if $I3481, if_3479
.annotate 'line', 2679
    new $P3486, 'String'
    set $P3486, "No compile-time value for "
    find_lex $P3487, "$first"
    unless_null $P3487, vivify_1835
    new $P3487, "Undef"
  vivify_1835:
    concat $P3488, $P3486, $P3487
    die $P3488
.annotate 'line', 2678
    goto if_3479_end
  if_3479:
.annotate 'line', 2674
    find_lex $P3482, "%sym"
    unless_null $P3482, vivify_1836
    $P3482 = root_new ['parrot';'Hash']
  vivify_1836:
    set $P3483, $P3482["value"]
    unless_null $P3483, vivify_1837
    new $P3483, "Undef"
  vivify_1837:
    store_lex "$result", $P3483
.annotate 'line', 2675
    find_lex $P3484, "@name"
    unless_null $P3484, vivify_1838
    $P3484 = root_new ['parrot';'ResizablePMCArray']
  vivify_1838:
    $P3484."shift"()
.annotate 'line', 2676
    set $I3485, .CONTROL_LOOP_LAST
    die 0, $I3485
  if_3479_end:
.annotate 'line', 2672
    set $P3474, $P3478
  if_3475_end:
.annotate 'line', 2670
    .return ($P3474)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3496"  :anon :subid("462_1306916577.75068") :outer("457_1306916577.75068")
    .param pmc param_3498
.annotate 'line', 2686
    .lex "$_", param_3498
.annotate 'line', 2687
    find_lex $P3503, "$_"
    unless_null $P3503, vivify_1841
    new $P3503, "Undef"
  vivify_1841:
    set $S3504, $P3503
    find_lex $P3501, "$result"
    unless_null $P3501, vivify_1842
    new $P3501, "Undef"
  vivify_1842:
    get_who $P3502, $P3501
    exists $I3505, $P3502[$S3504]
    if $I3505, if_3500
.annotate 'line', 2691
    new $P3510, "String"
    assign $P3510, "Could not locate compile-time value for symbol "
.annotate 'line', 2692
    find_lex $P3511, "@name"
    unless_null $P3511, vivify_1843
    $P3511 = root_new ['parrot';'ResizablePMCArray']
  vivify_1843:
    join $S3512, "::", $P3511
    concat $P3513, $P3510, $S3512
.annotate 'line', 2691
    die $P3513
.annotate 'line', 2690
    goto if_3500_end
  if_3500:
.annotate 'line', 2688
    find_lex $P3506, "$_"
    unless_null $P3506, vivify_1844
    new $P3506, "Undef"
  vivify_1844:
    find_lex $P3507, "$result"
    unless_null $P3507, vivify_1845
    new $P3507, "Undef"
  vivify_1845:
    get_who $P3508, $P3507
    set $P3509, $P3508[$P3506]
    unless_null $P3509, vivify_1846
    new $P3509, "Undef"
  vivify_1846:
    store_lex "$result", $P3509
.annotate 'line', 2687
    set $P3499, $P3509
  if_3500_end:
.annotate 'line', 2686
    .return ($P3499)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP" :anon :subid("463_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3529
    .param pmc param_3530
.annotate 'line', 1229
    .lex "self", param_3529
    .lex "$/", param_3530
    find_lex $P3531, "$/"
    find_lex $P3532, "$/"
    unless_null $P3532, vivify_1848
    $P3532 = root_new ['parrot';'Hash']
  vivify_1848:
    set $P3533, $P3532["comp_unit"]
    unless_null $P3533, vivify_1849
    new $P3533, "Undef"
  vivify_1849:
    $P3534 = $P3533."ast"()
    $P3535 = $P3531."!make"($P3534)
    .return ($P3535)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname" :anon :subid("464_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3537
    .param pmc param_3538
.annotate 'line', 1231
    .lex "self", param_3537
    .lex "$/", param_3538
.annotate 'line', 1232
    find_lex $P3539, "$/"
.annotate 'line', 1233
    find_lex $P3542, "$/"
    unless_null $P3542, vivify_1850
    $P3542 = root_new ['parrot';'Hash']
  vivify_1850:
    set $P3543, $P3542["colonpair"]
    unless_null $P3543, vivify_1851
    new $P3543, "Undef"
  vivify_1851:
    if $P3543, if_3541
.annotate 'line', 1235
    find_lex $P3563, "$/"
    unless_null $P3563, vivify_1852
    new $P3563, "Undef"
  vivify_1852:
    set $S3564, $P3563
    new $P3540, 'String'
    set $P3540, $S3564
.annotate 'line', 1233
    goto if_3541_end
  if_3541:
    find_lex $P3544, "$/"
    unless_null $P3544, vivify_1853
    $P3544 = root_new ['parrot';'Hash']
  vivify_1853:
    set $P3545, $P3544["identifier"]
    unless_null $P3545, vivify_1854
    new $P3545, "Undef"
  vivify_1854:
    set $S3546, $P3545
    new $P3547, 'String'
    set $P3547, $S3546
    concat $P3548, $P3547, ":"
    find_lex $P3549, "$/"
    unless_null $P3549, vivify_1855
    $P3549 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P3550, $P3549["colonpair"]
    unless_null $P3550, vivify_1856
    $P3550 = root_new ['parrot';'ResizablePMCArray']
  vivify_1856:
    set $P3551, $P3550[0]
    unless_null $P3551, vivify_1857
    new $P3551, "Undef"
  vivify_1857:
    $P3552 = $P3551."ast"()
    $S3553 = $P3552."named"()
    concat $P3554, $P3548, $S3553
    concat $P3555, $P3554, "<"
.annotate 'line', 1234
    find_lex $P3556, "$/"
    unless_null $P3556, vivify_1858
    $P3556 = root_new ['parrot';'Hash']
  vivify_1858:
    set $P3557, $P3556["colonpair"]
    unless_null $P3557, vivify_1859
    $P3557 = root_new ['parrot';'ResizablePMCArray']
  vivify_1859:
    set $P3558, $P3557[0]
    unless_null $P3558, vivify_1860
    new $P3558, "Undef"
  vivify_1860:
    $P3559 = $P3558."ast"()
    $S3560 = "colonpair_str"($P3559)
    concat $P3561, $P3555, $S3560
    concat $P3562, $P3561, ">"
    set $P3540, $P3562
  if_3541_end:
.annotate 'line', 1233
    $P3565 = $P3539."!make"($P3540)
.annotate 'line', 1231
    .return ($P3565)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "comp_unit" :anon :subid("465_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3568
    .param pmc param_3569
.annotate 'line', 1245
    .const 'Sub' $P3632 = "466_1306916577.75068" 
    capture_lex $P3632
    .lex "self", param_3568
    .lex "$/", param_3569
.annotate 'line', 1246
    new $P3570, "Undef"
    .lex "$mainline", $P3570
.annotate 'line', 1247
    new $P3571, "Undef"
    .lex "$unit", $P3571
.annotate 'line', 1270
    $P3572 = root_new ['parrot';'ResizablePMCArray']
    .lex "@loadlibs", $P3572
.annotate 'line', 1283
    new $P3573, "Undef"
    .lex "$main_tasks", $P3573
.annotate 'line', 1246
    find_lex $P3574, "$/"
    unless_null $P3574, vivify_1861
    $P3574 = root_new ['parrot';'Hash']
  vivify_1861:
    set $P3575, $P3574["statementlist"]
    unless_null $P3575, vivify_1862
    new $P3575, "Undef"
  vivify_1862:
    $P3576 = $P3575."ast"()
    store_lex "$mainline", $P3576
.annotate 'line', 1247
    find_lex $P3577, "$?PACKAGE"
    get_who $P3578, $P3577
    set $P3579, $P3578["@BLOCK"]
    unless_null $P3579, vivify_1863
    $P3579 = root_new ['parrot';'ResizablePMCArray']
  vivify_1863:
    $P3580 = $P3579."shift"()
    store_lex "$unit", $P3580
.annotate 'line', 1251
    find_lex $P3581, "$unit"
    unless_null $P3581, vivify_1864
    new $P3581, "Undef"
  vivify_1864:
    $P3582 = $P3581."loadinit"()
    find_dynamic_lex $P3585, "$*SC"
    unless_null $P3585, vivify_1865
    get_hll_global $P3583, "GLOBAL"
    get_who $P3584, $P3583
    set $P3585, $P3584["$SC"]
    unless_null $P3585, vivify_1866
    die "Contextual $*SC not found"
  vivify_1866:
  vivify_1865:
    $P3586 = $P3585."to_past"()
    $P3582."push"($P3586)
.annotate 'line', 1256
    find_lex $P3587, "$unit"
    unless_null $P3587, vivify_1867
    new $P3587, "Undef"
  vivify_1867:
    $P3588 = $P3587."loadinit"()
    get_hll_global $P3589, "GLOBAL"
    nqp_get_package_through_who $P3590, $P3589, "PAST"
    get_who $P3591, $P3590
    set $P3592, $P3591["Op"]
.annotate 'line', 1258
    get_hll_global $P3593, "GLOBAL"
    nqp_get_package_through_who $P3594, $P3593, "PAST"
    get_who $P3595, $P3594
    set $P3596, $P3595["Var"]
    new $P3597, "ResizablePMCArray"
    $P3598 = $P3596."new"("GLOBAL" :named("name"), $P3597 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1259
    find_dynamic_lex $P3601, "$*SC"
    unless_null $P3601, vivify_1868
    get_hll_global $P3599, "GLOBAL"
    get_who $P3600, $P3599
    set $P3601, $P3600["$SC"]
    unless_null $P3601, vivify_1869
    die "Contextual $*SC not found"
  vivify_1869:
  vivify_1868:
    find_dynamic_lex $P3604, "$*PACKAGE"
    unless_null $P3604, vivify_1870
    get_hll_global $P3602, "GLOBAL"
    get_who $P3603, $P3602
    set $P3604, $P3603["$PACKAGE"]
    unless_null $P3604, vivify_1871
    die "Contextual $*PACKAGE not found"
  vivify_1871:
  vivify_1870:
    $P3605 = $P3601."get_slot_past_for_object"($P3604)
    $P3606 = $P3592."new"($P3598, $P3605, "bind" :named("pasttype"))
.annotate 'line', 1256
    $P3588."push"($P3606)
.annotate 'line', 1265
    find_dynamic_lex $P3610, "$*HAS_YOU_ARE_HERE"
    unless_null $P3610, vivify_1872
    get_hll_global $P3608, "GLOBAL"
    get_who $P3609, $P3608
    set $P3610, $P3609["$HAS_YOU_ARE_HERE"]
    unless_null $P3610, vivify_1873
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1873:
  vivify_1872:
    if $P3610, unless_3607_end
.annotate 'line', 1266
    find_lex $P3611, "$unit"
    unless_null $P3611, vivify_1874
    new $P3611, "Undef"
  vivify_1874:
    find_lex $P3612, "self"
    $P3613 = $P3612."CTXSAVE"()
    $P3611."push"($P3613)
  unless_3607_end:
.annotate 'line', 1270
    new $P3614, "ResizablePMCArray"
    push $P3614, "nqp_group"
    push $P3614, "nqp_ops"
    push $P3614, "trans_ops"
    push $P3614, "io_ops"
    store_lex "@loadlibs", $P3614
.annotate 'line', 1271
    find_dynamic_lex $P3618, "%*COMPILING"
    unless_null $P3618, vivify_1875
    get_hll_global $P3616, "GLOBAL"
    get_who $P3617, $P3616
    set $P3618, $P3617["%COMPILING"]
    unless_null $P3618, vivify_1876
    die "Contextual %*COMPILING not found"
  vivify_1876:
  vivify_1875:
    set $P3619, $P3618["%?OPTIONS"]
    unless_null $P3619, vivify_1877
    $P3619 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P3620, $P3619["vmlibs"]
    unless_null $P3620, vivify_1878
    new $P3620, "Undef"
  vivify_1878:
    unless $P3620, if_3615_end
.annotate 'line', 1272
    find_dynamic_lex $P3624, "%*COMPILING"
    unless_null $P3624, vivify_1879
    get_hll_global $P3622, "GLOBAL"
    get_who $P3623, $P3622
    set $P3624, $P3623["%COMPILING"]
    unless_null $P3624, vivify_1880
    die "Contextual %*COMPILING not found"
  vivify_1880:
  vivify_1879:
    set $P3625, $P3624["%?OPTIONS"]
    unless_null $P3625, vivify_1881
    $P3625 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P3626, $P3625["vmlibs"]
    unless_null $P3626, vivify_1882
    new $P3626, "Undef"
  vivify_1882:
    set $S3627, $P3626
    split $P3628, ",", $S3627
    defined $I3629, $P3628
    unless $I3629, for_undef_1883
    iter $P3621, $P3628
    new $P3638, 'ExceptionHandler'
    set_label $P3638, loop3637_handler
    $P3638."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3638
  loop3637_test:
    unless $P3621, loop3637_done
    shift $P3630, $P3621
  loop3637_redo:
    .const 'Sub' $P3632 = "466_1306916577.75068" 
    capture_lex $P3632
    $P3632($P3630)
  loop3637_next:
    goto loop3637_test
  loop3637_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3639, exception, 'type'
    eq $P3639, .CONTROL_LOOP_NEXT, loop3637_next
    eq $P3639, .CONTROL_LOOP_REDO, loop3637_redo
  loop3637_done:
    pop_eh 
  for_undef_1883:
  if_3615_end:
.annotate 'line', 1276
    find_lex $P3640, "$unit"
    unless_null $P3640, vivify_1886
    new $P3640, "Undef"
  vivify_1886:
    find_lex $P3641, "@loadlibs"
    unless_null $P3641, vivify_1887
    $P3641 = root_new ['parrot';'ResizablePMCArray']
  vivify_1887:
    $P3640."loadlibs"($P3641 :flat)
.annotate 'line', 1282
    find_lex $P3642, "$unit"
    unless_null $P3642, vivify_1888
    new $P3642, "Undef"
  vivify_1888:
    get_hll_global $P3643, "GLOBAL"
    nqp_get_package_through_who $P3644, $P3643, "PAST"
    get_who $P3645, $P3644
    set $P3646, $P3645["Var"]
    $P3647 = $P3646."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3642."unshift"($P3647)
.annotate 'line', 1283
    get_hll_global $P3648, "GLOBAL"
    nqp_get_package_through_who $P3649, $P3648, "PAST"
    get_who $P3650, $P3649
    set $P3651, $P3650["Stmts"]
.annotate 'line', 1284
    get_hll_global $P3652, "GLOBAL"
    nqp_get_package_through_who $P3653, $P3652, "PAST"
    get_who $P3654, $P3653
    set $P3655, $P3654["Op"]
    $P3656 = $P3655."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1285
    get_hll_global $P3657, "GLOBAL"
    nqp_get_package_through_who $P3658, $P3657, "PAST"
    get_who $P3659, $P3658
    set $P3660, $P3659["Op"]
.annotate 'line', 1287
    get_hll_global $P3661, "GLOBAL"
    nqp_get_package_through_who $P3662, $P3661, "PAST"
    get_who $P3663, $P3662
    set $P3664, $P3663["Var"]
    new $P3665, "ResizablePMCArray"
    $P3666 = $P3664."new"("ModuleLoader" :named("name"), $P3665 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1288
    get_hll_global $P3667, "GLOBAL"
    nqp_get_package_through_who $P3668, $P3667, "PAST"
    get_who $P3669, $P3668
    set $P3670, $P3669["Var"]
    get_hll_global $P3671, "GLOBAL"
    nqp_get_package_through_who $P3672, $P3671, "PAST"
    get_who $P3673, $P3672
    set $P3674, $P3673["Op"]
    $P3675 = $P3674."new"("getinterp P" :named("pirop"))
    $P3676 = $P3670."new"($P3675, "context", "keyed" :named("scope"))
    $P3677 = $P3660."new"($P3666, $P3676, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1285
    $P3678 = $P3651."new"($P3656, $P3677)
.annotate 'line', 1283
    store_lex "$main_tasks", $P3678
.annotate 'line', 1291
    find_dynamic_lex $P3682, "$*MAIN_SUB"
    unless_null $P3682, vivify_1889
    get_hll_global $P3680, "GLOBAL"
    get_who $P3681, $P3680
    set $P3682, $P3681["$MAIN_SUB"]
    unless_null $P3682, vivify_1890
    die "Contextual $*MAIN_SUB not found"
  vivify_1890:
  vivify_1889:
    unless $P3682, if_3679_end
.annotate 'line', 1292
    find_lex $P3683, "$main_tasks"
    unless_null $P3683, vivify_1891
    new $P3683, "Undef"
  vivify_1891:
    get_hll_global $P3684, "GLOBAL"
    nqp_get_package_through_who $P3685, $P3684, "PAST"
    get_who $P3686, $P3685
    set $P3687, $P3686["Op"]
.annotate 'line', 1293
    get_hll_global $P3688, "GLOBAL"
    nqp_get_package_through_who $P3689, $P3688, "PAST"
    get_who $P3690, $P3689
    set $P3691, $P3690["Val"]
    find_dynamic_lex $P3694, "$*MAIN_SUB"
    unless_null $P3694, vivify_1892
    get_hll_global $P3692, "GLOBAL"
    get_who $P3693, $P3692
    set $P3694, $P3693["$MAIN_SUB"]
    unless_null $P3694, vivify_1893
    die "Contextual $*MAIN_SUB not found"
  vivify_1893:
  vivify_1892:
    $P3695 = $P3691."new"($P3694 :named("value"))
.annotate 'line', 1294
    get_hll_global $P3696, "GLOBAL"
    nqp_get_package_through_who $P3697, $P3696, "PAST"
    get_who $P3698, $P3697
    set $P3699, $P3698["Var"]
    $P3700 = $P3699."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3701 = $P3687."new"($P3695, $P3700, "call" :named("pasttype"))
.annotate 'line', 1292
    $P3683."push"($P3701)
  if_3679_end:
.annotate 'line', 1297
    find_lex $P3702, "$mainline"
    unless_null $P3702, vivify_1894
    new $P3702, "Undef"
  vivify_1894:
    get_hll_global $P3703, "GLOBAL"
    nqp_get_package_through_who $P3704, $P3703, "PAST"
    get_who $P3705, $P3704
    set $P3706, $P3705["Op"]
.annotate 'line', 1299
    get_hll_global $P3707, "GLOBAL"
    nqp_get_package_through_who $P3708, $P3707, "PAST"
    get_who $P3709, $P3708
    set $P3710, $P3709["Var"]
    $P3711 = $P3710."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P3712, "$main_tasks"
    unless_null $P3712, vivify_1895
    new $P3712, "Undef"
  vivify_1895:
    $P3713 = $P3706."new"($P3711, $P3712, "if" :named("pasttype"))
.annotate 'line', 1297
    $P3702."push"($P3713)
.annotate 'line', 1306
    find_lex $P3714, "$unit"
    unless_null $P3714, vivify_1896
    new $P3714, "Undef"
  vivify_1896:
.annotate 'line', 1307
    get_hll_global $P3715, "GLOBAL"
    nqp_get_package_through_who $P3716, $P3715, "PAST"
    get_who $P3717, $P3716
    set $P3718, $P3717["Op"]
    find_lex $P3719, "$mainline"
    unless_null $P3719, vivify_1897
    new $P3719, "Undef"
  vivify_1897:
    $P3720 = $P3718."new"($P3719, "return" :named("pirop"))
    $P3714."push"($P3720)
.annotate 'line', 1312
    find_lex $P3721, "$unit"
    unless_null $P3721, vivify_1898
    new $P3721, "Undef"
  vivify_1898:
.annotate 'line', 1313
    get_hll_global $P3722, "GLOBAL"
    nqp_get_package_through_who $P3723, $P3722, "PAST"
    get_who $P3724, $P3723
    set $P3725, $P3724["Block"]
.annotate 'line', 1315
    get_hll_global $P3726, "GLOBAL"
    nqp_get_package_through_who $P3727, $P3726, "PAST"
    get_who $P3728, $P3727
    set $P3729, $P3728["Op"]
    get_hll_global $P3730, "GLOBAL"
    nqp_get_package_through_who $P3731, $P3730, "PAST"
    get_who $P3732, $P3731
    set $P3733, $P3732["Val"]
    find_lex $P3734, "$unit"
    unless_null $P3734, vivify_1899
    new $P3734, "Undef"
  vivify_1899:
    $P3735 = $P3733."new"($P3734 :named("value"))
    $P3736 = $P3729."new"($P3735, "call" :named("pasttype"))
    $P3737 = $P3725."new"($P3736, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1313
    $P3721."push"($P3737)
.annotate 'line', 1318
    find_lex $P3738, "$unit"
    unless_null $P3738, vivify_1900
    new $P3738, "Undef"
  vivify_1900:
    find_lex $P3739, "$/"
    unless_null $P3739, vivify_1901
    new $P3739, "Undef"
  vivify_1901:
    $P3738."node"($P3739)
.annotate 'line', 1321
    find_lex $P3740, "$unit"
    unless_null $P3740, vivify_1902
    new $P3740, "Undef"
  vivify_1902:
    $P3740."hll"("nqp")
.annotate 'line', 1323
    find_lex $P3741, "$/"
    find_lex $P3742, "$unit"
    unless_null $P3742, vivify_1903
    new $P3742, "Undef"
  vivify_1903:
    $P3743 = $P3741."!make"($P3742)
.annotate 'line', 1245
    .return ($P3743)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3631"  :anon :subid("466_1306916577.75068") :outer("465_1306916577.75068")
    .param pmc param_3633
.annotate 'line', 1272
    .lex "$_", param_3633
.annotate 'line', 1273
    find_lex $P3634, "@loadlibs"
    unless_null $P3634, vivify_1884
    $P3634 = root_new ['parrot';'ResizablePMCArray']
  vivify_1884:
    find_lex $P3635, "$_"
    unless_null $P3635, vivify_1885
    new $P3635, "Undef"
  vivify_1885:
    $P3636 = $P3634."push"($P3635)
.annotate 'line', 1272
    .return ($P3636)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist" :anon :subid("467_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3745
    .param pmc param_3746
.annotate 'line', 1326
    .const 'Sub' $P3763 = "468_1306916577.75068" 
    capture_lex $P3763
    .lex "self", param_3745
    .lex "$/", param_3746
.annotate 'line', 1327
    new $P3747, "Undef"
    .lex "$past", $P3747
    get_hll_global $P3748, "GLOBAL"
    nqp_get_package_through_who $P3749, $P3748, "PAST"
    get_who $P3750, $P3749
    set $P3751, $P3750["Stmts"]
    find_lex $P3752, "$/"
    unless_null $P3752, vivify_1904
    new $P3752, "Undef"
  vivify_1904:
    $P3753 = $P3751."new"($P3752 :named("node"))
    store_lex "$past", $P3753
.annotate 'line', 1328
    find_lex $P3755, "$/"
    unless_null $P3755, vivify_1905
    $P3755 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3756, $P3755["statement"]
    unless_null $P3756, vivify_1906
    new $P3756, "Undef"
  vivify_1906:
    unless $P3756, if_3754_end
.annotate 'line', 1329
    find_lex $P3758, "$/"
    unless_null $P3758, vivify_1907
    $P3758 = root_new ['parrot';'Hash']
  vivify_1907:
    set $P3759, $P3758["statement"]
    unless_null $P3759, vivify_1908
    new $P3759, "Undef"
  vivify_1908:
    defined $I3760, $P3759
    unless $I3760, for_undef_1909
    iter $P3757, $P3759
    new $P3783, 'ExceptionHandler'
    set_label $P3783, loop3782_handler
    $P3783."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3783
  loop3782_test:
    unless $P3757, loop3782_done
    shift $P3761, $P3757
  loop3782_redo:
    .const 'Sub' $P3763 = "468_1306916577.75068" 
    capture_lex $P3763
    $P3763($P3761)
  loop3782_next:
    goto loop3782_test
  loop3782_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3784, exception, 'type'
    eq $P3784, .CONTROL_LOOP_NEXT, loop3782_next
    eq $P3784, .CONTROL_LOOP_REDO, loop3782_redo
  loop3782_done:
    pop_eh 
  for_undef_1909:
  if_3754_end:
.annotate 'line', 1336
    find_lex $P3785, "$/"
    find_lex $P3786, "$past"
    unless_null $P3786, vivify_1920
    new $P3786, "Undef"
  vivify_1920:
    $P3787 = $P3785."!make"($P3786)
.annotate 'line', 1326
    .return ($P3787)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3762"  :anon :subid("468_1306916577.75068") :outer("467_1306916577.75068")
    .param pmc param_3765
.annotate 'line', 1330
    new $P3764, "Undef"
    .lex "$ast", $P3764
    .lex "$_", param_3765
    find_lex $P3766, "$_"
    unless_null $P3766, vivify_1910
    new $P3766, "Undef"
  vivify_1910:
    $P3767 = $P3766."ast"()
    store_lex "$ast", $P3767
.annotate 'line', 1331
    find_lex $P3769, "$ast"
    unless_null $P3769, vivify_1911
    $P3769 = root_new ['parrot';'Hash']
  vivify_1911:
    set $P3770, $P3769["sink"]
    unless_null $P3770, vivify_1912
    new $P3770, "Undef"
  vivify_1912:
    defined $I3771, $P3770
    unless $I3771, if_3768_end
    find_lex $P3772, "$ast"
    unless_null $P3772, vivify_1913
    $P3772 = root_new ['parrot';'Hash']
  vivify_1913:
    set $P3773, $P3772["sink"]
    unless_null $P3773, vivify_1914
    new $P3773, "Undef"
  vivify_1914:
    store_lex "$ast", $P3773
  if_3768_end:
.annotate 'line', 1332
    find_lex $P3775, "$ast"
    unless_null $P3775, vivify_1915
    $P3775 = root_new ['parrot';'Hash']
  vivify_1915:
    set $P3776, $P3775["bareblock"]
    unless_null $P3776, vivify_1916
    new $P3776, "Undef"
  vivify_1916:
    unless $P3776, if_3774_end
    find_lex $P3777, "$ast"
    unless_null $P3777, vivify_1917
    new $P3777, "Undef"
  vivify_1917:
    $P3778 = "block_immediate"($P3777)
    store_lex "$ast", $P3778
  if_3774_end:
.annotate 'line', 1333
    find_lex $P3779, "$past"
    unless_null $P3779, vivify_1918
    new $P3779, "Undef"
  vivify_1918:
    find_lex $P3780, "$ast"
    unless_null $P3780, vivify_1919
    new $P3780, "Undef"
  vivify_1919:
    $P3781 = $P3779."push"($P3780)
.annotate 'line', 1329
    .return ($P3781)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement" :anon :subid("469_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3789
    .param pmc param_3790
    .param pmc param_3791 :optional
    .param int has_param_3791 :opt_flag
.annotate 'line', 1339
    .const 'Sub' $P3799 = "470_1306916577.75068" 
    capture_lex $P3799
    .lex "self", param_3789
    .lex "$/", param_3790
    if has_param_3791, optparam_1921
    new $P3792, "Undef"
    set param_3791, $P3792
  optparam_1921:
    .lex "$key", param_3791
.annotate 'line', 1340
    new $P3793, "Undef"
    .lex "$past", $P3793
.annotate 'line', 1339
    find_lex $P3794, "$past"
    unless_null $P3794, vivify_1922
    new $P3794, "Undef"
  vivify_1922:
.annotate 'line', 1341
    find_lex $P3796, "$/"
    unless_null $P3796, vivify_1923
    $P3796 = root_new ['parrot';'Hash']
  vivify_1923:
    set $P3797, $P3796["EXPR"]
    unless_null $P3797, vivify_1924
    new $P3797, "Undef"
  vivify_1924:
    if $P3797, if_3795
.annotate 'line', 1362
    find_lex $P3875, "$/"
    unless_null $P3875, vivify_1925
    $P3875 = root_new ['parrot';'Hash']
  vivify_1925:
    set $P3876, $P3875["statement_control"]
    unless_null $P3876, vivify_1926
    new $P3876, "Undef"
  vivify_1926:
    if $P3876, if_3874
.annotate 'line', 1363
    new $P3880, "Integer"
    assign $P3880, 0
    store_lex "$past", $P3880
    goto if_3874_end
  if_3874:
.annotate 'line', 1362
    find_lex $P3877, "$/"
    unless_null $P3877, vivify_1927
    $P3877 = root_new ['parrot';'Hash']
  vivify_1927:
    set $P3878, $P3877["statement_control"]
    unless_null $P3878, vivify_1928
    new $P3878, "Undef"
  vivify_1928:
    $P3879 = $P3878."ast"()
    store_lex "$past", $P3879
  if_3874_end:
    goto if_3795_end
  if_3795:
.annotate 'line', 1341
    .const 'Sub' $P3799 = "470_1306916577.75068" 
    capture_lex $P3799
    $P3799()
  if_3795_end:
.annotate 'line', 1364
    find_lex $P3881, "$/"
    find_lex $P3882, "$past"
    unless_null $P3882, vivify_1962
    new $P3882, "Undef"
  vivify_1962:
    $P3883 = $P3881."!make"($P3882)
.annotate 'line', 1339
    .return ($P3883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3798"  :anon :subid("470_1306916577.75068") :outer("469_1306916577.75068")
.annotate 'line', 1342
    new $P3800, "Undef"
    .lex "$mc", $P3800
.annotate 'line', 1343
    new $P3801, "Undef"
    .lex "$ml", $P3801
.annotate 'line', 1342
    find_lex $P3802, "$/"
    unless_null $P3802, vivify_1929
    $P3802 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P3803, $P3802["statement_mod_cond"]
    unless_null $P3803, vivify_1930
    $P3803 = root_new ['parrot';'ResizablePMCArray']
  vivify_1930:
    set $P3804, $P3803[0]
    unless_null $P3804, vivify_1931
    new $P3804, "Undef"
  vivify_1931:
    store_lex "$mc", $P3804
.annotate 'line', 1343
    find_lex $P3805, "$/"
    unless_null $P3805, vivify_1932
    $P3805 = root_new ['parrot';'Hash']
  vivify_1932:
    set $P3806, $P3805["statement_mod_loop"]
    unless_null $P3806, vivify_1933
    $P3806 = root_new ['parrot';'ResizablePMCArray']
  vivify_1933:
    set $P3807, $P3806[0]
    unless_null $P3807, vivify_1934
    new $P3807, "Undef"
  vivify_1934:
    store_lex "$ml", $P3807
.annotate 'line', 1344
    find_lex $P3808, "$/"
    unless_null $P3808, vivify_1935
    $P3808 = root_new ['parrot';'Hash']
  vivify_1935:
    set $P3809, $P3808["EXPR"]
    unless_null $P3809, vivify_1936
    new $P3809, "Undef"
  vivify_1936:
    $P3810 = $P3809."ast"()
    store_lex "$past", $P3810
.annotate 'line', 1345
    find_lex $P3812, "$mc"
    unless_null $P3812, vivify_1937
    new $P3812, "Undef"
  vivify_1937:
    unless $P3812, if_3811_end
.annotate 'line', 1346
    get_hll_global $P3813, "GLOBAL"
    nqp_get_package_through_who $P3814, $P3813, "PAST"
    get_who $P3815, $P3814
    set $P3816, $P3815["Op"]
    find_lex $P3817, "$mc"
    unless_null $P3817, vivify_1938
    $P3817 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P3818, $P3817["cond"]
    unless_null $P3818, vivify_1939
    new $P3818, "Undef"
  vivify_1939:
    $P3819 = $P3818."ast"()
    find_lex $P3820, "$past"
    unless_null $P3820, vivify_1940
    new $P3820, "Undef"
  vivify_1940:
    find_lex $P3821, "$mc"
    unless_null $P3821, vivify_1941
    $P3821 = root_new ['parrot';'Hash']
  vivify_1941:
    set $P3822, $P3821["sym"]
    unless_null $P3822, vivify_1942
    new $P3822, "Undef"
  vivify_1942:
    set $S3823, $P3822
    find_lex $P3824, "$/"
    unless_null $P3824, vivify_1943
    new $P3824, "Undef"
  vivify_1943:
    $P3825 = $P3816."new"($P3819, $P3820, $S3823 :named("pasttype"), $P3824 :named("node"))
    store_lex "$past", $P3825
  if_3811_end:
.annotate 'line', 1348
    find_lex $P3828, "$ml"
    unless_null $P3828, vivify_1944
    new $P3828, "Undef"
  vivify_1944:
    if $P3828, if_3827
    set $P3826, $P3828
    goto if_3827_end
  if_3827:
.annotate 'line', 1349
    find_lex $P3831, "$ml"
    unless_null $P3831, vivify_1945
    $P3831 = root_new ['parrot';'Hash']
  vivify_1945:
    set $P3832, $P3831["sym"]
    unless_null $P3832, vivify_1946
    new $P3832, "Undef"
  vivify_1946:
    set $S3833, $P3832
    iseq $I3834, $S3833, "for"
    if $I3834, if_3830
.annotate 'line', 1358
    get_hll_global $P3861, "GLOBAL"
    nqp_get_package_through_who $P3862, $P3861, "PAST"
    get_who $P3863, $P3862
    set $P3864, $P3863["Op"]
    find_lex $P3865, "$ml"
    unless_null $P3865, vivify_1947
    $P3865 = root_new ['parrot';'Hash']
  vivify_1947:
    set $P3866, $P3865["cond"]
    unless_null $P3866, vivify_1948
    new $P3866, "Undef"
  vivify_1948:
    $P3867 = $P3866."ast"()
    find_lex $P3868, "$past"
    unless_null $P3868, vivify_1949
    new $P3868, "Undef"
  vivify_1949:
    find_lex $P3869, "$ml"
    unless_null $P3869, vivify_1950
    $P3869 = root_new ['parrot';'Hash']
  vivify_1950:
    set $P3870, $P3869["sym"]
    unless_null $P3870, vivify_1951
    new $P3870, "Undef"
  vivify_1951:
    set $S3871, $P3870
    find_lex $P3872, "$/"
    unless_null $P3872, vivify_1952
    new $P3872, "Undef"
  vivify_1952:
    $P3873 = $P3864."new"($P3867, $P3868, $S3871 :named("pasttype"), $P3872 :named("node"))
    store_lex "$past", $P3873
.annotate 'line', 1357
    set $P3829, $P3873
.annotate 'line', 1349
    goto if_3830_end
  if_3830:
.annotate 'line', 1350
    get_hll_global $P3835, "GLOBAL"
    nqp_get_package_through_who $P3836, $P3835, "PAST"
    get_who $P3837, $P3836
    set $P3838, $P3837["Block"]
.annotate 'line', 1351
    get_hll_global $P3839, "GLOBAL"
    nqp_get_package_through_who $P3840, $P3839, "PAST"
    get_who $P3841, $P3840
    set $P3842, $P3841["Var"]
    $P3843 = $P3842."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3844, "$past"
    unless_null $P3844, vivify_1953
    new $P3844, "Undef"
  vivify_1953:
    $P3845 = $P3838."new"($P3843, $P3844, "immediate" :named("blocktype"))
.annotate 'line', 1350
    store_lex "$past", $P3845
.annotate 'line', 1353
    find_lex $P3846, "$past"
    unless_null $P3846, vivify_1954
    new $P3846, "Undef"
  vivify_1954:
    $P3846."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1354
    find_lex $P3847, "$past"
    unless_null $P3847, vivify_1955
    new $P3847, "Undef"
  vivify_1955:
    $P3847."arity"(1)
.annotate 'line', 1355
    get_hll_global $P3848, "GLOBAL"
    nqp_get_package_through_who $P3849, $P3848, "PAST"
    get_who $P3850, $P3849
    set $P3851, $P3850["Op"]
    find_lex $P3852, "$ml"
    unless_null $P3852, vivify_1956
    $P3852 = root_new ['parrot';'Hash']
  vivify_1956:
    set $P3853, $P3852["cond"]
    unless_null $P3853, vivify_1957
    new $P3853, "Undef"
  vivify_1957:
    $P3854 = $P3853."ast"()
    find_lex $P3855, "$past"
    unless_null $P3855, vivify_1958
    new $P3855, "Undef"
  vivify_1958:
    find_lex $P3856, "$ml"
    unless_null $P3856, vivify_1959
    $P3856 = root_new ['parrot';'Hash']
  vivify_1959:
    set $P3857, $P3856["sym"]
    unless_null $P3857, vivify_1960
    new $P3857, "Undef"
  vivify_1960:
    set $S3858, $P3857
    find_lex $P3859, "$/"
    unless_null $P3859, vivify_1961
    new $P3859, "Undef"
  vivify_1961:
    $P3860 = $P3851."new"($P3854, $P3855, $S3858 :named("pasttype"), $P3859 :named("node"))
    store_lex "$past", $P3860
.annotate 'line', 1349
    set $P3829, $P3860
  if_3830_end:
.annotate 'line', 1348
    set $P3826, $P3829
  if_3827_end:
.annotate 'line', 1341
    .return ($P3826)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock" :anon :subid("471_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3885
    .param pmc param_3886
.annotate 'line', 1367
    .lex "self", param_3885
    .lex "$/", param_3886
.annotate 'line', 1368
    find_lex $P3887, "$/"
    get_hll_global $P3888, "GLOBAL"
    nqp_get_package_through_who $P3889, $P3888, "PAST"
    get_who $P3890, $P3889
    set $P3891, $P3890["Op"]
    find_lex $P3892, "$/"
    unless_null $P3892, vivify_1963
    $P3892 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P3893, $P3892["EXPR"]
    unless_null $P3893, vivify_1964
    new $P3893, "Undef"
  vivify_1964:
    $P3894 = $P3893."ast"()
    find_lex $P3895, "$/"
    unless_null $P3895, vivify_1965
    $P3895 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P3896, $P3895["pblock"]
    unless_null $P3896, vivify_1966
    new $P3896, "Undef"
  vivify_1966:
    $P3897 = $P3896."ast"()
    find_lex $P3898, "$/"
    unless_null $P3898, vivify_1967
    new $P3898, "Undef"
  vivify_1967:
    $P3899 = $P3891."new"($P3894, $P3897, "if" :named("pasttype"), $P3898 :named("node"))
    $P3900 = $P3887."!make"($P3899)
.annotate 'line', 1367
    .return ($P3900)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock" :anon :subid("472_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3902
    .param pmc param_3903
.annotate 'line', 1371
    .lex "self", param_3902
    .lex "$/", param_3903
.annotate 'line', 1372
    find_lex $P3904, "$/"
    find_lex $P3905, "$/"
    unless_null $P3905, vivify_1968
    $P3905 = root_new ['parrot';'Hash']
  vivify_1968:
    set $P3906, $P3905["blockoid"]
    unless_null $P3906, vivify_1969
    new $P3906, "Undef"
  vivify_1969:
    $P3907 = $P3906."ast"()
    $P3908 = $P3904."!make"($P3907)
.annotate 'line', 1371
    .return ($P3908)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block" :anon :subid("473_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3910
    .param pmc param_3911
.annotate 'line', 1375
    .lex "self", param_3910
    .lex "$/", param_3911
.annotate 'line', 1376
    find_lex $P3912, "$/"
    find_lex $P3913, "$/"
    unless_null $P3913, vivify_1970
    $P3913 = root_new ['parrot';'Hash']
  vivify_1970:
    set $P3914, $P3913["blockoid"]
    unless_null $P3914, vivify_1971
    new $P3914, "Undef"
  vivify_1971:
    $P3915 = $P3914."ast"()
    $P3916 = $P3912."!make"($P3915)
.annotate 'line', 1375
    .return ($P3916)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid" :anon :subid("474_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3918
    .param pmc param_3919
.annotate 'line', 1379
    .const 'Sub' $P3930 = "475_1306916577.75068" 
    capture_lex $P3930
    .lex "self", param_3918
    .lex "$/", param_3919
.annotate 'line', 1380
    new $P3920, "Undef"
    .lex "$BLOCK", $P3920
    find_lex $P3921, "$?PACKAGE"
    get_who $P3922, $P3921
    set $P3923, $P3922["@BLOCK"]
    unless_null $P3923, vivify_1972
    $P3923 = root_new ['parrot';'ResizablePMCArray']
  vivify_1972:
    $P3924 = $P3923."shift"()
    store_lex "$BLOCK", $P3924
.annotate 'line', 1381
    find_lex $P3927, "$/"
    unless_null $P3927, vivify_1973
    $P3927 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P3928, $P3927["statementlist"]
    unless_null $P3928, vivify_1974
    new $P3928, "Undef"
  vivify_1974:
    if $P3928, if_3926
.annotate 'line', 1389
    find_dynamic_lex $P3947, "$*HAS_YOU_ARE_HERE"
    unless_null $P3947, vivify_1975
    get_hll_global $P3945, "GLOBAL"
    get_who $P3946, $P3945
    set $P3947, $P3946["$HAS_YOU_ARE_HERE"]
    unless_null $P3947, vivify_1976
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1976:
  vivify_1975:
    unless $P3947, if_3944_end
.annotate 'line', 1390
    find_lex $P3948, "$/"
    unless_null $P3948, vivify_1977
    new $P3948, "Undef"
  vivify_1977:
    $P3949 = $P3948."CURSOR"()
    $P3949."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3944_end:
.annotate 'line', 1392
    new $P3950, "Integer"
    assign $P3950, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3950
.annotate 'line', 1393
    find_lex $P3951, "$/"
    find_lex $P3952, "$/"
    unless_null $P3952, vivify_1978
    $P3952 = root_new ['parrot';'Hash']
  vivify_1978:
    set $P3953, $P3952["you_are_here"]
    unless_null $P3953, vivify_1979
    new $P3953, "Undef"
  vivify_1979:
    $P3954 = $P3953."ast"()
    $P3955 = $P3951."!make"($P3954)
.annotate 'line', 1388
    set $P3925, $P3955
.annotate 'line', 1381
    goto if_3926_end
  if_3926:
    .const 'Sub' $P3930 = "475_1306916577.75068" 
    capture_lex $P3930
    $P3943 = $P3930()
    set $P3925, $P3943
  if_3926_end:
.annotate 'line', 1379
    .return ($P3925)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3929"  :anon :subid("475_1306916577.75068") :outer("474_1306916577.75068")
.annotate 'line', 1382
    new $P3931, "Undef"
    .lex "$past", $P3931
    find_lex $P3932, "$/"
    unless_null $P3932, vivify_1980
    $P3932 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P3933, $P3932["statementlist"]
    unless_null $P3933, vivify_1981
    new $P3933, "Undef"
  vivify_1981:
    $P3934 = $P3933."ast"()
    store_lex "$past", $P3934
.annotate 'line', 1383
    find_lex $P3935, "$BLOCK"
    unless_null $P3935, vivify_1982
    new $P3935, "Undef"
  vivify_1982:
    find_lex $P3936, "$past"
    unless_null $P3936, vivify_1983
    new $P3936, "Undef"
  vivify_1983:
    $P3935."push"($P3936)
.annotate 'line', 1384
    find_lex $P3937, "$BLOCK"
    unless_null $P3937, vivify_1984
    new $P3937, "Undef"
  vivify_1984:
    find_lex $P3938, "$/"
    unless_null $P3938, vivify_1985
    new $P3938, "Undef"
  vivify_1985:
    $P3937."node"($P3938)
.annotate 'line', 1385
    find_lex $P3939, "$BLOCK"
    unless_null $P3939, vivify_1986
    new $P3939, "Undef"
  vivify_1986:
    $P3939."closure"(1)
.annotate 'line', 1386
    find_dynamic_lex $P3940, "$/"
    find_lex $P3941, "$BLOCK"
    unless_null $P3941, vivify_1987
    new $P3941, "Undef"
  vivify_1987:
    $P3942 = $P3940."!make"($P3941)
.annotate 'line', 1381
    .return ($P3942)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad" :anon :subid("476_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3957
    .param pmc param_3958
.annotate 'line', 1397
    .lex "self", param_3957
    .lex "$/", param_3958
.annotate 'line', 1398
    find_lex $P3959, "$?PACKAGE"
    get_who $P3960, $P3959
    set $P3961, $P3960["@BLOCK"]
    unless_null $P3961, vivify_1988
    $P3961 = root_new ['parrot';'ResizablePMCArray']
  vivify_1988:
    get_hll_global $P3962, "GLOBAL"
    nqp_get_package_through_who $P3963, $P3962, "PAST"
    get_who $P3964, $P3963
    set $P3965, $P3964["Block"]
    get_hll_global $P3966, "GLOBAL"
    nqp_get_package_through_who $P3967, $P3966, "PAST"
    get_who $P3968, $P3967
    set $P3969, $P3968["Stmts"]
    $P3970 = $P3969."new"()
    $P3971 = $P3965."new"($P3970)
    $P3972 = $P3961."unshift"($P3971)
.annotate 'line', 1397
    .return ($P3972)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx" :anon :subid("477_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_3974
    .param pmc param_3975
.annotate 'line', 1401
    .const 'Sub' $P3984 = "478_1306916577.75068" 
    capture_lex $P3984
    .lex "self", param_3974
    .lex "$/", param_3975
.annotate 'line', 1402
    find_dynamic_lex $P3979, "%*COMPILING"
    unless_null $P3979, vivify_1989
    get_hll_global $P3977, "GLOBAL"
    get_who $P3978, $P3977
    set $P3979, $P3978["%COMPILING"]
    unless_null $P3979, vivify_1990
    die "Contextual %*COMPILING not found"
  vivify_1990:
  vivify_1989:
    set $P3980, $P3979["%?OPTIONS"]
    unless_null $P3980, vivify_1991
    $P3980 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P3981, $P3980["outer_ctx"]
    unless_null $P3981, vivify_1992
    new $P3981, "Undef"
  vivify_1992:
    defined $I3982, $P3981
    if $I3982, unless_3976_end
    .const 'Sub' $P3984 = "478_1306916577.75068" 
    capture_lex $P3984
    $P3984()
  unless_3976_end:
.annotate 'line', 1415
    find_lex $P4016, "self"
    find_lex $P4017, "$?PACKAGE"
    get_who $P4018, $P4017
    set $P4019, $P4018["@BLOCK"]
    unless_null $P4019, vivify_2008
    $P4019 = root_new ['parrot';'ResizablePMCArray']
  vivify_2008:
    set $P4020, $P4019[0]
    unless_null $P4020, vivify_2009
    new $P4020, "Undef"
  vivify_2009:
    $P4021 = $P4016."SET_BLOCK_OUTER_CTX"($P4020)
.annotate 'line', 1401
    .return ($P4021)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3983"  :anon :subid("478_1306916577.75068") :outer("477_1306916577.75068")
.annotate 'line', 1405
    new $P3985, "Undef"
    .lex "$SETTING", $P3985
    find_dynamic_lex $P3988, "$*SC"
    unless_null $P3988, vivify_1993
    get_hll_global $P3986, "GLOBAL"
    get_who $P3987, $P3986
    set $P3988, $P3987["$SC"]
    unless_null $P3988, vivify_1994
    die "Contextual $*SC not found"
  vivify_1994:
  vivify_1993:
    find_dynamic_lex $P3992, "%*COMPILING"
    unless_null $P3992, vivify_1995
    get_hll_global $P3990, "GLOBAL"
    get_who $P3991, $P3990
    set $P3992, $P3991["%COMPILING"]
    unless_null $P3992, vivify_1996
    die "Contextual %*COMPILING not found"
  vivify_1996:
  vivify_1995:
    set $P3993, $P3992["%?OPTIONS"]
    unless_null $P3993, vivify_1997
    $P3993 = root_new ['parrot';'Hash']
  vivify_1997:
    set $P3994, $P3993["setting"]
    unless_null $P3994, vivify_1998
    new $P3994, "Undef"
  vivify_1998:
    set $P3989, $P3994
    defined $I3996, $P3989
    if $I3996, default_3995
    new $P3997, "String"
    assign $P3997, "NQPCORE"
    set $P3989, $P3997
  default_3995:
    $P3998 = $P3988."load_setting"($P3989)
    store_lex "$SETTING", $P3998
.annotate 'line', 1410
    find_dynamic_lex $P4003, "%*COMPILING"
    unless_null $P4003, vivify_1999
    get_hll_global $P4001, "GLOBAL"
    get_who $P4002, $P4001
    set $P4003, $P4002["%COMPILING"]
    unless_null $P4003, vivify_2000
    die "Contextual %*COMPILING not found"
  vivify_2000:
  vivify_1999:
    set $P4004, $P4003["%?OPTIONS"]
    unless_null $P4004, vivify_2001
    $P4004 = root_new ['parrot';'Hash']
  vivify_2001:
    set $P4005, $P4004["setting"]
    unless_null $P4005, vivify_2002
    new $P4005, "Undef"
  vivify_2002:
    set $S4006, $P4005
    iseq $I4007, $S4006, "NULL"
    unless $I4007, unless_4000
    new $P3999, 'Integer'
    set $P3999, $I4007
    goto unless_4000_end
  unless_4000:
.annotate 'line', 1411
    find_lex $P4008, "$SETTING"
    unless_null $P4008, vivify_2003
    new $P4008, "Undef"
  vivify_2003:
    "import_HOW_exports"($P4008)
.annotate 'line', 1412
    find_dynamic_lex $P4011, "$*SC"
    unless_null $P4011, vivify_2004
    get_hll_global $P4009, "GLOBAL"
    get_who $P4010, $P4009
    set $P4011, $P4010["$SC"]
    unless_null $P4011, vivify_2005
    die "Contextual $*SC not found"
  vivify_2005:
  vivify_2004:
    find_dynamic_lex $P4014, "$*GLOBALish"
    unless_null $P4014, vivify_2006
    get_hll_global $P4012, "GLOBAL"
    get_who $P4013, $P4012
    set $P4014, $P4013["$GLOBALish"]
    unless_null $P4014, vivify_2007
    die "Contextual $*GLOBALish not found"
  vivify_2007:
  vivify_2006:
    $P4015 = $P4011."load_module"("NQPRegex", $P4014)
.annotate 'line', 1410
    set $P3999, $P4015
  unless_4000_end:
.annotate 'line', 1402
    .return ($P3999)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish" :anon :subid("479_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4024
    .param pmc param_4025
.annotate 'line', 1427
    .lex "self", param_4024
    .lex "$/", param_4025
.annotate 'line', 1431
    find_dynamic_lex $P4028, "$*SC"
    unless_null $P4028, vivify_2010
    get_hll_global $P4026, "GLOBAL"
    get_who $P4027, $P4026
    set $P4028, $P4027["$SC"]
    unless_null $P4028, vivify_2011
    die "Contextual $*SC not found"
  vivify_2011:
  vivify_2010:
    find_dynamic_lex $P4031, "%*HOW"
    unless_null $P4031, vivify_2012
    get_hll_global $P4029, "GLOBAL"
    get_who $P4030, $P4029
    set $P4031, $P4030["%HOW"]
    unless_null $P4031, vivify_2013
    die "Contextual %*HOW not found"
  vivify_2013:
  vivify_2012:
    set $P4032, $P4031["knowhow"]
    unless_null $P4032, vivify_2014
    new $P4032, "Undef"
  vivify_2014:
    $P4033 = $P4028."pkg_create_mo"($P4032, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P4033
.annotate 'line', 1432
    find_dynamic_lex $P4036, "$*GLOBALish"
    unless_null $P4036, vivify_2015
    get_hll_global $P4034, "GLOBAL"
    get_who $P4035, $P4034
    set $P4036, $P4035["$GLOBALish"]
    unless_null $P4036, vivify_2016
    die "Contextual $*GLOBALish not found"
  vivify_2016:
  vivify_2015:
    get_how $P4037, $P4036
    find_dynamic_lex $P4040, "$*GLOBALish"
    unless_null $P4040, vivify_2017
    get_hll_global $P4038, "GLOBAL"
    get_who $P4039, $P4038
    set $P4040, $P4039["$GLOBALish"]
    unless_null $P4040, vivify_2018
    die "Contextual $*GLOBALish not found"
  vivify_2018:
  vivify_2017:
    $P4037."compose"($P4040)
.annotate 'line', 1433
    find_dynamic_lex $P4043, "$*SC"
    unless_null $P4043, vivify_2019
    get_hll_global $P4041, "GLOBAL"
    get_who $P4042, $P4041
    set $P4043, $P4042["$SC"]
    unless_null $P4043, vivify_2020
    die "Contextual $*SC not found"
  vivify_2020:
  vivify_2019:
    find_lex $P4044, "$?PACKAGE"
    get_who $P4045, $P4044
    set $P4046, $P4045["@BLOCK"]
    unless_null $P4046, vivify_2021
    $P4046 = root_new ['parrot';'ResizablePMCArray']
  vivify_2021:
    set $P4047, $P4046[0]
    unless_null $P4047, vivify_2022
    new $P4047, "Undef"
  vivify_2022:
    find_dynamic_lex $P4050, "$*GLOBALish"
    unless_null $P4050, vivify_2023
    get_hll_global $P4048, "GLOBAL"
    get_who $P4049, $P4048
    set $P4050, $P4049["$GLOBALish"]
    unless_null $P4050, vivify_2024
    die "Contextual $*GLOBALish not found"
  vivify_2024:
  vivify_2023:
    $P4043."install_lexical_symbol"($P4047, "GLOBALish", $P4050)
.annotate 'line', 1436
    find_dynamic_lex $P4053, "$*GLOBALish"
    unless_null $P4053, vivify_2025
    get_hll_global $P4051, "GLOBAL"
    get_who $P4052, $P4051
    set $P4053, $P4052["$GLOBALish"]
    unless_null $P4053, vivify_2026
    die "Contextual $*GLOBALish not found"
  vivify_2026:
  vivify_2025:
    store_dynamic_lex "$*PACKAGE", $P4053
.annotate 'line', 1437
    find_dynamic_lex $P4056, "$*SC"
    unless_null $P4056, vivify_2027
    get_hll_global $P4054, "GLOBAL"
    get_who $P4055, $P4054
    set $P4056, $P4055["$SC"]
    unless_null $P4056, vivify_2028
    die "Contextual $*SC not found"
  vivify_2028:
  vivify_2027:
    find_lex $P4057, "$?PACKAGE"
    get_who $P4058, $P4057
    set $P4059, $P4058["@BLOCK"]
    unless_null $P4059, vivify_2029
    $P4059 = root_new ['parrot';'ResizablePMCArray']
  vivify_2029:
    set $P4060, $P4059[0]
    unless_null $P4060, vivify_2030
    new $P4060, "Undef"
  vivify_2030:
    find_dynamic_lex $P4063, "$*PACKAGE"
    unless_null $P4063, vivify_2031
    get_hll_global $P4061, "GLOBAL"
    get_who $P4062, $P4061
    set $P4063, $P4062["$PACKAGE"]
    unless_null $P4063, vivify_2032
    die "Contextual $*PACKAGE not found"
  vivify_2032:
  vivify_2031:
    $P4064 = $P4056."install_lexical_symbol"($P4060, "$?PACKAGE", $P4063)
.annotate 'line', 1427
    .return ($P4064)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here" :anon :subid("480_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4066
    .param pmc param_4067
.annotate 'line', 1440
    .lex "self", param_4066
    .lex "$/", param_4067
.annotate 'line', 1441
    find_lex $P4068, "$/"
    find_lex $P4069, "self"
    $P4070 = $P4069."CTXSAVE"()
    $P4071 = $P4068."!make"($P4070)
.annotate 'line', 1440
    .return ($P4071)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>" :anon :subid("481_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4073
    .param pmc param_4074
.annotate 'line', 1446
    .lex "self", param_4073
    .lex "$/", param_4074
.annotate 'line', 1447
    new $P4075, "Undef"
    .lex "$module", $P4075
    find_dynamic_lex $P4078, "$*SC"
    unless_null $P4078, vivify_2033
    get_hll_global $P4076, "GLOBAL"
    get_who $P4077, $P4076
    set $P4078, $P4077["$SC"]
    unless_null $P4078, vivify_2034
    die "Contextual $*SC not found"
  vivify_2034:
  vivify_2033:
    find_lex $P4079, "$/"
    unless_null $P4079, vivify_2035
    $P4079 = root_new ['parrot';'Hash']
  vivify_2035:
    set $P4080, $P4079["name"]
    unless_null $P4080, vivify_2036
    new $P4080, "Undef"
  vivify_2036:
    set $S4081, $P4080
    find_dynamic_lex $P4084, "$*GLOBALish"
    unless_null $P4084, vivify_2037
    get_hll_global $P4082, "GLOBAL"
    get_who $P4083, $P4082
    set $P4084, $P4083["$GLOBALish"]
    unless_null $P4084, vivify_2038
    die "Contextual $*GLOBALish not found"
  vivify_2038:
  vivify_2037:
    $P4085 = $P4078."load_module"($S4081, $P4084)
    store_lex "$module", $P4085
.annotate 'line', 1448
    find_lex $P4087, "$module"
    unless_null $P4087, vivify_2039
    new $P4087, "Undef"
  vivify_2039:
    defined $I4088, $P4087
    unless $I4088, if_4086_end
.annotate 'line', 1449
    find_lex $P4089, "$module"
    unless_null $P4089, vivify_2040
    new $P4089, "Undef"
  vivify_2040:
    "import_HOW_exports"($P4089)
  if_4086_end:
.annotate 'line', 1451
    find_lex $P4090, "$/"
    get_hll_global $P4091, "GLOBAL"
    nqp_get_package_through_who $P4092, $P4091, "PAST"
    get_who $P4093, $P4092
    set $P4094, $P4093["Stmts"]
    $P4095 = $P4094."new"()
    $P4096 = $P4090."!make"($P4095)
.annotate 'line', 1446
    .return ($P4096)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>" :anon :subid("482_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4098
    .param pmc param_4099
.annotate 'line', 1454
    .const 'Sub' $P4127 = "483_1306916577.75068" 
    capture_lex $P4127
    .lex "self", param_4098
    .lex "$/", param_4099
.annotate 'line', 1455
    new $P4100, "Undef"
    .lex "$count", $P4100
.annotate 'line', 1456
    new $P4101, "Undef"
    .lex "$past", $P4101
.annotate 'line', 1455
    find_lex $P4102, "$/"
    unless_null $P4102, vivify_2041
    $P4102 = root_new ['parrot';'Hash']
  vivify_2041:
    set $P4103, $P4102["xblock"]
    unless_null $P4103, vivify_2042
    new $P4103, "Undef"
  vivify_2042:
    set $N4104, $P4103
    new $P4105, 'Float'
    set $P4105, $N4104
    sub $P4106, $P4105, 1
    store_lex "$count", $P4106
.annotate 'line', 1456
    find_lex $P4107, "$count"
    unless_null $P4107, vivify_2043
    new $P4107, "Undef"
  vivify_2043:
    set $I4108, $P4107
    find_lex $P4109, "$/"
    unless_null $P4109, vivify_2044
    $P4109 = root_new ['parrot';'Hash']
  vivify_2044:
    set $P4110, $P4109["xblock"]
    unless_null $P4110, vivify_2045
    $P4110 = root_new ['parrot';'ResizablePMCArray']
  vivify_2045:
    set $P4111, $P4110[$I4108]
    unless_null $P4111, vivify_2046
    new $P4111, "Undef"
  vivify_2046:
    $P4112 = $P4111."ast"()
    $P4113 = "xblock_immediate"($P4112)
    store_lex "$past", $P4113
.annotate 'line', 1457
    find_lex $P4115, "$/"
    unless_null $P4115, vivify_2047
    $P4115 = root_new ['parrot';'Hash']
  vivify_2047:
    set $P4116, $P4115["else"]
    unless_null $P4116, vivify_2048
    new $P4116, "Undef"
  vivify_2048:
    unless $P4116, if_4114_end
.annotate 'line', 1458
    find_lex $P4117, "$past"
    unless_null $P4117, vivify_2049
    new $P4117, "Undef"
  vivify_2049:
    find_lex $P4118, "$/"
    unless_null $P4118, vivify_2050
    $P4118 = root_new ['parrot';'Hash']
  vivify_2050:
    set $P4119, $P4118["else"]
    unless_null $P4119, vivify_2051
    $P4119 = root_new ['parrot';'ResizablePMCArray']
  vivify_2051:
    set $P4120, $P4119[0]
    unless_null $P4120, vivify_2052
    new $P4120, "Undef"
  vivify_2052:
    $P4121 = $P4120."ast"()
    $P4122 = "block_immediate"($P4121)
    $P4117."push"($P4122)
  if_4114_end:
.annotate 'line', 1461
    new $P4143, 'ExceptionHandler'
    set_label $P4143, loop4142_handler
    $P4143."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4143
  loop4142_test:
    find_lex $P4123, "$count"
    unless_null $P4123, vivify_2053
    new $P4123, "Undef"
  vivify_2053:
    set $N4124, $P4123
    isgt $I4125, $N4124, 0.0
    unless $I4125, loop4142_done
  loop4142_redo:
    .const 'Sub' $P4127 = "483_1306916577.75068" 
    capture_lex $P4127
    $P4127()
  loop4142_next:
    goto loop4142_test
  loop4142_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4144, exception, 'type'
    eq $P4144, .CONTROL_LOOP_NEXT, loop4142_next
    eq $P4144, .CONTROL_LOOP_REDO, loop4142_redo
  loop4142_done:
    pop_eh 
.annotate 'line', 1467
    find_lex $P4145, "$/"
    find_lex $P4146, "$past"
    unless_null $P4146, vivify_2062
    new $P4146, "Undef"
  vivify_2062:
    $P4147 = $P4145."!make"($P4146)
.annotate 'line', 1454
    .return ($P4147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4126"  :anon :subid("483_1306916577.75068") :outer("482_1306916577.75068")
.annotate 'line', 1463
    new $P4128, "Undef"
    .lex "$else", $P4128
.annotate 'line', 1461
    find_lex $P4129, "$count"
    unless_null $P4129, vivify_2054
    new $P4129, "Undef"
  vivify_2054:
    clone $P4130, $P4129
    dec $P4129
.annotate 'line', 1463
    find_lex $P4131, "$past"
    unless_null $P4131, vivify_2055
    new $P4131, "Undef"
  vivify_2055:
    store_lex "$else", $P4131
.annotate 'line', 1464
    find_lex $P4132, "$count"
    unless_null $P4132, vivify_2056
    new $P4132, "Undef"
  vivify_2056:
    set $I4133, $P4132
    find_lex $P4134, "$/"
    unless_null $P4134, vivify_2057
    $P4134 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P4135, $P4134["xblock"]
    unless_null $P4135, vivify_2058
    $P4135 = root_new ['parrot';'ResizablePMCArray']
  vivify_2058:
    set $P4136, $P4135[$I4133]
    unless_null $P4136, vivify_2059
    new $P4136, "Undef"
  vivify_2059:
    $P4137 = $P4136."ast"()
    $P4138 = "xblock_immediate"($P4137)
    store_lex "$past", $P4138
.annotate 'line', 1465
    find_lex $P4139, "$past"
    unless_null $P4139, vivify_2060
    new $P4139, "Undef"
  vivify_2060:
    find_lex $P4140, "$else"
    unless_null $P4140, vivify_2061
    new $P4140, "Undef"
  vivify_2061:
    $P4141 = $P4139."push"($P4140)
.annotate 'line', 1461
    .return ($P4141)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>" :anon :subid("484_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4149
    .param pmc param_4150
.annotate 'line', 1470
    .lex "self", param_4149
    .lex "$/", param_4150
.annotate 'line', 1471
    new $P4151, "Undef"
    .lex "$past", $P4151
    find_lex $P4152, "$/"
    unless_null $P4152, vivify_2063
    $P4152 = root_new ['parrot';'Hash']
  vivify_2063:
    set $P4153, $P4152["xblock"]
    unless_null $P4153, vivify_2064
    new $P4153, "Undef"
  vivify_2064:
    $P4154 = $P4153."ast"()
    $P4155 = "xblock_immediate"($P4154)
    store_lex "$past", $P4155
.annotate 'line', 1472
    find_lex $P4156, "$past"
    unless_null $P4156, vivify_2065
    new $P4156, "Undef"
  vivify_2065:
    $P4156."pasttype"("unless")
.annotate 'line', 1473
    find_lex $P4157, "$/"
    find_lex $P4158, "$past"
    unless_null $P4158, vivify_2066
    new $P4158, "Undef"
  vivify_2066:
    $P4159 = $P4157."!make"($P4158)
.annotate 'line', 1470
    .return ($P4159)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>" :anon :subid("485_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4161
    .param pmc param_4162
.annotate 'line', 1476
    .lex "self", param_4161
    .lex "$/", param_4162
.annotate 'line', 1477
    new $P4163, "Undef"
    .lex "$past", $P4163
    find_lex $P4164, "$/"
    unless_null $P4164, vivify_2067
    $P4164 = root_new ['parrot';'Hash']
  vivify_2067:
    set $P4165, $P4164["xblock"]
    unless_null $P4165, vivify_2068
    new $P4165, "Undef"
  vivify_2068:
    $P4166 = $P4165."ast"()
    $P4167 = "xblock_immediate"($P4166)
    store_lex "$past", $P4167
.annotate 'line', 1478
    find_lex $P4168, "$past"
    unless_null $P4168, vivify_2069
    new $P4168, "Undef"
  vivify_2069:
    find_lex $P4169, "$/"
    unless_null $P4169, vivify_2070
    $P4169 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P4170, $P4169["sym"]
    unless_null $P4170, vivify_2071
    new $P4170, "Undef"
  vivify_2071:
    set $S4171, $P4170
    $P4168."pasttype"($S4171)
.annotate 'line', 1479
    find_lex $P4172, "$/"
    find_lex $P4173, "$past"
    unless_null $P4173, vivify_2072
    new $P4173, "Undef"
  vivify_2072:
    $P4174 = $P4172."!make"($P4173)
.annotate 'line', 1476
    .return ($P4174)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>" :anon :subid("486_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4176
    .param pmc param_4177
.annotate 'line', 1482
    .lex "self", param_4176
    .lex "$/", param_4177
.annotate 'line', 1483
    new $P4178, "Undef"
    .lex "$pasttype", $P4178
.annotate 'line', 1484
    new $P4179, "Undef"
    .lex "$past", $P4179
.annotate 'line', 1483
    new $P4180, "String"
    assign $P4180, "repeat_"
    find_lex $P4181, "$/"
    unless_null $P4181, vivify_2073
    $P4181 = root_new ['parrot';'Hash']
  vivify_2073:
    set $P4182, $P4181["wu"]
    unless_null $P4182, vivify_2074
    new $P4182, "Undef"
  vivify_2074:
    set $S4183, $P4182
    concat $P4184, $P4180, $S4183
    store_lex "$pasttype", $P4184
    find_lex $P4185, "$past"
    unless_null $P4185, vivify_2075
    new $P4185, "Undef"
  vivify_2075:
.annotate 'line', 1485
    find_lex $P4187, "$/"
    unless_null $P4187, vivify_2076
    $P4187 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P4188, $P4187["xblock"]
    unless_null $P4188, vivify_2077
    new $P4188, "Undef"
  vivify_2077:
    if $P4188, if_4186
.annotate 'line', 1490
    get_hll_global $P4195, "GLOBAL"
    nqp_get_package_through_who $P4196, $P4195, "PAST"
    get_who $P4197, $P4196
    set $P4198, $P4197["Op"]
    find_lex $P4199, "$/"
    unless_null $P4199, vivify_2078
    $P4199 = root_new ['parrot';'Hash']
  vivify_2078:
    set $P4200, $P4199["EXPR"]
    unless_null $P4200, vivify_2079
    new $P4200, "Undef"
  vivify_2079:
    $P4201 = $P4200."ast"()
    find_lex $P4202, "$/"
    unless_null $P4202, vivify_2080
    $P4202 = root_new ['parrot';'Hash']
  vivify_2080:
    set $P4203, $P4202["pblock"]
    unless_null $P4203, vivify_2081
    new $P4203, "Undef"
  vivify_2081:
    $P4204 = $P4203."ast"()
    $P4205 = "block_immediate"($P4204)
    find_lex $P4206, "$pasttype"
    unless_null $P4206, vivify_2082
    new $P4206, "Undef"
  vivify_2082:
    find_lex $P4207, "$/"
    unless_null $P4207, vivify_2083
    new $P4207, "Undef"
  vivify_2083:
    $P4208 = $P4198."new"($P4201, $P4205, $P4206 :named("pasttype"), $P4207 :named("node"))
    store_lex "$past", $P4208
.annotate 'line', 1489
    goto if_4186_end
  if_4186:
.annotate 'line', 1486
    find_lex $P4189, "$/"
    unless_null $P4189, vivify_2084
    $P4189 = root_new ['parrot';'Hash']
  vivify_2084:
    set $P4190, $P4189["xblock"]
    unless_null $P4190, vivify_2085
    new $P4190, "Undef"
  vivify_2085:
    $P4191 = $P4190."ast"()
    $P4192 = "xblock_immediate"($P4191)
    store_lex "$past", $P4192
.annotate 'line', 1487
    find_lex $P4193, "$past"
    unless_null $P4193, vivify_2086
    new $P4193, "Undef"
  vivify_2086:
    find_lex $P4194, "$pasttype"
    unless_null $P4194, vivify_2087
    new $P4194, "Undef"
  vivify_2087:
    $P4193."pasttype"($P4194)
  if_4186_end:
.annotate 'line', 1493
    find_lex $P4209, "$/"
    find_lex $P4210, "$past"
    unless_null $P4210, vivify_2088
    new $P4210, "Undef"
  vivify_2088:
    $P4211 = $P4209."!make"($P4210)
.annotate 'line', 1482
    .return ($P4211)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>" :anon :subid("487_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4213
    .param pmc param_4214
.annotate 'line', 1496
    .lex "self", param_4213
    .lex "$/", param_4214
.annotate 'line', 1497
    new $P4215, "Undef"
    .lex "$past", $P4215
.annotate 'line', 1499
    new $P4216, "Undef"
    .lex "$block", $P4216
.annotate 'line', 1497
    find_lex $P4217, "$/"
    unless_null $P4217, vivify_2089
    $P4217 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P4218, $P4217["xblock"]
    unless_null $P4218, vivify_2090
    new $P4218, "Undef"
  vivify_2090:
    $P4219 = $P4218."ast"()
    store_lex "$past", $P4219
.annotate 'line', 1498
    find_lex $P4220, "$past"
    unless_null $P4220, vivify_2091
    new $P4220, "Undef"
  vivify_2091:
    $P4220."pasttype"("for")
.annotate 'line', 1499
    find_lex $P4221, "$past"
    unless_null $P4221, vivify_2092
    $P4221 = root_new ['parrot';'ResizablePMCArray']
  vivify_2092:
    set $P4222, $P4221[1]
    unless_null $P4222, vivify_2093
    new $P4222, "Undef"
  vivify_2093:
    store_lex "$block", $P4222
.annotate 'line', 1500
    find_lex $P4224, "$block"
    unless_null $P4224, vivify_2094
    new $P4224, "Undef"
  vivify_2094:
    $P4225 = $P4224."arity"()
    if $P4225, unless_4223_end
.annotate 'line', 1501
    find_lex $P4226, "$block"
    unless_null $P4226, vivify_2095
    $P4226 = root_new ['parrot';'ResizablePMCArray']
  vivify_2095:
    set $P4227, $P4226[0]
    unless_null $P4227, vivify_2096
    new $P4227, "Undef"
  vivify_2096:
    get_hll_global $P4228, "GLOBAL"
    nqp_get_package_through_who $P4229, $P4228, "PAST"
    get_who $P4230, $P4229
    set $P4231, $P4230["Var"]
    $P4232 = $P4231."new"("$_" :named("name"), "parameter" :named("scope"))
    $P4227."push"($P4232)
.annotate 'line', 1502
    find_lex $P4233, "$block"
    unless_null $P4233, vivify_2097
    new $P4233, "Undef"
  vivify_2097:
    $P4233."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1503
    find_lex $P4234, "$block"
    unless_null $P4234, vivify_2098
    new $P4234, "Undef"
  vivify_2098:
    $P4234."arity"(1)
  unless_4223_end:
.annotate 'line', 1505
    find_lex $P4235, "$block"
    unless_null $P4235, vivify_2099
    new $P4235, "Undef"
  vivify_2099:
    $P4235."blocktype"("immediate")
.annotate 'line', 1506
    find_lex $P4236, "$/"
    find_lex $P4237, "$past"
    unless_null $P4237, vivify_2100
    new $P4237, "Undef"
  vivify_2100:
    $P4238 = $P4236."!make"($P4237)
.annotate 'line', 1496
    .return ($P4238)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>" :anon :subid("488_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4240
    .param pmc param_4241
.annotate 'line', 1509
    .lex "self", param_4240
    .lex "$/", param_4241
.annotate 'line', 1510
    new $P4242, "Undef"
    .lex "$block", $P4242
    find_lex $P4243, "$/"
    unless_null $P4243, vivify_2101
    $P4243 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P4244, $P4243["block"]
    unless_null $P4244, vivify_2102
    new $P4244, "Undef"
  vivify_2102:
    $P4245 = $P4244."ast"()
    store_lex "$block", $P4245
.annotate 'line', 1511
    find_lex $P4246, "$/"
    unless_null $P4246, vivify_2103
    new $P4246, "Undef"
  vivify_2103:
    find_lex $P4247, "$block"
    unless_null $P4247, vivify_2104
    new $P4247, "Undef"
  vivify_2104:
    "push_block_handler"($P4246, $P4247)
.annotate 'line', 1512
    find_lex $P4248, "$?PACKAGE"
    get_who $P4249, $P4248
    set $P4250, $P4249["@BLOCK"]
    unless_null $P4250, vivify_2105
    $P4250 = root_new ['parrot';'ResizablePMCArray']
  vivify_2105:
    set $P4251, $P4250[0]
    unless_null $P4251, vivify_2106
    new $P4251, "Undef"
  vivify_2106:
    $P4252 = $P4251."handlers"()
    set $P4253, $P4252[0]
    unless_null $P4253, vivify_2107
    new $P4253, "Undef"
  vivify_2107:
    $P4253."handle_types_except"("CONTROL")
.annotate 'line', 1513
    find_lex $P4254, "$/"
    get_hll_global $P4255, "GLOBAL"
    nqp_get_package_through_who $P4256, $P4255, "PAST"
    get_who $P4257, $P4256
    set $P4258, $P4257["Stmts"]
    find_lex $P4259, "$/"
    unless_null $P4259, vivify_2108
    new $P4259, "Undef"
  vivify_2108:
    $P4260 = $P4258."new"($P4259 :named("node"))
    $P4261 = $P4254."!make"($P4260)
.annotate 'line', 1509
    .return ($P4261)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>" :anon :subid("489_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4263
    .param pmc param_4264
.annotate 'line', 1516
    .lex "self", param_4263
    .lex "$/", param_4264
.annotate 'line', 1517
    new $P4265, "Undef"
    .lex "$block", $P4265
    find_lex $P4266, "$/"
    unless_null $P4266, vivify_2109
    $P4266 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4267, $P4266["block"]
    unless_null $P4267, vivify_2110
    new $P4267, "Undef"
  vivify_2110:
    $P4268 = $P4267."ast"()
    store_lex "$block", $P4268
.annotate 'line', 1518
    find_lex $P4269, "$/"
    unless_null $P4269, vivify_2111
    new $P4269, "Undef"
  vivify_2111:
    find_lex $P4270, "$block"
    unless_null $P4270, vivify_2112
    new $P4270, "Undef"
  vivify_2112:
    "push_block_handler"($P4269, $P4270)
.annotate 'line', 1519
    find_lex $P4271, "$?PACKAGE"
    get_who $P4272, $P4271
    set $P4273, $P4272["@BLOCK"]
    unless_null $P4273, vivify_2113
    $P4273 = root_new ['parrot';'ResizablePMCArray']
  vivify_2113:
    set $P4274, $P4273[0]
    unless_null $P4274, vivify_2114
    new $P4274, "Undef"
  vivify_2114:
    $P4275 = $P4274."handlers"()
    set $P4276, $P4275[0]
    unless_null $P4276, vivify_2115
    new $P4276, "Undef"
  vivify_2115:
    $P4276."handle_types"("CONTROL")
.annotate 'line', 1520
    find_lex $P4277, "$/"
    get_hll_global $P4278, "GLOBAL"
    nqp_get_package_through_who $P4279, $P4278, "PAST"
    get_who $P4280, $P4279
    set $P4281, $P4280["Stmts"]
    find_lex $P4282, "$/"
    unless_null $P4282, vivify_2116
    new $P4282, "Undef"
  vivify_2116:
    $P4283 = $P4281."new"($P4282 :named("node"))
    $P4284 = $P4277."!make"($P4283)
.annotate 'line', 1516
    .return ($P4284)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>" :anon :subid("490_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4287
    .param pmc param_4288
.annotate 'line', 1560
    .lex "self", param_4287
    .lex "$/", param_4288
.annotate 'line', 1561
    find_lex $P4289, "$?PACKAGE"
    get_who $P4290, $P4289
    set $P4291, $P4290["@BLOCK"]
    unless_null $P4291, vivify_2117
    $P4291 = root_new ['parrot';'ResizablePMCArray']
  vivify_2117:
    set $P4292, $P4291[0]
    unless_null $P4292, vivify_2118
    new $P4292, "Undef"
  vivify_2118:
    find_lex $P4293, "$/"
    unless_null $P4293, vivify_2119
    $P4293 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4294, $P4293["blorst"]
    unless_null $P4294, vivify_2120
    new $P4294, "Undef"
  vivify_2120:
    $P4295 = $P4294."ast"()
    $P4292."push"($P4295)
.annotate 'line', 1562
    find_lex $P4296, "$/"
    get_hll_global $P4297, "GLOBAL"
    nqp_get_package_through_who $P4298, $P4297, "PAST"
    get_who $P4299, $P4298
    set $P4300, $P4299["Stmts"]
    $P4301 = $P4300."new"()
    $P4302 = $P4296."!make"($P4301)
.annotate 'line', 1560
    .return ($P4302)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>" :anon :subid("491_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4304
    .param pmc param_4305
.annotate 'line', 1565
    .lex "self", param_4304
    .lex "$/", param_4305
.annotate 'line', 1566
    new $P4306, "Undef"
    .lex "$past", $P4306
    find_lex $P4307, "$/"
    unless_null $P4307, vivify_2121
    $P4307 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P4308, $P4307["blorst"]
    unless_null $P4308, vivify_2122
    new $P4308, "Undef"
  vivify_2122:
    $P4309 = $P4308."ast"()
    store_lex "$past", $P4309
.annotate 'line', 1567
    get_hll_global $P4311, "GLOBAL"
    nqp_get_package_through_who $P4312, $P4311, "PAST"
    get_who $P4313, $P4312
    set $P4314, $P4313["Block"]
    find_lex $P4315, "$past"
    unless_null $P4315, vivify_2123
    new $P4315, "Undef"
  vivify_2123:
    $P4316 = $P4314."ACCEPTS"($P4315)
    if $P4316, unless_4310_end
.annotate 'line', 1568
    get_hll_global $P4317, "GLOBAL"
    nqp_get_package_through_who $P4318, $P4317, "PAST"
    get_who $P4319, $P4318
    set $P4320, $P4319["Block"]
    find_lex $P4321, "$past"
    unless_null $P4321, vivify_2124
    new $P4321, "Undef"
  vivify_2124:
    find_lex $P4322, "$/"
    unless_null $P4322, vivify_2125
    new $P4322, "Undef"
  vivify_2125:
    $P4323 = $P4320."new"($P4321, "immediate" :named("blocktype"), $P4322 :named("node"))
    store_lex "$past", $P4323
  unless_4310_end:
.annotate 'line', 1570
    find_lex $P4325, "$past"
    unless_null $P4325, vivify_2126
    new $P4325, "Undef"
  vivify_2126:
    $P4326 = $P4325."handlers"()
    if $P4326, unless_4324_end
.annotate 'line', 1571
    find_lex $P4327, "$past"
    unless_null $P4327, vivify_2127
    new $P4327, "Undef"
  vivify_2127:
    get_hll_global $P4328, "GLOBAL"
    nqp_get_package_through_who $P4329, $P4328, "PAST"
    get_who $P4330, $P4329
    set $P4331, $P4330["Control"]
.annotate 'line', 1573
    get_hll_global $P4332, "GLOBAL"
    nqp_get_package_through_who $P4333, $P4332, "PAST"
    get_who $P4334, $P4333
    set $P4335, $P4334["Stmts"]
.annotate 'line', 1574
    get_hll_global $P4336, "GLOBAL"
    nqp_get_package_through_who $P4337, $P4336, "PAST"
    get_who $P4338, $P4337
    set $P4339, $P4338["Op"]
.annotate 'line', 1575
    get_hll_global $P4340, "GLOBAL"
    nqp_get_package_through_who $P4341, $P4340, "PAST"
    get_who $P4342, $P4341
    set $P4343, $P4342["Var"]
.annotate 'line', 1576
    get_hll_global $P4344, "GLOBAL"
    nqp_get_package_through_who $P4345, $P4344, "PAST"
    get_who $P4346, $P4345
    set $P4347, $P4346["Var"]
    $P4348 = $P4347."new"("register" :named("scope"), "exception" :named("name"))
    $P4349 = $P4343."new"($P4348, "handled", "keyed" :named("scope"))
.annotate 'line', 1575
    $P4350 = $P4339."new"($P4349, 1, "bind" :named("pasttype"))
.annotate 'line', 1574
    $P4351 = $P4335."new"($P4350)
.annotate 'line', 1573
    $P4352 = $P4331."new"($P4351, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1571
    new $P4353, "ResizablePMCArray"
    push $P4353, $P4352
    $P4327."handlers"($P4353)
  unless_4324_end:
.annotate 'line', 1585
    find_lex $P4354, "$/"
    find_lex $P4355, "$past"
    unless_null $P4355, vivify_2128
    new $P4355, "Undef"
  vivify_2128:
    $P4356 = $P4354."!make"($P4355)
.annotate 'line', 1565
    .return ($P4356)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst" :anon :subid("492_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4358
    .param pmc param_4359
.annotate 'line', 1588
    .lex "self", param_4358
    .lex "$/", param_4359
.annotate 'line', 1589
    find_lex $P4360, "$/"
.annotate 'line', 1590
    find_lex $P4363, "$/"
    unless_null $P4363, vivify_2129
    $P4363 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P4364, $P4363["block"]
    unless_null $P4364, vivify_2130
    new $P4364, "Undef"
  vivify_2130:
    if $P4364, if_4362
.annotate 'line', 1591
    find_lex $P4369, "$/"
    unless_null $P4369, vivify_2131
    $P4369 = root_new ['parrot';'Hash']
  vivify_2131:
    set $P4370, $P4369["statement"]
    unless_null $P4370, vivify_2132
    new $P4370, "Undef"
  vivify_2132:
    $P4371 = $P4370."ast"()
    set $P4361, $P4371
.annotate 'line', 1590
    goto if_4362_end
  if_4362:
    find_lex $P4365, "$/"
    unless_null $P4365, vivify_2133
    $P4365 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P4366, $P4365["block"]
    unless_null $P4366, vivify_2134
    new $P4366, "Undef"
  vivify_2134:
    $P4367 = $P4366."ast"()
    $P4368 = "block_immediate"($P4367)
    set $P4361, $P4368
  if_4362_end:
    $P4372 = $P4360."!make"($P4361)
.annotate 'line', 1588
    .return ($P4372)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>" :anon :subid("493_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4374
    .param pmc param_4375
.annotate 'line', 1596
    .lex "self", param_4374
    .lex "$/", param_4375
    find_lex $P4376, "$/"
    find_lex $P4377, "$/"
    unless_null $P4377, vivify_2135
    $P4377 = root_new ['parrot';'Hash']
  vivify_2135:
    set $P4378, $P4377["cond"]
    unless_null $P4378, vivify_2136
    new $P4378, "Undef"
  vivify_2136:
    $P4379 = $P4378."ast"()
    $P4380 = $P4376."!make"($P4379)
    .return ($P4380)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>" :anon :subid("494_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4382
    .param pmc param_4383
.annotate 'line', 1597
    .lex "self", param_4382
    .lex "$/", param_4383
    find_lex $P4384, "$/"
    find_lex $P4385, "$/"
    unless_null $P4385, vivify_2137
    $P4385 = root_new ['parrot';'Hash']
  vivify_2137:
    set $P4386, $P4385["cond"]
    unless_null $P4386, vivify_2138
    new $P4386, "Undef"
  vivify_2138:
    $P4387 = $P4386."ast"()
    $P4388 = $P4384."!make"($P4387)
    .return ($P4388)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>" :anon :subid("495_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4390
    .param pmc param_4391
.annotate 'line', 1599
    .lex "self", param_4390
    .lex "$/", param_4391
    find_lex $P4392, "$/"
    find_lex $P4393, "$/"
    unless_null $P4393, vivify_2139
    $P4393 = root_new ['parrot';'Hash']
  vivify_2139:
    set $P4394, $P4393["cond"]
    unless_null $P4394, vivify_2140
    new $P4394, "Undef"
  vivify_2140:
    $P4395 = $P4394."ast"()
    $P4396 = $P4392."!make"($P4395)
    .return ($P4396)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>" :anon :subid("496_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4398
    .param pmc param_4399
.annotate 'line', 1600
    .lex "self", param_4398
    .lex "$/", param_4399
    find_lex $P4400, "$/"
    find_lex $P4401, "$/"
    unless_null $P4401, vivify_2141
    $P4401 = root_new ['parrot';'Hash']
  vivify_2141:
    set $P4402, $P4401["cond"]
    unless_null $P4402, vivify_2142
    new $P4402, "Undef"
  vivify_2142:
    $P4403 = $P4402."ast"()
    $P4404 = $P4400."!make"($P4403)
    .return ($P4404)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>" :anon :subid("497_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4406
    .param pmc param_4407
.annotate 'line', 1604
    .lex "self", param_4406
    .lex "$/", param_4407
    find_lex $P4408, "$/"
    find_lex $P4409, "$/"
    unless_null $P4409, vivify_2143
    $P4409 = root_new ['parrot';'Hash']
  vivify_2143:
    set $P4410, $P4409["fatarrow"]
    unless_null $P4410, vivify_2144
    new $P4410, "Undef"
  vivify_2144:
    $P4411 = $P4410."ast"()
    $P4412 = $P4408."!make"($P4411)
    .return ($P4412)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>" :anon :subid("498_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4414
    .param pmc param_4415
.annotate 'line', 1605
    .lex "self", param_4414
    .lex "$/", param_4415
    find_lex $P4416, "$/"
    find_lex $P4417, "$/"
    unless_null $P4417, vivify_2145
    $P4417 = root_new ['parrot';'Hash']
  vivify_2145:
    set $P4418, $P4417["colonpair"]
    unless_null $P4418, vivify_2146
    new $P4418, "Undef"
  vivify_2146:
    $P4419 = $P4418."ast"()
    $P4420 = $P4416."!make"($P4419)
    .return ($P4420)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>" :anon :subid("499_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4422
    .param pmc param_4423
.annotate 'line', 1606
    .lex "self", param_4422
    .lex "$/", param_4423
    find_lex $P4424, "$/"
    find_lex $P4425, "$/"
    unless_null $P4425, vivify_2147
    $P4425 = root_new ['parrot';'Hash']
  vivify_2147:
    set $P4426, $P4425["variable"]
    unless_null $P4426, vivify_2148
    new $P4426, "Undef"
  vivify_2148:
    $P4427 = $P4426."ast"()
    $P4428 = $P4424."!make"($P4427)
    .return ($P4428)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>" :anon :subid("500_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4430
    .param pmc param_4431
.annotate 'line', 1607
    .lex "self", param_4430
    .lex "$/", param_4431
    find_lex $P4432, "$/"
    find_lex $P4433, "$/"
    unless_null $P4433, vivify_2149
    $P4433 = root_new ['parrot';'Hash']
  vivify_2149:
    set $P4434, $P4433["package_declarator"]
    unless_null $P4434, vivify_2150
    new $P4434, "Undef"
  vivify_2150:
    $P4435 = $P4434."ast"()
    $P4436 = $P4432."!make"($P4435)
    .return ($P4436)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>" :anon :subid("501_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4438
    .param pmc param_4439
.annotate 'line', 1608
    .lex "self", param_4438
    .lex "$/", param_4439
    find_lex $P4440, "$/"
    find_lex $P4441, "$/"
    unless_null $P4441, vivify_2151
    $P4441 = root_new ['parrot';'Hash']
  vivify_2151:
    set $P4442, $P4441["scope_declarator"]
    unless_null $P4442, vivify_2152
    new $P4442, "Undef"
  vivify_2152:
    $P4443 = $P4442."ast"()
    $P4444 = $P4440."!make"($P4443)
    .return ($P4444)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>" :anon :subid("502_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4446
    .param pmc param_4447
.annotate 'line', 1609
    .lex "self", param_4446
    .lex "$/", param_4447
    find_lex $P4448, "$/"
    find_lex $P4449, "$/"
    unless_null $P4449, vivify_2153
    $P4449 = root_new ['parrot';'Hash']
  vivify_2153:
    set $P4450, $P4449["routine_declarator"]
    unless_null $P4450, vivify_2154
    new $P4450, "Undef"
  vivify_2154:
    $P4451 = $P4450."ast"()
    $P4452 = $P4448."!make"($P4451)
    .return ($P4452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>" :anon :subid("503_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4454
    .param pmc param_4455
.annotate 'line', 1610
    .lex "self", param_4454
    .lex "$/", param_4455
    find_lex $P4456, "$/"
    find_lex $P4457, "$/"
    unless_null $P4457, vivify_2155
    $P4457 = root_new ['parrot';'Hash']
  vivify_2155:
    set $P4458, $P4457["regex_declarator"]
    unless_null $P4458, vivify_2156
    new $P4458, "Undef"
  vivify_2156:
    $P4459 = $P4458."ast"()
    $P4460 = $P4456."!make"($P4459)
    .return ($P4460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>" :anon :subid("504_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4462
    .param pmc param_4463
.annotate 'line', 1611
    .lex "self", param_4462
    .lex "$/", param_4463
    find_lex $P4464, "$/"
    find_lex $P4465, "$/"
    unless_null $P4465, vivify_2157
    $P4465 = root_new ['parrot';'Hash']
  vivify_2157:
    set $P4466, $P4465["statement_prefix"]
    unless_null $P4466, vivify_2158
    new $P4466, "Undef"
  vivify_2158:
    $P4467 = $P4466."ast"()
    $P4468 = $P4464."!make"($P4467)
    .return ($P4468)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>" :anon :subid("505_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4470
    .param pmc param_4471
.annotate 'line', 1612
    .lex "self", param_4470
    .lex "$/", param_4471
    find_lex $P4472, "$/"
    find_lex $P4473, "$/"
    unless_null $P4473, vivify_2159
    $P4473 = root_new ['parrot';'Hash']
  vivify_2159:
    set $P4474, $P4473["pblock"]
    unless_null $P4474, vivify_2160
    new $P4474, "Undef"
  vivify_2160:
    $P4475 = $P4474."ast"()
    $P4476 = $P4472."!make"($P4475)
    .return ($P4476)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow" :anon :subid("506_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4478
    .param pmc param_4479
.annotate 'line', 1614
    .lex "self", param_4478
    .lex "$/", param_4479
.annotate 'line', 1615
    new $P4480, "Undef"
    .lex "$past", $P4480
    find_lex $P4481, "$/"
    unless_null $P4481, vivify_2161
    $P4481 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P4482, $P4481["val"]
    unless_null $P4482, vivify_2162
    new $P4482, "Undef"
  vivify_2162:
    $P4483 = $P4482."ast"()
    store_lex "$past", $P4483
.annotate 'line', 1616
    find_lex $P4484, "$past"
    unless_null $P4484, vivify_2163
    new $P4484, "Undef"
  vivify_2163:
    find_lex $P4485, "$/"
    unless_null $P4485, vivify_2164
    $P4485 = root_new ['parrot';'Hash']
  vivify_2164:
    set $P4486, $P4485["key"]
    unless_null $P4486, vivify_2165
    new $P4486, "Undef"
  vivify_2165:
    $P4487 = $P4486."Str"()
    $P4484."named"($P4487)
.annotate 'line', 1617
    find_lex $P4488, "$/"
    find_lex $P4489, "$past"
    unless_null $P4489, vivify_2166
    new $P4489, "Undef"
  vivify_2166:
    $P4490 = $P4488."!make"($P4489)
.annotate 'line', 1614
    .return ($P4490)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair" :anon :subid("507_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4492
    .param pmc param_4493
.annotate 'line', 1620
    .lex "self", param_4492
    .lex "$/", param_4493
.annotate 'line', 1621
    new $P4494, "Undef"
    .lex "$past", $P4494
.annotate 'line', 1622
    find_lex $P4497, "$/"
    unless_null $P4497, vivify_2167
    $P4497 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P4498, $P4497["circumfix"]
    unless_null $P4498, vivify_2168
    new $P4498, "Undef"
  vivify_2168:
    if $P4498, if_4496
.annotate 'line', 1623
    get_hll_global $P4503, "GLOBAL"
    nqp_get_package_through_who $P4504, $P4503, "PAST"
    get_who $P4505, $P4504
    set $P4506, $P4505["Val"]
    find_lex $P4507, "$/"
    unless_null $P4507, vivify_2169
    $P4507 = root_new ['parrot';'Hash']
  vivify_2169:
    set $P4508, $P4507["not"]
    unless_null $P4508, vivify_2170
    new $P4508, "Undef"
  vivify_2170:
    isfalse $I4509, $P4508
    $P4510 = $P4506."new"($I4509 :named("value"))
    set $P4495, $P4510
.annotate 'line', 1622
    goto if_4496_end
  if_4496:
    find_lex $P4499, "$/"
    unless_null $P4499, vivify_2171
    $P4499 = root_new ['parrot';'Hash']
  vivify_2171:
    set $P4500, $P4499["circumfix"]
    unless_null $P4500, vivify_2172
    $P4500 = root_new ['parrot';'ResizablePMCArray']
  vivify_2172:
    set $P4501, $P4500[0]
    unless_null $P4501, vivify_2173
    new $P4501, "Undef"
  vivify_2173:
    $P4502 = $P4501."ast"()
    set $P4495, $P4502
  if_4496_end:
    store_lex "$past", $P4495
.annotate 'line', 1624
    find_lex $P4511, "$past"
    unless_null $P4511, vivify_2174
    new $P4511, "Undef"
  vivify_2174:
    find_lex $P4512, "$/"
    unless_null $P4512, vivify_2175
    $P4512 = root_new ['parrot';'Hash']
  vivify_2175:
    set $P4513, $P4512["identifier"]
    unless_null $P4513, vivify_2176
    new $P4513, "Undef"
  vivify_2176:
    set $S4514, $P4513
    $P4511."named"($S4514)
.annotate 'line', 1625
    find_lex $P4515, "$/"
    find_lex $P4516, "$past"
    unless_null $P4516, vivify_2177
    new $P4516, "Undef"
  vivify_2177:
    $P4517 = $P4515."!make"($P4516)
.annotate 'line', 1620
    .return ($P4517)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable" :anon :subid("508_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4519
    .param pmc param_4520
.annotate 'line', 1628
    .const 'Sub' $P4536 = "509_1306916577.75068" 
    capture_lex $P4536
    .lex "self", param_4519
    .lex "$/", param_4520
.annotate 'line', 1629
    new $P4521, "Undef"
    .lex "$past", $P4521
.annotate 'line', 1628
    find_lex $P4522, "$past"
    unless_null $P4522, vivify_2178
    new $P4522, "Undef"
  vivify_2178:
.annotate 'line', 1630
    find_lex $P4524, "$/"
    unless_null $P4524, vivify_2179
    $P4524 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P4525, $P4524["postcircumfix"]
    unless_null $P4525, vivify_2180
    new $P4525, "Undef"
  vivify_2180:
    if $P4525, if_4523
.annotate 'line', 1634
    .const 'Sub' $P4536 = "509_1306916577.75068" 
    capture_lex $P4536
    $P4536()
    goto if_4523_end
  if_4523:
.annotate 'line', 1631
    find_lex $P4526, "$/"
    unless_null $P4526, vivify_2237
    $P4526 = root_new ['parrot';'Hash']
  vivify_2237:
    set $P4527, $P4526["postcircumfix"]
    unless_null $P4527, vivify_2238
    new $P4527, "Undef"
  vivify_2238:
    $P4528 = $P4527."ast"()
    store_lex "$past", $P4528
.annotate 'line', 1632
    find_lex $P4529, "$past"
    unless_null $P4529, vivify_2239
    new $P4529, "Undef"
  vivify_2239:
    get_hll_global $P4530, "GLOBAL"
    nqp_get_package_through_who $P4531, $P4530, "PAST"
    get_who $P4532, $P4531
    set $P4533, $P4532["Var"]
    $P4534 = $P4533."new"("$/" :named("name"))
    $P4529."unshift"($P4534)
  if_4523_end:
.annotate 'line', 1693
    find_lex $P4718, "$/"
    find_lex $P4719, "$past"
    unless_null $P4719, vivify_2240
    new $P4719, "Undef"
  vivify_2240:
    $P4720 = $P4718."!make"($P4719)
.annotate 'line', 1628
    .return ($P4720)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4535"  :anon :subid("509_1306916577.75068") :outer("508_1306916577.75068")
.annotate 'line', 1634
    .const 'Sub' $P4612 = "511_1306916577.75068" 
    capture_lex $P4612
    .const 'Sub' $P4571 = "510_1306916577.75068" 
    capture_lex $P4571
.annotate 'line', 1635
    $P4537 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4537
    get_hll_global $P4538, "GLOBAL"
    nqp_get_package_through_who $P4539, $P4538, "NQP"
    get_who $P4540, $P4539
    set $P4541, $P4540["Compiler"]
    find_lex $P4542, "$/"
    unless_null $P4542, vivify_2181
    new $P4542, "Undef"
  vivify_2181:
    set $S4543, $P4542
    $P4544 = $P4541."parse_name"($S4543)
    store_lex "@name", $P4544
.annotate 'line', 1636
    find_lex $P4547, "@name"
    unless_null $P4547, vivify_2182
    $P4547 = root_new ['parrot';'ResizablePMCArray']
  vivify_2182:
    set $N4548, $P4547
    isgt $I4549, $N4548, 1.0
    if $I4549, if_4546
.annotate 'line', 1643
    find_lex $P4565, "$/"
    unless_null $P4565, vivify_2183
    $P4565 = root_new ['parrot';'Hash']
  vivify_2183:
    set $P4566, $P4565["twigil"]
    unless_null $P4566, vivify_2184
    $P4566 = root_new ['parrot';'ResizablePMCArray']
  vivify_2184:
    set $P4567, $P4566[0]
    unless_null $P4567, vivify_2185
    new $P4567, "Undef"
  vivify_2185:
    set $S4568, $P4567
    iseq $I4569, $S4568, "*"
    if $I4569, if_4564
.annotate 'line', 1654
    find_lex $P4606, "$/"
    unless_null $P4606, vivify_2186
    $P4606 = root_new ['parrot';'Hash']
  vivify_2186:
    set $P4607, $P4606["twigil"]
    unless_null $P4607, vivify_2187
    $P4607 = root_new ['parrot';'ResizablePMCArray']
  vivify_2187:
    set $P4608, $P4607[0]
    unless_null $P4608, vivify_2188
    new $P4608, "Undef"
  vivify_2188:
    set $S4609, $P4608
    iseq $I4610, $S4609, "!"
    if $I4610, if_4605
.annotate 'line', 1683
    find_lex $P4695, "@name"
    unless_null $P4695, vivify_2189
    $P4695 = root_new ['parrot';'ResizablePMCArray']
  vivify_2189:
    set $P4696, $P4695[0]
    unless_null $P4696, vivify_2190
    new $P4696, "Undef"
  vivify_2190:
    set $S4697, $P4696
    $P4698 = "is_package"($S4697)
    if $P4698, if_4694
.annotate 'line', 1688
    get_hll_global $P4707, "GLOBAL"
    nqp_get_package_through_who $P4708, $P4707, "PAST"
    get_who $P4709, $P4708
    set $P4710, $P4709["Var"]
.annotate 'line', 1689
    find_lex $P4711, "@name"
    unless_null $P4711, vivify_2191
    $P4711 = root_new ['parrot';'ResizablePMCArray']
  vivify_2191:
    $P4712 = $P4711."pop"()
    set $S4713, $P4712
    find_lex $P4714, "$/"
    unless_null $P4714, vivify_2192
    $P4714 = root_new ['parrot';'Hash']
  vivify_2192:
    set $P4715, $P4714["sigil"]
    unless_null $P4715, vivify_2193
    new $P4715, "Undef"
  vivify_2193:
    $P4716 = "vivitype"($P4715)
    $P4717 = $P4710."new"($S4713 :named("name"), $P4716 :named("viviself"))
.annotate 'line', 1688
    store_lex "$past", $P4717
.annotate 'line', 1687
    set $P4693, $P4717
.annotate 'line', 1683
    goto if_4694_end
  if_4694:
.annotate 'line', 1684
    find_lex $P4699, "@name"
    unless_null $P4699, vivify_2194
    $P4699 = root_new ['parrot';'ResizablePMCArray']
  vivify_2194:
    find_lex $P4700, "$/"
    unless_null $P4700, vivify_2195
    new $P4700, "Undef"
  vivify_2195:
    $P4701 = "lexical_package_lookup"($P4699, $P4700)
    store_lex "$past", $P4701
.annotate 'line', 1685
    find_lex $P4702, "$past"
    unless_null $P4702, vivify_2196
    new $P4702, "Undef"
  vivify_2196:
    find_lex $P4703, "$/"
    unless_null $P4703, vivify_2197
    $P4703 = root_new ['parrot';'Hash']
  vivify_2197:
    set $P4704, $P4703["sigil"]
    unless_null $P4704, vivify_2198
    new $P4704, "Undef"
  vivify_2198:
    $P4705 = "vivitype"($P4704)
    $P4706 = $P4702."viviself"($P4705)
.annotate 'line', 1683
    set $P4693, $P4706
  if_4694_end:
    set $P4604, $P4693
.annotate 'line', 1654
    goto if_4605_end
  if_4605:
    .const 'Sub' $P4612 = "511_1306916577.75068" 
    capture_lex $P4612
    $P4692 = $P4612()
    set $P4604, $P4692
  if_4605_end:
    set $P4563, $P4604
.annotate 'line', 1643
    goto if_4564_end
  if_4564:
    .const 'Sub' $P4571 = "510_1306916577.75068" 
    capture_lex $P4571
    $P4603 = $P4571()
    set $P4563, $P4603
  if_4564_end:
    set $P4545, $P4563
.annotate 'line', 1636
    goto if_4546_end
  if_4546:
.annotate 'line', 1637
    find_lex $P4551, "$/"
    unless_null $P4551, vivify_2229
    $P4551 = root_new ['parrot';'Hash']
  vivify_2229:
    set $P4552, $P4551["twigil"]
    unless_null $P4552, vivify_2230
    new $P4552, "Undef"
  vivify_2230:
    unless $P4552, if_4550_end
.annotate 'line', 1638
    find_lex $P4553, "$/"
    unless_null $P4553, vivify_2231
    new $P4553, "Undef"
  vivify_2231:
    $P4554 = $P4553."CURSOR"()
    $P4554."panic"("Twigil not allowed on multi-part name")
  if_4550_end:
.annotate 'line', 1640
    find_lex $P4555, "@name"
    unless_null $P4555, vivify_2232
    $P4555 = root_new ['parrot';'ResizablePMCArray']
  vivify_2232:
    find_lex $P4556, "$/"
    unless_null $P4556, vivify_2233
    new $P4556, "Undef"
  vivify_2233:
    $P4557 = "lexical_package_lookup"($P4555, $P4556)
    store_lex "$past", $P4557
.annotate 'line', 1641
    find_lex $P4558, "$past"
    unless_null $P4558, vivify_2234
    new $P4558, "Undef"
  vivify_2234:
    find_lex $P4559, "$/"
    unless_null $P4559, vivify_2235
    $P4559 = root_new ['parrot';'Hash']
  vivify_2235:
    set $P4560, $P4559["sigil"]
    unless_null $P4560, vivify_2236
    new $P4560, "Undef"
  vivify_2236:
    $P4561 = "vivitype"($P4560)
    $P4562 = $P4558."viviself"($P4561)
.annotate 'line', 1636
    set $P4545, $P4562
  if_4546_end:
.annotate 'line', 1634
    .return ($P4545)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4611"  :anon :subid("511_1306916577.75068") :outer("509_1306916577.75068")
.annotate 'line', 1654
    .const 'Sub' $P4643 = "512_1306916577.75068" 
    capture_lex $P4643
.annotate 'line', 1656
    new $P4613, "Undef"
    .lex "$name", $P4613
    find_lex $P4614, "@name"
    unless_null $P4614, vivify_2199
    $P4614 = root_new ['parrot';'ResizablePMCArray']
  vivify_2199:
    $P4615 = $P4614."pop"()
    set $S4616, $P4615
    new $P4617, 'String'
    set $P4617, $S4616
    store_lex "$name", $P4617
.annotate 'line', 1657
    get_hll_global $P4618, "GLOBAL"
    nqp_get_package_through_who $P4619, $P4618, "PAST"
    get_who $P4620, $P4619
    set $P4621, $P4620["Var"]
    find_lex $P4622, "$name"
    unless_null $P4622, vivify_2200
    new $P4622, "Undef"
  vivify_2200:
.annotate 'line', 1659
    find_lex $P4623, "$/"
    unless_null $P4623, vivify_2201
    $P4623 = root_new ['parrot';'Hash']
  vivify_2201:
    set $P4624, $P4623["sigil"]
    unless_null $P4624, vivify_2202
    new $P4624, "Undef"
  vivify_2202:
    $P4625 = "vivitype"($P4624)
.annotate 'line', 1660
    get_hll_global $P4626, "GLOBAL"
    nqp_get_package_through_who $P4627, $P4626, "PAST"
    get_who $P4628, $P4627
    set $P4629, $P4628["Var"]
    $P4630 = $P4629."new"("self" :named("name"))
.annotate 'line', 1661
    get_hll_global $P4631, "GLOBAL"
    nqp_get_package_through_who $P4632, $P4631, "PAST"
    get_who $P4633, $P4632
    set $P4634, $P4633["Var"]
    $P4635 = $P4634."new"("$?CLASS" :named("name"))
    $P4636 = $P4621."new"($P4630, $P4635, $P4622 :named("name"), "attribute_6model" :named("scope"), $P4625 :named("viviself"))
.annotate 'line', 1657
    store_lex "$past", $P4636
.annotate 'line', 1665
    find_dynamic_lex $P4641, "$*IN_DECL"
    unless_null $P4641, vivify_2203
    get_hll_global $P4639, "GLOBAL"
    get_who $P4640, $P4639
    set $P4641, $P4640["$IN_DECL"]
    unless_null $P4641, vivify_2204
    die "Contextual $*IN_DECL not found"
  vivify_2204:
  vivify_2203:
    unless $P4641, unless_4638
    set $P4637, $P4641
    goto unless_4638_end
  unless_4638:
    .const 'Sub' $P4643 = "512_1306916577.75068" 
    capture_lex $P4643
    $P4691 = $P4643()
    set $P4637, $P4691
  unless_4638_end:
.annotate 'line', 1654
    .return ($P4637)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4642"  :anon :subid("512_1306916577.75068") :outer("511_1306916577.75068")
.annotate 'line', 1665
    .const 'Sub' $P4658 = "513_1306916577.75068" 
    capture_lex $P4658
.annotate 'line', 1666
    new $P4644, "Undef"
    .lex "$attr", $P4644
.annotate 'line', 1665
    find_lex $P4645, "$attr"
    unless_null $P4645, vivify_2205
    new $P4645, "Undef"
  vivify_2205:
.annotate 'line', 1667
    find_dynamic_lex $P4649, "$*PACKAGE"
    unless_null $P4649, vivify_2206
    get_hll_global $P4647, "GLOBAL"
    get_who $P4648, $P4647
    set $P4649, $P4648["$PACKAGE"]
    unless_null $P4649, vivify_2207
    die "Contextual $*PACKAGE not found"
  vivify_2207:
  vivify_2206:
    get_how $P4650, $P4649
    find_dynamic_lex $P4653, "$*PACKAGE"
    unless_null $P4653, vivify_2208
    get_hll_global $P4651, "GLOBAL"
    get_who $P4652, $P4651
    set $P4653, $P4652["$PACKAGE"]
    unless_null $P4653, vivify_2209
    die "Contextual $*PACKAGE not found"
  vivify_2209:
  vivify_2208:
    $P4654 = $P4650."attributes"($P4653, 1 :named("local"))
    defined $I4655, $P4654
    unless $I4655, for_undef_2210
    iter $P4646, $P4654
    new $P4670, 'ExceptionHandler'
    set_label $P4670, loop4669_handler
    $P4670."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4670
  loop4669_test:
    unless $P4646, loop4669_done
    shift $P4656, $P4646
  loop4669_redo:
    .const 'Sub' $P4658 = "513_1306916577.75068" 
    capture_lex $P4658
    $P4658($P4656)
  loop4669_next:
    goto loop4669_test
  loop4669_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4671, exception, 'type'
    eq $P4671, .CONTROL_LOOP_NEXT, loop4669_next
    eq $P4671, .CONTROL_LOOP_REDO, loop4669_redo
  loop4669_done:
    pop_eh 
  for_undef_2210:
.annotate 'line', 1673
    find_lex $P4674, "$attr"
    unless_null $P4674, vivify_2214
    new $P4674, "Undef"
  vivify_2214:
    defined $I4675, $P4674
    if $I4675, if_4673
.annotate 'line', 1679
    find_lex $P4684, "$/"
    unless_null $P4684, vivify_2215
    new $P4684, "Undef"
  vivify_2215:
    $P4685 = $P4684."CURSOR"()
    new $P4686, 'String'
    set $P4686, "Attribute '"
    find_lex $P4687, "$name"
    unless_null $P4687, vivify_2216
    new $P4687, "Undef"
  vivify_2216:
    concat $P4688, $P4686, $P4687
    concat $P4689, $P4688, "' not declared"
    $P4690 = $P4685."panic"($P4689)
.annotate 'line', 1678
    set $P4672, $P4690
.annotate 'line', 1673
    goto if_4673_end
  if_4673:
.annotate 'line', 1674
    find_lex $P4678, "$attr"
    unless_null $P4678, vivify_2217
    new $P4678, "Undef"
  vivify_2217:
    can $I4679, $P4678, "type"
    if $I4679, if_4677
    new $P4676, 'Integer'
    set $P4676, $I4679
    goto if_4677_end
  if_4677:
.annotate 'line', 1675
    find_lex $P4680, "$past"
    unless_null $P4680, vivify_2218
    new $P4680, "Undef"
  vivify_2218:
    find_lex $P4681, "$attr"
    unless_null $P4681, vivify_2219
    new $P4681, "Undef"
  vivify_2219:
    $P4682 = $P4681."type"()
    $P4683 = $P4680."type"($P4682)
.annotate 'line', 1674
    set $P4676, $P4683
  if_4677_end:
.annotate 'line', 1673
    set $P4672, $P4676
  if_4673_end:
.annotate 'line', 1665
    .return ($P4672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4657"  :anon :subid("513_1306916577.75068") :outer("512_1306916577.75068")
    .param pmc param_4659
.annotate 'line', 1667
    .lex "$_", param_4659
.annotate 'line', 1668
    find_lex $P4662, "$_"
    unless_null $P4662, vivify_2211
    new $P4662, "Undef"
  vivify_2211:
    $S4663 = $P4662."name"()
    find_lex $P4664, "$name"
    unless_null $P4664, vivify_2212
    new $P4664, "Undef"
  vivify_2212:
    set $S4665, $P4664
    iseq $I4666, $S4663, $S4665
    if $I4666, if_4661
    new $P4660, 'Integer'
    set $P4660, $I4666
    goto if_4661_end
  if_4661:
.annotate 'line', 1669
    find_lex $P4667, "$_"
    unless_null $P4667, vivify_2213
    new $P4667, "Undef"
  vivify_2213:
    store_lex "$attr", $P4667
.annotate 'line', 1670
    set $I4668, .CONTROL_LOOP_LAST
    die 0, $I4668
  if_4661_end:
.annotate 'line', 1667
    .return ($P4660)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4570"  :anon :subid("510_1306916577.75068") :outer("509_1306916577.75068")
.annotate 'line', 1644
    new $P4572, "Undef"
    .lex "$global_fallback", $P4572
    find_lex $P4573, "$/"
    unless_null $P4573, vivify_2220
    $P4573 = root_new ['parrot';'Hash']
  vivify_2220:
    set $P4574, $P4573["sigil"]
    unless_null $P4574, vivify_2221
    new $P4574, "Undef"
  vivify_2221:
    set $S4575, $P4574
    new $P4576, 'String'
    set $P4576, $S4575
    find_lex $P4577, "$/"
    unless_null $P4577, vivify_2222
    $P4577 = root_new ['parrot';'Hash']
  vivify_2222:
    set $P4578, $P4577["desigilname"]
    unless_null $P4578, vivify_2223
    new $P4578, "Undef"
  vivify_2223:
    concat $P4579, $P4576, $P4578
    new $P4580, "ResizablePMCArray"
    push $P4580, "GLOBAL"
    push $P4580, $P4579
    find_lex $P4581, "$/"
    unless_null $P4581, vivify_2224
    new $P4581, "Undef"
  vivify_2224:
    $P4582 = "lexical_package_lookup"($P4580, $P4581)
    store_lex "$global_fallback", $P4582
.annotate 'line', 1645
    find_lex $P4583, "$global_fallback"
    unless_null $P4583, vivify_2225
    new $P4583, "Undef"
  vivify_2225:
    get_hll_global $P4584, "GLOBAL"
    nqp_get_package_through_who $P4585, $P4584, "PAST"
    get_who $P4586, $P4585
    set $P4587, $P4586["Op"]
.annotate 'line', 1646
    new $P4588, "String"
    assign $P4588, "Contextual "
    find_lex $P4589, "$/"
    unless_null $P4589, vivify_2226
    new $P4589, "Undef"
  vivify_2226:
    set $S4590, $P4589
    concat $P4591, $P4588, $S4590
    concat $P4592, $P4591, " not found"
    $P4593 = $P4587."new"($P4592, "die" :named("pirop"))
.annotate 'line', 1645
    $P4583."viviself"($P4593)
.annotate 'line', 1649
    get_hll_global $P4594, "GLOBAL"
    nqp_get_package_through_who $P4595, $P4594, "PAST"
    get_who $P4596, $P4595
    set $P4597, $P4596["Var"]
.annotate 'line', 1650
    find_lex $P4598, "@name"
    unless_null $P4598, vivify_2227
    $P4598 = root_new ['parrot';'ResizablePMCArray']
  vivify_2227:
    $P4599 = $P4598."pop"()
    set $S4600, $P4599
    find_lex $P4601, "$global_fallback"
    unless_null $P4601, vivify_2228
    new $P4601, "Undef"
  vivify_2228:
    $P4602 = $P4597."new"($S4600 :named("name"), "contextual" :named("scope"), $P4601 :named("viviself"))
.annotate 'line', 1649
    store_lex "$past", $P4602
.annotate 'line', 1643
    .return ($P4602)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>" :anon :subid("514_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4722
    .param pmc param_4723
.annotate 'line', 1696
    .lex "self", param_4722
    .lex "$/", param_4723
    find_lex $P4724, "$/"
    find_lex $P4725, "$/"
    unless_null $P4725, vivify_2241
    $P4725 = root_new ['parrot';'Hash']
  vivify_2241:
    set $P4726, $P4725["package_def"]
    unless_null $P4726, vivify_2242
    new $P4726, "Undef"
  vivify_2242:
    $P4727 = $P4726."ast"()
    $P4728 = $P4724."!make"($P4727)
    .return ($P4728)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>" :anon :subid("515_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4730
    .param pmc param_4731
.annotate 'line', 1697
    .lex "self", param_4730
    .lex "$/", param_4731
    find_lex $P4732, "$/"
    find_lex $P4733, "$/"
    unless_null $P4733, vivify_2243
    $P4733 = root_new ['parrot';'Hash']
  vivify_2243:
    set $P4734, $P4733["package_def"]
    unless_null $P4734, vivify_2244
    new $P4734, "Undef"
  vivify_2244:
    $P4735 = $P4734."ast"()
    $P4736 = $P4732."!make"($P4735)
    .return ($P4736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>" :anon :subid("516_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4738
    .param pmc param_4739
.annotate 'line', 1698
    .lex "self", param_4738
    .lex "$/", param_4739
    find_lex $P4740, "$/"
    find_lex $P4741, "$/"
    unless_null $P4741, vivify_2245
    $P4741 = root_new ['parrot';'Hash']
  vivify_2245:
    set $P4742, $P4741["package_def"]
    unless_null $P4742, vivify_2246
    new $P4742, "Undef"
  vivify_2246:
    $P4743 = $P4742."ast"()
    $P4744 = $P4740."!make"($P4743)
    .return ($P4744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>" :anon :subid("517_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4746
    .param pmc param_4747
.annotate 'line', 1699
    .lex "self", param_4746
    .lex "$/", param_4747
    find_lex $P4748, "$/"
    find_lex $P4749, "$/"
    unless_null $P4749, vivify_2247
    $P4749 = root_new ['parrot';'Hash']
  vivify_2247:
    set $P4750, $P4749["package_def"]
    unless_null $P4750, vivify_2248
    new $P4750, "Undef"
  vivify_2248:
    $P4751 = $P4750."ast"()
    $P4752 = $P4748."!make"($P4751)
    .return ($P4752)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>" :anon :subid("518_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4754
    .param pmc param_4755
.annotate 'line', 1700
    .lex "self", param_4754
    .lex "$/", param_4755
    find_lex $P4756, "$/"
    find_lex $P4757, "$/"
    unless_null $P4757, vivify_2249
    $P4757 = root_new ['parrot';'Hash']
  vivify_2249:
    set $P4758, $P4757["package_def"]
    unless_null $P4758, vivify_2250
    new $P4758, "Undef"
  vivify_2250:
    $P4759 = $P4758."ast"()
    $P4760 = $P4756."!make"($P4759)
    .return ($P4760)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>" :anon :subid("519_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4762
    .param pmc param_4763
.annotate 'line', 1701
    .lex "self", param_4762
    .lex "$/", param_4763
    find_lex $P4764, "$/"
    find_lex $P4765, "$/"
    unless_null $P4765, vivify_2251
    $P4765 = root_new ['parrot';'Hash']
  vivify_2251:
    set $P4766, $P4765["package_def"]
    unless_null $P4766, vivify_2252
    new $P4766, "Undef"
  vivify_2252:
    $P4767 = $P4766."ast"()
    $P4768 = $P4764."!make"($P4767)
    .return ($P4768)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<stub>" :anon :subid("520_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4770
    .param pmc param_4771
.annotate 'line', 1703
    .lex "self", param_4770
    .lex "$/", param_4771
.annotate 'line', 1706
    new $P4772, "Undef"
    .lex "$HOW", $P4772
.annotate 'line', 1707
    new $P4773, "Undef"
    .lex "$PACKAGE", $P4773
.annotate 'line', 1706
    find_lex $P4774, "$/"
    unless_null $P4774, vivify_2253
    $P4774 = root_new ['parrot';'Hash']
  vivify_2253:
    set $P4775, $P4774["metaclass"]
    unless_null $P4775, vivify_2254
    $P4775 = root_new ['parrot';'Hash']
  vivify_2254:
    set $P4776, $P4775["identifier"]
    unless_null $P4776, vivify_2255
    new $P4776, "Undef"
  vivify_2255:
    find_lex $P4777, "$/"
    unless_null $P4777, vivify_2256
    new $P4777, "Undef"
  vivify_2256:
    $P4778 = "find_sym"($P4776, $P4777)
    store_lex "$HOW", $P4778
.annotate 'line', 1707
    find_dynamic_lex $P4781, "$*SC"
    unless_null $P4781, vivify_2257
    get_hll_global $P4779, "GLOBAL"
    get_who $P4780, $P4779
    set $P4781, $P4780["$SC"]
    unless_null $P4781, vivify_2258
    die "Contextual $*SC not found"
  vivify_2258:
  vivify_2257:
    find_lex $P4782, "$HOW"
    unless_null $P4782, vivify_2259
    new $P4782, "Undef"
  vivify_2259:
    find_lex $P4783, "$/"
    unless_null $P4783, vivify_2260
    $P4783 = root_new ['parrot';'Hash']
  vivify_2260:
    set $P4784, $P4783["name"]
    unless_null $P4784, vivify_2261
    new $P4784, "Undef"
  vivify_2261:
    set $S4785, $P4784
    $P4786 = $P4781."pkg_create_mo"($P4782, $S4785 :named("name"))
    store_lex "$PACKAGE", $P4786
.annotate 'line', 1710
    find_dynamic_lex $P4792, "$*SCOPE"
    unless_null $P4792, vivify_2262
    get_hll_global $P4790, "GLOBAL"
    get_who $P4791, $P4790
    set $P4792, $P4791["$SCOPE"]
    unless_null $P4792, vivify_2263
    die "Contextual $*SCOPE not found"
  vivify_2263:
  vivify_2262:
    set $S4793, $P4792
    iseq $I4794, $S4793, "our"
    unless $I4794, unless_4789
    new $P4788, 'Integer'
    set $P4788, $I4794
    goto unless_4789_end
  unless_4789:
    find_dynamic_lex $P4797, "$*SCOPE"
    unless_null $P4797, vivify_2264
    get_hll_global $P4795, "GLOBAL"
    get_who $P4796, $P4795
    set $P4797, $P4796["$SCOPE"]
    unless_null $P4797, vivify_2265
    die "Contextual $*SCOPE not found"
  vivify_2265:
  vivify_2264:
    set $S4798, $P4797
    iseq $I4799, $S4798, ""
    new $P4788, 'Integer'
    set $P4788, $I4799
  unless_4789_end:
    if $P4788, if_4787
.annotate 'line', 1716
    find_dynamic_lex $P4831, "$*SCOPE"
    unless_null $P4831, vivify_2266
    get_hll_global $P4829, "GLOBAL"
    get_who $P4830, $P4829
    set $P4831, $P4830["$SCOPE"]
    unless_null $P4831, vivify_2267
    die "Contextual $*SCOPE not found"
  vivify_2267:
  vivify_2266:
    set $S4832, $P4831
    iseq $I4833, $S4832, "my"
    if $I4833, if_4828
.annotate 'line', 1723
    find_lex $P4855, "$/"
    unless_null $P4855, vivify_2268
    new $P4855, "Undef"
  vivify_2268:
    $P4856 = $P4855."CURSOR"()
    find_dynamic_lex $P4859, "$*SCOPE"
    unless_null $P4859, vivify_2269
    get_hll_global $P4857, "GLOBAL"
    get_who $P4858, $P4857
    set $P4859, $P4858["$SCOPE"]
    unless_null $P4859, vivify_2270
    die "Contextual $*SCOPE not found"
  vivify_2270:
  vivify_2269:
    concat $P4860, $P4859, " scoped packages are not supported"
    $P4856."panic"($P4860)
.annotate 'line', 1722
    goto if_4828_end
  if_4828:
.annotate 'line', 1717
    find_lex $P4835, "$/"
    unless_null $P4835, vivify_2271
    $P4835 = root_new ['parrot';'Hash']
  vivify_2271:
    set $P4836, $P4835["name"]
    unless_null $P4836, vivify_2272
    $P4836 = root_new ['parrot';'Hash']
  vivify_2272:
    set $P4837, $P4836["identifier"]
    unless_null $P4837, vivify_2273
    new $P4837, "Undef"
  vivify_2273:
    set $N4838, $P4837
    isne $I4839, $N4838, 1.0
    unless $I4839, if_4834_end
.annotate 'line', 1718
    find_lex $P4840, "$/"
    unless_null $P4840, vivify_2274
    $P4840 = root_new ['parrot';'Hash']
  vivify_2274:
    set $P4841, $P4840["name"]
    unless_null $P4841, vivify_2275
    new $P4841, "Undef"
  vivify_2275:
    $P4842 = $P4841."CURSOR"()
    $P4842."panic"("A my scoped package cannot have a multi-part name yet")
  if_4834_end:
.annotate 'line', 1720
    find_dynamic_lex $P4845, "$*SC"
    unless_null $P4845, vivify_2276
    get_hll_global $P4843, "GLOBAL"
    get_who $P4844, $P4843
    set $P4845, $P4844["$SC"]
    unless_null $P4845, vivify_2277
    die "Contextual $*SC not found"
  vivify_2277:
  vivify_2276:
    find_lex $P4846, "$?PACKAGE"
    get_who $P4847, $P4846
    set $P4848, $P4847["@BLOCK"]
    unless_null $P4848, vivify_2278
    $P4848 = root_new ['parrot';'ResizablePMCArray']
  vivify_2278:
    set $P4849, $P4848[0]
    unless_null $P4849, vivify_2279
    new $P4849, "Undef"
  vivify_2279:
    find_lex $P4850, "$/"
    unless_null $P4850, vivify_2280
    $P4850 = root_new ['parrot';'Hash']
  vivify_2280:
    set $P4851, $P4850["name"]
    unless_null $P4851, vivify_2281
    $P4851 = root_new ['parrot';'Hash']
  vivify_2281:
    set $P4852, $P4851["identifier"]
    unless_null $P4852, vivify_2282
    $P4852 = root_new ['parrot';'ResizablePMCArray']
  vivify_2282:
    set $P4853, $P4852[0]
    unless_null $P4853, vivify_2283
    new $P4853, "Undef"
  vivify_2283:
    find_lex $P4854, "$PACKAGE"
    unless_null $P4854, vivify_2284
    new $P4854, "Undef"
  vivify_2284:
    $P4845."install_lexical_symbol"($P4849, $P4853, $P4854)
  if_4828_end:
.annotate 'line', 1716
    goto if_4787_end
  if_4787:
.annotate 'line', 1711
    find_dynamic_lex $P4802, "$*SC"
    unless_null $P4802, vivify_2285
    get_hll_global $P4800, "GLOBAL"
    get_who $P4801, $P4800
    set $P4802, $P4801["$SC"]
    unless_null $P4802, vivify_2286
    die "Contextual $*SC not found"
  vivify_2286:
  vivify_2285:
    find_dynamic_lex $P4805, "$*OUTERPACKAGE"
    unless_null $P4805, vivify_2287
    get_hll_global $P4803, "GLOBAL"
    get_who $P4804, $P4803
    set $P4805, $P4804["$OUTERPACKAGE"]
    unless_null $P4805, vivify_2288
    die "Contextual $*OUTERPACKAGE not found"
  vivify_2288:
  vivify_2287:
    find_lex $P4806, "$/"
    unless_null $P4806, vivify_2289
    $P4806 = root_new ['parrot';'Hash']
  vivify_2289:
    set $P4807, $P4806["name"]
    unless_null $P4807, vivify_2290
    $P4807 = root_new ['parrot';'Hash']
  vivify_2290:
    set $P4808, $P4807["identifier"]
    unless_null $P4808, vivify_2291
    new $P4808, "Undef"
  vivify_2291:
    find_lex $P4809, "$PACKAGE"
    unless_null $P4809, vivify_2292
    new $P4809, "Undef"
  vivify_2292:
    $P4802."install_package_symbol"($P4805, $P4808, $P4809)
.annotate 'line', 1712
    find_lex $P4811, "$/"
    unless_null $P4811, vivify_2293
    $P4811 = root_new ['parrot';'Hash']
  vivify_2293:
    set $P4812, $P4811["name"]
    unless_null $P4812, vivify_2294
    $P4812 = root_new ['parrot';'Hash']
  vivify_2294:
    set $P4813, $P4812["identifier"]
    unless_null $P4813, vivify_2295
    new $P4813, "Undef"
  vivify_2295:
    set $N4814, $P4813
    iseq $I4815, $N4814, 1.0
    unless $I4815, if_4810_end
.annotate 'line', 1713
    find_dynamic_lex $P4818, "$*SC"
    unless_null $P4818, vivify_2296
    get_hll_global $P4816, "GLOBAL"
    get_who $P4817, $P4816
    set $P4818, $P4817["$SC"]
    unless_null $P4818, vivify_2297
    die "Contextual $*SC not found"
  vivify_2297:
  vivify_2296:
    find_lex $P4819, "$?PACKAGE"
    get_who $P4820, $P4819
    set $P4821, $P4820["@BLOCK"]
    unless_null $P4821, vivify_2298
    $P4821 = root_new ['parrot';'ResizablePMCArray']
  vivify_2298:
    set $P4822, $P4821[0]
    unless_null $P4822, vivify_2299
    new $P4822, "Undef"
  vivify_2299:
    find_lex $P4823, "$/"
    unless_null $P4823, vivify_2300
    $P4823 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P4824, $P4823["name"]
    unless_null $P4824, vivify_2301
    $P4824 = root_new ['parrot';'Hash']
  vivify_2301:
    set $P4825, $P4824["identifier"]
    unless_null $P4825, vivify_2302
    $P4825 = root_new ['parrot';'ResizablePMCArray']
  vivify_2302:
    set $P4826, $P4825[0]
    unless_null $P4826, vivify_2303
    new $P4826, "Undef"
  vivify_2303:
    find_lex $P4827, "$PACKAGE"
    unless_null $P4827, vivify_2304
    new $P4827, "Undef"
  vivify_2304:
    $P4818."install_lexical_symbol"($P4822, $P4826, $P4827)
  if_4810_end:
  if_4787_end:
.annotate 'line', 1726
    find_lex $P4861, "$/"
    get_hll_global $P4862, "GLOBAL"
    nqp_get_package_through_who $P4863, $P4862, "PAST"
    get_who $P4864, $P4863
    set $P4865, $P4864["Stmts"]
    $P4866 = $P4865."new"()
    $P4867 = $P4861."!make"($P4866)
.annotate 'line', 1703
    .return ($P4867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def" :anon :subid("521_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_4869
    .param pmc param_4870
.annotate 'line', 1729
    .const 'Sub' $P5050 = "525_1306916577.75068" 
    capture_lex $P5050
    .const 'Sub' $P5020 = "524_1306916577.75068" 
    capture_lex $P5020
    .const 'Sub' $P4973 = "522_1306916577.75068" 
    capture_lex $P4973
    .lex "self", param_4869
    .lex "$/", param_4870
.annotate 'line', 1731
    $P4871 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4871
.annotate 'line', 1732
    new $P4872, "Undef"
    .lex "$name", $P4872
.annotate 'line', 1733
    new $P4873, "Undef"
    .lex "$how", $P4873
.annotate 'line', 1736
    new $P4874, "Undef"
    .lex "$past", $P4874
.annotate 'line', 1731
    find_lex $P4875, "$/"
    unless_null $P4875, vivify_2305
    $P4875 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P4876, $P4875["name"]
    unless_null $P4876, vivify_2306
    $P4876 = root_new ['parrot';'Hash']
  vivify_2306:
    set $P4877, $P4876["identifier"]
    unless_null $P4877, vivify_2307
    new $P4877, "Undef"
  vivify_2307:
    clone $P4878, $P4877
    store_lex "@ns", $P4878
.annotate 'line', 1732
    find_lex $P4879, "@ns"
    unless_null $P4879, vivify_2308
    $P4879 = root_new ['parrot';'ResizablePMCArray']
  vivify_2308:
    $P4880 = $P4879."pop"()
    set $S4881, $P4880
    new $P4882, 'String'
    set $P4882, $S4881
    store_lex "$name", $P4882
.annotate 'line', 1733
    find_dynamic_lex $P4885, "$*PKGDECL"
    unless_null $P4885, vivify_2309
    get_hll_global $P4883, "GLOBAL"
    get_who $P4884, $P4883
    set $P4885, $P4884["$PKGDECL"]
    unless_null $P4885, vivify_2310
    die "Contextual $*PKGDECL not found"
  vivify_2310:
  vivify_2309:
    find_dynamic_lex $P4888, "%*HOW"
    unless_null $P4888, vivify_2311
    get_hll_global $P4886, "GLOBAL"
    get_who $P4887, $P4886
    set $P4888, $P4887["%HOW"]
    unless_null $P4888, vivify_2312
    die "Contextual %*HOW not found"
  vivify_2312:
  vivify_2311:
    set $P4889, $P4888[$P4885]
    unless_null $P4889, vivify_2313
    new $P4889, "Undef"
  vivify_2313:
    store_lex "$how", $P4889
.annotate 'line', 1736
    find_lex $P4892, "$/"
    unless_null $P4892, vivify_2314
    $P4892 = root_new ['parrot';'Hash']
  vivify_2314:
    set $P4893, $P4892["block"]
    unless_null $P4893, vivify_2315
    new $P4893, "Undef"
  vivify_2315:
    if $P4893, if_4891
    find_lex $P4897, "$/"
    unless_null $P4897, vivify_2316
    $P4897 = root_new ['parrot';'Hash']
  vivify_2316:
    set $P4898, $P4897["comp_unit"]
    unless_null $P4898, vivify_2317
    new $P4898, "Undef"
  vivify_2317:
    $P4899 = $P4898."ast"()
    set $P4890, $P4899
    goto if_4891_end
  if_4891:
    find_lex $P4894, "$/"
    unless_null $P4894, vivify_2318
    $P4894 = root_new ['parrot';'Hash']
  vivify_2318:
    set $P4895, $P4894["block"]
    unless_null $P4895, vivify_2319
    new $P4895, "Undef"
  vivify_2319:
    $P4896 = $P4895."ast"()
    set $P4890, $P4896
  if_4891_end:
    store_lex "$past", $P4890
.annotate 'line', 1737
    find_dynamic_lex $P4905, "$*SCOPE"
    unless_null $P4905, vivify_2320
    get_hll_global $P4903, "GLOBAL"
    get_who $P4904, $P4903
    set $P4905, $P4904["$SCOPE"]
    unless_null $P4905, vivify_2321
    die "Contextual $*SCOPE not found"
  vivify_2321:
  vivify_2320:
    set $S4906, $P4905
    iseq $I4907, $S4906, "our"
    unless $I4907, unless_4902
    new $P4901, 'Integer'
    set $P4901, $I4907
    goto unless_4902_end
  unless_4902:
    find_dynamic_lex $P4910, "$*SCOPE"
    unless_null $P4910, vivify_2322
    get_hll_global $P4908, "GLOBAL"
    get_who $P4909, $P4908
    set $P4910, $P4909["$SCOPE"]
    unless_null $P4910, vivify_2323
    die "Contextual $*SCOPE not found"
  vivify_2323:
  vivify_2322:
    set $S4911, $P4910
    iseq $I4912, $S4911, ""
    new $P4901, 'Integer'
    set $P4901, $I4912
  unless_4902_end:
    unless $P4901, if_4900_end
.annotate 'line', 1738
    find_lex $P4913, "$past"
    unless_null $P4913, vivify_2324
    new $P4913, "Undef"
  vivify_2324:
    find_lex $P4914, "$/"
    unless_null $P4914, vivify_2325
    $P4914 = root_new ['parrot';'Hash']
  vivify_2325:
    set $P4915, $P4914["name"]
    unless_null $P4915, vivify_2326
    $P4915 = root_new ['parrot';'Hash']
  vivify_2326:
    set $P4916, $P4915["identifier"]
    unless_null $P4916, vivify_2327
    new $P4916, "Undef"
  vivify_2327:
    $P4913."namespace"($P4916)
  if_4900_end:
.annotate 'line', 1745
    find_lex $P4920, "$how"
    unless_null $P4920, vivify_2328
    new $P4920, "Undef"
  vivify_2328:
    can $I4921, $P4920, "parametric"
    if $I4921, if_4919
    new $P4918, 'Integer'
    set $P4918, $I4921
    goto if_4919_end
  if_4919:
    find_lex $P4922, "$how"
    unless_null $P4922, vivify_2329
    new $P4922, "Undef"
  vivify_2329:
    find_lex $P4923, "$how"
    unless_null $P4923, vivify_2330
    new $P4923, "Undef"
  vivify_2330:
    $P4924 = $P4922."parametric"($P4923)
    set $P4918, $P4924
  if_4919_end:
    if $P4918, if_4917
.annotate 'line', 1754
    find_lex $P4954, "$past"
    unless_null $P4954, vivify_2331
    new $P4954, "Undef"
  vivify_2331:
    $P4954."blocktype"("immediate")
.annotate 'line', 1755
    find_dynamic_lex $P4957, "$*SC"
    unless_null $P4957, vivify_2332
    get_hll_global $P4955, "GLOBAL"
    get_who $P4956, $P4955
    set $P4957, $P4956["$SC"]
    unless_null $P4957, vivify_2333
    die "Contextual $*SC not found"
  vivify_2333:
  vivify_2332:
    find_lex $P4958, "$past"
    unless_null $P4958, vivify_2334
    new $P4958, "Undef"
  vivify_2334:
    find_dynamic_lex $P4961, "$*PACKAGE"
    unless_null $P4961, vivify_2335
    get_hll_global $P4959, "GLOBAL"
    get_who $P4960, $P4959
    set $P4961, $P4960["$PACKAGE"]
    unless_null $P4961, vivify_2336
    die "Contextual $*PACKAGE not found"
  vivify_2336:
  vivify_2335:
    $P4957."install_lexical_symbol"($P4958, "$?PACKAGE", $P4961)
.annotate 'line', 1756
    find_dynamic_lex $P4964, "$*SC"
    unless_null $P4964, vivify_2337
    get_hll_global $P4962, "GLOBAL"
    get_who $P4963, $P4962
    set $P4964, $P4963["$SC"]
    unless_null $P4964, vivify_2338
    die "Contextual $*SC not found"
  vivify_2338:
  vivify_2337:
    find_lex $P4965, "$past"
    unless_null $P4965, vivify_2339
    new $P4965, "Undef"
  vivify_2339:
    find_dynamic_lex $P4968, "$*PACKAGE"
    unless_null $P4968, vivify_2340
    get_hll_global $P4966, "GLOBAL"
    get_who $P4967, $P4966
    set $P4968, $P4967["$PACKAGE"]
    unless_null $P4968, vivify_2341
    die "Contextual $*PACKAGE not found"
  vivify_2341:
  vivify_2340:
    $P4964."install_lexical_symbol"($P4965, "$?CLASS", $P4968)
.annotate 'line', 1753
    goto if_4917_end
  if_4917:
.annotate 'line', 1746
    find_lex $P4925, "$past"
    unless_null $P4925, vivify_2342
    new $P4925, "Undef"
  vivify_2342:
    $P4925."blocktype"("declaration")
.annotate 'line', 1747
    find_lex $P4926, "$past"
    unless_null $P4926, vivify_2343
    new $P4926, "Undef"
  vivify_2343:
    get_hll_global $P4927, "GLOBAL"
    nqp_get_package_through_who $P4928, $P4927, "PAST"
    get_who $P4929, $P4928
    set $P4930, $P4929["Var"]
    $P4931 = $P4930."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4926."unshift"($P4931)
.annotate 'line', 1748
    find_lex $P4932, "$past"
    unless_null $P4932, vivify_2344
    new $P4932, "Undef"
  vivify_2344:
    $P4932."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1749
    find_dynamic_lex $P4935, "$*SC"
    unless_null $P4935, vivify_2345
    get_hll_global $P4933, "GLOBAL"
    get_who $P4934, $P4933
    set $P4935, $P4934["$SC"]
    unless_null $P4935, vivify_2346
    die "Contextual $*SC not found"
  vivify_2346:
  vivify_2345:
    find_dynamic_lex $P4938, "$*PACKAGE"
    unless_null $P4938, vivify_2347
    get_hll_global $P4936, "GLOBAL"
    get_who $P4937, $P4936
    set $P4938, $P4937["$PACKAGE"]
    unless_null $P4938, vivify_2348
    die "Contextual $*PACKAGE not found"
  vivify_2348:
  vivify_2347:
    find_lex $P4939, "$past"
    unless_null $P4939, vivify_2349
    new $P4939, "Undef"
  vivify_2349:
    $P4935."pkg_set_body_block"($P4938, $P4939)
.annotate 'line', 1750
    find_dynamic_lex $P4942, "$*SC"
    unless_null $P4942, vivify_2350
    get_hll_global $P4940, "GLOBAL"
    get_who $P4941, $P4940
    set $P4942, $P4941["$SC"]
    unless_null $P4942, vivify_2351
    die "Contextual $*SC not found"
  vivify_2351:
  vivify_2350:
    find_lex $P4943, "$past"
    unless_null $P4943, vivify_2352
    new $P4943, "Undef"
  vivify_2352:
    find_dynamic_lex $P4946, "$*PACKAGE"
    unless_null $P4946, vivify_2353
    get_hll_global $P4944, "GLOBAL"
    get_who $P4945, $P4944
    set $P4946, $P4945["$PACKAGE"]
    unless_null $P4946, vivify_2354
    die "Contextual $*PACKAGE not found"
  vivify_2354:
  vivify_2353:
    $P4942."install_lexical_symbol"($P4943, "$?PACKAGE", $P4946)
.annotate 'line', 1751
    find_dynamic_lex $P4949, "$*SC"
    unless_null $P4949, vivify_2355
    get_hll_global $P4947, "GLOBAL"
    get_who $P4948, $P4947
    set $P4949, $P4948["$SC"]
    unless_null $P4949, vivify_2356
    die "Contextual $*SC not found"
  vivify_2356:
  vivify_2355:
    find_lex $P4950, "$past"
    unless_null $P4950, vivify_2357
    new $P4950, "Undef"
  vivify_2357:
    find_dynamic_lex $P4953, "$*PACKAGE"
    unless_null $P4953, vivify_2358
    get_hll_global $P4951, "GLOBAL"
    get_who $P4952, $P4951
    set $P4953, $P4952["$PACKAGE"]
    unless_null $P4953, vivify_2359
    die "Contextual $*PACKAGE not found"
  vivify_2359:
  vivify_2358:
    $P4949."install_lexical_symbol"($P4950, "$?ROLE", $P4953)
  if_4917_end:
.annotate 'line', 1760
    find_lex $P4970, "$/"
    unless_null $P4970, vivify_2360
    $P4970 = root_new ['parrot';'Hash']
  vivify_2360:
    set $P4971, $P4970["parent"]
    unless_null $P4971, vivify_2361
    new $P4971, "Undef"
  vivify_2361:
    if $P4971, if_4969
.annotate 'line', 1774
    find_lex $P5017, "$how"
    unless_null $P5017, vivify_2362
    new $P5017, "Undef"
  vivify_2362:
    can $I5018, $P5017, "set_default_parent"
    unless $I5018, if_5016_end
    .const 'Sub' $P5020 = "524_1306916577.75068" 
    capture_lex $P5020
    $P5020()
  if_5016_end:
    goto if_4969_end
  if_4969:
.annotate 'line', 1760
    .const 'Sub' $P4973 = "522_1306916577.75068" 
    capture_lex $P4973
    $P4973()
  if_4969_end:
.annotate 'line', 1781
    find_lex $P5042, "$/"
    unless_null $P5042, vivify_2388
    $P5042 = root_new ['parrot';'Hash']
  vivify_2388:
    set $P5043, $P5042["role"]
    unless_null $P5043, vivify_2389
    new $P5043, "Undef"
  vivify_2389:
    unless $P5043, if_5041_end
.annotate 'line', 1782
    find_lex $P5045, "$/"
    unless_null $P5045, vivify_2390
    $P5045 = root_new ['parrot';'Hash']
  vivify_2390:
    set $P5046, $P5045["role"]
    unless_null $P5046, vivify_2391
    new $P5046, "Undef"
  vivify_2391:
    defined $I5047, $P5046
    unless $I5047, for_undef_2392
    iter $P5044, $P5046
    new $P5091, 'ExceptionHandler'
    set_label $P5091, loop5090_handler
    $P5091."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5091
  loop5090_test:
    unless $P5044, loop5090_done
    shift $P5048, $P5044
  loop5090_redo:
    .const 'Sub' $P5050 = "525_1306916577.75068" 
    capture_lex $P5050
    $P5050($P5048)
  loop5090_next:
    goto loop5090_test
  loop5090_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5092, exception, 'type'
    eq $P5092, .CONTROL_LOOP_NEXT, loop5090_next
    eq $P5092, .CONTROL_LOOP_REDO, loop5090_redo
  loop5090_done:
    pop_eh 
  for_undef_2392:
  if_5041_end:
.annotate 'line', 1799
    find_dynamic_lex $P5095, "$*SC"
    unless_null $P5095, vivify_2406
    get_hll_global $P5093, "GLOBAL"
    get_who $P5094, $P5093
    set $P5095, $P5094["$SC"]
    unless_null $P5095, vivify_2407
    die "Contextual $*SC not found"
  vivify_2407:
  vivify_2406:
    find_dynamic_lex $P5098, "$*PACKAGE"
    unless_null $P5098, vivify_2408
    get_hll_global $P5096, "GLOBAL"
    get_who $P5097, $P5096
    set $P5098, $P5097["$PACKAGE"]
    unless_null $P5098, vivify_2409
    die "Contextual $*PACKAGE not found"
  vivify_2409:
  vivify_2408:
    $P5095."pkg_compose"($P5098)
.annotate 'line', 1801
    find_lex $P5099, "$/"
    find_lex $P5100, "$past"
    unless_null $P5100, vivify_2410
    new $P5100, "Undef"
  vivify_2410:
    $P5101 = $P5099."!make"($P5100)
.annotate 'line', 1729
    .return ($P5101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5019"  :anon :subid("524_1306916577.75068") :outer("521_1306916577.75068")
.annotate 'line', 1775
    new $P5021, "Undef"
    .lex "$default", $P5021
    find_dynamic_lex $P5026, "$*PKGDECL"
    unless_null $P5026, vivify_2363
    get_hll_global $P5024, "GLOBAL"
    get_who $P5025, $P5024
    set $P5026, $P5025["$PKGDECL"]
    unless_null $P5026, vivify_2364
    die "Contextual $*PKGDECL not found"
  vivify_2364:
  vivify_2363:
    set $S5027, $P5026
    iseq $I5028, $S5027, "grammar"
    if $I5028, if_5023
    new $P5030, "ResizablePMCArray"
    push $P5030, "NQPMu"
    set $P5022, $P5030
    goto if_5023_end
  if_5023:
    new $P5029, "ResizablePMCArray"
    push $P5029, "Regex"
    push $P5029, "Cursor"
    set $P5022, $P5029
  if_5023_end:
    store_lex "$default", $P5022
.annotate 'line', 1776
    find_dynamic_lex $P5033, "$*SC"
    unless_null $P5033, vivify_2365
    get_hll_global $P5031, "GLOBAL"
    get_who $P5032, $P5031
    set $P5033, $P5032["$SC"]
    unless_null $P5033, vivify_2366
    die "Contextual $*SC not found"
  vivify_2366:
  vivify_2365:
    find_dynamic_lex $P5036, "$*PACKAGE"
    unless_null $P5036, vivify_2367
    get_hll_global $P5034, "GLOBAL"
    get_who $P5035, $P5034
    set $P5036, $P5035["$PACKAGE"]
    unless_null $P5036, vivify_2368
    die "Contextual $*PACKAGE not found"
  vivify_2368:
  vivify_2367:
.annotate 'line', 1777
    find_lex $P5037, "$default"
    unless_null $P5037, vivify_2369
    new $P5037, "Undef"
  vivify_2369:
    find_lex $P5038, "$/"
    unless_null $P5038, vivify_2370
    new $P5038, "Undef"
  vivify_2370:
    $P5039 = "find_sym"($P5037, $P5038)
    $P5040 = $P5033."pkg_add_parent_or_role"($P5036, "set_default_parent", $P5039)
.annotate 'line', 1774
    .return ($P5040)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4972"  :anon :subid("522_1306916577.75068") :outer("521_1306916577.75068")
.annotate 'line', 1760
    .const 'Sub' $P4979 = "523_1306916577.75068" 
    capture_lex $P4979
.annotate 'line', 1761
    new $P4974, "Undef"
    .lex "$parent", $P4974
.annotate 'line', 1762
    new $P4975, "Undef"
    .lex "$parent_found", $P4975
.annotate 'line', 1760
    find_lex $P4976, "$parent"
    unless_null $P4976, vivify_2371
    new $P4976, "Undef"
  vivify_2371:
    find_lex $P4977, "$parent_found"
    unless_null $P4977, vivify_2372
    new $P4977, "Undef"
  vivify_2372:
.annotate 'line', 1763
    .const 'Sub' $P4979 = "523_1306916577.75068" 
    capture_lex $P4979
    $P4979()
.annotate 'line', 1767
    find_lex $P4997, "$parent_found"
    unless_null $P4997, vivify_2378
    new $P4997, "Undef"
  vivify_2378:
    if $P4997, if_4996
.annotate 'line', 1771
    find_lex $P5006, "$/"
    unless_null $P5006, vivify_2379
    new $P5006, "Undef"
  vivify_2379:
    $P5007 = $P5006."CURSOR"()
    new $P5008, "String"
    assign $P5008, "Could not find parent class '"
    find_lex $P5009, "$/"
    unless_null $P5009, vivify_2380
    $P5009 = root_new ['parrot';'Hash']
  vivify_2380:
    set $P5010, $P5009["parent"]
    unless_null $P5010, vivify_2381
    $P5010 = root_new ['parrot';'ResizablePMCArray']
  vivify_2381:
    set $P5011, $P5010[0]
    unless_null $P5011, vivify_2382
    new $P5011, "Undef"
  vivify_2382:
    set $S5012, $P5011
    concat $P5013, $P5008, $S5012
    concat $P5014, $P5013, "'"
    $P5015 = $P5007."panic"($P5014)
.annotate 'line', 1770
    set $P4995, $P5015
.annotate 'line', 1767
    goto if_4996_end
  if_4996:
.annotate 'line', 1768
    find_dynamic_lex $P5000, "$*SC"
    unless_null $P5000, vivify_2383
    get_hll_global $P4998, "GLOBAL"
    get_who $P4999, $P4998
    set $P5000, $P4999["$SC"]
    unless_null $P5000, vivify_2384
    die "Contextual $*SC not found"
  vivify_2384:
  vivify_2383:
    find_dynamic_lex $P5003, "$*PACKAGE"
    unless_null $P5003, vivify_2385
    get_hll_global $P5001, "GLOBAL"
    get_who $P5002, $P5001
    set $P5003, $P5002["$PACKAGE"]
    unless_null $P5003, vivify_2386
    die "Contextual $*PACKAGE not found"
  vivify_2386:
  vivify_2385:
    find_lex $P5004, "$parent"
    unless_null $P5004, vivify_2387
    new $P5004, "Undef"
  vivify_2387:
    $P5005 = $P5000."pkg_add_parent_or_role"($P5003, "add_parent", $P5004)
.annotate 'line', 1767
    set $P4995, $P5005
  if_4996_end:
.annotate 'line', 1760
    .return ($P4995)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4978"  :anon :subid("523_1306916577.75068") :outer("522_1306916577.75068")
.annotate 'line', 1763
    new $P4990, 'ExceptionHandler'
    set_label $P4990, control_4989
    $P4990."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4990
.annotate 'line', 1764
    find_lex $P4980, "$/"
    unless_null $P4980, vivify_2373
    $P4980 = root_new ['parrot';'Hash']
  vivify_2373:
    set $P4981, $P4980["parent"]
    unless_null $P4981, vivify_2374
    $P4981 = root_new ['parrot';'ResizablePMCArray']
  vivify_2374:
    set $P4982, $P4981[0]
    unless_null $P4982, vivify_2375
    $P4982 = root_new ['parrot';'Hash']
  vivify_2375:
    set $P4983, $P4982["identifier"]
    unless_null $P4983, vivify_2376
    new $P4983, "Undef"
  vivify_2376:
    clone $P4984, $P4983
    find_lex $P4985, "$/"
    unless_null $P4985, vivify_2377
    new $P4985, "Undef"
  vivify_2377:
    $P4986 = "find_sym"($P4984, $P4985)
    store_lex "$parent", $P4986
.annotate 'line', 1765
    new $P4987, "Integer"
    assign $P4987, 1
    store_lex "$parent_found", $P4987
.annotate 'line', 1763
    pop_eh 
    goto skip_handler_4988
  control_4989:
    .local pmc exception 
    .get_results (exception) 
    new $P4993, 'Integer'
    set $P4993, 1
    set exception["handled"], $P4993
    set $I4994, exception["handled"]
    ne $I4994, 1, nothandled_4992
  handled_4991:
    .return (exception)
  nothandled_4992:
    rethrow exception
  skip_handler_4988:
    .return ($P4987)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5049"  :anon :subid("525_1306916577.75068") :outer("521_1306916577.75068")
    .param pmc param_5053
.annotate 'line', 1782
    .const 'Sub' $P5057 = "526_1306916577.75068" 
    capture_lex $P5057
.annotate 'line', 1783
    new $P5051, "Undef"
    .lex "$role", $P5051
.annotate 'line', 1784
    new $P5052, "Undef"
    .lex "$role_found", $P5052
    .lex "$_", param_5053
.annotate 'line', 1782
    find_lex $P5054, "$role"
    unless_null $P5054, vivify_2393
    new $P5054, "Undef"
  vivify_2393:
    find_lex $P5055, "$role_found"
    unless_null $P5055, vivify_2394
    new $P5055, "Undef"
  vivify_2394:
.annotate 'line', 1785
    .const 'Sub' $P5057 = "526_1306916577.75068" 
    capture_lex $P5057
    $P5057()
.annotate 'line', 1789
    find_lex $P5073, "$role_found"
    unless_null $P5073, vivify_2398
    new $P5073, "Undef"
  vivify_2398:
    if $P5073, if_5072
.annotate 'line', 1793
    find_lex $P5082, "$/"
    unless_null $P5082, vivify_2399
    new $P5082, "Undef"
  vivify_2399:
    $P5083 = $P5082."CURSOR"()
    new $P5084, "String"
    assign $P5084, "Could not find role '"
    find_lex $P5085, "$_"
    unless_null $P5085, vivify_2400
    new $P5085, "Undef"
  vivify_2400:
    set $S5086, $P5085
    concat $P5087, $P5084, $S5086
    concat $P5088, $P5087, "'"
    $P5089 = $P5083."panic"($P5088)
.annotate 'line', 1792
    set $P5071, $P5089
.annotate 'line', 1789
    goto if_5072_end
  if_5072:
.annotate 'line', 1790
    find_dynamic_lex $P5076, "$*SC"
    unless_null $P5076, vivify_2401
    get_hll_global $P5074, "GLOBAL"
    get_who $P5075, $P5074
    set $P5076, $P5075["$SC"]
    unless_null $P5076, vivify_2402
    die "Contextual $*SC not found"
  vivify_2402:
  vivify_2401:
    find_dynamic_lex $P5079, "$*PACKAGE"
    unless_null $P5079, vivify_2403
    get_hll_global $P5077, "GLOBAL"
    get_who $P5078, $P5077
    set $P5079, $P5078["$PACKAGE"]
    unless_null $P5079, vivify_2404
    die "Contextual $*PACKAGE not found"
  vivify_2404:
  vivify_2403:
    find_lex $P5080, "$role"
    unless_null $P5080, vivify_2405
    new $P5080, "Undef"
  vivify_2405:
    $P5081 = $P5076."pkg_add_parent_or_role"($P5079, "add_role", $P5080)
.annotate 'line', 1789
    set $P5071, $P5081
  if_5072_end:
.annotate 'line', 1782
    .return ($P5071)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5056"  :anon :subid("526_1306916577.75068") :outer("525_1306916577.75068")
.annotate 'line', 1785
    new $P5066, 'ExceptionHandler'
    set_label $P5066, control_5065
    $P5066."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P5066
.annotate 'line', 1786
    find_lex $P5058, "$_"
    unless_null $P5058, vivify_2395
    $P5058 = root_new ['parrot';'Hash']
  vivify_2395:
    set $P5059, $P5058["identifier"]
    unless_null $P5059, vivify_2396
    new $P5059, "Undef"
  vivify_2396:
    clone $P5060, $P5059
    find_lex $P5061, "$/"
    unless_null $P5061, vivify_2397
    new $P5061, "Undef"
  vivify_2397:
    $P5062 = "find_sym"($P5060, $P5061)
    store_lex "$role", $P5062
.annotate 'line', 1787
    new $P5063, "Integer"
    assign $P5063, 1
    store_lex "$role_found", $P5063
.annotate 'line', 1785
    pop_eh 
    goto skip_handler_5064
  control_5065:
    .local pmc exception 
    .get_results (exception) 
    new $P5069, 'Integer'
    set $P5069, 1
    set exception["handled"], $P5069
    set $I5070, exception["handled"]
    ne $I5070, 1, nothandled_5068
  handled_5067:
    .return (exception)
  nothandled_5068:
    rethrow exception
  skip_handler_5064:
    .return ($P5063)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>" :anon :subid("527_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5103
    .param pmc param_5104
.annotate 'line', 1804
    .lex "self", param_5103
    .lex "$/", param_5104
    find_lex $P5105, "$/"
    find_lex $P5106, "$/"
    unless_null $P5106, vivify_2411
    $P5106 = root_new ['parrot';'Hash']
  vivify_2411:
    set $P5107, $P5106["scoped"]
    unless_null $P5107, vivify_2412
    new $P5107, "Undef"
  vivify_2412:
    $P5108 = $P5107."ast"()
    $P5109 = $P5105."!make"($P5108)
    .return ($P5109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>" :anon :subid("528_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5111
    .param pmc param_5112
.annotate 'line', 1805
    .lex "self", param_5111
    .lex "$/", param_5112
    find_lex $P5113, "$/"
    find_lex $P5114, "$/"
    unless_null $P5114, vivify_2413
    $P5114 = root_new ['parrot';'Hash']
  vivify_2413:
    set $P5115, $P5114["scoped"]
    unless_null $P5115, vivify_2414
    new $P5115, "Undef"
  vivify_2414:
    $P5116 = $P5115."ast"()
    $P5117 = $P5113."!make"($P5116)
    .return ($P5117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>" :anon :subid("529_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5119
    .param pmc param_5120
.annotate 'line', 1806
    .lex "self", param_5119
    .lex "$/", param_5120
    find_lex $P5121, "$/"
    find_lex $P5122, "$/"
    unless_null $P5122, vivify_2415
    $P5122 = root_new ['parrot';'Hash']
  vivify_2415:
    set $P5123, $P5122["scoped"]
    unless_null $P5123, vivify_2416
    new $P5123, "Undef"
  vivify_2416:
    $P5124 = $P5123."ast"()
    $P5125 = $P5121."!make"($P5124)
    .return ($P5125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped" :anon :subid("530_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5127
    .param pmc param_5128
.annotate 'line', 1808
    .lex "self", param_5127
    .lex "$/", param_5128
.annotate 'line', 1809
    find_lex $P5129, "$/"
    find_lex $P5132, "$/"
    unless_null $P5132, vivify_2417
    $P5132 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P5133, $P5132["declarator"]
    unless_null $P5133, vivify_2418
    new $P5133, "Undef"
  vivify_2418:
    if $P5133, if_5131
.annotate 'line', 1810
    find_lex $P5139, "$/"
    unless_null $P5139, vivify_2419
    $P5139 = root_new ['parrot';'Hash']
  vivify_2419:
    set $P5140, $P5139["multi_declarator"]
    unless_null $P5140, vivify_2420
    new $P5140, "Undef"
  vivify_2420:
    if $P5140, if_5138
.annotate 'line', 1811
    find_lex $P5144, "$/"
    unless_null $P5144, vivify_2421
    $P5144 = root_new ['parrot';'Hash']
  vivify_2421:
    set $P5145, $P5144["package_declarator"]
    unless_null $P5145, vivify_2422
    new $P5145, "Undef"
  vivify_2422:
    $P5146 = $P5145."ast"()
    set $P5137, $P5146
.annotate 'line', 1810
    goto if_5138_end
  if_5138:
    find_lex $P5141, "$/"
    unless_null $P5141, vivify_2423
    $P5141 = root_new ['parrot';'Hash']
  vivify_2423:
    set $P5142, $P5141["multi_declarator"]
    unless_null $P5142, vivify_2424
    new $P5142, "Undef"
  vivify_2424:
    $P5143 = $P5142."ast"()
    set $P5137, $P5143
  if_5138_end:
    set $P5130, $P5137
.annotate 'line', 1809
    goto if_5131_end
  if_5131:
    find_lex $P5134, "$/"
    unless_null $P5134, vivify_2425
    $P5134 = root_new ['parrot';'Hash']
  vivify_2425:
    set $P5135, $P5134["declarator"]
    unless_null $P5135, vivify_2426
    new $P5135, "Undef"
  vivify_2426:
    $P5136 = $P5135."ast"()
    set $P5130, $P5136
  if_5131_end:
    $P5147 = $P5129."!make"($P5130)
.annotate 'line', 1808
    .return ($P5147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator" :anon :subid("531_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5149
    .param pmc param_5150
.annotate 'line', 1814
    .lex "self", param_5149
    .lex "$/", param_5150
.annotate 'line', 1815
    find_lex $P5151, "$/"
.annotate 'line', 1816
    find_lex $P5154, "$/"
    unless_null $P5154, vivify_2427
    $P5154 = root_new ['parrot';'Hash']
  vivify_2427:
    set $P5155, $P5154["routine_declarator"]
    unless_null $P5155, vivify_2428
    new $P5155, "Undef"
  vivify_2428:
    if $P5155, if_5153
.annotate 'line', 1817
    find_lex $P5159, "$/"
    unless_null $P5159, vivify_2429
    $P5159 = root_new ['parrot';'Hash']
  vivify_2429:
    set $P5160, $P5159["variable_declarator"]
    unless_null $P5160, vivify_2430
    new $P5160, "Undef"
  vivify_2430:
    $P5161 = $P5160."ast"()
    set $P5152, $P5161
.annotate 'line', 1816
    goto if_5153_end
  if_5153:
    find_lex $P5156, "$/"
    unless_null $P5156, vivify_2431
    $P5156 = root_new ['parrot';'Hash']
  vivify_2431:
    set $P5157, $P5156["routine_declarator"]
    unless_null $P5157, vivify_2432
    new $P5157, "Undef"
  vivify_2432:
    $P5158 = $P5157."ast"()
    set $P5152, $P5158
  if_5153_end:
    $P5162 = $P5151."!make"($P5152)
.annotate 'line', 1814
    .return ($P5162)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>" :anon :subid("532_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5164
    .param pmc param_5165
.annotate 'line', 1820
    .lex "self", param_5164
    .lex "$/", param_5165
    find_lex $P5166, "$/"
    find_lex $P5169, "$/"
    unless_null $P5169, vivify_2433
    $P5169 = root_new ['parrot';'Hash']
  vivify_2433:
    set $P5170, $P5169["declarator"]
    unless_null $P5170, vivify_2434
    new $P5170, "Undef"
  vivify_2434:
    if $P5170, if_5168
    find_lex $P5174, "$/"
    unless_null $P5174, vivify_2435
    $P5174 = root_new ['parrot';'Hash']
  vivify_2435:
    set $P5175, $P5174["routine_def"]
    unless_null $P5175, vivify_2436
    new $P5175, "Undef"
  vivify_2436:
    $P5176 = $P5175."ast"()
    set $P5167, $P5176
    goto if_5168_end
  if_5168:
    find_lex $P5171, "$/"
    unless_null $P5171, vivify_2437
    $P5171 = root_new ['parrot';'Hash']
  vivify_2437:
    set $P5172, $P5171["declarator"]
    unless_null $P5172, vivify_2438
    new $P5172, "Undef"
  vivify_2438:
    $P5173 = $P5172."ast"()
    set $P5167, $P5173
  if_5168_end:
    $P5177 = $P5166."!make"($P5167)
    .return ($P5177)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>" :anon :subid("533_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5179
    .param pmc param_5180
.annotate 'line', 1821
    .lex "self", param_5179
    .lex "$/", param_5180
    find_lex $P5181, "$/"
    find_lex $P5184, "$/"
    unless_null $P5184, vivify_2439
    $P5184 = root_new ['parrot';'Hash']
  vivify_2439:
    set $P5185, $P5184["declarator"]
    unless_null $P5185, vivify_2440
    new $P5185, "Undef"
  vivify_2440:
    if $P5185, if_5183
    find_lex $P5189, "$/"
    unless_null $P5189, vivify_2441
    $P5189 = root_new ['parrot';'Hash']
  vivify_2441:
    set $P5190, $P5189["routine_def"]
    unless_null $P5190, vivify_2442
    new $P5190, "Undef"
  vivify_2442:
    $P5191 = $P5190."ast"()
    set $P5182, $P5191
    goto if_5183_end
  if_5183:
    find_lex $P5186, "$/"
    unless_null $P5186, vivify_2443
    $P5186 = root_new ['parrot';'Hash']
  vivify_2443:
    set $P5187, $P5186["declarator"]
    unless_null $P5187, vivify_2444
    new $P5187, "Undef"
  vivify_2444:
    $P5188 = $P5187."ast"()
    set $P5182, $P5188
  if_5183_end:
    $P5192 = $P5181."!make"($P5182)
    .return ($P5192)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>" :anon :subid("534_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5194
    .param pmc param_5195
.annotate 'line', 1822
    .lex "self", param_5194
    .lex "$/", param_5195
    find_lex $P5196, "$/"
    find_lex $P5197, "$/"
    unless_null $P5197, vivify_2445
    $P5197 = root_new ['parrot';'Hash']
  vivify_2445:
    set $P5198, $P5197["declarator"]
    unless_null $P5198, vivify_2446
    new $P5198, "Undef"
  vivify_2446:
    $P5199 = $P5198."ast"()
    $P5200 = $P5196."!make"($P5199)
    .return ($P5200)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator" :anon :subid("535_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5202
    .param pmc param_5203
.annotate 'line', 1825
    .const 'Sub' $P5335 = "537_1306916577.75068" 
    capture_lex $P5335
    .const 'Sub' $P5237 = "536_1306916577.75068" 
    capture_lex $P5237
    .lex "self", param_5202
    .lex "$/", param_5203
.annotate 'line', 1826
    new $P5204, "Undef"
    .lex "$past", $P5204
.annotate 'line', 1827
    new $P5205, "Undef"
    .lex "$sigil", $P5205
.annotate 'line', 1828
    new $P5206, "Undef"
    .lex "$name", $P5206
.annotate 'line', 1829
    new $P5207, "Undef"
    .lex "$BLOCK", $P5207
.annotate 'line', 1826
    find_lex $P5208, "$/"
    unless_null $P5208, vivify_2447
    $P5208 = root_new ['parrot';'Hash']
  vivify_2447:
    set $P5209, $P5208["variable"]
    unless_null $P5209, vivify_2448
    new $P5209, "Undef"
  vivify_2448:
    $P5210 = $P5209."ast"()
    store_lex "$past", $P5210
.annotate 'line', 1827
    find_lex $P5211, "$/"
    unless_null $P5211, vivify_2449
    $P5211 = root_new ['parrot';'Hash']
  vivify_2449:
    set $P5212, $P5211["variable"]
    unless_null $P5212, vivify_2450
    $P5212 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P5213, $P5212["sigil"]
    unless_null $P5213, vivify_2451
    new $P5213, "Undef"
  vivify_2451:
    store_lex "$sigil", $P5213
.annotate 'line', 1828
    find_lex $P5214, "$past"
    unless_null $P5214, vivify_2452
    new $P5214, "Undef"
  vivify_2452:
    $P5215 = $P5214."name"()
    store_lex "$name", $P5215
.annotate 'line', 1829
    find_lex $P5216, "$?PACKAGE"
    get_who $P5217, $P5216
    set $P5218, $P5217["@BLOCK"]
    unless_null $P5218, vivify_2453
    $P5218 = root_new ['parrot';'ResizablePMCArray']
  vivify_2453:
    set $P5219, $P5218[0]
    unless_null $P5219, vivify_2454
    new $P5219, "Undef"
  vivify_2454:
    store_lex "$BLOCK", $P5219
.annotate 'line', 1830
    find_lex $P5223, "$name"
    unless_null $P5223, vivify_2455
    new $P5223, "Undef"
  vivify_2455:
    if $P5223, if_5222
    set $P5221, $P5223
    goto if_5222_end
  if_5222:
    find_lex $P5224, "$BLOCK"
    unless_null $P5224, vivify_2456
    new $P5224, "Undef"
  vivify_2456:
    find_lex $P5225, "$name"
    unless_null $P5225, vivify_2457
    new $P5225, "Undef"
  vivify_2457:
    $P5226 = $P5224."symbol"($P5225)
    set $P5221, $P5226
  if_5222_end:
    unless $P5221, if_5220_end
.annotate 'line', 1831
    find_lex $P5227, "$/"
    unless_null $P5227, vivify_2458
    new $P5227, "Undef"
  vivify_2458:
    $P5228 = $P5227."CURSOR"()
    find_lex $P5229, "$name"
    unless_null $P5229, vivify_2459
    new $P5229, "Undef"
  vivify_2459:
    $P5228."panic"("Redeclaration of symbol ", $P5229)
  if_5220_end:
.annotate 'line', 1833
    find_dynamic_lex $P5233, "$*SCOPE"
    unless_null $P5233, vivify_2460
    get_hll_global $P5231, "GLOBAL"
    get_who $P5232, $P5231
    set $P5233, $P5232["$SCOPE"]
    unless_null $P5233, vivify_2461
    die "Contextual $*SCOPE not found"
  vivify_2461:
  vivify_2460:
    set $S5234, $P5233
    iseq $I5235, $S5234, "has"
    if $I5235, if_5230
.annotate 'line', 1853
    find_dynamic_lex $P5294, "$*SCOPE"
    unless_null $P5294, vivify_2462
    get_hll_global $P5292, "GLOBAL"
    get_who $P5293, $P5292
    set $P5294, $P5293["$SCOPE"]
    unless_null $P5294, vivify_2463
    die "Contextual $*SCOPE not found"
  vivify_2463:
  vivify_2462:
    set $S5295, $P5294
    iseq $I5296, $S5295, "our"
    if $I5296, if_5291
.annotate 'line', 1863
    find_lex $P5310, "$BLOCK"
    unless_null $P5310, vivify_2464
    $P5310 = root_new ['parrot';'ResizablePMCArray']
  vivify_2464:
    set $P5311, $P5310[0]
    unless_null $P5311, vivify_2465
    new $P5311, "Undef"
  vivify_2465:
    get_hll_global $P5312, "GLOBAL"
    nqp_get_package_through_who $P5313, $P5312, "PAST"
    get_who $P5314, $P5313
    set $P5315, $P5314["Var"]
    find_lex $P5316, "$name"
    unless_null $P5316, vivify_2466
    new $P5316, "Undef"
  vivify_2466:
.annotate 'line', 1865
    find_lex $P5317, "$sigil"
    unless_null $P5317, vivify_2467
    new $P5317, "Undef"
  vivify_2467:
    $P5318 = "vivitype"($P5317)
    find_lex $P5319, "$/"
    unless_null $P5319, vivify_2468
    new $P5319, "Undef"
  vivify_2468:
    $P5320 = $P5315."new"($P5316 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5318 :named("viviself"), $P5319 :named("node"))
.annotate 'line', 1863
    $P5311."push"($P5320)
.annotate 'line', 1868
    find_lex $P5321, "$BLOCK"
    unless_null $P5321, vivify_2469
    new $P5321, "Undef"
  vivify_2469:
    find_lex $P5322, "$name"
    unless_null $P5322, vivify_2470
    new $P5322, "Undef"
  vivify_2470:
    $P5321."symbol"($P5322, "lexical" :named("scope"))
.annotate 'line', 1862
    goto if_5291_end
  if_5291:
.annotate 'line', 1857
    find_lex $P5297, "$/"
    unless_null $P5297, vivify_2471
    $P5297 = root_new ['parrot';'Hash']
  vivify_2471:
    set $P5298, $P5297["variable"]
    unless_null $P5298, vivify_2472
    new $P5298, "Undef"
  vivify_2472:
    set $S5299, $P5298
    new $P5300, 'String'
    set $P5300, $S5299
    store_lex "$name", $P5300
.annotate 'line', 1858
    find_lex $P5301, "$name"
    unless_null $P5301, vivify_2473
    new $P5301, "Undef"
  vivify_2473:
    new $P5302, "ResizablePMCArray"
    push $P5302, $P5301
    find_lex $P5303, "$/"
    unless_null $P5303, vivify_2474
    new $P5303, "Undef"
  vivify_2474:
    $P5304 = "lexical_package_lookup"($P5302, $P5303)
    store_lex "$past", $P5304
.annotate 'line', 1859
    find_lex $P5305, "$past"
    unless_null $P5305, vivify_2475
    new $P5305, "Undef"
  vivify_2475:
    find_lex $P5306, "$sigil"
    unless_null $P5306, vivify_2476
    new $P5306, "Undef"
  vivify_2476:
    $P5307 = "vivitype"($P5306)
    $P5305."viviself"($P5307)
.annotate 'line', 1860
    find_lex $P5308, "$BLOCK"
    unless_null $P5308, vivify_2477
    new $P5308, "Undef"
  vivify_2477:
    find_lex $P5309, "$name"
    unless_null $P5309, vivify_2478
    new $P5309, "Undef"
  vivify_2478:
    $P5308."symbol"($P5309, "package" :named("scope"))
  if_5291_end:
.annotate 'line', 1853
    goto if_5230_end
  if_5230:
.annotate 'line', 1833
    .const 'Sub' $P5237 = "536_1306916577.75068" 
    capture_lex $P5237
    $P5237()
  if_5230_end:
.annotate 'line', 1872
    find_lex $P5323, "$/"
    find_lex $P5324, "$past"
    unless_null $P5324, vivify_2508
    new $P5324, "Undef"
  vivify_2508:
    $P5323."!make"($P5324)
.annotate 'line', 1874
    find_lex $P5327, "$/"
    unless_null $P5327, vivify_2509
    $P5327 = root_new ['parrot';'Hash']
  vivify_2509:
    set $P5328, $P5327["trait"]
    unless_null $P5328, vivify_2510
    new $P5328, "Undef"
  vivify_2510:
    if $P5328, if_5326
    set $P5325, $P5328
    goto if_5326_end
  if_5326:
.annotate 'line', 1875
    find_lex $P5330, "$/"
    unless_null $P5330, vivify_2511
    $P5330 = root_new ['parrot';'Hash']
  vivify_2511:
    set $P5331, $P5330["trait"]
    unless_null $P5331, vivify_2512
    new $P5331, "Undef"
  vivify_2512:
    defined $I5332, $P5331
    unless $I5332, for_undef_2513
    iter $P5329, $P5331
    new $P5342, 'ExceptionHandler'
    set_label $P5342, loop5341_handler
    $P5342."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5342
  loop5341_test:
    unless $P5329, loop5341_done
    shift $P5333, $P5329
  loop5341_redo:
    .const 'Sub' $P5335 = "537_1306916577.75068" 
    capture_lex $P5335
    $P5335($P5333)
  loop5341_next:
    goto loop5341_test
  loop5341_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5343, exception, 'type'
    eq $P5343, .CONTROL_LOOP_NEXT, loop5341_next
    eq $P5343, .CONTROL_LOOP_REDO, loop5341_redo
  loop5341_done:
    pop_eh 
  for_undef_2513:
.annotate 'line', 1874
    set $P5325, $P5329
  if_5326_end:
.annotate 'line', 1825
    .return ($P5325)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5236"  :anon :subid("536_1306916577.75068") :outer("535_1306916577.75068")
.annotate 'line', 1840
    $P5238 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P5238
.annotate 'line', 1841
    $P5239 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P5239
.annotate 'line', 1835
    find_dynamic_lex $P5246, "$*PKGDECL"
    unless_null $P5246, vivify_2479
    get_hll_global $P5244, "GLOBAL"
    get_who $P5245, $P5244
    set $P5246, $P5245["$PKGDECL"]
    unless_null $P5246, vivify_2480
    die "Contextual $*PKGDECL not found"
  vivify_2480:
  vivify_2479:
    concat $P5247, $P5246, "-attr"
    find_dynamic_lex $P5243, "%*HOW"
    unless_null $P5243, vivify_2481
    get_hll_global $P5241, "GLOBAL"
    get_who $P5242, $P5241
    set $P5243, $P5242["%HOW"]
    unless_null $P5243, vivify_2482
    die "Contextual %*HOW not found"
  vivify_2482:
  vivify_2481:
    exists $I5248, $P5243[$P5247]
    if $I5248, unless_5240_end
.annotate 'line', 1836
    find_lex $P5249, "$/"
    unless_null $P5249, vivify_2483
    new $P5249, "Undef"
  vivify_2483:
    $P5250 = $P5249."CURSOR"()
    find_dynamic_lex $P5253, "$*PKGDECL"
    unless_null $P5253, vivify_2484
    get_hll_global $P5251, "GLOBAL"
    get_who $P5252, $P5251
    set $P5253, $P5252["$PKGDECL"]
    unless_null $P5253, vivify_2485
    die "Contextual $*PKGDECL not found"
  vivify_2485:
  vivify_2484:
    concat $P5254, $P5253, " packages do not support attributes"
    $P5250."panic"($P5254)
  unless_5240_end:
.annotate 'line', 1835
    find_lex $P5255, "%lit_args"
    unless_null $P5255, vivify_2486
    $P5255 = root_new ['parrot';'Hash']
  vivify_2486:
    find_lex $P5256, "%obj_args"
    unless_null $P5256, vivify_2487
    $P5256 = root_new ['parrot';'Hash']
  vivify_2487:
.annotate 'line', 1842
    find_lex $P5257, "$name"
    unless_null $P5257, vivify_2488
    new $P5257, "Undef"
  vivify_2488:
    find_lex $P5258, "%lit_args"
    unless_null $P5258, vivify_2489
    $P5258 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P5258
  vivify_2489:
    set $P5258["name"], $P5257
.annotate 'line', 1843
    find_lex $P5260, "$/"
    unless_null $P5260, vivify_2490
    $P5260 = root_new ['parrot';'Hash']
  vivify_2490:
    set $P5261, $P5260["typename"]
    unless_null $P5261, vivify_2491
    new $P5261, "Undef"
  vivify_2491:
    unless $P5261, if_5259_end
.annotate 'line', 1844
    find_lex $P5262, "$/"
    unless_null $P5262, vivify_2492
    $P5262 = root_new ['parrot';'Hash']
  vivify_2492:
    set $P5263, $P5262["typename"]
    unless_null $P5263, vivify_2493
    $P5263 = root_new ['parrot';'ResizablePMCArray']
  vivify_2493:
    set $P5264, $P5263[0]
    unless_null $P5264, vivify_2494
    new $P5264, "Undef"
  vivify_2494:
    set $S5265, $P5264
    new $P5266, "ResizablePMCArray"
    push $P5266, $S5265
    find_lex $P5267, "$/"
    unless_null $P5267, vivify_2495
    new $P5267, "Undef"
  vivify_2495:
    $P5268 = "find_sym"($P5266, $P5267)
    find_lex $P5269, "%obj_args"
    unless_null $P5269, vivify_2496
    $P5269 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P5269
  vivify_2496:
    set $P5269["type"], $P5268
  if_5259_end:
.annotate 'line', 1848
    find_dynamic_lex $P5272, "$*SC"
    unless_null $P5272, vivify_2497
    get_hll_global $P5270, "GLOBAL"
    get_who $P5271, $P5270
    set $P5272, $P5271["$SC"]
    unless_null $P5272, vivify_2498
    die "Contextual $*SC not found"
  vivify_2498:
  vivify_2497:
    find_dynamic_lex $P5275, "$*PACKAGE"
    unless_null $P5275, vivify_2499
    get_hll_global $P5273, "GLOBAL"
    get_who $P5274, $P5273
    set $P5275, $P5274["$PACKAGE"]
    unless_null $P5275, vivify_2500
    die "Contextual $*PACKAGE not found"
  vivify_2500:
  vivify_2499:
    find_dynamic_lex $P5278, "$*PKGDECL"
    unless_null $P5278, vivify_2501
    get_hll_global $P5276, "GLOBAL"
    get_who $P5277, $P5276
    set $P5278, $P5277["$PKGDECL"]
    unless_null $P5278, vivify_2502
    die "Contextual $*PKGDECL not found"
  vivify_2502:
  vivify_2501:
    concat $P5279, $P5278, "-attr"
    find_dynamic_lex $P5282, "%*HOW"
    unless_null $P5282, vivify_2503
    get_hll_global $P5280, "GLOBAL"
    get_who $P5281, $P5280
    set $P5282, $P5281["%HOW"]
    unless_null $P5282, vivify_2504
    die "Contextual %*HOW not found"
  vivify_2504:
  vivify_2503:
    set $P5283, $P5282[$P5279]
    unless_null $P5283, vivify_2505
    new $P5283, "Undef"
  vivify_2505:
    find_lex $P5284, "%lit_args"
    unless_null $P5284, vivify_2506
    $P5284 = root_new ['parrot';'Hash']
  vivify_2506:
    find_lex $P5285, "%obj_args"
    unless_null $P5285, vivify_2507
    $P5285 = root_new ['parrot';'Hash']
  vivify_2507:
    $P5272."pkg_add_attribute"($P5275, $P5283, $P5284, $P5285)
.annotate 'line', 1851
    get_hll_global $P5286, "GLOBAL"
    nqp_get_package_through_who $P5287, $P5286, "PAST"
    get_who $P5288, $P5287
    set $P5289, $P5288["Stmts"]
    $P5290 = $P5289."new"()
    store_lex "$past", $P5290
.annotate 'line', 1833
    .return ($P5290)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5334"  :anon :subid("537_1306916577.75068") :outer("535_1306916577.75068")
    .param pmc param_5336
.annotate 'line', 1875
    .lex "$_", param_5336
    find_lex $P5337, "$_"
    unless_null $P5337, vivify_2514
    new $P5337, "Undef"
  vivify_2514:
    $P5338 = $P5337."ast"()
    find_lex $P5339, "$/"
    unless_null $P5339, vivify_2515
    new $P5339, "Undef"
  vivify_2515:
    $P5340 = $P5338($P5339)
    .return ($P5340)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>" :anon :subid("538_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5345
    .param pmc param_5346
.annotate 'line', 1880
    .lex "self", param_5345
    .lex "$/", param_5346
    find_lex $P5347, "$/"
    find_lex $P5348, "$/"
    unless_null $P5348, vivify_2516
    $P5348 = root_new ['parrot';'Hash']
  vivify_2516:
    set $P5349, $P5348["routine_def"]
    unless_null $P5349, vivify_2517
    new $P5349, "Undef"
  vivify_2517:
    $P5350 = $P5349."ast"()
    $P5351 = $P5347."!make"($P5350)
    .return ($P5351)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>" :anon :subid("539_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5353
    .param pmc param_5354
.annotate 'line', 1881
    .lex "self", param_5353
    .lex "$/", param_5354
    find_lex $P5355, "$/"
    find_lex $P5356, "$/"
    unless_null $P5356, vivify_2518
    $P5356 = root_new ['parrot';'Hash']
  vivify_2518:
    set $P5357, $P5356["method_def"]
    unless_null $P5357, vivify_2519
    new $P5357, "Undef"
  vivify_2519:
    $P5358 = $P5357."ast"()
    $P5359 = $P5355."!make"($P5358)
    .return ($P5359)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def" :anon :subid("540_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5361
    .param pmc param_5362
.annotate 'line', 1883
    .const 'Sub' $P5675 = "546_1306916577.75068" 
    capture_lex $P5675
    .const 'Sub' $P5384 = "541_1306916577.75068" 
    capture_lex $P5384
    .lex "self", param_5361
    .lex "$/", param_5362
.annotate 'line', 1886
    new $P5363, "Undef"
    .lex "$past", $P5363
.annotate 'line', 1897
    new $P5364, "Undef"
    .lex "$block", $P5364
.annotate 'line', 1883
    find_lex $P5365, "$past"
    unless_null $P5365, vivify_2520
    new $P5365, "Undef"
  vivify_2520:
.annotate 'line', 1887
    find_lex $P5367, "$/"
    unless_null $P5367, vivify_2521
    $P5367 = root_new ['parrot';'Hash']
  vivify_2521:
    set $P5368, $P5367["onlystar"]
    unless_null $P5368, vivify_2522
    new $P5368, "Undef"
  vivify_2522:
    if $P5368, if_5366
.annotate 'line', 1891
    find_lex $P5370, "$/"
    unless_null $P5370, vivify_2523
    $P5370 = root_new ['parrot';'Hash']
  vivify_2523:
    set $P5371, $P5370["blockoid"]
    unless_null $P5371, vivify_2524
    new $P5371, "Undef"
  vivify_2524:
    $P5372 = $P5371."ast"()
    store_lex "$past", $P5372
.annotate 'line', 1892
    find_lex $P5373, "$past"
    unless_null $P5373, vivify_2525
    new $P5373, "Undef"
  vivify_2525:
    $P5373."blocktype"("declaration")
.annotate 'line', 1893
    find_dynamic_lex $P5377, "$*RETURN_USED"
    unless_null $P5377, vivify_2526
    get_hll_global $P5375, "GLOBAL"
    get_who $P5376, $P5375
    set $P5377, $P5376["$RETURN_USED"]
    unless_null $P5377, vivify_2527
    die "Contextual $*RETURN_USED not found"
  vivify_2527:
  vivify_2526:
    unless $P5377, if_5374_end
.annotate 'line', 1894
    find_lex $P5378, "$past"
    unless_null $P5378, vivify_2528
    new $P5378, "Undef"
  vivify_2528:
    $P5378."control"("return_pir")
  if_5374_end:
.annotate 'line', 1890
    goto if_5366_end
  if_5366:
.annotate 'line', 1888
    $P5369 = "only_star_block"()
    store_lex "$past", $P5369
  if_5366_end:
.annotate 'line', 1897
    find_lex $P5379, "$past"
    unless_null $P5379, vivify_2529
    new $P5379, "Undef"
  vivify_2529:
    store_lex "$block", $P5379
.annotate 'line', 1899
    find_lex $P5381, "$/"
    unless_null $P5381, vivify_2530
    $P5381 = root_new ['parrot';'Hash']
  vivify_2530:
    set $P5382, $P5381["deflongname"]
    unless_null $P5382, vivify_2531
    new $P5382, "Undef"
  vivify_2531:
    unless $P5382, if_5380_end
    .const 'Sub' $P5384 = "541_1306916577.75068" 
    capture_lex $P5384
    $P5384()
  if_5380_end:
.annotate 'line', 2000
    find_lex $P5664, "$block"
    unless_null $P5664, vivify_2637
    new $P5664, "Undef"
  vivify_2637:
    find_lex $P5665, "$past"
    unless_null $P5665, vivify_2638
    $P5665 = root_new ['parrot';'Hash']
    store_lex "$past", $P5665
  vivify_2638:
    set $P5665["block_past"], $P5664
.annotate 'line', 2001
    find_lex $P5667, "$/"
    unless_null $P5667, vivify_2639
    $P5667 = root_new ['parrot';'Hash']
  vivify_2639:
    set $P5668, $P5667["trait"]
    unless_null $P5668, vivify_2640
    new $P5668, "Undef"
  vivify_2640:
    unless $P5668, if_5666_end
.annotate 'line', 2002
    find_lex $P5670, "$/"
    unless_null $P5670, vivify_2641
    $P5670 = root_new ['parrot';'Hash']
  vivify_2641:
    set $P5671, $P5670["trait"]
    unless_null $P5671, vivify_2642
    new $P5671, "Undef"
  vivify_2642:
    defined $I5672, $P5671
    unless $I5672, for_undef_2643
    iter $P5669, $P5671
    new $P5682, 'ExceptionHandler'
    set_label $P5682, loop5681_handler
    $P5682."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5682
  loop5681_test:
    unless $P5669, loop5681_done
    shift $P5673, $P5669
  loop5681_redo:
    .const 'Sub' $P5675 = "546_1306916577.75068" 
    capture_lex $P5675
    $P5675($P5673)
  loop5681_next:
    goto loop5681_test
  loop5681_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5683, exception, 'type'
    eq $P5683, .CONTROL_LOOP_NEXT, loop5681_next
    eq $P5683, .CONTROL_LOOP_REDO, loop5681_redo
  loop5681_done:
    pop_eh 
  for_undef_2643:
  if_5666_end:
.annotate 'line', 2005
    find_lex $P5684, "$/"
    find_lex $P5685, "$past"
    unless_null $P5685, vivify_2646
    new $P5685, "Undef"
  vivify_2646:
    $P5686 = $P5684."!make"($P5685)
.annotate 'line', 1883
    .return ($P5686)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5383"  :anon :subid("541_1306916577.75068") :outer("540_1306916577.75068")
.annotate 'line', 1899
    .const 'Sub' $P5538 = "545_1306916577.75068" 
    capture_lex $P5538
    .const 'Sub' $P5425 = "542_1306916577.75068" 
    capture_lex $P5425
.annotate 'line', 1900
    new $P5385, "Undef"
    .lex "$name", $P5385
    find_lex $P5386, "$/"
    unless_null $P5386, vivify_2532
    $P5386 = root_new ['parrot';'Hash']
  vivify_2532:
    set $P5387, $P5386["sigil"]
    unless_null $P5387, vivify_2533
    $P5387 = root_new ['parrot';'ResizablePMCArray']
  vivify_2533:
    set $P5388, $P5387[0]
    unless_null $P5388, vivify_2534
    new $P5388, "Undef"
  vivify_2534:
    set $S5389, $P5388
    new $P5390, 'String'
    set $P5390, $S5389
    find_lex $P5391, "$/"
    unless_null $P5391, vivify_2535
    $P5391 = root_new ['parrot';'Hash']
  vivify_2535:
    set $P5392, $P5391["deflongname"]
    unless_null $P5392, vivify_2536
    $P5392 = root_new ['parrot';'ResizablePMCArray']
  vivify_2536:
    set $P5393, $P5392[0]
    unless_null $P5393, vivify_2537
    new $P5393, "Undef"
  vivify_2537:
    $S5394 = $P5393."ast"()
    concat $P5395, $P5390, $S5394
    store_lex "$name", $P5395
.annotate 'line', 1901
    find_lex $P5396, "$past"
    unless_null $P5396, vivify_2538
    new $P5396, "Undef"
  vivify_2538:
    find_lex $P5397, "$name"
    unless_null $P5397, vivify_2539
    new $P5397, "Undef"
  vivify_2539:
    $P5396."name"($P5397)
.annotate 'line', 1902
    find_dynamic_lex $P5405, "$*SCOPE"
    unless_null $P5405, vivify_2540
    get_hll_global $P5403, "GLOBAL"
    get_who $P5404, $P5403
    set $P5405, $P5404["$SCOPE"]
    unless_null $P5405, vivify_2541
    die "Contextual $*SCOPE not found"
  vivify_2541:
  vivify_2540:
    set $S5406, $P5405
    iseq $I5407, $S5406, ""
    unless $I5407, unless_5402
    new $P5401, 'Integer'
    set $P5401, $I5407
    goto unless_5402_end
  unless_5402:
    find_dynamic_lex $P5410, "$*SCOPE"
    unless_null $P5410, vivify_2542
    get_hll_global $P5408, "GLOBAL"
    get_who $P5409, $P5408
    set $P5410, $P5409["$SCOPE"]
    unless_null $P5410, vivify_2543
    die "Contextual $*SCOPE not found"
  vivify_2543:
  vivify_2542:
    set $S5411, $P5410
    iseq $I5412, $S5411, "my"
    new $P5401, 'Integer'
    set $P5401, $I5412
  unless_5402_end:
    unless $P5401, unless_5400
    set $P5399, $P5401
    goto unless_5400_end
  unless_5400:
    find_dynamic_lex $P5415, "$*SCOPE"
    unless_null $P5415, vivify_2544
    get_hll_global $P5413, "GLOBAL"
    get_who $P5414, $P5413
    set $P5415, $P5414["$SCOPE"]
    unless_null $P5415, vivify_2545
    die "Contextual $*SCOPE not found"
  vivify_2545:
  vivify_2544:
    set $S5416, $P5415
    iseq $I5417, $S5416, "our"
    new $P5399, 'Integer'
    set $P5399, $I5417
  unless_5400_end:
    if $P5399, if_5398
.annotate 'line', 1990
    find_lex $P5645, "$/"
    unless_null $P5645, vivify_2546
    new $P5645, "Undef"
  vivify_2546:
    $P5646 = $P5645."CURSOR"()
    find_dynamic_lex $P5649, "$*SCOPE"
    unless_null $P5649, vivify_2547
    get_hll_global $P5647, "GLOBAL"
    get_who $P5648, $P5647
    set $P5649, $P5648["$SCOPE"]
    unless_null $P5649, vivify_2548
    die "Contextual $*SCOPE not found"
  vivify_2548:
  vivify_2547:
    concat $P5650, $P5649, " scoped routines are not supported yet"
    $P5646."panic"($P5650)
.annotate 'line', 1989
    goto if_5398_end
  if_5398:
.annotate 'line', 1903
    find_dynamic_lex $P5421, "$*MULTINESS"
    unless_null $P5421, vivify_2549
    get_hll_global $P5419, "GLOBAL"
    get_who $P5420, $P5419
    set $P5421, $P5420["$MULTINESS"]
    unless_null $P5421, vivify_2550
    die "Contextual $*MULTINESS not found"
  vivify_2550:
  vivify_2549:
    set $S5422, $P5421
    iseq $I5423, $S5422, "multi"
    if $I5423, if_5418
.annotate 'line', 1954
    find_dynamic_lex $P5534, "$*MULTINESS"
    unless_null $P5534, vivify_2551
    get_hll_global $P5532, "GLOBAL"
    get_who $P5533, $P5532
    set $P5534, $P5533["$MULTINESS"]
    unless_null $P5534, vivify_2552
    die "Contextual $*MULTINESS not found"
  vivify_2552:
  vivify_2551:
    set $S5535, $P5534
    iseq $I5536, $S5535, "proto"
    if $I5536, if_5531
.annotate 'line', 1973
    find_lex $P5588, "$?PACKAGE"
    get_who $P5589, $P5588
    set $P5590, $P5589["@BLOCK"]
    unless_null $P5590, vivify_2553
    $P5590 = root_new ['parrot';'ResizablePMCArray']
  vivify_2553:
    set $P5591, $P5590[0]
    unless_null $P5591, vivify_2554
    $P5591 = root_new ['parrot';'ResizablePMCArray']
  vivify_2554:
    set $P5592, $P5591[0]
    unless_null $P5592, vivify_2555
    new $P5592, "Undef"
  vivify_2555:
    get_hll_global $P5593, "GLOBAL"
    nqp_get_package_through_who $P5594, $P5593, "PAST"
    get_who $P5595, $P5594
    set $P5596, $P5595["Var"]
    find_lex $P5597, "$name"
    unless_null $P5597, vivify_2556
    new $P5597, "Undef"
  vivify_2556:
    find_lex $P5598, "$past"
    unless_null $P5598, vivify_2557
    new $P5598, "Undef"
  vivify_2557:
    $P5599 = $P5596."new"($P5597 :named("name"), 1 :named("isdecl"), $P5598 :named("viviself"), "lexical" :named("scope"))
    $P5592."push"($P5599)
.annotate 'line', 1975
    find_lex $P5600, "$?PACKAGE"
    get_who $P5601, $P5600
    set $P5602, $P5601["@BLOCK"]
    unless_null $P5602, vivify_2558
    $P5602 = root_new ['parrot';'ResizablePMCArray']
  vivify_2558:
    set $P5603, $P5602[0]
    unless_null $P5603, vivify_2559
    new $P5603, "Undef"
  vivify_2559:
    find_lex $P5604, "$name"
    unless_null $P5604, vivify_2560
    new $P5604, "Undef"
  vivify_2560:
    $P5603."symbol"($P5604, "lexical" :named("scope"))
.annotate 'line', 1976
    find_dynamic_lex $P5608, "$*SCOPE"
    unless_null $P5608, vivify_2561
    get_hll_global $P5606, "GLOBAL"
    get_who $P5607, $P5606
    set $P5608, $P5607["$SCOPE"]
    unless_null $P5608, vivify_2562
    die "Contextual $*SCOPE not found"
  vivify_2562:
  vivify_2561:
    set $S5609, $P5608
    iseq $I5610, $S5609, "our"
    unless $I5610, if_5605_end
.annotate 'line', 1979
    find_dynamic_lex $P5613, "$*SC"
    unless_null $P5613, vivify_2563
    get_hll_global $P5611, "GLOBAL"
    get_who $P5612, $P5611
    set $P5613, $P5612["$SC"]
    unless_null $P5613, vivify_2564
    die "Contextual $*SC not found"
  vivify_2564:
  vivify_2563:
    find_dynamic_lex $P5616, "$*PACKAGE"
    unless_null $P5616, vivify_2565
    get_hll_global $P5614, "GLOBAL"
    get_who $P5615, $P5614
    set $P5616, $P5615["$PACKAGE"]
    unless_null $P5616, vivify_2566
    die "Contextual $*PACKAGE not found"
  vivify_2566:
  vivify_2565:
    find_lex $P5617, "$name"
    unless_null $P5617, vivify_2567
    new $P5617, "Undef"
  vivify_2567:
    find_lex $P5618, "$past"
    unless_null $P5618, vivify_2568
    new $P5618, "Undef"
  vivify_2568:
    $P5613."install_package_routine"($P5616, $P5617, $P5618)
.annotate 'line', 1980
    find_lex $P5619, "$?PACKAGE"
    get_who $P5620, $P5619
    set $P5621, $P5620["@BLOCK"]
    unless_null $P5621, vivify_2569
    $P5621 = root_new ['parrot';'ResizablePMCArray']
  vivify_2569:
    set $P5622, $P5621[0]
    unless_null $P5622, vivify_2570
    $P5622 = root_new ['parrot';'ResizablePMCArray']
  vivify_2570:
    set $P5623, $P5622[0]
    unless_null $P5623, vivify_2571
    new $P5623, "Undef"
  vivify_2571:
    get_hll_global $P5624, "GLOBAL"
    nqp_get_package_through_who $P5625, $P5624, "PAST"
    get_who $P5626, $P5625
    set $P5627, $P5626["Op"]
.annotate 'line', 1982
    find_lex $P5628, "$name"
    unless_null $P5628, vivify_2572
    new $P5628, "Undef"
  vivify_2572:
    new $P5629, "ResizablePMCArray"
    push $P5629, $P5628
    find_lex $P5630, "$/"
    unless_null $P5630, vivify_2573
    new $P5630, "Undef"
  vivify_2573:
    $P5631 = "lexical_package_lookup"($P5629, $P5630)
.annotate 'line', 1983
    get_hll_global $P5632, "GLOBAL"
    nqp_get_package_through_who $P5633, $P5632, "PAST"
    get_who $P5634, $P5633
    set $P5635, $P5634["Var"]
    find_lex $P5636, "$name"
    unless_null $P5636, vivify_2574
    new $P5636, "Undef"
  vivify_2574:
    $P5637 = $P5635."new"($P5636 :named("name"), "lexical" :named("scope"))
    $P5638 = $P5627."new"($P5631, $P5637, "bind" :named("pasttype"))
.annotate 'line', 1980
    $P5623."push"($P5638)
  if_5605_end:
.annotate 'line', 1972
    goto if_5531_end
  if_5531:
.annotate 'line', 1954
    .const 'Sub' $P5538 = "545_1306916577.75068" 
    capture_lex $P5538
    $P5538()
  if_5531_end:
    goto if_5418_end
  if_5418:
.annotate 'line', 1903
    .const 'Sub' $P5425 = "542_1306916577.75068" 
    capture_lex $P5425
    $P5425()
  if_5418_end:
.annotate 'line', 1987
    get_hll_global $P5639, "GLOBAL"
    nqp_get_package_through_who $P5640, $P5639, "PAST"
    get_who $P5641, $P5640
    set $P5642, $P5641["Var"]
    find_lex $P5643, "$name"
    unless_null $P5643, vivify_2632
    new $P5643, "Undef"
  vivify_2632:
    $P5644 = $P5642."new"($P5643 :named("name"))
    store_lex "$past", $P5644
  if_5398_end:
.annotate 'line', 1994
    find_lex $P5655, "$name"
    unless_null $P5655, vivify_2633
    new $P5655, "Undef"
  vivify_2633:
    set $S5656, $P5655
    iseq $I5657, $S5656, "MAIN"
    if $I5657, if_5654
    new $P5653, 'Integer'
    set $P5653, $I5657
    goto if_5654_end
  if_5654:
    find_dynamic_lex $P5660, "$*MULTINESS"
    unless_null $P5660, vivify_2634
    get_hll_global $P5658, "GLOBAL"
    get_who $P5659, $P5658
    set $P5660, $P5659["$MULTINESS"]
    unless_null $P5660, vivify_2635
    die "Contextual $*MULTINESS not found"
  vivify_2635:
  vivify_2634:
    set $S5661, $P5660
    isne $I5662, $S5661, "multi"
    new $P5653, 'Integer'
    set $P5653, $I5662
  if_5654_end:
    if $P5653, if_5652
    set $P5651, $P5653
    goto if_5652_end
  if_5652:
.annotate 'line', 1995
    find_lex $P5663, "$block"
    unless_null $P5663, vivify_2636
    new $P5663, "Undef"
  vivify_2636:
    store_dynamic_lex "$*MAIN_SUB", $P5663
.annotate 'line', 1994
    set $P5651, $P5663
  if_5652_end:
.annotate 'line', 1899
    .return ($P5651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5537"  :anon :subid("545_1306916577.75068") :outer("541_1306916577.75068")
.annotate 'line', 1959
    new $P5539, "Undef"
    .lex "$cholder", $P5539
.annotate 'line', 1958
    find_dynamic_lex $P5543, "$*SCOPE"
    unless_null $P5543, vivify_2575
    get_hll_global $P5541, "GLOBAL"
    get_who $P5542, $P5541
    set $P5543, $P5542["$SCOPE"]
    unless_null $P5543, vivify_2576
    die "Contextual $*SCOPE not found"
  vivify_2576:
  vivify_2575:
    set $S5544, $P5543
    iseq $I5545, $S5544, "our"
    unless $I5545, if_5540_end
    die "our-scoped protos not yet implemented"
  if_5540_end:
.annotate 'line', 1959
    get_hll_global $P5546, "GLOBAL"
    nqp_get_package_through_who $P5547, $P5546, "PAST"
    get_who $P5548, $P5547
    set $P5549, $P5548["Op"]
    $P5550 = $P5549."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5550
.annotate 'line', 1960
    find_lex $P5551, "$?PACKAGE"
    get_who $P5552, $P5551
    set $P5553, $P5552["@BLOCK"]
    unless_null $P5553, vivify_2577
    $P5553 = root_new ['parrot';'ResizablePMCArray']
  vivify_2577:
    set $P5554, $P5553[0]
    unless_null $P5554, vivify_2578
    $P5554 = root_new ['parrot';'ResizablePMCArray']
  vivify_2578:
    set $P5555, $P5554[0]
    unless_null $P5555, vivify_2579
    new $P5555, "Undef"
  vivify_2579:
    get_hll_global $P5556, "GLOBAL"
    nqp_get_package_through_who $P5557, $P5556, "PAST"
    get_who $P5558, $P5557
    set $P5559, $P5558["Var"]
    find_lex $P5560, "$name"
    unless_null $P5560, vivify_2580
    new $P5560, "Undef"
  vivify_2580:
    find_lex $P5561, "$past"
    unless_null $P5561, vivify_2581
    new $P5561, "Undef"
  vivify_2581:
    $P5562 = $P5559."new"($P5560 :named("name"), 1 :named("isdecl"), $P5561 :named("viviself"), "lexical" :named("scope"))
    $P5555."push"($P5562)
.annotate 'line', 1962
    find_lex $P5563, "$?PACKAGE"
    get_who $P5564, $P5563
    set $P5565, $P5564["@BLOCK"]
    unless_null $P5565, vivify_2582
    $P5565 = root_new ['parrot';'ResizablePMCArray']
  vivify_2582:
    set $P5566, $P5565[0]
    unless_null $P5566, vivify_2583
    $P5566 = root_new ['parrot';'ResizablePMCArray']
  vivify_2583:
    set $P5567, $P5566[0]
    unless_null $P5567, vivify_2584
    new $P5567, "Undef"
  vivify_2584:
    get_hll_global $P5568, "GLOBAL"
    nqp_get_package_through_who $P5569, $P5568, "PAST"
    get_who $P5570, $P5569
    set $P5571, $P5570["Op"]
.annotate 'line', 1964
    get_hll_global $P5572, "GLOBAL"
    nqp_get_package_through_who $P5573, $P5572, "PAST"
    get_who $P5574, $P5573
    set $P5575, $P5574["Var"]
    find_lex $P5576, "$name"
    unless_null $P5576, vivify_2585
    new $P5576, "Undef"
  vivify_2585:
    $P5577 = $P5575."new"($P5576 :named("name"))
    find_lex $P5578, "$cholder"
    unless_null $P5578, vivify_2586
    new $P5578, "Undef"
  vivify_2586:
    $P5579 = $P5571."new"($P5577, $P5578, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1962
    $P5567."push"($P5579)
.annotate 'line', 1967
    find_lex $P5580, "$?PACKAGE"
    get_who $P5581, $P5580
    set $P5582, $P5581["@BLOCK"]
    unless_null $P5582, vivify_2587
    $P5582 = root_new ['parrot';'ResizablePMCArray']
  vivify_2587:
    set $P5583, $P5582[0]
    unless_null $P5583, vivify_2588
    new $P5583, "Undef"
  vivify_2588:
    find_lex $P5584, "$name"
    unless_null $P5584, vivify_2589
    new $P5584, "Undef"
  vivify_2589:
    find_lex $P5585, "$cholder"
    unless_null $P5585, vivify_2590
    new $P5585, "Undef"
  vivify_2590:
    $P5583."symbol"($P5584, "lexical" :named("scope"), 1 :named("proto"), $P5585 :named("cholder"))
.annotate 'line', 1970
    find_lex $P5586, "$past"
    unless_null $P5586, vivify_2591
    new $P5586, "Undef"
  vivify_2591:
    $P5587 = $P5586."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1954
    .return ($P5587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5424"  :anon :subid("542_1306916577.75068") :outer("541_1306916577.75068")
.annotate 'line', 1903
    .const 'Sub' $P5447 = "543_1306916577.75068" 
    capture_lex $P5447
.annotate 'line', 1906
    new $P5426, "Undef"
    .lex "$cholder", $P5426
.annotate 'line', 1907
    $P5427 = root_new ['parrot';'Hash']
    .lex "%sym", $P5427
.annotate 'line', 1905
    find_dynamic_lex $P5431, "$*SCOPE"
    unless_null $P5431, vivify_2592
    get_hll_global $P5429, "GLOBAL"
    get_who $P5430, $P5429
    set $P5431, $P5430["$SCOPE"]
    unless_null $P5431, vivify_2593
    die "Contextual $*SCOPE not found"
  vivify_2593:
  vivify_2592:
    set $S5432, $P5431
    iseq $I5433, $S5432, "our"
    unless $I5433, if_5428_end
    die "our-scoped multis not yet implemented"
  if_5428_end:
    find_lex $P5434, "$cholder"
    unless_null $P5434, vivify_2594
    new $P5434, "Undef"
  vivify_2594:
.annotate 'line', 1907
    find_lex $P5435, "$?PACKAGE"
    get_who $P5436, $P5435
    set $P5437, $P5436["@BLOCK"]
    unless_null $P5437, vivify_2595
    $P5437 = root_new ['parrot';'ResizablePMCArray']
  vivify_2595:
    set $P5438, $P5437[0]
    unless_null $P5438, vivify_2596
    new $P5438, "Undef"
  vivify_2596:
    find_lex $P5439, "$name"
    unless_null $P5439, vivify_2597
    new $P5439, "Undef"
  vivify_2597:
    $P5440 = $P5438."symbol"($P5439)
    store_lex "%sym", $P5440
.annotate 'line', 1908
    find_lex $P5442, "%sym"
    unless_null $P5442, vivify_2598
    $P5442 = root_new ['parrot';'Hash']
  vivify_2598:
    set $P5443, $P5442["cholder"]
    unless_null $P5443, vivify_2599
    new $P5443, "Undef"
  vivify_2599:
    if $P5443, if_5441
.annotate 'line', 1913
    .const 'Sub' $P5447 = "543_1306916577.75068" 
    capture_lex $P5447
    $P5447()
    goto if_5441_end
  if_5441:
.annotate 'line', 1909
    find_lex $P5444, "%sym"
    unless_null $P5444, vivify_2627
    $P5444 = root_new ['parrot';'Hash']
  vivify_2627:
    set $P5445, $P5444["cholder"]
    unless_null $P5445, vivify_2628
    new $P5445, "Undef"
  vivify_2628:
    store_lex "$cholder", $P5445
  if_5441_end:
.annotate 'line', 1949
    find_lex $P5527, "$cholder"
    unless_null $P5527, vivify_2629
    new $P5527, "Undef"
  vivify_2629:
    find_lex $P5528, "$past"
    unless_null $P5528, vivify_2630
    new $P5528, "Undef"
  vivify_2630:
    $P5527."push"($P5528)
.annotate 'line', 1952
    find_lex $P5529, "$past"
    unless_null $P5529, vivify_2631
    new $P5529, "Undef"
  vivify_2631:
    $P5530 = "attach_multi_signature"($P5529)
.annotate 'line', 1903
    .return ($P5530)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5446"  :anon :subid("543_1306916577.75068") :outer("542_1306916577.75068")
.annotate 'line', 1913
    .const 'Sub' $P5463 = "544_1306916577.75068" 
    capture_lex $P5463
.annotate 'line', 1920
    new $P5448, "Undef"
    .lex "$found_proto", $P5448
.annotate 'line', 1938
    new $P5449, "Undef"
    .lex "$dispatch_setup", $P5449
.annotate 'line', 1915
    find_lex $P5451, "%sym"
    unless_null $P5451, vivify_2600
    $P5451 = root_new ['parrot';'Hash']
  vivify_2600:
    set $P5452, $P5451["proto"]
    unless_null $P5452, vivify_2601
    new $P5452, "Undef"
  vivify_2601:
    unless $P5452, if_5450_end
.annotate 'line', 1918
    find_lex $P5453, "$/"
    unless_null $P5453, vivify_2602
    new $P5453, "Undef"
  vivify_2602:
    $P5454 = $P5453."CURSOR"()
    $P5454."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5450_end:
.annotate 'line', 1915
    find_lex $P5455, "$found_proto"
    unless_null $P5455, vivify_2603
    new $P5455, "Undef"
  vivify_2603:
.annotate 'line', 1921
    find_lex $P5457, "$?PACKAGE"
    get_who $P5458, $P5457
    set $P5459, $P5458["@BLOCK"]
    unless_null $P5459, vivify_2604
    $P5459 = root_new ['parrot';'ResizablePMCArray']
  vivify_2604:
    defined $I5460, $P5459
    unless $I5460, for_undef_2605
    iter $P5456, $P5459
    new $P5485, 'ExceptionHandler'
    set_label $P5485, loop5484_handler
    $P5485."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5485
  loop5484_test:
    unless $P5456, loop5484_done
    shift $P5461, $P5456
  loop5484_redo:
    .const 'Sub' $P5463 = "544_1306916577.75068" 
    capture_lex $P5463
    $P5463($P5461)
  loop5484_next:
    goto loop5484_test
  loop5484_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5486, exception, 'type'
    eq $P5486, .CONTROL_LOOP_NEXT, loop5484_next
    eq $P5486, .CONTROL_LOOP_REDO, loop5484_redo
  loop5484_done:
    pop_eh 
  for_undef_2605:
.annotate 'line', 1932
    find_lex $P5488, "$found_proto"
    unless_null $P5488, vivify_2614
    new $P5488, "Undef"
  vivify_2614:
    if $P5488, unless_5487_end
.annotate 'line', 1933
    find_lex $P5489, "$/"
    unless_null $P5489, vivify_2615
    new $P5489, "Undef"
  vivify_2615:
    $P5490 = $P5489."CURSOR"()
    $P5490."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5487_end:
.annotate 'line', 1937
    get_hll_global $P5491, "GLOBAL"
    nqp_get_package_through_who $P5492, $P5491, "PAST"
    get_who $P5493, $P5492
    set $P5494, $P5493["Op"]
    $P5495 = $P5494."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5495
.annotate 'line', 1938
    get_hll_global $P5496, "GLOBAL"
    nqp_get_package_through_who $P5497, $P5496, "PAST"
    get_who $P5498, $P5497
    set $P5499, $P5498["Op"]
.annotate 'line', 1940
    get_hll_global $P5500, "GLOBAL"
    nqp_get_package_through_who $P5501, $P5500, "PAST"
    get_who $P5502, $P5501
    set $P5503, $P5502["Var"]
    find_lex $P5504, "$name"
    unless_null $P5504, vivify_2616
    new $P5504, "Undef"
  vivify_2616:
    $P5505 = $P5503."new"($P5504 :named("name"), "outer" :named("scope"))
    find_lex $P5506, "$cholder"
    unless_null $P5506, vivify_2617
    new $P5506, "Undef"
  vivify_2617:
    $P5507 = $P5499."new"($P5505, $P5506, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1938
    store_lex "$dispatch_setup", $P5507
.annotate 'line', 1943
    find_lex $P5508, "$?PACKAGE"
    get_who $P5509, $P5508
    set $P5510, $P5509["@BLOCK"]
    unless_null $P5510, vivify_2618
    $P5510 = root_new ['parrot';'ResizablePMCArray']
  vivify_2618:
    set $P5511, $P5510[0]
    unless_null $P5511, vivify_2619
    $P5511 = root_new ['parrot';'ResizablePMCArray']
  vivify_2619:
    set $P5512, $P5511[0]
    unless_null $P5512, vivify_2620
    new $P5512, "Undef"
  vivify_2620:
    get_hll_global $P5513, "GLOBAL"
    nqp_get_package_through_who $P5514, $P5513, "PAST"
    get_who $P5515, $P5514
    set $P5516, $P5515["Var"]
    find_lex $P5517, "$name"
    unless_null $P5517, vivify_2621
    new $P5517, "Undef"
  vivify_2621:
    find_lex $P5518, "$dispatch_setup"
    unless_null $P5518, vivify_2622
    new $P5518, "Undef"
  vivify_2622:
    $P5519 = $P5516."new"($P5517 :named("name"), 1 :named("isdecl"), $P5518 :named("viviself"), "lexical" :named("scope"))
    $P5512."push"($P5519)
.annotate 'line', 1945
    find_lex $P5520, "$?PACKAGE"
    get_who $P5521, $P5520
    set $P5522, $P5521["@BLOCK"]
    unless_null $P5522, vivify_2623
    $P5522 = root_new ['parrot';'ResizablePMCArray']
  vivify_2623:
    set $P5523, $P5522[0]
    unless_null $P5523, vivify_2624
    new $P5523, "Undef"
  vivify_2624:
    find_lex $P5524, "$name"
    unless_null $P5524, vivify_2625
    new $P5524, "Undef"
  vivify_2625:
    find_lex $P5525, "$cholder"
    unless_null $P5525, vivify_2626
    new $P5525, "Undef"
  vivify_2626:
    $P5526 = $P5523."symbol"($P5524, "lexical" :named("scope"), $P5525 :named("cholder"))
.annotate 'line', 1913
    .return ($P5526)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5462"  :anon :subid("544_1306916577.75068") :outer("543_1306916577.75068")
    .param pmc param_5465
.annotate 'line', 1922
    $P5464 = root_new ['parrot';'Hash']
    .lex "%sym", $P5464
    .lex "$_", param_5465
    find_lex $P5466, "$_"
    unless_null $P5466, vivify_2606
    new $P5466, "Undef"
  vivify_2606:
    find_lex $P5467, "$name"
    unless_null $P5467, vivify_2607
    new $P5467, "Undef"
  vivify_2607:
    $P5468 = $P5466."symbol"($P5467)
    store_lex "%sym", $P5468
.annotate 'line', 1923
    find_lex $P5473, "%sym"
    unless_null $P5473, vivify_2608
    $P5473 = root_new ['parrot';'Hash']
  vivify_2608:
    set $P5474, $P5473["proto"]
    unless_null $P5474, vivify_2609
    new $P5474, "Undef"
  vivify_2609:
    unless $P5474, unless_5472
    set $P5471, $P5474
    goto unless_5472_end
  unless_5472:
    find_lex $P5475, "%sym"
    unless_null $P5475, vivify_2610
    $P5475 = root_new ['parrot';'Hash']
  vivify_2610:
    set $P5476, $P5475["cholder"]
    unless_null $P5476, vivify_2611
    new $P5476, "Undef"
  vivify_2611:
    set $P5471, $P5476
  unless_5472_end:
    if $P5471, if_5470
.annotate 'line', 1926
    find_lex $P5480, "%sym"
    unless_null $P5480, vivify_2612
    $P5480 = root_new ['parrot';'Hash']
  vivify_2612:
    if $P5480, if_5479
    set $P5478, $P5480
    goto if_5479_end
  if_5479:
.annotate 'line', 1927
    find_lex $P5481, "$/"
    unless_null $P5481, vivify_2613
    new $P5481, "Undef"
  vivify_2613:
    $P5482 = $P5481."CURSOR"()
    $P5483 = $P5482."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1926
    set $P5478, $P5483
  if_5479_end:
    set $P5469, $P5478
.annotate 'line', 1923
    goto if_5470_end
  if_5470:
.annotate 'line', 1924
    new $P5477, "Integer"
    assign $P5477, 1
    store_lex "$found_proto", $P5477
.annotate 'line', 1923
    set $P5469, $P5477
  if_5470_end:
.annotate 'line', 1921
    .return ($P5469)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5674"  :anon :subid("546_1306916577.75068") :outer("540_1306916577.75068")
    .param pmc param_5676
.annotate 'line', 2002
    .lex "$_", param_5676
    find_lex $P5677, "$_"
    unless_null $P5677, vivify_2644
    new $P5677, "Undef"
  vivify_2644:
    $P5678 = $P5677."ast"()
    find_lex $P5679, "$/"
    unless_null $P5679, vivify_2645
    new $P5679, "Undef"
  vivify_2645:
    $P5680 = $P5678($P5679)
    .return ($P5680)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def" :anon :subid("547_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5688
    .param pmc param_5689
.annotate 'line', 2009
    .const 'Sub' $P5818 = "549_1306916577.75068" 
    capture_lex $P5818
    .const 'Sub' $P5727 = "548_1306916577.75068" 
    capture_lex $P5727
    .lex "self", param_5688
    .lex "$/", param_5689
.annotate 'line', 2012
    new $P5690, "Undef"
    .lex "$past", $P5690
.annotate 'line', 2009
    find_lex $P5691, "$past"
    unless_null $P5691, vivify_2647
    new $P5691, "Undef"
  vivify_2647:
.annotate 'line', 2013
    find_lex $P5693, "$/"
    unless_null $P5693, vivify_2648
    $P5693 = root_new ['parrot';'Hash']
  vivify_2648:
    set $P5694, $P5693["onlystar"]
    unless_null $P5694, vivify_2649
    new $P5694, "Undef"
  vivify_2649:
    if $P5694, if_5692
.annotate 'line', 2017
    find_lex $P5696, "$/"
    unless_null $P5696, vivify_2650
    $P5696 = root_new ['parrot';'Hash']
  vivify_2650:
    set $P5697, $P5696["blockoid"]
    unless_null $P5697, vivify_2651
    new $P5697, "Undef"
  vivify_2651:
    $P5698 = $P5697."ast"()
    store_lex "$past", $P5698
.annotate 'line', 2018
    find_lex $P5699, "$past"
    unless_null $P5699, vivify_2652
    new $P5699, "Undef"
  vivify_2652:
    $P5699."blocktype"("declaration")
.annotate 'line', 2019
    find_dynamic_lex $P5703, "$*RETURN_USED"
    unless_null $P5703, vivify_2653
    get_hll_global $P5701, "GLOBAL"
    get_who $P5702, $P5701
    set $P5703, $P5702["$RETURN_USED"]
    unless_null $P5703, vivify_2654
    die "Contextual $*RETURN_USED not found"
  vivify_2654:
  vivify_2653:
    unless $P5703, if_5700_end
.annotate 'line', 2020
    find_lex $P5704, "$past"
    unless_null $P5704, vivify_2655
    new $P5704, "Undef"
  vivify_2655:
    $P5704."control"("return_pir")
  if_5700_end:
.annotate 'line', 2016
    goto if_5692_end
  if_5692:
.annotate 'line', 2014
    $P5695 = "only_star_block"()
    store_lex "$past", $P5695
  if_5692_end:
.annotate 'line', 2025
    find_lex $P5706, "$past"
    unless_null $P5706, vivify_2656
    $P5706 = root_new ['parrot';'Hash']
  vivify_2656:
    set $P5707, $P5706["signature_has_invocant"]
    unless_null $P5707, vivify_2657
    new $P5707, "Undef"
  vivify_2657:
    if $P5707, unless_5705_end
.annotate 'line', 2026
    find_lex $P5708, "$past"
    unless_null $P5708, vivify_2658
    $P5708 = root_new ['parrot';'ResizablePMCArray']
  vivify_2658:
    set $P5709, $P5708[0]
    unless_null $P5709, vivify_2659
    new $P5709, "Undef"
  vivify_2659:
    get_hll_global $P5710, "GLOBAL"
    nqp_get_package_through_who $P5711, $P5710, "PAST"
    get_who $P5712, $P5711
    set $P5713, $P5712["Var"]
.annotate 'line', 2028
    find_dynamic_lex $P5716, "$*SC"
    unless_null $P5716, vivify_2660
    get_hll_global $P5714, "GLOBAL"
    get_who $P5715, $P5714
    set $P5716, $P5715["$SC"]
    unless_null $P5716, vivify_2661
    die "Contextual $*SC not found"
  vivify_2661:
  vivify_2660:
    find_dynamic_lex $P5719, "$*PACKAGE"
    unless_null $P5719, vivify_2662
    get_hll_global $P5717, "GLOBAL"
    get_who $P5718, $P5717
    set $P5719, $P5718["$PACKAGE"]
    unless_null $P5719, vivify_2663
    die "Contextual $*PACKAGE not found"
  vivify_2663:
  vivify_2662:
    $P5720 = $P5716."get_object_sc_ref_past"($P5719)
    $P5721 = $P5713."new"("self" :named("name"), "parameter" :named("scope"), $P5720 :named("multitype"))
.annotate 'line', 2026
    $P5709."unshift"($P5721)
  unless_5705_end:
.annotate 'line', 2031
    find_lex $P5722, "$past"
    unless_null $P5722, vivify_2664
    new $P5722, "Undef"
  vivify_2664:
    $P5722."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 2034
    find_lex $P5724, "$/"
    unless_null $P5724, vivify_2665
    $P5724 = root_new ['parrot';'Hash']
  vivify_2665:
    set $P5725, $P5724["deflongname"]
    unless_null $P5725, vivify_2666
    new $P5725, "Undef"
  vivify_2666:
    unless $P5725, if_5723_end
    .const 'Sub' $P5727 = "548_1306916577.75068" 
    capture_lex $P5727
    $P5727()
  if_5723_end:
.annotate 'line', 2061
    find_lex $P5804, "$/"
    find_lex $P5805, "$past"
    unless_null $P5805, vivify_2701
    new $P5805, "Undef"
  vivify_2701:
    $P5804."!make"($P5805)
.annotate 'line', 2062
    find_lex $P5806, "$past"
    unless_null $P5806, vivify_2702
    new $P5806, "Undef"
  vivify_2702:
    find_lex $P5807, "$past"
    unless_null $P5807, vivify_2703
    $P5807 = root_new ['parrot';'Hash']
    store_lex "$past", $P5807
  vivify_2703:
    set $P5807["block_past"], $P5806
.annotate 'line', 2063
    find_lex $P5810, "$/"
    unless_null $P5810, vivify_2704
    $P5810 = root_new ['parrot';'Hash']
  vivify_2704:
    set $P5811, $P5810["trait"]
    unless_null $P5811, vivify_2705
    new $P5811, "Undef"
  vivify_2705:
    if $P5811, if_5809
    set $P5808, $P5811
    goto if_5809_end
  if_5809:
.annotate 'line', 2064
    find_lex $P5813, "$/"
    unless_null $P5813, vivify_2706
    $P5813 = root_new ['parrot';'Hash']
  vivify_2706:
    set $P5814, $P5813["trait"]
    unless_null $P5814, vivify_2707
    new $P5814, "Undef"
  vivify_2707:
    defined $I5815, $P5814
    unless $I5815, for_undef_2708
    iter $P5812, $P5814
    new $P5825, 'ExceptionHandler'
    set_label $P5825, loop5824_handler
    $P5825."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5825
  loop5824_test:
    unless $P5812, loop5824_done
    shift $P5816, $P5812
  loop5824_redo:
    .const 'Sub' $P5818 = "549_1306916577.75068" 
    capture_lex $P5818
    $P5818($P5816)
  loop5824_next:
    goto loop5824_test
  loop5824_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5826, exception, 'type'
    eq $P5826, .CONTROL_LOOP_NEXT, loop5824_next
    eq $P5826, .CONTROL_LOOP_REDO, loop5824_redo
  loop5824_done:
    pop_eh 
  for_undef_2708:
.annotate 'line', 2063
    set $P5808, $P5812
  if_5809_end:
.annotate 'line', 2009
    .return ($P5808)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5726"  :anon :subid("548_1306916577.75068") :outer("547_1306916577.75068")
.annotate 'line', 2036
    new $P5728, "Undef"
    .lex "$name", $P5728
.annotate 'line', 2044
    new $P5729, "Undef"
    .lex "$meta_meth", $P5729
.annotate 'line', 2045
    new $P5730, "Undef"
    .lex "$is_dispatcher", $P5730
.annotate 'line', 2036
    find_lex $P5731, "$/"
    unless_null $P5731, vivify_2667
    $P5731 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P5732, $P5731["private"]
    unless_null $P5732, vivify_2668
    new $P5732, "Undef"
  vivify_2668:
    set $S5733, $P5732
    new $P5734, 'String'
    set $P5734, $S5733
    find_lex $P5735, "$/"
    unless_null $P5735, vivify_2669
    $P5735 = root_new ['parrot';'Hash']
  vivify_2669:
    set $P5736, $P5735["deflongname"]
    unless_null $P5736, vivify_2670
    $P5736 = root_new ['parrot';'ResizablePMCArray']
  vivify_2670:
    set $P5737, $P5736[0]
    unless_null $P5737, vivify_2671
    new $P5737, "Undef"
  vivify_2671:
    $P5738 = $P5737."ast"()
    set $S5739, $P5738
    concat $P5740, $P5734, $S5739
    store_lex "$name", $P5740
.annotate 'line', 2037
    find_lex $P5741, "$past"
    unless_null $P5741, vivify_2672
    new $P5741, "Undef"
  vivify_2672:
    find_lex $P5742, "$name"
    unless_null $P5742, vivify_2673
    new $P5742, "Undef"
  vivify_2673:
    $P5741."name"($P5742)
.annotate 'line', 2041
    find_dynamic_lex $P5746, "$*MULTINESS"
    unless_null $P5746, vivify_2674
    get_hll_global $P5744, "GLOBAL"
    get_who $P5745, $P5744
    set $P5746, $P5745["$MULTINESS"]
    unless_null $P5746, vivify_2675
    die "Contextual $*MULTINESS not found"
  vivify_2675:
  vivify_2674:
    set $S5747, $P5746
    iseq $I5748, $S5747, "multi"
    unless $I5748, if_5743_end
    find_lex $P5749, "$past"
    unless_null $P5749, vivify_2676
    new $P5749, "Undef"
  vivify_2676:
    "attach_multi_signature"($P5749)
  if_5743_end:
.annotate 'line', 2044
    find_dynamic_lex $P5754, "$*MULTINESS"
    unless_null $P5754, vivify_2677
    get_hll_global $P5752, "GLOBAL"
    get_who $P5753, $P5752
    set $P5754, $P5753["$MULTINESS"]
    unless_null $P5754, vivify_2678
    die "Contextual $*MULTINESS not found"
  vivify_2678:
  vivify_2677:
    set $S5755, $P5754
    iseq $I5756, $S5755, "multi"
    if $I5756, if_5751
    new $P5758, "String"
    assign $P5758, "add_method"
    set $P5750, $P5758
    goto if_5751_end
  if_5751:
    new $P5757, "String"
    assign $P5757, "add_multi_method"
    set $P5750, $P5757
  if_5751_end:
    store_lex "$meta_meth", $P5750
.annotate 'line', 2045
    find_dynamic_lex $P5761, "$*MULTINESS"
    unless_null $P5761, vivify_2679
    get_hll_global $P5759, "GLOBAL"
    get_who $P5760, $P5759
    set $P5761, $P5760["$MULTINESS"]
    unless_null $P5761, vivify_2680
    die "Contextual $*MULTINESS not found"
  vivify_2680:
  vivify_2679:
    set $S5762, $P5761
    iseq $I5763, $S5762, "proto"
    new $P5764, 'Integer'
    set $P5764, $I5763
    store_lex "$is_dispatcher", $P5764
.annotate 'line', 2046
    find_dynamic_lex $P5767, "$*SC"
    unless_null $P5767, vivify_2681
    get_hll_global $P5765, "GLOBAL"
    get_who $P5766, $P5765
    set $P5767, $P5766["$SC"]
    unless_null $P5767, vivify_2682
    die "Contextual $*SC not found"
  vivify_2682:
  vivify_2681:
    find_dynamic_lex $P5770, "$*PACKAGE"
    unless_null $P5770, vivify_2683
    get_hll_global $P5768, "GLOBAL"
    get_who $P5769, $P5768
    set $P5770, $P5769["$PACKAGE"]
    unless_null $P5770, vivify_2684
    die "Contextual $*PACKAGE not found"
  vivify_2684:
  vivify_2683:
    find_lex $P5771, "$meta_meth"
    unless_null $P5771, vivify_2685
    new $P5771, "Undef"
  vivify_2685:
    find_lex $P5772, "$name"
    unless_null $P5772, vivify_2686
    new $P5772, "Undef"
  vivify_2686:
    find_lex $P5773, "$past"
    unless_null $P5773, vivify_2687
    new $P5773, "Undef"
  vivify_2687:
    find_lex $P5774, "$is_dispatcher"
    unless_null $P5774, vivify_2688
    new $P5774, "Undef"
  vivify_2688:
    $P5767."pkg_add_method"($P5770, $P5771, $P5772, $P5773, $P5774)
.annotate 'line', 2049
    find_dynamic_lex $P5779, "$*SCOPE"
    unless_null $P5779, vivify_2689
    get_hll_global $P5777, "GLOBAL"
    get_who $P5778, $P5777
    set $P5779, $P5778["$SCOPE"]
    unless_null $P5779, vivify_2690
    die "Contextual $*SCOPE not found"
  vivify_2690:
  vivify_2689:
    set $S5780, $P5779
    iseq $I5781, $S5780, "our"
    if $I5781, if_5776
.annotate 'line', 2052
    find_lex $P5793, "$past"
    unless_null $P5793, vivify_2691
    new $P5793, "Undef"
  vivify_2691:
    $P5794 = $P5793."pirflags"()
    if $P5794, if_5792
.annotate 'line', 2055
    find_lex $P5802, "$past"
    unless_null $P5802, vivify_2692
    new $P5802, "Undef"
  vivify_2692:
    $P5803 = $P5802."pirflags"(":anon")
.annotate 'line', 2054
    set $P5791, $P5803
.annotate 'line', 2052
    goto if_5792_end
  if_5792:
.annotate 'line', 2053
    find_lex $P5795, "$past"
    unless_null $P5795, vivify_2693
    new $P5795, "Undef"
  vivify_2693:
    find_lex $P5796, "$past"
    unless_null $P5796, vivify_2694
    new $P5796, "Undef"
  vivify_2694:
    $P5797 = $P5796."pirflags"()
    set $S5798, $P5797
    new $P5799, 'String'
    set $P5799, $S5798
    concat $P5800, $P5799, ":anon"
    $P5801 = $P5795."pirflags"($P5800)
.annotate 'line', 2052
    set $P5791, $P5801
  if_5792_end:
.annotate 'line', 2051
    set $P5775, $P5791
.annotate 'line', 2049
    goto if_5776_end
  if_5776:
.annotate 'line', 2050
    find_dynamic_lex $P5784, "$*SC"
    unless_null $P5784, vivify_2695
    get_hll_global $P5782, "GLOBAL"
    get_who $P5783, $P5782
    set $P5784, $P5783["$SC"]
    unless_null $P5784, vivify_2696
    die "Contextual $*SC not found"
  vivify_2696:
  vivify_2695:
    find_dynamic_lex $P5787, "$*PACKAGE"
    unless_null $P5787, vivify_2697
    get_hll_global $P5785, "GLOBAL"
    get_who $P5786, $P5785
    set $P5787, $P5786["$PACKAGE"]
    unless_null $P5787, vivify_2698
    die "Contextual $*PACKAGE not found"
  vivify_2698:
  vivify_2697:
    find_lex $P5788, "$name"
    unless_null $P5788, vivify_2699
    new $P5788, "Undef"
  vivify_2699:
    find_lex $P5789, "$past"
    unless_null $P5789, vivify_2700
    new $P5789, "Undef"
  vivify_2700:
    $P5790 = $P5784."install_package_routine"($P5787, $P5788, $P5789)
.annotate 'line', 2049
    set $P5775, $P5790
  if_5776_end:
.annotate 'line', 2034
    .return ($P5775)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5817"  :anon :subid("549_1306916577.75068") :outer("547_1306916577.75068")
    .param pmc param_5819
.annotate 'line', 2064
    .lex "$_", param_5819
    find_lex $P5820, "$_"
    unless_null $P5820, vivify_2709
    new $P5820, "Undef"
  vivify_2709:
    $P5821 = $P5820."ast"()
    find_lex $P5822, "$/"
    unless_null $P5822, vivify_2710
    new $P5822, "Undef"
  vivify_2710:
    $P5823 = $P5821($P5822)
    .return ($P5823)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature" :anon :subid("550_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5830
    .param pmc param_5831
.annotate 'line', 2093
    .const 'Sub' $P5874 = "552_1306916577.75068" 
    capture_lex $P5874
    .const 'Sub' $P5842 = "551_1306916577.75068" 
    capture_lex $P5842
    .lex "self", param_5830
    .lex "$/", param_5831
.annotate 'line', 2094
    new $P5832, "Undef"
    .lex "$BLOCKINIT", $P5832
    find_lex $P5833, "$?PACKAGE"
    get_who $P5834, $P5833
    set $P5835, $P5834["@BLOCK"]
    unless_null $P5835, vivify_2711
    $P5835 = root_new ['parrot';'ResizablePMCArray']
  vivify_2711:
    set $P5836, $P5835[0]
    unless_null $P5836, vivify_2712
    $P5836 = root_new ['parrot';'ResizablePMCArray']
  vivify_2712:
    set $P5837, $P5836[0]
    unless_null $P5837, vivify_2713
    new $P5837, "Undef"
  vivify_2713:
    store_lex "$BLOCKINIT", $P5837
.annotate 'line', 2095
    find_lex $P5839, "$/"
    unless_null $P5839, vivify_2714
    $P5839 = root_new ['parrot';'Hash']
  vivify_2714:
    set $P5840, $P5839["invocant"]
    unless_null $P5840, vivify_2715
    new $P5840, "Undef"
  vivify_2715:
    unless $P5840, if_5838_end
    .const 'Sub' $P5842 = "551_1306916577.75068" 
    capture_lex $P5842
    $P5842()
  if_5838_end:
.annotate 'line', 2104
    find_lex $P5869, "$/"
    unless_null $P5869, vivify_2725
    $P5869 = root_new ['parrot';'Hash']
  vivify_2725:
    set $P5870, $P5869["parameter"]
    unless_null $P5870, vivify_2726
    new $P5870, "Undef"
  vivify_2726:
    defined $I5871, $P5870
    unless $I5871, for_undef_2727
    iter $P5868, $P5870
    new $P5881, 'ExceptionHandler'
    set_label $P5881, loop5880_handler
    $P5881."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5881
  loop5880_test:
    unless $P5868, loop5880_done
    shift $P5872, $P5868
  loop5880_redo:
    .const 'Sub' $P5874 = "552_1306916577.75068" 
    capture_lex $P5874
    $P5874($P5872)
  loop5880_next:
    goto loop5880_test
  loop5880_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5882, exception, 'type'
    eq $P5882, .CONTROL_LOOP_NEXT, loop5880_next
    eq $P5882, .CONTROL_LOOP_REDO, loop5880_redo
  loop5880_done:
    pop_eh 
  for_undef_2727:
.annotate 'line', 2093
    .return ($P5868)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5841"  :anon :subid("551_1306916577.75068") :outer("550_1306916577.75068")
.annotate 'line', 2096
    new $P5843, "Undef"
    .lex "$inv", $P5843
    find_lex $P5844, "$/"
    unless_null $P5844, vivify_2716
    $P5844 = root_new ['parrot';'Hash']
  vivify_2716:
    set $P5845, $P5844["invocant"]
    unless_null $P5845, vivify_2717
    $P5845 = root_new ['parrot';'ResizablePMCArray']
  vivify_2717:
    set $P5846, $P5845[0]
    unless_null $P5846, vivify_2718
    new $P5846, "Undef"
  vivify_2718:
    $P5847 = $P5846."ast"()
    store_lex "$inv", $P5847
.annotate 'line', 2097
    find_lex $P5848, "$BLOCKINIT"
    unless_null $P5848, vivify_2719
    new $P5848, "Undef"
  vivify_2719:
    find_lex $P5849, "$inv"
    unless_null $P5849, vivify_2720
    new $P5849, "Undef"
  vivify_2720:
    $P5848."push"($P5849)
.annotate 'line', 2098
    find_lex $P5850, "$BLOCKINIT"
    unless_null $P5850, vivify_2721
    new $P5850, "Undef"
  vivify_2721:
    get_hll_global $P5851, "GLOBAL"
    nqp_get_package_through_who $P5852, $P5851, "PAST"
    get_who $P5853, $P5852
    set $P5854, $P5853["Var"]
.annotate 'line', 2100
    get_hll_global $P5855, "GLOBAL"
    nqp_get_package_through_who $P5856, $P5855, "PAST"
    get_who $P5857, $P5856
    set $P5858, $P5857["Var"]
    find_lex $P5859, "$inv"
    unless_null $P5859, vivify_2722
    new $P5859, "Undef"
  vivify_2722:
    $P5860 = $P5859."name"()
    $P5861 = $P5858."new"("lexical" :named("scope"), $P5860 :named("name"))
    $P5862 = $P5854."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5861 :named("viviself"))
.annotate 'line', 2098
    $P5850."push"($P5862)
.annotate 'line', 2102
    new $P5863, "Integer"
    assign $P5863, 1
    find_lex $P5864, "$?PACKAGE"
    get_who $P5865, $P5864
    set $P5866, $P5865["@BLOCK"]
    unless_null $P5866, vivify_2723
    $P5866 = root_new ['parrot';'ResizablePMCArray']
    set $P5865["@BLOCK"], $P5866
  vivify_2723:
    set $P5867, $P5866[0]
    unless_null $P5867, vivify_2724
    $P5867 = root_new ['parrot';'Hash']
    set $P5866[0], $P5867
  vivify_2724:
    set $P5867["signature_has_invocant"], $P5863
.annotate 'line', 2095
    .return ($P5863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5873"  :anon :subid("552_1306916577.75068") :outer("550_1306916577.75068")
    .param pmc param_5875
.annotate 'line', 2104
    .lex "$_", param_5875
    find_lex $P5876, "$BLOCKINIT"
    unless_null $P5876, vivify_2728
    new $P5876, "Undef"
  vivify_2728:
    find_lex $P5877, "$_"
    unless_null $P5877, vivify_2729
    new $P5877, "Undef"
  vivify_2729:
    $P5878 = $P5877."ast"()
    $P5879 = $P5876."push"($P5878)
    .return ($P5879)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter" :anon :subid("553_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5884
    .param pmc param_5885
.annotate 'line', 2107
    .lex "self", param_5884
    .lex "$/", param_5885
.annotate 'line', 2108
    new $P5886, "Undef"
    .lex "$quant", $P5886
.annotate 'line', 2109
    new $P5887, "Undef"
    .lex "$past", $P5887
.annotate 'line', 2108
    find_lex $P5888, "$/"
    unless_null $P5888, vivify_2730
    $P5888 = root_new ['parrot';'Hash']
  vivify_2730:
    set $P5889, $P5888["quant"]
    unless_null $P5889, vivify_2731
    new $P5889, "Undef"
  vivify_2731:
    store_lex "$quant", $P5889
    find_lex $P5890, "$past"
    unless_null $P5890, vivify_2732
    new $P5890, "Undef"
  vivify_2732:
.annotate 'line', 2110
    find_lex $P5892, "$/"
    unless_null $P5892, vivify_2733
    $P5892 = root_new ['parrot';'Hash']
  vivify_2733:
    set $P5893, $P5892["named_param"]
    unless_null $P5893, vivify_2734
    new $P5893, "Undef"
  vivify_2734:
    if $P5893, if_5891
.annotate 'line', 2117
    find_lex $P5907, "$/"
    unless_null $P5907, vivify_2735
    $P5907 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P5908, $P5907["param_var"]
    unless_null $P5908, vivify_2736
    new $P5908, "Undef"
  vivify_2736:
    $P5909 = $P5908."ast"()
    store_lex "$past", $P5909
.annotate 'line', 2118
    find_lex $P5911, "$quant"
    unless_null $P5911, vivify_2737
    new $P5911, "Undef"
  vivify_2737:
    set $S5912, $P5911
    iseq $I5913, $S5912, "*"
    if $I5913, if_5910
.annotate 'line', 2122
    find_lex $P5922, "$quant"
    unless_null $P5922, vivify_2738
    new $P5922, "Undef"
  vivify_2738:
    set $S5923, $P5922
    iseq $I5924, $S5923, "?"
    unless $I5924, if_5921_end
.annotate 'line', 2123
    find_lex $P5925, "$past"
    unless_null $P5925, vivify_2739
    new $P5925, "Undef"
  vivify_2739:
    find_lex $P5926, "$/"
    unless_null $P5926, vivify_2740
    $P5926 = root_new ['parrot';'Hash']
  vivify_2740:
    set $P5927, $P5926["param_var"]
    unless_null $P5927, vivify_2741
    $P5927 = root_new ['parrot';'Hash']
  vivify_2741:
    set $P5928, $P5927["sigil"]
    unless_null $P5928, vivify_2742
    new $P5928, "Undef"
  vivify_2742:
    $P5929 = "vivitype"($P5928)
    $P5925."viviself"($P5929)
  if_5921_end:
.annotate 'line', 2122
    goto if_5910_end
  if_5910:
.annotate 'line', 2119
    find_lex $P5914, "$past"
    unless_null $P5914, vivify_2743
    new $P5914, "Undef"
  vivify_2743:
    $P5914."slurpy"(1)
.annotate 'line', 2120
    find_lex $P5915, "$past"
    unless_null $P5915, vivify_2744
    new $P5915, "Undef"
  vivify_2744:
    find_lex $P5916, "$/"
    unless_null $P5916, vivify_2745
    $P5916 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P5917, $P5916["param_var"]
    unless_null $P5917, vivify_2746
    $P5917 = root_new ['parrot';'Hash']
  vivify_2746:
    set $P5918, $P5917["sigil"]
    unless_null $P5918, vivify_2747
    new $P5918, "Undef"
  vivify_2747:
    set $S5919, $P5918
    iseq $I5920, $S5919, "%"
    $P5915."named"($I5920)
  if_5910_end:
.annotate 'line', 2116
    goto if_5891_end
  if_5891:
.annotate 'line', 2111
    find_lex $P5894, "$/"
    unless_null $P5894, vivify_2748
    $P5894 = root_new ['parrot';'Hash']
  vivify_2748:
    set $P5895, $P5894["named_param"]
    unless_null $P5895, vivify_2749
    new $P5895, "Undef"
  vivify_2749:
    $P5896 = $P5895."ast"()
    store_lex "$past", $P5896
.annotate 'line', 2112
    find_lex $P5898, "$quant"
    unless_null $P5898, vivify_2750
    new $P5898, "Undef"
  vivify_2750:
    set $S5899, $P5898
    isne $I5900, $S5899, "!"
    unless $I5900, if_5897_end
.annotate 'line', 2113
    find_lex $P5901, "$past"
    unless_null $P5901, vivify_2751
    new $P5901, "Undef"
  vivify_2751:
    find_lex $P5902, "$/"
    unless_null $P5902, vivify_2752
    $P5902 = root_new ['parrot';'Hash']
  vivify_2752:
    set $P5903, $P5902["named_param"]
    unless_null $P5903, vivify_2753
    $P5903 = root_new ['parrot';'Hash']
  vivify_2753:
    set $P5904, $P5903["param_var"]
    unless_null $P5904, vivify_2754
    $P5904 = root_new ['parrot';'Hash']
  vivify_2754:
    set $P5905, $P5904["sigil"]
    unless_null $P5905, vivify_2755
    new $P5905, "Undef"
  vivify_2755:
    $P5906 = "vivitype"($P5905)
    $P5901."viviself"($P5906)
  if_5897_end:
  if_5891_end:
.annotate 'line', 2126
    find_lex $P5931, "$/"
    unless_null $P5931, vivify_2756
    $P5931 = root_new ['parrot';'Hash']
  vivify_2756:
    set $P5932, $P5931["default_value"]
    unless_null $P5932, vivify_2757
    new $P5932, "Undef"
  vivify_2757:
    unless $P5932, if_5930_end
.annotate 'line', 2127
    find_lex $P5934, "$quant"
    unless_null $P5934, vivify_2758
    new $P5934, "Undef"
  vivify_2758:
    set $S5935, $P5934
    iseq $I5936, $S5935, "*"
    unless $I5936, if_5933_end
.annotate 'line', 2128
    find_lex $P5937, "$/"
    unless_null $P5937, vivify_2759
    new $P5937, "Undef"
  vivify_2759:
    $P5938 = $P5937."CURSOR"()
    $P5938."panic"("Can't put default on slurpy parameter")
  if_5933_end:
.annotate 'line', 2130
    find_lex $P5940, "$quant"
    unless_null $P5940, vivify_2760
    new $P5940, "Undef"
  vivify_2760:
    set $S5941, $P5940
    iseq $I5942, $S5941, "!"
    unless $I5942, if_5939_end
.annotate 'line', 2131
    find_lex $P5943, "$/"
    unless_null $P5943, vivify_2761
    new $P5943, "Undef"
  vivify_2761:
    $P5944 = $P5943."CURSOR"()
    $P5944."panic"("Can't put default on required parameter")
  if_5939_end:
.annotate 'line', 2133
    find_lex $P5945, "$past"
    unless_null $P5945, vivify_2762
    new $P5945, "Undef"
  vivify_2762:
    find_lex $P5946, "$/"
    unless_null $P5946, vivify_2763
    $P5946 = root_new ['parrot';'Hash']
  vivify_2763:
    set $P5947, $P5946["default_value"]
    unless_null $P5947, vivify_2764
    $P5947 = root_new ['parrot';'ResizablePMCArray']
  vivify_2764:
    set $P5948, $P5947[0]
    unless_null $P5948, vivify_2765
    $P5948 = root_new ['parrot';'Hash']
  vivify_2765:
    set $P5949, $P5948["EXPR"]
    unless_null $P5949, vivify_2766
    new $P5949, "Undef"
  vivify_2766:
    $P5950 = $P5949."ast"()
    $P5945."viviself"($P5950)
  if_5930_end:
.annotate 'line', 2135
    find_lex $P5952, "$past"
    unless_null $P5952, vivify_2767
    new $P5952, "Undef"
  vivify_2767:
    $P5953 = $P5952."viviself"()
    if $P5953, unless_5951_end
    find_lex $P5954, "$?PACKAGE"
    get_who $P5955, $P5954
    set $P5956, $P5955["@BLOCK"]
    unless_null $P5956, vivify_2768
    $P5956 = root_new ['parrot';'ResizablePMCArray']
  vivify_2768:
    set $P5957, $P5956[0]
    unless_null $P5957, vivify_2769
    new $P5957, "Undef"
  vivify_2769:
    find_lex $P5958, "$?PACKAGE"
    get_who $P5959, $P5958
    set $P5960, $P5959["@BLOCK"]
    unless_null $P5960, vivify_2770
    $P5960 = root_new ['parrot';'ResizablePMCArray']
  vivify_2770:
    set $P5961, $P5960[0]
    unless_null $P5961, vivify_2771
    new $P5961, "Undef"
  vivify_2771:
    $P5962 = $P5961."arity"()
    set $N5963, $P5962
    new $P5964, 'Float'
    set $P5964, $N5963
    add $P5965, $P5964, 1
    $P5957."arity"($P5965)
  unless_5951_end:
.annotate 'line', 2139
    find_lex $P5967, "$/"
    unless_null $P5967, vivify_2772
    $P5967 = root_new ['parrot';'Hash']
  vivify_2772:
    set $P5968, $P5967["typename"]
    unless_null $P5968, vivify_2773
    new $P5968, "Undef"
  vivify_2773:
    unless $P5968, if_5966_end
.annotate 'line', 2140
    find_lex $P5969, "$past"
    unless_null $P5969, vivify_2774
    new $P5969, "Undef"
  vivify_2774:
    find_lex $P5970, "$/"
    unless_null $P5970, vivify_2775
    $P5970 = root_new ['parrot';'Hash']
  vivify_2775:
    set $P5971, $P5970["typename"]
    unless_null $P5971, vivify_2776
    $P5971 = root_new ['parrot';'ResizablePMCArray']
  vivify_2776:
    set $P5972, $P5971[0]
    unless_null $P5972, vivify_2777
    new $P5972, "Undef"
  vivify_2777:
    $P5973 = $P5972."ast"()
    $P5969."multitype"($P5973)
  if_5966_end:
.annotate 'line', 2144
    find_lex $P5975, "$/"
    unless_null $P5975, vivify_2778
    $P5975 = root_new ['parrot';'Hash']
  vivify_2778:
    set $P5976, $P5975["definedness"]
    unless_null $P5976, vivify_2779
    new $P5976, "Undef"
  vivify_2779:
    unless $P5976, if_5974_end
.annotate 'line', 2145
    find_lex $P5977, "$/"
    unless_null $P5977, vivify_2780
    $P5977 = root_new ['parrot';'Hash']
  vivify_2780:
    set $P5978, $P5977["definedness"]
    unless_null $P5978, vivify_2781
    $P5978 = root_new ['parrot';'ResizablePMCArray']
  vivify_2781:
    set $P5979, $P5978[0]
    unless_null $P5979, vivify_2782
    new $P5979, "Undef"
  vivify_2782:
    set $S5980, $P5979
    new $P5981, 'String'
    set $P5981, $S5980
    find_lex $P5982, "$past"
    unless_null $P5982, vivify_2783
    $P5982 = root_new ['parrot';'Hash']
    store_lex "$past", $P5982
  vivify_2783:
    set $P5982["definedness"], $P5981
  if_5974_end:
.annotate 'line', 2148
    find_lex $P5983, "$/"
    find_lex $P5984, "$past"
    unless_null $P5984, vivify_2784
    new $P5984, "Undef"
  vivify_2784:
    $P5985 = $P5983."!make"($P5984)
.annotate 'line', 2107
    .return ($P5985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var" :anon :subid("554_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_5987
    .param pmc param_5988
.annotate 'line', 2151
    .lex "self", param_5987
    .lex "$/", param_5988
.annotate 'line', 2152
    new $P5989, "Undef"
    .lex "$name", $P5989
.annotate 'line', 2153
    new $P5990, "Undef"
    .lex "$past", $P5990
.annotate 'line', 2152
    find_lex $P5991, "$/"
    unless_null $P5991, vivify_2785
    new $P5991, "Undef"
  vivify_2785:
    set $S5992, $P5991
    new $P5993, 'String'
    set $P5993, $S5992
    store_lex "$name", $P5993
.annotate 'line', 2153
    get_hll_global $P5994, "GLOBAL"
    nqp_get_package_through_who $P5995, $P5994, "PAST"
    get_who $P5996, $P5995
    set $P5997, $P5996["Var"]
    find_lex $P5998, "$name"
    unless_null $P5998, vivify_2786
    new $P5998, "Undef"
  vivify_2786:
    find_lex $P5999, "$/"
    unless_null $P5999, vivify_2787
    new $P5999, "Undef"
  vivify_2787:
    $P6000 = $P5997."new"($P5998 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5999 :named("node"))
    store_lex "$past", $P6000
.annotate 'line', 2155
    find_lex $P6001, "$?PACKAGE"
    get_who $P6002, $P6001
    set $P6003, $P6002["@BLOCK"]
    unless_null $P6003, vivify_2788
    $P6003 = root_new ['parrot';'ResizablePMCArray']
  vivify_2788:
    set $P6004, $P6003[0]
    unless_null $P6004, vivify_2789
    new $P6004, "Undef"
  vivify_2789:
    find_lex $P6005, "$name"
    unless_null $P6005, vivify_2790
    new $P6005, "Undef"
  vivify_2790:
    $P6004."symbol"($P6005, "lexical" :named("scope"))
.annotate 'line', 2156
    find_lex $P6006, "$/"
    find_lex $P6007, "$past"
    unless_null $P6007, vivify_2791
    new $P6007, "Undef"
  vivify_2791:
    $P6008 = $P6006."!make"($P6007)
.annotate 'line', 2151
    .return ($P6008)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param" :anon :subid("555_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6010
    .param pmc param_6011
.annotate 'line', 2159
    .lex "self", param_6010
    .lex "$/", param_6011
.annotate 'line', 2160
    new $P6012, "Undef"
    .lex "$past", $P6012
    find_lex $P6013, "$/"
    unless_null $P6013, vivify_2792
    $P6013 = root_new ['parrot';'Hash']
  vivify_2792:
    set $P6014, $P6013["param_var"]
    unless_null $P6014, vivify_2793
    new $P6014, "Undef"
  vivify_2793:
    $P6015 = $P6014."ast"()
    store_lex "$past", $P6015
.annotate 'line', 2161
    find_lex $P6016, "$past"
    unless_null $P6016, vivify_2794
    new $P6016, "Undef"
  vivify_2794:
    find_lex $P6017, "$/"
    unless_null $P6017, vivify_2795
    $P6017 = root_new ['parrot';'Hash']
  vivify_2795:
    set $P6018, $P6017["param_var"]
    unless_null $P6018, vivify_2796
    $P6018 = root_new ['parrot';'Hash']
  vivify_2796:
    set $P6019, $P6018["name"]
    unless_null $P6019, vivify_2797
    new $P6019, "Undef"
  vivify_2797:
    set $S6020, $P6019
    $P6016."named"($S6020)
.annotate 'line', 2162
    find_lex $P6021, "$/"
    find_lex $P6022, "$past"
    unless_null $P6022, vivify_2798
    new $P6022, "Undef"
  vivify_2798:
    $P6023 = $P6021."!make"($P6022)
.annotate 'line', 2159
    .return ($P6023)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename" :anon :subid("556_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6025
    .param pmc param_6026
.annotate 'line', 2165
    .const 'Sub' $P6038 = "557_1306916577.75068" 
    capture_lex $P6038
    .lex "self", param_6025
    .lex "$/", param_6026
.annotate 'line', 2169
    $P6027 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P6027
.annotate 'line', 2170
    new $P6028, "Undef"
    .lex "$found", $P6028
.annotate 'line', 2169
    get_hll_global $P6029, "GLOBAL"
    nqp_get_package_through_who $P6030, $P6029, "HLL"
    get_who $P6031, $P6030
    set $P6032, $P6031["Compiler"]
    find_lex $P6033, "$/"
    unless_null $P6033, vivify_2799
    new $P6033, "Undef"
  vivify_2799:
    set $S6034, $P6033
    $P6035 = $P6032."parse_name"($S6034)
    store_lex "@name", $P6035
.annotate 'line', 2170
    new $P6036, "Integer"
    assign $P6036, 0
    store_lex "$found", $P6036
.annotate 'line', 2171
    .const 'Sub' $P6038 = "557_1306916577.75068" 
    capture_lex $P6038
    $P6038()
.annotate 'line', 2176
    find_lex $P6059, "$found"
    unless_null $P6059, vivify_2805
    new $P6059, "Undef"
  vivify_2805:
    unless $P6059, unless_6058
    set $P6057, $P6059
    goto unless_6058_end
  unless_6058:
.annotate 'line', 2177
    find_lex $P6060, "$/"
    unless_null $P6060, vivify_2806
    new $P6060, "Undef"
  vivify_2806:
    $P6061 = $P6060."CURSOR"()
    new $P6062, "String"
    assign $P6062, "Use of undeclared type '"
    find_lex $P6063, "$/"
    unless_null $P6063, vivify_2807
    new $P6063, "Undef"
  vivify_2807:
    set $S6064, $P6063
    concat $P6065, $P6062, $S6064
    concat $P6066, $P6065, "'"
    $P6067 = $P6061."panic"($P6066)
.annotate 'line', 2176
    set $P6057, $P6067
  unless_6058_end:
.annotate 'line', 2165
    .return ($P6057)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6037"  :anon :subid("557_1306916577.75068") :outer("556_1306916577.75068")
.annotate 'line', 2171
    new $P6052, 'ExceptionHandler'
    set_label $P6052, control_6051
    $P6052."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P6052
.annotate 'line', 2172
    new $P6039, "Undef"
    .lex "$sym", $P6039
    find_lex $P6040, "@name"
    unless_null $P6040, vivify_2800
    $P6040 = root_new ['parrot';'ResizablePMCArray']
  vivify_2800:
    find_lex $P6041, "$/"
    unless_null $P6041, vivify_2801
    new $P6041, "Undef"
  vivify_2801:
    $P6042 = "find_sym"($P6040, $P6041)
    store_lex "$sym", $P6042
.annotate 'line', 2173
    find_dynamic_lex $P6043, "$/"
    find_dynamic_lex $P6046, "$*SC"
    unless_null $P6046, vivify_2802
    get_hll_global $P6044, "GLOBAL"
    get_who $P6045, $P6044
    set $P6046, $P6045["$SC"]
    unless_null $P6046, vivify_2803
    die "Contextual $*SC not found"
  vivify_2803:
  vivify_2802:
    find_lex $P6047, "$sym"
    unless_null $P6047, vivify_2804
    new $P6047, "Undef"
  vivify_2804:
    $P6048 = $P6046."get_object_sc_ref_past"($P6047)
    $P6043."!make"($P6048)
.annotate 'line', 2174
    new $P6049, "Integer"
    assign $P6049, 1
    store_lex "$found", $P6049
.annotate 'line', 2171
    pop_eh 
    goto skip_handler_6050
  control_6051:
    .local pmc exception 
    .get_results (exception) 
    new $P6055, 'Integer'
    set $P6055, 1
    set exception["handled"], $P6055
    set $I6056, exception["handled"]
    ne $I6056, 1, nothandled_6054
  handled_6053:
    .return (exception)
  nothandled_6054:
    rethrow exception
  skip_handler_6050:
    .return ($P6049)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait" :anon :subid("558_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6069
    .param pmc param_6070
.annotate 'line', 2181
    .lex "self", param_6069
    .lex "$/", param_6070
.annotate 'line', 2182
    find_lex $P6071, "$/"
    find_lex $P6072, "$/"
    unless_null $P6072, vivify_2808
    $P6072 = root_new ['parrot';'Hash']
  vivify_2808:
    set $P6073, $P6072["trait_mod"]
    unless_null $P6073, vivify_2809
    new $P6073, "Undef"
  vivify_2809:
    $P6074 = $P6073."ast"()
    $P6075 = $P6071."!make"($P6074)
.annotate 'line', 2181
    .return ($P6075)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>" :anon :subid("559_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6077
    .param pmc param_6078
.annotate 'line', 2185
    .const 'Sub' $P6139 = "562_1306916577.75068" 
    capture_lex $P6139
    .const 'Sub' $P6086 = "560_1306916577.75068" 
    capture_lex $P6086
    .lex "self", param_6077
    .lex "$/", param_6078
.annotate 'line', 2186
    find_lex $P6081, "$/"
    unless_null $P6081, vivify_2810
    $P6081 = root_new ['parrot';'Hash']
  vivify_2810:
    set $P6082, $P6081["longname"]
    unless_null $P6082, vivify_2811
    new $P6082, "Undef"
  vivify_2811:
    set $S6083, $P6082
    iseq $I6084, $S6083, "parrot_vtable"
    if $I6084, if_6080
.annotate 'line', 2199
    find_lex $P6134, "$/"
    unless_null $P6134, vivify_2812
    $P6134 = root_new ['parrot';'Hash']
  vivify_2812:
    set $P6135, $P6134["longname"]
    unless_null $P6135, vivify_2813
    new $P6135, "Undef"
  vivify_2813:
    set $S6136, $P6135
    iseq $I6137, $S6136, "parrot_vtable_handler"
    if $I6137, if_6133
.annotate 'line', 2210
    find_lex $P6179, "$/"
    unless_null $P6179, vivify_2814
    $P6179 = root_new ['parrot';'Hash']
  vivify_2814:
    set $P6180, $P6179["longname"]
    unless_null $P6180, vivify_2815
    new $P6180, "Undef"
  vivify_2815:
    set $S6181, $P6180
    iseq $I6182, $S6181, "pirflags"
    if $I6182, if_6178
.annotate 'line', 2214
    find_lex $P6186, "$/"
    unless_null $P6186, vivify_2816
    new $P6186, "Undef"
  vivify_2816:
    $P6187 = $P6186."CURSOR"()
    new $P6188, 'String'
    set $P6188, "Trait '"
    find_lex $P6189, "$/"
    unless_null $P6189, vivify_2817
    $P6189 = root_new ['parrot';'Hash']
  vivify_2817:
    set $P6190, $P6189["longname"]
    unless_null $P6190, vivify_2818
    new $P6190, "Undef"
  vivify_2818:
    concat $P6191, $P6188, $P6190
    concat $P6192, $P6191, "' not implemented"
    $P6193 = $P6187."panic"($P6192)
.annotate 'line', 2213
    set $P6177, $P6193
.annotate 'line', 2210
    goto if_6178_end
  if_6178:
.annotate 'line', 2211
    find_lex $P6183, "$/"
    unless_null $P6183, vivify_2819
    new $P6183, "Undef"
  vivify_2819:
    $P6184 = $P6183."CURSOR"()
    $P6185 = $P6184."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2210
    set $P6177, $P6185
  if_6178_end:
    set $P6132, $P6177
.annotate 'line', 2199
    goto if_6133_end
  if_6133:
    .const 'Sub' $P6139 = "562_1306916577.75068" 
    capture_lex $P6139
    $P6176 = $P6139()
    set $P6132, $P6176
  if_6133_end:
    set $P6079, $P6132
.annotate 'line', 2186
    goto if_6080_end
  if_6080:
    .const 'Sub' $P6086 = "560_1306916577.75068" 
    capture_lex $P6086
    $P6131 = $P6086()
    set $P6079, $P6131
  if_6080_end:
.annotate 'line', 2185
    .return ($P6079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6138"  :anon :subid("562_1306916577.75068") :outer("559_1306916577.75068")
.annotate 'line', 2199
    .const 'Sub' $P6163 = "563_1306916577.75068" 
    capture_lex $P6163
.annotate 'line', 2201
    new $P6140, "Undef"
    .lex "$cpast", $P6140
.annotate 'line', 2204
    new $P6141, "Undef"
    .lex "$name", $P6141
.annotate 'line', 2205
    new $P6142, "Undef"
    .lex "$package", $P6142
.annotate 'line', 2201
    find_lex $P6143, "$/"
    unless_null $P6143, vivify_2820
    $P6143 = root_new ['parrot';'Hash']
  vivify_2820:
    set $P6144, $P6143["circumfix"]
    unless_null $P6144, vivify_2821
    $P6144 = root_new ['parrot';'ResizablePMCArray']
  vivify_2821:
    set $P6145, $P6144[0]
    unless_null $P6145, vivify_2822
    new $P6145, "Undef"
  vivify_2822:
    $P6146 = $P6145."ast"()
    store_lex "$cpast", $P6146
.annotate 'line', 2203
    get_hll_global $P6148, "GLOBAL"
    nqp_get_package_through_who $P6149, $P6148, "PAST"
    get_who $P6150, $P6149
    set $P6151, $P6150["Val"]
    find_lex $P6152, "$cpast"
    unless_null $P6152, vivify_2823
    new $P6152, "Undef"
  vivify_2823:
    $P6153 = $P6151."ACCEPTS"($P6152)
    if $P6153, unless_6147_end
.annotate 'line', 2202
    find_lex $P6154, "$/"
    unless_null $P6154, vivify_2824
    new $P6154, "Undef"
  vivify_2824:
    $P6155 = $P6154."CURSOR"()
    $P6155."panic"("Trait 'parrot_vtable_handler' requires constant scalar argument")
  unless_6147_end:
.annotate 'line', 2204
    find_lex $P6156, "$cpast"
    unless_null $P6156, vivify_2825
    new $P6156, "Undef"
  vivify_2825:
    $P6157 = $P6156."value"()
    store_lex "$name", $P6157
.annotate 'line', 2205
    find_dynamic_lex $P6160, "$*PACKAGE"
    unless_null $P6160, vivify_2826
    get_hll_global $P6158, "GLOBAL"
    get_who $P6159, $P6158
    set $P6160, $P6159["$PACKAGE"]
    unless_null $P6160, vivify_2827
    die "Contextual $*PACKAGE not found"
  vivify_2827:
  vivify_2826:
    store_lex "$package", $P6160
.annotate 'line', 2206
    find_dynamic_lex $P6161, "$/"
    .const 'Sub' $P6163 = "563_1306916577.75068" 
    newclosure $P6174, $P6163
    $P6175 = $P6161."!make"($P6174)
.annotate 'line', 2199
    .return ($P6175)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6162"  :anon :subid("563_1306916577.75068") :outer("562_1306916577.75068")
    .param pmc param_6164
.annotate 'line', 2206
    .lex "$match", param_6164
.annotate 'line', 2207
    find_dynamic_lex $P6167, "$*SC"
    unless_null $P6167, vivify_2828
    get_hll_global $P6165, "GLOBAL"
    get_who $P6166, $P6165
    set $P6167, $P6166["$SC"]
    unless_null $P6167, vivify_2829
    die "Contextual $*SC not found"
  vivify_2829:
  vivify_2828:
    find_lex $P6168, "$package"
    unless_null $P6168, vivify_2830
    new $P6168, "Undef"
  vivify_2830:
    find_lex $P6169, "$name"
    unless_null $P6169, vivify_2831
    new $P6169, "Undef"
  vivify_2831:
    find_lex $P6170, "$match"
    unless_null $P6170, vivify_2832
    $P6170 = root_new ['parrot';'Hash']
  vivify_2832:
    set $P6171, $P6170["variable"]
    unless_null $P6171, vivify_2833
    new $P6171, "Undef"
  vivify_2833:
    set $S6172, $P6171
    $P6173 = $P6167."pkg_add_parrot_vtable_handler_mapping"($P6168, $P6169, $S6172)
.annotate 'line', 2206
    .return ($P6173)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6085"  :anon :subid("560_1306916577.75068") :outer("559_1306916577.75068")
.annotate 'line', 2186
    .const 'Sub' $P6117 = "561_1306916577.75068" 
    capture_lex $P6117
.annotate 'line', 2188
    new $P6087, "Undef"
    .lex "$cpast", $P6087
.annotate 'line', 2191
    new $P6088, "Undef"
    .lex "$name", $P6088
.annotate 'line', 2192
    new $P6089, "Undef"
    .lex "$package", $P6089
.annotate 'line', 2193
    new $P6090, "Undef"
    .lex "$is_dispatcher", $P6090
.annotate 'line', 2188
    find_lex $P6091, "$/"
    unless_null $P6091, vivify_2834
    $P6091 = root_new ['parrot';'Hash']
  vivify_2834:
    set $P6092, $P6091["circumfix"]
    unless_null $P6092, vivify_2835
    $P6092 = root_new ['parrot';'ResizablePMCArray']
  vivify_2835:
    set $P6093, $P6092[0]
    unless_null $P6093, vivify_2836
    new $P6093, "Undef"
  vivify_2836:
    $P6094 = $P6093."ast"()
    store_lex "$cpast", $P6094
.annotate 'line', 2190
    get_hll_global $P6096, "GLOBAL"
    nqp_get_package_through_who $P6097, $P6096, "PAST"
    get_who $P6098, $P6097
    set $P6099, $P6098["Val"]
    find_lex $P6100, "$cpast"
    unless_null $P6100, vivify_2837
    new $P6100, "Undef"
  vivify_2837:
    $P6101 = $P6099."ACCEPTS"($P6100)
    if $P6101, unless_6095_end
.annotate 'line', 2189
    find_lex $P6102, "$/"
    unless_null $P6102, vivify_2838
    new $P6102, "Undef"
  vivify_2838:
    $P6103 = $P6102."CURSOR"()
    $P6103."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_6095_end:
.annotate 'line', 2191
    find_lex $P6104, "$cpast"
    unless_null $P6104, vivify_2839
    new $P6104, "Undef"
  vivify_2839:
    $P6105 = $P6104."value"()
    store_lex "$name", $P6105
.annotate 'line', 2192
    find_dynamic_lex $P6108, "$*PACKAGE"
    unless_null $P6108, vivify_2840
    get_hll_global $P6106, "GLOBAL"
    get_who $P6107, $P6106
    set $P6108, $P6107["$PACKAGE"]
    unless_null $P6108, vivify_2841
    die "Contextual $*PACKAGE not found"
  vivify_2841:
  vivify_2840:
    store_lex "$package", $P6108
.annotate 'line', 2193
    find_dynamic_lex $P6111, "$*SCOPE"
    unless_null $P6111, vivify_2842
    get_hll_global $P6109, "GLOBAL"
    get_who $P6110, $P6109
    set $P6111, $P6110["$SCOPE"]
    unless_null $P6111, vivify_2843
    die "Contextual $*SCOPE not found"
  vivify_2843:
  vivify_2842:
    set $S6112, $P6111
    iseq $I6113, $S6112, "proto"
    new $P6114, 'Integer'
    set $P6114, $I6113
    store_lex "$is_dispatcher", $P6114
.annotate 'line', 2194
    find_dynamic_lex $P6115, "$/"
    .const 'Sub' $P6117 = "561_1306916577.75068" 
    newclosure $P6129, $P6117
    $P6130 = $P6115."!make"($P6129)
.annotate 'line', 2186
    .return ($P6130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6116"  :anon :subid("561_1306916577.75068") :outer("560_1306916577.75068")
    .param pmc param_6118
.annotate 'line', 2194
    .lex "$match", param_6118
.annotate 'line', 2195
    find_dynamic_lex $P6121, "$*SC"
    unless_null $P6121, vivify_2844
    get_hll_global $P6119, "GLOBAL"
    get_who $P6120, $P6119
    set $P6121, $P6120["$SC"]
    unless_null $P6121, vivify_2845
    die "Contextual $*SC not found"
  vivify_2845:
  vivify_2844:
    find_lex $P6122, "$package"
    unless_null $P6122, vivify_2846
    new $P6122, "Undef"
  vivify_2846:
    find_lex $P6123, "$name"
    unless_null $P6123, vivify_2847
    new $P6123, "Undef"
  vivify_2847:
.annotate 'line', 2196
    find_lex $P6124, "$match"
    unless_null $P6124, vivify_2848
    new $P6124, "Undef"
  vivify_2848:
    $P6125 = $P6124."ast"()
    set $P6126, $P6125["block_past"]
    unless_null $P6126, vivify_2849
    new $P6126, "Undef"
  vivify_2849:
.annotate 'line', 2195
    find_lex $P6127, "$is_dispatcher"
    unless_null $P6127, vivify_2850
    new $P6127, "Undef"
  vivify_2850:
    $P6128 = $P6121."pkg_add_method"($P6122, "add_parrot_vtable_mapping", $P6123, $P6126, $P6127)
.annotate 'line', 2194
    .return ($P6128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator" :anon :subid("564_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6197
    .param pmc param_6198
    .param pmc param_6199 :optional
    .param int has_param_6199 :opt_flag
.annotate 'line', 2218
    .const 'Sub' $P6326 = "567_1306916577.75068" 
    capture_lex $P6326
    .const 'Sub' $P6288 = "566_1306916577.75068" 
    capture_lex $P6288
    .const 'Sub' $P6268 = "565_1306916577.75068" 
    capture_lex $P6268
    new $P6196, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6196, control_6195
    push_eh $P6196
    .lex "self", param_6197
    .lex "$/", param_6198
    if has_param_6199, optparam_2851
    new $P6200, "Undef"
    set param_6199, $P6200
  optparam_2851:
    .lex "$key", param_6199
.annotate 'line', 2219
    $P6201 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P6201
.annotate 'line', 2220
    new $P6202, "Undef"
    .lex "$name", $P6202
.annotate 'line', 2221
    new $P6203, "Undef"
    .lex "$past", $P6203
.annotate 'line', 2219
    get_hll_global $P6204, "GLOBAL"
    nqp_get_package_through_who $P6205, $P6204, "Regex"
    nqp_get_package_through_who $P6206, $P6205, "P6Regex"
    nqp_get_package_through_who $P6207, $P6206, "Actions"
    get_who $P6208, $P6207
    set $P6209, $P6208["@MODIFIERS"]
    unless_null $P6209, vivify_2852
    $P6209 = root_new ['parrot';'ResizablePMCArray']
  vivify_2852:
    store_lex "@MODIFIERS", $P6209
.annotate 'line', 2220
    find_lex $P6210, "$/"
    unless_null $P6210, vivify_2853
    $P6210 = root_new ['parrot';'Hash']
  vivify_2853:
    set $P6211, $P6210["deflongname"]
    unless_null $P6211, vivify_2854
    new $P6211, "Undef"
  vivify_2854:
    $P6212 = $P6211."ast"()
    set $S6213, $P6212
    new $P6214, 'String'
    set $P6214, $S6213
    store_lex "$name", $P6214
    find_lex $P6215, "$past"
    unless_null $P6215, vivify_2855
    new $P6215, "Undef"
  vivify_2855:
.annotate 'line', 2222
    find_lex $P6217, "$/"
    unless_null $P6217, vivify_2856
    $P6217 = root_new ['parrot';'Hash']
  vivify_2856:
    set $P6218, $P6217["proto"]
    unless_null $P6218, vivify_2857
    new $P6218, "Undef"
  vivify_2857:
    if $P6218, if_6216
.annotate 'line', 2252
    find_lex $P6284, "$key"
    unless_null $P6284, vivify_2858
    new $P6284, "Undef"
  vivify_2858:
    set $S6285, $P6284
    iseq $I6286, $S6285, "open"
    if $I6286, if_6283
.annotate 'line', 2262
    .const 'Sub' $P6326 = "567_1306916577.75068" 
    capture_lex $P6326
    $P6326()
    goto if_6283_end
  if_6283:
.annotate 'line', 2252
    .const 'Sub' $P6288 = "566_1306916577.75068" 
    capture_lex $P6288
    $P6288()
  if_6283_end:
    goto if_6216_end
  if_6216:
.annotate 'line', 2224
    get_hll_global $P6219, "GLOBAL"
    nqp_get_package_through_who $P6220, $P6219, "PAST"
    get_who $P6221, $P6220
    set $P6222, $P6221["Stmts"]
.annotate 'line', 2225
    get_hll_global $P6223, "GLOBAL"
    nqp_get_package_through_who $P6224, $P6223, "PAST"
    get_who $P6225, $P6224
    set $P6226, $P6225["Block"]
    find_lex $P6227, "$name"
    unless_null $P6227, vivify_2908
    new $P6227, "Undef"
  vivify_2908:
.annotate 'line', 2226
    get_hll_global $P6228, "GLOBAL"
    nqp_get_package_through_who $P6229, $P6228, "PAST"
    get_who $P6230, $P6229
    set $P6231, $P6230["Op"]
.annotate 'line', 2227
    get_hll_global $P6232, "GLOBAL"
    nqp_get_package_through_who $P6233, $P6232, "PAST"
    get_who $P6234, $P6233
    set $P6235, $P6234["Var"]
    $P6236 = $P6235."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P6237, "$name"
    unless_null $P6237, vivify_2909
    new $P6237, "Undef"
  vivify_2909:
    $P6238 = $P6231."new"($P6236, $P6237, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2226
    find_lex $P6239, "$/"
    unless_null $P6239, vivify_2910
    new $P6239, "Undef"
  vivify_2910:
    $P6240 = $P6226."new"($P6238, $P6227 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P6239 :named("node"))
.annotate 'line', 2236
    get_hll_global $P6241, "GLOBAL"
    nqp_get_package_through_who $P6242, $P6241, "PAST"
    get_who $P6243, $P6242
    set $P6244, $P6243["Block"]
    new $P6245, "String"
    assign $P6245, "!PREFIX__"
    find_lex $P6246, "$name"
    unless_null $P6246, vivify_2911
    new $P6246, "Undef"
  vivify_2911:
    concat $P6247, $P6245, $P6246
.annotate 'line', 2237
    get_hll_global $P6248, "GLOBAL"
    nqp_get_package_through_who $P6249, $P6248, "PAST"
    get_who $P6250, $P6249
    set $P6251, $P6250["Op"]
.annotate 'line', 2238
    get_hll_global $P6252, "GLOBAL"
    nqp_get_package_through_who $P6253, $P6252, "PAST"
    get_who $P6254, $P6253
    set $P6255, $P6254["Var"]
    $P6256 = $P6255."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P6257, "$name"
    unless_null $P6257, vivify_2912
    new $P6257, "Undef"
  vivify_2912:
    $P6258 = $P6251."new"($P6256, $P6257, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2237
    find_lex $P6259, "$/"
    unless_null $P6259, vivify_2913
    new $P6259, "Undef"
  vivify_2913:
    $P6260 = $P6244."new"($P6258, $P6247 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P6259 :named("node"))
.annotate 'line', 2236
    $P6261 = $P6222."new"($P6240, $P6260)
.annotate 'line', 2224
    store_lex "$past", $P6261
.annotate 'line', 2248
    find_lex $P6263, "$past"
    unless_null $P6263, vivify_2914
    new $P6263, "Undef"
  vivify_2914:
    $P6264 = $P6263."list"()
    defined $I6265, $P6264
    unless $I6265, for_undef_2915
    iter $P6262, $P6264
    new $P6281, 'ExceptionHandler'
    set_label $P6281, loop6280_handler
    $P6281."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6281
  loop6280_test:
    unless $P6262, loop6280_done
    shift $P6266, $P6262
  loop6280_redo:
    .const 'Sub' $P6268 = "565_1306916577.75068" 
    capture_lex $P6268
    $P6268($P6266)
  loop6280_next:
    goto loop6280_test
  loop6280_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6282, exception, 'type'
    eq $P6282, .CONTROL_LOOP_NEXT, loop6280_next
    eq $P6282, .CONTROL_LOOP_REDO, loop6280_redo
  loop6280_done:
    pop_eh 
  for_undef_2915:
  if_6216_end:
.annotate 'line', 2293
    find_lex $P6419, "$/"
    find_lex $P6420, "$past"
    unless_null $P6420, vivify_2922
    new $P6420, "Undef"
  vivify_2922:
    $P6421 = $P6419."!make"($P6420)
.annotate 'line', 2218
    .return ($P6421)
  control_6195:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6422, exception, "payload"
    .return ($P6422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6325"  :anon :subid("567_1306916577.75068") :outer("564_1306916577.75068")
.annotate 'line', 2262
    .const 'Sub' $P6358 = "568_1306916577.75068" 
    capture_lex $P6358
.annotate 'line', 2263
    new $P6327, "Undef"
    .lex "$regex", $P6327
.annotate 'line', 2266
    new $P6328, "Undef"
    .lex "$prefix_meth", $P6328
.annotate 'line', 2264
    get_hll_global $P6329, "GLOBAL"
    nqp_get_package_through_who $P6330, $P6329, "Regex"
    nqp_get_package_through_who $P6331, $P6330, "P6Regex"
    nqp_get_package_through_who $P6332, $P6331, "Actions"
    get_who $P6333, $P6332
    set $P6334, $P6333["buildsub"]
    find_lex $P6335, "$/"
    unless_null $P6335, vivify_2859
    $P6335 = root_new ['parrot';'Hash']
  vivify_2859:
    set $P6336, $P6335["p6regex"]
    unless_null $P6336, vivify_2860
    new $P6336, "Undef"
  vivify_2860:
    $P6337 = $P6336."ast"()
    find_lex $P6338, "$?PACKAGE"
    get_who $P6339, $P6338
    set $P6340, $P6339["@BLOCK"]
    unless_null $P6340, vivify_2861
    $P6340 = root_new ['parrot';'ResizablePMCArray']
  vivify_2861:
    $P6341 = $P6340."shift"()
    $P6342 = $P6334($P6337, $P6341)
    store_lex "$regex", $P6342
.annotate 'line', 2265
    find_lex $P6343, "$regex"
    unless_null $P6343, vivify_2862
    new $P6343, "Undef"
  vivify_2862:
    find_lex $P6344, "$name"
    unless_null $P6344, vivify_2863
    new $P6344, "Undef"
  vivify_2863:
    $P6343."name"($P6344)
    find_lex $P6345, "$prefix_meth"
    unless_null $P6345, vivify_2864
    new $P6345, "Undef"
  vivify_2864:
.annotate 'line', 2268
    find_dynamic_lex $P6351, "$*PKGDECL"
    unless_null $P6351, vivify_2865
    get_hll_global $P6349, "GLOBAL"
    get_who $P6350, $P6349
    set $P6351, $P6350["$PKGDECL"]
    unless_null $P6351, vivify_2866
    die "Contextual $*PKGDECL not found"
  vivify_2866:
  vivify_2865:
    if $P6351, if_6348
    set $P6347, $P6351
    goto if_6348_end
  if_6348:
    find_dynamic_lex $P6354, "$*PACKAGE"
    unless_null $P6354, vivify_2867
    get_hll_global $P6352, "GLOBAL"
    get_who $P6353, $P6352
    set $P6354, $P6353["$PACKAGE"]
    unless_null $P6354, vivify_2868
    die "Contextual $*PACKAGE not found"
  vivify_2868:
  vivify_2867:
    get_how $P6355, $P6354
    can $I6356, $P6355, "add_method"
    new $P6347, 'Integer'
    set $P6347, $I6356
  if_6348_end:
    unless $P6347, if_6346_end
    .const 'Sub' $P6358 = "568_1306916577.75068" 
    capture_lex $P6358
    $P6358()
  if_6346_end:
.annotate 'line', 2283
    get_hll_global $P6396, "GLOBAL"
    nqp_get_package_through_who $P6397, $P6396, "PAST"
    get_who $P6398, $P6397
    set $P6399, $P6398["Op"]
.annotate 'line', 2285
    new $P6400, "ResizablePMCArray"
    push $P6400, "Regex"
    push $P6400, "Method"
    find_lex $P6401, "$/"
    unless_null $P6401, vivify_2885
    new $P6401, "Undef"
  vivify_2885:
    $P6402 = "lexical_package_lookup"($P6400, $P6401)
    find_lex $P6403, "$regex"
    unless_null $P6403, vivify_2886
    new $P6403, "Undef"
  vivify_2886:
    $P6404 = $P6399."new"($P6402, $P6403, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2283
    store_lex "$past", $P6404
.annotate 'line', 2288
    find_lex $P6407, "$prefix_meth"
    unless_null $P6407, vivify_2887
    new $P6407, "Undef"
  vivify_2887:
    if $P6407, if_6406
    find_lex $P6415, "$regex"
    unless_null $P6415, vivify_2888
    new $P6415, "Undef"
  vivify_2888:
    set $P6405, $P6415
    goto if_6406_end
  if_6406:
.annotate 'line', 2289
    get_hll_global $P6408, "GLOBAL"
    nqp_get_package_through_who $P6409, $P6408, "PAST"
    get_who $P6410, $P6409
    set $P6411, $P6410["Stmts"]
    find_lex $P6412, "$regex"
    unless_null $P6412, vivify_2889
    new $P6412, "Undef"
  vivify_2889:
    find_lex $P6413, "$prefix_meth"
    unless_null $P6413, vivify_2890
    new $P6413, "Undef"
  vivify_2890:
    $P6414 = $P6411."new"($P6412, $P6413)
    set $P6405, $P6414
  if_6406_end:
.annotate 'line', 2288
    find_lex $P6416, "$past"
    unless_null $P6416, vivify_2891
    $P6416 = root_new ['parrot';'Hash']
    store_lex "$past", $P6416
  vivify_2891:
    set $P6416["sink"], $P6405
.annotate 'line', 2291
    find_lex $P6417, "@MODIFIERS"
    unless_null $P6417, vivify_2892
    $P6417 = root_new ['parrot';'ResizablePMCArray']
  vivify_2892:
    $P6418 = $P6417."shift"()
.annotate 'line', 2262
    .return ($P6418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6357"  :anon :subid("568_1306916577.75068") :outer("567_1306916577.75068")
.annotate 'line', 2273
    $P6359 = root_new ['parrot';'ResizablePMCArray']
    .lex "@prefixes", $P6359
.annotate 'line', 2270
    find_dynamic_lex $P6362, "$*SC"
    unless_null $P6362, vivify_2869
    get_hll_global $P6360, "GLOBAL"
    get_who $P6361, $P6360
    set $P6362, $P6361["$SC"]
    unless_null $P6362, vivify_2870
    die "Contextual $*SC not found"
  vivify_2870:
  vivify_2869:
    find_dynamic_lex $P6365, "$*PACKAGE"
    unless_null $P6365, vivify_2871
    get_hll_global $P6363, "GLOBAL"
    get_who $P6364, $P6363
    set $P6365, $P6364["$PACKAGE"]
    unless_null $P6365, vivify_2872
    die "Contextual $*PACKAGE not found"
  vivify_2872:
  vivify_2871:
    find_lex $P6366, "$name"
    unless_null $P6366, vivify_2873
    new $P6366, "Undef"
  vivify_2873:
    find_lex $P6367, "$regex"
    unless_null $P6367, vivify_2874
    new $P6367, "Undef"
  vivify_2874:
    $P6362."pkg_add_method"($P6365, "add_method", $P6366, $P6367, 0)
.annotate 'line', 2273
    find_lex $P6368, "$/"
    unless_null $P6368, vivify_2875
    $P6368 = root_new ['parrot';'Hash']
  vivify_2875:
    set $P6369, $P6368["p6regex"]
    unless_null $P6369, vivify_2876
    new $P6369, "Undef"
  vivify_2876:
    $P6370 = $P6369."ast"()
    $P6371 = $P6370."prefix_list"()
    store_lex "@prefixes", $P6371
.annotate 'line', 2274
    get_hll_global $P6372, "GLOBAL"
    nqp_get_package_through_who $P6373, $P6372, "PAST"
    get_who $P6374, $P6373
    set $P6375, $P6374["Block"]
.annotate 'line', 2275
    new $P6376, "String"
    assign $P6376, "!PREFIX__"
    find_lex $P6377, "$name"
    unless_null $P6377, vivify_2877
    new $P6377, "Undef"
  vivify_2877:
    concat $P6378, $P6376, $P6377
.annotate 'line', 2276
    get_hll_global $P6379, "GLOBAL"
    nqp_get_package_through_who $P6380, $P6379, "PAST"
    get_who $P6381, $P6380
    set $P6382, $P6381["Op"]
    find_lex $P6383, "@prefixes"
    unless_null $P6383, vivify_2878
    $P6383 = root_new ['parrot';'ResizablePMCArray']
  vivify_2878:
    $P6384 = $P6382."new"($P6383 :flat, "list" :named("pasttype"))
    $P6385 = $P6375."new"($P6384, $P6378 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2274
    store_lex "$prefix_meth", $P6385
.annotate 'line', 2278
    find_dynamic_lex $P6388, "$*SC"
    unless_null $P6388, vivify_2879
    get_hll_global $P6386, "GLOBAL"
    get_who $P6387, $P6386
    set $P6388, $P6387["$SC"]
    unless_null $P6388, vivify_2880
    die "Contextual $*SC not found"
  vivify_2880:
  vivify_2879:
    find_dynamic_lex $P6391, "$*PACKAGE"
    unless_null $P6391, vivify_2881
    get_hll_global $P6389, "GLOBAL"
    get_who $P6390, $P6389
    set $P6391, $P6390["$PACKAGE"]
    unless_null $P6391, vivify_2882
    die "Contextual $*PACKAGE not found"
  vivify_2882:
  vivify_2881:
    find_lex $P6392, "$prefix_meth"
    unless_null $P6392, vivify_2883
    new $P6392, "Undef"
  vivify_2883:
    $P6393 = $P6392."name"()
    find_lex $P6394, "$prefix_meth"
    unless_null $P6394, vivify_2884
    new $P6394, "Undef"
  vivify_2884:
    $P6395 = $P6388."pkg_add_method"($P6391, "add_method", $P6393, $P6394, 0)
.annotate 'line', 2268
    .return ($P6395)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6287"  :anon :subid("566_1306916577.75068") :outer("564_1306916577.75068")
.annotate 'line', 2253
    $P6289 = root_new ['parrot';'Hash']
    .lex "%h", $P6289
.annotate 'line', 2252
    find_lex $P6290, "%h"
    unless_null $P6290, vivify_2893
    $P6290 = root_new ['parrot';'Hash']
  vivify_2893:
.annotate 'line', 2254
    find_lex $P6292, "$/"
    unless_null $P6292, vivify_2894
    $P6292 = root_new ['parrot';'Hash']
  vivify_2894:
    set $P6293, $P6292["sym"]
    unless_null $P6293, vivify_2895
    new $P6293, "Undef"
  vivify_2895:
    set $S6294, $P6293
    iseq $I6295, $S6294, "token"
    unless $I6295, if_6291_end
    new $P6296, "Integer"
    assign $P6296, 1
    find_lex $P6297, "%h"
    unless_null $P6297, vivify_2896
    $P6297 = root_new ['parrot';'Hash']
    store_lex "%h", $P6297
  vivify_2896:
    set $P6297["r"], $P6296
  if_6291_end:
.annotate 'line', 2255
    find_lex $P6299, "$/"
    unless_null $P6299, vivify_2897
    $P6299 = root_new ['parrot';'Hash']
  vivify_2897:
    set $P6300, $P6299["sym"]
    unless_null $P6300, vivify_2898
    new $P6300, "Undef"
  vivify_2898:
    set $S6301, $P6300
    iseq $I6302, $S6301, "rule"
    unless $I6302, if_6298_end
    new $P6303, "Integer"
    assign $P6303, 1
    find_lex $P6304, "%h"
    unless_null $P6304, vivify_2899
    $P6304 = root_new ['parrot';'Hash']
    store_lex "%h", $P6304
  vivify_2899:
    set $P6304["r"], $P6303
    new $P6305, "Integer"
    assign $P6305, 1
    find_lex $P6306, "%h"
    unless_null $P6306, vivify_2900
    $P6306 = root_new ['parrot';'Hash']
    store_lex "%h", $P6306
  vivify_2900:
    set $P6306["s"], $P6305
  if_6298_end:
.annotate 'line', 2256
    find_lex $P6307, "@MODIFIERS"
    unless_null $P6307, vivify_2901
    $P6307 = root_new ['parrot';'ResizablePMCArray']
  vivify_2901:
    find_lex $P6308, "%h"
    unless_null $P6308, vivify_2902
    $P6308 = root_new ['parrot';'Hash']
  vivify_2902:
    $P6307."unshift"($P6308)
.annotate 'line', 2257
    find_lex $P6309, "$name"
    unless_null $P6309, vivify_2903
    new $P6309, "Undef"
  vivify_2903:
    get_hll_global $P6310, "GLOBAL"
    nqp_get_package_through_who $P6311, $P6310, "Regex"
    nqp_get_package_through_who $P6312, $P6311, "P6Regex"
    nqp_get_package_through_who $P6313, $P6312, "Actions"
    get_who $P6314, $P6313
    set $P6314["$REGEXNAME"], $P6309
.annotate 'line', 2258
    find_lex $P6315, "$?PACKAGE"
    get_who $P6316, $P6315
    set $P6317, $P6316["@BLOCK"]
    unless_null $P6317, vivify_2904
    $P6317 = root_new ['parrot';'ResizablePMCArray']
  vivify_2904:
    set $P6318, $P6317[0]
    unless_null $P6318, vivify_2905
    new $P6318, "Undef"
  vivify_2905:
    $P6318."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2259
    find_lex $P6319, "$?PACKAGE"
    get_who $P6320, $P6319
    set $P6321, $P6320["@BLOCK"]
    unless_null $P6321, vivify_2906
    $P6321 = root_new ['parrot';'ResizablePMCArray']
  vivify_2906:
    set $P6322, $P6321[0]
    unless_null $P6322, vivify_2907
    new $P6322, "Undef"
  vivify_2907:
    $P6322."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2260
    new $P6323, "Exception"
    set $P6323['type'], .CONTROL_RETURN
    new $P6324, "Integer"
    assign $P6324, 0
    setattribute $P6323, 'payload', $P6324
    throw $P6323
.annotate 'line', 2252
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6267"  :anon :subid("565_1306916577.75068") :outer("564_1306916577.75068")
    .param pmc param_6269
.annotate 'line', 2248
    .lex "$_", param_6269
.annotate 'line', 2249
    find_dynamic_lex $P6272, "$*SC"
    unless_null $P6272, vivify_2916
    get_hll_global $P6270, "GLOBAL"
    get_who $P6271, $P6270
    set $P6272, $P6271["$SC"]
    unless_null $P6272, vivify_2917
    die "Contextual $*SC not found"
  vivify_2917:
  vivify_2916:
    find_dynamic_lex $P6275, "$*PACKAGE"
    unless_null $P6275, vivify_2918
    get_hll_global $P6273, "GLOBAL"
    get_who $P6274, $P6273
    set $P6275, $P6274["$PACKAGE"]
    unless_null $P6275, vivify_2919
    die "Contextual $*PACKAGE not found"
  vivify_2919:
  vivify_2918:
    find_lex $P6276, "$_"
    unless_null $P6276, vivify_2920
    new $P6276, "Undef"
  vivify_2920:
    $P6277 = $P6276."name"()
    find_lex $P6278, "$_"
    unless_null $P6278, vivify_2921
    new $P6278, "Undef"
  vivify_2921:
    $P6279 = $P6272."pkg_add_method"($P6275, "add_method", $P6277, $P6278, 0)
.annotate 'line', 2248
    .return ($P6279)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty" :anon :subid("569_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6424
    .param pmc param_6425
.annotate 'line', 2297
    .lex "self", param_6424
    .lex "$/", param_6425
.annotate 'line', 2298
    new $P6426, "Undef"
    .lex "$past", $P6426
    find_lex $P6429, "$/"
    unless_null $P6429, vivify_2923
    $P6429 = root_new ['parrot';'Hash']
  vivify_2923:
    set $P6430, $P6429["args"]
    unless_null $P6430, vivify_2924
    new $P6430, "Undef"
  vivify_2924:
    if $P6430, if_6428
    get_hll_global $P6435, "GLOBAL"
    nqp_get_package_through_who $P6436, $P6435, "PAST"
    get_who $P6437, $P6436
    set $P6438, $P6437["Op"]
    find_lex $P6439, "$/"
    unless_null $P6439, vivify_2925
    new $P6439, "Undef"
  vivify_2925:
    $P6440 = $P6438."new"($P6439 :named("node"))
    set $P6427, $P6440
    goto if_6428_end
  if_6428:
    find_lex $P6431, "$/"
    unless_null $P6431, vivify_2926
    $P6431 = root_new ['parrot';'Hash']
  vivify_2926:
    set $P6432, $P6431["args"]
    unless_null $P6432, vivify_2927
    $P6432 = root_new ['parrot';'ResizablePMCArray']
  vivify_2927:
    set $P6433, $P6432[0]
    unless_null $P6433, vivify_2928
    new $P6433, "Undef"
  vivify_2928:
    $P6434 = $P6433."ast"()
    set $P6427, $P6434
  if_6428_end:
    store_lex "$past", $P6427
.annotate 'line', 2299
    find_lex $P6442, "$/"
    unless_null $P6442, vivify_2929
    $P6442 = root_new ['parrot';'Hash']
  vivify_2929:
    set $P6443, $P6442["quote"]
    unless_null $P6443, vivify_2930
    new $P6443, "Undef"
  vivify_2930:
    if $P6443, if_6441
.annotate 'line', 2303
    find_lex $P6450, "$/"
    unless_null $P6450, vivify_2931
    $P6450 = root_new ['parrot';'Hash']
  vivify_2931:
    set $P6451, $P6450["longname"]
    unless_null $P6451, vivify_2932
    new $P6451, "Undef"
  vivify_2932:
    set $S6452, $P6451
    iseq $I6453, $S6452, "HOW"
    if $I6453, if_6449
.annotate 'line', 2306
    find_lex $P6456, "$/"
    unless_null $P6456, vivify_2933
    $P6456 = root_new ['parrot';'Hash']
  vivify_2933:
    set $P6457, $P6456["longname"]
    unless_null $P6457, vivify_2934
    new $P6457, "Undef"
  vivify_2934:
    set $S6458, $P6457
    iseq $I6459, $S6458, "WHAT"
    if $I6459, if_6455
.annotate 'line', 2309
    find_lex $P6462, "$/"
    unless_null $P6462, vivify_2935
    $P6462 = root_new ['parrot';'Hash']
  vivify_2935:
    set $P6463, $P6462["longname"]
    unless_null $P6463, vivify_2936
    new $P6463, "Undef"
  vivify_2936:
    set $S6464, $P6463
    iseq $I6465, $S6464, "WHO"
    if $I6465, if_6461
.annotate 'line', 2313
    find_lex $P6467, "$past"
    unless_null $P6467, vivify_2937
    new $P6467, "Undef"
  vivify_2937:
    find_lex $P6468, "$/"
    unless_null $P6468, vivify_2938
    $P6468 = root_new ['parrot';'Hash']
  vivify_2938:
    set $P6469, $P6468["longname"]
    unless_null $P6469, vivify_2939
    new $P6469, "Undef"
  vivify_2939:
    set $S6470, $P6469
    $P6467."name"($S6470)
.annotate 'line', 2314
    find_lex $P6471, "$past"
    unless_null $P6471, vivify_2940
    new $P6471, "Undef"
  vivify_2940:
    $P6471."pasttype"("callmethod")
.annotate 'line', 2312
    goto if_6461_end
  if_6461:
.annotate 'line', 2310
    find_lex $P6466, "$past"
    unless_null $P6466, vivify_2941
    new $P6466, "Undef"
  vivify_2941:
    $P6466."pirop"("get_who PP")
  if_6461_end:
.annotate 'line', 2309
    goto if_6455_end
  if_6455:
.annotate 'line', 2307
    find_lex $P6460, "$past"
    unless_null $P6460, vivify_2942
    new $P6460, "Undef"
  vivify_2942:
    $P6460."pirop"("get_what PP")
  if_6455_end:
.annotate 'line', 2306
    goto if_6449_end
  if_6449:
.annotate 'line', 2304
    find_lex $P6454, "$past"
    unless_null $P6454, vivify_2943
    new $P6454, "Undef"
  vivify_2943:
    $P6454."pirop"("get_how PP")
  if_6449_end:
.annotate 'line', 2303
    goto if_6441_end
  if_6441:
.annotate 'line', 2300
    find_lex $P6444, "$past"
    unless_null $P6444, vivify_2944
    new $P6444, "Undef"
  vivify_2944:
    find_lex $P6445, "$/"
    unless_null $P6445, vivify_2945
    $P6445 = root_new ['parrot';'Hash']
  vivify_2945:
    set $P6446, $P6445["quote"]
    unless_null $P6446, vivify_2946
    new $P6446, "Undef"
  vivify_2946:
    $P6447 = $P6446."ast"()
    $P6444."name"($P6447)
.annotate 'line', 2301
    find_lex $P6448, "$past"
    unless_null $P6448, vivify_2947
    new $P6448, "Undef"
  vivify_2947:
    $P6448."pasttype"("callmethod")
  if_6441_end:
.annotate 'line', 2316
    find_lex $P6472, "$/"
    find_lex $P6473, "$past"
    unless_null $P6473, vivify_2948
    new $P6473, "Undef"
  vivify_2948:
    $P6474 = $P6472."!make"($P6473)
.annotate 'line', 2297
    .return ($P6474)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>" :anon :subid("570_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6476
    .param pmc param_6477
.annotate 'line', 2321
    .lex "self", param_6476
    .lex "$/", param_6477
.annotate 'line', 2322
    find_lex $P6478, "$/"
    get_hll_global $P6479, "GLOBAL"
    nqp_get_package_through_who $P6480, $P6479, "PAST"
    get_who $P6481, $P6480
    set $P6482, $P6481["Var"]
    $P6483 = $P6482."new"("self" :named("name"))
    $P6484 = $P6478."!make"($P6483)
.annotate 'line', 2321
    .return ($P6484)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>" :anon :subid("571_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6486
    .param pmc param_6487
.annotate 'line', 2325
    .lex "self", param_6486
    .lex "$/", param_6487
.annotate 'line', 2326
    new $P6488, "Undef"
    .lex "$past", $P6488
    find_lex $P6489, "$/"
    unless_null $P6489, vivify_2949
    $P6489 = root_new ['parrot';'Hash']
  vivify_2949:
    set $P6490, $P6489["args"]
    unless_null $P6490, vivify_2950
    new $P6490, "Undef"
  vivify_2950:
    $P6491 = $P6490."ast"()
    store_lex "$past", $P6491
.annotate 'line', 2327
    find_lex $P6492, "$past"
    unless_null $P6492, vivify_2951
    new $P6492, "Undef"
  vivify_2951:
    find_lex $P6493, "$/"
    unless_null $P6493, vivify_2952
    $P6493 = root_new ['parrot';'Hash']
  vivify_2952:
    set $P6494, $P6493["deflongname"]
    unless_null $P6494, vivify_2953
    new $P6494, "Undef"
  vivify_2953:
    set $S6495, $P6494
    $P6492."name"($S6495)
.annotate 'line', 2328
    find_lex $P6496, "$/"
    find_lex $P6497, "$past"
    unless_null $P6497, vivify_2954
    new $P6497, "Undef"
  vivify_2954:
    $P6498 = $P6496."!make"($P6497)
.annotate 'line', 2325
    .return ($P6498)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>" :anon :subid("572_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6500
    .param pmc param_6501
.annotate 'line', 2331
    .const 'Sub' $P6519 = "573_1306916577.75068" 
    capture_lex $P6519
    .lex "self", param_6500
    .lex "$/", param_6501
.annotate 'line', 2333
    new $P6502, "Undef"
    .lex "$var", $P6502
.annotate 'line', 2343
    new $P6503, "Undef"
    .lex "$past", $P6503
.annotate 'line', 2331
    find_lex $P6504, "$var"
    unless_null $P6504, vivify_2955
    new $P6504, "Undef"
  vivify_2955:
.annotate 'line', 2334
    find_lex $P6506, "$/"
    unless_null $P6506, vivify_2956
    $P6506 = root_new ['parrot';'Hash']
  vivify_2956:
    set $P6507, $P6506["name"]
    unless_null $P6507, vivify_2957
    new $P6507, "Undef"
  vivify_2957:
    set $S6508, $P6507
    $P6509 = "is_lexical"($S6508)
    if $P6509, if_6505
.annotate 'line', 2337
    .const 'Sub' $P6519 = "573_1306916577.75068" 
    capture_lex $P6519
    $P6519()
    goto if_6505_end
  if_6505:
.annotate 'line', 2335
    get_hll_global $P6510, "GLOBAL"
    nqp_get_package_through_who $P6511, $P6510, "PAST"
    get_who $P6512, $P6511
    set $P6513, $P6512["Var"]
    find_lex $P6514, "$/"
    unless_null $P6514, vivify_2963
    $P6514 = root_new ['parrot';'Hash']
  vivify_2963:
    set $P6515, $P6514["name"]
    unless_null $P6515, vivify_2964
    new $P6515, "Undef"
  vivify_2964:
    set $S6516, $P6515
    $P6517 = $P6513."new"($S6516 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6517
  if_6505_end:
.annotate 'line', 2343
    find_lex $P6528, "$var"
    unless_null $P6528, vivify_2965
    new $P6528, "Undef"
  vivify_2965:
    store_lex "$past", $P6528
.annotate 'line', 2344
    find_lex $P6530, "$/"
    unless_null $P6530, vivify_2966
    $P6530 = root_new ['parrot';'Hash']
  vivify_2966:
    set $P6531, $P6530["args"]
    unless_null $P6531, vivify_2967
    new $P6531, "Undef"
  vivify_2967:
    unless $P6531, if_6529_end
.annotate 'line', 2345
    find_lex $P6532, "$/"
    unless_null $P6532, vivify_2968
    $P6532 = root_new ['parrot';'Hash']
  vivify_2968:
    set $P6533, $P6532["args"]
    unless_null $P6533, vivify_2969
    $P6533 = root_new ['parrot';'ResizablePMCArray']
  vivify_2969:
    set $P6534, $P6533[0]
    unless_null $P6534, vivify_2970
    new $P6534, "Undef"
  vivify_2970:
    $P6535 = $P6534."ast"()
    store_lex "$past", $P6535
.annotate 'line', 2346
    find_lex $P6536, "$past"
    unless_null $P6536, vivify_2971
    new $P6536, "Undef"
  vivify_2971:
    find_lex $P6537, "$var"
    unless_null $P6537, vivify_2972
    new $P6537, "Undef"
  vivify_2972:
    $P6536."unshift"($P6537)
  if_6529_end:
.annotate 'line', 2348
    find_lex $P6538, "$/"
    find_lex $P6539, "$past"
    unless_null $P6539, vivify_2973
    new $P6539, "Undef"
  vivify_2973:
    $P6540 = $P6538."!make"($P6539)
.annotate 'line', 2331
    .return ($P6540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6518"  :anon :subid("573_1306916577.75068") :outer("572_1306916577.75068")
.annotate 'line', 2338
    $P6520 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6520
    find_lex $P6521, "$/"
    unless_null $P6521, vivify_2958
    $P6521 = root_new ['parrot';'Hash']
  vivify_2958:
    set $P6522, $P6521["name"]
    unless_null $P6522, vivify_2959
    $P6522 = root_new ['parrot';'Hash']
  vivify_2959:
    set $P6523, $P6522["identifier"]
    unless_null $P6523, vivify_2960
    new $P6523, "Undef"
  vivify_2960:
    clone $P6524, $P6523
    store_lex "@ns", $P6524
.annotate 'line', 2339
    find_lex $P6525, "@ns"
    unless_null $P6525, vivify_2961
    $P6525 = root_new ['parrot';'ResizablePMCArray']
  vivify_2961:
    find_lex $P6526, "$/"
    unless_null $P6526, vivify_2962
    new $P6526, "Undef"
  vivify_2962:
    $P6527 = "lexical_package_lookup"($P6525, $P6526)
    store_lex "$var", $P6527
.annotate 'line', 2337
    .return ($P6527)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>" :anon :subid("574_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6542
    .param pmc param_6543
.annotate 'line', 2351
    .lex "self", param_6542
    .lex "$/", param_6543
.annotate 'line', 2352
    new $P6544, "Undef"
    .lex "$past", $P6544
.annotate 'line', 2353
    new $P6545, "Undef"
    .lex "$pirop", $P6545
.annotate 'line', 2352
    find_lex $P6548, "$/"
    unless_null $P6548, vivify_2974
    $P6548 = root_new ['parrot';'Hash']
  vivify_2974:
    set $P6549, $P6548["args"]
    unless_null $P6549, vivify_2975
    new $P6549, "Undef"
  vivify_2975:
    if $P6549, if_6547
    get_hll_global $P6554, "GLOBAL"
    nqp_get_package_through_who $P6555, $P6554, "PAST"
    get_who $P6556, $P6555
    set $P6557, $P6556["Op"]
    find_lex $P6558, "$/"
    unless_null $P6558, vivify_2976
    new $P6558, "Undef"
  vivify_2976:
    $P6559 = $P6557."new"($P6558 :named("node"))
    set $P6546, $P6559
    goto if_6547_end
  if_6547:
    find_lex $P6550, "$/"
    unless_null $P6550, vivify_2977
    $P6550 = root_new ['parrot';'Hash']
  vivify_2977:
    set $P6551, $P6550["args"]
    unless_null $P6551, vivify_2978
    $P6551 = root_new ['parrot';'ResizablePMCArray']
  vivify_2978:
    set $P6552, $P6551[0]
    unless_null $P6552, vivify_2979
    new $P6552, "Undef"
  vivify_2979:
    $P6553 = $P6552."ast"()
    set $P6546, $P6553
  if_6547_end:
    store_lex "$past", $P6546
.annotate 'line', 2353
    find_lex $P6560, "$/"
    unless_null $P6560, vivify_2980
    $P6560 = root_new ['parrot';'Hash']
  vivify_2980:
    set $P6561, $P6560["op"]
    unless_null $P6561, vivify_2981
    new $P6561, "Undef"
  vivify_2981:
    set $S6562, $P6561
    new $P6563, 'String'
    set $P6563, $S6562
    store_lex "$pirop", $P6563
.annotate 'line', 2354
    find_lex $P6564, "$pirop"
    unless_null $P6564, vivify_2982
    new $P6564, "Undef"
  vivify_2982:
    set $S6565, $P6564
    split $P6566, "__", $S6565
    join $S6567, " ", $P6566
    new $P6568, 'String'
    set $P6568, $S6567
    store_lex "$pirop", $P6568
.annotate 'line', 2355
    find_lex $P6569, "$past"
    unless_null $P6569, vivify_2983
    new $P6569, "Undef"
  vivify_2983:
    find_lex $P6570, "$pirop"
    unless_null $P6570, vivify_2984
    new $P6570, "Undef"
  vivify_2984:
    $P6569."pirop"($P6570)
.annotate 'line', 2356
    find_lex $P6571, "$past"
    unless_null $P6571, vivify_2985
    new $P6571, "Undef"
  vivify_2985:
    $P6571."pasttype"("pirop")
.annotate 'line', 2357
    find_lex $P6572, "$/"
    find_lex $P6573, "$past"
    unless_null $P6573, vivify_2986
    new $P6573, "Undef"
  vivify_2986:
    $P6574 = $P6572."!make"($P6573)
.annotate 'line', 2351
    .return ($P6574)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>" :anon :subid("575_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6576
    .param pmc param_6577
.annotate 'line', 2360
    .lex "self", param_6576
    .lex "$/", param_6577
.annotate 'line', 2361
    find_lex $P6578, "$/"
    get_hll_global $P6579, "GLOBAL"
    nqp_get_package_through_who $P6580, $P6579, "PAST"
    get_who $P6581, $P6580
    set $P6582, $P6581["Op"]
    $P6583 = $P6582."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6584 = $P6578."!make"($P6583)
.annotate 'line', 2360
    .return ($P6584)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args" :anon :subid("576_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6586
    .param pmc param_6587
.annotate 'line', 2366
    .lex "self", param_6586
    .lex "$/", param_6587
    find_lex $P6588, "$/"
    find_lex $P6589, "$/"
    unless_null $P6589, vivify_2987
    $P6589 = root_new ['parrot';'Hash']
  vivify_2987:
    set $P6590, $P6589["arglist"]
    unless_null $P6590, vivify_2988
    new $P6590, "Undef"
  vivify_2988:
    $P6591 = $P6590."ast"()
    $P6592 = $P6588."!make"($P6591)
    .return ($P6592)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist" :anon :subid("577_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6594
    .param pmc param_6595
.annotate 'line', 2368
    .const 'Sub' $P6609 = "578_1306916577.75068" 
    capture_lex $P6609
    .lex "self", param_6594
    .lex "$/", param_6595
.annotate 'line', 2369
    new $P6596, "Undef"
    .lex "$past", $P6596
.annotate 'line', 2377
    new $P6597, "Undef"
    .lex "$i", $P6597
.annotate 'line', 2378
    new $P6598, "Undef"
    .lex "$n", $P6598
.annotate 'line', 2369
    get_hll_global $P6599, "GLOBAL"
    nqp_get_package_through_who $P6600, $P6599, "PAST"
    get_who $P6601, $P6600
    set $P6602, $P6601["Op"]
    find_lex $P6603, "$/"
    unless_null $P6603, vivify_2989
    new $P6603, "Undef"
  vivify_2989:
    $P6604 = $P6602."new"("call" :named("pasttype"), $P6603 :named("node"))
    store_lex "$past", $P6604
.annotate 'line', 2370
    find_lex $P6606, "$/"
    unless_null $P6606, vivify_2990
    $P6606 = root_new ['parrot';'Hash']
  vivify_2990:
    set $P6607, $P6606["EXPR"]
    unless_null $P6607, vivify_2991
    new $P6607, "Undef"
  vivify_2991:
    unless $P6607, if_6605_end
    .const 'Sub' $P6609 = "578_1306916577.75068" 
    capture_lex $P6609
    $P6609()
  if_6605_end:
.annotate 'line', 2377
    new $P6641, "Integer"
    assign $P6641, 0
    store_lex "$i", $P6641
.annotate 'line', 2378
    find_lex $P6642, "$past"
    unless_null $P6642, vivify_3002
    new $P6642, "Undef"
  vivify_3002:
    $P6643 = $P6642."list"()
    set $N6644, $P6643
    new $P6645, 'Float'
    set $P6645, $N6644
    store_lex "$n", $P6645
.annotate 'line', 2379
    new $P6696, 'ExceptionHandler'
    set_label $P6696, loop6695_handler
    $P6696."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6696
  loop6695_test:
    find_lex $P6646, "$i"
    unless_null $P6646, vivify_3003
    new $P6646, "Undef"
  vivify_3003:
    set $N6647, $P6646
    find_lex $P6648, "$n"
    unless_null $P6648, vivify_3004
    new $P6648, "Undef"
  vivify_3004:
    set $N6649, $P6648
    islt $I6650, $N6647, $N6649
    unless $I6650, loop6695_done
  loop6695_redo:
.annotate 'line', 2380
    find_lex $P6652, "$i"
    unless_null $P6652, vivify_3005
    new $P6652, "Undef"
  vivify_3005:
    set $I6653, $P6652
    find_lex $P6654, "$past"
    unless_null $P6654, vivify_3006
    $P6654 = root_new ['parrot';'ResizablePMCArray']
  vivify_3006:
    set $P6655, $P6654[$I6653]
    unless_null $P6655, vivify_3007
    new $P6655, "Undef"
  vivify_3007:
    $S6656 = $P6655."name"()
    iseq $I6657, $S6656, "&prefix:<|>"
    unless $I6657, if_6651_end
.annotate 'line', 2381
    find_lex $P6658, "$i"
    unless_null $P6658, vivify_3008
    new $P6658, "Undef"
  vivify_3008:
    set $I6659, $P6658
    find_lex $P6660, "$past"
    unless_null $P6660, vivify_3009
    $P6660 = root_new ['parrot';'ResizablePMCArray']
  vivify_3009:
    set $P6661, $P6660[$I6659]
    unless_null $P6661, vivify_3010
    $P6661 = root_new ['parrot';'ResizablePMCArray']
  vivify_3010:
    set $P6662, $P6661[0]
    unless_null $P6662, vivify_3011
    new $P6662, "Undef"
  vivify_3011:
    find_lex $P6663, "$i"
    unless_null $P6663, vivify_3012
    new $P6663, "Undef"
  vivify_3012:
    set $I6664, $P6663
    find_lex $P6665, "$past"
    unless_null $P6665, vivify_3013
    $P6665 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6665
  vivify_3013:
    set $P6665[$I6664], $P6662
.annotate 'line', 2382
    find_lex $P6666, "$i"
    unless_null $P6666, vivify_3014
    new $P6666, "Undef"
  vivify_3014:
    set $I6667, $P6666
    find_lex $P6668, "$past"
    unless_null $P6668, vivify_3015
    $P6668 = root_new ['parrot';'ResizablePMCArray']
  vivify_3015:
    set $P6669, $P6668[$I6667]
    unless_null $P6669, vivify_3016
    new $P6669, "Undef"
  vivify_3016:
    $P6669."flat"(1)
.annotate 'line', 2383
    find_lex $P6673, "$i"
    unless_null $P6673, vivify_3017
    new $P6673, "Undef"
  vivify_3017:
    set $I6674, $P6673
    find_lex $P6675, "$past"
    unless_null $P6675, vivify_3018
    $P6675 = root_new ['parrot';'ResizablePMCArray']
  vivify_3018:
    set $P6676, $P6675[$I6674]
    unless_null $P6676, vivify_3019
    new $P6676, "Undef"
  vivify_3019:
    get_hll_global $P6677, "GLOBAL"
    nqp_get_package_through_who $P6678, $P6677, "PAST"
    get_who $P6679, $P6678
    set $P6680, $P6679["Val"]
    $P6681 = $P6676."isa"($P6680)
    if $P6681, if_6672
    set $P6671, $P6681
    goto if_6672_end
  if_6672:
.annotate 'line', 2384
    find_lex $P6682, "$i"
    unless_null $P6682, vivify_3020
    new $P6682, "Undef"
  vivify_3020:
    set $I6683, $P6682
    find_lex $P6684, "$past"
    unless_null $P6684, vivify_3021
    $P6684 = root_new ['parrot';'ResizablePMCArray']
  vivify_3021:
    set $P6685, $P6684[$I6683]
    unless_null $P6685, vivify_3022
    new $P6685, "Undef"
  vivify_3022:
    $S6686 = $P6685."name"()
    substr $S6687, $S6686, 0, 1
    iseq $I6688, $S6687, "%"
    new $P6671, 'Integer'
    set $P6671, $I6688
  if_6672_end:
    unless $P6671, if_6670_end
.annotate 'line', 2385
    find_lex $P6689, "$i"
    unless_null $P6689, vivify_3023
    new $P6689, "Undef"
  vivify_3023:
    set $I6690, $P6689
    find_lex $P6691, "$past"
    unless_null $P6691, vivify_3024
    $P6691 = root_new ['parrot';'ResizablePMCArray']
  vivify_3024:
    set $P6692, $P6691[$I6690]
    unless_null $P6692, vivify_3025
    new $P6692, "Undef"
  vivify_3025:
    $P6692."named"(1)
  if_6670_end:
  if_6651_end:
.annotate 'line', 2380
    find_lex $P6693, "$i"
    unless_null $P6693, vivify_3026
    new $P6693, "Undef"
  vivify_3026:
    clone $P6694, $P6693
    inc $P6693
  loop6695_next:
.annotate 'line', 2379
    goto loop6695_test
  loop6695_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6697, exception, 'type'
    eq $P6697, .CONTROL_LOOP_NEXT, loop6695_next
    eq $P6697, .CONTROL_LOOP_REDO, loop6695_redo
  loop6695_done:
    pop_eh 
.annotate 'line', 2390
    find_lex $P6698, "$/"
    find_lex $P6699, "$past"
    unless_null $P6699, vivify_3027
    new $P6699, "Undef"
  vivify_3027:
    $P6700 = $P6698."!make"($P6699)
.annotate 'line', 2368
    .return ($P6700)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6608"  :anon :subid("578_1306916577.75068") :outer("577_1306916577.75068")
.annotate 'line', 2370
    .const 'Sub' $P6630 = "579_1306916577.75068" 
    capture_lex $P6630
.annotate 'line', 2371
    new $P6610, "Undef"
    .lex "$expr", $P6610
    find_lex $P6611, "$/"
    unless_null $P6611, vivify_2992
    $P6611 = root_new ['parrot';'Hash']
  vivify_2992:
    set $P6612, $P6611["EXPR"]
    unless_null $P6612, vivify_2993
    new $P6612, "Undef"
  vivify_2993:
    $P6613 = $P6612."ast"()
    store_lex "$expr", $P6613
.annotate 'line', 2372
    find_lex $P6618, "$expr"
    unless_null $P6618, vivify_2994
    new $P6618, "Undef"
  vivify_2994:
    $S6619 = $P6618."name"()
    iseq $I6620, $S6619, "&infix:<,>"
    if $I6620, if_6617
    new $P6616, 'Integer'
    set $P6616, $I6620
    goto if_6617_end
  if_6617:
    find_lex $P6621, "$expr"
    unless_null $P6621, vivify_2995
    new $P6621, "Undef"
  vivify_2995:
    $P6622 = $P6621."named"()
    isfalse $I6623, $P6622
    new $P6616, 'Integer'
    set $P6616, $I6623
  if_6617_end:
    if $P6616, if_6615
.annotate 'line', 2375
    find_lex $P6638, "$past"
    unless_null $P6638, vivify_2996
    new $P6638, "Undef"
  vivify_2996:
    find_lex $P6639, "$expr"
    unless_null $P6639, vivify_2997
    new $P6639, "Undef"
  vivify_2997:
    $P6640 = $P6638."push"($P6639)
    set $P6614, $P6640
.annotate 'line', 2372
    goto if_6615_end
  if_6615:
.annotate 'line', 2373
    find_lex $P6625, "$expr"
    unless_null $P6625, vivify_2998
    new $P6625, "Undef"
  vivify_2998:
    $P6626 = $P6625."list"()
    defined $I6627, $P6626
    unless $I6627, for_undef_2999
    iter $P6624, $P6626
    new $P6636, 'ExceptionHandler'
    set_label $P6636, loop6635_handler
    $P6636."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6636
  loop6635_test:
    unless $P6624, loop6635_done
    shift $P6628, $P6624
  loop6635_redo:
    .const 'Sub' $P6630 = "579_1306916577.75068" 
    capture_lex $P6630
    $P6630($P6628)
  loop6635_next:
    goto loop6635_test
  loop6635_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6637, exception, 'type'
    eq $P6637, .CONTROL_LOOP_NEXT, loop6635_next
    eq $P6637, .CONTROL_LOOP_REDO, loop6635_redo
  loop6635_done:
    pop_eh 
  for_undef_2999:
.annotate 'line', 2372
    set $P6614, $P6624
  if_6615_end:
.annotate 'line', 2370
    .return ($P6614)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6629"  :anon :subid("579_1306916577.75068") :outer("578_1306916577.75068")
    .param pmc param_6631
.annotate 'line', 2373
    .lex "$_", param_6631
    find_lex $P6632, "$past"
    unless_null $P6632, vivify_3000
    new $P6632, "Undef"
  vivify_3000:
    find_lex $P6633, "$_"
    unless_null $P6633, vivify_3001
    new $P6633, "Undef"
  vivify_3001:
    $P6634 = $P6632."push"($P6633)
    .return ($P6634)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>" :anon :subid("580_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6702
    .param pmc param_6703
.annotate 'line', 2393
    .lex "self", param_6702
    .lex "$/", param_6703
    find_lex $P6704, "$/"
    find_lex $P6705, "$/"
    unless_null $P6705, vivify_3028
    $P6705 = root_new ['parrot';'Hash']
  vivify_3028:
    set $P6706, $P6705["multi_declarator"]
    unless_null $P6706, vivify_3029
    new $P6706, "Undef"
  vivify_3029:
    $P6707 = $P6706."ast"()
    $P6708 = $P6704."!make"($P6707)
    .return ($P6708)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>" :anon :subid("581_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6710
    .param pmc param_6711
.annotate 'line', 2395
    .lex "self", param_6710
    .lex "$/", param_6711
    find_lex $P6712, "$/"
    find_lex $P6713, "$/"
    unless_null $P6713, vivify_3030
    $P6713 = root_new ['parrot';'Hash']
  vivify_3030:
    set $P6714, $P6713["value"]
    unless_null $P6714, vivify_3031
    new $P6714, "Undef"
  vivify_3031:
    $P6715 = $P6714."ast"()
    $P6716 = $P6712."!make"($P6715)
    .return ($P6716)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>" :anon :subid("582_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6718
    .param pmc param_6719
.annotate 'line', 2397
    .lex "self", param_6718
    .lex "$/", param_6719
.annotate 'line', 2398
    find_lex $P6720, "$/"
.annotate 'line', 2399
    find_lex $P6723, "$/"
    unless_null $P6723, vivify_3032
    $P6723 = root_new ['parrot';'Hash']
  vivify_3032:
    set $P6724, $P6723["EXPR"]
    unless_null $P6724, vivify_3033
    new $P6724, "Undef"
  vivify_3033:
    if $P6724, if_6722
.annotate 'line', 2400
    get_hll_global $P6729, "GLOBAL"
    nqp_get_package_through_who $P6730, $P6729, "PAST"
    get_who $P6731, $P6730
    set $P6732, $P6731["Op"]
    find_lex $P6733, "$/"
    unless_null $P6733, vivify_3034
    new $P6733, "Undef"
  vivify_3034:
    $P6734 = $P6732."new"("list" :named("pasttype"), $P6733 :named("node"))
    set $P6721, $P6734
.annotate 'line', 2399
    goto if_6722_end
  if_6722:
    find_lex $P6725, "$/"
    unless_null $P6725, vivify_3035
    $P6725 = root_new ['parrot';'Hash']
  vivify_3035:
    set $P6726, $P6725["EXPR"]
    unless_null $P6726, vivify_3036
    $P6726 = root_new ['parrot';'ResizablePMCArray']
  vivify_3036:
    set $P6727, $P6726[0]
    unless_null $P6727, vivify_3037
    new $P6727, "Undef"
  vivify_3037:
    $P6728 = $P6727."ast"()
    set $P6721, $P6728
  if_6722_end:
    $P6735 = $P6720."!make"($P6721)
.annotate 'line', 2397
    .return ($P6735)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>" :anon :subid("583_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6737
    .param pmc param_6738
.annotate 'line', 2403
    .lex "self", param_6737
    .lex "$/", param_6738
.annotate 'line', 2404
    new $P6739, "Undef"
    .lex "$past", $P6739
.annotate 'line', 2403
    find_lex $P6740, "$past"
    unless_null $P6740, vivify_3038
    new $P6740, "Undef"
  vivify_3038:
.annotate 'line', 2405
    find_lex $P6742, "$/"
    unless_null $P6742, vivify_3039
    $P6742 = root_new ['parrot';'Hash']
  vivify_3039:
    set $P6743, $P6742["EXPR"]
    unless_null $P6743, vivify_3040
    new $P6743, "Undef"
  vivify_3040:
    if $P6743, if_6741
.annotate 'line', 2412
    get_hll_global $P6758, "GLOBAL"
    nqp_get_package_through_who $P6759, $P6758, "PAST"
    get_who $P6760, $P6759
    set $P6761, $P6760["Op"]
    $P6762 = $P6761."new"("list" :named("pasttype"))
    store_lex "$past", $P6762
.annotate 'line', 2411
    goto if_6741_end
  if_6741:
.annotate 'line', 2406
    find_lex $P6744, "$/"
    unless_null $P6744, vivify_3041
    $P6744 = root_new ['parrot';'Hash']
  vivify_3041:
    set $P6745, $P6744["EXPR"]
    unless_null $P6745, vivify_3042
    $P6745 = root_new ['parrot';'ResizablePMCArray']
  vivify_3042:
    set $P6746, $P6745[0]
    unless_null $P6746, vivify_3043
    new $P6746, "Undef"
  vivify_3043:
    $P6747 = $P6746."ast"()
    store_lex "$past", $P6747
.annotate 'line', 2407
    find_lex $P6749, "$past"
    unless_null $P6749, vivify_3044
    new $P6749, "Undef"
  vivify_3044:
    $S6750 = $P6749."name"()
    isne $I6751, $S6750, "&infix:<,>"
    unless $I6751, if_6748_end
.annotate 'line', 2408
    get_hll_global $P6752, "GLOBAL"
    nqp_get_package_through_who $P6753, $P6752, "PAST"
    get_who $P6754, $P6753
    set $P6755, $P6754["Op"]
    find_lex $P6756, "$past"
    unless_null $P6756, vivify_3045
    new $P6756, "Undef"
  vivify_3045:
    $P6757 = $P6755."new"($P6756, "list" :named("pasttype"))
    store_lex "$past", $P6757
  if_6748_end:
  if_6741_end:
.annotate 'line', 2414
    find_lex $P6763, "$past"
    unless_null $P6763, vivify_3046
    new $P6763, "Undef"
  vivify_3046:
    $P6763."name"("&circumfix:<[ ]>")
.annotate 'line', 2415
    find_lex $P6764, "$/"
    find_lex $P6765, "$past"
    unless_null $P6765, vivify_3047
    new $P6765, "Undef"
  vivify_3047:
    $P6766 = $P6764."!make"($P6765)
.annotate 'line', 2403
    .return ($P6766)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>" :anon :subid("584_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6768
    .param pmc param_6769
.annotate 'line', 2418
    .lex "self", param_6768
    .lex "$/", param_6769
    find_lex $P6770, "$/"
    find_lex $P6771, "$/"
    unless_null $P6771, vivify_3048
    $P6771 = root_new ['parrot';'Hash']
  vivify_3048:
    set $P6772, $P6771["quote_EXPR"]
    unless_null $P6772, vivify_3049
    new $P6772, "Undef"
  vivify_3049:
    $P6773 = $P6772."ast"()
    $P6774 = $P6770."!make"($P6773)
    .return ($P6774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>" :anon :subid("585_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6776
    .param pmc param_6777
.annotate 'line', 2419
    .lex "self", param_6776
    .lex "$/", param_6777
    find_lex $P6778, "$/"
    find_lex $P6779, "$/"
    unless_null $P6779, vivify_3050
    $P6779 = root_new ['parrot';'Hash']
  vivify_3050:
    set $P6780, $P6779["quote_EXPR"]
    unless_null $P6780, vivify_3051
    new $P6780, "Undef"
  vivify_3051:
    $P6781 = $P6780."ast"()
    $P6782 = $P6778."!make"($P6781)
    .return ($P6782)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>" :anon :subid("586_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6784
    .param pmc param_6785
.annotate 'line', 2421
    .const 'Sub' $P6796 = "587_1306916577.75068" 
    capture_lex $P6796
    .lex "self", param_6784
    .lex "$/", param_6785
.annotate 'line', 2422
    find_lex $P6788, "$/"
    unless_null $P6788, vivify_3052
    $P6788 = root_new ['parrot';'Hash']
  vivify_3052:
    set $P6789, $P6788["pblock"]
    unless_null $P6789, vivify_3053
    $P6789 = root_new ['parrot';'Hash']
  vivify_3053:
    set $P6790, $P6789["blockoid"]
    unless_null $P6790, vivify_3054
    $P6790 = root_new ['parrot';'Hash']
  vivify_3054:
    set $P6791, $P6790["statementlist"]
    unless_null $P6791, vivify_3055
    $P6791 = root_new ['parrot';'Hash']
  vivify_3055:
    set $P6792, $P6791["statement"]
    unless_null $P6792, vivify_3056
    new $P6792, "Undef"
  vivify_3056:
    set $N6793, $P6792
    isgt $I6794, $N6793, 0.0
    if $I6794, if_6787
.annotate 'line', 2427
    find_lex $P6809, "$/"
    unless_null $P6809, vivify_3057
    $P6809 = root_new ['parrot';'Hash']
  vivify_3057:
    set $P6810, $P6809["pblock"]
    unless_null $P6810, vivify_3058
    $P6810 = root_new ['parrot';'Hash']
  vivify_3058:
    set $P6811, $P6810["blockoid"]
    unless_null $P6811, vivify_3059
    $P6811 = root_new ['parrot';'Hash']
  vivify_3059:
    set $P6812, $P6811["you_are_here"]
    unless_null $P6812, vivify_3060
    new $P6812, "Undef"
  vivify_3060:
    if $P6812, if_6808
.annotate 'line', 2431
    find_lex $P6818, "$/"
    $P6819 = "vivitype"("%")
    $P6820 = $P6818."!make"($P6819)
.annotate 'line', 2430
    set $P6807, $P6820
.annotate 'line', 2427
    goto if_6808_end
  if_6808:
.annotate 'line', 2428
    find_lex $P6813, "$/"
    find_lex $P6814, "$/"
    unless_null $P6814, vivify_3061
    $P6814 = root_new ['parrot';'Hash']
  vivify_3061:
    set $P6815, $P6814["pblock"]
    unless_null $P6815, vivify_3062
    new $P6815, "Undef"
  vivify_3062:
    $P6816 = $P6815."ast"()
    $P6817 = $P6813."!make"($P6816)
.annotate 'line', 2427
    set $P6807, $P6817
  if_6808_end:
    set $P6786, $P6807
.annotate 'line', 2422
    goto if_6787_end
  if_6787:
    .const 'Sub' $P6796 = "587_1306916577.75068" 
    capture_lex $P6796
    $P6806 = $P6796()
    set $P6786, $P6806
  if_6787_end:
.annotate 'line', 2421
    .return ($P6786)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6795"  :anon :subid("587_1306916577.75068") :outer("586_1306916577.75068")
.annotate 'line', 2423
    new $P6797, "Undef"
    .lex "$past", $P6797
    find_lex $P6798, "$/"
    unless_null $P6798, vivify_3063
    $P6798 = root_new ['parrot';'Hash']
  vivify_3063:
    set $P6799, $P6798["pblock"]
    unless_null $P6799, vivify_3064
    new $P6799, "Undef"
  vivify_3064:
    $P6800 = $P6799."ast"()
    store_lex "$past", $P6800
.annotate 'line', 2424
    new $P6801, "Integer"
    assign $P6801, 1
    find_lex $P6802, "$past"
    unless_null $P6802, vivify_3065
    $P6802 = root_new ['parrot';'Hash']
    store_lex "$past", $P6802
  vivify_3065:
    set $P6802["bareblock"], $P6801
.annotate 'line', 2425
    find_dynamic_lex $P6803, "$/"
    find_lex $P6804, "$past"
    unless_null $P6804, vivify_3066
    new $P6804, "Undef"
  vivify_3066:
    $P6805 = $P6803."!make"($P6804)
.annotate 'line', 2422
    .return ($P6805)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>" :anon :subid("588_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6822
    .param pmc param_6823
.annotate 'line', 2435
    .lex "self", param_6822
    .lex "$/", param_6823
.annotate 'line', 2436
    new $P6824, "Undef"
    .lex "$name", $P6824
    find_lex $P6827, "$/"
    unless_null $P6827, vivify_3067
    $P6827 = root_new ['parrot';'Hash']
  vivify_3067:
    set $P6828, $P6827["sigil"]
    unless_null $P6828, vivify_3068
    new $P6828, "Undef"
  vivify_3068:
    set $S6829, $P6828
    iseq $I6830, $S6829, "@"
    if $I6830, if_6826
.annotate 'line', 2437
    find_lex $P6834, "$/"
    unless_null $P6834, vivify_3069
    $P6834 = root_new ['parrot';'Hash']
  vivify_3069:
    set $P6835, $P6834["sigil"]
    unless_null $P6835, vivify_3070
    new $P6835, "Undef"
  vivify_3070:
    set $S6836, $P6835
    iseq $I6837, $S6836, "%"
    if $I6837, if_6833
    new $P6839, "String"
    assign $P6839, "item"
    set $P6832, $P6839
    goto if_6833_end
  if_6833:
    new $P6838, "String"
    assign $P6838, "hash"
    set $P6832, $P6838
  if_6833_end:
    set $P6825, $P6832
.annotate 'line', 2436
    goto if_6826_end
  if_6826:
    new $P6831, "String"
    assign $P6831, "list"
    set $P6825, $P6831
  if_6826_end:
    store_lex "$name", $P6825
.annotate 'line', 2439
    find_lex $P6840, "$/"
    get_hll_global $P6841, "GLOBAL"
    nqp_get_package_through_who $P6842, $P6841, "PAST"
    get_who $P6843, $P6842
    set $P6844, $P6843["Op"]
    find_lex $P6845, "$name"
    unless_null $P6845, vivify_3071
    new $P6845, "Undef"
  vivify_3071:
    find_lex $P6846, "$/"
    unless_null $P6846, vivify_3072
    $P6846 = root_new ['parrot';'Hash']
  vivify_3072:
    set $P6847, $P6846["semilist"]
    unless_null $P6847, vivify_3073
    new $P6847, "Undef"
  vivify_3073:
    $P6848 = $P6847."ast"()
    $P6849 = $P6844."new"($P6848, "callmethod" :named("pasttype"), $P6845 :named("name"))
    $P6850 = $P6840."!make"($P6849)
.annotate 'line', 2435
    .return ($P6850)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist" :anon :subid("589_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6852
    .param pmc param_6853
.annotate 'line', 2442
    .lex "self", param_6852
    .lex "$/", param_6853
    find_lex $P6854, "$/"
    find_lex $P6855, "$/"
    unless_null $P6855, vivify_3074
    $P6855 = root_new ['parrot';'Hash']
  vivify_3074:
    set $P6856, $P6855["statement"]
    unless_null $P6856, vivify_3075
    new $P6856, "Undef"
  vivify_3075:
    $P6857 = $P6856."ast"()
    $P6858 = $P6854."!make"($P6857)
    .return ($P6858)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>" :anon :subid("590_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6860
    .param pmc param_6861
.annotate 'line', 2444
    .lex "self", param_6860
    .lex "$/", param_6861
.annotate 'line', 2445
    find_lex $P6862, "$/"
    get_hll_global $P6863, "GLOBAL"
    nqp_get_package_through_who $P6864, $P6863, "PAST"
    get_who $P6865, $P6864
    set $P6866, $P6865["Var"]
    find_lex $P6867, "$/"
    unless_null $P6867, vivify_3076
    $P6867 = root_new ['parrot';'Hash']
  vivify_3076:
    set $P6868, $P6867["EXPR"]
    unless_null $P6868, vivify_3077
    new $P6868, "Undef"
  vivify_3077:
    $P6869 = $P6868."ast"()
.annotate 'line', 2447
    $P6870 = "vivitype"("@")
    $P6871 = $P6866."new"($P6869, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6870 :named("vivibase"))
.annotate 'line', 2445
    $P6872 = $P6862."!make"($P6871)
.annotate 'line', 2444
    .return ($P6872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>" :anon :subid("591_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6874
    .param pmc param_6875
.annotate 'line', 2450
    .lex "self", param_6874
    .lex "$/", param_6875
.annotate 'line', 2451
    find_lex $P6876, "$/"
    get_hll_global $P6877, "GLOBAL"
    nqp_get_package_through_who $P6878, $P6877, "PAST"
    get_who $P6879, $P6878
    set $P6880, $P6879["Var"]
    find_lex $P6881, "$/"
    unless_null $P6881, vivify_3078
    $P6881 = root_new ['parrot';'Hash']
  vivify_3078:
    set $P6882, $P6881["EXPR"]
    unless_null $P6882, vivify_3079
    new $P6882, "Undef"
  vivify_3079:
    $P6883 = $P6882."ast"()
.annotate 'line', 2453
    $P6884 = "vivitype"("%")
    $P6885 = $P6880."new"($P6883, "keyed" :named("scope"), "Undef" :named("viviself"), $P6884 :named("vivibase"))
.annotate 'line', 2451
    $P6886 = $P6876."!make"($P6885)
.annotate 'line', 2450
    .return ($P6886)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>" :anon :subid("592_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6888
    .param pmc param_6889
.annotate 'line', 2456
    .lex "self", param_6888
    .lex "$/", param_6889
.annotate 'line', 2457
    find_lex $P6890, "$/"
    get_hll_global $P6891, "GLOBAL"
    nqp_get_package_through_who $P6892, $P6891, "PAST"
    get_who $P6893, $P6892
    set $P6894, $P6893["Var"]
    find_lex $P6895, "$/"
    unless_null $P6895, vivify_3080
    $P6895 = root_new ['parrot';'Hash']
  vivify_3080:
    set $P6896, $P6895["quote_EXPR"]
    unless_null $P6896, vivify_3081
    new $P6896, "Undef"
  vivify_3081:
    $P6897 = $P6896."ast"()
.annotate 'line', 2459
    $P6898 = "vivitype"("%")
    $P6899 = $P6894."new"($P6897, "keyed" :named("scope"), "Undef" :named("viviself"), $P6898 :named("vivibase"))
.annotate 'line', 2457
    $P6900 = $P6890."!make"($P6899)
.annotate 'line', 2456
    .return ($P6900)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>" :anon :subid("593_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6902
    .param pmc param_6903
.annotate 'line', 2462
    .lex "self", param_6902
    .lex "$/", param_6903
.annotate 'line', 2463
    find_lex $P6904, "$/"
    find_lex $P6905, "$/"
    unless_null $P6905, vivify_3082
    $P6905 = root_new ['parrot';'Hash']
  vivify_3082:
    set $P6906, $P6905["arglist"]
    unless_null $P6906, vivify_3083
    new $P6906, "Undef"
  vivify_3083:
    $P6907 = $P6906."ast"()
    $P6908 = $P6904."!make"($P6907)
.annotate 'line', 2462
    .return ($P6908)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value" :anon :subid("594_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6910
    .param pmc param_6911
.annotate 'line', 2466
    .lex "self", param_6910
    .lex "$/", param_6911
.annotate 'line', 2467
    find_lex $P6912, "$/"
    find_lex $P6915, "$/"
    unless_null $P6915, vivify_3084
    $P6915 = root_new ['parrot';'Hash']
  vivify_3084:
    set $P6916, $P6915["quote"]
    unless_null $P6916, vivify_3085
    new $P6916, "Undef"
  vivify_3085:
    if $P6916, if_6914
    find_lex $P6920, "$/"
    unless_null $P6920, vivify_3086
    $P6920 = root_new ['parrot';'Hash']
  vivify_3086:
    set $P6921, $P6920["number"]
    unless_null $P6921, vivify_3087
    new $P6921, "Undef"
  vivify_3087:
    $P6922 = $P6921."ast"()
    set $P6913, $P6922
    goto if_6914_end
  if_6914:
    find_lex $P6917, "$/"
    unless_null $P6917, vivify_3088
    $P6917 = root_new ['parrot';'Hash']
  vivify_3088:
    set $P6918, $P6917["quote"]
    unless_null $P6918, vivify_3089
    new $P6918, "Undef"
  vivify_3089:
    $P6919 = $P6918."ast"()
    set $P6913, $P6919
  if_6914_end:
    $P6923 = $P6912."!make"($P6913)
.annotate 'line', 2466
    .return ($P6923)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number" :anon :subid("595_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6925
    .param pmc param_6926
.annotate 'line', 2470
    .lex "self", param_6925
    .lex "$/", param_6926
.annotate 'line', 2471
    new $P6927, "Undef"
    .lex "$value", $P6927
    find_lex $P6930, "$/"
    unless_null $P6930, vivify_3090
    $P6930 = root_new ['parrot';'Hash']
  vivify_3090:
    set $P6931, $P6930["dec_number"]
    unless_null $P6931, vivify_3091
    new $P6931, "Undef"
  vivify_3091:
    if $P6931, if_6929
    find_lex $P6935, "$/"
    unless_null $P6935, vivify_3092
    $P6935 = root_new ['parrot';'Hash']
  vivify_3092:
    set $P6936, $P6935["integer"]
    unless_null $P6936, vivify_3093
    new $P6936, "Undef"
  vivify_3093:
    $P6937 = $P6936."ast"()
    set $P6928, $P6937
    goto if_6929_end
  if_6929:
    find_lex $P6932, "$/"
    unless_null $P6932, vivify_3094
    $P6932 = root_new ['parrot';'Hash']
  vivify_3094:
    set $P6933, $P6932["dec_number"]
    unless_null $P6933, vivify_3095
    new $P6933, "Undef"
  vivify_3095:
    $P6934 = $P6933."ast"()
    set $P6928, $P6934
  if_6929_end:
    store_lex "$value", $P6928
.annotate 'line', 2472
    find_lex $P6939, "$/"
    unless_null $P6939, vivify_3096
    $P6939 = root_new ['parrot';'Hash']
  vivify_3096:
    set $P6940, $P6939["sign"]
    unless_null $P6940, vivify_3097
    new $P6940, "Undef"
  vivify_3097:
    set $S6941, $P6940
    iseq $I6942, $S6941, "-"
    unless $I6942, if_6938_end
    find_lex $P6943, "$value"
    unless_null $P6943, vivify_3098
    new $P6943, "Undef"
  vivify_3098:
    neg $P6944, $P6943
    store_lex "$value", $P6944
  if_6938_end:
.annotate 'line', 2473
    find_lex $P6945, "$/"
    get_hll_global $P6946, "GLOBAL"
    nqp_get_package_through_who $P6947, $P6946, "PAST"
    get_who $P6948, $P6947
    set $P6949, $P6948["Val"]
    find_lex $P6950, "$value"
    unless_null $P6950, vivify_3099
    new $P6950, "Undef"
  vivify_3099:
    $P6951 = $P6949."new"($P6950 :named("value"))
    $P6952 = $P6945."!make"($P6951)
.annotate 'line', 2470
    .return ($P6952)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>" :anon :subid("596_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6954
    .param pmc param_6955
.annotate 'line', 2476
    .lex "self", param_6954
    .lex "$/", param_6955
    find_lex $P6956, "$/"
    find_lex $P6957, "$/"
    unless_null $P6957, vivify_3100
    $P6957 = root_new ['parrot';'Hash']
  vivify_3100:
    set $P6958, $P6957["quote_EXPR"]
    unless_null $P6958, vivify_3101
    new $P6958, "Undef"
  vivify_3101:
    $P6959 = $P6958."ast"()
    $P6960 = $P6956."!make"($P6959)
    .return ($P6960)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>" :anon :subid("597_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6962
    .param pmc param_6963
.annotate 'line', 2477
    .lex "self", param_6962
    .lex "$/", param_6963
    find_lex $P6964, "$/"
    find_lex $P6965, "$/"
    unless_null $P6965, vivify_3102
    $P6965 = root_new ['parrot';'Hash']
  vivify_3102:
    set $P6966, $P6965["quote_EXPR"]
    unless_null $P6966, vivify_3103
    new $P6966, "Undef"
  vivify_3103:
    $P6967 = $P6966."ast"()
    $P6968 = $P6964."!make"($P6967)
    .return ($P6968)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>" :anon :subid("598_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6970
    .param pmc param_6971
.annotate 'line', 2478
    .lex "self", param_6970
    .lex "$/", param_6971
    find_lex $P6972, "$/"
    find_lex $P6973, "$/"
    unless_null $P6973, vivify_3104
    $P6973 = root_new ['parrot';'Hash']
  vivify_3104:
    set $P6974, $P6973["quote_EXPR"]
    unless_null $P6974, vivify_3105
    new $P6974, "Undef"
  vivify_3105:
    $P6975 = $P6974."ast"()
    $P6976 = $P6972."!make"($P6975)
    .return ($P6976)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>" :anon :subid("599_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6978
    .param pmc param_6979
.annotate 'line', 2479
    .lex "self", param_6978
    .lex "$/", param_6979
    find_lex $P6980, "$/"
    find_lex $P6981, "$/"
    unless_null $P6981, vivify_3106
    $P6981 = root_new ['parrot';'Hash']
  vivify_3106:
    set $P6982, $P6981["quote_EXPR"]
    unless_null $P6982, vivify_3107
    new $P6982, "Undef"
  vivify_3107:
    $P6983 = $P6982."ast"()
    $P6984 = $P6980."!make"($P6983)
    .return ($P6984)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>" :anon :subid("600_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6986
    .param pmc param_6987
.annotate 'line', 2480
    .lex "self", param_6986
    .lex "$/", param_6987
    find_lex $P6988, "$/"
    find_lex $P6989, "$/"
    unless_null $P6989, vivify_3108
    $P6989 = root_new ['parrot';'Hash']
  vivify_3108:
    set $P6990, $P6989["quote_EXPR"]
    unless_null $P6990, vivify_3109
    new $P6990, "Undef"
  vivify_3109:
    $P6991 = $P6990."ast"()
    $P6992 = $P6988."!make"($P6991)
    .return ($P6992)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>" :anon :subid("601_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_6994
    .param pmc param_6995
.annotate 'line', 2481
    .lex "self", param_6994
    .lex "$/", param_6995
.annotate 'line', 2482
    find_lex $P6996, "$/"
    get_hll_global $P6997, "GLOBAL"
    nqp_get_package_through_who $P6998, $P6997, "PAST"
    get_who $P6999, $P6998
    set $P7000, $P6999["Op"]
    find_lex $P7001, "$/"
    unless_null $P7001, vivify_3110
    $P7001 = root_new ['parrot';'Hash']
  vivify_3110:
    set $P7002, $P7001["quote_EXPR"]
    unless_null $P7002, vivify_3111
    new $P7002, "Undef"
  vivify_3111:
    $P7003 = $P7002."ast"()
    $P7004 = $P7003."value"()
    find_lex $P7005, "$/"
    unless_null $P7005, vivify_3112
    new $P7005, "Undef"
  vivify_3112:
    $P7006 = $P7000."new"($P7004 :named("inline"), "inline" :named("pasttype"), $P7005 :named("node"))
    $P7007 = $P6996."!make"($P7006)
.annotate 'line', 2481
    .return ($P7007)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />" :anon :subid("602_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7011
    .param pmc param_7012
    .param pmc param_7013 :optional
    .param int has_param_7013 :opt_flag
.annotate 'line', 2487
    new $P7010, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P7010, control_7009
    push_eh $P7010
    .lex "self", param_7011
    .lex "$/", param_7012
    if has_param_7013, optparam_3113
    new $P7014, "Undef"
    set param_7013, $P7014
  optparam_3113:
    .lex "$key", param_7013
.annotate 'line', 2494
    new $P7015, "Undef"
    .lex "$regex", $P7015
.annotate 'line', 2496
    new $P7016, "Undef"
    .lex "$past", $P7016
.annotate 'line', 2488
    find_lex $P7018, "$key"
    unless_null $P7018, vivify_3114
    new $P7018, "Undef"
  vivify_3114:
    set $S7019, $P7018
    iseq $I7020, $S7019, "open"
    unless $I7020, if_7017_end
.annotate 'line', 2489
    null $P7021
    get_hll_global $P7022, "GLOBAL"
    nqp_get_package_through_who $P7023, $P7022, "Regex"
    nqp_get_package_through_who $P7024, $P7023, "P6Regex"
    nqp_get_package_through_who $P7025, $P7024, "Actions"
    get_who $P7026, $P7025
    set $P7026["$REGEXNAME"], $P7021
.annotate 'line', 2490
    find_lex $P7027, "$?PACKAGE"
    get_who $P7028, $P7027
    set $P7029, $P7028["@BLOCK"]
    unless_null $P7029, vivify_3115
    $P7029 = root_new ['parrot';'ResizablePMCArray']
  vivify_3115:
    set $P7030, $P7029[0]
    unless_null $P7030, vivify_3116
    new $P7030, "Undef"
  vivify_3116:
    $P7030."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2491
    find_lex $P7031, "$?PACKAGE"
    get_who $P7032, $P7031
    set $P7033, $P7032["@BLOCK"]
    unless_null $P7033, vivify_3117
    $P7033 = root_new ['parrot';'ResizablePMCArray']
  vivify_3117:
    set $P7034, $P7033[0]
    unless_null $P7034, vivify_3118
    new $P7034, "Undef"
  vivify_3118:
    $P7034."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2492
    new $P7035, "Exception"
    set $P7035['type'], .CONTROL_RETURN
    new $P7036, "Integer"
    assign $P7036, 0
    setattribute $P7035, 'payload', $P7036
    throw $P7035
  if_7017_end:
.annotate 'line', 2495
    get_hll_global $P7037, "GLOBAL"
    nqp_get_package_through_who $P7038, $P7037, "Regex"
    nqp_get_package_through_who $P7039, $P7038, "P6Regex"
    nqp_get_package_through_who $P7040, $P7039, "Actions"
    get_who $P7041, $P7040
    set $P7042, $P7041["buildsub"]
    find_lex $P7043, "$/"
    unless_null $P7043, vivify_3119
    $P7043 = root_new ['parrot';'Hash']
  vivify_3119:
    set $P7044, $P7043["p6regex"]
    unless_null $P7044, vivify_3120
    new $P7044, "Undef"
  vivify_3120:
    $P7045 = $P7044."ast"()
    find_lex $P7046, "$?PACKAGE"
    get_who $P7047, $P7046
    set $P7048, $P7047["@BLOCK"]
    unless_null $P7048, vivify_3121
    $P7048 = root_new ['parrot';'ResizablePMCArray']
  vivify_3121:
    $P7049 = $P7048."shift"()
    $P7050 = $P7042($P7045, $P7049)
    store_lex "$regex", $P7050
.annotate 'line', 2497
    get_hll_global $P7051, "GLOBAL"
    nqp_get_package_through_who $P7052, $P7051, "PAST"
    get_who $P7053, $P7052
    set $P7054, $P7053["Op"]
.annotate 'line', 2499
    new $P7055, "ResizablePMCArray"
    push $P7055, "Regex"
    push $P7055, "Regex"
    find_lex $P7056, "$/"
    unless_null $P7056, vivify_3122
    new $P7056, "Undef"
  vivify_3122:
    $P7057 = "lexical_package_lookup"($P7055, $P7056)
    find_lex $P7058, "$regex"
    unless_null $P7058, vivify_3123
    new $P7058, "Undef"
  vivify_3123:
    $P7059 = $P7054."new"($P7057, $P7058, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2497
    store_lex "$past", $P7059
.annotate 'line', 2503
    find_lex $P7060, "$regex"
    unless_null $P7060, vivify_3124
    new $P7060, "Undef"
  vivify_3124:
    find_lex $P7061, "$past"
    unless_null $P7061, vivify_3125
    $P7061 = root_new ['parrot';'Hash']
    store_lex "$past", $P7061
  vivify_3125:
    set $P7061["sink"], $P7060
.annotate 'line', 2504
    find_lex $P7062, "$/"
    find_lex $P7063, "$past"
    unless_null $P7063, vivify_3126
    new $P7063, "Undef"
  vivify_3126:
    $P7064 = $P7062."!make"($P7063)
.annotate 'line', 2487
    .return ($P7064)
  control_7009:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P7065, exception, "payload"
    .return ($P7065)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>" :anon :subid("603_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7067
    .param pmc param_7068
.annotate 'line', 2507
    .lex "self", param_7067
    .lex "$/", param_7068
    find_lex $P7069, "$/"
    find_lex $P7070, "$/"
    unless_null $P7070, vivify_3127
    $P7070 = root_new ['parrot';'Hash']
  vivify_3127:
    set $P7071, $P7070["variable"]
    unless_null $P7071, vivify_3128
    new $P7071, "Undef"
  vivify_3128:
    $P7072 = $P7071."ast"()
    $P7073 = $P7069."!make"($P7072)
    .return ($P7073)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>" :anon :subid("604_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7075
    .param pmc param_7076
.annotate 'line', 2508
    .lex "self", param_7075
    .lex "$/", param_7076
.annotate 'line', 2509
    find_lex $P7077, "$/"
    get_hll_global $P7078, "GLOBAL"
    nqp_get_package_through_who $P7079, $P7078, "PAST"
    get_who $P7080, $P7079
    set $P7081, $P7080["Op"]
.annotate 'line', 2510
    find_lex $P7082, "$/"
    unless_null $P7082, vivify_3129
    $P7082 = root_new ['parrot';'Hash']
  vivify_3129:
    set $P7083, $P7082["block"]
    unless_null $P7083, vivify_3130
    new $P7083, "Undef"
  vivify_3130:
    $P7084 = $P7083."ast"()
    $P7085 = "block_immediate"($P7084)
    find_lex $P7086, "$/"
    unless_null $P7086, vivify_3131
    new $P7086, "Undef"
  vivify_3131:
    $P7087 = $P7081."new"($P7085, "set S*" :named("pirop"), $P7086 :named("node"))
.annotate 'line', 2509
    $P7088 = $P7077."!make"($P7087)
.annotate 'line', 2508
    .return ($P7088)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>" :anon :subid("605_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7090
    .param pmc param_7091
.annotate 'line', 2513
    .lex "self", param_7090
    .lex "$/", param_7091
    find_lex $P7092, "$/"
    $P7093 = $P7092."!make"("\e")
    .return ($P7093)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>" :anon :subid("606_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7095
    .param pmc param_7096
.annotate 'line', 2517
    .lex "self", param_7095
    .lex "$/", param_7096
    find_lex $P7097, "$/"
    find_lex $P7098, "$/"
    unless_null $P7098, vivify_3132
    $P7098 = root_new ['parrot';'Hash']
  vivify_3132:
    set $P7099, $P7098["dotty"]
    unless_null $P7099, vivify_3133
    new $P7099, "Undef"
  vivify_3133:
    $P7100 = $P7099."ast"()
    $P7101 = $P7097."!make"($P7100)
    .return ($P7101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>" :anon :subid("607_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7103
    .param pmc param_7104
.annotate 'line', 2519
    .lex "self", param_7103
    .lex "$/", param_7104
.annotate 'line', 2520
    find_lex $P7105, "$/"
    get_hll_global $P7106, "GLOBAL"
    nqp_get_package_through_who $P7107, $P7106, "PAST"
    get_who $P7108, $P7107
    set $P7109, $P7108["Op"]
.annotate 'line', 2521
    new $P7110, "ResizablePMCArray"
    push $P7110, "    clone %r, %0"
    push $P7110, "    inc %0"
    $P7111 = $P7109."new"("postfix:<++>" :named("name"), $P7110 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2520
    $P7112 = $P7105."!make"($P7111)
.annotate 'line', 2519
    .return ($P7112)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->" :anon :subid("608_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7114
    .param pmc param_7115
.annotate 'line', 2525
    .lex "self", param_7114
    .lex "$/", param_7115
.annotate 'line', 2526
    find_lex $P7116, "$/"
    get_hll_global $P7117, "GLOBAL"
    nqp_get_package_through_who $P7118, $P7117, "PAST"
    get_who $P7119, $P7118
    set $P7120, $P7119["Op"]
.annotate 'line', 2527
    new $P7121, "ResizablePMCArray"
    push $P7121, "    clone %r, %0"
    push $P7121, "    dec %0"
    $P7122 = $P7120."new"("postfix:<-->" :named("name"), $P7121 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2526
    $P7123 = $P7116."!make"($P7122)
.annotate 'line', 2525
    .return ($P7123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>" :anon :subid("609_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7125
    .param pmc param_7126
.annotate 'line', 2531
    .lex "self", param_7125
    .lex "$/", param_7126
.annotate 'line', 2532
    find_lex $P7127, "$/"
    get_hll_global $P7128, "GLOBAL"
    nqp_get_package_through_who $P7129, $P7128, "PAST"
    get_who $P7130, $P7129
    set $P7131, $P7130["Op"]
.annotate 'line', 2533
    get_hll_global $P7132, "GLOBAL"
    nqp_get_package_through_who $P7133, $P7132, "PAST"
    get_who $P7134, $P7133
    set $P7135, $P7134["Var"]
    $P7136 = $P7135."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P7137, "$/"
    unless_null $P7137, vivify_3134
    new $P7137, "Undef"
  vivify_3134:
    $P7138 = $P7131."new"($P7136, "callmethod" :named("pasttype"), "!make" :named("name"), $P7137 :named("node"))
.annotate 'line', 2532
    $P7139 = $P7127."!make"($P7138)
.annotate 'line', 2531
    .return ($P7139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>" :anon :subid("610_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7142
    .param pmc param_7143
.annotate 'line', 2549
    .lex "self", param_7142
    .lex "$/", param_7143
    find_lex $P7144, "$/"
    unless_null $P7144, vivify_3135
    new $P7144, "Undef"
  vivify_3135:
    $P7145 = "control"($P7144, "CONTROL_LOOP_NEXT")
    .return ($P7145)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>" :anon :subid("611_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7147
    .param pmc param_7148
.annotate 'line', 2550
    .lex "self", param_7147
    .lex "$/", param_7148
    find_lex $P7149, "$/"
    unless_null $P7149, vivify_3136
    new $P7149, "Undef"
  vivify_3136:
    $P7150 = "control"($P7149, "CONTROL_LOOP_LAST")
    .return ($P7150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>" :anon :subid("612_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7152
    .param pmc param_7153
.annotate 'line', 2551
    .lex "self", param_7152
    .lex "$/", param_7153
    find_lex $P7154, "$/"
    unless_null $P7154, vivify_3137
    new $P7154, "Undef"
  vivify_3137:
    $P7155 = "control"($P7154, "CONTROL_LOOP_REDO")
    .return ($P7155)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>" :anon :subid("613_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7157
    .param pmc param_7158
.annotate 'line', 2553
    .lex "self", param_7157
    .lex "$/", param_7158
.annotate 'line', 2554
    find_lex $P7159, "$/"
    get_hll_global $P7160, "GLOBAL"
    nqp_get_package_through_who $P7161, $P7160, "PAST"
    get_who $P7162, $P7161
    set $P7163, $P7162["Op"]
    find_lex $P7164, "$/"
    unless_null $P7164, vivify_3138
    new $P7164, "Undef"
  vivify_3138:
    $P7165 = $P7163."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P7164 :named("node"))
    $P7166 = $P7159."!make"($P7165)
.annotate 'line', 2553
    .return ($P7166)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym" :anon :subid("614_1306916577.75068") :outer("436_1306916577.75068")
    .param pmc param_7172
    .param pmc param_7173
    .param pmc param_7174
.annotate 'line', 2631
    .const 'Sub' $P7178 = "615_1306916577.75068" 
    capture_lex $P7178
    .lex "self", param_7172
    .lex "$/", param_7173
    .lex "@name", param_7174
.annotate 'line', 2632
    new $P7175, "Undef"
    .lex "$known", $P7175
    new $P7176, "Integer"
    assign $P7176, 0
    store_lex "$known", $P7176
.annotate 'line', 2633
    .const 'Sub' $P7178 = "615_1306916577.75068" 
    capture_lex $P7178
    $P7178()
    find_lex $P7189, "$known"
    unless_null $P7189, vivify_3141
    new $P7189, "Undef"
  vivify_3141:
.annotate 'line', 2631
    .return ($P7189)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block7177"  :anon :subid("615_1306916577.75068") :outer("614_1306916577.75068")
.annotate 'line', 2633
    new $P7184, 'ExceptionHandler'
    set_label $P7184, control_7183
    $P7184."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P7184
.annotate 'line', 2634
    find_lex $P7179, "@name"
    unless_null $P7179, vivify_3139
    $P7179 = root_new ['parrot';'ResizablePMCArray']
  vivify_3139:
    find_lex $P7180, "$/"
    unless_null $P7180, vivify_3140
    new $P7180, "Undef"
  vivify_3140:
    "find_sym"($P7179, $P7180)
.annotate 'line', 2635
    new $P7181, "Integer"
    assign $P7181, 1
    store_lex "$known", $P7181
.annotate 'line', 2633
    pop_eh 
    goto skip_handler_7182
  control_7183:
    .local pmc exception 
    .get_results (exception) 
    new $P7187, 'Integer'
    set $P7187, 1
    set exception["handled"], $P7187
    set $I7188, exception["handled"]
    ne $I7188, 1, nothandled_7186
  handled_7185:
    .return (exception)
  nothandled_7186:
    rethrow exception
  skip_handler_7182:
    .return ($P7181)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7191"  :subid("616_1306916577.75068") :outer("10_1306916577.75068")
.annotate 'line', 2700
    .const 'Sub' $P7285 = "623_1306916577.75068" 
    capture_lex $P7285
    .const 'Sub' $P7271 = "622_1306916577.75068" 
    capture_lex $P7271
    .const 'Sub' $P7253 = "621_1306916577.75068" 
    capture_lex $P7253
    .const 'Sub' $P7239 = "620_1306916577.75068" 
    capture_lex $P7239
    .const 'Sub' $P7225 = "619_1306916577.75068" 
    capture_lex $P7225
    .const 'Sub' $P7211 = "618_1306916577.75068" 
    capture_lex $P7211
    .const 'Sub' $P7195 = "617_1306916577.75068" 
    capture_lex $P7195
    .lex "$?PACKAGE", $P7193
    .lex "$?CLASS", $P7194
.annotate 'line', 2734
    .const 'Sub' $P7285 = "623_1306916577.75068" 
    newclosure $P7323, $P7285
.annotate 'line', 2700
    .return ($P7323)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>" :anon :subid("617_1306916577.75068") :outer("616_1306916577.75068")
    .param pmc param_7196
    .param pmc param_7197
.annotate 'line', 2702
    .lex "self", param_7196
    .lex "$/", param_7197
.annotate 'line', 2703
    new $P7198, "Undef"
    .lex "$past", $P7198
    find_lex $P7199, "$/"
    unless_null $P7199, vivify_3142
    $P7199 = root_new ['parrot';'Hash']
  vivify_3142:
    set $P7200, $P7199["statement"]
    unless_null $P7200, vivify_3143
    new $P7200, "Undef"
  vivify_3143:
    $P7201 = $P7200."ast"()
    store_lex "$past", $P7201
.annotate 'line', 2704
    find_lex $P7202, "$/"
    get_hll_global $P7203, "GLOBAL"
    nqp_get_package_through_who $P7204, $P7203, "PAST"
    get_who $P7205, $P7204
    set $P7206, $P7205["Regex"]
    find_lex $P7207, "$past"
    unless_null $P7207, vivify_3144
    new $P7207, "Undef"
  vivify_3144:
    find_lex $P7208, "$/"
    unless_null $P7208, vivify_3145
    new $P7208, "Undef"
  vivify_3145:
    $P7209 = $P7206."new"($P7207, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P7208 :named("node"))
    $P7210 = $P7202."!make"($P7209)
.annotate 'line', 2702
    .return ($P7210)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>" :anon :subid("618_1306916577.75068") :outer("616_1306916577.75068")
    .param pmc param_7212
    .param pmc param_7213
.annotate 'line', 2708
    .lex "self", param_7212
    .lex "$/", param_7213
.annotate 'line', 2709
    find_lex $P7214, "$/"
    get_hll_global $P7215, "GLOBAL"
    nqp_get_package_through_who $P7216, $P7215, "PAST"
    get_who $P7217, $P7216
    set $P7218, $P7217["Regex"]
    find_lex $P7219, "$/"
    unless_null $P7219, vivify_3146
    $P7219 = root_new ['parrot';'Hash']
  vivify_3146:
    set $P7220, $P7219["codeblock"]
    unless_null $P7220, vivify_3147
    new $P7220, "Undef"
  vivify_3147:
    $P7221 = $P7220."ast"()
    find_lex $P7222, "$/"
    unless_null $P7222, vivify_3148
    new $P7222, "Undef"
  vivify_3148:
    $P7223 = $P7218."new"($P7221, "pastnode" :named("pasttype"), $P7222 :named("node"))
    $P7224 = $P7214."!make"($P7223)
.annotate 'line', 2708
    .return ($P7224)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>" :anon :subid("619_1306916577.75068") :outer("616_1306916577.75068")
    .param pmc param_7226
    .param pmc param_7227
.annotate 'line', 2713
    .lex "self", param_7226
    .lex "$/", param_7227
.annotate 'line', 2714
    find_lex $P7228, "$/"
    get_hll_global $P7229, "GLOBAL"
    nqp_get_package_through_who $P7230, $P7229, "PAST"
    get_who $P7231, $P7230
    set $P7232, $P7231["Regex"]
    find_lex $P7233, "$/"
    unless_null $P7233, vivify_3149
    $P7233 = root_new ['parrot';'Hash']
  vivify_3149:
    set $P7234, $P7233["var"]
    unless_null $P7234, vivify_3150
    new $P7234, "Undef"
  vivify_3150:
    $P7235 = $P7234."ast"()
    find_lex $P7236, "$/"
    unless_null $P7236, vivify_3151
    new $P7236, "Undef"
  vivify_3151:
    $P7237 = $P7232."new"("!INTERPOLATE", $P7235, "subrule" :named("pasttype"), "method" :named("subtype"), $P7236 :named("node"))
    $P7238 = $P7228."!make"($P7237)
.annotate 'line', 2713
    .return ($P7238)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>" :anon :subid("620_1306916577.75068") :outer("616_1306916577.75068")
    .param pmc param_7240
    .param pmc param_7241
.annotate 'line', 2718
    .lex "self", param_7240
    .lex "$/", param_7241
.annotate 'line', 2719
    find_lex $P7242, "$/"
    get_hll_global $P7243, "GLOBAL"
    nqp_get_package_through_who $P7244, $P7243, "PAST"
    get_who $P7245, $P7244
    set $P7246, $P7245["Regex"]
    find_lex $P7247, "$/"
    unless_null $P7247, vivify_3152
    $P7247 = root_new ['parrot';'Hash']
  vivify_3152:
    set $P7248, $P7247["codeblock"]
    unless_null $P7248, vivify_3153
    new $P7248, "Undef"
  vivify_3153:
    $P7249 = $P7248."ast"()
    find_lex $P7250, "$/"
    unless_null $P7250, vivify_3154
    new $P7250, "Undef"
  vivify_3154:
    $P7251 = $P7246."new"("!INTERPOLATE_REGEX", $P7249, "subrule" :named("pasttype"), "method" :named("subtype"), $P7250 :named("node"))
    $P7252 = $P7242."!make"($P7251)
.annotate 'line', 2718
    .return ($P7252)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>" :anon :subid("621_1306916577.75068") :outer("616_1306916577.75068")
    .param pmc param_7254
    .param pmc param_7255
.annotate 'line', 2723
    .lex "self", param_7254
    .lex "$/", param_7255
.annotate 'line', 2724
    find_lex $P7256, "$/"
    get_hll_global $P7257, "GLOBAL"
    nqp_get_package_through_who $P7258, $P7257, "PAST"
    get_who $P7259, $P7258
    set $P7260, $P7259["Regex"]
    find_lex $P7261, "$/"
    unless_null $P7261, vivify_3155
    $P7261 = root_new ['parrot';'Hash']
  vivify_3155:
    set $P7262, $P7261["codeblock"]
    unless_null $P7262, vivify_3156
    new $P7262, "Undef"
  vivify_3156:
    $P7263 = $P7262."ast"()
.annotate 'line', 2725
    find_lex $P7264, "$/"
    unless_null $P7264, vivify_3157
    $P7264 = root_new ['parrot';'Hash']
  vivify_3157:
    set $P7265, $P7264["zw"]
    unless_null $P7265, vivify_3158
    new $P7265, "Undef"
  vivify_3158:
    set $S7266, $P7265
    iseq $I7267, $S7266, "!"
    find_lex $P7268, "$/"
    unless_null $P7268, vivify_3159
    new $P7268, "Undef"
  vivify_3159:
    $P7269 = $P7260."new"($P7263, "zerowidth" :named("subtype"), $I7267 :named("negate"), "pastnode" :named("pasttype"), $P7268 :named("node"))
.annotate 'line', 2724
    $P7270 = $P7256."!make"($P7269)
.annotate 'line', 2723
    .return ($P7270)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>" :anon :subid("622_1306916577.75068") :outer("616_1306916577.75068")
    .param pmc param_7272
    .param pmc param_7273
.annotate 'line', 2729
    .lex "self", param_7272
    .lex "$/", param_7273
.annotate 'line', 2730
    find_lex $P7274, "$/"
    get_hll_global $P7275, "GLOBAL"
    nqp_get_package_through_who $P7276, $P7275, "PAST"
    get_who $P7277, $P7276
    set $P7278, $P7277["Regex"]
    find_lex $P7279, "$/"
    unless_null $P7279, vivify_3160
    $P7279 = root_new ['parrot';'Hash']
  vivify_3160:
    set $P7280, $P7279["var"]
    unless_null $P7280, vivify_3161
    new $P7280, "Undef"
  vivify_3161:
    $P7281 = $P7280."ast"()
    find_lex $P7282, "$/"
    unless_null $P7282, vivify_3162
    new $P7282, "Undef"
  vivify_3162:
    $P7283 = $P7278."new"("!INTERPOLATE_REGEX", $P7281, "subrule" :named("pasttype"), "method" :named("subtype"), $P7282 :named("node"))
    $P7284 = $P7274."!make"($P7283)
.annotate 'line', 2729
    .return ($P7284)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock" :anon :subid("623_1306916577.75068") :outer("616_1306916577.75068")
    .param pmc param_7286
    .param pmc param_7287
.annotate 'line', 2734
    .lex "self", param_7286
    .lex "$/", param_7287
.annotate 'line', 2735
    new $P7288, "Undef"
    .lex "$block", $P7288
.annotate 'line', 2737
    new $P7289, "Undef"
    .lex "$past", $P7289
.annotate 'line', 2735
    find_lex $P7290, "$/"
    unless_null $P7290, vivify_3163
    $P7290 = root_new ['parrot';'Hash']
  vivify_3163:
    set $P7291, $P7290["block"]
    unless_null $P7291, vivify_3164
    new $P7291, "Undef"
  vivify_3164:
    $P7292 = $P7291."ast"()
    store_lex "$block", $P7292
.annotate 'line', 2736
    find_lex $P7293, "$block"
    unless_null $P7293, vivify_3165
    new $P7293, "Undef"
  vivify_3165:
    $P7293."blocktype"("immediate")
.annotate 'line', 2738
    get_hll_global $P7294, "GLOBAL"
    nqp_get_package_through_who $P7295, $P7294, "PAST"
    get_who $P7296, $P7295
    set $P7297, $P7296["Stmts"]
.annotate 'line', 2739
    get_hll_global $P7298, "GLOBAL"
    nqp_get_package_through_who $P7299, $P7298, "PAST"
    get_who $P7300, $P7299
    set $P7301, $P7300["Op"]
.annotate 'line', 2740
    get_hll_global $P7302, "GLOBAL"
    nqp_get_package_through_who $P7303, $P7302, "PAST"
    get_who $P7304, $P7303
    set $P7305, $P7304["Var"]
    $P7306 = $P7305."new"("$/" :named("name"))
.annotate 'line', 2741
    get_hll_global $P7307, "GLOBAL"
    nqp_get_package_through_who $P7308, $P7307, "PAST"
    get_who $P7309, $P7308
    set $P7310, $P7309["Op"]
.annotate 'line', 2742
    get_hll_global $P7311, "GLOBAL"
    nqp_get_package_through_who $P7312, $P7311, "PAST"
    get_who $P7313, $P7312
    set $P7314, $P7313["Var"]
    $P7315 = $P7314."new"(unicode:"$\x{a2}" :named("name"))
    $P7316 = $P7310."new"($P7315, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2741
    $P7317 = $P7301."new"($P7306, $P7316, "bind" :named("pasttype"))
.annotate 'line', 2739
    find_lex $P7318, "$block"
    unless_null $P7318, vivify_3166
    new $P7318, "Undef"
  vivify_3166:
    $P7319 = $P7297."new"($P7317, $P7318)
.annotate 'line', 2738
    store_lex "$past", $P7319
.annotate 'line', 2750
    find_lex $P7320, "$/"
    find_lex $P7321, "$past"
    unless_null $P7321, vivify_3167
    new $P7321, "Undef"
  vivify_3167:
    $P7322 = $P7320."!make"($P7321)
.annotate 'line', 2734
    .return ($P7322)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7324"  :subid("624_1306916577.75068") :outer("10_1306916577.75068")
.annotate 'line', 2755
    .lex "$?PACKAGE", $P7326
    .lex "$?CLASS", $P7327
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block7339" :load :anon :subid("625_1306916577.75068")
.annotate 'line', 1
    .const 'Sub' $P7341 = "10_1306916577.75068" 
    $P7342 = $P7341()
    .return ($P7342)
.end

