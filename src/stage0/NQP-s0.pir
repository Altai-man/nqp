
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1304277427.017")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P6599 = "592_1304277427.017" 
    capture_lex $P6599
    .const 'Sub' $P6461 = "583_1304277427.017" 
    capture_lex $P6461
    .const 'Sub' $P2372 = "408_1304277427.017" 
    capture_lex $P2372
    .const 'Sub' $P2286 = "386_1304277427.017" 
    capture_lex $P2286
    .const 'Sub' $P47 = "12_1304277427.017" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1304277427.017" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2292
    .const 'Sub' $P16 = "11_1304277427.017" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1304277427.017" 
    capture_lex $P47
    $P47()
.annotate 'line', 731
    .const 'Sub' $P2286 = "386_1304277427.017" 
    capture_lex $P2286
    $P2286()
.annotate 'line', 774
    .const 'Sub' $P2372 = "408_1304277427.017" 
    capture_lex $P2372
    $P2372()
.annotate 'line', 2234
    .const 'Sub' $P6461 = "583_1304277427.017" 
    capture_lex $P6461
    $P6461()
.annotate 'line', 2289
    .const 'Sub' $P6599 = "592_1304277427.017" 
    capture_lex $P6599
    $P6599()
    find_lex $P6607, "MAIN"
    find_lex $P6610, "@ARGS"
    if $P6610, if_6609
    set $P6608, $P6610
    goto if_6609_end
  if_6609:
    .const 'Sub' $P6611 = "11_1304277427.017" 
    find_lex $P6612, "@ARGS"
    $P6613 = $P6611($P6612 :flat)
    set $P6608, $P6613
  if_6609_end:
.annotate 'line', 1
    .return ($P6608)
    .const 'Sub' $P6615 = "594_1304277427.017" 
    .return ($P6615)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post595") :outer("10_1304277427.017")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1304277427.017" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6619, "1304277414.8"
    isnull $I6620, $P6619
    if $I6620, if_6618
    .const 'Sub' $P8011 = "10_1304277427.017" 
    $P8012 = $P8011."get_lexinfo"()
    nqp_get_sc_object $P8013, "1304277414.8", 0
    $P8012."set_static_lexpad_value"("GLOBALish", $P8013)
    .const 'Sub' $P8014 = "10_1304277427.017" 
    $P8015 = $P8014."get_lexinfo"()
    $P8015."finish_static_lexpad"()
    .const 'Sub' $P8016 = "10_1304277427.017" 
    $P8017 = $P8016."get_lexinfo"()
    nqp_get_sc_object $P8018, "1304277414.8", 0
    $P8017."set_static_lexpad_value"("$?PACKAGE", $P8018)
    .const 'Sub' $P8019 = "10_1304277427.017" 
    $P8020 = $P8019."get_lexinfo"()
    $P8020."finish_static_lexpad"()
    nqp_get_sc_object $P8021, "1304277414.8", 2
    .const 'Sub' $P8022 = "13_1304277427.017" 
    copy $P8021, $P8022
    nqp_get_sc_object $P8023, "1304277414.8", 3
    .const 'Sub' $P8024 = "14_1304277427.017" 
    copy $P8023, $P8024
    nqp_get_sc_object $P8025, "1304277414.8", 4
    .const 'Sub' $P8026 = "16_1304277427.017" 
    copy $P8025, $P8026
    nqp_get_sc_object $P8027, "1304277414.8", 5
    .const 'Sub' $P8028 = "18_1304277427.017" 
    copy $P8027, $P8028
    nqp_get_sc_object $P8029, "1304277414.8", 6
    .const 'Sub' $P8030 = "20_1304277427.017" 
    copy $P8029, $P8030
    nqp_get_sc_object $P8031, "1304277414.8", 7
    .const 'Sub' $P8032 = "22_1304277427.017" 
    copy $P8031, $P8032
    nqp_get_sc_object $P8033, "1304277414.8", 8
    .const 'Sub' $P8034 = "24_1304277427.017" 
    copy $P8033, $P8034
    nqp_get_sc_object $P8035, "1304277414.8", 9
    .const 'Sub' $P8036 = "27_1304277427.017" 
    copy $P8035, $P8036
    nqp_get_sc_object $P8037, "1304277414.8", 10
    .const 'Sub' $P8038 = "30_1304277427.017" 
    copy $P8037, $P8038
    nqp_get_sc_object $P8039, "1304277414.8", 11
    .const 'Sub' $P8040 = "32_1304277427.017" 
    copy $P8039, $P8040
    nqp_get_sc_object $P8041, "1304277414.8", 12
    .const 'Sub' $P8042 = "34_1304277427.017" 
    copy $P8041, $P8042
    nqp_get_sc_object $P8043, "1304277414.8", 13
    .const 'Sub' $P8044 = "37_1304277427.017" 
    copy $P8043, $P8044
    nqp_get_sc_object $P8045, "1304277414.8", 14
    .const 'Sub' $P8046 = "39_1304277427.017" 
    copy $P8045, $P8046
    nqp_get_sc_object $P8047, "1304277414.8", 15
    .const 'Sub' $P8048 = "41_1304277427.017" 
    copy $P8047, $P8048
    nqp_get_sc_object $P8049, "1304277414.8", 16
    .const 'Sub' $P8050 = "43_1304277427.017" 
    copy $P8049, $P8050
    nqp_get_sc_object $P8051, "1304277414.8", 17
    .const 'Sub' $P8052 = "45_1304277427.017" 
    copy $P8051, $P8052
    nqp_get_sc_object $P8053, "1304277414.8", 18
    .const 'Sub' $P8054 = "47_1304277427.017" 
    copy $P8053, $P8054
    nqp_get_sc_object $P8055, "1304277414.8", 19
    .const 'Sub' $P8056 = "49_1304277427.017" 
    copy $P8055, $P8056
    nqp_get_sc_object $P8057, "1304277414.8", 20
    .const 'Sub' $P8058 = "51_1304277427.017" 
    copy $P8057, $P8058
    nqp_get_sc_object $P8059, "1304277414.8", 21
    .const 'Sub' $P8060 = "53_1304277427.017" 
    copy $P8059, $P8060
    nqp_get_sc_object $P8061, "1304277414.8", 22
    .const 'Sub' $P8062 = "55_1304277427.017" 
    copy $P8061, $P8062
    nqp_get_sc_object $P8063, "1304277414.8", 23
    .const 'Sub' $P8064 = "57_1304277427.017" 
    copy $P8063, $P8064
    nqp_get_sc_object $P8065, "1304277414.8", 24
    .const 'Sub' $P8066 = "59_1304277427.017" 
    copy $P8065, $P8066
    nqp_get_sc_object $P8067, "1304277414.8", 25
    .const 'Sub' $P8068 = "60_1304277427.017" 
    copy $P8067, $P8068
    nqp_get_sc_object $P8069, "1304277414.8", 26
    .const 'Sub' $P8070 = "61_1304277427.017" 
    copy $P8069, $P8070
    nqp_get_sc_object $P8071, "1304277414.8", 27
    .const 'Sub' $P8072 = "63_1304277427.017" 
    copy $P8071, $P8072
    nqp_get_sc_object $P8073, "1304277414.8", 28
    .const 'Sub' $P8074 = "65_1304277427.017" 
    copy $P8073, $P8074
    nqp_get_sc_object $P8075, "1304277414.8", 29
    .const 'Sub' $P8076 = "66_1304277427.017" 
    copy $P8075, $P8076
    nqp_get_sc_object $P8077, "1304277414.8", 30
    .const 'Sub' $P8078 = "67_1304277427.017" 
    copy $P8077, $P8078
    nqp_get_sc_object $P8079, "1304277414.8", 31
    .const 'Sub' $P8080 = "69_1304277427.017" 
    copy $P8079, $P8080
    nqp_get_sc_object $P8081, "1304277414.8", 32
    .const 'Sub' $P8082 = "71_1304277427.017" 
    copy $P8081, $P8082
    nqp_get_sc_object $P8083, "1304277414.8", 33
    .const 'Sub' $P8084 = "74_1304277427.017" 
    copy $P8083, $P8084
    nqp_get_sc_object $P8085, "1304277414.8", 34
    .const 'Sub' $P8086 = "76_1304277427.017" 
    copy $P8085, $P8086
    nqp_get_sc_object $P8087, "1304277414.8", 35
    .const 'Sub' $P8088 = "78_1304277427.017" 
    copy $P8087, $P8088
    nqp_get_sc_object $P8089, "1304277414.8", 36
    .const 'Sub' $P8090 = "80_1304277427.017" 
    copy $P8089, $P8090
    nqp_get_sc_object $P8091, "1304277414.8", 37
    .const 'Sub' $P8092 = "82_1304277427.017" 
    copy $P8091, $P8092
    nqp_get_sc_object $P8093, "1304277414.8", 38
    .const 'Sub' $P8094 = "84_1304277427.017" 
    copy $P8093, $P8094
    nqp_get_sc_object $P8095, "1304277414.8", 39
    .const 'Sub' $P8096 = "85_1304277427.017" 
    copy $P8095, $P8096
    nqp_get_sc_object $P8097, "1304277414.8", 40
    .const 'Sub' $P8098 = "86_1304277427.017" 
    copy $P8097, $P8098
    nqp_get_sc_object $P8099, "1304277414.8", 41
    .const 'Sub' $P8100 = "88_1304277427.017" 
    copy $P8099, $P8100
    nqp_get_sc_object $P8101, "1304277414.8", 42
    .const 'Sub' $P8102 = "90_1304277427.017" 
    copy $P8101, $P8102
    nqp_get_sc_object $P8103, "1304277414.8", 43
    .const 'Sub' $P8104 = "92_1304277427.017" 
    copy $P8103, $P8104
    nqp_get_sc_object $P8105, "1304277414.8", 44
    .const 'Sub' $P8106 = "93_1304277427.017" 
    copy $P8105, $P8106
    nqp_get_sc_object $P8107, "1304277414.8", 45
    .const 'Sub' $P8108 = "94_1304277427.017" 
    copy $P8107, $P8108
    nqp_get_sc_object $P8109, "1304277414.8", 46
    .const 'Sub' $P8110 = "96_1304277427.017" 
    copy $P8109, $P8110
    nqp_get_sc_object $P8111, "1304277414.8", 47
    .const 'Sub' $P8112 = "98_1304277427.017" 
    copy $P8111, $P8112
    nqp_get_sc_object $P8113, "1304277414.8", 48
    .const 'Sub' $P8114 = "99_1304277427.017" 
    copy $P8113, $P8114
    nqp_get_sc_object $P8115, "1304277414.8", 49
    .const 'Sub' $P8116 = "100_1304277427.017" 
    copy $P8115, $P8116
    nqp_get_sc_object $P8117, "1304277414.8", 50
    .const 'Sub' $P8118 = "102_1304277427.017" 
    copy $P8117, $P8118
    nqp_get_sc_object $P8119, "1304277414.8", 51
    .const 'Sub' $P8120 = "104_1304277427.017" 
    copy $P8119, $P8120
    nqp_get_sc_object $P8121, "1304277414.8", 52
    .const 'Sub' $P8122 = "106_1304277427.017" 
    copy $P8121, $P8122
    nqp_get_sc_object $P8123, "1304277414.8", 53
    .const 'Sub' $P8124 = "108_1304277427.017" 
    copy $P8123, $P8124
    nqp_get_sc_object $P8125, "1304277414.8", 54
    .const 'Sub' $P8126 = "110_1304277427.017" 
    copy $P8125, $P8126
    nqp_get_sc_object $P8127, "1304277414.8", 55
    .const 'Sub' $P8128 = "112_1304277427.017" 
    copy $P8127, $P8128
    nqp_get_sc_object $P8129, "1304277414.8", 56
    .const 'Sub' $P8130 = "114_1304277427.017" 
    copy $P8129, $P8130
    nqp_get_sc_object $P8131, "1304277414.8", 57
    .const 'Sub' $P8132 = "116_1304277427.017" 
    copy $P8131, $P8132
    nqp_get_sc_object $P8133, "1304277414.8", 58
    .const 'Sub' $P8134 = "118_1304277427.017" 
    copy $P8133, $P8134
    nqp_get_sc_object $P8135, "1304277414.8", 59
    .const 'Sub' $P8136 = "122_1304277427.017" 
    copy $P8135, $P8136
    nqp_get_sc_object $P8137, "1304277414.8", 60
    .const 'Sub' $P8138 = "124_1304277427.017" 
    copy $P8137, $P8138
    nqp_get_sc_object $P8139, "1304277414.8", 61
    .const 'Sub' $P8140 = "126_1304277427.017" 
    copy $P8139, $P8140
    nqp_get_sc_object $P8141, "1304277414.8", 62
    .const 'Sub' $P8142 = "128_1304277427.017" 
    copy $P8141, $P8142
    nqp_get_sc_object $P8143, "1304277414.8", 63
    .const 'Sub' $P8144 = "130_1304277427.017" 
    copy $P8143, $P8144
    nqp_get_sc_object $P8145, "1304277414.8", 64
    .const 'Sub' $P8146 = "132_1304277427.017" 
    copy $P8145, $P8146
    nqp_get_sc_object $P8147, "1304277414.8", 65
    .const 'Sub' $P8148 = "134_1304277427.017" 
    copy $P8147, $P8148
    nqp_get_sc_object $P8149, "1304277414.8", 66
    .const 'Sub' $P8150 = "136_1304277427.017" 
    copy $P8149, $P8150
    nqp_get_sc_object $P8151, "1304277414.8", 67
    .const 'Sub' $P8152 = "138_1304277427.017" 
    copy $P8151, $P8152
    nqp_get_sc_object $P8153, "1304277414.8", 68
    .const 'Sub' $P8154 = "139_1304277427.017" 
    copy $P8153, $P8154
    nqp_get_sc_object $P8155, "1304277414.8", 69
    .const 'Sub' $P8156 = "140_1304277427.017" 
    copy $P8155, $P8156
    nqp_get_sc_object $P8157, "1304277414.8", 70
    .const 'Sub' $P8158 = "142_1304277427.017" 
    copy $P8157, $P8158
    nqp_get_sc_object $P8159, "1304277414.8", 71
    .const 'Sub' $P8160 = "144_1304277427.017" 
    copy $P8159, $P8160
    nqp_get_sc_object $P8161, "1304277414.8", 72
    .const 'Sub' $P8162 = "146_1304277427.017" 
    copy $P8161, $P8162
    nqp_get_sc_object $P8163, "1304277414.8", 73
    .const 'Sub' $P8164 = "148_1304277427.017" 
    copy $P8163, $P8164
    nqp_get_sc_object $P8165, "1304277414.8", 74
    .const 'Sub' $P8166 = "150_1304277427.017" 
    copy $P8165, $P8166
    nqp_get_sc_object $P8167, "1304277414.8", 75
    .const 'Sub' $P8168 = "152_1304277427.017" 
    copy $P8167, $P8168
    nqp_get_sc_object $P8169, "1304277414.8", 76
    .const 'Sub' $P8170 = "155_1304277427.017" 
    copy $P8169, $P8170
    nqp_get_sc_object $P8171, "1304277414.8", 77
    .const 'Sub' $P8172 = "156_1304277427.017" 
    copy $P8171, $P8172
    nqp_get_sc_object $P8173, "1304277414.8", 78
    .const 'Sub' $P8174 = "157_1304277427.017" 
    copy $P8173, $P8174
    nqp_get_sc_object $P8175, "1304277414.8", 79
    .const 'Sub' $P8176 = "159_1304277427.017" 
    copy $P8175, $P8176
    nqp_get_sc_object $P8177, "1304277414.8", 80
    .const 'Sub' $P8178 = "161_1304277427.017" 
    copy $P8177, $P8178
    nqp_get_sc_object $P8179, "1304277414.8", 81
    .const 'Sub' $P8180 = "163_1304277427.017" 
    copy $P8179, $P8180
    nqp_get_sc_object $P8181, "1304277414.8", 82
    .const 'Sub' $P8182 = "165_1304277427.017" 
    copy $P8181, $P8182
    nqp_get_sc_object $P8183, "1304277414.8", 83
    .const 'Sub' $P8184 = "168_1304277427.017" 
    copy $P8183, $P8184
    nqp_get_sc_object $P8185, "1304277414.8", 84
    .const 'Sub' $P8186 = "170_1304277427.017" 
    copy $P8185, $P8186
    nqp_get_sc_object $P8187, "1304277414.8", 85
    .const 'Sub' $P8188 = "173_1304277427.017" 
    copy $P8187, $P8188
    nqp_get_sc_object $P8189, "1304277414.8", 86
    .const 'Sub' $P8190 = "174_1304277427.017" 
    copy $P8189, $P8190
    nqp_get_sc_object $P8191, "1304277414.8", 87
    .const 'Sub' $P8192 = "175_1304277427.017" 
    copy $P8191, $P8192
    nqp_get_sc_object $P8193, "1304277414.8", 88
    .const 'Sub' $P8194 = "177_1304277427.017" 
    copy $P8193, $P8194
    nqp_get_sc_object $P8195, "1304277414.8", 89
    .const 'Sub' $P8196 = "179_1304277427.017" 
    copy $P8195, $P8196
    nqp_get_sc_object $P8197, "1304277414.8", 90
    .const 'Sub' $P8198 = "181_1304277427.017" 
    copy $P8197, $P8198
    nqp_get_sc_object $P8199, "1304277414.8", 91
    .const 'Sub' $P8200 = "184_1304277427.017" 
    copy $P8199, $P8200
    nqp_get_sc_object $P8201, "1304277414.8", 92
    .const 'Sub' $P8202 = "187_1304277427.017" 
    copy $P8201, $P8202
    nqp_get_sc_object $P8203, "1304277414.8", 93
    .const 'Sub' $P8204 = "188_1304277427.017" 
    copy $P8203, $P8204
    nqp_get_sc_object $P8205, "1304277414.8", 94
    .const 'Sub' $P8206 = "189_1304277427.017" 
    copy $P8205, $P8206
    nqp_get_sc_object $P8207, "1304277414.8", 95
    .const 'Sub' $P8208 = "191_1304277427.017" 
    copy $P8207, $P8208
    nqp_get_sc_object $P8209, "1304277414.8", 96
    .const 'Sub' $P8210 = "193_1304277427.017" 
    copy $P8209, $P8210
    nqp_get_sc_object $P8211, "1304277414.8", 97
    .const 'Sub' $P8212 = "195_1304277427.017" 
    copy $P8211, $P8212
    nqp_get_sc_object $P8213, "1304277414.8", 98
    .const 'Sub' $P8214 = "198_1304277427.017" 
    copy $P8213, $P8214
    nqp_get_sc_object $P8215, "1304277414.8", 99
    .const 'Sub' $P8216 = "200_1304277427.017" 
    copy $P8215, $P8216
    nqp_get_sc_object $P8217, "1304277414.8", 100
    .const 'Sub' $P8218 = "202_1304277427.017" 
    copy $P8217, $P8218
    nqp_get_sc_object $P8219, "1304277414.8", 101
    .const 'Sub' $P8220 = "204_1304277427.017" 
    copy $P8219, $P8220
    nqp_get_sc_object $P8221, "1304277414.8", 102
    .const 'Sub' $P8222 = "206_1304277427.017" 
    copy $P8221, $P8222
    nqp_get_sc_object $P8223, "1304277414.8", 103
    .const 'Sub' $P8224 = "208_1304277427.017" 
    copy $P8223, $P8224
    nqp_get_sc_object $P8225, "1304277414.8", 104
    .const 'Sub' $P8226 = "209_1304277427.017" 
    copy $P8225, $P8226
    nqp_get_sc_object $P8227, "1304277414.8", 105
    .const 'Sub' $P8228 = "210_1304277427.017" 
    copy $P8227, $P8228
    nqp_get_sc_object $P8229, "1304277414.8", 106
    .const 'Sub' $P8230 = "212_1304277427.017" 
    copy $P8229, $P8230
    nqp_get_sc_object $P8231, "1304277414.8", 107
    .const 'Sub' $P8232 = "214_1304277427.017" 
    copy $P8231, $P8232
    nqp_get_sc_object $P8233, "1304277414.8", 108
    .const 'Sub' $P8234 = "216_1304277427.017" 
    copy $P8233, $P8234
    nqp_get_sc_object $P8235, "1304277414.8", 109
    .const 'Sub' $P8236 = "217_1304277427.017" 
    copy $P8235, $P8236
    nqp_get_sc_object $P8237, "1304277414.8", 110
    .const 'Sub' $P8238 = "218_1304277427.017" 
    copy $P8237, $P8238
    nqp_get_sc_object $P8239, "1304277414.8", 111
    .const 'Sub' $P8240 = "220_1304277427.017" 
    copy $P8239, $P8240
    nqp_get_sc_object $P8241, "1304277414.8", 112
    .const 'Sub' $P8242 = "222_1304277427.017" 
    copy $P8241, $P8242
    nqp_get_sc_object $P8243, "1304277414.8", 113
    .const 'Sub' $P8244 = "224_1304277427.017" 
    copy $P8243, $P8244
    nqp_get_sc_object $P8245, "1304277414.8", 114
    .const 'Sub' $P8246 = "226_1304277427.017" 
    copy $P8245, $P8246
    nqp_get_sc_object $P8247, "1304277414.8", 115
    .const 'Sub' $P8248 = "229_1304277427.017" 
    copy $P8247, $P8248
    nqp_get_sc_object $P8249, "1304277414.8", 116
    .const 'Sub' $P8250 = "231_1304277427.017" 
    copy $P8249, $P8250
    nqp_get_sc_object $P8251, "1304277414.8", 117
    .const 'Sub' $P8252 = "233_1304277427.017" 
    copy $P8251, $P8252
    nqp_get_sc_object $P8253, "1304277414.8", 118
    .const 'Sub' $P8254 = "235_1304277427.017" 
    copy $P8253, $P8254
    nqp_get_sc_object $P8255, "1304277414.8", 119
    .const 'Sub' $P8256 = "237_1304277427.017" 
    copy $P8255, $P8256
    nqp_get_sc_object $P8257, "1304277414.8", 120
    .const 'Sub' $P8258 = "239_1304277427.017" 
    copy $P8257, $P8258
    nqp_get_sc_object $P8259, "1304277414.8", 121
    .const 'Sub' $P8260 = "240_1304277427.017" 
    copy $P8259, $P8260
    nqp_get_sc_object $P8261, "1304277414.8", 122
    .const 'Sub' $P8262 = "241_1304277427.017" 
    copy $P8261, $P8262
    nqp_get_sc_object $P8263, "1304277414.8", 123
    .const 'Sub' $P8264 = "243_1304277427.017" 
    copy $P8263, $P8264
    nqp_get_sc_object $P8265, "1304277414.8", 124
    .const 'Sub' $P8266 = "245_1304277427.017" 
    copy $P8265, $P8266
    nqp_get_sc_object $P8267, "1304277414.8", 125
    .const 'Sub' $P8268 = "247_1304277427.017" 
    copy $P8267, $P8268
    nqp_get_sc_object $P8269, "1304277414.8", 126
    .const 'Sub' $P8270 = "249_1304277427.017" 
    copy $P8269, $P8270
    nqp_get_sc_object $P8271, "1304277414.8", 127
    .const 'Sub' $P8272 = "251_1304277427.017" 
    copy $P8271, $P8272
    nqp_get_sc_object $P8273, "1304277414.8", 128
    .const 'Sub' $P8274 = "253_1304277427.017" 
    copy $P8273, $P8274
    nqp_get_sc_object $P8275, "1304277414.8", 129
    .const 'Sub' $P8276 = "255_1304277427.017" 
    copy $P8275, $P8276
    nqp_get_sc_object $P8277, "1304277414.8", 130
    .const 'Sub' $P8278 = "257_1304277427.017" 
    copy $P8277, $P8278
    nqp_get_sc_object $P8279, "1304277414.8", 131
    .const 'Sub' $P8280 = "259_1304277427.017" 
    copy $P8279, $P8280
    nqp_get_sc_object $P8281, "1304277414.8", 132
    .const 'Sub' $P8282 = "261_1304277427.017" 
    copy $P8281, $P8282
    nqp_get_sc_object $P8283, "1304277414.8", 133
    .const 'Sub' $P8284 = "263_1304277427.017" 
    copy $P8283, $P8284
    nqp_get_sc_object $P8285, "1304277414.8", 134
    .const 'Sub' $P8286 = "265_1304277427.017" 
    copy $P8285, $P8286
    nqp_get_sc_object $P8287, "1304277414.8", 135
    .const 'Sub' $P8288 = "267_1304277427.017" 
    copy $P8287, $P8288
    nqp_get_sc_object $P8289, "1304277414.8", 136
    .const 'Sub' $P8290 = "269_1304277427.017" 
    copy $P8289, $P8290
    nqp_get_sc_object $P8291, "1304277414.8", 137
    .const 'Sub' $P8292 = "271_1304277427.017" 
    copy $P8291, $P8292
    nqp_get_sc_object $P8293, "1304277414.8", 138
    .const 'Sub' $P8294 = "273_1304277427.017" 
    copy $P8293, $P8294
    nqp_get_sc_object $P8295, "1304277414.8", 139
    .const 'Sub' $P8296 = "275_1304277427.017" 
    copy $P8295, $P8296
    nqp_get_sc_object $P8297, "1304277414.8", 140
    .const 'Sub' $P8298 = "277_1304277427.017" 
    copy $P8297, $P8298
    nqp_get_sc_object $P8299, "1304277414.8", 141
    .const 'Sub' $P8300 = "279_1304277427.017" 
    copy $P8299, $P8300
    nqp_get_sc_object $P8301, "1304277414.8", 142
    .const 'Sub' $P8302 = "281_1304277427.017" 
    copy $P8301, $P8302
    nqp_get_sc_object $P8303, "1304277414.8", 143
    .const 'Sub' $P8304 = "283_1304277427.017" 
    copy $P8303, $P8304
    nqp_get_sc_object $P8305, "1304277414.8", 144
    .const 'Sub' $P8306 = "285_1304277427.017" 
    copy $P8305, $P8306
    nqp_get_sc_object $P8307, "1304277414.8", 145
    .const 'Sub' $P8308 = "287_1304277427.017" 
    copy $P8307, $P8308
    nqp_get_sc_object $P8309, "1304277414.8", 146
    .const 'Sub' $P8310 = "289_1304277427.017" 
    copy $P8309, $P8310
    nqp_get_sc_object $P8311, "1304277414.8", 147
    .const 'Sub' $P8312 = "291_1304277427.017" 
    copy $P8311, $P8312
    nqp_get_sc_object $P8313, "1304277414.8", 148
    .const 'Sub' $P8314 = "293_1304277427.017" 
    copy $P8313, $P8314
    nqp_get_sc_object $P8315, "1304277414.8", 149
    .const 'Sub' $P8316 = "295_1304277427.017" 
    copy $P8315, $P8316
    nqp_get_sc_object $P8317, "1304277414.8", 150
    .const 'Sub' $P8318 = "297_1304277427.017" 
    copy $P8317, $P8318
    nqp_get_sc_object $P8319, "1304277414.8", 151
    .const 'Sub' $P8320 = "299_1304277427.017" 
    copy $P8319, $P8320
    nqp_get_sc_object $P8321, "1304277414.8", 152
    .const 'Sub' $P8322 = "301_1304277427.017" 
    copy $P8321, $P8322
    nqp_get_sc_object $P8323, "1304277414.8", 153
    .const 'Sub' $P8324 = "303_1304277427.017" 
    copy $P8323, $P8324
    nqp_get_sc_object $P8325, "1304277414.8", 154
    .const 'Sub' $P8326 = "305_1304277427.017" 
    copy $P8325, $P8326
    nqp_get_sc_object $P8327, "1304277414.8", 155
    .const 'Sub' $P8328 = "307_1304277427.017" 
    copy $P8327, $P8328
    nqp_get_sc_object $P8329, "1304277414.8", 156
    .const 'Sub' $P8330 = "309_1304277427.017" 
    copy $P8329, $P8330
    nqp_get_sc_object $P8331, "1304277414.8", 157
    .const 'Sub' $P8332 = "311_1304277427.017" 
    copy $P8331, $P8332
    nqp_get_sc_object $P8333, "1304277414.8", 158
    .const 'Sub' $P8334 = "313_1304277427.017" 
    copy $P8333, $P8334
    nqp_get_sc_object $P8335, "1304277414.8", 159
    .const 'Sub' $P8336 = "315_1304277427.017" 
    copy $P8335, $P8336
    nqp_get_sc_object $P8337, "1304277414.8", 160
    .const 'Sub' $P8338 = "317_1304277427.017" 
    copy $P8337, $P8338
    nqp_get_sc_object $P8339, "1304277414.8", 161
    .const 'Sub' $P8340 = "319_1304277427.017" 
    copy $P8339, $P8340
    nqp_get_sc_object $P8341, "1304277414.8", 162
    .const 'Sub' $P8342 = "321_1304277427.017" 
    copy $P8341, $P8342
    nqp_get_sc_object $P8343, "1304277414.8", 163
    .const 'Sub' $P8344 = "323_1304277427.017" 
    copy $P8343, $P8344
    nqp_get_sc_object $P8345, "1304277414.8", 164
    .const 'Sub' $P8346 = "325_1304277427.017" 
    copy $P8345, $P8346
    nqp_get_sc_object $P8347, "1304277414.8", 165
    .const 'Sub' $P8348 = "327_1304277427.017" 
    copy $P8347, $P8348
    nqp_get_sc_object $P8349, "1304277414.8", 166
    .const 'Sub' $P8350 = "329_1304277427.017" 
    copy $P8349, $P8350
    nqp_get_sc_object $P8351, "1304277414.8", 167
    .const 'Sub' $P8352 = "331_1304277427.017" 
    copy $P8351, $P8352
    nqp_get_sc_object $P8353, "1304277414.8", 168
    .const 'Sub' $P8354 = "333_1304277427.017" 
    copy $P8353, $P8354
    nqp_get_sc_object $P8355, "1304277414.8", 169
    .const 'Sub' $P8356 = "335_1304277427.017" 
    copy $P8355, $P8356
    nqp_get_sc_object $P8357, "1304277414.8", 170
    .const 'Sub' $P8358 = "337_1304277427.017" 
    copy $P8357, $P8358
    nqp_get_sc_object $P8359, "1304277414.8", 171
    .const 'Sub' $P8360 = "339_1304277427.017" 
    copy $P8359, $P8360
    nqp_get_sc_object $P8361, "1304277414.8", 172
    .const 'Sub' $P8362 = "341_1304277427.017" 
    copy $P8361, $P8362
    nqp_get_sc_object $P8363, "1304277414.8", 173
    .const 'Sub' $P8364 = "343_1304277427.017" 
    copy $P8363, $P8364
    nqp_get_sc_object $P8365, "1304277414.8", 174
    .const 'Sub' $P8366 = "345_1304277427.017" 
    copy $P8365, $P8366
    nqp_get_sc_object $P8367, "1304277414.8", 175
    .const 'Sub' $P8368 = "347_1304277427.017" 
    copy $P8367, $P8368
    nqp_get_sc_object $P8369, "1304277414.8", 176
    .const 'Sub' $P8370 = "349_1304277427.017" 
    copy $P8369, $P8370
    nqp_get_sc_object $P8371, "1304277414.8", 177
    .const 'Sub' $P8372 = "351_1304277427.017" 
    copy $P8371, $P8372
    nqp_get_sc_object $P8373, "1304277414.8", 178
    .const 'Sub' $P8374 = "353_1304277427.017" 
    copy $P8373, $P8374
    nqp_get_sc_object $P8375, "1304277414.8", 179
    .const 'Sub' $P8376 = "355_1304277427.017" 
    copy $P8375, $P8376
    nqp_get_sc_object $P8377, "1304277414.8", 180
    .const 'Sub' $P8378 = "357_1304277427.017" 
    copy $P8377, $P8378
    nqp_get_sc_object $P8379, "1304277414.8", 181
    .const 'Sub' $P8380 = "359_1304277427.017" 
    copy $P8379, $P8380
    nqp_get_sc_object $P8381, "1304277414.8", 182
    .const 'Sub' $P8382 = "361_1304277427.017" 
    copy $P8381, $P8382
    nqp_get_sc_object $P8383, "1304277414.8", 183
    .const 'Sub' $P8384 = "363_1304277427.017" 
    copy $P8383, $P8384
    nqp_get_sc_object $P8385, "1304277414.8", 184
    .const 'Sub' $P8386 = "365_1304277427.017" 
    copy $P8385, $P8386
    nqp_get_sc_object $P8387, "1304277414.8", 185
    .const 'Sub' $P8388 = "367_1304277427.017" 
    copy $P8387, $P8388
    nqp_get_sc_object $P8389, "1304277414.8", 186
    .const 'Sub' $P8390 = "369_1304277427.017" 
    copy $P8389, $P8390
    nqp_get_sc_object $P8391, "1304277414.8", 187
    .const 'Sub' $P8392 = "371_1304277427.017" 
    copy $P8391, $P8392
    nqp_get_sc_object $P8393, "1304277414.8", 188
    .const 'Sub' $P8394 = "373_1304277427.017" 
    copy $P8393, $P8394
    nqp_get_sc_object $P8395, "1304277414.8", 189
    .const 'Sub' $P8396 = "376_1304277427.017" 
    copy $P8395, $P8396
    nqp_get_sc_object $P8397, "1304277414.8", 190
    .const 'Sub' $P8398 = "378_1304277427.017" 
    copy $P8397, $P8398
    nqp_get_sc_object $P8399, "1304277414.8", 191
    .const 'Sub' $P8400 = "380_1304277427.017" 
    copy $P8399, $P8400
    nqp_get_sc_object $P8401, "1304277414.8", 192
    .const 'Sub' $P8402 = "382_1304277427.017" 
    copy $P8401, $P8402
    nqp_get_sc_object $P8403, "1304277414.8", 193
    .const 'Sub' $P8404 = "384_1304277427.017" 
    copy $P8403, $P8404
    .const 'Sub' $P8405 = "12_1304277427.017" 
    $P8406 = $P8405."get_lexinfo"()
    nqp_get_sc_object $P8407, "1304277414.8", 1
    $P8406."set_static_lexpad_value"("$?PACKAGE", $P8407)
    .const 'Sub' $P8408 = "12_1304277427.017" 
    $P8409 = $P8408."get_lexinfo"()
    $P8409."finish_static_lexpad"()
    .const 'Sub' $P8410 = "12_1304277427.017" 
    $P8411 = $P8410."get_lexinfo"()
    nqp_get_sc_object $P8412, "1304277414.8", 1
    $P8411."set_static_lexpad_value"("$?CLASS", $P8412)
    .const 'Sub' $P8413 = "12_1304277427.017" 
    $P8414 = $P8413."get_lexinfo"()
    $P8414."finish_static_lexpad"()
    nqp_get_sc_object $P8415, "1304277414.8", 195
    .const 'Sub' $P8416 = "387_1304277427.017" 
    copy $P8415, $P8416
    nqp_get_sc_object $P8417, "1304277414.8", 196
    .const 'Sub' $P8418 = "390_1304277427.017" 
    copy $P8417, $P8418
    nqp_get_sc_object $P8419, "1304277414.8", 197
    .const 'Sub' $P8420 = "392_1304277427.017" 
    copy $P8419, $P8420
    nqp_get_sc_object $P8421, "1304277414.8", 198
    .const 'Sub' $P8422 = "395_1304277427.017" 
    copy $P8421, $P8422
    nqp_get_sc_object $P8423, "1304277414.8", 199
    .const 'Sub' $P8424 = "397_1304277427.017" 
    copy $P8423, $P8424
    nqp_get_sc_object $P8425, "1304277414.8", 200
    .const 'Sub' $P8426 = "400_1304277427.017" 
    copy $P8425, $P8426
    nqp_get_sc_object $P8427, "1304277414.8", 201
    .const 'Sub' $P8428 = "403_1304277427.017" 
    copy $P8427, $P8428
    nqp_get_sc_object $P8429, "1304277414.8", 202
    .const 'Sub' $P8430 = "405_1304277427.017" 
    copy $P8429, $P8430
    .const 'Sub' $P8431 = "386_1304277427.017" 
    $P8432 = $P8431."get_lexinfo"()
    nqp_get_sc_object $P8433, "1304277414.8", 194
    $P8432."set_static_lexpad_value"("$?PACKAGE", $P8433)
    .const 'Sub' $P8434 = "386_1304277427.017" 
    $P8435 = $P8434."get_lexinfo"()
    $P8435."finish_static_lexpad"()
    .const 'Sub' $P8436 = "386_1304277427.017" 
    $P8437 = $P8436."get_lexinfo"()
    nqp_get_sc_object $P8438, "1304277414.8", 194
    $P8437."set_static_lexpad_value"("$?CLASS", $P8438)
    .const 'Sub' $P8439 = "386_1304277427.017" 
    $P8440 = $P8439."get_lexinfo"()
    $P8440."finish_static_lexpad"()
    nqp_get_sc_object $P8441, "1304277414.8", 204
    .const 'Sub' $P8442 = "435_1304277427.017" 
    copy $P8441, $P8442
    nqp_get_sc_object $P8443, "1304277414.8", 205
    .const 'Sub' $P8444 = "436_1304277427.017" 
    copy $P8443, $P8444
    nqp_get_sc_object $P8445, "1304277414.8", 206
    .const 'Sub' $P8446 = "437_1304277427.017" 
    copy $P8445, $P8446
    nqp_get_sc_object $P8447, "1304277414.8", 207
    .const 'Sub' $P8448 = "438_1304277427.017" 
    copy $P8447, $P8448
    nqp_get_sc_object $P8449, "1304277414.8", 208
    .const 'Sub' $P8450 = "440_1304277427.017" 
    copy $P8449, $P8450
    nqp_get_sc_object $P8451, "1304277414.8", 209
    .const 'Sub' $P8452 = "442_1304277427.017" 
    copy $P8451, $P8452
    nqp_get_sc_object $P8453, "1304277414.8", 210
    .const 'Sub' $P8454 = "443_1304277427.017" 
    copy $P8453, $P8454
    nqp_get_sc_object $P8455, "1304277414.8", 211
    .const 'Sub' $P8456 = "444_1304277427.017" 
    copy $P8455, $P8456
    nqp_get_sc_object $P8457, "1304277414.8", 212
    .const 'Sub' $P8458 = "445_1304277427.017" 
    copy $P8457, $P8458
    nqp_get_sc_object $P8459, "1304277414.8", 213
    .const 'Sub' $P8460 = "447_1304277427.017" 
    copy $P8459, $P8460
    nqp_get_sc_object $P8461, "1304277414.8", 214
    .const 'Sub' $P8462 = "448_1304277427.017" 
    copy $P8461, $P8462
    nqp_get_sc_object $P8463, "1304277414.8", 215
    .const 'Sub' $P8464 = "450_1304277427.017" 
    copy $P8463, $P8464
    nqp_get_sc_object $P8465, "1304277414.8", 216
    .const 'Sub' $P8466 = "451_1304277427.017" 
    copy $P8465, $P8466
    nqp_get_sc_object $P8467, "1304277414.8", 217
    .const 'Sub' $P8468 = "452_1304277427.017" 
    copy $P8467, $P8468
    nqp_get_sc_object $P8469, "1304277414.8", 218
    .const 'Sub' $P8470 = "453_1304277427.017" 
    copy $P8469, $P8470
    nqp_get_sc_object $P8471, "1304277414.8", 219
    .const 'Sub' $P8472 = "455_1304277427.017" 
    copy $P8471, $P8472
    nqp_get_sc_object $P8473, "1304277414.8", 220
    .const 'Sub' $P8474 = "456_1304277427.017" 
    copy $P8473, $P8474
    nqp_get_sc_object $P8475, "1304277414.8", 221
    .const 'Sub' $P8476 = "457_1304277427.017" 
    copy $P8475, $P8476
    nqp_get_sc_object $P8477, "1304277414.8", 222
    .const 'Sub' $P8478 = "458_1304277427.017" 
    copy $P8477, $P8478
    nqp_get_sc_object $P8479, "1304277414.8", 223
    .const 'Sub' $P8480 = "459_1304277427.017" 
    copy $P8479, $P8480
    nqp_get_sc_object $P8481, "1304277414.8", 224
    .const 'Sub' $P8482 = "460_1304277427.017" 
    copy $P8481, $P8482
    nqp_get_sc_object $P8483, "1304277414.8", 225
    .const 'Sub' $P8484 = "461_1304277427.017" 
    copy $P8483, $P8484
    nqp_get_sc_object $P8485, "1304277414.8", 226
    .const 'Sub' $P8486 = "462_1304277427.017" 
    copy $P8485, $P8486
    nqp_get_sc_object $P8487, "1304277414.8", 227
    .const 'Sub' $P8488 = "463_1304277427.017" 
    copy $P8487, $P8488
    nqp_get_sc_object $P8489, "1304277414.8", 228
    .const 'Sub' $P8490 = "464_1304277427.017" 
    copy $P8489, $P8490
    nqp_get_sc_object $P8491, "1304277414.8", 229
    .const 'Sub' $P8492 = "465_1304277427.017" 
    copy $P8491, $P8492
    nqp_get_sc_object $P8493, "1304277414.8", 230
    .const 'Sub' $P8494 = "466_1304277427.017" 
    copy $P8493, $P8494
    nqp_get_sc_object $P8495, "1304277414.8", 231
    .const 'Sub' $P8496 = "467_1304277427.017" 
    copy $P8495, $P8496
    nqp_get_sc_object $P8497, "1304277414.8", 232
    .const 'Sub' $P8498 = "468_1304277427.017" 
    copy $P8497, $P8498
    nqp_get_sc_object $P8499, "1304277414.8", 233
    .const 'Sub' $P8500 = "469_1304277427.017" 
    copy $P8499, $P8500
    nqp_get_sc_object $P8501, "1304277414.8", 234
    .const 'Sub' $P8502 = "470_1304277427.017" 
    copy $P8501, $P8502
    nqp_get_sc_object $P8503, "1304277414.8", 235
    .const 'Sub' $P8504 = "471_1304277427.017" 
    copy $P8503, $P8504
    nqp_get_sc_object $P8505, "1304277414.8", 236
    .const 'Sub' $P8506 = "472_1304277427.017" 
    copy $P8505, $P8506
    nqp_get_sc_object $P8507, "1304277414.8", 237
    .const 'Sub' $P8508 = "473_1304277427.017" 
    copy $P8507, $P8508
    nqp_get_sc_object $P8509, "1304277414.8", 238
    .const 'Sub' $P8510 = "474_1304277427.017" 
    copy $P8509, $P8510
    nqp_get_sc_object $P8511, "1304277414.8", 239
    .const 'Sub' $P8512 = "475_1304277427.017" 
    copy $P8511, $P8512
    nqp_get_sc_object $P8513, "1304277414.8", 240
    .const 'Sub' $P8514 = "476_1304277427.017" 
    copy $P8513, $P8514
    nqp_get_sc_object $P8515, "1304277414.8", 241
    .const 'Sub' $P8516 = "477_1304277427.017" 
    copy $P8515, $P8516
    nqp_get_sc_object $P8517, "1304277414.8", 242
    .const 'Sub' $P8518 = "478_1304277427.017" 
    copy $P8517, $P8518
    nqp_get_sc_object $P8519, "1304277414.8", 243
    .const 'Sub' $P8520 = "479_1304277427.017" 
    copy $P8519, $P8520
    nqp_get_sc_object $P8521, "1304277414.8", 244
    .const 'Sub' $P8522 = "485_1304277427.017" 
    copy $P8521, $P8522
    nqp_get_sc_object $P8523, "1304277414.8", 245
    .const 'Sub' $P8524 = "486_1304277427.017" 
    copy $P8523, $P8524
    nqp_get_sc_object $P8525, "1304277414.8", 246
    .const 'Sub' $P8526 = "487_1304277427.017" 
    copy $P8525, $P8526
    nqp_get_sc_object $P8527, "1304277414.8", 247
    .const 'Sub' $P8528 = "488_1304277427.017" 
    copy $P8527, $P8528
    nqp_get_sc_object $P8529, "1304277414.8", 248
    .const 'Sub' $P8530 = "489_1304277427.017" 
    copy $P8529, $P8530
    nqp_get_sc_object $P8531, "1304277414.8", 249
    .const 'Sub' $P8532 = "490_1304277427.017" 
    copy $P8531, $P8532
    nqp_get_sc_object $P8533, "1304277414.8", 250
    .const 'Sub' $P8534 = "491_1304277427.017" 
    copy $P8533, $P8534
    nqp_get_sc_object $P8535, "1304277414.8", 251
    .const 'Sub' $P8536 = "497_1304277427.017" 
    copy $P8535, $P8536
    nqp_get_sc_object $P8537, "1304277414.8", 252
    .const 'Sub' $P8538 = "498_1304277427.017" 
    copy $P8537, $P8538
    nqp_get_sc_object $P8539, "1304277414.8", 253
    .const 'Sub' $P8540 = "499_1304277427.017" 
    copy $P8539, $P8540
    nqp_get_sc_object $P8541, "1304277414.8", 254
    .const 'Sub' $P8542 = "500_1304277427.017" 
    copy $P8541, $P8542
    nqp_get_sc_object $P8543, "1304277414.8", 255
    .const 'Sub' $P8544 = "501_1304277427.017" 
    copy $P8543, $P8544
    nqp_get_sc_object $P8545, "1304277414.8", 256
    .const 'Sub' $P8546 = "502_1304277427.017" 
    copy $P8545, $P8546
    nqp_get_sc_object $P8547, "1304277414.8", 257
    .const 'Sub' $P8548 = "503_1304277427.017" 
    copy $P8547, $P8548
    nqp_get_sc_object $P8549, "1304277414.8", 258
    .const 'Sub' $P8550 = "504_1304277427.017" 
    copy $P8549, $P8550
    nqp_get_sc_object $P8551, "1304277414.8", 259
    .const 'Sub' $P8552 = "505_1304277427.017" 
    copy $P8551, $P8552
    nqp_get_sc_object $P8553, "1304277414.8", 260
    .const 'Sub' $P8554 = "507_1304277427.017" 
    copy $P8553, $P8554
    nqp_get_sc_object $P8555, "1304277414.8", 261
    .const 'Sub' $P8556 = "508_1304277427.017" 
    copy $P8555, $P8556
    nqp_get_sc_object $P8557, "1304277414.8", 262
    .const 'Sub' $P8558 = "509_1304277427.017" 
    copy $P8557, $P8558
    nqp_get_sc_object $P8559, "1304277414.8", 263
    .const 'Sub' $P8560 = "516_1304277427.017" 
    copy $P8559, $P8560
    nqp_get_sc_object $P8561, "1304277414.8", 264
    .const 'Sub' $P8562 = "519_1304277427.017" 
    copy $P8561, $P8562
    nqp_get_sc_object $P8563, "1304277414.8", 265
    .const 'Sub' $P8564 = "522_1304277427.017" 
    copy $P8563, $P8564
    nqp_get_sc_object $P8565, "1304277414.8", 266
    .const 'Sub' $P8566 = "523_1304277427.017" 
    copy $P8565, $P8566
    nqp_get_sc_object $P8567, "1304277414.8", 267
    .const 'Sub' $P8568 = "524_1304277427.017" 
    copy $P8567, $P8568
    nqp_get_sc_object $P8569, "1304277414.8", 268
    .const 'Sub' $P8570 = "525_1304277427.017" 
    copy $P8569, $P8570
    nqp_get_sc_object $P8571, "1304277414.8", 269
    .const 'Sub' $P8572 = "527_1304277427.017" 
    copy $P8571, $P8572
    nqp_get_sc_object $P8573, "1304277414.8", 270
    .const 'Sub' $P8574 = "528_1304277427.017" 
    copy $P8573, $P8574
    nqp_get_sc_object $P8575, "1304277414.8", 271
    .const 'Sub' $P8576 = "531_1304277427.017" 
    copy $P8575, $P8576
    nqp_get_sc_object $P8577, "1304277414.8", 272
    .const 'Sub' $P8578 = "535_1304277427.017" 
    copy $P8577, $P8578
    nqp_get_sc_object $P8579, "1304277414.8", 273
    .const 'Sub' $P8580 = "536_1304277427.017" 
    copy $P8579, $P8580
    nqp_get_sc_object $P8581, "1304277414.8", 274
    .const 'Sub' $P8582 = "537_1304277427.017" 
    copy $P8581, $P8582
    nqp_get_sc_object $P8583, "1304277414.8", 275
    .const 'Sub' $P8584 = "538_1304277427.017" 
    copy $P8583, $P8584
    nqp_get_sc_object $P8585, "1304277414.8", 276
    .const 'Sub' $P8586 = "540_1304277427.017" 
    copy $P8585, $P8586
    nqp_get_sc_object $P8587, "1304277414.8", 277
    .const 'Sub' $P8588 = "541_1304277427.017" 
    copy $P8587, $P8588
    nqp_get_sc_object $P8589, "1304277414.8", 278
    .const 'Sub' $P8590 = "542_1304277427.017" 
    copy $P8589, $P8590
    nqp_get_sc_object $P8591, "1304277414.8", 279
    .const 'Sub' $P8592 = "543_1304277427.017" 
    copy $P8591, $P8592
    nqp_get_sc_object $P8593, "1304277414.8", 280
    .const 'Sub' $P8594 = "546_1304277427.017" 
    copy $P8593, $P8594
    nqp_get_sc_object $P8595, "1304277414.8", 281
    .const 'Sub' $P8596 = "547_1304277427.017" 
    copy $P8595, $P8596
    nqp_get_sc_object $P8597, "1304277414.8", 282
    .const 'Sub' $P8598 = "548_1304277427.017" 
    copy $P8597, $P8598
    nqp_get_sc_object $P8599, "1304277414.8", 283
    .const 'Sub' $P8600 = "549_1304277427.017" 
    copy $P8599, $P8600
    nqp_get_sc_object $P8601, "1304277414.8", 284
    .const 'Sub' $P8602 = "550_1304277427.017" 
    copy $P8601, $P8602
    nqp_get_sc_object $P8603, "1304277414.8", 285
    .const 'Sub' $P8604 = "551_1304277427.017" 
    copy $P8603, $P8604
    nqp_get_sc_object $P8605, "1304277414.8", 286
    .const 'Sub' $P8606 = "552_1304277427.017" 
    copy $P8605, $P8606
    nqp_get_sc_object $P8607, "1304277414.8", 287
    .const 'Sub' $P8608 = "554_1304277427.017" 
    copy $P8607, $P8608
    nqp_get_sc_object $P8609, "1304277414.8", 288
    .const 'Sub' $P8610 = "555_1304277427.017" 
    copy $P8609, $P8610
    nqp_get_sc_object $P8611, "1304277414.8", 289
    .const 'Sub' $P8612 = "556_1304277427.017" 
    copy $P8611, $P8612
    nqp_get_sc_object $P8613, "1304277414.8", 290
    .const 'Sub' $P8614 = "557_1304277427.017" 
    copy $P8613, $P8614
    nqp_get_sc_object $P8615, "1304277414.8", 291
    .const 'Sub' $P8616 = "558_1304277427.017" 
    copy $P8615, $P8616
    nqp_get_sc_object $P8617, "1304277414.8", 292
    .const 'Sub' $P8618 = "559_1304277427.017" 
    copy $P8617, $P8618
    nqp_get_sc_object $P8619, "1304277414.8", 293
    .const 'Sub' $P8620 = "560_1304277427.017" 
    copy $P8619, $P8620
    nqp_get_sc_object $P8621, "1304277414.8", 294
    .const 'Sub' $P8622 = "561_1304277427.017" 
    copy $P8621, $P8622
    nqp_get_sc_object $P8623, "1304277414.8", 295
    .const 'Sub' $P8624 = "562_1304277427.017" 
    copy $P8623, $P8624
    nqp_get_sc_object $P8625, "1304277414.8", 296
    .const 'Sub' $P8626 = "563_1304277427.017" 
    copy $P8625, $P8626
    nqp_get_sc_object $P8627, "1304277414.8", 297
    .const 'Sub' $P8628 = "564_1304277427.017" 
    copy $P8627, $P8628
    nqp_get_sc_object $P8629, "1304277414.8", 298
    .const 'Sub' $P8630 = "565_1304277427.017" 
    copy $P8629, $P8630
    nqp_get_sc_object $P8631, "1304277414.8", 299
    .const 'Sub' $P8632 = "566_1304277427.017" 
    copy $P8631, $P8632
    nqp_get_sc_object $P8633, "1304277414.8", 300
    .const 'Sub' $P8634 = "567_1304277427.017" 
    copy $P8633, $P8634
    nqp_get_sc_object $P8635, "1304277414.8", 301
    .const 'Sub' $P8636 = "568_1304277427.017" 
    copy $P8635, $P8636
    nqp_get_sc_object $P8637, "1304277414.8", 302
    .const 'Sub' $P8638 = "569_1304277427.017" 
    copy $P8637, $P8638
    nqp_get_sc_object $P8639, "1304277414.8", 303
    .const 'Sub' $P8640 = "570_1304277427.017" 
    copy $P8639, $P8640
    nqp_get_sc_object $P8641, "1304277414.8", 304
    .const 'Sub' $P8642 = "571_1304277427.017" 
    copy $P8641, $P8642
    nqp_get_sc_object $P8643, "1304277414.8", 305
    .const 'Sub' $P8644 = "572_1304277427.017" 
    copy $P8643, $P8644
    nqp_get_sc_object $P8645, "1304277414.8", 306
    .const 'Sub' $P8646 = "573_1304277427.017" 
    copy $P8645, $P8646
    nqp_get_sc_object $P8647, "1304277414.8", 307
    .const 'Sub' $P8648 = "574_1304277427.017" 
    copy $P8647, $P8648
    nqp_get_sc_object $P8649, "1304277414.8", 308
    .const 'Sub' $P8650 = "575_1304277427.017" 
    copy $P8649, $P8650
    nqp_get_sc_object $P8651, "1304277414.8", 309
    .const 'Sub' $P8652 = "576_1304277427.017" 
    copy $P8651, $P8652
    nqp_get_sc_object $P8653, "1304277414.8", 310
    .const 'Sub' $P8654 = "577_1304277427.017" 
    copy $P8653, $P8654
    nqp_get_sc_object $P8655, "1304277414.8", 311
    .const 'Sub' $P8656 = "578_1304277427.017" 
    copy $P8655, $P8656
    nqp_get_sc_object $P8657, "1304277414.8", 312
    .const 'Sub' $P8658 = "579_1304277427.017" 
    copy $P8657, $P8658
    nqp_get_sc_object $P8659, "1304277414.8", 313
    .const 'Sub' $P8660 = "580_1304277427.017" 
    copy $P8659, $P8660
    .const 'Sub' $P8661 = "408_1304277427.017" 
    $P8662 = $P8661."get_lexinfo"()
    nqp_get_sc_object $P8663, "1304277414.8", 203
    $P8662."set_static_lexpad_value"("$?PACKAGE", $P8663)
    .const 'Sub' $P8664 = "408_1304277427.017" 
    $P8665 = $P8664."get_lexinfo"()
    $P8665."finish_static_lexpad"()
    .const 'Sub' $P8666 = "408_1304277427.017" 
    $P8667 = $P8666."get_lexinfo"()
    nqp_get_sc_object $P8668, "1304277414.8", 203
    $P8667."set_static_lexpad_value"("$?CLASS", $P8668)
    .const 'Sub' $P8669 = "408_1304277427.017" 
    $P8670 = $P8669."get_lexinfo"()
    $P8670."finish_static_lexpad"()
    nqp_get_sc_object $P8671, "1304277414.8", 315
    .const 'Sub' $P8672 = "584_1304277427.017" 
    copy $P8671, $P8672
    nqp_get_sc_object $P8673, "1304277414.8", 316
    .const 'Sub' $P8674 = "585_1304277427.017" 
    copy $P8673, $P8674
    nqp_get_sc_object $P8675, "1304277414.8", 317
    .const 'Sub' $P8676 = "586_1304277427.017" 
    copy $P8675, $P8676
    nqp_get_sc_object $P8677, "1304277414.8", 318
    .const 'Sub' $P8678 = "587_1304277427.017" 
    copy $P8677, $P8678
    nqp_get_sc_object $P8679, "1304277414.8", 319
    .const 'Sub' $P8680 = "588_1304277427.017" 
    copy $P8679, $P8680
    nqp_get_sc_object $P8681, "1304277414.8", 320
    .const 'Sub' $P8682 = "589_1304277427.017" 
    copy $P8681, $P8682
    nqp_get_sc_object $P8683, "1304277414.8", 321
    .const 'Sub' $P8684 = "590_1304277427.017" 
    copy $P8683, $P8684
    .const 'Sub' $P8685 = "583_1304277427.017" 
    $P8686 = $P8685."get_lexinfo"()
    nqp_get_sc_object $P8687, "1304277414.8", 314
    $P8686."set_static_lexpad_value"("$?PACKAGE", $P8687)
    .const 'Sub' $P8688 = "583_1304277427.017" 
    $P8689 = $P8688."get_lexinfo"()
    $P8689."finish_static_lexpad"()
    .const 'Sub' $P8690 = "583_1304277427.017" 
    $P8691 = $P8690."get_lexinfo"()
    nqp_get_sc_object $P8692, "1304277414.8", 314
    $P8691."set_static_lexpad_value"("$?CLASS", $P8692)
    .const 'Sub' $P8693 = "583_1304277427.017" 
    $P8694 = $P8693."get_lexinfo"()
    $P8694."finish_static_lexpad"()
    .const 'Sub' $P8695 = "592_1304277427.017" 
    $P8696 = $P8695."get_lexinfo"()
    nqp_get_sc_object $P8697, "1304277414.8", 322
    $P8696."set_static_lexpad_value"("$?PACKAGE", $P8697)
    .const 'Sub' $P8698 = "592_1304277427.017" 
    $P8699 = $P8698."get_lexinfo"()
    $P8699."finish_static_lexpad"()
    .const 'Sub' $P8700 = "592_1304277427.017" 
    $P8701 = $P8700."get_lexinfo"()
    nqp_get_sc_object $P8702, "1304277414.8", 322
    $P8701."set_static_lexpad_value"("$?CLASS", $P8702)
    .const 'Sub' $P8703 = "592_1304277427.017" 
    $P8704 = $P8703."get_lexinfo"()
    $P8704."finish_static_lexpad"()
    goto if_6618_end
  if_6618:
    nqp_dynop_setup 
    getinterp $P6621
    get_class $P6622, "LexPad"
    get_class $P6623, "NQPLexPad"
    $P6621."hll_map"($P6622, $P6623)
    nqp_create_sc $P6624, "1304277414.8"
    .local pmc cur_sc
    set cur_sc, $P6624
    nqp_get_sc_object $P6625, "__6MODEL_CORE__", 0
    $P6626 = $P6625."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6626, cur_sc
    nqp_set_sc_object "1304277414.8", 0, $P6626
    .const 'Sub' $P6627 = "10_1304277427.017" 
    $P6628 = $P6627."get_lexinfo"()
    nqp_get_sc_object $P6629, "1304277414.8", 0
    $P6628."set_static_lexpad_value"("GLOBALish", $P6629)
    .const 'Sub' $P6630 = "10_1304277427.017" 
    $P6631 = $P6630."get_lexinfo"()
    $P6631."finish_static_lexpad"()
    .const 'Sub' $P6632 = "10_1304277427.017" 
    $P6633 = $P6632."get_lexinfo"()
    nqp_get_sc_object $P6634, "1304277414.8", 0
    $P6633."set_static_lexpad_value"("$?PACKAGE", $P6634)
    .const 'Sub' $P6635 = "10_1304277427.017" 
    $P6636 = $P6635."get_lexinfo"()
    $P6636."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6637, "ModuleLoader"
    $P6638 = $P6637."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6638)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6639, "ModuleLoader"
    nqp_get_sc_object $P6640, "1304277414.8", 0
    $P6639."load_module"("Regex", $P6640)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6641, "ModuleLoader"
    nqp_get_sc_object $P6642, "1304277414.8", 0
    $P6641."load_module"("P6Regex", $P6642)
    nqp_get_sc_object $P6643, "1304277388.915", 41
    $P6644 = $P6643."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6644, cur_sc
    nqp_set_sc_object "1304277414.8", 1, $P6644
    nqp_get_sc_object $P6645, "1304277414.8", 1
    nqp_get_sc_object $P6646, "1304277414.8", 0
    nqp_get_package_through_who $P6647, $P6646, "NQP"
    get_who $P6648, $P6647
    set $P6648["Grammar"], $P6645
    nqp_get_sc_object $P6649, "1304277414.8", 1
    get_how $P6650, $P6649
    nqp_get_sc_object $P6651, "1304277414.8", 1
    .const 'Sub' $P6652 = "13_1304277427.017" 
    $P6650."add_method"($P6651, "TOP", $P6652)
    nqp_get_sc_object $P6653, "1304277414.8", 1
    get_how $P6654, $P6653
    nqp_get_sc_object $P6655, "1304277414.8", 1
    .const 'Sub' $P6656 = "14_1304277427.017" 
    $P6654."add_method"($P6655, "identifier", $P6656)
    nqp_get_sc_object $P6657, "1304277414.8", 1
    get_how $P6658, $P6657
    nqp_get_sc_object $P6659, "1304277414.8", 1
    .const 'Sub' $P6660 = "16_1304277427.017" 
    $P6658."add_method"($P6659, "name", $P6660)
    nqp_get_sc_object $P6661, "1304277414.8", 1
    get_how $P6662, $P6661
    nqp_get_sc_object $P6663, "1304277414.8", 1
    .const 'Sub' $P6664 = "18_1304277427.017" 
    $P6662."add_method"($P6663, "deflongname", $P6664)
    nqp_get_sc_object $P6665, "1304277414.8", 1
    get_how $P6666, $P6665
    nqp_get_sc_object $P6667, "1304277414.8", 1
    .const 'Sub' $P6668 = "20_1304277427.017" 
    $P6666."add_method"($P6667, "ENDSTMT", $P6668)
    nqp_get_sc_object $P6669, "1304277414.8", 1
    get_how $P6670, $P6669
    nqp_get_sc_object $P6671, "1304277414.8", 1
    .const 'Sub' $P6672 = "22_1304277427.017" 
    $P6670."add_method"($P6671, "ws", $P6672)
    nqp_get_sc_object $P6673, "1304277414.8", 1
    get_how $P6674, $P6673
    nqp_get_sc_object $P6675, "1304277414.8", 1
    .const 'Sub' $P6676 = "24_1304277427.017" 
    $P6674."add_method"($P6675, "unv", $P6676)
    nqp_get_sc_object $P6677, "1304277414.8", 1
    get_how $P6678, $P6677
    nqp_get_sc_object $P6679, "1304277414.8", 1
    .const 'Sub' $P6680 = "27_1304277427.017" 
    $P6678."add_method"($P6679, "pod_comment", $P6680)
    nqp_get_sc_object $P6681, "1304277414.8", 1
    get_how $P6682, $P6681
    nqp_get_sc_object $P6683, "1304277414.8", 1
    .const 'Sub' $P6684 = "30_1304277427.017" 
    $P6682."add_method"($P6683, "comp_unit", $P6684)
    nqp_get_sc_object $P6685, "1304277414.8", 1
    get_how $P6686, $P6685
    nqp_get_sc_object $P6687, "1304277414.8", 1
    .const 'Sub' $P6688 = "32_1304277427.017" 
    $P6686."add_method"($P6687, "statementlist", $P6688)
    nqp_get_sc_object $P6689, "1304277414.8", 1
    get_how $P6690, $P6689
    nqp_get_sc_object $P6691, "1304277414.8", 1
    .const 'Sub' $P6692 = "34_1304277427.017" 
    $P6690."add_method"($P6691, "statement", $P6692)
    nqp_get_sc_object $P6693, "1304277414.8", 1
    get_how $P6694, $P6693
    nqp_get_sc_object $P6695, "1304277414.8", 1
    .const 'Sub' $P6696 = "37_1304277427.017" 
    $P6694."add_method"($P6695, "eat_terminator", $P6696)
    nqp_get_sc_object $P6697, "1304277414.8", 1
    get_how $P6698, $P6697
    nqp_get_sc_object $P6699, "1304277414.8", 1
    .const 'Sub' $P6700 = "39_1304277427.017" 
    $P6698."add_method"($P6699, "xblock", $P6700)
    nqp_get_sc_object $P6701, "1304277414.8", 1
    get_how $P6702, $P6701
    nqp_get_sc_object $P6703, "1304277414.8", 1
    .const 'Sub' $P6704 = "41_1304277427.017" 
    $P6702."add_method"($P6703, "pblock", $P6704)
    nqp_get_sc_object $P6705, "1304277414.8", 1
    get_how $P6706, $P6705
    nqp_get_sc_object $P6707, "1304277414.8", 1
    .const 'Sub' $P6708 = "43_1304277427.017" 
    $P6706."add_method"($P6707, "lambda", $P6708)
    nqp_get_sc_object $P6709, "1304277414.8", 1
    get_how $P6710, $P6709
    nqp_get_sc_object $P6711, "1304277414.8", 1
    .const 'Sub' $P6712 = "45_1304277427.017" 
    $P6710."add_method"($P6711, "block", $P6712)
    nqp_get_sc_object $P6713, "1304277414.8", 1
    get_how $P6714, $P6713
    nqp_get_sc_object $P6715, "1304277414.8", 1
    .const 'Sub' $P6716 = "47_1304277427.017" 
    $P6714."add_method"($P6715, "blockoid", $P6716)
    nqp_get_sc_object $P6717, "1304277414.8", 1
    get_how $P6718, $P6717
    nqp_get_sc_object $P6719, "1304277414.8", 1
    .const 'Sub' $P6720 = "49_1304277427.017" 
    $P6718."add_method"($P6719, "newpad", $P6720)
    nqp_get_sc_object $P6721, "1304277414.8", 1
    get_how $P6722, $P6721
    nqp_get_sc_object $P6723, "1304277414.8", 1
    .const 'Sub' $P6724 = "51_1304277427.017" 
    $P6722."add_method"($P6723, "outerctx", $P6724)
    nqp_get_sc_object $P6725, "1304277414.8", 1
    get_how $P6726, $P6725
    nqp_get_sc_object $P6727, "1304277414.8", 1
    .const 'Sub' $P6728 = "53_1304277427.017" 
    $P6726."add_method"($P6727, "GLOBALish", $P6728)
    nqp_get_sc_object $P6729, "1304277414.8", 1
    get_how $P6730, $P6729
    nqp_get_sc_object $P6731, "1304277414.8", 1
    .const 'Sub' $P6732 = "55_1304277427.017" 
    $P6730."add_method"($P6731, "finishpad", $P6732)
    nqp_get_sc_object $P6733, "1304277414.8", 1
    get_how $P6734, $P6733
    nqp_get_sc_object $P6735, "1304277414.8", 1
    .const 'Sub' $P6736 = "57_1304277427.017" 
    $P6734."add_method"($P6735, "you_are_here", $P6736)
    nqp_get_sc_object $P6737, "1304277414.8", 1
    get_how $P6738, $P6737
    nqp_get_sc_object $P6739, "1304277414.8", 1
    .const 'Sub' $P6740 = "59_1304277427.017" 
    $P6738."add_method"($P6739, "terminator", $P6740)
    nqp_get_sc_object $P6741, "1304277414.8", 1
    get_how $P6742, $P6741
    nqp_get_sc_object $P6743, "1304277414.8", 1
    .const 'Sub' $P6744 = "60_1304277427.017" 
    $P6742."add_method"($P6743, "!PREFIX__terminator", $P6744)
    nqp_get_sc_object $P6745, "1304277414.8", 1
    get_how $P6746, $P6745
    nqp_get_sc_object $P6747, "1304277414.8", 1
    .const 'Sub' $P6748 = "61_1304277427.017" 
    $P6746."add_method"($P6747, "terminator:sym<;>", $P6748)
    nqp_get_sc_object $P6749, "1304277414.8", 1
    get_how $P6750, $P6749
    nqp_get_sc_object $P6751, "1304277414.8", 1
    .const 'Sub' $P6752 = "63_1304277427.017" 
    $P6750."add_method"($P6751, "terminator:sym<}>", $P6752)
    nqp_get_sc_object $P6753, "1304277414.8", 1
    get_how $P6754, $P6753
    nqp_get_sc_object $P6755, "1304277414.8", 1
    .const 'Sub' $P6756 = "65_1304277427.017" 
    $P6754."add_method"($P6755, "statement_control", $P6756)
    nqp_get_sc_object $P6757, "1304277414.8", 1
    get_how $P6758, $P6757
    nqp_get_sc_object $P6759, "1304277414.8", 1
    .const 'Sub' $P6760 = "66_1304277427.017" 
    $P6758."add_method"($P6759, "!PREFIX__statement_control", $P6760)
    nqp_get_sc_object $P6761, "1304277414.8", 1
    get_how $P6762, $P6761
    nqp_get_sc_object $P6763, "1304277414.8", 1
    .const 'Sub' $P6764 = "67_1304277427.017" 
    $P6762."add_method"($P6763, "statement_control:sym<use>", $P6764)
    nqp_get_sc_object $P6765, "1304277414.8", 1
    get_how $P6766, $P6765
    nqp_get_sc_object $P6767, "1304277414.8", 1
    .const 'Sub' $P6768 = "69_1304277427.017" 
    $P6766."add_method"($P6767, "statement_control:sym<if>", $P6768)
    nqp_get_sc_object $P6769, "1304277414.8", 1
    get_how $P6770, $P6769
    nqp_get_sc_object $P6771, "1304277414.8", 1
    .const 'Sub' $P6772 = "71_1304277427.017" 
    $P6770."add_method"($P6771, "statement_control:sym<unless>", $P6772)
    nqp_get_sc_object $P6773, "1304277414.8", 1
    get_how $P6774, $P6773
    nqp_get_sc_object $P6775, "1304277414.8", 1
    .const 'Sub' $P6776 = "74_1304277427.017" 
    $P6774."add_method"($P6775, "statement_control:sym<while>", $P6776)
    nqp_get_sc_object $P6777, "1304277414.8", 1
    get_how $P6778, $P6777
    nqp_get_sc_object $P6779, "1304277414.8", 1
    .const 'Sub' $P6780 = "76_1304277427.017" 
    $P6778."add_method"($P6779, "statement_control:sym<repeat>", $P6780)
    nqp_get_sc_object $P6781, "1304277414.8", 1
    get_how $P6782, $P6781
    nqp_get_sc_object $P6783, "1304277414.8", 1
    .const 'Sub' $P6784 = "78_1304277427.017" 
    $P6782."add_method"($P6783, "statement_control:sym<for>", $P6784)
    nqp_get_sc_object $P6785, "1304277414.8", 1
    get_how $P6786, $P6785
    nqp_get_sc_object $P6787, "1304277414.8", 1
    .const 'Sub' $P6788 = "80_1304277427.017" 
    $P6786."add_method"($P6787, "statement_control:sym<CATCH>", $P6788)
    nqp_get_sc_object $P6789, "1304277414.8", 1
    get_how $P6790, $P6789
    nqp_get_sc_object $P6791, "1304277414.8", 1
    .const 'Sub' $P6792 = "82_1304277427.017" 
    $P6790."add_method"($P6791, "statement_control:sym<CONTROL>", $P6792)
    nqp_get_sc_object $P6793, "1304277414.8", 1
    get_how $P6794, $P6793
    nqp_get_sc_object $P6795, "1304277414.8", 1
    .const 'Sub' $P6796 = "84_1304277427.017" 
    $P6794."add_method"($P6795, "statement_prefix", $P6796)
    nqp_get_sc_object $P6797, "1304277414.8", 1
    get_how $P6798, $P6797
    nqp_get_sc_object $P6799, "1304277414.8", 1
    .const 'Sub' $P6800 = "85_1304277427.017" 
    $P6798."add_method"($P6799, "!PREFIX__statement_prefix", $P6800)
    nqp_get_sc_object $P6801, "1304277414.8", 1
    get_how $P6802, $P6801
    nqp_get_sc_object $P6803, "1304277414.8", 1
    .const 'Sub' $P6804 = "86_1304277427.017" 
    $P6802."add_method"($P6803, "statement_prefix:sym<INIT>", $P6804)
    nqp_get_sc_object $P6805, "1304277414.8", 1
    get_how $P6806, $P6805
    nqp_get_sc_object $P6807, "1304277414.8", 1
    .const 'Sub' $P6808 = "88_1304277427.017" 
    $P6806."add_method"($P6807, "statement_prefix:sym<try>", $P6808)
    nqp_get_sc_object $P6809, "1304277414.8", 1
    get_how $P6810, $P6809
    nqp_get_sc_object $P6811, "1304277414.8", 1
    .const 'Sub' $P6812 = "90_1304277427.017" 
    $P6810."add_method"($P6811, "blorst", $P6812)
    nqp_get_sc_object $P6813, "1304277414.8", 1
    get_how $P6814, $P6813
    nqp_get_sc_object $P6815, "1304277414.8", 1
    .const 'Sub' $P6816 = "92_1304277427.017" 
    $P6814."add_method"($P6815, "statement_mod_cond", $P6816)
    nqp_get_sc_object $P6817, "1304277414.8", 1
    get_how $P6818, $P6817
    nqp_get_sc_object $P6819, "1304277414.8", 1
    .const 'Sub' $P6820 = "93_1304277427.017" 
    $P6818."add_method"($P6819, "!PREFIX__statement_mod_cond", $P6820)
    nqp_get_sc_object $P6821, "1304277414.8", 1
    get_how $P6822, $P6821
    nqp_get_sc_object $P6823, "1304277414.8", 1
    .const 'Sub' $P6824 = "94_1304277427.017" 
    $P6822."add_method"($P6823, "statement_mod_cond:sym<if>", $P6824)
    nqp_get_sc_object $P6825, "1304277414.8", 1
    get_how $P6826, $P6825
    nqp_get_sc_object $P6827, "1304277414.8", 1
    .const 'Sub' $P6828 = "96_1304277427.017" 
    $P6826."add_method"($P6827, "statement_mod_cond:sym<unless>", $P6828)
    nqp_get_sc_object $P6829, "1304277414.8", 1
    get_how $P6830, $P6829
    nqp_get_sc_object $P6831, "1304277414.8", 1
    .const 'Sub' $P6832 = "98_1304277427.017" 
    $P6830."add_method"($P6831, "statement_mod_loop", $P6832)
    nqp_get_sc_object $P6833, "1304277414.8", 1
    get_how $P6834, $P6833
    nqp_get_sc_object $P6835, "1304277414.8", 1
    .const 'Sub' $P6836 = "99_1304277427.017" 
    $P6834."add_method"($P6835, "!PREFIX__statement_mod_loop", $P6836)
    nqp_get_sc_object $P6837, "1304277414.8", 1
    get_how $P6838, $P6837
    nqp_get_sc_object $P6839, "1304277414.8", 1
    .const 'Sub' $P6840 = "100_1304277427.017" 
    $P6838."add_method"($P6839, "statement_mod_loop:sym<while>", $P6840)
    nqp_get_sc_object $P6841, "1304277414.8", 1
    get_how $P6842, $P6841
    nqp_get_sc_object $P6843, "1304277414.8", 1
    .const 'Sub' $P6844 = "102_1304277427.017" 
    $P6842."add_method"($P6843, "statement_mod_loop:sym<until>", $P6844)
    nqp_get_sc_object $P6845, "1304277414.8", 1
    get_how $P6846, $P6845
    nqp_get_sc_object $P6847, "1304277414.8", 1
    .const 'Sub' $P6848 = "104_1304277427.017" 
    $P6846."add_method"($P6847, "statement_mod_loop:sym<for>", $P6848)
    nqp_get_sc_object $P6849, "1304277414.8", 1
    get_how $P6850, $P6849
    nqp_get_sc_object $P6851, "1304277414.8", 1
    .const 'Sub' $P6852 = "106_1304277427.017" 
    $P6850."add_method"($P6851, "term:sym<fatarrow>", $P6852)
    nqp_get_sc_object $P6853, "1304277414.8", 1
    get_how $P6854, $P6853
    nqp_get_sc_object $P6855, "1304277414.8", 1
    .const 'Sub' $P6856 = "108_1304277427.017" 
    $P6854."add_method"($P6855, "term:sym<colonpair>", $P6856)
    nqp_get_sc_object $P6857, "1304277414.8", 1
    get_how $P6858, $P6857
    nqp_get_sc_object $P6859, "1304277414.8", 1
    .const 'Sub' $P6860 = "110_1304277427.017" 
    $P6858."add_method"($P6859, "term:sym<variable>", $P6860)
    nqp_get_sc_object $P6861, "1304277414.8", 1
    get_how $P6862, $P6861
    nqp_get_sc_object $P6863, "1304277414.8", 1
    .const 'Sub' $P6864 = "112_1304277427.017" 
    $P6862."add_method"($P6863, "term:sym<package_declarator>", $P6864)
    nqp_get_sc_object $P6865, "1304277414.8", 1
    get_how $P6866, $P6865
    nqp_get_sc_object $P6867, "1304277414.8", 1
    .const 'Sub' $P6868 = "114_1304277427.017" 
    $P6866."add_method"($P6867, "term:sym<scope_declarator>", $P6868)
    nqp_get_sc_object $P6869, "1304277414.8", 1
    get_how $P6870, $P6869
    nqp_get_sc_object $P6871, "1304277414.8", 1
    .const 'Sub' $P6872 = "116_1304277427.017" 
    $P6870."add_method"($P6871, "term:sym<routine_declarator>", $P6872)
    nqp_get_sc_object $P6873, "1304277414.8", 1
    get_how $P6874, $P6873
    nqp_get_sc_object $P6875, "1304277414.8", 1
    .const 'Sub' $P6876 = "118_1304277427.017" 
    $P6874."add_method"($P6875, "term:sym<multi_declarator>", $P6876)
    nqp_get_sc_object $P6877, "1304277414.8", 1
    get_how $P6878, $P6877
    nqp_get_sc_object $P6879, "1304277414.8", 1
    .const 'Sub' $P6880 = "122_1304277427.017" 
    $P6878."add_method"($P6879, "term:sym<regex_declarator>", $P6880)
    nqp_get_sc_object $P6881, "1304277414.8", 1
    get_how $P6882, $P6881
    nqp_get_sc_object $P6883, "1304277414.8", 1
    .const 'Sub' $P6884 = "124_1304277427.017" 
    $P6882."add_method"($P6883, "term:sym<statement_prefix>", $P6884)
    nqp_get_sc_object $P6885, "1304277414.8", 1
    get_how $P6886, $P6885
    nqp_get_sc_object $P6887, "1304277414.8", 1
    .const 'Sub' $P6888 = "126_1304277427.017" 
    $P6886."add_method"($P6887, "term:sym<lambda>", $P6888)
    nqp_get_sc_object $P6889, "1304277414.8", 1
    get_how $P6890, $P6889
    nqp_get_sc_object $P6891, "1304277414.8", 1
    .const 'Sub' $P6892 = "128_1304277427.017" 
    $P6890."add_method"($P6891, "fatarrow", $P6892)
    nqp_get_sc_object $P6893, "1304277414.8", 1
    get_how $P6894, $P6893
    nqp_get_sc_object $P6895, "1304277414.8", 1
    .const 'Sub' $P6896 = "130_1304277427.017" 
    $P6894."add_method"($P6895, "colonpair", $P6896)
    nqp_get_sc_object $P6897, "1304277414.8", 1
    get_how $P6898, $P6897
    nqp_get_sc_object $P6899, "1304277414.8", 1
    .const 'Sub' $P6900 = "132_1304277427.017" 
    $P6898."add_method"($P6899, "variable", $P6900)
    nqp_get_sc_object $P6901, "1304277414.8", 1
    get_how $P6902, $P6901
    nqp_get_sc_object $P6903, "1304277414.8", 1
    .const 'Sub' $P6904 = "134_1304277427.017" 
    $P6902."add_method"($P6903, "sigil", $P6904)
    nqp_get_sc_object $P6905, "1304277414.8", 1
    get_how $P6906, $P6905
    nqp_get_sc_object $P6907, "1304277414.8", 1
    .const 'Sub' $P6908 = "136_1304277427.017" 
    $P6906."add_method"($P6907, "twigil", $P6908)
    nqp_get_sc_object $P6909, "1304277414.8", 1
    get_how $P6910, $P6909
    nqp_get_sc_object $P6911, "1304277414.8", 1
    .const 'Sub' $P6912 = "138_1304277427.017" 
    $P6910."add_method"($P6911, "package_declarator", $P6912)
    nqp_get_sc_object $P6913, "1304277414.8", 1
    get_how $P6914, $P6913
    nqp_get_sc_object $P6915, "1304277414.8", 1
    .const 'Sub' $P6916 = "139_1304277427.017" 
    $P6914."add_method"($P6915, "!PREFIX__package_declarator", $P6916)
    nqp_get_sc_object $P6917, "1304277414.8", 1
    get_how $P6918, $P6917
    nqp_get_sc_object $P6919, "1304277414.8", 1
    .const 'Sub' $P6920 = "140_1304277427.017" 
    $P6918."add_method"($P6919, "package_declarator:sym<module>", $P6920)
    nqp_get_sc_object $P6921, "1304277414.8", 1
    get_how $P6922, $P6921
    nqp_get_sc_object $P6923, "1304277414.8", 1
    .const 'Sub' $P6924 = "142_1304277427.017" 
    $P6922."add_method"($P6923, "package_declarator:sym<knowhow>", $P6924)
    nqp_get_sc_object $P6925, "1304277414.8", 1
    get_how $P6926, $P6925
    nqp_get_sc_object $P6927, "1304277414.8", 1
    .const 'Sub' $P6928 = "144_1304277427.017" 
    $P6926."add_method"($P6927, "package_declarator:sym<class>", $P6928)
    nqp_get_sc_object $P6929, "1304277414.8", 1
    get_how $P6930, $P6929
    nqp_get_sc_object $P6931, "1304277414.8", 1
    .const 'Sub' $P6932 = "146_1304277427.017" 
    $P6930."add_method"($P6931, "package_declarator:sym<grammar>", $P6932)
    nqp_get_sc_object $P6933, "1304277414.8", 1
    get_how $P6934, $P6933
    nqp_get_sc_object $P6935, "1304277414.8", 1
    .const 'Sub' $P6936 = "148_1304277427.017" 
    $P6934."add_method"($P6935, "package_declarator:sym<role>", $P6936)
    nqp_get_sc_object $P6937, "1304277414.8", 1
    get_how $P6938, $P6937
    nqp_get_sc_object $P6939, "1304277414.8", 1
    .const 'Sub' $P6940 = "150_1304277427.017" 
    $P6938."add_method"($P6939, "package_declarator:sym<native>", $P6940)
    nqp_get_sc_object $P6941, "1304277414.8", 1
    get_how $P6942, $P6941
    nqp_get_sc_object $P6943, "1304277414.8", 1
    .const 'Sub' $P6944 = "152_1304277427.017" 
    $P6942."add_method"($P6943, "package_def", $P6944)
    nqp_get_sc_object $P6945, "1304277414.8", 1
    get_how $P6946, $P6945
    nqp_get_sc_object $P6947, "1304277414.8", 1
    .const 'Sub' $P6948 = "155_1304277427.017" 
    $P6946."add_method"($P6947, "scope_declarator", $P6948)
    nqp_get_sc_object $P6949, "1304277414.8", 1
    get_how $P6950, $P6949
    nqp_get_sc_object $P6951, "1304277414.8", 1
    .const 'Sub' $P6952 = "156_1304277427.017" 
    $P6950."add_method"($P6951, "!PREFIX__scope_declarator", $P6952)
    nqp_get_sc_object $P6953, "1304277414.8", 1
    get_how $P6954, $P6953
    nqp_get_sc_object $P6955, "1304277414.8", 1
    .const 'Sub' $P6956 = "157_1304277427.017" 
    $P6954."add_method"($P6955, "scope_declarator:sym<my>", $P6956)
    nqp_get_sc_object $P6957, "1304277414.8", 1
    get_how $P6958, $P6957
    nqp_get_sc_object $P6959, "1304277414.8", 1
    .const 'Sub' $P6960 = "159_1304277427.017" 
    $P6958."add_method"($P6959, "scope_declarator:sym<our>", $P6960)
    nqp_get_sc_object $P6961, "1304277414.8", 1
    get_how $P6962, $P6961
    nqp_get_sc_object $P6963, "1304277414.8", 1
    .const 'Sub' $P6964 = "161_1304277427.017" 
    $P6962."add_method"($P6963, "scope_declarator:sym<has>", $P6964)
    nqp_get_sc_object $P6965, "1304277414.8", 1
    get_how $P6966, $P6965
    nqp_get_sc_object $P6967, "1304277414.8", 1
    .const 'Sub' $P6968 = "163_1304277427.017" 
    $P6966."add_method"($P6967, "scoped", $P6968)
    nqp_get_sc_object $P6969, "1304277414.8", 1
    get_how $P6970, $P6969
    nqp_get_sc_object $P6971, "1304277414.8", 1
    .const 'Sub' $P6972 = "165_1304277427.017" 
    $P6970."add_method"($P6971, "typename", $P6972)
    nqp_get_sc_object $P6973, "1304277414.8", 1
    get_how $P6974, $P6973
    nqp_get_sc_object $P6975, "1304277414.8", 1
    .const 'Sub' $P6976 = "168_1304277427.017" 
    $P6974."add_method"($P6975, "declarator", $P6976)
    nqp_get_sc_object $P6977, "1304277414.8", 1
    get_how $P6978, $P6977
    nqp_get_sc_object $P6979, "1304277414.8", 1
    .const 'Sub' $P6980 = "170_1304277427.017" 
    $P6978."add_method"($P6979, "variable_declarator", $P6980)
    nqp_get_sc_object $P6981, "1304277414.8", 1
    get_how $P6982, $P6981
    nqp_get_sc_object $P6983, "1304277414.8", 1
    .const 'Sub' $P6984 = "173_1304277427.017" 
    $P6982."add_method"($P6983, "routine_declarator", $P6984)
    nqp_get_sc_object $P6985, "1304277414.8", 1
    get_how $P6986, $P6985
    nqp_get_sc_object $P6987, "1304277414.8", 1
    .const 'Sub' $P6988 = "174_1304277427.017" 
    $P6986."add_method"($P6987, "!PREFIX__routine_declarator", $P6988)
    nqp_get_sc_object $P6989, "1304277414.8", 1
    get_how $P6990, $P6989
    nqp_get_sc_object $P6991, "1304277414.8", 1
    .const 'Sub' $P6992 = "175_1304277427.017" 
    $P6990."add_method"($P6991, "routine_declarator:sym<sub>", $P6992)
    nqp_get_sc_object $P6993, "1304277414.8", 1
    get_how $P6994, $P6993
    nqp_get_sc_object $P6995, "1304277414.8", 1
    .const 'Sub' $P6996 = "177_1304277427.017" 
    $P6994."add_method"($P6995, "routine_declarator:sym<method>", $P6996)
    nqp_get_sc_object $P6997, "1304277414.8", 1
    get_how $P6998, $P6997
    nqp_get_sc_object $P6999, "1304277414.8", 1
    .const 'Sub' $P7000 = "179_1304277427.017" 
    $P6998."add_method"($P6999, "routine_def", $P7000)
    nqp_get_sc_object $P7001, "1304277414.8", 1
    get_how $P7002, $P7001
    nqp_get_sc_object $P7003, "1304277414.8", 1
    .const 'Sub' $P7004 = "181_1304277427.017" 
    $P7002."add_method"($P7003, "method_def", $P7004)
    nqp_get_sc_object $P7005, "1304277414.8", 1
    get_how $P7006, $P7005
    nqp_get_sc_object $P7007, "1304277414.8", 1
    .const 'Sub' $P7008 = "184_1304277427.017" 
    $P7006."add_method"($P7007, "onlystar", $P7008)
    nqp_get_sc_object $P7009, "1304277414.8", 1
    get_how $P7010, $P7009
    nqp_get_sc_object $P7011, "1304277414.8", 1
    .const 'Sub' $P7012 = "187_1304277427.017" 
    $P7010."add_method"($P7011, "multi_declarator", $P7012)
    nqp_get_sc_object $P7013, "1304277414.8", 1
    get_how $P7014, $P7013
    nqp_get_sc_object $P7015, "1304277414.8", 1
    .const 'Sub' $P7016 = "188_1304277427.017" 
    $P7014."add_method"($P7015, "!PREFIX__multi_declarator", $P7016)
    nqp_get_sc_object $P7017, "1304277414.8", 1
    get_how $P7018, $P7017
    nqp_get_sc_object $P7019, "1304277414.8", 1
    .const 'Sub' $P7020 = "189_1304277427.017" 
    $P7018."add_method"($P7019, "multi_declarator:sym<multi>", $P7020)
    nqp_get_sc_object $P7021, "1304277414.8", 1
    get_how $P7022, $P7021
    nqp_get_sc_object $P7023, "1304277414.8", 1
    .const 'Sub' $P7024 = "191_1304277427.017" 
    $P7022."add_method"($P7023, "multi_declarator:sym<proto>", $P7024)
    nqp_get_sc_object $P7025, "1304277414.8", 1
    get_how $P7026, $P7025
    nqp_get_sc_object $P7027, "1304277414.8", 1
    .const 'Sub' $P7028 = "193_1304277427.017" 
    $P7026."add_method"($P7027, "multi_declarator:sym<null>", $P7028)
    nqp_get_sc_object $P7029, "1304277414.8", 1
    get_how $P7030, $P7029
    nqp_get_sc_object $P7031, "1304277414.8", 1
    .const 'Sub' $P7032 = "195_1304277427.017" 
    $P7030."add_method"($P7031, "signature", $P7032)
    nqp_get_sc_object $P7033, "1304277414.8", 1
    get_how $P7034, $P7033
    nqp_get_sc_object $P7035, "1304277414.8", 1
    .const 'Sub' $P7036 = "198_1304277427.017" 
    $P7034."add_method"($P7035, "parameter", $P7036)
    nqp_get_sc_object $P7037, "1304277414.8", 1
    get_how $P7038, $P7037
    nqp_get_sc_object $P7039, "1304277414.8", 1
    .const 'Sub' $P7040 = "200_1304277427.017" 
    $P7038."add_method"($P7039, "param_var", $P7040)
    nqp_get_sc_object $P7041, "1304277414.8", 1
    get_how $P7042, $P7041
    nqp_get_sc_object $P7043, "1304277414.8", 1
    .const 'Sub' $P7044 = "202_1304277427.017" 
    $P7042."add_method"($P7043, "named_param", $P7044)
    nqp_get_sc_object $P7045, "1304277414.8", 1
    get_how $P7046, $P7045
    nqp_get_sc_object $P7047, "1304277414.8", 1
    .const 'Sub' $P7048 = "204_1304277427.017" 
    $P7046."add_method"($P7047, "default_value", $P7048)
    nqp_get_sc_object $P7049, "1304277414.8", 1
    get_how $P7050, $P7049
    nqp_get_sc_object $P7051, "1304277414.8", 1
    .const 'Sub' $P7052 = "206_1304277427.017" 
    $P7050."add_method"($P7051, "trait", $P7052)
    nqp_get_sc_object $P7053, "1304277414.8", 1
    get_how $P7054, $P7053
    nqp_get_sc_object $P7055, "1304277414.8", 1
    .const 'Sub' $P7056 = "208_1304277427.017" 
    $P7054."add_method"($P7055, "trait_mod", $P7056)
    nqp_get_sc_object $P7057, "1304277414.8", 1
    get_how $P7058, $P7057
    nqp_get_sc_object $P7059, "1304277414.8", 1
    .const 'Sub' $P7060 = "209_1304277427.017" 
    $P7058."add_method"($P7059, "!PREFIX__trait_mod", $P7060)
    nqp_get_sc_object $P7061, "1304277414.8", 1
    get_how $P7062, $P7061
    nqp_get_sc_object $P7063, "1304277414.8", 1
    .const 'Sub' $P7064 = "210_1304277427.017" 
    $P7062."add_method"($P7063, "trait_mod:sym<is>", $P7064)
    nqp_get_sc_object $P7065, "1304277414.8", 1
    get_how $P7066, $P7065
    nqp_get_sc_object $P7067, "1304277414.8", 1
    .const 'Sub' $P7068 = "212_1304277427.017" 
    $P7066."add_method"($P7067, "regex_declarator", $P7068)
    nqp_get_sc_object $P7069, "1304277414.8", 1
    get_how $P7070, $P7069
    nqp_get_sc_object $P7071, "1304277414.8", 1
    .const 'Sub' $P7072 = "214_1304277427.017" 
    $P7070."add_method"($P7071, "dotty", $P7072)
    nqp_get_sc_object $P7073, "1304277414.8", 1
    get_how $P7074, $P7073
    nqp_get_sc_object $P7075, "1304277414.8", 1
    .const 'Sub' $P7076 = "216_1304277427.017" 
    $P7074."add_method"($P7075, "term", $P7076)
    nqp_get_sc_object $P7077, "1304277414.8", 1
    get_how $P7078, $P7077
    nqp_get_sc_object $P7079, "1304277414.8", 1
    .const 'Sub' $P7080 = "217_1304277427.017" 
    $P7078."add_method"($P7079, "!PREFIX__term", $P7080)
    nqp_get_sc_object $P7081, "1304277414.8", 1
    get_how $P7082, $P7081
    nqp_get_sc_object $P7083, "1304277414.8", 1
    .const 'Sub' $P7084 = "218_1304277427.017" 
    $P7082."add_method"($P7083, "term:sym<self>", $P7084)
    nqp_get_sc_object $P7085, "1304277414.8", 1
    get_how $P7086, $P7085
    nqp_get_sc_object $P7087, "1304277414.8", 1
    .const 'Sub' $P7088 = "220_1304277427.017" 
    $P7086."add_method"($P7087, "term:sym<identifier>", $P7088)
    nqp_get_sc_object $P7089, "1304277414.8", 1
    get_how $P7090, $P7089
    nqp_get_sc_object $P7091, "1304277414.8", 1
    .const 'Sub' $P7092 = "222_1304277427.017" 
    $P7090."add_method"($P7091, "term:sym<name>", $P7092)
    nqp_get_sc_object $P7093, "1304277414.8", 1
    get_how $P7094, $P7093
    nqp_get_sc_object $P7095, "1304277414.8", 1
    .const 'Sub' $P7096 = "224_1304277427.017" 
    $P7094."add_method"($P7095, "term:sym<pir::op>", $P7096)
    nqp_get_sc_object $P7097, "1304277414.8", 1
    get_how $P7098, $P7097
    nqp_get_sc_object $P7099, "1304277414.8", 1
    .const 'Sub' $P7100 = "226_1304277427.017" 
    $P7098."add_method"($P7099, "term:sym<onlystar>", $P7100)
    nqp_get_sc_object $P7101, "1304277414.8", 1
    get_how $P7102, $P7101
    nqp_get_sc_object $P7103, "1304277414.8", 1
    .const 'Sub' $P7104 = "229_1304277427.017" 
    $P7102."add_method"($P7103, "args", $P7104)
    nqp_get_sc_object $P7105, "1304277414.8", 1
    get_how $P7106, $P7105
    nqp_get_sc_object $P7107, "1304277414.8", 1
    .const 'Sub' $P7108 = "231_1304277427.017" 
    $P7106."add_method"($P7107, "arglist", $P7108)
    nqp_get_sc_object $P7109, "1304277414.8", 1
    get_how $P7110, $P7109
    nqp_get_sc_object $P7111, "1304277414.8", 1
    .const 'Sub' $P7112 = "233_1304277427.017" 
    $P7110."add_method"($P7111, "term:sym<value>", $P7112)
    nqp_get_sc_object $P7113, "1304277414.8", 1
    get_how $P7114, $P7113
    nqp_get_sc_object $P7115, "1304277414.8", 1
    .const 'Sub' $P7116 = "235_1304277427.017" 
    $P7114."add_method"($P7115, "value", $P7116)
    nqp_get_sc_object $P7117, "1304277414.8", 1
    get_how $P7118, $P7117
    nqp_get_sc_object $P7119, "1304277414.8", 1
    .const 'Sub' $P7120 = "237_1304277427.017" 
    $P7118."add_method"($P7119, "number", $P7120)
    nqp_get_sc_object $P7121, "1304277414.8", 1
    get_how $P7122, $P7121
    nqp_get_sc_object $P7123, "1304277414.8", 1
    .const 'Sub' $P7124 = "239_1304277427.017" 
    $P7122."add_method"($P7123, "quote", $P7124)
    nqp_get_sc_object $P7125, "1304277414.8", 1
    get_how $P7126, $P7125
    nqp_get_sc_object $P7127, "1304277414.8", 1
    .const 'Sub' $P7128 = "240_1304277427.017" 
    $P7126."add_method"($P7127, "!PREFIX__quote", $P7128)
    nqp_get_sc_object $P7129, "1304277414.8", 1
    get_how $P7130, $P7129
    nqp_get_sc_object $P7131, "1304277414.8", 1
    .const 'Sub' $P7132 = "241_1304277427.017" 
    $P7130."add_method"($P7131, "quote:sym<apos>", $P7132)
    nqp_get_sc_object $P7133, "1304277414.8", 1
    get_how $P7134, $P7133
    nqp_get_sc_object $P7135, "1304277414.8", 1
    .const 'Sub' $P7136 = "243_1304277427.017" 
    $P7134."add_method"($P7135, "quote:sym<dblq>", $P7136)
    nqp_get_sc_object $P7137, "1304277414.8", 1
    get_how $P7138, $P7137
    nqp_get_sc_object $P7139, "1304277414.8", 1
    .const 'Sub' $P7140 = "245_1304277427.017" 
    $P7138."add_method"($P7139, "quote:sym<q>", $P7140)
    nqp_get_sc_object $P7141, "1304277414.8", 1
    get_how $P7142, $P7141
    nqp_get_sc_object $P7143, "1304277414.8", 1
    .const 'Sub' $P7144 = "247_1304277427.017" 
    $P7142."add_method"($P7143, "quote:sym<qq>", $P7144)
    nqp_get_sc_object $P7145, "1304277414.8", 1
    get_how $P7146, $P7145
    nqp_get_sc_object $P7147, "1304277414.8", 1
    .const 'Sub' $P7148 = "249_1304277427.017" 
    $P7146."add_method"($P7147, "quote:sym<Q>", $P7148)
    nqp_get_sc_object $P7149, "1304277414.8", 1
    get_how $P7150, $P7149
    nqp_get_sc_object $P7151, "1304277414.8", 1
    .const 'Sub' $P7152 = "251_1304277427.017" 
    $P7150."add_method"($P7151, "quote:sym<Q:PIR>", $P7152)
    nqp_get_sc_object $P7153, "1304277414.8", 1
    get_how $P7154, $P7153
    nqp_get_sc_object $P7155, "1304277414.8", 1
    .const 'Sub' $P7156 = "253_1304277427.017" 
    $P7154."add_method"($P7155, "quote:sym</ />", $P7156)
    nqp_get_sc_object $P7157, "1304277414.8", 1
    get_how $P7158, $P7157
    nqp_get_sc_object $P7159, "1304277414.8", 1
    .const 'Sub' $P7160 = "255_1304277427.017" 
    $P7158."add_method"($P7159, "quote_escape:sym<$>", $P7160)
    nqp_get_sc_object $P7161, "1304277414.8", 1
    get_how $P7162, $P7161
    nqp_get_sc_object $P7163, "1304277414.8", 1
    .const 'Sub' $P7164 = "257_1304277427.017" 
    $P7162."add_method"($P7163, "quote_escape:sym<{ }>", $P7164)
    nqp_get_sc_object $P7165, "1304277414.8", 1
    get_how $P7166, $P7165
    nqp_get_sc_object $P7167, "1304277414.8", 1
    .const 'Sub' $P7168 = "259_1304277427.017" 
    $P7166."add_method"($P7167, "quote_escape:sym<esc>", $P7168)
    nqp_get_sc_object $P7169, "1304277414.8", 1
    get_how $P7170, $P7169
    nqp_get_sc_object $P7171, "1304277414.8", 1
    .const 'Sub' $P7172 = "261_1304277427.017" 
    $P7170."add_method"($P7171, "circumfix:sym<( )>", $P7172)
    nqp_get_sc_object $P7173, "1304277414.8", 1
    get_how $P7174, $P7173
    nqp_get_sc_object $P7175, "1304277414.8", 1
    .const 'Sub' $P7176 = "263_1304277427.017" 
    $P7174."add_method"($P7175, "circumfix:sym<[ ]>", $P7176)
    nqp_get_sc_object $P7177, "1304277414.8", 1
    get_how $P7178, $P7177
    nqp_get_sc_object $P7179, "1304277414.8", 1
    .const 'Sub' $P7180 = "265_1304277427.017" 
    $P7178."add_method"($P7179, "circumfix:sym<ang>", $P7180)
    nqp_get_sc_object $P7181, "1304277414.8", 1
    get_how $P7182, $P7181
    nqp_get_sc_object $P7183, "1304277414.8", 1
    .const 'Sub' $P7184 = "267_1304277427.017" 
    $P7182."add_method"($P7183, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7184)
    nqp_get_sc_object $P7185, "1304277414.8", 1
    get_how $P7186, $P7185
    nqp_get_sc_object $P7187, "1304277414.8", 1
    .const 'Sub' $P7188 = "269_1304277427.017" 
    $P7186."add_method"($P7187, "circumfix:sym<{ }>", $P7188)
    nqp_get_sc_object $P7189, "1304277414.8", 1
    get_how $P7190, $P7189
    nqp_get_sc_object $P7191, "1304277414.8", 1
    .const 'Sub' $P7192 = "271_1304277427.017" 
    $P7190."add_method"($P7191, "circumfix:sym<sigil>", $P7192)
    nqp_get_sc_object $P7193, "1304277414.8", 1
    get_how $P7194, $P7193
    nqp_get_sc_object $P7195, "1304277414.8", 1
    .const 'Sub' $P7196 = "273_1304277427.017" 
    $P7194."add_method"($P7195, "semilist", $P7196)
    nqp_get_sc_object $P7197, "1304277414.8", 1
    get_how $P7198, $P7197
    nqp_get_sc_object $P7199, "1304277414.8", 1
    .const 'Sub' $P7200 = "275_1304277427.017" 
    $P7198."add_method"($P7199, "infixish", $P7200)
    nqp_get_sc_object $P7201, "1304277414.8", 1
    get_how $P7202, $P7201
    nqp_get_sc_object $P7203, "1304277414.8", 1
    .const 'Sub' $P7204 = "277_1304277427.017" 
    $P7202."add_method"($P7203, "infixstopper", $P7204)
    nqp_get_sc_object $P7205, "1304277414.8", 1
    get_how $P7206, $P7205
    nqp_get_sc_object $P7207, "1304277414.8", 1
    .const 'Sub' $P7208 = "279_1304277427.017" 
    $P7206."add_method"($P7207, "postcircumfix:sym<[ ]>", $P7208)
    nqp_get_sc_object $P7209, "1304277414.8", 1
    get_how $P7210, $P7209
    nqp_get_sc_object $P7211, "1304277414.8", 1
    .const 'Sub' $P7212 = "281_1304277427.017" 
    $P7210."add_method"($P7211, "postcircumfix:sym<{ }>", $P7212)
    nqp_get_sc_object $P7213, "1304277414.8", 1
    get_how $P7214, $P7213
    nqp_get_sc_object $P7215, "1304277414.8", 1
    .const 'Sub' $P7216 = "283_1304277427.017" 
    $P7214."add_method"($P7215, "postcircumfix:sym<ang>", $P7216)
    nqp_get_sc_object $P7217, "1304277414.8", 1
    get_how $P7218, $P7217
    nqp_get_sc_object $P7219, "1304277414.8", 1
    .const 'Sub' $P7220 = "285_1304277427.017" 
    $P7218."add_method"($P7219, "postcircumfix:sym<( )>", $P7220)
    nqp_get_sc_object $P7221, "1304277414.8", 1
    get_how $P7222, $P7221
    nqp_get_sc_object $P7223, "1304277414.8", 1
    .const 'Sub' $P7224 = "287_1304277427.017" 
    $P7222."add_method"($P7223, "postfix:sym<.>", $P7224)
    nqp_get_sc_object $P7225, "1304277414.8", 1
    get_how $P7226, $P7225
    nqp_get_sc_object $P7227, "1304277414.8", 1
    .const 'Sub' $P7228 = "289_1304277427.017" 
    $P7226."add_method"($P7227, "prefix:sym<++>", $P7228)
    nqp_get_sc_object $P7229, "1304277414.8", 1
    get_how $P7230, $P7229
    nqp_get_sc_object $P7231, "1304277414.8", 1
    .const 'Sub' $P7232 = "291_1304277427.017" 
    $P7230."add_method"($P7231, "prefix:sym<-->", $P7232)
    nqp_get_sc_object $P7233, "1304277414.8", 1
    get_how $P7234, $P7233
    nqp_get_sc_object $P7235, "1304277414.8", 1
    .const 'Sub' $P7236 = "293_1304277427.017" 
    $P7234."add_method"($P7235, "postfix:sym<++>", $P7236)
    nqp_get_sc_object $P7237, "1304277414.8", 1
    get_how $P7238, $P7237
    nqp_get_sc_object $P7239, "1304277414.8", 1
    .const 'Sub' $P7240 = "295_1304277427.017" 
    $P7238."add_method"($P7239, "postfix:sym<-->", $P7240)
    nqp_get_sc_object $P7241, "1304277414.8", 1
    get_how $P7242, $P7241
    nqp_get_sc_object $P7243, "1304277414.8", 1
    .const 'Sub' $P7244 = "297_1304277427.017" 
    $P7242."add_method"($P7243, "infix:sym<**>", $P7244)
    nqp_get_sc_object $P7245, "1304277414.8", 1
    get_how $P7246, $P7245
    nqp_get_sc_object $P7247, "1304277414.8", 1
    .const 'Sub' $P7248 = "299_1304277427.017" 
    $P7246."add_method"($P7247, "prefix:sym<+>", $P7248)
    nqp_get_sc_object $P7249, "1304277414.8", 1
    get_how $P7250, $P7249
    nqp_get_sc_object $P7251, "1304277414.8", 1
    .const 'Sub' $P7252 = "301_1304277427.017" 
    $P7250."add_method"($P7251, "prefix:sym<~>", $P7252)
    nqp_get_sc_object $P7253, "1304277414.8", 1
    get_how $P7254, $P7253
    nqp_get_sc_object $P7255, "1304277414.8", 1
    .const 'Sub' $P7256 = "303_1304277427.017" 
    $P7254."add_method"($P7255, "prefix:sym<->", $P7256)
    nqp_get_sc_object $P7257, "1304277414.8", 1
    get_how $P7258, $P7257
    nqp_get_sc_object $P7259, "1304277414.8", 1
    .const 'Sub' $P7260 = "305_1304277427.017" 
    $P7258."add_method"($P7259, "prefix:sym<?>", $P7260)
    nqp_get_sc_object $P7261, "1304277414.8", 1
    get_how $P7262, $P7261
    nqp_get_sc_object $P7263, "1304277414.8", 1
    .const 'Sub' $P7264 = "307_1304277427.017" 
    $P7262."add_method"($P7263, "prefix:sym<!>", $P7264)
    nqp_get_sc_object $P7265, "1304277414.8", 1
    get_how $P7266, $P7265
    nqp_get_sc_object $P7267, "1304277414.8", 1
    .const 'Sub' $P7268 = "309_1304277427.017" 
    $P7266."add_method"($P7267, "prefix:sym<|>", $P7268)
    nqp_get_sc_object $P7269, "1304277414.8", 1
    get_how $P7270, $P7269
    nqp_get_sc_object $P7271, "1304277414.8", 1
    .const 'Sub' $P7272 = "311_1304277427.017" 
    $P7270."add_method"($P7271, "infix:sym<*>", $P7272)
    nqp_get_sc_object $P7273, "1304277414.8", 1
    get_how $P7274, $P7273
    nqp_get_sc_object $P7275, "1304277414.8", 1
    .const 'Sub' $P7276 = "313_1304277427.017" 
    $P7274."add_method"($P7275, "infix:sym</>", $P7276)
    nqp_get_sc_object $P7277, "1304277414.8", 1
    get_how $P7278, $P7277
    nqp_get_sc_object $P7279, "1304277414.8", 1
    .const 'Sub' $P7280 = "315_1304277427.017" 
    $P7278."add_method"($P7279, "infix:sym<%>", $P7280)
    nqp_get_sc_object $P7281, "1304277414.8", 1
    get_how $P7282, $P7281
    nqp_get_sc_object $P7283, "1304277414.8", 1
    .const 'Sub' $P7284 = "317_1304277427.017" 
    $P7282."add_method"($P7283, "infix:sym<+&>", $P7284)
    nqp_get_sc_object $P7285, "1304277414.8", 1
    get_how $P7286, $P7285
    nqp_get_sc_object $P7287, "1304277414.8", 1
    .const 'Sub' $P7288 = "319_1304277427.017" 
    $P7286."add_method"($P7287, "infix:sym<+>", $P7288)
    nqp_get_sc_object $P7289, "1304277414.8", 1
    get_how $P7290, $P7289
    nqp_get_sc_object $P7291, "1304277414.8", 1
    .const 'Sub' $P7292 = "321_1304277427.017" 
    $P7290."add_method"($P7291, "infix:sym<->", $P7292)
    nqp_get_sc_object $P7293, "1304277414.8", 1
    get_how $P7294, $P7293
    nqp_get_sc_object $P7295, "1304277414.8", 1
    .const 'Sub' $P7296 = "323_1304277427.017" 
    $P7294."add_method"($P7295, "infix:sym<+|>", $P7296)
    nqp_get_sc_object $P7297, "1304277414.8", 1
    get_how $P7298, $P7297
    nqp_get_sc_object $P7299, "1304277414.8", 1
    .const 'Sub' $P7300 = "325_1304277427.017" 
    $P7298."add_method"($P7299, "infix:sym<+^>", $P7300)
    nqp_get_sc_object $P7301, "1304277414.8", 1
    get_how $P7302, $P7301
    nqp_get_sc_object $P7303, "1304277414.8", 1
    .const 'Sub' $P7304 = "327_1304277427.017" 
    $P7302."add_method"($P7303, "infix:sym<~>", $P7304)
    nqp_get_sc_object $P7305, "1304277414.8", 1
    get_how $P7306, $P7305
    nqp_get_sc_object $P7307, "1304277414.8", 1
    .const 'Sub' $P7308 = "329_1304277427.017" 
    $P7306."add_method"($P7307, "infix:sym<==>", $P7308)
    nqp_get_sc_object $P7309, "1304277414.8", 1
    get_how $P7310, $P7309
    nqp_get_sc_object $P7311, "1304277414.8", 1
    .const 'Sub' $P7312 = "331_1304277427.017" 
    $P7310."add_method"($P7311, "infix:sym<!=>", $P7312)
    nqp_get_sc_object $P7313, "1304277414.8", 1
    get_how $P7314, $P7313
    nqp_get_sc_object $P7315, "1304277414.8", 1
    .const 'Sub' $P7316 = "333_1304277427.017" 
    $P7314."add_method"($P7315, "infix:sym<<=>", $P7316)
    nqp_get_sc_object $P7317, "1304277414.8", 1
    get_how $P7318, $P7317
    nqp_get_sc_object $P7319, "1304277414.8", 1
    .const 'Sub' $P7320 = "335_1304277427.017" 
    $P7318."add_method"($P7319, "infix:sym<>=>", $P7320)
    nqp_get_sc_object $P7321, "1304277414.8", 1
    get_how $P7322, $P7321
    nqp_get_sc_object $P7323, "1304277414.8", 1
    .const 'Sub' $P7324 = "337_1304277427.017" 
    $P7322."add_method"($P7323, "infix:sym<<>", $P7324)
    nqp_get_sc_object $P7325, "1304277414.8", 1
    get_how $P7326, $P7325
    nqp_get_sc_object $P7327, "1304277414.8", 1
    .const 'Sub' $P7328 = "339_1304277427.017" 
    $P7326."add_method"($P7327, "infix:sym<>>", $P7328)
    nqp_get_sc_object $P7329, "1304277414.8", 1
    get_how $P7330, $P7329
    nqp_get_sc_object $P7331, "1304277414.8", 1
    .const 'Sub' $P7332 = "341_1304277427.017" 
    $P7330."add_method"($P7331, "infix:sym<eq>", $P7332)
    nqp_get_sc_object $P7333, "1304277414.8", 1
    get_how $P7334, $P7333
    nqp_get_sc_object $P7335, "1304277414.8", 1
    .const 'Sub' $P7336 = "343_1304277427.017" 
    $P7334."add_method"($P7335, "infix:sym<ne>", $P7336)
    nqp_get_sc_object $P7337, "1304277414.8", 1
    get_how $P7338, $P7337
    nqp_get_sc_object $P7339, "1304277414.8", 1
    .const 'Sub' $P7340 = "345_1304277427.017" 
    $P7338."add_method"($P7339, "infix:sym<le>", $P7340)
    nqp_get_sc_object $P7341, "1304277414.8", 1
    get_how $P7342, $P7341
    nqp_get_sc_object $P7343, "1304277414.8", 1
    .const 'Sub' $P7344 = "347_1304277427.017" 
    $P7342."add_method"($P7343, "infix:sym<ge>", $P7344)
    nqp_get_sc_object $P7345, "1304277414.8", 1
    get_how $P7346, $P7345
    nqp_get_sc_object $P7347, "1304277414.8", 1
    .const 'Sub' $P7348 = "349_1304277427.017" 
    $P7346."add_method"($P7347, "infix:sym<lt>", $P7348)
    nqp_get_sc_object $P7349, "1304277414.8", 1
    get_how $P7350, $P7349
    nqp_get_sc_object $P7351, "1304277414.8", 1
    .const 'Sub' $P7352 = "351_1304277427.017" 
    $P7350."add_method"($P7351, "infix:sym<gt>", $P7352)
    nqp_get_sc_object $P7353, "1304277414.8", 1
    get_how $P7354, $P7353
    nqp_get_sc_object $P7355, "1304277414.8", 1
    .const 'Sub' $P7356 = "353_1304277427.017" 
    $P7354."add_method"($P7355, "infix:sym<=:=>", $P7356)
    nqp_get_sc_object $P7357, "1304277414.8", 1
    get_how $P7358, $P7357
    nqp_get_sc_object $P7359, "1304277414.8", 1
    .const 'Sub' $P7360 = "355_1304277427.017" 
    $P7358."add_method"($P7359, "infix:sym<~~>", $P7360)
    nqp_get_sc_object $P7361, "1304277414.8", 1
    get_how $P7362, $P7361
    nqp_get_sc_object $P7363, "1304277414.8", 1
    .const 'Sub' $P7364 = "357_1304277427.017" 
    $P7362."add_method"($P7363, "infix:sym<&&>", $P7364)
    nqp_get_sc_object $P7365, "1304277414.8", 1
    get_how $P7366, $P7365
    nqp_get_sc_object $P7367, "1304277414.8", 1
    .const 'Sub' $P7368 = "359_1304277427.017" 
    $P7366."add_method"($P7367, "infix:sym<||>", $P7368)
    nqp_get_sc_object $P7369, "1304277414.8", 1
    get_how $P7370, $P7369
    nqp_get_sc_object $P7371, "1304277414.8", 1
    .const 'Sub' $P7372 = "361_1304277427.017" 
    $P7370."add_method"($P7371, "infix:sym<//>", $P7372)
    nqp_get_sc_object $P7373, "1304277414.8", 1
    get_how $P7374, $P7373
    nqp_get_sc_object $P7375, "1304277414.8", 1
    .const 'Sub' $P7376 = "363_1304277427.017" 
    $P7374."add_method"($P7375, "infix:sym<?? !!>", $P7376)
    nqp_get_sc_object $P7377, "1304277414.8", 1
    get_how $P7378, $P7377
    nqp_get_sc_object $P7379, "1304277414.8", 1
    .const 'Sub' $P7380 = "365_1304277427.017" 
    $P7378."add_method"($P7379, "infix:sym<=>", $P7380)
    nqp_get_sc_object $P7381, "1304277414.8", 1
    get_how $P7382, $P7381
    nqp_get_sc_object $P7383, "1304277414.8", 1
    .const 'Sub' $P7384 = "367_1304277427.017" 
    $P7382."add_method"($P7383, "infix:sym<:=>", $P7384)
    nqp_get_sc_object $P7385, "1304277414.8", 1
    get_how $P7386, $P7385
    nqp_get_sc_object $P7387, "1304277414.8", 1
    .const 'Sub' $P7388 = "369_1304277427.017" 
    $P7386."add_method"($P7387, "infix:sym<::=>", $P7388)
    nqp_get_sc_object $P7389, "1304277414.8", 1
    get_how $P7390, $P7389
    nqp_get_sc_object $P7391, "1304277414.8", 1
    .const 'Sub' $P7392 = "371_1304277427.017" 
    $P7390."add_method"($P7391, "infix:sym<,>", $P7392)
    nqp_get_sc_object $P7393, "1304277414.8", 1
    get_how $P7394, $P7393
    nqp_get_sc_object $P7395, "1304277414.8", 1
    .const 'Sub' $P7396 = "373_1304277427.017" 
    $P7394."add_method"($P7395, "prefix:sym<return>", $P7396)
    nqp_get_sc_object $P7397, "1304277414.8", 1
    get_how $P7398, $P7397
    nqp_get_sc_object $P7399, "1304277414.8", 1
    .const 'Sub' $P7400 = "376_1304277427.017" 
    $P7398."add_method"($P7399, "prefix:sym<make>", $P7400)
    nqp_get_sc_object $P7401, "1304277414.8", 1
    get_how $P7402, $P7401
    nqp_get_sc_object $P7403, "1304277414.8", 1
    .const 'Sub' $P7404 = "378_1304277427.017" 
    $P7402."add_method"($P7403, "term:sym<last>", $P7404)
    nqp_get_sc_object $P7405, "1304277414.8", 1
    get_how $P7406, $P7405
    nqp_get_sc_object $P7407, "1304277414.8", 1
    .const 'Sub' $P7408 = "380_1304277427.017" 
    $P7406."add_method"($P7407, "term:sym<next>", $P7408)
    nqp_get_sc_object $P7409, "1304277414.8", 1
    get_how $P7410, $P7409
    nqp_get_sc_object $P7411, "1304277414.8", 1
    .const 'Sub' $P7412 = "382_1304277427.017" 
    $P7410."add_method"($P7411, "term:sym<redo>", $P7412)
    nqp_get_sc_object $P7413, "1304277414.8", 1
    get_how $P7414, $P7413
    nqp_get_sc_object $P7415, "1304277414.8", 1
    .const 'Sub' $P7416 = "384_1304277427.017" 
    $P7414."add_method"($P7415, "smartmatch", $P7416)
    .const 'Sub' $P7417 = "12_1304277427.017" 
    $P7418 = $P7417."get_lexinfo"()
    nqp_get_sc_object $P7419, "1304277414.8", 1
    $P7418."set_static_lexpad_value"("$?PACKAGE", $P7419)
    .const 'Sub' $P7420 = "12_1304277427.017" 
    $P7421 = $P7420."get_lexinfo"()
    $P7421."finish_static_lexpad"()
    .const 'Sub' $P7422 = "12_1304277427.017" 
    $P7423 = $P7422."get_lexinfo"()
    nqp_get_sc_object $P7424, "1304277414.8", 1
    $P7423."set_static_lexpad_value"("$?CLASS", $P7424)
    .const 'Sub' $P7425 = "12_1304277427.017" 
    $P7426 = $P7425."get_lexinfo"()
    $P7426."finish_static_lexpad"()
    nqp_get_sc_object $P7427, "1304277414.8", 1
    get_how $P7428, $P7427
    nqp_get_sc_object $P7429, "1304277414.8", 1
    nqp_get_sc_object $P7430, "1304277396.391", 1
    $P7428."add_parent"($P7429, $P7430)
    nqp_get_sc_object $P7431, "1304277388.915", 41
    $P7432 = $P7431."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P7432, cur_sc
    nqp_set_sc_object "1304277414.8", 194, $P7432
    nqp_get_sc_object $P7433, "1304277414.8", 194
    nqp_get_sc_object $P7434, "1304277414.8", 0
    nqp_get_package_through_who $P7435, $P7434, "NQP"
    get_who $P7436, $P7435
    set $P7436["Regex"], $P7433
    nqp_get_sc_object $P7437, "1304277414.8", 194
    get_how $P7438, $P7437
    nqp_get_sc_object $P7439, "1304277414.8", 194
    .const 'Sub' $P7440 = "387_1304277427.017" 
    $P7438."add_method"($P7439, "metachar:sym<:my>", $P7440)
    nqp_get_sc_object $P7441, "1304277414.8", 194
    get_how $P7442, $P7441
    nqp_get_sc_object $P7443, "1304277414.8", 194
    .const 'Sub' $P7444 = "390_1304277427.017" 
    $P7442."add_method"($P7443, "metachar:sym<{ }>", $P7444)
    nqp_get_sc_object $P7445, "1304277414.8", 194
    get_how $P7446, $P7445
    nqp_get_sc_object $P7447, "1304277414.8", 194
    .const 'Sub' $P7448 = "392_1304277427.017" 
    $P7446."add_method"($P7447, "metachar:sym<nqpvar>", $P7448)
    nqp_get_sc_object $P7449, "1304277414.8", 194
    get_how $P7450, $P7449
    nqp_get_sc_object $P7451, "1304277414.8", 194
    .const 'Sub' $P7452 = "395_1304277427.017" 
    $P7450."add_method"($P7451, "assertion:sym<{ }>", $P7452)
    nqp_get_sc_object $P7453, "1304277414.8", 194
    get_how $P7454, $P7453
    nqp_get_sc_object $P7455, "1304277414.8", 194
    .const 'Sub' $P7456 = "397_1304277427.017" 
    $P7454."add_method"($P7455, "assertion:sym<?{ }>", $P7456)
    nqp_get_sc_object $P7457, "1304277414.8", 194
    get_how $P7458, $P7457
    nqp_get_sc_object $P7459, "1304277414.8", 194
    .const 'Sub' $P7460 = "400_1304277427.017" 
    $P7458."add_method"($P7459, "assertion:sym<name>", $P7460)
    nqp_get_sc_object $P7461, "1304277414.8", 194
    get_how $P7462, $P7461
    nqp_get_sc_object $P7463, "1304277414.8", 194
    .const 'Sub' $P7464 = "403_1304277427.017" 
    $P7462."add_method"($P7463, "assertion:sym<var>", $P7464)
    nqp_get_sc_object $P7465, "1304277414.8", 194
    get_how $P7466, $P7465
    nqp_get_sc_object $P7467, "1304277414.8", 194
    .const 'Sub' $P7468 = "405_1304277427.017" 
    $P7466."add_method"($P7467, "codeblock", $P7468)
    .const 'Sub' $P7469 = "386_1304277427.017" 
    $P7470 = $P7469."get_lexinfo"()
    nqp_get_sc_object $P7471, "1304277414.8", 194
    $P7470."set_static_lexpad_value"("$?PACKAGE", $P7471)
    .const 'Sub' $P7472 = "386_1304277427.017" 
    $P7473 = $P7472."get_lexinfo"()
    $P7473."finish_static_lexpad"()
    .const 'Sub' $P7474 = "386_1304277427.017" 
    $P7475 = $P7474."get_lexinfo"()
    nqp_get_sc_object $P7476, "1304277414.8", 194
    $P7475."set_static_lexpad_value"("$?CLASS", $P7476)
    .const 'Sub' $P7477 = "386_1304277427.017" 
    $P7478 = $P7477."get_lexinfo"()
    $P7478."finish_static_lexpad"()
    nqp_get_sc_object $P7479, "1304277414.8", 194
    get_how $P7480, $P7479
    nqp_get_sc_object $P7481, "1304277414.8", 194
    nqp_get_sc_object $P7482, "1304277407.992", 1
    $P7480."add_parent"($P7481, $P7482)
    nqp_get_sc_object $P7483, "1304277388.915", 41
    $P7484 = $P7483."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P7484, cur_sc
    nqp_set_sc_object "1304277414.8", 203, $P7484
    nqp_get_sc_object $P7485, "1304277414.8", 203
    nqp_get_sc_object $P7486, "1304277414.8", 0
    nqp_get_package_through_who $P7487, $P7486, "NQP"
    get_who $P7488, $P7487
    set $P7488["Actions"], $P7485
    nqp_get_sc_object $P7489, "1304277414.8", 203
    get_how $P7490, $P7489
    nqp_get_sc_object $P7491, "1304277414.8", 203
    .const 'Sub' $P7492 = "435_1304277427.017" 
    $P7490."add_method"($P7491, "TOP", $P7492)
    nqp_get_sc_object $P7493, "1304277414.8", 203
    get_how $P7494, $P7493
    nqp_get_sc_object $P7495, "1304277414.8", 203
    .const 'Sub' $P7496 = "436_1304277427.017" 
    $P7494."add_method"($P7495, "deflongname", $P7496)
    nqp_get_sc_object $P7497, "1304277414.8", 203
    get_how $P7498, $P7497
    nqp_get_sc_object $P7499, "1304277414.8", 203
    .const 'Sub' $P7500 = "437_1304277427.017" 
    $P7498."add_method"($P7499, "comp_unit", $P7500)
    nqp_get_sc_object $P7501, "1304277414.8", 203
    get_how $P7502, $P7501
    nqp_get_sc_object $P7503, "1304277414.8", 203
    .const 'Sub' $P7504 = "438_1304277427.017" 
    $P7502."add_method"($P7503, "statementlist", $P7504)
    nqp_get_sc_object $P7505, "1304277414.8", 203
    get_how $P7506, $P7505
    nqp_get_sc_object $P7507, "1304277414.8", 203
    .const 'Sub' $P7508 = "440_1304277427.017" 
    $P7506."add_method"($P7507, "statement", $P7508)
    nqp_get_sc_object $P7509, "1304277414.8", 203
    get_how $P7510, $P7509
    nqp_get_sc_object $P7511, "1304277414.8", 203
    .const 'Sub' $P7512 = "442_1304277427.017" 
    $P7510."add_method"($P7511, "xblock", $P7512)
    nqp_get_sc_object $P7513, "1304277414.8", 203
    get_how $P7514, $P7513
    nqp_get_sc_object $P7515, "1304277414.8", 203
    .const 'Sub' $P7516 = "443_1304277427.017" 
    $P7514."add_method"($P7515, "pblock", $P7516)
    nqp_get_sc_object $P7517, "1304277414.8", 203
    get_how $P7518, $P7517
    nqp_get_sc_object $P7519, "1304277414.8", 203
    .const 'Sub' $P7520 = "444_1304277427.017" 
    $P7518."add_method"($P7519, "block", $P7520)
    nqp_get_sc_object $P7521, "1304277414.8", 203
    get_how $P7522, $P7521
    nqp_get_sc_object $P7523, "1304277414.8", 203
    .const 'Sub' $P7524 = "445_1304277427.017" 
    $P7522."add_method"($P7523, "blockoid", $P7524)
    nqp_get_sc_object $P7525, "1304277414.8", 203
    get_how $P7526, $P7525
    nqp_get_sc_object $P7527, "1304277414.8", 203
    .const 'Sub' $P7528 = "447_1304277427.017" 
    $P7526."add_method"($P7527, "newpad", $P7528)
    nqp_get_sc_object $P7529, "1304277414.8", 203
    get_how $P7530, $P7529
    nqp_get_sc_object $P7531, "1304277414.8", 203
    .const 'Sub' $P7532 = "448_1304277427.017" 
    $P7530."add_method"($P7531, "outerctx", $P7532)
    nqp_get_sc_object $P7533, "1304277414.8", 203
    get_how $P7534, $P7533
    nqp_get_sc_object $P7535, "1304277414.8", 203
    .const 'Sub' $P7536 = "450_1304277427.017" 
    $P7534."add_method"($P7535, "GLOBALish", $P7536)
    nqp_get_sc_object $P7537, "1304277414.8", 203
    get_how $P7538, $P7537
    nqp_get_sc_object $P7539, "1304277414.8", 203
    .const 'Sub' $P7540 = "451_1304277427.017" 
    $P7538."add_method"($P7539, "you_are_here", $P7540)
    nqp_get_sc_object $P7541, "1304277414.8", 203
    get_how $P7542, $P7541
    nqp_get_sc_object $P7543, "1304277414.8", 203
    .const 'Sub' $P7544 = "452_1304277427.017" 
    $P7542."add_method"($P7543, "statement_control:sym<use>", $P7544)
    nqp_get_sc_object $P7545, "1304277414.8", 203
    get_how $P7546, $P7545
    nqp_get_sc_object $P7547, "1304277414.8", 203
    .const 'Sub' $P7548 = "453_1304277427.017" 
    $P7546."add_method"($P7547, "statement_control:sym<if>", $P7548)
    nqp_get_sc_object $P7549, "1304277414.8", 203
    get_how $P7550, $P7549
    nqp_get_sc_object $P7551, "1304277414.8", 203
    .const 'Sub' $P7552 = "455_1304277427.017" 
    $P7550."add_method"($P7551, "statement_control:sym<unless>", $P7552)
    nqp_get_sc_object $P7553, "1304277414.8", 203
    get_how $P7554, $P7553
    nqp_get_sc_object $P7555, "1304277414.8", 203
    .const 'Sub' $P7556 = "456_1304277427.017" 
    $P7554."add_method"($P7555, "statement_control:sym<while>", $P7556)
    nqp_get_sc_object $P7557, "1304277414.8", 203
    get_how $P7558, $P7557
    nqp_get_sc_object $P7559, "1304277414.8", 203
    .const 'Sub' $P7560 = "457_1304277427.017" 
    $P7558."add_method"($P7559, "statement_control:sym<repeat>", $P7560)
    nqp_get_sc_object $P7561, "1304277414.8", 203
    get_how $P7562, $P7561
    nqp_get_sc_object $P7563, "1304277414.8", 203
    .const 'Sub' $P7564 = "458_1304277427.017" 
    $P7562."add_method"($P7563, "statement_control:sym<for>", $P7564)
    nqp_get_sc_object $P7565, "1304277414.8", 203
    get_how $P7566, $P7565
    nqp_get_sc_object $P7567, "1304277414.8", 203
    .const 'Sub' $P7568 = "459_1304277427.017" 
    $P7566."add_method"($P7567, "statement_control:sym<CATCH>", $P7568)
    nqp_get_sc_object $P7569, "1304277414.8", 203
    get_how $P7570, $P7569
    nqp_get_sc_object $P7571, "1304277414.8", 203
    .const 'Sub' $P7572 = "460_1304277427.017" 
    $P7570."add_method"($P7571, "statement_control:sym<CONTROL>", $P7572)
    nqp_get_sc_object $P7573, "1304277414.8", 203
    get_how $P7574, $P7573
    nqp_get_sc_object $P7575, "1304277414.8", 203
    .const 'Sub' $P7576 = "461_1304277427.017" 
    $P7574."add_method"($P7575, "statement_prefix:sym<INIT>", $P7576)
    nqp_get_sc_object $P7577, "1304277414.8", 203
    get_how $P7578, $P7577
    nqp_get_sc_object $P7579, "1304277414.8", 203
    .const 'Sub' $P7580 = "462_1304277427.017" 
    $P7578."add_method"($P7579, "statement_prefix:sym<try>", $P7580)
    nqp_get_sc_object $P7581, "1304277414.8", 203
    get_how $P7582, $P7581
    nqp_get_sc_object $P7583, "1304277414.8", 203
    .const 'Sub' $P7584 = "463_1304277427.017" 
    $P7582."add_method"($P7583, "blorst", $P7584)
    nqp_get_sc_object $P7585, "1304277414.8", 203
    get_how $P7586, $P7585
    nqp_get_sc_object $P7587, "1304277414.8", 203
    .const 'Sub' $P7588 = "464_1304277427.017" 
    $P7586."add_method"($P7587, "statement_mod_cond:sym<if>", $P7588)
    nqp_get_sc_object $P7589, "1304277414.8", 203
    get_how $P7590, $P7589
    nqp_get_sc_object $P7591, "1304277414.8", 203
    .const 'Sub' $P7592 = "465_1304277427.017" 
    $P7590."add_method"($P7591, "statement_mod_cond:sym<unless>", $P7592)
    nqp_get_sc_object $P7593, "1304277414.8", 203
    get_how $P7594, $P7593
    nqp_get_sc_object $P7595, "1304277414.8", 203
    .const 'Sub' $P7596 = "466_1304277427.017" 
    $P7594."add_method"($P7595, "statement_mod_loop:sym<while>", $P7596)
    nqp_get_sc_object $P7597, "1304277414.8", 203
    get_how $P7598, $P7597
    nqp_get_sc_object $P7599, "1304277414.8", 203
    .const 'Sub' $P7600 = "467_1304277427.017" 
    $P7598."add_method"($P7599, "statement_mod_loop:sym<until>", $P7600)
    nqp_get_sc_object $P7601, "1304277414.8", 203
    get_how $P7602, $P7601
    nqp_get_sc_object $P7603, "1304277414.8", 203
    .const 'Sub' $P7604 = "468_1304277427.017" 
    $P7602."add_method"($P7603, "term:sym<fatarrow>", $P7604)
    nqp_get_sc_object $P7605, "1304277414.8", 203
    get_how $P7606, $P7605
    nqp_get_sc_object $P7607, "1304277414.8", 203
    .const 'Sub' $P7608 = "469_1304277427.017" 
    $P7606."add_method"($P7607, "term:sym<colonpair>", $P7608)
    nqp_get_sc_object $P7609, "1304277414.8", 203
    get_how $P7610, $P7609
    nqp_get_sc_object $P7611, "1304277414.8", 203
    .const 'Sub' $P7612 = "470_1304277427.017" 
    $P7610."add_method"($P7611, "term:sym<variable>", $P7612)
    nqp_get_sc_object $P7613, "1304277414.8", 203
    get_how $P7614, $P7613
    nqp_get_sc_object $P7615, "1304277414.8", 203
    .const 'Sub' $P7616 = "471_1304277427.017" 
    $P7614."add_method"($P7615, "term:sym<package_declarator>", $P7616)
    nqp_get_sc_object $P7617, "1304277414.8", 203
    get_how $P7618, $P7617
    nqp_get_sc_object $P7619, "1304277414.8", 203
    .const 'Sub' $P7620 = "472_1304277427.017" 
    $P7618."add_method"($P7619, "term:sym<scope_declarator>", $P7620)
    nqp_get_sc_object $P7621, "1304277414.8", 203
    get_how $P7622, $P7621
    nqp_get_sc_object $P7623, "1304277414.8", 203
    .const 'Sub' $P7624 = "473_1304277427.017" 
    $P7622."add_method"($P7623, "term:sym<routine_declarator>", $P7624)
    nqp_get_sc_object $P7625, "1304277414.8", 203
    get_how $P7626, $P7625
    nqp_get_sc_object $P7627, "1304277414.8", 203
    .const 'Sub' $P7628 = "474_1304277427.017" 
    $P7626."add_method"($P7627, "term:sym<regex_declarator>", $P7628)
    nqp_get_sc_object $P7629, "1304277414.8", 203
    get_how $P7630, $P7629
    nqp_get_sc_object $P7631, "1304277414.8", 203
    .const 'Sub' $P7632 = "475_1304277427.017" 
    $P7630."add_method"($P7631, "term:sym<statement_prefix>", $P7632)
    nqp_get_sc_object $P7633, "1304277414.8", 203
    get_how $P7634, $P7633
    nqp_get_sc_object $P7635, "1304277414.8", 203
    .const 'Sub' $P7636 = "476_1304277427.017" 
    $P7634."add_method"($P7635, "term:sym<lambda>", $P7636)
    nqp_get_sc_object $P7637, "1304277414.8", 203
    get_how $P7638, $P7637
    nqp_get_sc_object $P7639, "1304277414.8", 203
    .const 'Sub' $P7640 = "477_1304277427.017" 
    $P7638."add_method"($P7639, "fatarrow", $P7640)
    nqp_get_sc_object $P7641, "1304277414.8", 203
    get_how $P7642, $P7641
    nqp_get_sc_object $P7643, "1304277414.8", 203
    .const 'Sub' $P7644 = "478_1304277427.017" 
    $P7642."add_method"($P7643, "colonpair", $P7644)
    nqp_get_sc_object $P7645, "1304277414.8", 203
    get_how $P7646, $P7645
    nqp_get_sc_object $P7647, "1304277414.8", 203
    .const 'Sub' $P7648 = "479_1304277427.017" 
    $P7646."add_method"($P7647, "variable", $P7648)
    nqp_get_sc_object $P7649, "1304277414.8", 203
    get_how $P7650, $P7649
    nqp_get_sc_object $P7651, "1304277414.8", 203
    .const 'Sub' $P7652 = "485_1304277427.017" 
    $P7650."add_method"($P7651, "package_declarator:sym<module>", $P7652)
    nqp_get_sc_object $P7653, "1304277414.8", 203
    get_how $P7654, $P7653
    nqp_get_sc_object $P7655, "1304277414.8", 203
    .const 'Sub' $P7656 = "486_1304277427.017" 
    $P7654."add_method"($P7655, "package_declarator:sym<knowhow>", $P7656)
    nqp_get_sc_object $P7657, "1304277414.8", 203
    get_how $P7658, $P7657
    nqp_get_sc_object $P7659, "1304277414.8", 203
    .const 'Sub' $P7660 = "487_1304277427.017" 
    $P7658."add_method"($P7659, "package_declarator:sym<class>", $P7660)
    nqp_get_sc_object $P7661, "1304277414.8", 203
    get_how $P7662, $P7661
    nqp_get_sc_object $P7663, "1304277414.8", 203
    .const 'Sub' $P7664 = "488_1304277427.017" 
    $P7662."add_method"($P7663, "package_declarator:sym<grammar>", $P7664)
    nqp_get_sc_object $P7665, "1304277414.8", 203
    get_how $P7666, $P7665
    nqp_get_sc_object $P7667, "1304277414.8", 203
    .const 'Sub' $P7668 = "489_1304277427.017" 
    $P7666."add_method"($P7667, "package_declarator:sym<role>", $P7668)
    nqp_get_sc_object $P7669, "1304277414.8", 203
    get_how $P7670, $P7669
    nqp_get_sc_object $P7671, "1304277414.8", 203
    .const 'Sub' $P7672 = "490_1304277427.017" 
    $P7670."add_method"($P7671, "package_declarator:sym<native>", $P7672)
    nqp_get_sc_object $P7673, "1304277414.8", 203
    get_how $P7674, $P7673
    nqp_get_sc_object $P7675, "1304277414.8", 203
    .const 'Sub' $P7676 = "491_1304277427.017" 
    $P7674."add_method"($P7675, "package_def", $P7676)
    nqp_get_sc_object $P7677, "1304277414.8", 203
    get_how $P7678, $P7677
    nqp_get_sc_object $P7679, "1304277414.8", 203
    .const 'Sub' $P7680 = "497_1304277427.017" 
    $P7678."add_method"($P7679, "scope_declarator:sym<my>", $P7680)
    nqp_get_sc_object $P7681, "1304277414.8", 203
    get_how $P7682, $P7681
    nqp_get_sc_object $P7683, "1304277414.8", 203
    .const 'Sub' $P7684 = "498_1304277427.017" 
    $P7682."add_method"($P7683, "scope_declarator:sym<our>", $P7684)
    nqp_get_sc_object $P7685, "1304277414.8", 203
    get_how $P7686, $P7685
    nqp_get_sc_object $P7687, "1304277414.8", 203
    .const 'Sub' $P7688 = "499_1304277427.017" 
    $P7686."add_method"($P7687, "scope_declarator:sym<has>", $P7688)
    nqp_get_sc_object $P7689, "1304277414.8", 203
    get_how $P7690, $P7689
    nqp_get_sc_object $P7691, "1304277414.8", 203
    .const 'Sub' $P7692 = "500_1304277427.017" 
    $P7690."add_method"($P7691, "scoped", $P7692)
    nqp_get_sc_object $P7693, "1304277414.8", 203
    get_how $P7694, $P7693
    nqp_get_sc_object $P7695, "1304277414.8", 203
    .const 'Sub' $P7696 = "501_1304277427.017" 
    $P7694."add_method"($P7695, "declarator", $P7696)
    nqp_get_sc_object $P7697, "1304277414.8", 203
    get_how $P7698, $P7697
    nqp_get_sc_object $P7699, "1304277414.8", 203
    .const 'Sub' $P7700 = "502_1304277427.017" 
    $P7698."add_method"($P7699, "multi_declarator:sym<multi>", $P7700)
    nqp_get_sc_object $P7701, "1304277414.8", 203
    get_how $P7702, $P7701
    nqp_get_sc_object $P7703, "1304277414.8", 203
    .const 'Sub' $P7704 = "503_1304277427.017" 
    $P7702."add_method"($P7703, "multi_declarator:sym<proto>", $P7704)
    nqp_get_sc_object $P7705, "1304277414.8", 203
    get_how $P7706, $P7705
    nqp_get_sc_object $P7707, "1304277414.8", 203
    .const 'Sub' $P7708 = "504_1304277427.017" 
    $P7706."add_method"($P7707, "multi_declarator:sym<null>", $P7708)
    nqp_get_sc_object $P7709, "1304277414.8", 203
    get_how $P7710, $P7709
    nqp_get_sc_object $P7711, "1304277414.8", 203
    .const 'Sub' $P7712 = "505_1304277427.017" 
    $P7710."add_method"($P7711, "variable_declarator", $P7712)
    nqp_get_sc_object $P7713, "1304277414.8", 203
    get_how $P7714, $P7713
    nqp_get_sc_object $P7715, "1304277414.8", 203
    .const 'Sub' $P7716 = "507_1304277427.017" 
    $P7714."add_method"($P7715, "routine_declarator:sym<sub>", $P7716)
    nqp_get_sc_object $P7717, "1304277414.8", 203
    get_how $P7718, $P7717
    nqp_get_sc_object $P7719, "1304277414.8", 203
    .const 'Sub' $P7720 = "508_1304277427.017" 
    $P7718."add_method"($P7719, "routine_declarator:sym<method>", $P7720)
    nqp_get_sc_object $P7721, "1304277414.8", 203
    get_how $P7722, $P7721
    nqp_get_sc_object $P7723, "1304277414.8", 203
    .const 'Sub' $P7724 = "509_1304277427.017" 
    $P7722."add_method"($P7723, "routine_def", $P7724)
    nqp_get_sc_object $P7725, "1304277414.8", 203
    get_how $P7726, $P7725
    nqp_get_sc_object $P7727, "1304277414.8", 203
    .const 'Sub' $P7728 = "516_1304277427.017" 
    $P7726."add_method"($P7727, "method_def", $P7728)
    nqp_get_sc_object $P7729, "1304277414.8", 203
    get_how $P7730, $P7729
    nqp_get_sc_object $P7731, "1304277414.8", 203
    .const 'Sub' $P7732 = "519_1304277427.017" 
    $P7730."add_method"($P7731, "signature", $P7732)
    nqp_get_sc_object $P7733, "1304277414.8", 203
    get_how $P7734, $P7733
    nqp_get_sc_object $P7735, "1304277414.8", 203
    .const 'Sub' $P7736 = "522_1304277427.017" 
    $P7734."add_method"($P7735, "parameter", $P7736)
    nqp_get_sc_object $P7737, "1304277414.8", 203
    get_how $P7738, $P7737
    nqp_get_sc_object $P7739, "1304277414.8", 203
    .const 'Sub' $P7740 = "523_1304277427.017" 
    $P7738."add_method"($P7739, "param_var", $P7740)
    nqp_get_sc_object $P7741, "1304277414.8", 203
    get_how $P7742, $P7741
    nqp_get_sc_object $P7743, "1304277414.8", 203
    .const 'Sub' $P7744 = "524_1304277427.017" 
    $P7742."add_method"($P7743, "named_param", $P7744)
    nqp_get_sc_object $P7745, "1304277414.8", 203
    get_how $P7746, $P7745
    nqp_get_sc_object $P7747, "1304277414.8", 203
    .const 'Sub' $P7748 = "525_1304277427.017" 
    $P7746."add_method"($P7747, "typename", $P7748)
    nqp_get_sc_object $P7749, "1304277414.8", 203
    get_how $P7750, $P7749
    nqp_get_sc_object $P7751, "1304277414.8", 203
    .const 'Sub' $P7752 = "527_1304277427.017" 
    $P7750."add_method"($P7751, "trait", $P7752)
    nqp_get_sc_object $P7753, "1304277414.8", 203
    get_how $P7754, $P7753
    nqp_get_sc_object $P7755, "1304277414.8", 203
    .const 'Sub' $P7756 = "528_1304277427.017" 
    $P7754."add_method"($P7755, "trait_mod:sym<is>", $P7756)
    nqp_get_sc_object $P7757, "1304277414.8", 203
    get_how $P7758, $P7757
    nqp_get_sc_object $P7759, "1304277414.8", 203
    .const 'Sub' $P7760 = "531_1304277427.017" 
    $P7758."add_method"($P7759, "regex_declarator", $P7760)
    nqp_get_sc_object $P7761, "1304277414.8", 203
    get_how $P7762, $P7761
    nqp_get_sc_object $P7763, "1304277414.8", 203
    .const 'Sub' $P7764 = "535_1304277427.017" 
    $P7762."add_method"($P7763, "dotty", $P7764)
    nqp_get_sc_object $P7765, "1304277414.8", 203
    get_how $P7766, $P7765
    nqp_get_sc_object $P7767, "1304277414.8", 203
    .const 'Sub' $P7768 = "536_1304277427.017" 
    $P7766."add_method"($P7767, "term:sym<self>", $P7768)
    nqp_get_sc_object $P7769, "1304277414.8", 203
    get_how $P7770, $P7769
    nqp_get_sc_object $P7771, "1304277414.8", 203
    .const 'Sub' $P7772 = "537_1304277427.017" 
    $P7770."add_method"($P7771, "term:sym<identifier>", $P7772)
    nqp_get_sc_object $P7773, "1304277414.8", 203
    get_how $P7774, $P7773
    nqp_get_sc_object $P7775, "1304277414.8", 203
    .const 'Sub' $P7776 = "538_1304277427.017" 
    $P7774."add_method"($P7775, "term:sym<name>", $P7776)
    nqp_get_sc_object $P7777, "1304277414.8", 203
    get_how $P7778, $P7777
    nqp_get_sc_object $P7779, "1304277414.8", 203
    .const 'Sub' $P7780 = "540_1304277427.017" 
    $P7778."add_method"($P7779, "term:sym<pir::op>", $P7780)
    nqp_get_sc_object $P7781, "1304277414.8", 203
    get_how $P7782, $P7781
    nqp_get_sc_object $P7783, "1304277414.8", 203
    .const 'Sub' $P7784 = "541_1304277427.017" 
    $P7782."add_method"($P7783, "term:sym<onlystar>", $P7784)
    nqp_get_sc_object $P7785, "1304277414.8", 203
    get_how $P7786, $P7785
    nqp_get_sc_object $P7787, "1304277414.8", 203
    .const 'Sub' $P7788 = "542_1304277427.017" 
    $P7786."add_method"($P7787, "args", $P7788)
    nqp_get_sc_object $P7789, "1304277414.8", 203
    get_how $P7790, $P7789
    nqp_get_sc_object $P7791, "1304277414.8", 203
    .const 'Sub' $P7792 = "543_1304277427.017" 
    $P7790."add_method"($P7791, "arglist", $P7792)
    nqp_get_sc_object $P7793, "1304277414.8", 203
    get_how $P7794, $P7793
    nqp_get_sc_object $P7795, "1304277414.8", 203
    .const 'Sub' $P7796 = "546_1304277427.017" 
    $P7794."add_method"($P7795, "term:sym<multi_declarator>", $P7796)
    nqp_get_sc_object $P7797, "1304277414.8", 203
    get_how $P7798, $P7797
    nqp_get_sc_object $P7799, "1304277414.8", 203
    .const 'Sub' $P7800 = "547_1304277427.017" 
    $P7798."add_method"($P7799, "term:sym<value>", $P7800)
    nqp_get_sc_object $P7801, "1304277414.8", 203
    get_how $P7802, $P7801
    nqp_get_sc_object $P7803, "1304277414.8", 203
    .const 'Sub' $P7804 = "548_1304277427.017" 
    $P7802."add_method"($P7803, "circumfix:sym<( )>", $P7804)
    nqp_get_sc_object $P7805, "1304277414.8", 203
    get_how $P7806, $P7805
    nqp_get_sc_object $P7807, "1304277414.8", 203
    .const 'Sub' $P7808 = "549_1304277427.017" 
    $P7806."add_method"($P7807, "circumfix:sym<[ ]>", $P7808)
    nqp_get_sc_object $P7809, "1304277414.8", 203
    get_how $P7810, $P7809
    nqp_get_sc_object $P7811, "1304277414.8", 203
    .const 'Sub' $P7812 = "550_1304277427.017" 
    $P7810."add_method"($P7811, "circumfix:sym<ang>", $P7812)
    nqp_get_sc_object $P7813, "1304277414.8", 203
    get_how $P7814, $P7813
    nqp_get_sc_object $P7815, "1304277414.8", 203
    .const 'Sub' $P7816 = "551_1304277427.017" 
    $P7814."add_method"($P7815, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7816)
    nqp_get_sc_object $P7817, "1304277414.8", 203
    get_how $P7818, $P7817
    nqp_get_sc_object $P7819, "1304277414.8", 203
    .const 'Sub' $P7820 = "552_1304277427.017" 
    $P7818."add_method"($P7819, "circumfix:sym<{ }>", $P7820)
    nqp_get_sc_object $P7821, "1304277414.8", 203
    get_how $P7822, $P7821
    nqp_get_sc_object $P7823, "1304277414.8", 203
    .const 'Sub' $P7824 = "554_1304277427.017" 
    $P7822."add_method"($P7823, "circumfix:sym<sigil>", $P7824)
    nqp_get_sc_object $P7825, "1304277414.8", 203
    get_how $P7826, $P7825
    nqp_get_sc_object $P7827, "1304277414.8", 203
    .const 'Sub' $P7828 = "555_1304277427.017" 
    $P7826."add_method"($P7827, "semilist", $P7828)
    nqp_get_sc_object $P7829, "1304277414.8", 203
    get_how $P7830, $P7829
    nqp_get_sc_object $P7831, "1304277414.8", 203
    .const 'Sub' $P7832 = "556_1304277427.017" 
    $P7830."add_method"($P7831, "postcircumfix:sym<[ ]>", $P7832)
    nqp_get_sc_object $P7833, "1304277414.8", 203
    get_how $P7834, $P7833
    nqp_get_sc_object $P7835, "1304277414.8", 203
    .const 'Sub' $P7836 = "557_1304277427.017" 
    $P7834."add_method"($P7835, "postcircumfix:sym<{ }>", $P7836)
    nqp_get_sc_object $P7837, "1304277414.8", 203
    get_how $P7838, $P7837
    nqp_get_sc_object $P7839, "1304277414.8", 203
    .const 'Sub' $P7840 = "558_1304277427.017" 
    $P7838."add_method"($P7839, "postcircumfix:sym<ang>", $P7840)
    nqp_get_sc_object $P7841, "1304277414.8", 203
    get_how $P7842, $P7841
    nqp_get_sc_object $P7843, "1304277414.8", 203
    .const 'Sub' $P7844 = "559_1304277427.017" 
    $P7842."add_method"($P7843, "postcircumfix:sym<( )>", $P7844)
    nqp_get_sc_object $P7845, "1304277414.8", 203
    get_how $P7846, $P7845
    nqp_get_sc_object $P7847, "1304277414.8", 203
    .const 'Sub' $P7848 = "560_1304277427.017" 
    $P7846."add_method"($P7847, "value", $P7848)
    nqp_get_sc_object $P7849, "1304277414.8", 203
    get_how $P7850, $P7849
    nqp_get_sc_object $P7851, "1304277414.8", 203
    .const 'Sub' $P7852 = "561_1304277427.017" 
    $P7850."add_method"($P7851, "number", $P7852)
    nqp_get_sc_object $P7853, "1304277414.8", 203
    get_how $P7854, $P7853
    nqp_get_sc_object $P7855, "1304277414.8", 203
    .const 'Sub' $P7856 = "562_1304277427.017" 
    $P7854."add_method"($P7855, "quote:sym<apos>", $P7856)
    nqp_get_sc_object $P7857, "1304277414.8", 203
    get_how $P7858, $P7857
    nqp_get_sc_object $P7859, "1304277414.8", 203
    .const 'Sub' $P7860 = "563_1304277427.017" 
    $P7858."add_method"($P7859, "quote:sym<dblq>", $P7860)
    nqp_get_sc_object $P7861, "1304277414.8", 203
    get_how $P7862, $P7861
    nqp_get_sc_object $P7863, "1304277414.8", 203
    .const 'Sub' $P7864 = "564_1304277427.017" 
    $P7862."add_method"($P7863, "quote:sym<qq>", $P7864)
    nqp_get_sc_object $P7865, "1304277414.8", 203
    get_how $P7866, $P7865
    nqp_get_sc_object $P7867, "1304277414.8", 203
    .const 'Sub' $P7868 = "565_1304277427.017" 
    $P7866."add_method"($P7867, "quote:sym<q>", $P7868)
    nqp_get_sc_object $P7869, "1304277414.8", 203
    get_how $P7870, $P7869
    nqp_get_sc_object $P7871, "1304277414.8", 203
    .const 'Sub' $P7872 = "566_1304277427.017" 
    $P7870."add_method"($P7871, "quote:sym<Q>", $P7872)
    nqp_get_sc_object $P7873, "1304277414.8", 203
    get_how $P7874, $P7873
    nqp_get_sc_object $P7875, "1304277414.8", 203
    .const 'Sub' $P7876 = "567_1304277427.017" 
    $P7874."add_method"($P7875, "quote:sym<Q:PIR>", $P7876)
    nqp_get_sc_object $P7877, "1304277414.8", 203
    get_how $P7878, $P7877
    nqp_get_sc_object $P7879, "1304277414.8", 203
    .const 'Sub' $P7880 = "568_1304277427.017" 
    $P7878."add_method"($P7879, "quote:sym</ />", $P7880)
    nqp_get_sc_object $P7881, "1304277414.8", 203
    get_how $P7882, $P7881
    nqp_get_sc_object $P7883, "1304277414.8", 203
    .const 'Sub' $P7884 = "569_1304277427.017" 
    $P7882."add_method"($P7883, "quote_escape:sym<$>", $P7884)
    nqp_get_sc_object $P7885, "1304277414.8", 203
    get_how $P7886, $P7885
    nqp_get_sc_object $P7887, "1304277414.8", 203
    .const 'Sub' $P7888 = "570_1304277427.017" 
    $P7886."add_method"($P7887, "quote_escape:sym<{ }>", $P7888)
    nqp_get_sc_object $P7889, "1304277414.8", 203
    get_how $P7890, $P7889
    nqp_get_sc_object $P7891, "1304277414.8", 203
    .const 'Sub' $P7892 = "571_1304277427.017" 
    $P7890."add_method"($P7891, "quote_escape:sym<esc>", $P7892)
    nqp_get_sc_object $P7893, "1304277414.8", 203
    get_how $P7894, $P7893
    nqp_get_sc_object $P7895, "1304277414.8", 203
    .const 'Sub' $P7896 = "572_1304277427.017" 
    $P7894."add_method"($P7895, "postfix:sym<.>", $P7896)
    nqp_get_sc_object $P7897, "1304277414.8", 203
    get_how $P7898, $P7897
    nqp_get_sc_object $P7899, "1304277414.8", 203
    .const 'Sub' $P7900 = "573_1304277427.017" 
    $P7898."add_method"($P7899, "postfix:sym<++>", $P7900)
    nqp_get_sc_object $P7901, "1304277414.8", 203
    get_how $P7902, $P7901
    nqp_get_sc_object $P7903, "1304277414.8", 203
    .const 'Sub' $P7904 = "574_1304277427.017" 
    $P7902."add_method"($P7903, "postfix:sym<-->", $P7904)
    nqp_get_sc_object $P7905, "1304277414.8", 203
    get_how $P7906, $P7905
    nqp_get_sc_object $P7907, "1304277414.8", 203
    .const 'Sub' $P7908 = "575_1304277427.017" 
    $P7906."add_method"($P7907, "prefix:sym<make>", $P7908)
    nqp_get_sc_object $P7909, "1304277414.8", 203
    get_how $P7910, $P7909
    nqp_get_sc_object $P7911, "1304277414.8", 203
    .const 'Sub' $P7912 = "576_1304277427.017" 
    $P7910."add_method"($P7911, "term:sym<next>", $P7912)
    nqp_get_sc_object $P7913, "1304277414.8", 203
    get_how $P7914, $P7913
    nqp_get_sc_object $P7915, "1304277414.8", 203
    .const 'Sub' $P7916 = "577_1304277427.017" 
    $P7914."add_method"($P7915, "term:sym<last>", $P7916)
    nqp_get_sc_object $P7917, "1304277414.8", 203
    get_how $P7918, $P7917
    nqp_get_sc_object $P7919, "1304277414.8", 203
    .const 'Sub' $P7920 = "578_1304277427.017" 
    $P7918."add_method"($P7919, "term:sym<redo>", $P7920)
    nqp_get_sc_object $P7921, "1304277414.8", 203
    get_how $P7922, $P7921
    nqp_get_sc_object $P7923, "1304277414.8", 203
    .const 'Sub' $P7924 = "579_1304277427.017" 
    $P7922."add_method"($P7923, "infix:sym<~~>", $P7924)
    nqp_get_sc_object $P7925, "1304277414.8", 203
    get_how $P7926, $P7925
    nqp_get_sc_object $P7927, "1304277414.8", 203
    .const 'Sub' $P7928 = "580_1304277427.017" 
    $P7926."add_method"($P7927, "known_sym", $P7928)
    .const 'Sub' $P7929 = "408_1304277427.017" 
    $P7930 = $P7929."get_lexinfo"()
    nqp_get_sc_object $P7931, "1304277414.8", 203
    $P7930."set_static_lexpad_value"("$?PACKAGE", $P7931)
    .const 'Sub' $P7932 = "408_1304277427.017" 
    $P7933 = $P7932."get_lexinfo"()
    $P7933."finish_static_lexpad"()
    .const 'Sub' $P7934 = "408_1304277427.017" 
    $P7935 = $P7934."get_lexinfo"()
    nqp_get_sc_object $P7936, "1304277414.8", 203
    $P7935."set_static_lexpad_value"("$?CLASS", $P7936)
    .const 'Sub' $P7937 = "408_1304277427.017" 
    $P7938 = $P7937."get_lexinfo"()
    $P7938."finish_static_lexpad"()
    nqp_get_sc_object $P7939, "1304277414.8", 203
    get_how $P7940, $P7939
    nqp_get_sc_object $P7941, "1304277414.8", 203
    nqp_get_sc_object $P7942, "1304277396.391", 68
    $P7940."add_parent"($P7941, $P7942)
    nqp_get_sc_object $P7943, "1304277388.915", 41
    $P7944 = $P7943."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P7944, cur_sc
    nqp_set_sc_object "1304277414.8", 314, $P7944
    nqp_get_sc_object $P7945, "1304277414.8", 314
    nqp_get_sc_object $P7946, "1304277414.8", 0
    nqp_get_package_through_who $P7947, $P7946, "NQP"
    get_who $P7948, $P7947
    set $P7948["RegexActions"], $P7945
    nqp_get_sc_object $P7949, "1304277414.8", 314
    get_how $P7950, $P7949
    nqp_get_sc_object $P7951, "1304277414.8", 314
    .const 'Sub' $P7952 = "584_1304277427.017" 
    $P7950."add_method"($P7951, "metachar:sym<:my>", $P7952)
    nqp_get_sc_object $P7953, "1304277414.8", 314
    get_how $P7954, $P7953
    nqp_get_sc_object $P7955, "1304277414.8", 314
    .const 'Sub' $P7956 = "585_1304277427.017" 
    $P7954."add_method"($P7955, "metachar:sym<{ }>", $P7956)
    nqp_get_sc_object $P7957, "1304277414.8", 314
    get_how $P7958, $P7957
    nqp_get_sc_object $P7959, "1304277414.8", 314
    .const 'Sub' $P7960 = "586_1304277427.017" 
    $P7958."add_method"($P7959, "metachar:sym<nqpvar>", $P7960)
    nqp_get_sc_object $P7961, "1304277414.8", 314
    get_how $P7962, $P7961
    nqp_get_sc_object $P7963, "1304277414.8", 314
    .const 'Sub' $P7964 = "587_1304277427.017" 
    $P7962."add_method"($P7963, "assertion:sym<{ }>", $P7964)
    nqp_get_sc_object $P7965, "1304277414.8", 314
    get_how $P7966, $P7965
    nqp_get_sc_object $P7967, "1304277414.8", 314
    .const 'Sub' $P7968 = "588_1304277427.017" 
    $P7966."add_method"($P7967, "assertion:sym<?{ }>", $P7968)
    nqp_get_sc_object $P7969, "1304277414.8", 314
    get_how $P7970, $P7969
    nqp_get_sc_object $P7971, "1304277414.8", 314
    .const 'Sub' $P7972 = "589_1304277427.017" 
    $P7970."add_method"($P7971, "assertion:sym<var>", $P7972)
    nqp_get_sc_object $P7973, "1304277414.8", 314
    get_how $P7974, $P7973
    nqp_get_sc_object $P7975, "1304277414.8", 314
    .const 'Sub' $P7976 = "590_1304277427.017" 
    $P7974."add_method"($P7975, "codeblock", $P7976)
    .const 'Sub' $P7977 = "583_1304277427.017" 
    $P7978 = $P7977."get_lexinfo"()
    nqp_get_sc_object $P7979, "1304277414.8", 314
    $P7978."set_static_lexpad_value"("$?PACKAGE", $P7979)
    .const 'Sub' $P7980 = "583_1304277427.017" 
    $P7981 = $P7980."get_lexinfo"()
    $P7981."finish_static_lexpad"()
    .const 'Sub' $P7982 = "583_1304277427.017" 
    $P7983 = $P7982."get_lexinfo"()
    nqp_get_sc_object $P7984, "1304277414.8", 314
    $P7983."set_static_lexpad_value"("$?CLASS", $P7984)
    .const 'Sub' $P7985 = "583_1304277427.017" 
    $P7986 = $P7985."get_lexinfo"()
    $P7986."finish_static_lexpad"()
    nqp_get_sc_object $P7987, "1304277414.8", 314
    get_how $P7988, $P7987
    nqp_get_sc_object $P7989, "1304277414.8", 314
    nqp_get_sc_object $P7990, "1304277407.992", 79
    $P7988."add_parent"($P7989, $P7990)
    nqp_get_sc_object $P7991, "1304277388.915", 41
    $P7992 = $P7991."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P7992, cur_sc
    nqp_set_sc_object "1304277414.8", 322, $P7992
    nqp_get_sc_object $P7993, "1304277414.8", 322
    nqp_get_sc_object $P7994, "1304277414.8", 0
    nqp_get_package_through_who $P7995, $P7994, "NQP"
    get_who $P7996, $P7995
    set $P7996["Compiler"], $P7993
    .const 'Sub' $P7997 = "592_1304277427.017" 
    $P7998 = $P7997."get_lexinfo"()
    nqp_get_sc_object $P7999, "1304277414.8", 322
    $P7998."set_static_lexpad_value"("$?PACKAGE", $P7999)
    .const 'Sub' $P8000 = "592_1304277427.017" 
    $P8001 = $P8000."get_lexinfo"()
    $P8001."finish_static_lexpad"()
    .const 'Sub' $P8002 = "592_1304277427.017" 
    $P8003 = $P8002."get_lexinfo"()
    nqp_get_sc_object $P8004, "1304277414.8", 322
    $P8003."set_static_lexpad_value"("$?CLASS", $P8004)
    .const 'Sub' $P8005 = "592_1304277427.017" 
    $P8006 = $P8005."get_lexinfo"()
    $P8006."finish_static_lexpad"()
    nqp_get_sc_object $P8007, "1304277414.8", 322
    get_how $P8008, $P8007
    nqp_get_sc_object $P8009, "1304277414.8", 322
    nqp_get_sc_object $P8010, "1304277396.391", 101
    $P8008."add_parent"($P8009, $P8010)
  if_6618_end:
    nqp_get_sc_object $P8705, "1304277414.8", 0
    set_hll_global "GLOBAL", $P8705
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1304277427.017") :outer("10_1304277427.017")
    .param pmc param_17
.annotate 'line', 2292
    .lex "@ARGS", param_17
.annotate 'line', 2294
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2300
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2294
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2295
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_596
    new $P25, "Undef"
  vivify_596:
    $P25."language"("nqp")
.annotate 'line', 2296
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_597
    new $P26, "Undef"
  vivify_597:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2297
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_598
    new $P31, "Undef"
  vivify_598:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2300
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_599
    new $P36, "Undef"
  vivify_599:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2301
    find_lex $P38, "@clo"
    unless_null $P38, vivify_600
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_600:
    $P38."push"("parsetrace")
.annotate 'line', 2302
    find_lex $P39, "@clo"
    unless_null $P39, vivify_601
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_601:
    $P39."push"("setting=s")
.annotate 'line', 2303
    find_lex $P40, "@clo"
    unless_null $P40, vivify_602
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_602:
    $P40."push"("setting-path=s")
.annotate 'line', 2304
    find_lex $P41, "@clo"
    unless_null $P41, vivify_603
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_603:
    $P41."push"("module-path=s")
.annotate 'line', 2307
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_604
    new $P42, "Undef"
  vivify_604:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_605
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_605:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2292
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1304277427.017") :outer("10_1304277427.017")
.annotate 'line', 9
    .const 'Sub' $P1949 = "385_1304277427.017" 
    capture_lex $P1949
    .const 'Sub' $P1936 = "384_1304277427.017" 
    capture_lex $P1936
    .const 'Sub' $P1930 = "382_1304277427.017" 
    capture_lex $P1930
    .const 'Sub' $P1924 = "380_1304277427.017" 
    capture_lex $P1924
    .const 'Sub' $P1918 = "378_1304277427.017" 
    capture_lex $P1918
    .const 'Sub' $P1912 = "376_1304277427.017" 
    capture_lex $P1912
    .const 'Sub' $P1900 = "373_1304277427.017" 
    capture_lex $P1900
    .const 'Sub' $P1893 = "371_1304277427.017" 
    capture_lex $P1893
    .const 'Sub' $P1886 = "369_1304277427.017" 
    capture_lex $P1886
    .const 'Sub' $P1879 = "367_1304277427.017" 
    capture_lex $P1879
    .const 'Sub' $P1872 = "365_1304277427.017" 
    capture_lex $P1872
    .const 'Sub' $P1866 = "363_1304277427.017" 
    capture_lex $P1866
    .const 'Sub' $P1859 = "361_1304277427.017" 
    capture_lex $P1859
    .const 'Sub' $P1852 = "359_1304277427.017" 
    capture_lex $P1852
    .const 'Sub' $P1845 = "357_1304277427.017" 
    capture_lex $P1845
    .const 'Sub' $P1838 = "355_1304277427.017" 
    capture_lex $P1838
    .const 'Sub' $P1831 = "353_1304277427.017" 
    capture_lex $P1831
    .const 'Sub' $P1824 = "351_1304277427.017" 
    capture_lex $P1824
    .const 'Sub' $P1817 = "349_1304277427.017" 
    capture_lex $P1817
    .const 'Sub' $P1810 = "347_1304277427.017" 
    capture_lex $P1810
    .const 'Sub' $P1803 = "345_1304277427.017" 
    capture_lex $P1803
    .const 'Sub' $P1796 = "343_1304277427.017" 
    capture_lex $P1796
    .const 'Sub' $P1789 = "341_1304277427.017" 
    capture_lex $P1789
    .const 'Sub' $P1782 = "339_1304277427.017" 
    capture_lex $P1782
    .const 'Sub' $P1775 = "337_1304277427.017" 
    capture_lex $P1775
    .const 'Sub' $P1768 = "335_1304277427.017" 
    capture_lex $P1768
    .const 'Sub' $P1761 = "333_1304277427.017" 
    capture_lex $P1761
    .const 'Sub' $P1754 = "331_1304277427.017" 
    capture_lex $P1754
    .const 'Sub' $P1747 = "329_1304277427.017" 
    capture_lex $P1747
    .const 'Sub' $P1740 = "327_1304277427.017" 
    capture_lex $P1740
    .const 'Sub' $P1733 = "325_1304277427.017" 
    capture_lex $P1733
    .const 'Sub' $P1726 = "323_1304277427.017" 
    capture_lex $P1726
    .const 'Sub' $P1719 = "321_1304277427.017" 
    capture_lex $P1719
    .const 'Sub' $P1712 = "319_1304277427.017" 
    capture_lex $P1712
    .const 'Sub' $P1705 = "317_1304277427.017" 
    capture_lex $P1705
    .const 'Sub' $P1698 = "315_1304277427.017" 
    capture_lex $P1698
    .const 'Sub' $P1691 = "313_1304277427.017" 
    capture_lex $P1691
    .const 'Sub' $P1684 = "311_1304277427.017" 
    capture_lex $P1684
    .const 'Sub' $P1677 = "309_1304277427.017" 
    capture_lex $P1677
    .const 'Sub' $P1670 = "307_1304277427.017" 
    capture_lex $P1670
    .const 'Sub' $P1663 = "305_1304277427.017" 
    capture_lex $P1663
    .const 'Sub' $P1657 = "303_1304277427.017" 
    capture_lex $P1657
    .const 'Sub' $P1650 = "301_1304277427.017" 
    capture_lex $P1650
    .const 'Sub' $P1643 = "299_1304277427.017" 
    capture_lex $P1643
    .const 'Sub' $P1636 = "297_1304277427.017" 
    capture_lex $P1636
    .const 'Sub' $P1629 = "295_1304277427.017" 
    capture_lex $P1629
    .const 'Sub' $P1622 = "293_1304277427.017" 
    capture_lex $P1622
    .const 'Sub' $P1615 = "291_1304277427.017" 
    capture_lex $P1615
    .const 'Sub' $P1608 = "289_1304277427.017" 
    capture_lex $P1608
    .const 'Sub' $P1602 = "287_1304277427.017" 
    capture_lex $P1602
    .const 'Sub' $P1596 = "285_1304277427.017" 
    capture_lex $P1596
    .const 'Sub' $P1591 = "283_1304277427.017" 
    capture_lex $P1591
    .const 'Sub' $P1585 = "281_1304277427.017" 
    capture_lex $P1585
    .const 'Sub' $P1579 = "279_1304277427.017" 
    capture_lex $P1579
    .const 'Sub' $P1574 = "277_1304277427.017" 
    capture_lex $P1574
    .const 'Sub' $P1569 = "275_1304277427.017" 
    capture_lex $P1569
    .const 'Sub' $P1561 = "273_1304277427.017" 
    capture_lex $P1561
    .const 'Sub' $P1552 = "271_1304277427.017" 
    capture_lex $P1552
    .const 'Sub' $P1547 = "269_1304277427.017" 
    capture_lex $P1547
    .const 'Sub' $P1542 = "267_1304277427.017" 
    capture_lex $P1542
    .const 'Sub' $P1537 = "265_1304277427.017" 
    capture_lex $P1537
    .const 'Sub' $P1529 = "263_1304277427.017" 
    capture_lex $P1529
    .const 'Sub' $P1521 = "261_1304277427.017" 
    capture_lex $P1521
    .const 'Sub' $P1516 = "259_1304277427.017" 
    capture_lex $P1516
    .const 'Sub' $P1511 = "257_1304277427.017" 
    capture_lex $P1511
    .const 'Sub' $P1506 = "255_1304277427.017" 
    capture_lex $P1506
    .const 'Sub' $P1500 = "253_1304277427.017" 
    capture_lex $P1500
    .const 'Sub' $P1493 = "251_1304277427.017" 
    capture_lex $P1493
    .const 'Sub' $P1486 = "249_1304277427.017" 
    capture_lex $P1486
    .const 'Sub' $P1479 = "247_1304277427.017" 
    capture_lex $P1479
    .const 'Sub' $P1472 = "245_1304277427.017" 
    capture_lex $P1472
    .const 'Sub' $P1467 = "243_1304277427.017" 
    capture_lex $P1467
    .const 'Sub' $P1462 = "241_1304277427.017" 
    capture_lex $P1462
    .const 'Sub' $P1448 = "237_1304277427.017" 
    capture_lex $P1448
    .const 'Sub' $P1440 = "235_1304277427.017" 
    capture_lex $P1440
    .const 'Sub' $P1434 = "233_1304277427.017" 
    capture_lex $P1434
    .const 'Sub' $P1427 = "231_1304277427.017" 
    capture_lex $P1427
    .const 'Sub' $P1421 = "229_1304277427.017" 
    capture_lex $P1421
    .const 'Sub' $P1405 = "226_1304277427.017" 
    capture_lex $P1405
    .const 'Sub' $P1397 = "224_1304277427.017" 
    capture_lex $P1397
    .const 'Sub' $P1389 = "222_1304277427.017" 
    capture_lex $P1389
    .const 'Sub' $P1383 = "220_1304277427.017" 
    capture_lex $P1383
    .const 'Sub' $P1377 = "218_1304277427.017" 
    capture_lex $P1377
    .const 'Sub' $P1361 = "214_1304277427.017" 
    capture_lex $P1361
    .const 'Sub' $P1320 = "212_1304277427.017" 
    capture_lex $P1320
    .const 'Sub' $P1309 = "210_1304277427.017" 
    capture_lex $P1309
    .const 'Sub' $P1295 = "206_1304277427.017" 
    capture_lex $P1295
    .const 'Sub' $P1286 = "204_1304277427.017" 
    capture_lex $P1286
    .const 'Sub' $P1280 = "202_1304277427.017" 
    capture_lex $P1280
    .const 'Sub' $P1270 = "200_1304277427.017" 
    capture_lex $P1270
    .const 'Sub' $P1255 = "198_1304277427.017" 
    capture_lex $P1255
    .const 'Sub' $P1239 = "195_1304277427.017" 
    capture_lex $P1239
    .const 'Sub' $P1231 = "193_1304277427.017" 
    capture_lex $P1231
    .const 'Sub' $P1221 = "191_1304277427.017" 
    capture_lex $P1221
    .const 'Sub' $P1211 = "189_1304277427.017" 
    capture_lex $P1211
    .const 'Sub' $P1190 = "184_1304277427.017" 
    capture_lex $P1190
    .const 'Sub' $P1146 = "181_1304277427.017" 
    capture_lex $P1146
    .const 'Sub' $P1112 = "179_1304277427.017" 
    capture_lex $P1112
    .const 'Sub' $P1105 = "177_1304277427.017" 
    capture_lex $P1105
    .const 'Sub' $P1098 = "175_1304277427.017" 
    capture_lex $P1098
    .const 'Sub' $P1071 = "170_1304277427.017" 
    capture_lex $P1071
    .const 'Sub' $P1063 = "168_1304277427.017" 
    capture_lex $P1063
    .const 'Sub' $P1044 = "165_1304277427.017" 
    capture_lex $P1044
    .const 'Sub' $P1028 = "163_1304277427.017" 
    capture_lex $P1028
    .const 'Sub' $P1021 = "161_1304277427.017" 
    capture_lex $P1021
    .const 'Sub' $P1014 = "159_1304277427.017" 
    capture_lex $P1014
    .const 'Sub' $P1007 = "157_1304277427.017" 
    capture_lex $P1007
    .const 'Sub' $P829 = "152_1304277427.017" 
    capture_lex $P829
    .const 'Sub' $P810 = "150_1304277427.017" 
    capture_lex $P810
    .const 'Sub' $P791 = "148_1304277427.017" 
    capture_lex $P791
    .const 'Sub' $P772 = "146_1304277427.017" 
    capture_lex $P772
    .const 'Sub' $P753 = "144_1304277427.017" 
    capture_lex $P753
    .const 'Sub' $P734 = "142_1304277427.017" 
    capture_lex $P734
    .const 'Sub' $P715 = "140_1304277427.017" 
    capture_lex $P715
    .const 'Sub' $P704 = "136_1304277427.017" 
    capture_lex $P704
    .const 'Sub' $P699 = "134_1304277427.017" 
    capture_lex $P699
    .const 'Sub' $P687 = "132_1304277427.017" 
    capture_lex $P687
    .const 'Sub' $P675 = "130_1304277427.017" 
    capture_lex $P675
    .const 'Sub' $P668 = "128_1304277427.017" 
    capture_lex $P668
    .const 'Sub' $P663 = "126_1304277427.017" 
    capture_lex $P663
    .const 'Sub' $P657 = "124_1304277427.017" 
    capture_lex $P657
    .const 'Sub' $P651 = "122_1304277427.017" 
    capture_lex $P651
    .const 'Sub' $P636 = "118_1304277427.017" 
    capture_lex $P636
    .const 'Sub' $P630 = "116_1304277427.017" 
    capture_lex $P630
    .const 'Sub' $P624 = "114_1304277427.017" 
    capture_lex $P624
    .const 'Sub' $P618 = "112_1304277427.017" 
    capture_lex $P618
    .const 'Sub' $P612 = "110_1304277427.017" 
    capture_lex $P612
    .const 'Sub' $P606 = "108_1304277427.017" 
    capture_lex $P606
    .const 'Sub' $P600 = "106_1304277427.017" 
    capture_lex $P600
    .const 'Sub' $P591 = "104_1304277427.017" 
    capture_lex $P591
    .const 'Sub' $P582 = "102_1304277427.017" 
    capture_lex $P582
    .const 'Sub' $P573 = "100_1304277427.017" 
    capture_lex $P573
    .const 'Sub' $P558 = "96_1304277427.017" 
    capture_lex $P558
    .const 'Sub' $P549 = "94_1304277427.017" 
    capture_lex $P549
    .const 'Sub' $P537 = "90_1304277427.017" 
    capture_lex $P537
    .const 'Sub' $P530 = "88_1304277427.017" 
    capture_lex $P530
    .const 'Sub' $P523 = "86_1304277427.017" 
    capture_lex $P523
    .const 'Sub' $P509 = "82_1304277427.017" 
    capture_lex $P509
    .const 'Sub' $P501 = "80_1304277427.017" 
    capture_lex $P501
    .const 'Sub' $P493 = "78_1304277427.017" 
    capture_lex $P493
    .const 'Sub' $P473 = "76_1304277427.017" 
    capture_lex $P473
    .const 'Sub' $P464 = "74_1304277427.017" 
    capture_lex $P464
    .const 'Sub' $P446 = "71_1304277427.017" 
    capture_lex $P446
    .const 'Sub' $P428 = "69_1304277427.017" 
    capture_lex $P428
    .const 'Sub' $P420 = "67_1304277427.017" 
    capture_lex $P420
    .const 'Sub' $P409 = "63_1304277427.017" 
    capture_lex $P409
    .const 'Sub' $P404 = "61_1304277427.017" 
    capture_lex $P404
    .const 'Sub' $P393 = "57_1304277427.017" 
    capture_lex $P393
    .const 'Sub' $P388 = "55_1304277427.017" 
    capture_lex $P388
    .const 'Sub' $P383 = "53_1304277427.017" 
    capture_lex $P383
    .const 'Sub' $P378 = "51_1304277427.017" 
    capture_lex $P378
    .const 'Sub' $P373 = "49_1304277427.017" 
    capture_lex $P373
    .const 'Sub' $P363 = "47_1304277427.017" 
    capture_lex $P363
    .const 'Sub' $P356 = "45_1304277427.017" 
    capture_lex $P356
    .const 'Sub' $P350 = "43_1304277427.017" 
    capture_lex $P350
    .const 'Sub' $P342 = "41_1304277427.017" 
    capture_lex $P342
    .const 'Sub' $P336 = "39_1304277427.017" 
    capture_lex $P336
    .const 'Sub' $P330 = "37_1304277427.017" 
    capture_lex $P330
    .const 'Sub' $P315 = "34_1304277427.017" 
    capture_lex $P315
    .const 'Sub' $P301 = "32_1304277427.017" 
    capture_lex $P301
    .const 'Sub' $P278 = "30_1304277427.017" 
    capture_lex $P278
    .const 'Sub' $P239 = "27_1304277427.017" 
    capture_lex $P239
    .const 'Sub' $P224 = "24_1304277427.017" 
    capture_lex $P224
    .const 'Sub' $P213 = "22_1304277427.017" 
    capture_lex $P213
    .const 'Sub' $P201 = "20_1304277427.017" 
    capture_lex $P201
    .const 'Sub' $P193 = "18_1304277427.017" 
    capture_lex $P193
    .const 'Sub' $P186 = "16_1304277427.017" 
    capture_lex $P186
    .const 'Sub' $P179 = "14_1304277427.017" 
    capture_lex $P179
    .const 'Sub' $P110 = "13_1304277427.017" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 612
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 613
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 614
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 615
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 616
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 617
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 618
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 619
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 620
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 621
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 622
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 623
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 624
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 625
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 626
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 725
    .const 'Sub' $P1936 = "384_1304277427.017" 
    newclosure $P1947, $P1936
.annotate 'line', 9
    .return ($P1947)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post606") :outer("12_1304277427.017")
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1304277427.017" 
    .local pmc block
    set block, $P47
    .const 'Sub' $P1949 = "385_1304277427.017" 
    capture_lex $P1949
    $P1949()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1948"  :anon :subid("385_1304277427.017") :outer("12_1304277427.017")
.annotate 'line', 9
    nqp_get_sc_object $P1950, "1304277414.8", 1
    .local pmc type_obj
    set type_obj, $P1950
    get_how $P1951, type_obj
    get_global $P1952, "!PREFIX__identifier"
    $P1951."add_method"(type_obj, "!PREFIX__identifier", $P1952)
    get_how $P1953, type_obj
    get_global $P1954, "!PREFIX__name"
    $P1953."add_method"(type_obj, "!PREFIX__name", $P1954)
    get_how $P1955, type_obj
    get_global $P1956, "!PREFIX__deflongname"
    $P1955."add_method"(type_obj, "!PREFIX__deflongname", $P1956)
    get_how $P1957, type_obj
    get_global $P1958, "!PREFIX__ENDSTMT"
    $P1957."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1958)
    get_how $P1959, type_obj
    get_global $P1960, "!PREFIX__ws"
    $P1959."add_method"(type_obj, "!PREFIX__ws", $P1960)
    get_how $P1961, type_obj
    get_global $P1962, "!PREFIX__unv"
    $P1961."add_method"(type_obj, "!PREFIX__unv", $P1962)
    get_how $P1963, type_obj
    get_global $P1964, "!PREFIX__pod_comment"
    $P1963."add_method"(type_obj, "!PREFIX__pod_comment", $P1964)
    get_how $P1965, type_obj
    get_global $P1966, "!PREFIX__comp_unit"
    $P1965."add_method"(type_obj, "!PREFIX__comp_unit", $P1966)
    get_how $P1967, type_obj
    get_global $P1968, "!PREFIX__statementlist"
    $P1967."add_method"(type_obj, "!PREFIX__statementlist", $P1968)
    get_how $P1969, type_obj
    get_global $P1970, "!PREFIX__statement"
    $P1969."add_method"(type_obj, "!PREFIX__statement", $P1970)
    get_how $P1971, type_obj
    get_global $P1972, "!PREFIX__eat_terminator"
    $P1971."add_method"(type_obj, "!PREFIX__eat_terminator", $P1972)
    get_how $P1973, type_obj
    get_global $P1974, "!PREFIX__xblock"
    $P1973."add_method"(type_obj, "!PREFIX__xblock", $P1974)
    get_how $P1975, type_obj
    get_global $P1976, "!PREFIX__pblock"
    $P1975."add_method"(type_obj, "!PREFIX__pblock", $P1976)
    get_how $P1977, type_obj
    get_global $P1978, "!PREFIX__lambda"
    $P1977."add_method"(type_obj, "!PREFIX__lambda", $P1978)
    get_how $P1979, type_obj
    get_global $P1980, "!PREFIX__block"
    $P1979."add_method"(type_obj, "!PREFIX__block", $P1980)
    get_how $P1981, type_obj
    get_global $P1982, "!PREFIX__blockoid"
    $P1981."add_method"(type_obj, "!PREFIX__blockoid", $P1982)
    get_how $P1983, type_obj
    get_global $P1984, "!PREFIX__newpad"
    $P1983."add_method"(type_obj, "!PREFIX__newpad", $P1984)
    get_how $P1985, type_obj
    get_global $P1986, "!PREFIX__outerctx"
    $P1985."add_method"(type_obj, "!PREFIX__outerctx", $P1986)
    get_how $P1987, type_obj
    get_global $P1988, "!PREFIX__GLOBALish"
    $P1987."add_method"(type_obj, "!PREFIX__GLOBALish", $P1988)
    get_how $P1989, type_obj
    get_global $P1990, "!PREFIX__finishpad"
    $P1989."add_method"(type_obj, "!PREFIX__finishpad", $P1990)
    get_how $P1991, type_obj
    get_global $P1992, "!PREFIX__you_are_here"
    $P1991."add_method"(type_obj, "!PREFIX__you_are_here", $P1992)
    get_how $P1993, type_obj
    get_global $P1994, "!PREFIX__terminator:sym<;>"
    $P1993."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1994)
    get_how $P1995, type_obj
    get_global $P1996, "!PREFIX__terminator:sym<}>"
    $P1995."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1996)
    get_how $P1997, type_obj
    get_global $P1998, "!PREFIX__statement_control:sym<use>"
    $P1997."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1998)
    get_how $P1999, type_obj
    get_global $P2000, "!PREFIX__statement_control:sym<if>"
    $P1999."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P2000)
    get_how $P2001, type_obj
    get_global $P2002, "!PREFIX__statement_control:sym<unless>"
    $P2001."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P2002)
    get_how $P2003, type_obj
    get_global $P2004, "!PREFIX__statement_control:sym<while>"
    $P2003."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P2004)
    get_how $P2005, type_obj
    get_global $P2006, "!PREFIX__statement_control:sym<repeat>"
    $P2005."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P2006)
    get_how $P2007, type_obj
    get_global $P2008, "!PREFIX__statement_control:sym<for>"
    $P2007."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P2008)
    get_how $P2009, type_obj
    get_global $P2010, "!PREFIX__statement_control:sym<CATCH>"
    $P2009."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P2010)
    get_how $P2011, type_obj
    get_global $P2012, "!PREFIX__statement_control:sym<CONTROL>"
    $P2011."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P2012)
    get_how $P2013, type_obj
    get_global $P2014, "!PREFIX__statement_prefix:sym<INIT>"
    $P2013."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P2014)
    get_how $P2015, type_obj
    get_global $P2016, "!PREFIX__statement_prefix:sym<try>"
    $P2015."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P2016)
    get_how $P2017, type_obj
    get_global $P2018, "!PREFIX__blorst"
    $P2017."add_method"(type_obj, "!PREFIX__blorst", $P2018)
    get_how $P2019, type_obj
    get_global $P2020, "!PREFIX__statement_mod_cond:sym<if>"
    $P2019."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P2020)
    get_how $P2021, type_obj
    get_global $P2022, "!PREFIX__statement_mod_cond:sym<unless>"
    $P2021."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P2022)
    get_how $P2023, type_obj
    get_global $P2024, "!PREFIX__statement_mod_loop:sym<while>"
    $P2023."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P2024)
    get_how $P2025, type_obj
    get_global $P2026, "!PREFIX__statement_mod_loop:sym<until>"
    $P2025."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P2026)
    get_how $P2027, type_obj
    get_global $P2028, "!PREFIX__statement_mod_loop:sym<for>"
    $P2027."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P2028)
    get_how $P2029, type_obj
    get_global $P2030, "!PREFIX__term:sym<fatarrow>"
    $P2029."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P2030)
    get_how $P2031, type_obj
    get_global $P2032, "!PREFIX__term:sym<colonpair>"
    $P2031."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P2032)
    get_how $P2033, type_obj
    get_global $P2034, "!PREFIX__term:sym<variable>"
    $P2033."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P2034)
    get_how $P2035, type_obj
    get_global $P2036, "!PREFIX__term:sym<package_declarator>"
    $P2035."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P2036)
    get_how $P2037, type_obj
    get_global $P2038, "!PREFIX__term:sym<scope_declarator>"
    $P2037."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P2038)
    get_how $P2039, type_obj
    get_global $P2040, "!PREFIX__term:sym<routine_declarator>"
    $P2039."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P2040)
    get_how $P2041, type_obj
    get_global $P2042, "!PREFIX__term:sym<multi_declarator>"
    $P2041."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P2042)
    get_how $P2043, type_obj
    get_global $P2044, "!PREFIX__term:sym<regex_declarator>"
    $P2043."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P2044)
    get_how $P2045, type_obj
    get_global $P2046, "!PREFIX__term:sym<statement_prefix>"
    $P2045."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P2046)
    get_how $P2047, type_obj
    get_global $P2048, "!PREFIX__term:sym<lambda>"
    $P2047."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P2048)
    get_how $P2049, type_obj
    get_global $P2050, "!PREFIX__fatarrow"
    $P2049."add_method"(type_obj, "!PREFIX__fatarrow", $P2050)
    get_how $P2051, type_obj
    get_global $P2052, "!PREFIX__colonpair"
    $P2051."add_method"(type_obj, "!PREFIX__colonpair", $P2052)
    get_how $P2053, type_obj
    get_global $P2054, "!PREFIX__variable"
    $P2053."add_method"(type_obj, "!PREFIX__variable", $P2054)
    get_how $P2055, type_obj
    get_global $P2056, "!PREFIX__sigil"
    $P2055."add_method"(type_obj, "!PREFIX__sigil", $P2056)
    get_how $P2057, type_obj
    get_global $P2058, "!PREFIX__twigil"
    $P2057."add_method"(type_obj, "!PREFIX__twigil", $P2058)
    get_how $P2059, type_obj
    get_global $P2060, "!PREFIX__package_declarator:sym<module>"
    $P2059."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2060)
    get_how $P2061, type_obj
    get_global $P2062, "!PREFIX__package_declarator:sym<knowhow>"
    $P2061."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2062)
    get_how $P2063, type_obj
    get_global $P2064, "!PREFIX__package_declarator:sym<class>"
    $P2063."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2064)
    get_how $P2065, type_obj
    get_global $P2066, "!PREFIX__package_declarator:sym<grammar>"
    $P2065."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2066)
    get_how $P2067, type_obj
    get_global $P2068, "!PREFIX__package_declarator:sym<role>"
    $P2067."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2068)
    get_how $P2069, type_obj
    get_global $P2070, "!PREFIX__package_declarator:sym<native>"
    $P2069."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2070)
    get_how $P2071, type_obj
    get_global $P2072, "!PREFIX__package_def"
    $P2071."add_method"(type_obj, "!PREFIX__package_def", $P2072)
    get_how $P2073, type_obj
    get_global $P2074, "!PREFIX__scope_declarator:sym<my>"
    $P2073."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2074)
    get_how $P2075, type_obj
    get_global $P2076, "!PREFIX__scope_declarator:sym<our>"
    $P2075."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2076)
    get_how $P2077, type_obj
    get_global $P2078, "!PREFIX__scope_declarator:sym<has>"
    $P2077."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2078)
    get_how $P2079, type_obj
    get_global $P2080, "!PREFIX__scoped"
    $P2079."add_method"(type_obj, "!PREFIX__scoped", $P2080)
    get_how $P2081, type_obj
    get_global $P2082, "!PREFIX__typename"
    $P2081."add_method"(type_obj, "!PREFIX__typename", $P2082)
    get_how $P2083, type_obj
    get_global $P2084, "!PREFIX__declarator"
    $P2083."add_method"(type_obj, "!PREFIX__declarator", $P2084)
    get_how $P2085, type_obj
    get_global $P2086, "!PREFIX__variable_declarator"
    $P2085."add_method"(type_obj, "!PREFIX__variable_declarator", $P2086)
    get_how $P2087, type_obj
    get_global $P2088, "!PREFIX__routine_declarator:sym<sub>"
    $P2087."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2088)
    get_how $P2089, type_obj
    get_global $P2090, "!PREFIX__routine_declarator:sym<method>"
    $P2089."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2090)
    get_how $P2091, type_obj
    get_global $P2092, "!PREFIX__routine_def"
    $P2091."add_method"(type_obj, "!PREFIX__routine_def", $P2092)
    get_how $P2093, type_obj
    get_global $P2094, "!PREFIX__method_def"
    $P2093."add_method"(type_obj, "!PREFIX__method_def", $P2094)
    get_how $P2095, type_obj
    get_global $P2096, "!PREFIX__onlystar"
    $P2095."add_method"(type_obj, "!PREFIX__onlystar", $P2096)
    get_how $P2097, type_obj
    get_global $P2098, "!PREFIX__multi_declarator:sym<multi>"
    $P2097."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2098)
    get_how $P2099, type_obj
    get_global $P2100, "!PREFIX__multi_declarator:sym<proto>"
    $P2099."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2100)
    get_how $P2101, type_obj
    get_global $P2102, "!PREFIX__multi_declarator:sym<null>"
    $P2101."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2102)
    get_how $P2103, type_obj
    get_global $P2104, "!PREFIX__signature"
    $P2103."add_method"(type_obj, "!PREFIX__signature", $P2104)
    get_how $P2105, type_obj
    get_global $P2106, "!PREFIX__parameter"
    $P2105."add_method"(type_obj, "!PREFIX__parameter", $P2106)
    get_how $P2107, type_obj
    get_global $P2108, "!PREFIX__param_var"
    $P2107."add_method"(type_obj, "!PREFIX__param_var", $P2108)
    get_how $P2109, type_obj
    get_global $P2110, "!PREFIX__named_param"
    $P2109."add_method"(type_obj, "!PREFIX__named_param", $P2110)
    get_how $P2111, type_obj
    get_global $P2112, "!PREFIX__default_value"
    $P2111."add_method"(type_obj, "!PREFIX__default_value", $P2112)
    get_how $P2113, type_obj
    get_global $P2114, "!PREFIX__trait"
    $P2113."add_method"(type_obj, "!PREFIX__trait", $P2114)
    get_how $P2115, type_obj
    get_global $P2116, "!PREFIX__trait_mod:sym<is>"
    $P2115."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2116)
    get_how $P2117, type_obj
    get_global $P2118, "!PREFIX__regex_declarator"
    $P2117."add_method"(type_obj, "!PREFIX__regex_declarator", $P2118)
    get_how $P2119, type_obj
    get_global $P2120, "!PREFIX__dotty"
    $P2119."add_method"(type_obj, "!PREFIX__dotty", $P2120)
    get_how $P2121, type_obj
    get_global $P2122, "!PREFIX__term:sym<self>"
    $P2121."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2122)
    get_how $P2123, type_obj
    get_global $P2124, "!PREFIX__term:sym<identifier>"
    $P2123."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2124)
    get_how $P2125, type_obj
    get_global $P2126, "!PREFIX__term:sym<name>"
    $P2125."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2126)
    get_how $P2127, type_obj
    get_global $P2128, "!PREFIX__term:sym<pir::op>"
    $P2127."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2128)
    get_how $P2129, type_obj
    get_global $P2130, "!PREFIX__term:sym<onlystar>"
    $P2129."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2130)
    get_how $P2131, type_obj
    get_global $P2132, "!PREFIX__args"
    $P2131."add_method"(type_obj, "!PREFIX__args", $P2132)
    get_how $P2133, type_obj
    get_global $P2134, "!PREFIX__arglist"
    $P2133."add_method"(type_obj, "!PREFIX__arglist", $P2134)
    get_how $P2135, type_obj
    get_global $P2136, "!PREFIX__term:sym<value>"
    $P2135."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2136)
    get_how $P2137, type_obj
    get_global $P2138, "!PREFIX__value"
    $P2137."add_method"(type_obj, "!PREFIX__value", $P2138)
    get_how $P2139, type_obj
    get_global $P2140, "!PREFIX__number"
    $P2139."add_method"(type_obj, "!PREFIX__number", $P2140)
    get_how $P2141, type_obj
    get_global $P2142, "!PREFIX__quote:sym<apos>"
    $P2141."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2142)
    get_how $P2143, type_obj
    get_global $P2144, "!PREFIX__quote:sym<dblq>"
    $P2143."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2144)
    get_how $P2145, type_obj
    get_global $P2146, "!PREFIX__quote:sym<q>"
    $P2145."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2146)
    get_how $P2147, type_obj
    get_global $P2148, "!PREFIX__quote:sym<qq>"
    $P2147."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2148)
    get_how $P2149, type_obj
    get_global $P2150, "!PREFIX__quote:sym<Q>"
    $P2149."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2150)
    get_how $P2151, type_obj
    get_global $P2152, "!PREFIX__quote:sym<Q:PIR>"
    $P2151."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2152)
    get_how $P2153, type_obj
    get_global $P2154, "!PREFIX__quote:sym</ />"
    $P2153."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2154)
    get_how $P2155, type_obj
    get_global $P2156, "!PREFIX__quote_escape:sym<$>"
    $P2155."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2156)
    get_how $P2157, type_obj
    get_global $P2158, "!PREFIX__quote_escape:sym<{ }>"
    $P2157."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2158)
    get_how $P2159, type_obj
    get_global $P2160, "!PREFIX__quote_escape:sym<esc>"
    $P2159."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2160)
    get_how $P2161, type_obj
    get_global $P2162, "!PREFIX__circumfix:sym<( )>"
    $P2161."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2162)
    get_how $P2163, type_obj
    get_global $P2164, "!PREFIX__circumfix:sym<[ ]>"
    $P2163."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2164)
    get_how $P2165, type_obj
    get_global $P2166, "!PREFIX__circumfix:sym<ang>"
    $P2165."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2166)
    get_how $P2167, type_obj
    get_global $P2168, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2167."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2168)
    get_how $P2169, type_obj
    get_global $P2170, "!PREFIX__circumfix:sym<{ }>"
    $P2169."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2170)
    get_how $P2171, type_obj
    get_global $P2172, "!PREFIX__circumfix:sym<sigil>"
    $P2171."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2172)
    get_how $P2173, type_obj
    get_global $P2174, "!PREFIX__semilist"
    $P2173."add_method"(type_obj, "!PREFIX__semilist", $P2174)
    get_how $P2175, type_obj
    get_global $P2176, "!PREFIX__infixish"
    $P2175."add_method"(type_obj, "!PREFIX__infixish", $P2176)
    get_how $P2177, type_obj
    get_global $P2178, "!PREFIX__infixstopper"
    $P2177."add_method"(type_obj, "!PREFIX__infixstopper", $P2178)
    get_how $P2179, type_obj
    get_global $P2180, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2179."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2180)
    get_how $P2181, type_obj
    get_global $P2182, "!PREFIX__postcircumfix:sym<{ }>"
    $P2181."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2182)
    get_how $P2183, type_obj
    get_global $P2184, "!PREFIX__postcircumfix:sym<ang>"
    $P2183."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2184)
    get_how $P2185, type_obj
    get_global $P2186, "!PREFIX__postcircumfix:sym<( )>"
    $P2185."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2186)
    get_how $P2187, type_obj
    get_global $P2188, "!PREFIX__postfix:sym<.>"
    $P2187."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2188)
    get_how $P2189, type_obj
    get_global $P2190, "!PREFIX__prefix:sym<++>"
    $P2189."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2190)
    get_how $P2191, type_obj
    get_global $P2192, "!PREFIX__prefix:sym<-->"
    $P2191."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2192)
    get_how $P2193, type_obj
    get_global $P2194, "!PREFIX__postfix:sym<++>"
    $P2193."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2194)
    get_how $P2195, type_obj
    get_global $P2196, "!PREFIX__postfix:sym<-->"
    $P2195."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2196)
    get_how $P2197, type_obj
    get_global $P2198, "!PREFIX__infix:sym<**>"
    $P2197."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2198)
    get_how $P2199, type_obj
    get_global $P2200, "!PREFIX__prefix:sym<+>"
    $P2199."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2200)
    get_how $P2201, type_obj
    get_global $P2202, "!PREFIX__prefix:sym<~>"
    $P2201."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2202)
    get_how $P2203, type_obj
    get_global $P2204, "!PREFIX__prefix:sym<->"
    $P2203."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2204)
    get_how $P2205, type_obj
    get_global $P2206, "!PREFIX__prefix:sym<?>"
    $P2205."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2206)
    get_how $P2207, type_obj
    get_global $P2208, "!PREFIX__prefix:sym<!>"
    $P2207."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2208)
    get_how $P2209, type_obj
    get_global $P2210, "!PREFIX__prefix:sym<|>"
    $P2209."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2210)
    get_how $P2211, type_obj
    get_global $P2212, "!PREFIX__infix:sym<*>"
    $P2211."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2212)
    get_how $P2213, type_obj
    get_global $P2214, "!PREFIX__infix:sym</>"
    $P2213."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2214)
    get_how $P2215, type_obj
    get_global $P2216, "!PREFIX__infix:sym<%>"
    $P2215."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2216)
    get_how $P2217, type_obj
    get_global $P2218, "!PREFIX__infix:sym<+&>"
    $P2217."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2218)
    get_how $P2219, type_obj
    get_global $P2220, "!PREFIX__infix:sym<+>"
    $P2219."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2220)
    get_how $P2221, type_obj
    get_global $P2222, "!PREFIX__infix:sym<->"
    $P2221."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2222)
    get_how $P2223, type_obj
    get_global $P2224, "!PREFIX__infix:sym<+|>"
    $P2223."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2224)
    get_how $P2225, type_obj
    get_global $P2226, "!PREFIX__infix:sym<+^>"
    $P2225."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2226)
    get_how $P2227, type_obj
    get_global $P2228, "!PREFIX__infix:sym<~>"
    $P2227."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2228)
    get_how $P2229, type_obj
    get_global $P2230, "!PREFIX__infix:sym<==>"
    $P2229."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2230)
    get_how $P2231, type_obj
    get_global $P2232, "!PREFIX__infix:sym<!=>"
    $P2231."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2232)
    get_how $P2233, type_obj
    get_global $P2234, "!PREFIX__infix:sym<<=>"
    $P2233."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2234)
    get_how $P2235, type_obj
    get_global $P2236, "!PREFIX__infix:sym<>=>"
    $P2235."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2236)
    get_how $P2237, type_obj
    get_global $P2238, "!PREFIX__infix:sym<<>"
    $P2237."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2238)
    get_how $P2239, type_obj
    get_global $P2240, "!PREFIX__infix:sym<>>"
    $P2239."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2240)
    get_how $P2241, type_obj
    get_global $P2242, "!PREFIX__infix:sym<eq>"
    $P2241."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2242)
    get_how $P2243, type_obj
    get_global $P2244, "!PREFIX__infix:sym<ne>"
    $P2243."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2244)
    get_how $P2245, type_obj
    get_global $P2246, "!PREFIX__infix:sym<le>"
    $P2245."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2246)
    get_how $P2247, type_obj
    get_global $P2248, "!PREFIX__infix:sym<ge>"
    $P2247."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2248)
    get_how $P2249, type_obj
    get_global $P2250, "!PREFIX__infix:sym<lt>"
    $P2249."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2250)
    get_how $P2251, type_obj
    get_global $P2252, "!PREFIX__infix:sym<gt>"
    $P2251."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2252)
    get_how $P2253, type_obj
    get_global $P2254, "!PREFIX__infix:sym<=:=>"
    $P2253."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2254)
    get_how $P2255, type_obj
    get_global $P2256, "!PREFIX__infix:sym<~~>"
    $P2255."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2256)
    get_how $P2257, type_obj
    get_global $P2258, "!PREFIX__infix:sym<&&>"
    $P2257."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2258)
    get_how $P2259, type_obj
    get_global $P2260, "!PREFIX__infix:sym<||>"
    $P2259."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2260)
    get_how $P2261, type_obj
    get_global $P2262, "!PREFIX__infix:sym<//>"
    $P2261."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2262)
    get_how $P2263, type_obj
    get_global $P2264, "!PREFIX__infix:sym<?? !!>"
    $P2263."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2264)
    get_how $P2265, type_obj
    get_global $P2266, "!PREFIX__infix:sym<=>"
    $P2265."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2266)
    get_how $P2267, type_obj
    get_global $P2268, "!PREFIX__infix:sym<:=>"
    $P2267."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2268)
    get_how $P2269, type_obj
    get_global $P2270, "!PREFIX__infix:sym<::=>"
    $P2269."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2270)
    get_how $P2271, type_obj
    get_global $P2272, "!PREFIX__infix:sym<,>"
    $P2271."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2272)
    get_how $P2273, type_obj
    get_global $P2274, "!PREFIX__prefix:sym<return>"
    $P2273."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2274)
    get_how $P2275, type_obj
    get_global $P2276, "!PREFIX__prefix:sym<make>"
    $P2275."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2276)
    get_how $P2277, type_obj
    get_global $P2278, "!PREFIX__term:sym<last>"
    $P2277."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2278)
    get_how $P2279, type_obj
    get_global $P2280, "!PREFIX__term:sym<next>"
    $P2279."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2280)
    get_how $P2281, type_obj
    get_global $P2282, "!PREFIX__term:sym<redo>"
    $P2281."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2282)
    get_how $P2283, type_obj
    $P2284 = $P2283."compose"(type_obj)
    .return ($P2284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1304277427.017") :outer("12_1304277427.017")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 21
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 28
    new $P114, "Undef"
    .lex "$*SC", $P114
.annotate 'line', 32
    new $P115, "Undef"
    .lex "$*SCOPE", $P115
.annotate 'line', 33
    new $P116, "Undef"
    .lex "$*MULTINESS", $P116
.annotate 'line', 34
    new $P117, "Undef"
    .lex "$*INVOCANT_OK", $P117
.annotate 'line', 35
    new $P118, "Undef"
    .lex "$*RETURN_USED", $P118
.annotate 'line', 36
    new $P119, "Undef"
    .lex "$*PACKAGE-SETUP", $P119
.annotate 'line', 10
    find_lex $P122, "%*LANG"
    unless_null $P122, vivify_607
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["%LANG"]
    unless_null $P122, vivify_608
    die "Contextual %*LANG not found"
  vivify_608:
  vivify_607:
.annotate 'line', 13
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "NQP"
    get_who $P125, $P124
    set $P126, $P125["Regex"]
    find_lex $P129, "%*LANG"
    unless_null $P129, vivify_609
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["%LANG"]
    unless_null $P129, vivify_610
    die "Contextual %*LANG not found"
  vivify_610:
    store_lex "%*LANG", $P129
  vivify_609:
    set $P129["Regex"], $P126
.annotate 'line', 14
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "NQP"
    get_who $P132, $P131
    set $P133, $P132["RegexActions"]
    find_lex $P136, "%*LANG"
    unless_null $P136, vivify_611
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["%LANG"]
    unless_null $P136, vivify_612
    die "Contextual %*LANG not found"
  vivify_612:
    store_lex "%*LANG", $P136
  vivify_611:
    set $P136["Regex-actions"], $P133
.annotate 'line', 15
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "NQP"
    get_who $P139, $P138
    set $P140, $P139["Grammar"]
    find_lex $P143, "%*LANG"
    unless_null $P143, vivify_613
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["%LANG"]
    unless_null $P143, vivify_614
    die "Contextual %*LANG not found"
  vivify_614:
    store_lex "%*LANG", $P143
  vivify_613:
    set $P143["MAIN"], $P140
.annotate 'line', 16
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "NQP"
    get_who $P146, $P145
    set $P147, $P146["Actions"]
    find_lex $P150, "%*LANG"
    unless_null $P150, vivify_615
    get_hll_global $P148, "GLOBAL"
    get_who $P149, $P148
    set $P150, $P149["%LANG"]
    unless_null $P150, vivify_616
    die "Contextual %*LANG not found"
  vivify_616:
    store_lex "%*LANG", $P150
  vivify_615:
    set $P150["MAIN-actions"], $P147
    find_lex $P153, "%*HOW"
    unless_null $P153, vivify_617
    get_hll_global $P151, "GLOBAL"
    get_who $P152, $P151
    set $P153, $P152["%HOW"]
    unless_null $P153, vivify_618
    die "Contextual %*HOW not found"
  vivify_618:
  vivify_617:
.annotate 'line', 22
    get_knowhow $P154
    find_lex $P157, "%*HOW"
    unless_null $P157, vivify_619
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["%HOW"]
    unless_null $P157, vivify_620
    die "Contextual %*HOW not found"
  vivify_620:
    store_lex "%*HOW", $P157
  vivify_619:
    set $P157["knowhow"], $P154
.annotate 'line', 23
    get_knowhow_attribute $P158
    find_lex $P161, "%*HOW"
    unless_null $P161, vivify_621
    get_hll_global $P159, "GLOBAL"
    get_who $P160, $P159
    set $P161, $P160["%HOW"]
    unless_null $P161, vivify_622
    die "Contextual %*HOW not found"
  vivify_622:
    store_lex "%*HOW", $P161
  vivify_621:
    set $P161["knowhow-attr"], $P158
.annotate 'line', 28
    get_hll_global $P162, "GLOBAL"
    nqp_get_package_through_who $P163, $P162, "HLL"
    nqp_get_package_through_who $P164, $P163, "Compiler"
    get_who $P165, $P164
    set $P166, $P165["SerializationContextBuilder"]
.annotate 'line', 30
    time $N167
    set $S168, $N167
    $P169 = $P166."new"($S168 :named("handle"))
.annotate 'line', 28
    store_lex "$*SC", $P169
.annotate 'line', 32
    new $P170, "String"
    assign $P170, ""
    store_lex "$*SCOPE", $P170
.annotate 'line', 33
    new $P171, "String"
    assign $P171, ""
    store_lex "$*MULTINESS", $P171
.annotate 'line', 34
    new $P172, "Integer"
    assign $P172, 0
    store_lex "$*INVOCANT_OK", $P172
.annotate 'line', 35
    new $P173, "Integer"
    assign $P173, 0
    store_lex "$*RETURN_USED", $P173
    find_lex $P176, "$*PACKAGE-SETUP"
    unless_null $P176, vivify_623
    get_hll_global $P174, "GLOBAL"
    get_who $P175, $P174
    set $P176, $P175["$PACKAGE-SETUP"]
    unless_null $P176, vivify_624
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_624:
  vivify_623:
.annotate 'line', 37
    find_lex $P177, "self"
    $P178 = $P177."comp_unit"()
.annotate 'line', 10
    .return ($P178)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx180_tgt
    .local int rx180_pos
    .local int rx180_off
    .local int rx180_eos
    .local int rx180_rep
    .local pmc rx180_cur
    .local pmc rx180_debug
    (rx180_cur, rx180_pos, rx180_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx180_cur
    .local pmc match
    .lex "$/", match
    length rx180_eos, rx180_tgt
    gt rx180_pos, rx180_eos, rx180_done
    set rx180_off, 0
    lt rx180_pos, 2, rx180_start
    sub rx180_off, rx180_pos, 1
    substr rx180_tgt, rx180_tgt, rx180_off
  rx180_start:
    eq $I10, 1, rx180_restart
    if_null rx180_debug, debug_625
    rx180_cur."!cursor_debug"("START", "identifier")
  debug_625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan184_done
    goto rxscan184_scan
  rxscan184_loop:
    (rx180_pos) = rx180_cur."from"()
    inc rx180_pos
    rx180_cur."!cursor_from"(rx180_pos)
    ge rx180_pos, rx180_eos, rxscan184_done
  rxscan184_scan:
    set_addr $I10, rxscan184_loop
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxscan184_done:
.annotate 'line', 42
  # rx subrule "ident" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ident"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
  # rx rxquantr185 ** 0..*
    set_addr $I10, rxquantr185_done
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxquantr185_loop:
  # rx enumcharlist negate=0 
    ge rx180_pos, rx180_eos, rx180_fail
    sub $I10, rx180_pos, rx180_off
    substr $S10, rx180_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx180_fail
    inc rx180_pos
  # rx subrule "ident" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ident"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
    set_addr $I10, rxquantr185_done
    (rx180_rep) = rx180_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr185_done
    rx180_cur."!mark_push"(rx180_rep, rx180_pos, $I10)
    goto rxquantr185_loop
  rxquantr185_done:
  # rx pass
    rx180_cur."!cursor_pass"(rx180_pos, "identifier")
    if_null rx180_debug, debug_626
    rx180_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx180_pos)
  debug_626:
    .return (rx180_cur)
  rx180_restart:
.annotate 'line', 10
    if_null rx180_debug, debug_627
    rx180_cur."!cursor_debug"("NEXT", "identifier")
  debug_627:
  rx180_fail:
    (rx180_rep, rx180_pos, $I10, $P10) = rx180_cur."!mark_fail"(0)
    lt rx180_pos, -1, rx180_done
    eq rx180_pos, -1, rx180_fail
    jump $I10
  rx180_done:
    rx180_cur."!cursor_fail"()
    if_null rx180_debug, debug_628
    rx180_cur."!cursor_debug"("FAIL", "identifier")
  debug_628:
    .return (rx180_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1304277427.017") :method
.annotate 'line', 10
    $P182 = self."!PREFIX__!subrule"("ident", "")
    new $P183, "ResizablePMCArray"
    push $P183, $P182
    .return ($P183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx187_tgt
    .local int rx187_pos
    .local int rx187_off
    .local int rx187_eos
    .local int rx187_rep
    .local pmc rx187_cur
    .local pmc rx187_debug
    (rx187_cur, rx187_pos, rx187_tgt, $I10) = self."!cursor_start"()
    rx187_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx187_cur
    .local pmc match
    .lex "$/", match
    length rx187_eos, rx187_tgt
    gt rx187_pos, rx187_eos, rx187_done
    set rx187_off, 0
    lt rx187_pos, 2, rx187_start
    sub rx187_off, rx187_pos, 1
    substr rx187_tgt, rx187_tgt, rx187_off
  rx187_start:
    eq $I10, 1, rx187_restart
    if_null rx187_debug, debug_629
    rx187_cur."!cursor_debug"("START", "name")
  debug_629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx187_pos) = rx187_cur."from"()
    inc rx187_pos
    rx187_cur."!cursor_from"(rx187_pos)
    ge rx187_pos, rx187_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  rxscan190_done:
.annotate 'line', 44
  # rx rxquantr191 ** 1..*
    set_addr $I10, rxquantr191_done
    rx187_cur."!mark_push"(0, -1, $I10)
  rxquantr191_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."identifier"()
    unless $P10, rx187_fail
    goto rxsubrule192_pass
  rxsubrule192_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx187_fail
  rxsubrule192_pass:
    set_addr $I10, rxsubrule192_back
    rx187_cur."!mark_push"(0, rx187_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx187_pos = $P10."pos"()
    set_addr $I10, rxquantr191_done
    (rx187_rep) = rx187_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr191_done
    rx187_cur."!mark_push"(rx187_rep, rx187_pos, $I10)
  # rx literal  "::"
    add $I11, rx187_pos, 2
    gt $I11, rx187_eos, rx187_fail
    sub $I11, rx187_pos, rx187_off
    substr $S10, rx187_tgt, $I11, 2
    ne $S10, "::", rx187_fail
    add rx187_pos, 2
    goto rxquantr191_loop
  rxquantr191_done:
  # rx pass
    rx187_cur."!cursor_pass"(rx187_pos, "name")
    if_null rx187_debug, debug_630
    rx187_cur."!cursor_debug"("PASS", "name", " at pos=", rx187_pos)
  debug_630:
    .return (rx187_cur)
  rx187_restart:
.annotate 'line', 10
    if_null rx187_debug, debug_631
    rx187_cur."!cursor_debug"("NEXT", "name")
  debug_631:
  rx187_fail:
    (rx187_rep, rx187_pos, $I10, $P10) = rx187_cur."!mark_fail"(0)
    lt rx187_pos, -1, rx187_done
    eq rx187_pos, -1, rx187_fail
    jump $I10
  rx187_done:
    rx187_cur."!cursor_fail"()
    if_null rx187_debug, debug_632
    rx187_cur."!cursor_debug"("FAIL", "name")
  debug_632:
    .return (rx187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1304277427.017") :method
.annotate 'line', 10
    new $P189, "ResizablePMCArray"
    push $P189, ""
    .return ($P189)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx194_tgt
    .local int rx194_pos
    .local int rx194_off
    .local int rx194_eos
    .local int rx194_rep
    .local pmc rx194_cur
    .local pmc rx194_debug
    (rx194_cur, rx194_pos, rx194_tgt, $I10) = self."!cursor_start"()
    rx194_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx194_cur
    .local pmc match
    .lex "$/", match
    length rx194_eos, rx194_tgt
    gt rx194_pos, rx194_eos, rx194_done
    set rx194_off, 0
    lt rx194_pos, 2, rx194_start
    sub rx194_off, rx194_pos, 1
    substr rx194_tgt, rx194_tgt, rx194_off
  rx194_start:
    eq $I10, 1, rx194_restart
    if_null rx194_debug, debug_633
    rx194_cur."!cursor_debug"("START", "deflongname")
  debug_633:
    $I10 = self.'from'()
    ne $I10, -1, rxscan198_done
    goto rxscan198_scan
  rxscan198_loop:
    (rx194_pos) = rx194_cur."from"()
    inc rx194_pos
    rx194_cur."!cursor_from"(rx194_pos)
    ge rx194_pos, rx194_eos, rxscan198_done
  rxscan198_scan:
    set_addr $I10, rxscan198_loop
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxscan198_done:
.annotate 'line', 47
  # rx subrule "identifier" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."identifier"()
    unless $P10, rx194_fail
    rx194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx194_pos = $P10."pos"()
  # rx rxquantr199 ** 0..1
    set_addr $I10, rxquantr199_done
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxquantr199_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."colonpair"()
    unless $P10, rx194_fail
    goto rxsubrule200_pass
  rxsubrule200_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx194_fail
  rxsubrule200_pass:
    set_addr $I10, rxsubrule200_back
    rx194_cur."!mark_push"(0, rx194_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx194_pos = $P10."pos"()
    set_addr $I10, rxquantr199_done
    (rx194_rep) = rx194_cur."!mark_commit"($I10)
  rxquantr199_done:
.annotate 'line', 46
  # rx pass
    rx194_cur."!cursor_pass"(rx194_pos, "deflongname")
    if_null rx194_debug, debug_634
    rx194_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx194_pos)
  debug_634:
    .return (rx194_cur)
  rx194_restart:
.annotate 'line', 10
    if_null rx194_debug, debug_635
    rx194_cur."!cursor_debug"("NEXT", "deflongname")
  debug_635:
  rx194_fail:
    (rx194_rep, rx194_pos, $I10, $P10) = rx194_cur."!mark_fail"(0)
    lt rx194_pos, -1, rx194_done
    eq rx194_pos, -1, rx194_fail
    jump $I10
  rx194_done:
    rx194_cur."!cursor_fail"()
    if_null rx194_debug, debug_636
    rx194_cur."!cursor_debug"("FAIL", "deflongname")
  debug_636:
    .return (rx194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1304277427.017") :method
.annotate 'line', 10
    $P196 = self."!PREFIX__!subrule"("identifier", "")
    new $P197, "ResizablePMCArray"
    push $P197, $P196
    .return ($P197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx202_tgt
    .local int rx202_pos
    .local int rx202_off
    .local int rx202_eos
    .local int rx202_rep
    .local pmc rx202_cur
    .local pmc rx202_debug
    (rx202_cur, rx202_pos, rx202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx202_cur
    .local pmc match
    .lex "$/", match
    length rx202_eos, rx202_tgt
    gt rx202_pos, rx202_eos, rx202_done
    set rx202_off, 0
    lt rx202_pos, 2, rx202_start
    sub rx202_off, rx202_pos, 1
    substr rx202_tgt, rx202_tgt, rx202_off
  rx202_start:
    eq $I10, 1, rx202_restart
    if_null rx202_debug, debug_637
    rx202_cur."!cursor_debug"("START", "ENDSTMT")
  debug_637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan205_done
    goto rxscan205_scan
  rxscan205_loop:
    (rx202_pos) = rx202_cur."from"()
    inc rx202_pos
    rx202_cur."!cursor_from"(rx202_pos)
    ge rx202_pos, rx202_eos, rxscan205_done
  rxscan205_scan:
    set_addr $I10, rxscan205_loop
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxscan205_done:
.annotate 'line', 54
  # rx rxquantr206 ** 0..1
    set_addr $I10, rxquantr206_done
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxquantr206_loop:
  alt207_0:
.annotate 'line', 51
    set_addr $I10, alt207_1
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
.annotate 'line', 52
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx202_pos, rx202_off
    set rx202_rep, 0
    sub $I12, rx202_eos, rx202_pos
  rxenumcharlistq208_loop:
    le $I12, 0, rxenumcharlistq208_done
    substr $S10, rx202_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq208_done
    inc rx202_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq208_loop
  rxenumcharlistq208_done:
    add rx202_pos, rx202_pos, rx202_rep
  # rxanchor eol
    sub $I10, rx202_pos, rx202_off
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rxanchor209_done
    ne rx202_pos, rx202_eos, rx202_fail
    eq rx202_pos, 0, rxanchor209_done
    dec $I10
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rx202_fail
  rxanchor209_done:
  # rx subrule "ws" subtype=method negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."ws"()
    unless $P10, rx202_fail
    rx202_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."MARKER"("endstmt")
    unless $P10, rx202_fail
    goto alt207_end
  alt207_1:
.annotate 'line', 53
  # rx rxquantr210 ** 0..1
    set_addr $I10, rxquantr210_done
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxquantr210_loop:
  # rx subrule "unv" subtype=method negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."unv"()
    unless $P10, rx202_fail
    goto rxsubrule211_pass
  rxsubrule211_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx202_fail
  rxsubrule211_pass:
    set_addr $I10, rxsubrule211_back
    rx202_cur."!mark_push"(0, rx202_pos, $I10, $P10)
    rx202_pos = $P10."pos"()
    set_addr $I10, rxquantr210_done
    (rx202_rep) = rx202_cur."!mark_commit"($I10)
  rxquantr210_done:
  # rxanchor eol
    sub $I10, rx202_pos, rx202_off
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rxanchor212_done
    ne rx202_pos, rx202_eos, rx202_fail
    eq rx202_pos, 0, rxanchor212_done
    dec $I10
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rx202_fail
  rxanchor212_done:
  # rx subrule "ws" subtype=method negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."ws"()
    unless $P10, rx202_fail
    rx202_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."MARKER"("endstmt")
    unless $P10, rx202_fail
  alt207_end:
.annotate 'line', 54
    set_addr $I10, rxquantr206_done
    (rx202_rep) = rx202_cur."!mark_commit"($I10)
  rxquantr206_done:
.annotate 'line', 50
  # rx pass
    rx202_cur."!cursor_pass"(rx202_pos, "ENDSTMT")
    if_null rx202_debug, debug_638
    rx202_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx202_pos)
  debug_638:
    .return (rx202_cur)
  rx202_restart:
.annotate 'line', 10
    if_null rx202_debug, debug_639
    rx202_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_639:
  rx202_fail:
    (rx202_rep, rx202_pos, $I10, $P10) = rx202_cur."!mark_fail"(0)
    lt rx202_pos, -1, rx202_done
    eq rx202_pos, -1, rx202_fail
    jump $I10
  rx202_done:
    rx202_cur."!cursor_fail"()
    if_null rx202_debug, debug_640
    rx202_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_640:
    .return (rx202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1304277427.017") :method
.annotate 'line', 10
    new $P204, "ResizablePMCArray"
    push $P204, ""
    .return ($P204)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx214_tgt
    .local int rx214_pos
    .local int rx214_off
    .local int rx214_eos
    .local int rx214_rep
    .local pmc rx214_cur
    .local pmc rx214_debug
    (rx214_cur, rx214_pos, rx214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx214_cur
    .local pmc match
    .lex "$/", match
    length rx214_eos, rx214_tgt
    gt rx214_pos, rx214_eos, rx214_done
    set rx214_off, 0
    lt rx214_pos, 2, rx214_start
    sub rx214_off, rx214_pos, 1
    substr rx214_tgt, rx214_tgt, rx214_off
  rx214_start:
    eq $I10, 1, rx214_restart
    if_null rx214_debug, debug_641
    rx214_cur."!cursor_debug"("START", "ws")
  debug_641:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx214_pos) = rx214_cur."from"()
    inc rx214_pos
    rx214_cur."!cursor_from"(rx214_pos)
    ge rx214_pos, rx214_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxscan217_done:
  alt218_0:
.annotate 'line', 57
    set_addr $I10, alt218_1
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 58
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."MARKED"("ws")
    unless $P10, rx214_fail
    goto alt218_end
  alt218_1:
.annotate 'line', 59
  # rx subrule "ww" subtype=zerowidth negate=1
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."ww"()
    if $P10, rx214_fail
.annotate 'line', 64
  # rx rxquantr219 ** 0..*
    set_addr $I10, rxquantr219_done
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxquantr219_loop:
  alt220_0:
.annotate 'line', 60
    set_addr $I10, alt220_1
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx214_pos, rx214_off
    set rx214_rep, 0
    sub $I12, rx214_eos, rx214_pos
  rxenumcharlistq221_loop:
    le $I12, 0, rxenumcharlistq221_done
    substr $S10, rx214_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq221_done
    inc rx214_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq221_loop
  rxenumcharlistq221_done:
    lt rx214_rep, 1, rx214_fail
    add rx214_pos, rx214_pos, rx214_rep
    goto alt220_end
  alt220_1:
    set_addr $I10, alt220_2
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 61
  # rx literal  "#"
    add $I11, rx214_pos, 1
    gt $I11, rx214_eos, rx214_fail
    sub $I11, rx214_pos, rx214_off
    ord $I11, rx214_tgt, $I11
    ne $I11, 35, rx214_fail
    add rx214_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx214_pos, rx214_off
    find_cclass $I11, 4096, rx214_tgt, $I10, rx214_eos
    add rx214_pos, rx214_off, $I11
    goto alt220_end
  alt220_2:
    set_addr $I10, alt220_3
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 62
  # rxanchor bol
    eq rx214_pos, 0, rxanchor222_done
    ge rx214_pos, rx214_eos, rx214_fail
    sub $I10, rx214_pos, rx214_off
    dec $I10
    is_cclass $I11, 4096, rx214_tgt, $I10
    unless $I11, rx214_fail
  rxanchor222_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."pod_comment"()
    unless $P10, rx214_fail
    rx214_pos = $P10."pos"()
    goto alt220_end
  alt220_3:
.annotate 'line', 63
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx214_pos, rx214_off
    set rx214_rep, 0
    sub $I12, rx214_eos, rx214_pos
  rxenumcharlistq223_loop:
    le $I12, 0, rxenumcharlistq223_done
    substr $S10, rx214_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq223_done
    inc rx214_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq223_loop
  rxenumcharlistq223_done:
    lt rx214_rep, 1, rx214_fail
    add rx214_pos, rx214_pos, rx214_rep
  alt220_end:
.annotate 'line', 64
    set_addr $I10, rxquantr219_done
    (rx214_rep) = rx214_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr219_done
    rx214_cur."!mark_push"(rx214_rep, rx214_pos, $I10)
    goto rxquantr219_loop
  rxquantr219_done:
.annotate 'line', 65
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."MARKER"("ws")
    unless $P10, rx214_fail
  alt218_end:
.annotate 'line', 57
  # rx pass
    rx214_cur."!cursor_pass"(rx214_pos, "ws")
    if_null rx214_debug, debug_642
    rx214_cur."!cursor_debug"("PASS", "ws", " at pos=", rx214_pos)
  debug_642:
    .return (rx214_cur)
  rx214_restart:
.annotate 'line', 10
    if_null rx214_debug, debug_643
    rx214_cur."!cursor_debug"("NEXT", "ws")
  debug_643:
  rx214_fail:
    (rx214_rep, rx214_pos, $I10, $P10) = rx214_cur."!mark_fail"(0)
    lt rx214_pos, -1, rx214_done
    eq rx214_pos, -1, rx214_fail
    jump $I10
  rx214_done:
    rx214_cur."!cursor_fail"()
    if_null rx214_debug, debug_644
    rx214_cur."!cursor_debug"("FAIL", "ws")
  debug_644:
    .return (rx214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1304277427.017") :method
.annotate 'line', 10
    new $P216, "ResizablePMCArray"
    push $P216, ""
    push $P216, ""
    .return ($P216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P232 = "26_1304277427.017" 
    capture_lex $P232
    .local string rx225_tgt
    .local int rx225_pos
    .local int rx225_off
    .local int rx225_eos
    .local int rx225_rep
    .local pmc rx225_cur
    .local pmc rx225_debug
    (rx225_cur, rx225_pos, rx225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx225_cur
    .local pmc match
    .lex "$/", match
    length rx225_eos, rx225_tgt
    gt rx225_pos, rx225_eos, rx225_done
    set rx225_off, 0
    lt rx225_pos, 2, rx225_start
    sub rx225_off, rx225_pos, 1
    substr rx225_tgt, rx225_tgt, rx225_off
  rx225_start:
    eq $I10, 1, rx225_restart
    if_null rx225_debug, debug_645
    rx225_cur."!cursor_debug"("START", "unv")
  debug_645:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx225_pos) = rx225_cur."from"()
    inc rx225_pos
    rx225_cur."!cursor_from"(rx225_pos)
    ge rx225_pos, rx225_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 70
    set_addr $I10, alt229_1
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 71
  # rxanchor bol
    eq rx225_pos, 0, rxanchor230_done
    ge rx225_pos, rx225_eos, rx225_fail
    sub $I10, rx225_pos, rx225_off
    dec $I10
    is_cclass $I11, 4096, rx225_tgt, $I10
    unless $I11, rx225_fail
  rxanchor230_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    .const 'Sub' $P232 = "26_1304277427.017" 
    capture_lex $P232
    $P10 = rx225_cur."before"($P232)
    unless $P10, rx225_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."pod_comment"()
    unless $P10, rx225_fail
    rx225_pos = $P10."pos"()
    goto alt229_end
  alt229_1:
    set_addr $I10, alt229_2
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 72
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx225_pos, rx225_off
    set rx225_rep, 0
    sub $I12, rx225_eos, rx225_pos
  rxenumcharlistq237_loop:
    le $I12, 0, rxenumcharlistq237_done
    substr $S10, rx225_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq237_done
    inc rx225_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq237_loop
  rxenumcharlistq237_done:
    add rx225_pos, rx225_pos, rx225_rep
  # rx literal  "#"
    add $I11, rx225_pos, 1
    gt $I11, rx225_eos, rx225_fail
    sub $I11, rx225_pos, rx225_off
    ord $I11, rx225_tgt, $I11
    ne $I11, 35, rx225_fail
    add rx225_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx225_pos, rx225_off
    find_cclass $I11, 4096, rx225_tgt, $I10, rx225_eos
    add rx225_pos, rx225_off, $I11
    goto alt229_end
  alt229_2:
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx225_pos, rx225_off
    set rx225_rep, 0
    sub $I12, rx225_eos, rx225_pos
  rxenumcharlistq238_loop:
    le $I12, 0, rxenumcharlistq238_done
    substr $S10, rx225_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq238_done
    inc rx225_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq238_loop
  rxenumcharlistq238_done:
    lt rx225_rep, 1, rx225_fail
    add rx225_pos, rx225_pos, rx225_rep
  alt229_end:
.annotate 'line', 68
  # rx pass
    rx225_cur."!cursor_pass"(rx225_pos, "unv")
    if_null rx225_debug, debug_650
    rx225_cur."!cursor_debug"("PASS", "unv", " at pos=", rx225_pos)
  debug_650:
    .return (rx225_cur)
  rx225_restart:
.annotate 'line', 10
    if_null rx225_debug, debug_651
    rx225_cur."!cursor_debug"("NEXT", "unv")
  debug_651:
  rx225_fail:
    (rx225_rep, rx225_pos, $I10, $P10) = rx225_cur."!mark_fail"(0)
    lt rx225_pos, -1, rx225_done
    eq rx225_pos, -1, rx225_fail
    jump $I10
  rx225_done:
    rx225_cur."!cursor_fail"()
    if_null rx225_debug, debug_652
    rx225_cur."!cursor_debug"("FAIL", "unv")
  debug_652:
    .return (rx225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1304277427.017") :method
.annotate 'line', 10
    new $P227, "ResizablePMCArray"
    push $P227, ""
    push $P227, ""
    push $P227, ""
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block231"  :anon :subid("26_1304277427.017") :method :outer("24_1304277427.017")
.annotate 'line', 71
    .local string rx233_tgt
    .local int rx233_pos
    .local int rx233_off
    .local int rx233_eos
    .local int rx233_rep
    .local pmc rx233_cur
    .local pmc rx233_debug
    (rx233_cur, rx233_pos, rx233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx233_cur
    .local pmc match
    .lex "$/", match
    length rx233_eos, rx233_tgt
    gt rx233_pos, rx233_eos, rx233_done
    set rx233_off, 0
    lt rx233_pos, 2, rx233_start
    sub rx233_off, rx233_pos, 1
    substr rx233_tgt, rx233_tgt, rx233_off
  rx233_start:
    eq $I10, 1, rx233_restart
    if_null rx233_debug, debug_646
    rx233_cur."!cursor_debug"("START", "")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan234_done
    goto rxscan234_scan
  rxscan234_loop:
    (rx233_pos) = rx233_cur."from"()
    inc rx233_pos
    rx233_cur."!cursor_from"(rx233_pos)
    ge rx233_pos, rx233_eos, rxscan234_done
  rxscan234_scan:
    set_addr $I10, rxscan234_loop
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxscan234_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx233_pos, rx233_off
    set rx233_rep, 0
    sub $I12, rx233_eos, rx233_pos
  rxenumcharlistq235_loop:
    le $I12, 0, rxenumcharlistq235_done
    substr $S10, rx233_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq235_done
    inc rx233_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq235_loop
  rxenumcharlistq235_done:
    add rx233_pos, rx233_pos, rx233_rep
  # rx literal  "="
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 61, rx233_fail
    add rx233_pos, 1
  alt236_0:
    set_addr $I10, alt236_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  # rx charclass w
    ge rx233_pos, rx233_eos, rx233_fail
    sub $I10, rx233_pos, rx233_off
    is_cclass $I11, 8192, rx233_tgt, $I10
    unless $I11, rx233_fail
    inc rx233_pos
    goto alt236_end
  alt236_1:
  # rx literal  "\\"
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 92, rx233_fail
    add rx233_pos, 1
  alt236_end:
  # rx pass
    rx233_cur."!cursor_pass"(rx233_pos, "")
    if_null rx233_debug, debug_647
    rx233_cur."!cursor_debug"("PASS", "", " at pos=", rx233_pos)
  debug_647:
    .return (rx233_cur)
  rx233_restart:
    if_null rx233_debug, debug_648
    rx233_cur."!cursor_debug"("NEXT", "")
  debug_648:
  rx233_fail:
    (rx233_rep, rx233_pos, $I10, $P10) = rx233_cur."!mark_fail"(0)
    lt rx233_pos, -1, rx233_done
    eq rx233_pos, -1, rx233_fail
    jump $I10
  rx233_done:
    rx233_cur."!cursor_fail"()
    if_null rx233_debug, debug_649
    rx233_cur."!cursor_debug"("FAIL", "")
  debug_649:
    .return (rx233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P271 = "29_1304277427.017" 
    capture_lex $P271
    .local string rx240_tgt
    .local int rx240_pos
    .local int rx240_off
    .local int rx240_eos
    .local int rx240_rep
    .local pmc rx240_cur
    .local pmc rx240_debug
    (rx240_cur, rx240_pos, rx240_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx240_cur
    .local pmc match
    .lex "$/", match
    length rx240_eos, rx240_tgt
    gt rx240_pos, rx240_eos, rx240_done
    set rx240_off, 0
    lt rx240_pos, 2, rx240_start
    sub rx240_off, rx240_pos, 1
    substr rx240_tgt, rx240_tgt, rx240_off
  rx240_start:
    eq $I10, 1, rx240_restart
    if_null rx240_debug, debug_653
    rx240_cur."!cursor_debug"("START", "pod_comment")
  debug_653:
    $I10 = self.'from'()
    ne $I10, -1, rxscan243_done
    goto rxscan243_scan
  rxscan243_loop:
    (rx240_pos) = rx240_cur."from"()
    inc rx240_pos
    rx240_cur."!cursor_from"(rx240_pos)
    ge rx240_pos, rx240_eos, rxscan243_done
  rxscan243_scan:
    set_addr $I10, rxscan243_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  rxscan243_done:
.annotate 'line', 78
  # rxanchor bol
    eq rx240_pos, 0, rxanchor244_done
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    dec $I10
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
  rxanchor244_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq245_loop:
    le $I12, 0, rxenumcharlistq245_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq245_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq245_loop
  rxenumcharlistq245_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "="
    add $I11, rx240_pos, 1
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    ord $I11, rx240_tgt, $I11
    ne $I11, 61, rx240_fail
    add rx240_pos, 1
  alt246_0:
.annotate 'line', 79
    set_addr $I10, alt246_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx240_pos, 5
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 5
    ne $S10, "begin", rx240_fail
    add rx240_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq247_loop:
    le $I12, 0, rxenumcharlistq247_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq247_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq247_loop
  rxenumcharlistq247_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "END"
    add $I11, rx240_pos, 3
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 3
    ne $S10, "END", rx240_fail
    add rx240_pos, 3
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  alt248_0:
.annotate 'line', 81
    set_addr $I10, alt248_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rx rxquantf249 ** 0..*
    set_addr $I10, rxquantf249_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf249_done
  rxquantf249_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf249_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf249_done:
  # rx charclass nl
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
    substr $S10, rx240_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx240_pos, $I11
    inc rx240_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq251_loop:
    le $I12, 0, rxenumcharlistq251_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq251_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq251_loop
  rxenumcharlistq251_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "=end"
    add $I11, rx240_pos, 4
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 4
    ne $S10, "=end", rx240_fail
    add rx240_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq252_loop:
    le $I12, 0, rxenumcharlistq252_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq252_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq252_loop
  rxenumcharlistq252_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "END"
    add $I11, rx240_pos, 3
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 3
    ne $S10, "END", rx240_fail
    add rx240_pos, 3
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
    goto alt248_end
  alt248_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_not_cclass $I11, 65535, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
  alt248_end:
.annotate 'line', 80
    goto alt246_end
  alt246_1:
    set_addr $I10, alt246_2
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 82
  # rx literal  "begin"
    add $I11, rx240_pos, 5
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 5
    ne $S10, "begin", rx240_fail
    add rx240_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq253_loop:
    le $I12, 0, rxenumcharlistq253_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq253_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq253_loop
  rxenumcharlistq253_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx subrule "identifier" subtype=capture negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."identifier"()
    unless $P10, rx240_fail
    rx240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx240_pos = $P10."pos"()
  alt254_0:
.annotate 'line', 83
    set_addr $I10, alt254_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 84
  # rx rxquantf255 ** 0..*
    set_addr $I10, rxquantf255_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf255_done
  rxquantf255_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf255_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf255_done:
  # rx charclass nl
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
    substr $S10, rx240_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx240_pos, $I11
    inc rx240_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq257_loop:
    le $I12, 0, rxenumcharlistq257_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq257_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq257_loop
  rxenumcharlistq257_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "=end"
    add $I11, rx240_pos, 4
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 4
    ne $S10, "=end", rx240_fail
    add rx240_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq258_loop:
    le $I12, 0, rxenumcharlistq258_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq258_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq258_loop
  rxenumcharlistq258_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."!BACKREF"("identifier")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
    goto alt254_end
  alt254_1:
.annotate 'line', 85
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("=begin without matching =end")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt254_end:
.annotate 'line', 82
    goto alt246_end
  alt246_2:
    set_addr $I10, alt246_3
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx240_pos, 5
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 5
    ne $S10, "begin", rx240_fail
    add rx240_pos, 5
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq260_loop:
    le $I12, 0, rxenumcharlistq260_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq260_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq260_loop
  rxenumcharlistq260_done:
    add rx240_pos, rx240_pos, rx240_rep
  alt261_0:
.annotate 'line', 88
    set_addr $I10, alt261_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rxanchor eol
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    if $I11, rxanchor262_done
    ne rx240_pos, rx240_eos, rx240_fail
    eq rx240_pos, 0, rxanchor262_done
    dec $I10
    is_cclass $I11, 4096, rx240_tgt, $I10
    if $I11, rx240_fail
  rxanchor262_done:
    goto alt261_end
  alt261_1:
    set_addr $I10, alt261_2
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rx literal  "#"
    add $I11, rx240_pos, 1
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    ord $I11, rx240_tgt, $I11
    ne $I11, 35, rx240_fail
    add rx240_pos, 1
    goto alt261_end
  alt261_2:
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt261_end:
  alt263_0:
.annotate 'line', 89
    set_addr $I10, alt263_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 90
  # rx rxquantf264 ** 0..*
    set_addr $I10, rxquantf264_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf264_done
  rxquantf264_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf264_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf264_done:
  # rx charclass nl
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
    substr $S10, rx240_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx240_pos, $I11
    inc rx240_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq266_loop:
    le $I12, 0, rxenumcharlistq266_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq266_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq266_loop
  rxenumcharlistq266_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "=end"
    add $I11, rx240_pos, 4
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 4
    ne $S10, "=end", rx240_fail
    add rx240_pos, 4
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
    goto alt263_end
  alt263_1:
.annotate 'line', 91
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("=begin without matching =end")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt263_end:
.annotate 'line', 87
    goto alt246_end
  alt246_3:
    set_addr $I10, alt246_4
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 93
  # rx subrule "identifier" subtype=capture negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."identifier"()
    unless $P10, rx240_fail
    rx240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx240_pos = $P10."pos"()
.annotate 'line', 94
  # rx rxquantf267 ** 0..*
    set_addr $I10, rxquantf267_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf267_done
  rxquantf267_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf267_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf267_done:
  # rxanchor bol
    eq rx240_pos, 0, rxanchor269_done
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    dec $I10
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
  rxanchor269_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    .const 'Sub' $P271 = "29_1304277427.017" 
    capture_lex $P271
    $P10 = rx240_cur."before"($P271)
    unless $P10, rx240_fail
.annotate 'line', 93
    goto alt246_end
  alt246_4:
  alt277_0:
.annotate 'line', 100
    set_addr $I10, alt277_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rx charclass s
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 32, rx240_tgt, $I10
    unless $I11, rx240_fail
    inc rx240_pos
    goto alt277_end
  alt277_1:
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("Illegal pod directive")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt277_end:
.annotate 'line', 101
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
  alt246_end:
.annotate 'line', 77
  # rx pass
    rx240_cur."!cursor_pass"(rx240_pos, "pod_comment")
    if_null rx240_debug, debug_658
    rx240_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx240_pos)
  debug_658:
    .return (rx240_cur)
  rx240_restart:
.annotate 'line', 10
    if_null rx240_debug, debug_659
    rx240_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_659:
  rx240_fail:
    (rx240_rep, rx240_pos, $I10, $P10) = rx240_cur."!mark_fail"(0)
    lt rx240_pos, -1, rx240_done
    eq rx240_pos, -1, rx240_fail
    jump $I10
  rx240_done:
    rx240_cur."!cursor_fail"()
    if_null rx240_debug, debug_660
    rx240_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_660:
    .return (rx240_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1304277427.017") :method
.annotate 'line', 10
    new $P242, "ResizablePMCArray"
    push $P242, ""
    .return ($P242)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block270"  :anon :subid("29_1304277427.017") :method :outer("27_1304277427.017")
.annotate 'line', 94
    .local string rx272_tgt
    .local int rx272_pos
    .local int rx272_off
    .local int rx272_eos
    .local int rx272_rep
    .local pmc rx272_cur
    .local pmc rx272_debug
    (rx272_cur, rx272_pos, rx272_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx272_cur
    .local pmc match
    .lex "$/", match
    length rx272_eos, rx272_tgt
    gt rx272_pos, rx272_eos, rx272_done
    set rx272_off, 0
    lt rx272_pos, 2, rx272_start
    sub rx272_off, rx272_pos, 1
    substr rx272_tgt, rx272_tgt, rx272_off
  rx272_start:
    eq $I10, 1, rx272_restart
    if_null rx272_debug, debug_654
    rx272_cur."!cursor_debug"("START", "")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan273_done
    goto rxscan273_scan
  rxscan273_loop:
    (rx272_pos) = rx272_cur."from"()
    inc rx272_pos
    rx272_cur."!cursor_from"(rx272_pos)
    ge rx272_pos, rx272_eos, rxscan273_done
  rxscan273_scan:
    set_addr $I10, rxscan273_loop
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
  rxscan273_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx272_pos, rx272_off
    set rx272_rep, 0
    sub $I12, rx272_eos, rx272_pos
  rxenumcharlistq274_loop:
    le $I12, 0, rxenumcharlistq274_done
    substr $S10, rx272_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq274_done
    inc rx272_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq274_loop
  rxenumcharlistq274_done:
    add rx272_pos, rx272_pos, rx272_rep
  alt275_0:
    set_addr $I10, alt275_1
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
.annotate 'line', 95
  # rx literal  "="
    add $I11, rx272_pos, 1
    gt $I11, rx272_eos, rx272_fail
    sub $I11, rx272_pos, rx272_off
    ord $I11, rx272_tgt, $I11
    ne $I11, 61, rx272_fail
    add rx272_pos, 1
.annotate 'line', 97
  # rx rxquantr276 ** 0..1
    set_addr $I10, rxquantr276_done
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
  rxquantr276_loop:
.annotate 'line', 96
  # rx literal  "cut"
    add $I11, rx272_pos, 3
    gt $I11, rx272_eos, rx272_fail
    sub $I11, rx272_pos, rx272_off
    substr $S10, rx272_tgt, $I11, 3
    ne $S10, "cut", rx272_fail
    add rx272_pos, 3
  # rxanchor rwb
    le rx272_pos, 0, rx272_fail
    sub $I10, rx272_pos, rx272_off
    is_cclass $I11, 8192, rx272_tgt, $I10
    if $I11, rx272_fail
    dec $I10
    is_cclass $I11, 8192, rx272_tgt, $I10
    unless $I11, rx272_fail
.annotate 'line', 97
  # rx subrule "panic" subtype=method negate=
    rx272_cur."!cursor_pos"(rx272_pos)
    $P10 = rx272_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx272_fail
    rx272_pos = $P10."pos"()
    set_addr $I10, rxquantr276_done
    (rx272_rep) = rx272_cur."!mark_commit"($I10)
  rxquantr276_done:
.annotate 'line', 94
    goto alt275_end
  alt275_1:
.annotate 'line', 98
  # rx charclass nl
    ge rx272_pos, rx272_eos, rx272_fail
    sub $I10, rx272_pos, rx272_off
    is_cclass $I11, 4096, rx272_tgt, $I10
    unless $I11, rx272_fail
    substr $S10, rx272_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx272_pos, $I11
    inc rx272_pos
  alt275_end:
.annotate 'line', 94
  # rx pass
    rx272_cur."!cursor_pass"(rx272_pos, "")
    if_null rx272_debug, debug_655
    rx272_cur."!cursor_debug"("PASS", "", " at pos=", rx272_pos)
  debug_655:
    .return (rx272_cur)
  rx272_restart:
    if_null rx272_debug, debug_656
    rx272_cur."!cursor_debug"("NEXT", "")
  debug_656:
  rx272_fail:
    (rx272_rep, rx272_pos, $I10, $P10) = rx272_cur."!mark_fail"(0)
    lt rx272_pos, -1, rx272_done
    eq rx272_pos, -1, rx272_fail
    jump $I10
  rx272_done:
    rx272_cur."!cursor_fail"()
    if_null rx272_debug, debug_657
    rx272_cur."!cursor_debug"("FAIL", "")
  debug_657:
    .return (rx272_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 109
    new $P279, "Undef"
    .lex "$*IN_DECL", $P279
.annotate 'line', 111
    new $P280, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P280
.annotate 'line', 112
    new $P281, "Undef"
    .lex "$*MAIN_SUB", $P281
.annotate 'line', 115
    new $P282, "Undef"
    .lex "$*PACKAGE", $P282
.annotate 'line', 116
    new $P283, "Undef"
    .lex "$*GLOBALish", $P283
.annotate 'line', 10
    .local string rx284_tgt
    .local int rx284_pos
    .local int rx284_off
    .local int rx284_eos
    .local int rx284_rep
    .local pmc rx284_cur
    .local pmc rx284_debug
    (rx284_cur, rx284_pos, rx284_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx284_cur
    .local pmc match
    .lex "$/", match
    length rx284_eos, rx284_tgt
    gt rx284_pos, rx284_eos, rx284_done
    set rx284_off, 0
    lt rx284_pos, 2, rx284_start
    sub rx284_off, rx284_pos, 1
    substr rx284_tgt, rx284_tgt, rx284_off
  rx284_start:
    eq $I10, 1, rx284_restart
    if_null rx284_debug, debug_661
    rx284_cur."!cursor_debug"("START", "comp_unit")
  debug_661:
    $I10 = self.'from'()
    ne $I10, -1, rxscan288_done
    goto rxscan288_scan
  rxscan288_loop:
    (rx284_pos) = rx284_cur."from"()
    inc rx284_pos
    rx284_cur."!cursor_from"(rx284_pos)
    ge rx284_pos, rx284_eos, rxscan288_done
  rxscan288_scan:
    set_addr $I10, rxscan288_loop
    rx284_cur."!mark_push"(0, rx284_pos, $I10)
  rxscan288_done:
.annotate 'line', 109
    rx284_cur."!cursor_pos"(rx284_pos)
    new $P289, "String"
    assign $P289, ""
    store_lex "$*IN_DECL", $P289
.annotate 'line', 111
    rx284_cur."!cursor_pos"(rx284_pos)
    new $P290, "Integer"
    assign $P290, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P290
.annotate 'line', 112
    rx284_cur."!cursor_pos"(rx284_pos)
    find_lex $P293, "$*MAIN_SUB"
    unless_null $P293, vivify_662
    get_hll_global $P291, "GLOBAL"
    get_who $P292, $P291
    set $P293, $P292["$MAIN_SUB"]
    unless_null $P293, vivify_663
    die "Contextual $*MAIN_SUB not found"
  vivify_663:
  vivify_662:
.annotate 'line', 113
  # rx subrule "newpad" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."newpad"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 115
    rx284_cur."!cursor_pos"(rx284_pos)
    find_lex $P296, "$*PACKAGE"
    unless_null $P296, vivify_664
    get_hll_global $P294, "GLOBAL"
    get_who $P295, $P294
    set $P296, $P295["$PACKAGE"]
    unless_null $P296, vivify_665
    die "Contextual $*PACKAGE not found"
  vivify_665:
  vivify_664:
.annotate 'line', 116
    rx284_cur."!cursor_pos"(rx284_pos)
    find_lex $P299, "$*GLOBALish"
    unless_null $P299, vivify_666
    get_hll_global $P297, "GLOBAL"
    get_who $P298, $P297
    set $P299, $P298["$GLOBALish"]
    unless_null $P299, vivify_667
    die "Contextual $*GLOBALish not found"
  vivify_667:
  vivify_666:
.annotate 'line', 117
  # rx subrule "GLOBALish" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."GLOBALish"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."outerctx"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 121
  # rx subrule "statementlist" subtype=capture negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."statementlist"()
    unless $P10, rx284_fail
    rx284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx284_pos = $P10."pos"()
  alt300_0:
.annotate 'line', 122
    set_addr $I10, alt300_1
    rx284_cur."!mark_push"(0, rx284_pos, $I10)
  # rxanchor eos
    ne rx284_pos, rx284_eos, rx284_fail
    goto alt300_end
  alt300_1:
  # rx subrule "panic" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."panic"("Confused")
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
  alt300_end:
.annotate 'line', 108
  # rx pass
    rx284_cur."!cursor_pass"(rx284_pos, "comp_unit")
    if_null rx284_debug, debug_668
    rx284_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx284_pos)
  debug_668:
    .return (rx284_cur)
  rx284_restart:
.annotate 'line', 10
    if_null rx284_debug, debug_669
    rx284_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_669:
  rx284_fail:
    (rx284_rep, rx284_pos, $I10, $P10) = rx284_cur."!mark_fail"(0)
    lt rx284_pos, -1, rx284_done
    eq rx284_pos, -1, rx284_fail
    jump $I10
  rx284_done:
    rx284_cur."!cursor_fail"()
    if_null rx284_debug, debug_670
    rx284_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_670:
    .return (rx284_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1304277427.017") :method
.annotate 'line', 10
    $P286 = self."!PREFIX__!subrule"("newpad", "")
    new $P287, "ResizablePMCArray"
    push $P287, $P286
    .return ($P287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx302_tgt
    .local int rx302_pos
    .local int rx302_off
    .local int rx302_eos
    .local int rx302_rep
    .local pmc rx302_cur
    .local pmc rx302_debug
    (rx302_cur, rx302_pos, rx302_tgt, $I10) = self."!cursor_start"()
    rx302_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx302_cur
    .local pmc match
    .lex "$/", match
    length rx302_eos, rx302_tgt
    gt rx302_pos, rx302_eos, rx302_done
    set rx302_off, 0
    lt rx302_pos, 2, rx302_start
    sub rx302_off, rx302_pos, 1
    substr rx302_tgt, rx302_tgt, rx302_off
  rx302_start:
    eq $I10, 1, rx302_restart
    if_null rx302_debug, debug_671
    rx302_cur."!cursor_debug"("START", "statementlist")
  debug_671:
    $I10 = self.'from'()
    ne $I10, -1, rxscan307_done
    goto rxscan307_scan
  rxscan307_loop:
    (rx302_pos) = rx302_cur."from"()
    inc rx302_pos
    rx302_cur."!cursor_from"(rx302_pos)
    ge rx302_pos, rx302_eos, rxscan307_done
  rxscan307_scan:
    set_addr $I10, rxscan307_loop
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxscan307_done:
  alt308_0:
.annotate 'line', 125
    set_addr $I10, alt308_1
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rxanchor eos
    ne rx302_pos, rx302_eos, rx302_fail
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
    goto alt308_end
  alt308_1:
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx rxquantr312 ** 0..*
    set_addr $I10, rxquantr312_done
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxquantr312_loop:
  # rx subrule "statement" subtype=capture negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."statement"()
    unless $P10, rx302_fail
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx302_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."eat_terminator"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
    set_addr $I10, rxquantr312_done
    (rx302_rep) = rx302_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr312_done
    rx302_cur."!mark_push"(rx302_rep, rx302_pos, $I10)
    goto rxquantr312_loop
  rxquantr312_done:
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  alt308_end:
.annotate 'line', 125
  # rx pass
    rx302_cur."!cursor_pass"(rx302_pos, "statementlist")
    if_null rx302_debug, debug_672
    rx302_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx302_pos)
  debug_672:
    .return (rx302_cur)
  rx302_restart:
.annotate 'line', 10
    if_null rx302_debug, debug_673
    rx302_cur."!cursor_debug"("NEXT", "statementlist")
  debug_673:
  rx302_fail:
    (rx302_rep, rx302_pos, $I10, $P10) = rx302_cur."!mark_fail"(0)
    lt rx302_pos, -1, rx302_done
    eq rx302_pos, -1, rx302_fail
    jump $I10
  rx302_done:
    rx302_cur."!cursor_fail"()
    if_null rx302_debug, debug_674
    rx302_cur."!cursor_debug"("FAIL", "statementlist")
  debug_674:
    .return (rx302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1304277427.017") :method
.annotate 'line', 10
    $P304 = self."!PREFIX__!subrule"("ws", "")
    $P305 = self."!PREFIX__!subrule"("ws", "")
    new $P306, "ResizablePMCArray"
    push $P306, $P304
    push $P306, $P305
    .return ($P306)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P321 = "36_1304277427.017" 
    capture_lex $P321
    .local string rx316_tgt
    .local int rx316_pos
    .local int rx316_off
    .local int rx316_eos
    .local int rx316_rep
    .local pmc rx316_cur
    .local pmc rx316_debug
    (rx316_cur, rx316_pos, rx316_tgt, $I10) = self."!cursor_start"()
    rx316_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx316_cur
    .local pmc match
    .lex "$/", match
    length rx316_eos, rx316_tgt
    gt rx316_pos, rx316_eos, rx316_done
    set rx316_off, 0
    lt rx316_pos, 2, rx316_start
    sub rx316_off, rx316_pos, 1
    substr rx316_tgt, rx316_tgt, rx316_off
  rx316_start:
    eq $I10, 1, rx316_restart
    if_null rx316_debug, debug_675
    rx316_cur."!cursor_debug"("START", "statement")
  debug_675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan319_done
    goto rxscan319_scan
  rxscan319_loop:
    (rx316_pos) = rx316_cur."from"()
    inc rx316_pos
    rx316_cur."!cursor_from"(rx316_pos)
    ge rx316_pos, rx316_eos, rxscan319_done
  rxscan319_scan:
    set_addr $I10, rxscan319_loop
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  rxscan319_done:
.annotate 'line', 131
  # rx subrule "before" subtype=zerowidth negate=1
    rx316_cur."!cursor_pos"(rx316_pos)
    .const 'Sub' $P321 = "36_1304277427.017" 
    capture_lex $P321
    $P10 = rx316_cur."before"($P321)
    if $P10, rx316_fail
  alt325_0:
.annotate 'line', 132
    set_addr $I10, alt325_1
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
.annotate 'line', 133
  # rx subrule "statement_control" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_control"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx316_pos = $P10."pos"()
    goto alt325_end
  alt325_1:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."EXPR"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx316_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
.annotate 'line', 139
  # rx rxquantr326 ** 0..1
    set_addr $I10, rxquantr326_done
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  rxquantr326_loop:
  alt327_0:
.annotate 'line', 135
    set_addr $I10, alt327_1
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
.annotate 'line', 136
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."MARKED"("endstmt")
    unless $P10, rx316_fail
    goto alt327_end
  alt327_1:
    set_addr $I10, alt327_2
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_mod_cond"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx316_pos = $P10."pos"()
  # rx rxquantr328 ** 0..1
    set_addr $I10, rxquantr328_done
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  rxquantr328_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_mod_loop"()
    unless $P10, rx316_fail
    goto rxsubrule329_pass
  rxsubrule329_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx316_fail
  rxsubrule329_pass:
    set_addr $I10, rxsubrule329_back
    rx316_cur."!mark_push"(0, rx316_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx316_pos = $P10."pos"()
    set_addr $I10, rxquantr328_done
    (rx316_rep) = rx316_cur."!mark_commit"($I10)
  rxquantr328_done:
    goto alt327_end
  alt327_2:
.annotate 'line', 138
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_mod_loop"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx316_pos = $P10."pos"()
  alt327_end:
.annotate 'line', 139
    set_addr $I10, rxquantr326_done
    (rx316_rep) = rx316_cur."!mark_commit"($I10)
  rxquantr326_done:
  alt325_end:
.annotate 'line', 130
  # rx pass
    rx316_cur."!cursor_pass"(rx316_pos, "statement")
    if_null rx316_debug, debug_680
    rx316_cur."!cursor_debug"("PASS", "statement", " at pos=", rx316_pos)
  debug_680:
    .return (rx316_cur)
  rx316_restart:
.annotate 'line', 10
    if_null rx316_debug, debug_681
    rx316_cur."!cursor_debug"("NEXT", "statement")
  debug_681:
  rx316_fail:
    (rx316_rep, rx316_pos, $I10, $P10) = rx316_cur."!mark_fail"(0)
    lt rx316_pos, -1, rx316_done
    eq rx316_pos, -1, rx316_fail
    jump $I10
  rx316_done:
    rx316_cur."!cursor_fail"()
    if_null rx316_debug, debug_682
    rx316_cur."!cursor_debug"("FAIL", "statement")
  debug_682:
    .return (rx316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1304277427.017") :method
.annotate 'line', 10
    new $P318, "ResizablePMCArray"
    push $P318, ""
    .return ($P318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block320"  :anon :subid("36_1304277427.017") :method :outer("34_1304277427.017")
.annotate 'line', 131
    .local string rx322_tgt
    .local int rx322_pos
    .local int rx322_off
    .local int rx322_eos
    .local int rx322_rep
    .local pmc rx322_cur
    .local pmc rx322_debug
    (rx322_cur, rx322_pos, rx322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx322_cur
    .local pmc match
    .lex "$/", match
    length rx322_eos, rx322_tgt
    gt rx322_pos, rx322_eos, rx322_done
    set rx322_off, 0
    lt rx322_pos, 2, rx322_start
    sub rx322_off, rx322_pos, 1
    substr rx322_tgt, rx322_tgt, rx322_off
  rx322_start:
    eq $I10, 1, rx322_restart
    if_null rx322_debug, debug_676
    rx322_cur."!cursor_debug"("START", "")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan323_done
    goto rxscan323_scan
  rxscan323_loop:
    (rx322_pos) = rx322_cur."from"()
    inc rx322_pos
    rx322_cur."!cursor_from"(rx322_pos)
    ge rx322_pos, rx322_eos, rxscan323_done
  rxscan323_scan:
    set_addr $I10, rxscan323_loop
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  rxscan323_done:
  alt324_0:
    set_addr $I10, alt324_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx322_fail
    inc rx322_pos
    goto alt324_end
  alt324_1:
  # rxanchor eos
    ne rx322_pos, rx322_eos, rx322_fail
  alt324_end:
  # rx pass
    rx322_cur."!cursor_pass"(rx322_pos, "")
    if_null rx322_debug, debug_677
    rx322_cur."!cursor_debug"("PASS", "", " at pos=", rx322_pos)
  debug_677:
    .return (rx322_cur)
  rx322_restart:
    if_null rx322_debug, debug_678
    rx322_cur."!cursor_debug"("NEXT", "")
  debug_678:
  rx322_fail:
    (rx322_rep, rx322_pos, $I10, $P10) = rx322_cur."!mark_fail"(0)
    lt rx322_pos, -1, rx322_done
    eq rx322_pos, -1, rx322_fail
    jump $I10
  rx322_done:
    rx322_cur."!cursor_fail"()
    if_null rx322_debug, debug_679
    rx322_cur."!cursor_debug"("FAIL", "")
  debug_679:
    .return (rx322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx331_tgt
    .local int rx331_pos
    .local int rx331_off
    .local int rx331_eos
    .local int rx331_rep
    .local pmc rx331_cur
    .local pmc rx331_debug
    (rx331_cur, rx331_pos, rx331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx331_cur
    .local pmc match
    .lex "$/", match
    length rx331_eos, rx331_tgt
    gt rx331_pos, rx331_eos, rx331_done
    set rx331_off, 0
    lt rx331_pos, 2, rx331_start
    sub rx331_off, rx331_pos, 1
    substr rx331_tgt, rx331_tgt, rx331_off
  rx331_start:
    eq $I10, 1, rx331_restart
    if_null rx331_debug, debug_683
    rx331_cur."!cursor_debug"("START", "eat_terminator")
  debug_683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan334_done
    goto rxscan334_scan
  rxscan334_loop:
    (rx331_pos) = rx331_cur."from"()
    inc rx331_pos
    rx331_cur."!cursor_from"(rx331_pos)
    ge rx331_pos, rx331_eos, rxscan334_done
  rxscan334_scan:
    set_addr $I10, rxscan334_loop
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
  rxscan334_done:
  alt335_0:
.annotate 'line', 143
    set_addr $I10, alt335_1
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
.annotate 'line', 144
  # rx literal  ";"
    add $I11, rx331_pos, 1
    gt $I11, rx331_eos, rx331_fail
    sub $I11, rx331_pos, rx331_off
    ord $I11, rx331_tgt, $I11
    ne $I11, 59, rx331_fail
    add rx331_pos, 1
    goto alt335_end
  alt335_1:
    set_addr $I10, alt335_2
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
.annotate 'line', 145
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx331_cur."!cursor_pos"(rx331_pos)
    $P10 = rx331_cur."MARKED"("endstmt")
    unless $P10, rx331_fail
    goto alt335_end
  alt335_2:
    set_addr $I10, alt335_3
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
.annotate 'line', 146
  # rx subrule "terminator" subtype=zerowidth negate=
    rx331_cur."!cursor_pos"(rx331_pos)
    $P10 = rx331_cur."terminator"()
    unless $P10, rx331_fail
    goto alt335_end
  alt335_3:
.annotate 'line', 147
  # rxanchor eos
    ne rx331_pos, rx331_eos, rx331_fail
  alt335_end:
.annotate 'line', 143
  # rx pass
    rx331_cur."!cursor_pass"(rx331_pos, "eat_terminator")
    if_null rx331_debug, debug_684
    rx331_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx331_pos)
  debug_684:
    .return (rx331_cur)
  rx331_restart:
.annotate 'line', 10
    if_null rx331_debug, debug_685
    rx331_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_685:
  rx331_fail:
    (rx331_rep, rx331_pos, $I10, $P10) = rx331_cur."!mark_fail"(0)
    lt rx331_pos, -1, rx331_done
    eq rx331_pos, -1, rx331_fail
    jump $I10
  rx331_done:
    rx331_cur."!cursor_fail"()
    if_null rx331_debug, debug_686
    rx331_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_686:
    .return (rx331_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1304277427.017") :method
.annotate 'line', 10
    new $P333, "ResizablePMCArray"
    push $P333, ""
    push $P333, ""
    push $P333, ""
    push $P333, ";"
    .return ($P333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx337_tgt
    .local int rx337_pos
    .local int rx337_off
    .local int rx337_eos
    .local int rx337_rep
    .local pmc rx337_cur
    .local pmc rx337_debug
    (rx337_cur, rx337_pos, rx337_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx337_cur
    .local pmc match
    .lex "$/", match
    length rx337_eos, rx337_tgt
    gt rx337_pos, rx337_eos, rx337_done
    set rx337_off, 0
    lt rx337_pos, 2, rx337_start
    sub rx337_off, rx337_pos, 1
    substr rx337_tgt, rx337_tgt, rx337_off
  rx337_start:
    eq $I10, 1, rx337_restart
    if_null rx337_debug, debug_687
    rx337_cur."!cursor_debug"("START", "xblock")
  debug_687:
    $I10 = self.'from'()
    ne $I10, -1, rxscan341_done
    goto rxscan341_scan
  rxscan341_loop:
    (rx337_pos) = rx337_cur."from"()
    inc rx337_pos
    rx337_cur."!cursor_from"(rx337_pos)
    ge rx337_pos, rx337_eos, rxscan341_done
  rxscan341_scan:
    set_addr $I10, rxscan341_loop
    rx337_cur."!mark_push"(0, rx337_pos, $I10)
  rxscan341_done:
.annotate 'line', 151
  # rx subrule "EXPR" subtype=capture negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."EXPR"()
    unless $P10, rx337_fail
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx337_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."ws"()
    unless $P10, rx337_fail
    rx337_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."pblock"()
    unless $P10, rx337_fail
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx337_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx337_cur."!cursor_pass"(rx337_pos, "xblock")
    if_null rx337_debug, debug_688
    rx337_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx337_pos)
  debug_688:
    .return (rx337_cur)
  rx337_restart:
.annotate 'line', 10
    if_null rx337_debug, debug_689
    rx337_cur."!cursor_debug"("NEXT", "xblock")
  debug_689:
  rx337_fail:
    (rx337_rep, rx337_pos, $I10, $P10) = rx337_cur."!mark_fail"(0)
    lt rx337_pos, -1, rx337_done
    eq rx337_pos, -1, rx337_fail
    jump $I10
  rx337_done:
    rx337_cur."!cursor_fail"()
    if_null rx337_debug, debug_690
    rx337_cur."!cursor_debug"("FAIL", "xblock")
  debug_690:
    .return (rx337_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1304277427.017") :method
.annotate 'line', 10
    $P339 = self."!PREFIX__!subrule"("EXPR", "")
    new $P340, "ResizablePMCArray"
    push $P340, $P339
    .return ($P340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx343_tgt
    .local int rx343_pos
    .local int rx343_off
    .local int rx343_eos
    .local int rx343_rep
    .local pmc rx343_cur
    .local pmc rx343_debug
    (rx343_cur, rx343_pos, rx343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx343_cur
    .local pmc match
    .lex "$/", match
    length rx343_eos, rx343_tgt
    gt rx343_pos, rx343_eos, rx343_done
    set rx343_off, 0
    lt rx343_pos, 2, rx343_start
    sub rx343_off, rx343_pos, 1
    substr rx343_tgt, rx343_tgt, rx343_off
  rx343_start:
    eq $I10, 1, rx343_restart
    if_null rx343_debug, debug_691
    rx343_cur."!cursor_debug"("START", "pblock")
  debug_691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx343_pos) = rx343_cur."from"()
    inc rx343_pos
    rx343_cur."!cursor_from"(rx343_pos)
    ge rx343_pos, rx343_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  rxscan348_done:
  alt349_0:
.annotate 'line', 154
    set_addr $I10, alt349_1
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
.annotate 'line', 155
  # rx subrule "lambda" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."lambda"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "newpad" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."newpad"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "signature" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."signature"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx343_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "blockoid" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."blockoid"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx343_pos = $P10."pos"()
.annotate 'line', 155
    goto alt349_end
  alt349_1:
    set_addr $I10, alt349_2
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
.annotate 'line', 159
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx343_pos, rx343_off
    substr $S10, rx343_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx343_fail
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."newpad"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "blockoid" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."blockoid"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx343_pos = $P10."pos"()
.annotate 'line', 159
    goto alt349_end
  alt349_2:
.annotate 'line', 162
  # rx subrule "panic" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."panic"("Missing block")
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  alt349_end:
.annotate 'line', 154
  # rx pass
    rx343_cur."!cursor_pass"(rx343_pos, "pblock")
    if_null rx343_debug, debug_692
    rx343_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx343_pos)
  debug_692:
    .return (rx343_cur)
  rx343_restart:
.annotate 'line', 10
    if_null rx343_debug, debug_693
    rx343_cur."!cursor_debug"("NEXT", "pblock")
  debug_693:
  rx343_fail:
    (rx343_rep, rx343_pos, $I10, $P10) = rx343_cur."!mark_fail"(0)
    lt rx343_pos, -1, rx343_done
    eq rx343_pos, -1, rx343_fail
    jump $I10
  rx343_done:
    rx343_cur."!cursor_fail"()
    if_null rx343_debug, debug_694
    rx343_cur."!cursor_debug"("FAIL", "pblock")
  debug_694:
    .return (rx343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1304277427.017") :method
.annotate 'line', 10
    $P345 = self."!PREFIX__!subrule"("panic", "")
    $P346 = self."!PREFIX__!subrule"("lambda", "")
    new $P347, "ResizablePMCArray"
    push $P347, $P345
    push $P347, "{"
    push $P347, $P346
    .return ($P347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx351_tgt
    .local int rx351_pos
    .local int rx351_off
    .local int rx351_eos
    .local int rx351_rep
    .local pmc rx351_cur
    .local pmc rx351_debug
    (rx351_cur, rx351_pos, rx351_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx351_cur
    .local pmc match
    .lex "$/", match
    length rx351_eos, rx351_tgt
    gt rx351_pos, rx351_eos, rx351_done
    set rx351_off, 0
    lt rx351_pos, 2, rx351_start
    sub rx351_off, rx351_pos, 1
    substr rx351_tgt, rx351_tgt, rx351_off
  rx351_start:
    eq $I10, 1, rx351_restart
    if_null rx351_debug, debug_695
    rx351_cur."!cursor_debug"("START", "lambda")
  debug_695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan354_done
    goto rxscan354_scan
  rxscan354_loop:
    (rx351_pos) = rx351_cur."from"()
    inc rx351_pos
    rx351_cur."!cursor_from"(rx351_pos)
    ge rx351_pos, rx351_eos, rxscan354_done
  rxscan354_scan:
    set_addr $I10, rxscan354_loop
    rx351_cur."!mark_push"(0, rx351_pos, $I10)
  rxscan354_done:
  alt355_0:
.annotate 'line', 165
    set_addr $I10, alt355_1
    rx351_cur."!mark_push"(0, rx351_pos, $I10)
  # rx literal  "->"
    add $I11, rx351_pos, 2
    gt $I11, rx351_eos, rx351_fail
    sub $I11, rx351_pos, rx351_off
    substr $S10, rx351_tgt, $I11, 2
    ne $S10, "->", rx351_fail
    add rx351_pos, 2
    goto alt355_end
  alt355_1:
  # rx literal  "<->"
    add $I11, rx351_pos, 3
    gt $I11, rx351_eos, rx351_fail
    sub $I11, rx351_pos, rx351_off
    substr $S10, rx351_tgt, $I11, 3
    ne $S10, "<->", rx351_fail
    add rx351_pos, 3
  alt355_end:
  # rx pass
    rx351_cur."!cursor_pass"(rx351_pos, "lambda")
    if_null rx351_debug, debug_696
    rx351_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx351_pos)
  debug_696:
    .return (rx351_cur)
  rx351_restart:
.annotate 'line', 10
    if_null rx351_debug, debug_697
    rx351_cur."!cursor_debug"("NEXT", "lambda")
  debug_697:
  rx351_fail:
    (rx351_rep, rx351_pos, $I10, $P10) = rx351_cur."!mark_fail"(0)
    lt rx351_pos, -1, rx351_done
    eq rx351_pos, -1, rx351_fail
    jump $I10
  rx351_done:
    rx351_cur."!cursor_fail"()
    if_null rx351_debug, debug_698
    rx351_cur."!cursor_debug"("FAIL", "lambda")
  debug_698:
    .return (rx351_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1304277427.017") :method
.annotate 'line', 10
    new $P353, "ResizablePMCArray"
    push $P353, "<->"
    push $P353, "->"
    .return ($P353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx357_tgt
    .local int rx357_pos
    .local int rx357_off
    .local int rx357_eos
    .local int rx357_rep
    .local pmc rx357_cur
    .local pmc rx357_debug
    (rx357_cur, rx357_pos, rx357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx357_cur
    .local pmc match
    .lex "$/", match
    length rx357_eos, rx357_tgt
    gt rx357_pos, rx357_eos, rx357_done
    set rx357_off, 0
    lt rx357_pos, 2, rx357_start
    sub rx357_off, rx357_pos, 1
    substr rx357_tgt, rx357_tgt, rx357_off
  rx357_start:
    eq $I10, 1, rx357_restart
    if_null rx357_debug, debug_699
    rx357_cur."!cursor_debug"("START", "block")
  debug_699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan361_done
    goto rxscan361_scan
  rxscan361_loop:
    (rx357_pos) = rx357_cur."from"()
    inc rx357_pos
    rx357_cur."!cursor_from"(rx357_pos)
    ge rx357_pos, rx357_eos, rxscan361_done
  rxscan361_scan:
    set_addr $I10, rxscan361_loop
    rx357_cur."!mark_push"(0, rx357_pos, $I10)
  rxscan361_done:
  alt362_0:
.annotate 'line', 168
    set_addr $I10, alt362_1
    rx357_cur."!mark_push"(0, rx357_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx357_pos, rx357_off
    substr $S10, rx357_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx357_fail
    goto alt362_end
  alt362_1:
  # rx subrule "panic" subtype=method negate=
    rx357_cur."!cursor_pos"(rx357_pos)
    $P10 = rx357_cur."panic"("Missing block")
    unless $P10, rx357_fail
    rx357_pos = $P10."pos"()
  alt362_end:
.annotate 'line', 169
  # rx subrule "newpad" subtype=method negate=
    rx357_cur."!cursor_pos"(rx357_pos)
    $P10 = rx357_cur."newpad"()
    unless $P10, rx357_fail
    rx357_pos = $P10."pos"()
.annotate 'line', 170
  # rx subrule "blockoid" subtype=capture negate=
    rx357_cur."!cursor_pos"(rx357_pos)
    $P10 = rx357_cur."blockoid"()
    unless $P10, rx357_fail
    rx357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx357_pos = $P10."pos"()
.annotate 'line', 167
  # rx pass
    rx357_cur."!cursor_pass"(rx357_pos, "block")
    if_null rx357_debug, debug_700
    rx357_cur."!cursor_debug"("PASS", "block", " at pos=", rx357_pos)
  debug_700:
    .return (rx357_cur)
  rx357_restart:
.annotate 'line', 10
    if_null rx357_debug, debug_701
    rx357_cur."!cursor_debug"("NEXT", "block")
  debug_701:
  rx357_fail:
    (rx357_rep, rx357_pos, $I10, $P10) = rx357_cur."!mark_fail"(0)
    lt rx357_pos, -1, rx357_done
    eq rx357_pos, -1, rx357_fail
    jump $I10
  rx357_done:
    rx357_cur."!cursor_fail"()
    if_null rx357_debug, debug_702
    rx357_cur."!cursor_debug"("FAIL", "block")
  debug_702:
    .return (rx357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1304277427.017") :method
.annotate 'line', 10
    $P359 = self."!PREFIX__!subrule"("panic", "")
    new $P360, "ResizablePMCArray"
    push $P360, $P359
    push $P360, "{"
    .return ($P360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx364_tgt
    .local int rx364_pos
    .local int rx364_off
    .local int rx364_eos
    .local int rx364_rep
    .local pmc rx364_cur
    .local pmc rx364_debug
    (rx364_cur, rx364_pos, rx364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx364_cur
    .local pmc match
    .lex "$/", match
    length rx364_eos, rx364_tgt
    gt rx364_pos, rx364_eos, rx364_done
    set rx364_off, 0
    lt rx364_pos, 2, rx364_start
    sub rx364_off, rx364_pos, 1
    substr rx364_tgt, rx364_tgt, rx364_off
  rx364_start:
    eq $I10, 1, rx364_restart
    if_null rx364_debug, debug_703
    rx364_cur."!cursor_debug"("START", "blockoid")
  debug_703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan368_done
    goto rxscan368_scan
  rxscan368_loop:
    (rx364_pos) = rx364_cur."from"()
    inc rx364_pos
    rx364_cur."!cursor_from"(rx364_pos)
    ge rx364_pos, rx364_eos, rxscan368_done
  rxscan368_scan:
    set_addr $I10, rxscan368_loop
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  rxscan368_done:
.annotate 'line', 174
  # rx subrule "finishpad" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."finishpad"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  alt369_0:
.annotate 'line', 175
    set_addr $I10, alt369_1
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
.annotate 'line', 176
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx364_pos, 14
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    substr $S10, rx364_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx364_fail
    add rx364_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."you_are_here"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx364_pos = $P10."pos"()
    goto alt369_end
  alt369_1:
.annotate 'line', 177
  # rx literal  "{"
    add $I11, rx364_pos, 1
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    ord $I11, rx364_tgt, $I11
    ne $I11, 123, rx364_fail
    add rx364_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."statementlist"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx364_pos = $P10."pos"()
  alt370_0:
    set_addr $I10, alt370_1
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx literal  "}"
    add $I11, rx364_pos, 1
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    ord $I11, rx364_tgt, $I11
    ne $I11, 125, rx364_fail
    add rx364_pos, 1
    goto alt370_end
  alt370_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."FAILGOAL"("'}'")
    unless $P10, rx364_fail
    goto rxsubrule372_pass
  rxsubrule372_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx364_fail
  rxsubrule372_pass:
    set_addr $I10, rxsubrule372_back
    rx364_cur."!mark_push"(0, rx364_pos, $I10, $P10)
    rx364_pos = $P10."pos"()
  alt370_end:
  alt369_end:
.annotate 'line', 179
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ENDSTMT"()
    unless $P10, rx364_fail
.annotate 'line', 173
  # rx pass
    rx364_cur."!cursor_pass"(rx364_pos, "blockoid")
    if_null rx364_debug, debug_704
    rx364_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx364_pos)
  debug_704:
    .return (rx364_cur)
  rx364_restart:
.annotate 'line', 10
    if_null rx364_debug, debug_705
    rx364_cur."!cursor_debug"("NEXT", "blockoid")
  debug_705:
  rx364_fail:
    (rx364_rep, rx364_pos, $I10, $P10) = rx364_cur."!mark_fail"(0)
    lt rx364_pos, -1, rx364_done
    eq rx364_pos, -1, rx364_fail
    jump $I10
  rx364_done:
    rx364_cur."!cursor_fail"()
    if_null rx364_debug, debug_706
    rx364_cur."!cursor_debug"("FAIL", "blockoid")
  debug_706:
    .return (rx364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1304277427.017") :method
.annotate 'line', 10
    $P366 = self."!PREFIX__!subrule"("finishpad", "")
    new $P367, "ResizablePMCArray"
    push $P367, $P366
    .return ($P367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx374_tgt
    .local int rx374_pos
    .local int rx374_off
    .local int rx374_eos
    .local int rx374_rep
    .local pmc rx374_cur
    .local pmc rx374_debug
    (rx374_cur, rx374_pos, rx374_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx374_cur
    .local pmc match
    .lex "$/", match
    length rx374_eos, rx374_tgt
    gt rx374_pos, rx374_eos, rx374_done
    set rx374_off, 0
    lt rx374_pos, 2, rx374_start
    sub rx374_off, rx374_pos, 1
    substr rx374_tgt, rx374_tgt, rx374_off
  rx374_start:
    eq $I10, 1, rx374_restart
    if_null rx374_debug, debug_707
    rx374_cur."!cursor_debug"("START", "newpad")
  debug_707:
    $I10 = self.'from'()
    ne $I10, -1, rxscan377_done
    goto rxscan377_scan
  rxscan377_loop:
    (rx374_pos) = rx374_cur."from"()
    inc rx374_pos
    rx374_cur."!cursor_from"(rx374_pos)
    ge rx374_pos, rx374_eos, rxscan377_done
  rxscan377_scan:
    set_addr $I10, rxscan377_loop
    rx374_cur."!mark_push"(0, rx374_pos, $I10)
  rxscan377_done:
.annotate 'line', 182
  # rx pass
    rx374_cur."!cursor_pass"(rx374_pos, "newpad")
    if_null rx374_debug, debug_708
    rx374_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx374_pos)
  debug_708:
    .return (rx374_cur)
  rx374_restart:
.annotate 'line', 10
    if_null rx374_debug, debug_709
    rx374_cur."!cursor_debug"("NEXT", "newpad")
  debug_709:
  rx374_fail:
    (rx374_rep, rx374_pos, $I10, $P10) = rx374_cur."!mark_fail"(0)
    lt rx374_pos, -1, rx374_done
    eq rx374_pos, -1, rx374_fail
    jump $I10
  rx374_done:
    rx374_cur."!cursor_fail"()
    if_null rx374_debug, debug_710
    rx374_cur."!cursor_debug"("FAIL", "newpad")
  debug_710:
    .return (rx374_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1304277427.017") :method
.annotate 'line', 10
    new $P376, "ResizablePMCArray"
    push $P376, ""
    .return ($P376)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx379_tgt
    .local int rx379_pos
    .local int rx379_off
    .local int rx379_eos
    .local int rx379_rep
    .local pmc rx379_cur
    .local pmc rx379_debug
    (rx379_cur, rx379_pos, rx379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx379_cur
    .local pmc match
    .lex "$/", match
    length rx379_eos, rx379_tgt
    gt rx379_pos, rx379_eos, rx379_done
    set rx379_off, 0
    lt rx379_pos, 2, rx379_start
    sub rx379_off, rx379_pos, 1
    substr rx379_tgt, rx379_tgt, rx379_off
  rx379_start:
    eq $I10, 1, rx379_restart
    if_null rx379_debug, debug_711
    rx379_cur."!cursor_debug"("START", "outerctx")
  debug_711:
    $I10 = self.'from'()
    ne $I10, -1, rxscan382_done
    goto rxscan382_scan
  rxscan382_loop:
    (rx379_pos) = rx379_cur."from"()
    inc rx379_pos
    rx379_cur."!cursor_from"(rx379_pos)
    ge rx379_pos, rx379_eos, rxscan382_done
  rxscan382_scan:
    set_addr $I10, rxscan382_loop
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  rxscan382_done:
.annotate 'line', 183
  # rx pass
    rx379_cur."!cursor_pass"(rx379_pos, "outerctx")
    if_null rx379_debug, debug_712
    rx379_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx379_pos)
  debug_712:
    .return (rx379_cur)
  rx379_restart:
.annotate 'line', 10
    if_null rx379_debug, debug_713
    rx379_cur."!cursor_debug"("NEXT", "outerctx")
  debug_713:
  rx379_fail:
    (rx379_rep, rx379_pos, $I10, $P10) = rx379_cur."!mark_fail"(0)
    lt rx379_pos, -1, rx379_done
    eq rx379_pos, -1, rx379_fail
    jump $I10
  rx379_done:
    rx379_cur."!cursor_fail"()
    if_null rx379_debug, debug_714
    rx379_cur."!cursor_debug"("FAIL", "outerctx")
  debug_714:
    .return (rx379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1304277427.017") :method
.annotate 'line', 10
    new $P381, "ResizablePMCArray"
    push $P381, ""
    .return ($P381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx384_tgt
    .local int rx384_pos
    .local int rx384_off
    .local int rx384_eos
    .local int rx384_rep
    .local pmc rx384_cur
    .local pmc rx384_debug
    (rx384_cur, rx384_pos, rx384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx384_cur
    .local pmc match
    .lex "$/", match
    length rx384_eos, rx384_tgt
    gt rx384_pos, rx384_eos, rx384_done
    set rx384_off, 0
    lt rx384_pos, 2, rx384_start
    sub rx384_off, rx384_pos, 1
    substr rx384_tgt, rx384_tgt, rx384_off
  rx384_start:
    eq $I10, 1, rx384_restart
    if_null rx384_debug, debug_715
    rx384_cur."!cursor_debug"("START", "GLOBALish")
  debug_715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan387_done
    goto rxscan387_scan
  rxscan387_loop:
    (rx384_pos) = rx384_cur."from"()
    inc rx384_pos
    rx384_cur."!cursor_from"(rx384_pos)
    ge rx384_pos, rx384_eos, rxscan387_done
  rxscan387_scan:
    set_addr $I10, rxscan387_loop
    rx384_cur."!mark_push"(0, rx384_pos, $I10)
  rxscan387_done:
.annotate 'line', 184
  # rx pass
    rx384_cur."!cursor_pass"(rx384_pos, "GLOBALish")
    if_null rx384_debug, debug_716
    rx384_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx384_pos)
  debug_716:
    .return (rx384_cur)
  rx384_restart:
.annotate 'line', 10
    if_null rx384_debug, debug_717
    rx384_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_717:
  rx384_fail:
    (rx384_rep, rx384_pos, $I10, $P10) = rx384_cur."!mark_fail"(0)
    lt rx384_pos, -1, rx384_done
    eq rx384_pos, -1, rx384_fail
    jump $I10
  rx384_done:
    rx384_cur."!cursor_fail"()
    if_null rx384_debug, debug_718
    rx384_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_718:
    .return (rx384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1304277427.017") :method
.annotate 'line', 10
    new $P386, "ResizablePMCArray"
    push $P386, ""
    .return ($P386)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx389_tgt
    .local int rx389_pos
    .local int rx389_off
    .local int rx389_eos
    .local int rx389_rep
    .local pmc rx389_cur
    .local pmc rx389_debug
    (rx389_cur, rx389_pos, rx389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx389_cur
    .local pmc match
    .lex "$/", match
    length rx389_eos, rx389_tgt
    gt rx389_pos, rx389_eos, rx389_done
    set rx389_off, 0
    lt rx389_pos, 2, rx389_start
    sub rx389_off, rx389_pos, 1
    substr rx389_tgt, rx389_tgt, rx389_off
  rx389_start:
    eq $I10, 1, rx389_restart
    if_null rx389_debug, debug_719
    rx389_cur."!cursor_debug"("START", "finishpad")
  debug_719:
    $I10 = self.'from'()
    ne $I10, -1, rxscan392_done
    goto rxscan392_scan
  rxscan392_loop:
    (rx389_pos) = rx389_cur."from"()
    inc rx389_pos
    rx389_cur."!cursor_from"(rx389_pos)
    ge rx389_pos, rx389_eos, rxscan392_done
  rxscan392_scan:
    set_addr $I10, rxscan392_loop
    rx389_cur."!mark_push"(0, rx389_pos, $I10)
  rxscan392_done:
.annotate 'line', 185
  # rx pass
    rx389_cur."!cursor_pass"(rx389_pos, "finishpad")
    if_null rx389_debug, debug_720
    rx389_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx389_pos)
  debug_720:
    .return (rx389_cur)
  rx389_restart:
.annotate 'line', 10
    if_null rx389_debug, debug_721
    rx389_cur."!cursor_debug"("NEXT", "finishpad")
  debug_721:
  rx389_fail:
    (rx389_rep, rx389_pos, $I10, $P10) = rx389_cur."!mark_fail"(0)
    lt rx389_pos, -1, rx389_done
    eq rx389_pos, -1, rx389_fail
    jump $I10
  rx389_done:
    rx389_cur."!cursor_fail"()
    if_null rx389_debug, debug_722
    rx389_cur."!cursor_debug"("FAIL", "finishpad")
  debug_722:
    .return (rx389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1304277427.017") :method
.annotate 'line', 10
    new $P391, "ResizablePMCArray"
    push $P391, ""
    .return ($P391)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx394_tgt
    .local int rx394_pos
    .local int rx394_off
    .local int rx394_eos
    .local int rx394_rep
    .local pmc rx394_cur
    .local pmc rx394_debug
    (rx394_cur, rx394_pos, rx394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx394_cur
    .local pmc match
    .lex "$/", match
    length rx394_eos, rx394_tgt
    gt rx394_pos, rx394_eos, rx394_done
    set rx394_off, 0
    lt rx394_pos, 2, rx394_start
    sub rx394_off, rx394_pos, 1
    substr rx394_tgt, rx394_tgt, rx394_off
  rx394_start:
    eq $I10, 1, rx394_restart
    if_null rx394_debug, debug_723
    rx394_cur."!cursor_debug"("START", "you_are_here")
  debug_723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan397_done
    goto rxscan397_scan
  rxscan397_loop:
    (rx394_pos) = rx394_cur."from"()
    inc rx394_pos
    rx394_cur."!cursor_from"(rx394_pos)
    ge rx394_pos, rx394_eos, rxscan397_done
  rxscan397_scan:
    set_addr $I10, rxscan397_loop
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  rxscan397_done:
.annotate 'line', 186
  # rx pass
    rx394_cur."!cursor_pass"(rx394_pos, "you_are_here")
    if_null rx394_debug, debug_724
    rx394_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx394_pos)
  debug_724:
    .return (rx394_cur)
  rx394_restart:
.annotate 'line', 10
    if_null rx394_debug, debug_725
    rx394_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_725:
  rx394_fail:
    (rx394_rep, rx394_pos, $I10, $P10) = rx394_cur."!mark_fail"(0)
    lt rx394_pos, -1, rx394_done
    eq rx394_pos, -1, rx394_fail
    jump $I10
  rx394_done:
    rx394_cur."!cursor_fail"()
    if_null rx394_debug, debug_726
    rx394_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_726:
    .return (rx394_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1304277427.017") :method
.annotate 'line', 10
    new $P396, "ResizablePMCArray"
    push $P396, ""
    .return ($P396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1304277427.017")
    .param pmc param_399
.annotate 'line', 188
    .lex "self", param_399
    $P400 = param_399."!protoregex"("terminator")
    .return ($P400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1304277427.017")
    .param pmc param_402
.annotate 'line', 188
    .lex "self", param_402
    $P403 = param_402."!PREFIX__!protoregex"("terminator")
    .return ($P403)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx405_tgt
    .local int rx405_pos
    .local int rx405_off
    .local int rx405_eos
    .local int rx405_rep
    .local pmc rx405_cur
    .local pmc rx405_debug
    (rx405_cur, rx405_pos, rx405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx405_cur
    .local pmc match
    .lex "$/", match
    length rx405_eos, rx405_tgt
    gt rx405_pos, rx405_eos, rx405_done
    set rx405_off, 0
    lt rx405_pos, 2, rx405_start
    sub rx405_off, rx405_pos, 1
    substr rx405_tgt, rx405_tgt, rx405_off
  rx405_start:
    eq $I10, 1, rx405_restart
    if_null rx405_debug, debug_727
    rx405_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_727:
    $I10 = self.'from'()
    ne $I10, -1, rxscan408_done
    goto rxscan408_scan
  rxscan408_loop:
    (rx405_pos) = rx405_cur."from"()
    inc rx405_pos
    rx405_cur."!cursor_from"(rx405_pos)
    ge rx405_pos, rx405_eos, rxscan408_done
  rxscan408_scan:
    set_addr $I10, rxscan408_loop
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  rxscan408_done:
.annotate 'line', 190
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx405_pos, rx405_off
    substr $S10, rx405_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx405_fail
  # rx pass
    rx405_cur."!cursor_pass"(rx405_pos, "terminator:sym<;>")
    if_null rx405_debug, debug_728
    rx405_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx405_pos)
  debug_728:
    .return (rx405_cur)
  rx405_restart:
.annotate 'line', 10
    if_null rx405_debug, debug_729
    rx405_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_729:
  rx405_fail:
    (rx405_rep, rx405_pos, $I10, $P10) = rx405_cur."!mark_fail"(0)
    lt rx405_pos, -1, rx405_done
    eq rx405_pos, -1, rx405_fail
    jump $I10
  rx405_done:
    rx405_cur."!cursor_fail"()
    if_null rx405_debug, debug_730
    rx405_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_730:
    .return (rx405_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1304277427.017") :method
.annotate 'line', 10
    new $P407, "ResizablePMCArray"
    push $P407, ";"
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx410_tgt
    .local int rx410_pos
    .local int rx410_off
    .local int rx410_eos
    .local int rx410_rep
    .local pmc rx410_cur
    .local pmc rx410_debug
    (rx410_cur, rx410_pos, rx410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx410_cur
    .local pmc match
    .lex "$/", match
    length rx410_eos, rx410_tgt
    gt rx410_pos, rx410_eos, rx410_done
    set rx410_off, 0
    lt rx410_pos, 2, rx410_start
    sub rx410_off, rx410_pos, 1
    substr rx410_tgt, rx410_tgt, rx410_off
  rx410_start:
    eq $I10, 1, rx410_restart
    if_null rx410_debug, debug_731
    rx410_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_731:
    $I10 = self.'from'()
    ne $I10, -1, rxscan413_done
    goto rxscan413_scan
  rxscan413_loop:
    (rx410_pos) = rx410_cur."from"()
    inc rx410_pos
    rx410_cur."!cursor_from"(rx410_pos)
    ge rx410_pos, rx410_eos, rxscan413_done
  rxscan413_scan:
    set_addr $I10, rxscan413_loop
    rx410_cur."!mark_push"(0, rx410_pos, $I10)
  rxscan413_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx410_pos, rx410_off
    substr $S10, rx410_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx410_fail
  # rx pass
    rx410_cur."!cursor_pass"(rx410_pos, "terminator:sym<}>")
    if_null rx410_debug, debug_732
    rx410_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx410_pos)
  debug_732:
    .return (rx410_cur)
  rx410_restart:
.annotate 'line', 10
    if_null rx410_debug, debug_733
    rx410_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_733:
  rx410_fail:
    (rx410_rep, rx410_pos, $I10, $P10) = rx410_cur."!mark_fail"(0)
    lt rx410_pos, -1, rx410_done
    eq rx410_pos, -1, rx410_fail
    jump $I10
  rx410_done:
    rx410_cur."!cursor_fail"()
    if_null rx410_debug, debug_734
    rx410_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_734:
    .return (rx410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1304277427.017") :method
.annotate 'line', 10
    new $P412, "ResizablePMCArray"
    push $P412, "}"
    .return ($P412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1304277427.017")
    .param pmc param_415
.annotate 'line', 195
    .lex "self", param_415
    $P416 = param_415."!protoregex"("statement_control")
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1304277427.017")
    .param pmc param_418
.annotate 'line', 195
    .lex "self", param_418
    $P419 = param_418."!PREFIX__!protoregex"("statement_control")
    .return ($P419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx421_tgt
    .local int rx421_pos
    .local int rx421_off
    .local int rx421_eos
    .local int rx421_rep
    .local pmc rx421_cur
    .local pmc rx421_debug
    (rx421_cur, rx421_pos, rx421_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx421_cur
    .local pmc match
    .lex "$/", match
    length rx421_eos, rx421_tgt
    gt rx421_pos, rx421_eos, rx421_done
    set rx421_off, 0
    lt rx421_pos, 2, rx421_start
    sub rx421_off, rx421_pos, 1
    substr rx421_tgt, rx421_tgt, rx421_off
  rx421_start:
    eq $I10, 1, rx421_restart
    if_null rx421_debug, debug_735
    rx421_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_735:
    $I10 = self.'from'()
    ne $I10, -1, rxscan424_done
    goto rxscan424_scan
  rxscan424_loop:
    (rx421_pos) = rx421_cur."from"()
    inc rx421_pos
    rx421_cur."!cursor_from"(rx421_pos)
    ge rx421_pos, rx421_eos, rxscan424_done
  rxscan424_scan:
    set_addr $I10, rxscan424_loop
    rx421_cur."!mark_push"(0, rx421_pos, $I10)
  rxscan424_done:
.annotate 'line', 198
  # rx subcapture "sym"
    set_addr $I10, rxcap_425_fail
    rx421_cur."!mark_push"(0, rx421_pos, $I10)
  # rx literal  "use"
    add $I11, rx421_pos, 3
    gt $I11, rx421_eos, rx421_fail
    sub $I11, rx421_pos, rx421_off
    substr $S10, rx421_tgt, $I11, 3
    ne $S10, "use", rx421_fail
    add rx421_pos, 3
    set_addr $I10, rxcap_425_fail
    ($I12, $I11) = rx421_cur."!mark_peek"($I10)
    rx421_cur."!cursor_pos"($I11)
    ($P10) = rx421_cur."!cursor_start"()
    $P10."!cursor_pass"(rx421_pos, "")
    rx421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_425_done
  rxcap_425_fail:
    goto rx421_fail
  rxcap_425_done:
  # rx charclass s
    ge rx421_pos, rx421_eos, rx421_fail
    sub $I10, rx421_pos, rx421_off
    is_cclass $I11, 32, rx421_tgt, $I10
    unless $I11, rx421_fail
    inc rx421_pos
  # rx subrule "ws" subtype=method negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."ws"()
    unless $P10, rx421_fail
    rx421_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."name"()
    unless $P10, rx421_fail
    rx421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx421_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."ws"()
    unless $P10, rx421_fail
    rx421_pos = $P10."pos"()
.annotate 'line', 197
  # rx pass
    rx421_cur."!cursor_pass"(rx421_pos, "statement_control:sym<use>")
    if_null rx421_debug, debug_736
    rx421_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx421_pos)
  debug_736:
    .return (rx421_cur)
  rx421_restart:
.annotate 'line', 10
    if_null rx421_debug, debug_737
    rx421_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_737:
  rx421_fail:
    (rx421_rep, rx421_pos, $I10, $P10) = rx421_cur."!mark_fail"(0)
    lt rx421_pos, -1, rx421_done
    eq rx421_pos, -1, rx421_fail
    jump $I10
  rx421_done:
    rx421_cur."!cursor_fail"()
    if_null rx421_debug, debug_738
    rx421_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_738:
    .return (rx421_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1304277427.017") :method
.annotate 'line', 10
    new $P423, "ResizablePMCArray"
    push $P423, "use"
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx429_tgt
    .local int rx429_pos
    .local int rx429_off
    .local int rx429_eos
    .local int rx429_rep
    .local pmc rx429_cur
    .local pmc rx429_debug
    (rx429_cur, rx429_pos, rx429_tgt, $I10) = self."!cursor_start"()
    rx429_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx429_cur
    .local pmc match
    .lex "$/", match
    length rx429_eos, rx429_tgt
    gt rx429_pos, rx429_eos, rx429_done
    set rx429_off, 0
    lt rx429_pos, 2, rx429_start
    sub rx429_off, rx429_pos, 1
    substr rx429_tgt, rx429_tgt, rx429_off
  rx429_start:
    eq $I10, 1, rx429_restart
    if_null rx429_debug, debug_739
    rx429_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_739:
    $I10 = self.'from'()
    ne $I10, -1, rxscan432_done
    goto rxscan432_scan
  rxscan432_loop:
    (rx429_pos) = rx429_cur."from"()
    inc rx429_pos
    rx429_cur."!cursor_from"(rx429_pos)
    ge rx429_pos, rx429_eos, rxscan432_done
  rxscan432_scan:
    set_addr $I10, rxscan432_loop
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxscan432_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_433_fail
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  # rx literal  "if"
    add $I11, rx429_pos, 2
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 2
    ne $S10, "if", rx429_fail
    add rx429_pos, 2
    set_addr $I10, rxcap_433_fail
    ($I12, $I11) = rx429_cur."!mark_peek"($I10)
    rx429_cur."!cursor_pos"($I11)
    ($P10) = rx429_cur."!cursor_start"()
    $P10."!cursor_pass"(rx429_pos, "")
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_433_done
  rxcap_433_fail:
    goto rx429_fail
  rxcap_433_done:
  # rx charclass s
    ge rx429_pos, rx429_eos, rx429_fail
    sub $I10, rx429_pos, rx429_off
    is_cclass $I11, 32, rx429_tgt, $I10
    unless $I11, rx429_fail
    inc rx429_pos
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."xblock"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx429_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 204
  # rx rxquantr436 ** 0..*
    set_addr $I10, rxquantr436_done
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxquantr436_loop:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx429_pos, 5
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 5
    ne $S10, "elsif", rx429_fail
    add rx429_pos, 5
  # rx charclass s
    ge rx429_pos, rx429_eos, rx429_fail
    sub $I10, rx429_pos, rx429_off
    is_cclass $I11, 32, rx429_tgt, $I10
    unless $I11, rx429_fail
    inc rx429_pos
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."xblock"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx429_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
    set_addr $I10, rxquantr436_done
    (rx429_rep) = rx429_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr436_done
    rx429_cur."!mark_push"(rx429_rep, rx429_pos, $I10)
    goto rxquantr436_loop
  rxquantr436_done:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr441 ** 0..1
    set_addr $I10, rxquantr441_done
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxquantr441_loop:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx429_pos, 4
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 4
    ne $S10, "else", rx429_fail
    add rx429_pos, 4
  # rx charclass s
    ge rx429_pos, rx429_eos, rx429_fail
    sub $I10, rx429_pos, rx429_off
    is_cclass $I11, 32, rx429_tgt, $I10
    unless $I11, rx429_fail
    inc rx429_pos
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."pblock"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx429_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
    set_addr $I10, rxquantr441_done
    (rx429_rep) = rx429_cur."!mark_commit"($I10)
  rxquantr441_done:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx429_cur."!cursor_pass"(rx429_pos, "statement_control:sym<if>")
    if_null rx429_debug, debug_740
    rx429_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx429_pos)
  debug_740:
    .return (rx429_cur)
  rx429_restart:
.annotate 'line', 10
    if_null rx429_debug, debug_741
    rx429_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_741:
  rx429_fail:
    (rx429_rep, rx429_pos, $I10, $P10) = rx429_cur."!mark_fail"(0)
    lt rx429_pos, -1, rx429_done
    eq rx429_pos, -1, rx429_fail
    jump $I10
  rx429_done:
    rx429_cur."!cursor_fail"()
    if_null rx429_debug, debug_742
    rx429_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_742:
    .return (rx429_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1304277427.017") :method
.annotate 'line', 10
    new $P431, "ResizablePMCArray"
    push $P431, "if"
    .return ($P431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P457 = "73_1304277427.017" 
    capture_lex $P457
    .local string rx447_tgt
    .local int rx447_pos
    .local int rx447_off
    .local int rx447_eos
    .local int rx447_rep
    .local pmc rx447_cur
    .local pmc rx447_debug
    (rx447_cur, rx447_pos, rx447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx447_cur
    .local pmc match
    .lex "$/", match
    length rx447_eos, rx447_tgt
    gt rx447_pos, rx447_eos, rx447_done
    set rx447_off, 0
    lt rx447_pos, 2, rx447_start
    sub rx447_off, rx447_pos, 1
    substr rx447_tgt, rx447_tgt, rx447_off
  rx447_start:
    eq $I10, 1, rx447_restart
    if_null rx447_debug, debug_743
    rx447_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_743:
    $I10 = self.'from'()
    ne $I10, -1, rxscan450_done
    goto rxscan450_scan
  rxscan450_loop:
    (rx447_pos) = rx447_cur."from"()
    inc rx447_pos
    rx447_cur."!cursor_from"(rx447_pos)
    ge rx447_pos, rx447_eos, rxscan450_done
  rxscan450_scan:
    set_addr $I10, rxscan450_loop
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  rxscan450_done:
.annotate 'line', 209
  # rx subcapture "sym"
    set_addr $I10, rxcap_451_fail
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  # rx literal  "unless"
    add $I11, rx447_pos, 6
    gt $I11, rx447_eos, rx447_fail
    sub $I11, rx447_pos, rx447_off
    substr $S10, rx447_tgt, $I11, 6
    ne $S10, "unless", rx447_fail
    add rx447_pos, 6
    set_addr $I10, rxcap_451_fail
    ($I12, $I11) = rx447_cur."!mark_peek"($I10)
    rx447_cur."!cursor_pos"($I11)
    ($P10) = rx447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx447_pos, "")
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_451_done
  rxcap_451_fail:
    goto rx447_fail
  rxcap_451_done:
  # rx charclass s
    ge rx447_pos, rx447_eos, rx447_fail
    sub $I10, rx447_pos, rx447_off
    is_cclass $I11, 32, rx447_tgt, $I10
    unless $I11, rx447_fail
    inc rx447_pos
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
.annotate 'line', 210
  # rx subrule "xblock" subtype=capture negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."xblock"()
    unless $P10, rx447_fail
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx447_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  alt454_0:
.annotate 'line', 211
    set_addr $I10, alt454_1
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx447_cur."!cursor_pos"(rx447_pos)
    .const 'Sub' $P457 = "73_1304277427.017" 
    capture_lex $P457
    $P10 = rx447_cur."before"($P457)
    if $P10, rx447_fail
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
    goto alt454_end
  alt454_1:
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  alt454_end:
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
.annotate 'line', 208
  # rx pass
    rx447_cur."!cursor_pass"(rx447_pos, "statement_control:sym<unless>")
    if_null rx447_debug, debug_748
    rx447_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx447_pos)
  debug_748:
    .return (rx447_cur)
  rx447_restart:
.annotate 'line', 10
    if_null rx447_debug, debug_749
    rx447_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_749:
  rx447_fail:
    (rx447_rep, rx447_pos, $I10, $P10) = rx447_cur."!mark_fail"(0)
    lt rx447_pos, -1, rx447_done
    eq rx447_pos, -1, rx447_fail
    jump $I10
  rx447_done:
    rx447_cur."!cursor_fail"()
    if_null rx447_debug, debug_750
    rx447_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_750:
    .return (rx447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1304277427.017") :method
.annotate 'line', 10
    new $P449, "ResizablePMCArray"
    push $P449, "unless"
    .return ($P449)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block456"  :anon :subid("73_1304277427.017") :method :outer("71_1304277427.017")
.annotate 'line', 211
    .local string rx458_tgt
    .local int rx458_pos
    .local int rx458_off
    .local int rx458_eos
    .local int rx458_rep
    .local pmc rx458_cur
    .local pmc rx458_debug
    (rx458_cur, rx458_pos, rx458_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx458_cur
    .local pmc match
    .lex "$/", match
    length rx458_eos, rx458_tgt
    gt rx458_pos, rx458_eos, rx458_done
    set rx458_off, 0
    lt rx458_pos, 2, rx458_start
    sub rx458_off, rx458_pos, 1
    substr rx458_tgt, rx458_tgt, rx458_off
  rx458_start:
    eq $I10, 1, rx458_restart
    if_null rx458_debug, debug_744
    rx458_cur."!cursor_debug"("START", "")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan459_done
    goto rxscan459_scan
  rxscan459_loop:
    (rx458_pos) = rx458_cur."from"()
    inc rx458_pos
    rx458_cur."!cursor_from"(rx458_pos)
    ge rx458_pos, rx458_eos, rxscan459_done
  rxscan459_scan:
    set_addr $I10, rxscan459_loop
    rx458_cur."!mark_push"(0, rx458_pos, $I10)
  rxscan459_done:
  # rx literal  "else"
    add $I11, rx458_pos, 4
    gt $I11, rx458_eos, rx458_fail
    sub $I11, rx458_pos, rx458_off
    substr $S10, rx458_tgt, $I11, 4
    ne $S10, "else", rx458_fail
    add rx458_pos, 4
  # rx pass
    rx458_cur."!cursor_pass"(rx458_pos, "")
    if_null rx458_debug, debug_745
    rx458_cur."!cursor_debug"("PASS", "", " at pos=", rx458_pos)
  debug_745:
    .return (rx458_cur)
  rx458_restart:
    if_null rx458_debug, debug_746
    rx458_cur."!cursor_debug"("NEXT", "")
  debug_746:
  rx458_fail:
    (rx458_rep, rx458_pos, $I10, $P10) = rx458_cur."!mark_fail"(0)
    lt rx458_pos, -1, rx458_done
    eq rx458_pos, -1, rx458_fail
    jump $I10
  rx458_done:
    rx458_cur."!cursor_fail"()
    if_null rx458_debug, debug_747
    rx458_cur."!cursor_debug"("FAIL", "")
  debug_747:
    .return (rx458_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx465_tgt
    .local int rx465_pos
    .local int rx465_off
    .local int rx465_eos
    .local int rx465_rep
    .local pmc rx465_cur
    .local pmc rx465_debug
    (rx465_cur, rx465_pos, rx465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx465_cur
    .local pmc match
    .lex "$/", match
    length rx465_eos, rx465_tgt
    gt rx465_pos, rx465_eos, rx465_done
    set rx465_off, 0
    lt rx465_pos, 2, rx465_start
    sub rx465_off, rx465_pos, 1
    substr rx465_tgt, rx465_tgt, rx465_off
  rx465_start:
    eq $I10, 1, rx465_restart
    if_null rx465_debug, debug_751
    rx465_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_751:
    $I10 = self.'from'()
    ne $I10, -1, rxscan468_done
    goto rxscan468_scan
  rxscan468_loop:
    (rx465_pos) = rx465_cur."from"()
    inc rx465_pos
    rx465_cur."!cursor_from"(rx465_pos)
    ge rx465_pos, rx465_eos, rxscan468_done
  rxscan468_scan:
    set_addr $I10, rxscan468_loop
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  rxscan468_done:
.annotate 'line', 215
  # rx subcapture "sym"
    set_addr $I10, rxcap_470_fail
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  alt469_0:
    set_addr $I10, alt469_1
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  # rx literal  "while"
    add $I11, rx465_pos, 5
    gt $I11, rx465_eos, rx465_fail
    sub $I11, rx465_pos, rx465_off
    substr $S10, rx465_tgt, $I11, 5
    ne $S10, "while", rx465_fail
    add rx465_pos, 5
    goto alt469_end
  alt469_1:
  # rx literal  "until"
    add $I11, rx465_pos, 5
    gt $I11, rx465_eos, rx465_fail
    sub $I11, rx465_pos, rx465_off
    substr $S10, rx465_tgt, $I11, 5
    ne $S10, "until", rx465_fail
    add rx465_pos, 5
  alt469_end:
    set_addr $I10, rxcap_470_fail
    ($I12, $I11) = rx465_cur."!mark_peek"($I10)
    rx465_cur."!cursor_pos"($I11)
    ($P10) = rx465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx465_pos, "")
    rx465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_470_done
  rxcap_470_fail:
    goto rx465_fail
  rxcap_470_done:
  # rx charclass s
    ge rx465_pos, rx465_eos, rx465_fail
    sub $I10, rx465_pos, rx465_off
    is_cclass $I11, 32, rx465_tgt, $I10
    unless $I11, rx465_fail
    inc rx465_pos
  # rx subrule "ws" subtype=method negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."ws"()
    unless $P10, rx465_fail
    rx465_pos = $P10."pos"()
.annotate 'line', 216
  # rx subrule "xblock" subtype=capture negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."xblock"()
    unless $P10, rx465_fail
    rx465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx465_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."ws"()
    unless $P10, rx465_fail
    rx465_pos = $P10."pos"()
.annotate 'line', 214
  # rx pass
    rx465_cur."!cursor_pass"(rx465_pos, "statement_control:sym<while>")
    if_null rx465_debug, debug_752
    rx465_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx465_pos)
  debug_752:
    .return (rx465_cur)
  rx465_restart:
.annotate 'line', 10
    if_null rx465_debug, debug_753
    rx465_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_753:
  rx465_fail:
    (rx465_rep, rx465_pos, $I10, $P10) = rx465_cur."!mark_fail"(0)
    lt rx465_pos, -1, rx465_done
    eq rx465_pos, -1, rx465_fail
    jump $I10
  rx465_done:
    rx465_cur."!cursor_fail"()
    if_null rx465_debug, debug_754
    rx465_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_754:
    .return (rx465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1304277427.017") :method
.annotate 'line', 10
    new $P467, "ResizablePMCArray"
    push $P467, "until"
    push $P467, "while"
    .return ($P467)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx474_tgt
    .local int rx474_pos
    .local int rx474_off
    .local int rx474_eos
    .local int rx474_rep
    .local pmc rx474_cur
    .local pmc rx474_debug
    (rx474_cur, rx474_pos, rx474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx474_cur
    .local pmc match
    .lex "$/", match
    length rx474_eos, rx474_tgt
    gt rx474_pos, rx474_eos, rx474_done
    set rx474_off, 0
    lt rx474_pos, 2, rx474_start
    sub rx474_off, rx474_pos, 1
    substr rx474_tgt, rx474_tgt, rx474_off
  rx474_start:
    eq $I10, 1, rx474_restart
    if_null rx474_debug, debug_755
    rx474_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_755:
    $I10 = self.'from'()
    ne $I10, -1, rxscan477_done
    goto rxscan477_scan
  rxscan477_loop:
    (rx474_pos) = rx474_cur."from"()
    inc rx474_pos
    rx474_cur."!cursor_from"(rx474_pos)
    ge rx474_pos, rx474_eos, rxscan477_done
  rxscan477_scan:
    set_addr $I10, rxscan477_loop
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  rxscan477_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_478_fail
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx474_pos, 6
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 6
    ne $S10, "repeat", rx474_fail
    add rx474_pos, 6
    set_addr $I10, rxcap_478_fail
    ($I12, $I11) = rx474_cur."!mark_peek"($I10)
    rx474_cur."!cursor_pos"($I11)
    ($P10) = rx474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx474_pos, "")
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_478_done
  rxcap_478_fail:
    goto rx474_fail
  rxcap_478_done:
  # rx charclass s
    ge rx474_pos, rx474_eos, rx474_fail
    sub $I10, rx474_pos, rx474_off
    is_cclass $I11, 32, rx474_tgt, $I10
    unless $I11, rx474_fail
    inc rx474_pos
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  alt480_0:
.annotate 'line', 221
    set_addr $I10, alt480_1
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_483_fail
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  alt482_0:
    set_addr $I10, alt482_1
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "while"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "while", rx474_fail
    add rx474_pos, 5
    goto alt482_end
  alt482_1:
  # rx literal  "until"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "until", rx474_fail
    add rx474_pos, 5
  alt482_end:
    set_addr $I10, rxcap_483_fail
    ($I12, $I11) = rx474_cur."!mark_peek"($I10)
    rx474_cur."!cursor_pos"($I11)
    ($P10) = rx474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx474_pos, "")
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_483_done
  rxcap_483_fail:
    goto rx474_fail
  rxcap_483_done:
  # rx charclass s
    ge rx474_pos, rx474_eos, rx474_fail
    sub $I10, rx474_pos, rx474_off
    is_cclass $I11, 32, rx474_tgt, $I10
    unless $I11, rx474_fail
    inc rx474_pos
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."xblock"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx474_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
    goto alt480_end
  alt480_1:
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."pblock"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx474_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_489_fail
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  alt488_0:
    set_addr $I10, alt488_1
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "while"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "while", rx474_fail
    add rx474_pos, 5
    goto alt488_end
  alt488_1:
  # rx literal  "until"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "until", rx474_fail
    add rx474_pos, 5
  alt488_end:
    set_addr $I10, rxcap_489_fail
    ($I12, $I11) = rx474_cur."!mark_peek"($I10)
    rx474_cur."!cursor_pos"($I11)
    ($P10) = rx474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx474_pos, "")
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_489_done
  rxcap_489_fail:
    goto rx474_fail
  rxcap_489_done:
  # rx charclass s
    ge rx474_pos, rx474_eos, rx474_fail
    sub $I10, rx474_pos, rx474_off
    is_cclass $I11, 32, rx474_tgt, $I10
    unless $I11, rx474_fail
    inc rx474_pos
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."EXPR"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx474_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  alt480_end:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx474_cur."!cursor_pass"(rx474_pos, "statement_control:sym<repeat>")
    if_null rx474_debug, debug_756
    rx474_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx474_pos)
  debug_756:
    .return (rx474_cur)
  rx474_restart:
.annotate 'line', 10
    if_null rx474_debug, debug_757
    rx474_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_757:
  rx474_fail:
    (rx474_rep, rx474_pos, $I10, $P10) = rx474_cur."!mark_fail"(0)
    lt rx474_pos, -1, rx474_done
    eq rx474_pos, -1, rx474_fail
    jump $I10
  rx474_done:
    rx474_cur."!cursor_fail"()
    if_null rx474_debug, debug_758
    rx474_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_758:
    .return (rx474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1304277427.017") :method
.annotate 'line', 10
    new $P476, "ResizablePMCArray"
    push $P476, "repeat"
    .return ($P476)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx494_tgt
    .local int rx494_pos
    .local int rx494_off
    .local int rx494_eos
    .local int rx494_rep
    .local pmc rx494_cur
    .local pmc rx494_debug
    (rx494_cur, rx494_pos, rx494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx494_cur
    .local pmc match
    .lex "$/", match
    length rx494_eos, rx494_tgt
    gt rx494_pos, rx494_eos, rx494_done
    set rx494_off, 0
    lt rx494_pos, 2, rx494_start
    sub rx494_off, rx494_pos, 1
    substr rx494_tgt, rx494_tgt, rx494_off
  rx494_start:
    eq $I10, 1, rx494_restart
    if_null rx494_debug, debug_759
    rx494_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_759:
    $I10 = self.'from'()
    ne $I10, -1, rxscan497_done
    goto rxscan497_scan
  rxscan497_loop:
    (rx494_pos) = rx494_cur."from"()
    inc rx494_pos
    rx494_cur."!cursor_from"(rx494_pos)
    ge rx494_pos, rx494_eos, rxscan497_done
  rxscan497_scan:
    set_addr $I10, rxscan497_loop
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  rxscan497_done:
.annotate 'line', 228
  # rx subcapture "sym"
    set_addr $I10, rxcap_498_fail
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  # rx literal  "for"
    add $I11, rx494_pos, 3
    gt $I11, rx494_eos, rx494_fail
    sub $I11, rx494_pos, rx494_off
    substr $S10, rx494_tgt, $I11, 3
    ne $S10, "for", rx494_fail
    add rx494_pos, 3
    set_addr $I10, rxcap_498_fail
    ($I12, $I11) = rx494_cur."!mark_peek"($I10)
    rx494_cur."!cursor_pos"($I11)
    ($P10) = rx494_cur."!cursor_start"()
    $P10."!cursor_pass"(rx494_pos, "")
    rx494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_498_done
  rxcap_498_fail:
    goto rx494_fail
  rxcap_498_done:
  # rx charclass s
    ge rx494_pos, rx494_eos, rx494_fail
    sub $I10, rx494_pos, rx494_off
    is_cclass $I11, 32, rx494_tgt, $I10
    unless $I11, rx494_fail
    inc rx494_pos
  # rx subrule "ws" subtype=method negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."ws"()
    unless $P10, rx494_fail
    rx494_pos = $P10."pos"()
.annotate 'line', 229
  # rx subrule "xblock" subtype=capture negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."xblock"()
    unless $P10, rx494_fail
    rx494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx494_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."ws"()
    unless $P10, rx494_fail
    rx494_pos = $P10."pos"()
.annotate 'line', 227
  # rx pass
    rx494_cur."!cursor_pass"(rx494_pos, "statement_control:sym<for>")
    if_null rx494_debug, debug_760
    rx494_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx494_pos)
  debug_760:
    .return (rx494_cur)
  rx494_restart:
.annotate 'line', 10
    if_null rx494_debug, debug_761
    rx494_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_761:
  rx494_fail:
    (rx494_rep, rx494_pos, $I10, $P10) = rx494_cur."!mark_fail"(0)
    lt rx494_pos, -1, rx494_done
    eq rx494_pos, -1, rx494_fail
    jump $I10
  rx494_done:
    rx494_cur."!cursor_fail"()
    if_null rx494_debug, debug_762
    rx494_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_762:
    .return (rx494_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1304277427.017") :method
.annotate 'line', 10
    new $P496, "ResizablePMCArray"
    push $P496, "for"
    .return ($P496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx502_tgt
    .local int rx502_pos
    .local int rx502_off
    .local int rx502_eos
    .local int rx502_rep
    .local pmc rx502_cur
    .local pmc rx502_debug
    (rx502_cur, rx502_pos, rx502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx502_cur
    .local pmc match
    .lex "$/", match
    length rx502_eos, rx502_tgt
    gt rx502_pos, rx502_eos, rx502_done
    set rx502_off, 0
    lt rx502_pos, 2, rx502_start
    sub rx502_off, rx502_pos, 1
    substr rx502_tgt, rx502_tgt, rx502_off
  rx502_start:
    eq $I10, 1, rx502_restart
    if_null rx502_debug, debug_763
    rx502_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_763:
    $I10 = self.'from'()
    ne $I10, -1, rxscan505_done
    goto rxscan505_scan
  rxscan505_loop:
    (rx502_pos) = rx502_cur."from"()
    inc rx502_pos
    rx502_cur."!cursor_from"(rx502_pos)
    ge rx502_pos, rx502_eos, rxscan505_done
  rxscan505_scan:
    set_addr $I10, rxscan505_loop
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  rxscan505_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_506_fail
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx502_pos, 5
    gt $I11, rx502_eos, rx502_fail
    sub $I11, rx502_pos, rx502_off
    substr $S10, rx502_tgt, $I11, 5
    ne $S10, "CATCH", rx502_fail
    add rx502_pos, 5
    set_addr $I10, rxcap_506_fail
    ($I12, $I11) = rx502_cur."!mark_peek"($I10)
    rx502_cur."!cursor_pos"($I11)
    ($P10) = rx502_cur."!cursor_start"()
    $P10."!cursor_pass"(rx502_pos, "")
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_506_done
  rxcap_506_fail:
    goto rx502_fail
  rxcap_506_done:
  # rx charclass s
    ge rx502_pos, rx502_eos, rx502_fail
    sub $I10, rx502_pos, rx502_off
    is_cclass $I11, 32, rx502_tgt, $I10
    unless $I11, rx502_fail
    inc rx502_pos
  # rx subrule "ws" subtype=method negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."ws"()
    unless $P10, rx502_fail
    rx502_pos = $P10."pos"()
.annotate 'line', 234
  # rx subrule "block" subtype=capture negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."block"()
    unless $P10, rx502_fail
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx502_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."ws"()
    unless $P10, rx502_fail
    rx502_pos = $P10."pos"()
.annotate 'line', 232
  # rx pass
    rx502_cur."!cursor_pass"(rx502_pos, "statement_control:sym<CATCH>")
    if_null rx502_debug, debug_764
    rx502_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx502_pos)
  debug_764:
    .return (rx502_cur)
  rx502_restart:
.annotate 'line', 10
    if_null rx502_debug, debug_765
    rx502_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_765:
  rx502_fail:
    (rx502_rep, rx502_pos, $I10, $P10) = rx502_cur."!mark_fail"(0)
    lt rx502_pos, -1, rx502_done
    eq rx502_pos, -1, rx502_fail
    jump $I10
  rx502_done:
    rx502_cur."!cursor_fail"()
    if_null rx502_debug, debug_766
    rx502_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_766:
    .return (rx502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1304277427.017") :method
.annotate 'line', 10
    new $P504, "ResizablePMCArray"
    push $P504, "CATCH"
    .return ($P504)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx510_tgt
    .local int rx510_pos
    .local int rx510_off
    .local int rx510_eos
    .local int rx510_rep
    .local pmc rx510_cur
    .local pmc rx510_debug
    (rx510_cur, rx510_pos, rx510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx510_cur
    .local pmc match
    .lex "$/", match
    length rx510_eos, rx510_tgt
    gt rx510_pos, rx510_eos, rx510_done
    set rx510_off, 0
    lt rx510_pos, 2, rx510_start
    sub rx510_off, rx510_pos, 1
    substr rx510_tgt, rx510_tgt, rx510_off
  rx510_start:
    eq $I10, 1, rx510_restart
    if_null rx510_debug, debug_767
    rx510_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_767:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    (rx510_pos) = rx510_cur."from"()
    inc rx510_pos
    rx510_cur."!cursor_from"(rx510_pos)
    ge rx510_pos, rx510_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  rxscan513_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_514_fail
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx510_pos, 7
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 7
    ne $S10, "CONTROL", rx510_fail
    add rx510_pos, 7
    set_addr $I10, rxcap_514_fail
    ($I12, $I11) = rx510_cur."!mark_peek"($I10)
    rx510_cur."!cursor_pos"($I11)
    ($P10) = rx510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx510_pos, "")
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_514_done
  rxcap_514_fail:
    goto rx510_fail
  rxcap_514_done:
  # rx charclass s
    ge rx510_pos, rx510_eos, rx510_fail
    sub $I10, rx510_pos, rx510_off
    is_cclass $I11, 32, rx510_tgt, $I10
    unless $I11, rx510_fail
    inc rx510_pos
  # rx subrule "ws" subtype=method negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."ws"()
    unless $P10, rx510_fail
    rx510_pos = $P10."pos"()
.annotate 'line', 239
  # rx subrule "block" subtype=capture negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."block"()
    unless $P10, rx510_fail
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx510_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."ws"()
    unless $P10, rx510_fail
    rx510_pos = $P10."pos"()
.annotate 'line', 237
  # rx pass
    rx510_cur."!cursor_pass"(rx510_pos, "statement_control:sym<CONTROL>")
    if_null rx510_debug, debug_768
    rx510_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx510_pos)
  debug_768:
    .return (rx510_cur)
  rx510_restart:
.annotate 'line', 10
    if_null rx510_debug, debug_769
    rx510_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_769:
  rx510_fail:
    (rx510_rep, rx510_pos, $I10, $P10) = rx510_cur."!mark_fail"(0)
    lt rx510_pos, -1, rx510_done
    eq rx510_pos, -1, rx510_fail
    jump $I10
  rx510_done:
    rx510_cur."!cursor_fail"()
    if_null rx510_debug, debug_770
    rx510_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_770:
    .return (rx510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1304277427.017") :method
.annotate 'line', 10
    new $P512, "ResizablePMCArray"
    push $P512, "CONTROL"
    .return ($P512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1304277427.017")
    .param pmc param_518
.annotate 'line', 242
    .lex "self", param_518
    $P519 = param_518."!protoregex"("statement_prefix")
    .return ($P519)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1304277427.017")
    .param pmc param_521
.annotate 'line', 242
    .lex "self", param_521
    $P522 = param_521."!PREFIX__!protoregex"("statement_prefix")
    .return ($P522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx524_tgt
    .local int rx524_pos
    .local int rx524_off
    .local int rx524_eos
    .local int rx524_rep
    .local pmc rx524_cur
    .local pmc rx524_debug
    (rx524_cur, rx524_pos, rx524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx524_cur
    .local pmc match
    .lex "$/", match
    length rx524_eos, rx524_tgt
    gt rx524_pos, rx524_eos, rx524_done
    set rx524_off, 0
    lt rx524_pos, 2, rx524_start
    sub rx524_off, rx524_pos, 1
    substr rx524_tgt, rx524_tgt, rx524_off
  rx524_start:
    eq $I10, 1, rx524_restart
    if_null rx524_debug, debug_771
    rx524_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_771:
    $I10 = self.'from'()
    ne $I10, -1, rxscan528_done
    goto rxscan528_scan
  rxscan528_loop:
    (rx524_pos) = rx524_cur."from"()
    inc rx524_pos
    rx524_cur."!cursor_from"(rx524_pos)
    ge rx524_pos, rx524_eos, rxscan528_done
  rxscan528_scan:
    set_addr $I10, rxscan528_loop
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxscan528_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_529_fail
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx524_pos, 4
    gt $I11, rx524_eos, rx524_fail
    sub $I11, rx524_pos, rx524_off
    substr $S10, rx524_tgt, $I11, 4
    ne $S10, "INIT", rx524_fail
    add rx524_pos, 4
    set_addr $I10, rxcap_529_fail
    ($I12, $I11) = rx524_cur."!mark_peek"($I10)
    rx524_cur."!cursor_pos"($I11)
    ($P10) = rx524_cur."!cursor_start"()
    $P10."!cursor_pass"(rx524_pos, "")
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_529_done
  rxcap_529_fail:
    goto rx524_fail
  rxcap_529_done:
  # rx subrule "blorst" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."blorst"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx524_pos = $P10."pos"()
  # rx pass
    rx524_cur."!cursor_pass"(rx524_pos, "statement_prefix:sym<INIT>")
    if_null rx524_debug, debug_772
    rx524_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx524_pos)
  debug_772:
    .return (rx524_cur)
  rx524_restart:
.annotate 'line', 10
    if_null rx524_debug, debug_773
    rx524_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_773:
  rx524_fail:
    (rx524_rep, rx524_pos, $I10, $P10) = rx524_cur."!mark_fail"(0)
    lt rx524_pos, -1, rx524_done
    eq rx524_pos, -1, rx524_fail
    jump $I10
  rx524_done:
    rx524_cur."!cursor_fail"()
    if_null rx524_debug, debug_774
    rx524_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_774:
    .return (rx524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1304277427.017") :method
.annotate 'line', 10
    $P526 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P527, "ResizablePMCArray"
    push $P527, $P526
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx531_tgt
    .local int rx531_pos
    .local int rx531_off
    .local int rx531_eos
    .local int rx531_rep
    .local pmc rx531_cur
    .local pmc rx531_debug
    (rx531_cur, rx531_pos, rx531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx531_cur
    .local pmc match
    .lex "$/", match
    length rx531_eos, rx531_tgt
    gt rx531_pos, rx531_eos, rx531_done
    set rx531_off, 0
    lt rx531_pos, 2, rx531_start
    sub rx531_off, rx531_pos, 1
    substr rx531_tgt, rx531_tgt, rx531_off
  rx531_start:
    eq $I10, 1, rx531_restart
    if_null rx531_debug, debug_775
    rx531_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_775:
    $I10 = self.'from'()
    ne $I10, -1, rxscan535_done
    goto rxscan535_scan
  rxscan535_loop:
    (rx531_pos) = rx531_cur."from"()
    inc rx531_pos
    rx531_cur."!cursor_from"(rx531_pos)
    ge rx531_pos, rx531_eos, rxscan535_done
  rxscan535_scan:
    set_addr $I10, rxscan535_loop
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  rxscan535_done:
.annotate 'line', 246
  # rx subcapture "sym"
    set_addr $I10, rxcap_536_fail
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  # rx literal  "try"
    add $I11, rx531_pos, 3
    gt $I11, rx531_eos, rx531_fail
    sub $I11, rx531_pos, rx531_off
    substr $S10, rx531_tgt, $I11, 3
    ne $S10, "try", rx531_fail
    add rx531_pos, 3
    set_addr $I10, rxcap_536_fail
    ($I12, $I11) = rx531_cur."!mark_peek"($I10)
    rx531_cur."!cursor_pos"($I11)
    ($P10) = rx531_cur."!cursor_start"()
    $P10."!cursor_pass"(rx531_pos, "")
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_536_done
  rxcap_536_fail:
    goto rx531_fail
  rxcap_536_done:
.annotate 'line', 247
  # rx subrule "blorst" subtype=capture negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."blorst"()
    unless $P10, rx531_fail
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx531_pos = $P10."pos"()
.annotate 'line', 245
  # rx pass
    rx531_cur."!cursor_pass"(rx531_pos, "statement_prefix:sym<try>")
    if_null rx531_debug, debug_776
    rx531_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx531_pos)
  debug_776:
    .return (rx531_cur)
  rx531_restart:
.annotate 'line', 10
    if_null rx531_debug, debug_777
    rx531_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_777:
  rx531_fail:
    (rx531_rep, rx531_pos, $I10, $P10) = rx531_cur."!mark_fail"(0)
    lt rx531_pos, -1, rx531_done
    eq rx531_pos, -1, rx531_fail
    jump $I10
  rx531_done:
    rx531_cur."!cursor_fail"()
    if_null rx531_debug, debug_778
    rx531_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_778:
    .return (rx531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1304277427.017") :method
.annotate 'line', 10
    $P533 = self."!PREFIX__!subrule"("blorst", "try")
    new $P534, "ResizablePMCArray"
    push $P534, $P533
    .return ($P534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx538_tgt
    .local int rx538_pos
    .local int rx538_off
    .local int rx538_eos
    .local int rx538_rep
    .local pmc rx538_cur
    .local pmc rx538_debug
    (rx538_cur, rx538_pos, rx538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx538_cur
    .local pmc match
    .lex "$/", match
    length rx538_eos, rx538_tgt
    gt rx538_pos, rx538_eos, rx538_done
    set rx538_off, 0
    lt rx538_pos, 2, rx538_start
    sub rx538_off, rx538_pos, 1
    substr rx538_tgt, rx538_tgt, rx538_off
  rx538_start:
    eq $I10, 1, rx538_restart
    if_null rx538_debug, debug_779
    rx538_cur."!cursor_debug"("START", "blorst")
  debug_779:
    $I10 = self.'from'()
    ne $I10, -1, rxscan541_done
    goto rxscan541_scan
  rxscan541_loop:
    (rx538_pos) = rx538_cur."from"()
    inc rx538_pos
    rx538_cur."!cursor_from"(rx538_pos)
    ge rx538_pos, rx538_eos, rxscan541_done
  rxscan541_scan:
    set_addr $I10, rxscan541_loop
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  rxscan541_done:
.annotate 'line', 251
  # rx charclass s
    ge rx538_pos, rx538_eos, rx538_fail
    sub $I10, rx538_pos, rx538_off
    is_cclass $I11, 32, rx538_tgt, $I10
    unless $I11, rx538_fail
    inc rx538_pos
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  alt542_0:
    set_addr $I10, alt542_1
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx538_fail
  # rx subrule "block" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."block"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx538_pos = $P10."pos"()
    goto alt542_end
  alt542_1:
  # rx subrule "statement" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."statement"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx538_pos = $P10."pos"()
  alt542_end:
.annotate 'line', 250
  # rx pass
    rx538_cur."!cursor_pass"(rx538_pos, "blorst")
    if_null rx538_debug, debug_780
    rx538_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx538_pos)
  debug_780:
    .return (rx538_cur)
  rx538_restart:
.annotate 'line', 10
    if_null rx538_debug, debug_781
    rx538_cur."!cursor_debug"("NEXT", "blorst")
  debug_781:
  rx538_fail:
    (rx538_rep, rx538_pos, $I10, $P10) = rx538_cur."!mark_fail"(0)
    lt rx538_pos, -1, rx538_done
    eq rx538_pos, -1, rx538_fail
    jump $I10
  rx538_done:
    rx538_cur."!cursor_fail"()
    if_null rx538_debug, debug_782
    rx538_cur."!cursor_debug"("FAIL", "blorst")
  debug_782:
    .return (rx538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1304277427.017") :method
.annotate 'line', 10
    new $P540, "ResizablePMCArray"
    push $P540, ""
    .return ($P540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1304277427.017")
    .param pmc param_544
.annotate 'line', 256
    .lex "self", param_544
    $P545 = param_544."!protoregex"("statement_mod_cond")
    .return ($P545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1304277427.017")
    .param pmc param_547
.annotate 'line', 256
    .lex "self", param_547
    $P548 = param_547."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P548)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx550_tgt
    .local int rx550_pos
    .local int rx550_off
    .local int rx550_eos
    .local int rx550_rep
    .local pmc rx550_cur
    .local pmc rx550_debug
    (rx550_cur, rx550_pos, rx550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx550_cur
    .local pmc match
    .lex "$/", match
    length rx550_eos, rx550_tgt
    gt rx550_pos, rx550_eos, rx550_done
    set rx550_off, 0
    lt rx550_pos, 2, rx550_start
    sub rx550_off, rx550_pos, 1
    substr rx550_tgt, rx550_tgt, rx550_off
  rx550_start:
    eq $I10, 1, rx550_restart
    if_null rx550_debug, debug_783
    rx550_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_783:
    $I10 = self.'from'()
    ne $I10, -1, rxscan554_done
    goto rxscan554_scan
  rxscan554_loop:
    (rx550_pos) = rx550_cur."from"()
    inc rx550_pos
    rx550_cur."!cursor_from"(rx550_pos)
    ge rx550_pos, rx550_eos, rxscan554_done
  rxscan554_scan:
    set_addr $I10, rxscan554_loop
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  rxscan554_done:
.annotate 'line', 258
  # rx subcapture "sym"
    set_addr $I10, rxcap_555_fail
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  # rx literal  "if"
    add $I11, rx550_pos, 2
    gt $I11, rx550_eos, rx550_fail
    sub $I11, rx550_pos, rx550_off
    substr $S10, rx550_tgt, $I11, 2
    ne $S10, "if", rx550_fail
    add rx550_pos, 2
    set_addr $I10, rxcap_555_fail
    ($I12, $I11) = rx550_cur."!mark_peek"($I10)
    rx550_cur."!cursor_pos"($I11)
    ($P10) = rx550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx550_pos, "")
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_555_done
  rxcap_555_fail:
    goto rx550_fail
  rxcap_555_done:
  # rx subrule "ws" subtype=method negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."ws"()
    unless $P10, rx550_fail
    rx550_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."EXPR"()
    unless $P10, rx550_fail
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx550_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."ws"()
    unless $P10, rx550_fail
    rx550_pos = $P10."pos"()
  # rx pass
    rx550_cur."!cursor_pass"(rx550_pos, "statement_mod_cond:sym<if>")
    if_null rx550_debug, debug_784
    rx550_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx550_pos)
  debug_784:
    .return (rx550_cur)
  rx550_restart:
.annotate 'line', 10
    if_null rx550_debug, debug_785
    rx550_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_785:
  rx550_fail:
    (rx550_rep, rx550_pos, $I10, $P10) = rx550_cur."!mark_fail"(0)
    lt rx550_pos, -1, rx550_done
    eq rx550_pos, -1, rx550_fail
    jump $I10
  rx550_done:
    rx550_cur."!cursor_fail"()
    if_null rx550_debug, debug_786
    rx550_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_786:
    .return (rx550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1304277427.017") :method
.annotate 'line', 10
    $P552 = self."!PREFIX__!subrule"("ws", "if")
    new $P553, "ResizablePMCArray"
    push $P553, $P552
    .return ($P553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx559_tgt
    .local int rx559_pos
    .local int rx559_off
    .local int rx559_eos
    .local int rx559_rep
    .local pmc rx559_cur
    .local pmc rx559_debug
    (rx559_cur, rx559_pos, rx559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx559_cur
    .local pmc match
    .lex "$/", match
    length rx559_eos, rx559_tgt
    gt rx559_pos, rx559_eos, rx559_done
    set rx559_off, 0
    lt rx559_pos, 2, rx559_start
    sub rx559_off, rx559_pos, 1
    substr rx559_tgt, rx559_tgt, rx559_off
  rx559_start:
    eq $I10, 1, rx559_restart
    if_null rx559_debug, debug_787
    rx559_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan563_done
    goto rxscan563_scan
  rxscan563_loop:
    (rx559_pos) = rx559_cur."from"()
    inc rx559_pos
    rx559_cur."!cursor_from"(rx559_pos)
    ge rx559_pos, rx559_eos, rxscan563_done
  rxscan563_scan:
    set_addr $I10, rxscan563_loop
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  rxscan563_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_564_fail
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  # rx literal  "unless"
    add $I11, rx559_pos, 6
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 6
    ne $S10, "unless", rx559_fail
    add rx559_pos, 6
    set_addr $I10, rxcap_564_fail
    ($I12, $I11) = rx559_cur."!mark_peek"($I10)
    rx559_cur."!cursor_pos"($I11)
    ($P10) = rx559_cur."!cursor_start"()
    $P10."!cursor_pass"(rx559_pos, "")
    rx559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_564_done
  rxcap_564_fail:
    goto rx559_fail
  rxcap_564_done:
  # rx subrule "ws" subtype=method negate=
    rx559_cur."!cursor_pos"(rx559_pos)
    $P10 = rx559_cur."ws"()
    unless $P10, rx559_fail
    rx559_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx559_cur."!cursor_pos"(rx559_pos)
    $P10 = rx559_cur."EXPR"()
    unless $P10, rx559_fail
    rx559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx559_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx559_cur."!cursor_pos"(rx559_pos)
    $P10 = rx559_cur."ws"()
    unless $P10, rx559_fail
    rx559_pos = $P10."pos"()
  # rx pass
    rx559_cur."!cursor_pass"(rx559_pos, "statement_mod_cond:sym<unless>")
    if_null rx559_debug, debug_788
    rx559_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx559_pos)
  debug_788:
    .return (rx559_cur)
  rx559_restart:
.annotate 'line', 10
    if_null rx559_debug, debug_789
    rx559_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_789:
  rx559_fail:
    (rx559_rep, rx559_pos, $I10, $P10) = rx559_cur."!mark_fail"(0)
    lt rx559_pos, -1, rx559_done
    eq rx559_pos, -1, rx559_fail
    jump $I10
  rx559_done:
    rx559_cur."!cursor_fail"()
    if_null rx559_debug, debug_790
    rx559_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_790:
    .return (rx559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1304277427.017") :method
.annotate 'line', 10
    $P561 = self."!PREFIX__!subrule"("ws", "unless")
    new $P562, "ResizablePMCArray"
    push $P562, $P561
    .return ($P562)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1304277427.017")
    .param pmc param_568
.annotate 'line', 261
    .lex "self", param_568
    $P569 = param_568."!protoregex"("statement_mod_loop")
    .return ($P569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1304277427.017")
    .param pmc param_571
.annotate 'line', 261
    .lex "self", param_571
    $P572 = param_571."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P572)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_791
    rx574_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_791:
    $I10 = self.'from'()
    ne $I10, -1, rxscan578_done
    goto rxscan578_scan
  rxscan578_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan578_done
  rxscan578_scan:
    set_addr $I10, rxscan578_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan578_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_579_fail
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  # rx literal  "while"
    add $I11, rx574_pos, 5
    gt $I11, rx574_eos, rx574_fail
    sub $I11, rx574_pos, rx574_off
    substr $S10, rx574_tgt, $I11, 5
    ne $S10, "while", rx574_fail
    add rx574_pos, 5
    set_addr $I10, rxcap_579_fail
    ($I12, $I11) = rx574_cur."!mark_peek"($I10)
    rx574_cur."!cursor_pos"($I11)
    ($P10) = rx574_cur."!cursor_start"()
    $P10."!cursor_pass"(rx574_pos, "")
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_579_done
  rxcap_579_fail:
    goto rx574_fail
  rxcap_579_done:
  # rx subrule "ws" subtype=method negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."ws"()
    unless $P10, rx574_fail
    rx574_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."EXPR"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx574_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."ws"()
    unless $P10, rx574_fail
    rx574_pos = $P10."pos"()
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "statement_mod_loop:sym<while>")
    if_null rx574_debug, debug_792
    rx574_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx574_pos)
  debug_792:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 10
    if_null rx574_debug, debug_793
    rx574_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_793:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_794
    rx574_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_794:
    .return (rx574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1304277427.017") :method
.annotate 'line', 10
    $P576 = self."!PREFIX__!subrule"("ws", "while")
    new $P577, "ResizablePMCArray"
    push $P577, $P576
    .return ($P577)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx583_tgt
    .local int rx583_pos
    .local int rx583_off
    .local int rx583_eos
    .local int rx583_rep
    .local pmc rx583_cur
    .local pmc rx583_debug
    (rx583_cur, rx583_pos, rx583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx583_cur
    .local pmc match
    .lex "$/", match
    length rx583_eos, rx583_tgt
    gt rx583_pos, rx583_eos, rx583_done
    set rx583_off, 0
    lt rx583_pos, 2, rx583_start
    sub rx583_off, rx583_pos, 1
    substr rx583_tgt, rx583_tgt, rx583_off
  rx583_start:
    eq $I10, 1, rx583_restart
    if_null rx583_debug, debug_795
    rx583_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_795:
    $I10 = self.'from'()
    ne $I10, -1, rxscan587_done
    goto rxscan587_scan
  rxscan587_loop:
    (rx583_pos) = rx583_cur."from"()
    inc rx583_pos
    rx583_cur."!cursor_from"(rx583_pos)
    ge rx583_pos, rx583_eos, rxscan587_done
  rxscan587_scan:
    set_addr $I10, rxscan587_loop
    rx583_cur."!mark_push"(0, rx583_pos, $I10)
  rxscan587_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_588_fail
    rx583_cur."!mark_push"(0, rx583_pos, $I10)
  # rx literal  "until"
    add $I11, rx583_pos, 5
    gt $I11, rx583_eos, rx583_fail
    sub $I11, rx583_pos, rx583_off
    substr $S10, rx583_tgt, $I11, 5
    ne $S10, "until", rx583_fail
    add rx583_pos, 5
    set_addr $I10, rxcap_588_fail
    ($I12, $I11) = rx583_cur."!mark_peek"($I10)
    rx583_cur."!cursor_pos"($I11)
    ($P10) = rx583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx583_pos, "")
    rx583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_588_done
  rxcap_588_fail:
    goto rx583_fail
  rxcap_588_done:
  # rx subrule "ws" subtype=method negate=
    rx583_cur."!cursor_pos"(rx583_pos)
    $P10 = rx583_cur."ws"()
    unless $P10, rx583_fail
    rx583_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx583_cur."!cursor_pos"(rx583_pos)
    $P10 = rx583_cur."EXPR"()
    unless $P10, rx583_fail
    rx583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx583_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx583_cur."!cursor_pos"(rx583_pos)
    $P10 = rx583_cur."ws"()
    unless $P10, rx583_fail
    rx583_pos = $P10."pos"()
  # rx pass
    rx583_cur."!cursor_pass"(rx583_pos, "statement_mod_loop:sym<until>")
    if_null rx583_debug, debug_796
    rx583_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx583_pos)
  debug_796:
    .return (rx583_cur)
  rx583_restart:
.annotate 'line', 10
    if_null rx583_debug, debug_797
    rx583_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_797:
  rx583_fail:
    (rx583_rep, rx583_pos, $I10, $P10) = rx583_cur."!mark_fail"(0)
    lt rx583_pos, -1, rx583_done
    eq rx583_pos, -1, rx583_fail
    jump $I10
  rx583_done:
    rx583_cur."!cursor_fail"()
    if_null rx583_debug, debug_798
    rx583_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_798:
    .return (rx583_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1304277427.017") :method
.annotate 'line', 10
    $P585 = self."!PREFIX__!subrule"("ws", "until")
    new $P586, "ResizablePMCArray"
    push $P586, $P585
    .return ($P586)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx592_tgt
    .local int rx592_pos
    .local int rx592_off
    .local int rx592_eos
    .local int rx592_rep
    .local pmc rx592_cur
    .local pmc rx592_debug
    (rx592_cur, rx592_pos, rx592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx592_cur
    .local pmc match
    .lex "$/", match
    length rx592_eos, rx592_tgt
    gt rx592_pos, rx592_eos, rx592_done
    set rx592_off, 0
    lt rx592_pos, 2, rx592_start
    sub rx592_off, rx592_pos, 1
    substr rx592_tgt, rx592_tgt, rx592_off
  rx592_start:
    eq $I10, 1, rx592_restart
    if_null rx592_debug, debug_799
    rx592_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_799:
    $I10 = self.'from'()
    ne $I10, -1, rxscan596_done
    goto rxscan596_scan
  rxscan596_loop:
    (rx592_pos) = rx592_cur."from"()
    inc rx592_pos
    rx592_cur."!cursor_from"(rx592_pos)
    ge rx592_pos, rx592_eos, rxscan596_done
  rxscan596_scan:
    set_addr $I10, rxscan596_loop
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  rxscan596_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_597_fail
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  # rx literal  "for"
    add $I11, rx592_pos, 3
    gt $I11, rx592_eos, rx592_fail
    sub $I11, rx592_pos, rx592_off
    substr $S10, rx592_tgt, $I11, 3
    ne $S10, "for", rx592_fail
    add rx592_pos, 3
    set_addr $I10, rxcap_597_fail
    ($I12, $I11) = rx592_cur."!mark_peek"($I10)
    rx592_cur."!cursor_pos"($I11)
    ($P10) = rx592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx592_pos, "")
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_597_done
  rxcap_597_fail:
    goto rx592_fail
  rxcap_597_done:
  # rx subrule "ws" subtype=method negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."ws"()
    unless $P10, rx592_fail
    rx592_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."EXPR"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx592_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."ws"()
    unless $P10, rx592_fail
    rx592_pos = $P10."pos"()
  # rx pass
    rx592_cur."!cursor_pass"(rx592_pos, "statement_mod_loop:sym<for>")
    if_null rx592_debug, debug_800
    rx592_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx592_pos)
  debug_800:
    .return (rx592_cur)
  rx592_restart:
.annotate 'line', 10
    if_null rx592_debug, debug_801
    rx592_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_801:
  rx592_fail:
    (rx592_rep, rx592_pos, $I10, $P10) = rx592_cur."!mark_fail"(0)
    lt rx592_pos, -1, rx592_done
    eq rx592_pos, -1, rx592_fail
    jump $I10
  rx592_done:
    rx592_cur."!cursor_fail"()
    if_null rx592_debug, debug_802
    rx592_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_802:
    .return (rx592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1304277427.017") :method
.annotate 'line', 10
    $P594 = self."!PREFIX__!subrule"("ws", "for")
    new $P595, "ResizablePMCArray"
    push $P595, $P594
    .return ($P595)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx601_tgt
    .local int rx601_pos
    .local int rx601_off
    .local int rx601_eos
    .local int rx601_rep
    .local pmc rx601_cur
    .local pmc rx601_debug
    (rx601_cur, rx601_pos, rx601_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx601_cur
    .local pmc match
    .lex "$/", match
    length rx601_eos, rx601_tgt
    gt rx601_pos, rx601_eos, rx601_done
    set rx601_off, 0
    lt rx601_pos, 2, rx601_start
    sub rx601_off, rx601_pos, 1
    substr rx601_tgt, rx601_tgt, rx601_off
  rx601_start:
    eq $I10, 1, rx601_restart
    if_null rx601_debug, debug_803
    rx601_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_803:
    $I10 = self.'from'()
    ne $I10, -1, rxscan605_done
    goto rxscan605_scan
  rxscan605_loop:
    (rx601_pos) = rx601_cur."from"()
    inc rx601_pos
    rx601_cur."!cursor_from"(rx601_pos)
    ge rx601_pos, rx601_eos, rxscan605_done
  rxscan605_scan:
    set_addr $I10, rxscan605_loop
    rx601_cur."!mark_push"(0, rx601_pos, $I10)
  rxscan605_done:
.annotate 'line', 269
  # rx subrule "fatarrow" subtype=capture negate=
    rx601_cur."!cursor_pos"(rx601_pos)
    $P10 = rx601_cur."fatarrow"()
    unless $P10, rx601_fail
    rx601_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx601_pos = $P10."pos"()
  # rx pass
    rx601_cur."!cursor_pass"(rx601_pos, "term:sym<fatarrow>")
    if_null rx601_debug, debug_804
    rx601_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx601_pos)
  debug_804:
    .return (rx601_cur)
  rx601_restart:
.annotate 'line', 10
    if_null rx601_debug, debug_805
    rx601_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_805:
  rx601_fail:
    (rx601_rep, rx601_pos, $I10, $P10) = rx601_cur."!mark_fail"(0)
    lt rx601_pos, -1, rx601_done
    eq rx601_pos, -1, rx601_fail
    jump $I10
  rx601_done:
    rx601_cur."!cursor_fail"()
    if_null rx601_debug, debug_806
    rx601_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_806:
    .return (rx601_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1304277427.017") :method
.annotate 'line', 10
    $P603 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P604, "ResizablePMCArray"
    push $P604, $P603
    .return ($P604)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx607_tgt
    .local int rx607_pos
    .local int rx607_off
    .local int rx607_eos
    .local int rx607_rep
    .local pmc rx607_cur
    .local pmc rx607_debug
    (rx607_cur, rx607_pos, rx607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx607_cur
    .local pmc match
    .lex "$/", match
    length rx607_eos, rx607_tgt
    gt rx607_pos, rx607_eos, rx607_done
    set rx607_off, 0
    lt rx607_pos, 2, rx607_start
    sub rx607_off, rx607_pos, 1
    substr rx607_tgt, rx607_tgt, rx607_off
  rx607_start:
    eq $I10, 1, rx607_restart
    if_null rx607_debug, debug_807
    rx607_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_807:
    $I10 = self.'from'()
    ne $I10, -1, rxscan611_done
    goto rxscan611_scan
  rxscan611_loop:
    (rx607_pos) = rx607_cur."from"()
    inc rx607_pos
    rx607_cur."!cursor_from"(rx607_pos)
    ge rx607_pos, rx607_eos, rxscan611_done
  rxscan611_scan:
    set_addr $I10, rxscan611_loop
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  rxscan611_done:
.annotate 'line', 270
  # rx subrule "colonpair" subtype=capture negate=
    rx607_cur."!cursor_pos"(rx607_pos)
    $P10 = rx607_cur."colonpair"()
    unless $P10, rx607_fail
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx607_pos = $P10."pos"()
  # rx pass
    rx607_cur."!cursor_pass"(rx607_pos, "term:sym<colonpair>")
    if_null rx607_debug, debug_808
    rx607_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx607_pos)
  debug_808:
    .return (rx607_cur)
  rx607_restart:
.annotate 'line', 10
    if_null rx607_debug, debug_809
    rx607_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_809:
  rx607_fail:
    (rx607_rep, rx607_pos, $I10, $P10) = rx607_cur."!mark_fail"(0)
    lt rx607_pos, -1, rx607_done
    eq rx607_pos, -1, rx607_fail
    jump $I10
  rx607_done:
    rx607_cur."!cursor_fail"()
    if_null rx607_debug, debug_810
    rx607_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_810:
    .return (rx607_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1304277427.017") :method
.annotate 'line', 10
    $P609 = self."!PREFIX__!subrule"("colonpair", "")
    new $P610, "ResizablePMCArray"
    push $P610, $P609
    .return ($P610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx613_tgt
    .local int rx613_pos
    .local int rx613_off
    .local int rx613_eos
    .local int rx613_rep
    .local pmc rx613_cur
    .local pmc rx613_debug
    (rx613_cur, rx613_pos, rx613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx613_cur
    .local pmc match
    .lex "$/", match
    length rx613_eos, rx613_tgt
    gt rx613_pos, rx613_eos, rx613_done
    set rx613_off, 0
    lt rx613_pos, 2, rx613_start
    sub rx613_off, rx613_pos, 1
    substr rx613_tgt, rx613_tgt, rx613_off
  rx613_start:
    eq $I10, 1, rx613_restart
    if_null rx613_debug, debug_811
    rx613_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_811:
    $I10 = self.'from'()
    ne $I10, -1, rxscan617_done
    goto rxscan617_scan
  rxscan617_loop:
    (rx613_pos) = rx613_cur."from"()
    inc rx613_pos
    rx613_cur."!cursor_from"(rx613_pos)
    ge rx613_pos, rx613_eos, rxscan617_done
  rxscan617_scan:
    set_addr $I10, rxscan617_loop
    rx613_cur."!mark_push"(0, rx613_pos, $I10)
  rxscan617_done:
.annotate 'line', 271
  # rx subrule "variable" subtype=capture negate=
    rx613_cur."!cursor_pos"(rx613_pos)
    $P10 = rx613_cur."variable"()
    unless $P10, rx613_fail
    rx613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx613_pos = $P10."pos"()
  # rx pass
    rx613_cur."!cursor_pass"(rx613_pos, "term:sym<variable>")
    if_null rx613_debug, debug_812
    rx613_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx613_pos)
  debug_812:
    .return (rx613_cur)
  rx613_restart:
.annotate 'line', 10
    if_null rx613_debug, debug_813
    rx613_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_813:
  rx613_fail:
    (rx613_rep, rx613_pos, $I10, $P10) = rx613_cur."!mark_fail"(0)
    lt rx613_pos, -1, rx613_done
    eq rx613_pos, -1, rx613_fail
    jump $I10
  rx613_done:
    rx613_cur."!cursor_fail"()
    if_null rx613_debug, debug_814
    rx613_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_814:
    .return (rx613_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1304277427.017") :method
.annotate 'line', 10
    $P615 = self."!PREFIX__!subrule"("variable", "")
    new $P616, "ResizablePMCArray"
    push $P616, $P615
    .return ($P616)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx619_tgt
    .local int rx619_pos
    .local int rx619_off
    .local int rx619_eos
    .local int rx619_rep
    .local pmc rx619_cur
    .local pmc rx619_debug
    (rx619_cur, rx619_pos, rx619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx619_cur
    .local pmc match
    .lex "$/", match
    length rx619_eos, rx619_tgt
    gt rx619_pos, rx619_eos, rx619_done
    set rx619_off, 0
    lt rx619_pos, 2, rx619_start
    sub rx619_off, rx619_pos, 1
    substr rx619_tgt, rx619_tgt, rx619_off
  rx619_start:
    eq $I10, 1, rx619_restart
    if_null rx619_debug, debug_815
    rx619_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_815:
    $I10 = self.'from'()
    ne $I10, -1, rxscan623_done
    goto rxscan623_scan
  rxscan623_loop:
    (rx619_pos) = rx619_cur."from"()
    inc rx619_pos
    rx619_cur."!cursor_from"(rx619_pos)
    ge rx619_pos, rx619_eos, rxscan623_done
  rxscan623_scan:
    set_addr $I10, rxscan623_loop
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  rxscan623_done:
.annotate 'line', 272
  # rx subrule "package_declarator" subtype=capture negate=
    rx619_cur."!cursor_pos"(rx619_pos)
    $P10 = rx619_cur."package_declarator"()
    unless $P10, rx619_fail
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx619_pos = $P10."pos"()
  # rx pass
    rx619_cur."!cursor_pass"(rx619_pos, "term:sym<package_declarator>")
    if_null rx619_debug, debug_816
    rx619_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx619_pos)
  debug_816:
    .return (rx619_cur)
  rx619_restart:
.annotate 'line', 10
    if_null rx619_debug, debug_817
    rx619_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_817:
  rx619_fail:
    (rx619_rep, rx619_pos, $I10, $P10) = rx619_cur."!mark_fail"(0)
    lt rx619_pos, -1, rx619_done
    eq rx619_pos, -1, rx619_fail
    jump $I10
  rx619_done:
    rx619_cur."!cursor_fail"()
    if_null rx619_debug, debug_818
    rx619_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_818:
    .return (rx619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1304277427.017") :method
.annotate 'line', 10
    $P621 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P622, "ResizablePMCArray"
    push $P622, $P621
    .return ($P622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx625_tgt
    .local int rx625_pos
    .local int rx625_off
    .local int rx625_eos
    .local int rx625_rep
    .local pmc rx625_cur
    .local pmc rx625_debug
    (rx625_cur, rx625_pos, rx625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx625_cur
    .local pmc match
    .lex "$/", match
    length rx625_eos, rx625_tgt
    gt rx625_pos, rx625_eos, rx625_done
    set rx625_off, 0
    lt rx625_pos, 2, rx625_start
    sub rx625_off, rx625_pos, 1
    substr rx625_tgt, rx625_tgt, rx625_off
  rx625_start:
    eq $I10, 1, rx625_restart
    if_null rx625_debug, debug_819
    rx625_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_819:
    $I10 = self.'from'()
    ne $I10, -1, rxscan629_done
    goto rxscan629_scan
  rxscan629_loop:
    (rx625_pos) = rx625_cur."from"()
    inc rx625_pos
    rx625_cur."!cursor_from"(rx625_pos)
    ge rx625_pos, rx625_eos, rxscan629_done
  rxscan629_scan:
    set_addr $I10, rxscan629_loop
    rx625_cur."!mark_push"(0, rx625_pos, $I10)
  rxscan629_done:
.annotate 'line', 273
  # rx subrule "scope_declarator" subtype=capture negate=
    rx625_cur."!cursor_pos"(rx625_pos)
    $P10 = rx625_cur."scope_declarator"()
    unless $P10, rx625_fail
    rx625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx625_pos = $P10."pos"()
  # rx pass
    rx625_cur."!cursor_pass"(rx625_pos, "term:sym<scope_declarator>")
    if_null rx625_debug, debug_820
    rx625_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx625_pos)
  debug_820:
    .return (rx625_cur)
  rx625_restart:
.annotate 'line', 10
    if_null rx625_debug, debug_821
    rx625_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_821:
  rx625_fail:
    (rx625_rep, rx625_pos, $I10, $P10) = rx625_cur."!mark_fail"(0)
    lt rx625_pos, -1, rx625_done
    eq rx625_pos, -1, rx625_fail
    jump $I10
  rx625_done:
    rx625_cur."!cursor_fail"()
    if_null rx625_debug, debug_822
    rx625_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_822:
    .return (rx625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1304277427.017") :method
.annotate 'line', 10
    $P627 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P628, "ResizablePMCArray"
    push $P628, $P627
    .return ($P628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx631_tgt
    .local int rx631_pos
    .local int rx631_off
    .local int rx631_eos
    .local int rx631_rep
    .local pmc rx631_cur
    .local pmc rx631_debug
    (rx631_cur, rx631_pos, rx631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx631_cur
    .local pmc match
    .lex "$/", match
    length rx631_eos, rx631_tgt
    gt rx631_pos, rx631_eos, rx631_done
    set rx631_off, 0
    lt rx631_pos, 2, rx631_start
    sub rx631_off, rx631_pos, 1
    substr rx631_tgt, rx631_tgt, rx631_off
  rx631_start:
    eq $I10, 1, rx631_restart
    if_null rx631_debug, debug_823
    rx631_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_823:
    $I10 = self.'from'()
    ne $I10, -1, rxscan635_done
    goto rxscan635_scan
  rxscan635_loop:
    (rx631_pos) = rx631_cur."from"()
    inc rx631_pos
    rx631_cur."!cursor_from"(rx631_pos)
    ge rx631_pos, rx631_eos, rxscan635_done
  rxscan635_scan:
    set_addr $I10, rxscan635_loop
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  rxscan635_done:
.annotate 'line', 274
  # rx subrule "routine_declarator" subtype=capture negate=
    rx631_cur."!cursor_pos"(rx631_pos)
    $P10 = rx631_cur."routine_declarator"()
    unless $P10, rx631_fail
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx631_pos = $P10."pos"()
  # rx pass
    rx631_cur."!cursor_pass"(rx631_pos, "term:sym<routine_declarator>")
    if_null rx631_debug, debug_824
    rx631_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx631_pos)
  debug_824:
    .return (rx631_cur)
  rx631_restart:
.annotate 'line', 10
    if_null rx631_debug, debug_825
    rx631_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_825:
  rx631_fail:
    (rx631_rep, rx631_pos, $I10, $P10) = rx631_cur."!mark_fail"(0)
    lt rx631_pos, -1, rx631_done
    eq rx631_pos, -1, rx631_fail
    jump $I10
  rx631_done:
    rx631_cur."!cursor_fail"()
    if_null rx631_debug, debug_826
    rx631_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_826:
    .return (rx631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1304277427.017") :method
.annotate 'line', 10
    $P633 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P634, "ResizablePMCArray"
    push $P634, $P633
    .return ($P634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P647 = "121_1304277427.017" 
    capture_lex $P647
    .const 'Sub' $P642 = "120_1304277427.017" 
    capture_lex $P642
    .local string rx637_tgt
    .local int rx637_pos
    .local int rx637_off
    .local int rx637_eos
    .local int rx637_rep
    .local pmc rx637_cur
    .local pmc rx637_debug
    (rx637_cur, rx637_pos, rx637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx637_cur
    .local pmc match
    .lex "$/", match
    length rx637_eos, rx637_tgt
    gt rx637_pos, rx637_eos, rx637_done
    set rx637_off, 0
    lt rx637_pos, 2, rx637_start
    sub rx637_off, rx637_pos, 1
    substr rx637_tgt, rx637_tgt, rx637_off
  rx637_start:
    eq $I10, 1, rx637_restart
    if_null rx637_debug, debug_827
    rx637_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_827:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx637_pos) = rx637_cur."from"()
    inc rx637_pos
    rx637_cur."!cursor_from"(rx637_pos)
    ge rx637_pos, rx637_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx637_cur."!mark_push"(0, rx637_pos, $I10)
  rxscan640_done:
.annotate 'line', 276
  # rx subrule "before" subtype=zerowidth negate=
    rx637_cur."!cursor_pos"(rx637_pos)
    .const 'Sub' $P642 = "120_1304277427.017" 
    capture_lex $P642
    $P10 = rx637_cur."before"($P642)
    unless $P10, rx637_fail
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=1
    rx637_cur."!cursor_pos"(rx637_pos)
    .const 'Sub' $P647 = "121_1304277427.017" 
    capture_lex $P647
    $P10 = rx637_cur."before"($P647)
    if $P10, rx637_fail
.annotate 'line', 278
  # rx subrule "multi_declarator" subtype=capture negate=
    rx637_cur."!cursor_pos"(rx637_pos)
    $P10 = rx637_cur."multi_declarator"()
    unless $P10, rx637_fail
    rx637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx637_pos = $P10."pos"()
.annotate 'line', 275
  # rx pass
    rx637_cur."!cursor_pass"(rx637_pos, "term:sym<multi_declarator>")
    if_null rx637_debug, debug_836
    rx637_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx637_pos)
  debug_836:
    .return (rx637_cur)
  rx637_restart:
.annotate 'line', 10
    if_null rx637_debug, debug_837
    rx637_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_837:
  rx637_fail:
    (rx637_rep, rx637_pos, $I10, $P10) = rx637_cur."!mark_fail"(0)
    lt rx637_pos, -1, rx637_done
    eq rx637_pos, -1, rx637_fail
    jump $I10
  rx637_done:
    rx637_cur."!cursor_fail"()
    if_null rx637_debug, debug_838
    rx637_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_838:
    .return (rx637_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1304277427.017") :method
.annotate 'line', 10
    new $P639, "ResizablePMCArray"
    push $P639, ""
    .return ($P639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block641"  :anon :subid("120_1304277427.017") :method :outer("118_1304277427.017")
.annotate 'line', 276
    .local string rx643_tgt
    .local int rx643_pos
    .local int rx643_off
    .local int rx643_eos
    .local int rx643_rep
    .local pmc rx643_cur
    .local pmc rx643_debug
    (rx643_cur, rx643_pos, rx643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx643_cur
    .local pmc match
    .lex "$/", match
    length rx643_eos, rx643_tgt
    gt rx643_pos, rx643_eos, rx643_done
    set rx643_off, 0
    lt rx643_pos, 2, rx643_start
    sub rx643_off, rx643_pos, 1
    substr rx643_tgt, rx643_tgt, rx643_off
  rx643_start:
    eq $I10, 1, rx643_restart
    if_null rx643_debug, debug_828
    rx643_cur."!cursor_debug"("START", "")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan644_done
    goto rxscan644_scan
  rxscan644_loop:
    (rx643_pos) = rx643_cur."from"()
    inc rx643_pos
    rx643_cur."!cursor_from"(rx643_pos)
    ge rx643_pos, rx643_eos, rxscan644_done
  rxscan644_scan:
    set_addr $I10, rxscan644_loop
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  rxscan644_done:
  alt645_0:
    set_addr $I10, alt645_1
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  # rx literal  "multi"
    add $I11, rx643_pos, 5
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 5
    ne $S10, "multi", rx643_fail
    add rx643_pos, 5
    goto alt645_end
  alt645_1:
    set_addr $I10, alt645_2
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  # rx literal  "proto"
    add $I11, rx643_pos, 5
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 5
    ne $S10, "proto", rx643_fail
    add rx643_pos, 5
    goto alt645_end
  alt645_2:
  # rx literal  "only"
    add $I11, rx643_pos, 4
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 4
    ne $S10, "only", rx643_fail
    add rx643_pos, 4
  alt645_end:
  # rx pass
    rx643_cur."!cursor_pass"(rx643_pos, "")
    if_null rx643_debug, debug_829
    rx643_cur."!cursor_debug"("PASS", "", " at pos=", rx643_pos)
  debug_829:
    .return (rx643_cur)
  rx643_restart:
    if_null rx643_debug, debug_830
    rx643_cur."!cursor_debug"("NEXT", "")
  debug_830:
  rx643_fail:
    (rx643_rep, rx643_pos, $I10, $P10) = rx643_cur."!mark_fail"(0)
    lt rx643_pos, -1, rx643_done
    eq rx643_pos, -1, rx643_fail
    jump $I10
  rx643_done:
    rx643_cur."!cursor_fail"()
    if_null rx643_debug, debug_831
    rx643_cur."!cursor_debug"("FAIL", "")
  debug_831:
    .return (rx643_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block646"  :anon :subid("121_1304277427.017") :method :outer("118_1304277427.017")
.annotate 'line', 277
    .local string rx648_tgt
    .local int rx648_pos
    .local int rx648_off
    .local int rx648_eos
    .local int rx648_rep
    .local pmc rx648_cur
    .local pmc rx648_debug
    (rx648_cur, rx648_pos, rx648_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx648_cur
    .local pmc match
    .lex "$/", match
    length rx648_eos, rx648_tgt
    gt rx648_pos, rx648_eos, rx648_done
    set rx648_off, 0
    lt rx648_pos, 2, rx648_start
    sub rx648_off, rx648_pos, 1
    substr rx648_tgt, rx648_tgt, rx648_off
  rx648_start:
    eq $I10, 1, rx648_restart
    if_null rx648_debug, debug_832
    rx648_cur."!cursor_debug"("START", "")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan649_done
    goto rxscan649_scan
  rxscan649_loop:
    (rx648_pos) = rx648_cur."from"()
    inc rx648_pos
    rx648_cur."!cursor_from"(rx648_pos)
    ge rx648_pos, rx648_eos, rxscan649_done
  rxscan649_scan:
    set_addr $I10, rxscan649_loop
    rx648_cur."!mark_push"(0, rx648_pos, $I10)
  rxscan649_done:
  # rx literal  "proto"
    add $I11, rx648_pos, 5
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 5
    ne $S10, "proto", rx648_fail
    add rx648_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx648_cur."!cursor_pos"(rx648_pos)
    $P10 = rx648_cur."ws"()
    unless $P10, rx648_fail
    rx648_pos = $P10."pos"()
  alt650_0:
    set_addr $I10, alt650_1
    rx648_cur."!mark_push"(0, rx648_pos, $I10)
  # rx literal  "regex"
    add $I11, rx648_pos, 5
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 5
    ne $S10, "regex", rx648_fail
    add rx648_pos, 5
    goto alt650_end
  alt650_1:
    set_addr $I10, alt650_2
    rx648_cur."!mark_push"(0, rx648_pos, $I10)
  # rx literal  "token"
    add $I11, rx648_pos, 5
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 5
    ne $S10, "token", rx648_fail
    add rx648_pos, 5
    goto alt650_end
  alt650_2:
  # rx literal  "rule"
    add $I11, rx648_pos, 4
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 4
    ne $S10, "rule", rx648_fail
    add rx648_pos, 4
  alt650_end:
  # rx pass
    rx648_cur."!cursor_pass"(rx648_pos, "")
    if_null rx648_debug, debug_833
    rx648_cur."!cursor_debug"("PASS", "", " at pos=", rx648_pos)
  debug_833:
    .return (rx648_cur)
  rx648_restart:
    if_null rx648_debug, debug_834
    rx648_cur."!cursor_debug"("NEXT", "")
  debug_834:
  rx648_fail:
    (rx648_rep, rx648_pos, $I10, $P10) = rx648_cur."!mark_fail"(0)
    lt rx648_pos, -1, rx648_done
    eq rx648_pos, -1, rx648_fail
    jump $I10
  rx648_done:
    rx648_cur."!cursor_fail"()
    if_null rx648_debug, debug_835
    rx648_cur."!cursor_debug"("FAIL", "")
  debug_835:
    .return (rx648_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx652_tgt
    .local int rx652_pos
    .local int rx652_off
    .local int rx652_eos
    .local int rx652_rep
    .local pmc rx652_cur
    .local pmc rx652_debug
    (rx652_cur, rx652_pos, rx652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx652_cur
    .local pmc match
    .lex "$/", match
    length rx652_eos, rx652_tgt
    gt rx652_pos, rx652_eos, rx652_done
    set rx652_off, 0
    lt rx652_pos, 2, rx652_start
    sub rx652_off, rx652_pos, 1
    substr rx652_tgt, rx652_tgt, rx652_off
  rx652_start:
    eq $I10, 1, rx652_restart
    if_null rx652_debug, debug_839
    rx652_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_839:
    $I10 = self.'from'()
    ne $I10, -1, rxscan656_done
    goto rxscan656_scan
  rxscan656_loop:
    (rx652_pos) = rx652_cur."from"()
    inc rx652_pos
    rx652_cur."!cursor_from"(rx652_pos)
    ge rx652_pos, rx652_eos, rxscan656_done
  rxscan656_scan:
    set_addr $I10, rxscan656_loop
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  rxscan656_done:
.annotate 'line', 280
  # rx subrule "regex_declarator" subtype=capture negate=
    rx652_cur."!cursor_pos"(rx652_pos)
    $P10 = rx652_cur."regex_declarator"()
    unless $P10, rx652_fail
    rx652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx652_pos = $P10."pos"()
  # rx pass
    rx652_cur."!cursor_pass"(rx652_pos, "term:sym<regex_declarator>")
    if_null rx652_debug, debug_840
    rx652_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx652_pos)
  debug_840:
    .return (rx652_cur)
  rx652_restart:
.annotate 'line', 10
    if_null rx652_debug, debug_841
    rx652_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_841:
  rx652_fail:
    (rx652_rep, rx652_pos, $I10, $P10) = rx652_cur."!mark_fail"(0)
    lt rx652_pos, -1, rx652_done
    eq rx652_pos, -1, rx652_fail
    jump $I10
  rx652_done:
    rx652_cur."!cursor_fail"()
    if_null rx652_debug, debug_842
    rx652_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_842:
    .return (rx652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1304277427.017") :method
.annotate 'line', 10
    $P654 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P655, "ResizablePMCArray"
    push $P655, $P654
    .return ($P655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx658_tgt
    .local int rx658_pos
    .local int rx658_off
    .local int rx658_eos
    .local int rx658_rep
    .local pmc rx658_cur
    .local pmc rx658_debug
    (rx658_cur, rx658_pos, rx658_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx658_cur
    .local pmc match
    .lex "$/", match
    length rx658_eos, rx658_tgt
    gt rx658_pos, rx658_eos, rx658_done
    set rx658_off, 0
    lt rx658_pos, 2, rx658_start
    sub rx658_off, rx658_pos, 1
    substr rx658_tgt, rx658_tgt, rx658_off
  rx658_start:
    eq $I10, 1, rx658_restart
    if_null rx658_debug, debug_843
    rx658_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_843:
    $I10 = self.'from'()
    ne $I10, -1, rxscan662_done
    goto rxscan662_scan
  rxscan662_loop:
    (rx658_pos) = rx658_cur."from"()
    inc rx658_pos
    rx658_cur."!cursor_from"(rx658_pos)
    ge rx658_pos, rx658_eos, rxscan662_done
  rxscan662_scan:
    set_addr $I10, rxscan662_loop
    rx658_cur."!mark_push"(0, rx658_pos, $I10)
  rxscan662_done:
.annotate 'line', 281
  # rx subrule "statement_prefix" subtype=capture negate=
    rx658_cur."!cursor_pos"(rx658_pos)
    $P10 = rx658_cur."statement_prefix"()
    unless $P10, rx658_fail
    rx658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx658_pos = $P10."pos"()
  # rx pass
    rx658_cur."!cursor_pass"(rx658_pos, "term:sym<statement_prefix>")
    if_null rx658_debug, debug_844
    rx658_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx658_pos)
  debug_844:
    .return (rx658_cur)
  rx658_restart:
.annotate 'line', 10
    if_null rx658_debug, debug_845
    rx658_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_845:
  rx658_fail:
    (rx658_rep, rx658_pos, $I10, $P10) = rx658_cur."!mark_fail"(0)
    lt rx658_pos, -1, rx658_done
    eq rx658_pos, -1, rx658_fail
    jump $I10
  rx658_done:
    rx658_cur."!cursor_fail"()
    if_null rx658_debug, debug_846
    rx658_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_846:
    .return (rx658_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1304277427.017") :method
.annotate 'line', 10
    $P660 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P661, "ResizablePMCArray"
    push $P661, $P660
    .return ($P661)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx664_tgt
    .local int rx664_pos
    .local int rx664_off
    .local int rx664_eos
    .local int rx664_rep
    .local pmc rx664_cur
    .local pmc rx664_debug
    (rx664_cur, rx664_pos, rx664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx664_cur
    .local pmc match
    .lex "$/", match
    length rx664_eos, rx664_tgt
    gt rx664_pos, rx664_eos, rx664_done
    set rx664_off, 0
    lt rx664_pos, 2, rx664_start
    sub rx664_off, rx664_pos, 1
    substr rx664_tgt, rx664_tgt, rx664_off
  rx664_start:
    eq $I10, 1, rx664_restart
    if_null rx664_debug, debug_847
    rx664_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_847:
    $I10 = self.'from'()
    ne $I10, -1, rxscan667_done
    goto rxscan667_scan
  rxscan667_loop:
    (rx664_pos) = rx664_cur."from"()
    inc rx664_pos
    rx664_cur."!cursor_from"(rx664_pos)
    ge rx664_pos, rx664_eos, rxscan667_done
  rxscan667_scan:
    set_addr $I10, rxscan667_loop
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  rxscan667_done:
.annotate 'line', 282
  # rx subrule "lambda" subtype=zerowidth negate=
    rx664_cur."!cursor_pos"(rx664_pos)
    $P10 = rx664_cur."lambda"()
    unless $P10, rx664_fail
  # rx subrule "pblock" subtype=capture negate=
    rx664_cur."!cursor_pos"(rx664_pos)
    $P10 = rx664_cur."pblock"()
    unless $P10, rx664_fail
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx664_pos = $P10."pos"()
  # rx pass
    rx664_cur."!cursor_pass"(rx664_pos, "term:sym<lambda>")
    if_null rx664_debug, debug_848
    rx664_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx664_pos)
  debug_848:
    .return (rx664_cur)
  rx664_restart:
.annotate 'line', 10
    if_null rx664_debug, debug_849
    rx664_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_849:
  rx664_fail:
    (rx664_rep, rx664_pos, $I10, $P10) = rx664_cur."!mark_fail"(0)
    lt rx664_pos, -1, rx664_done
    eq rx664_pos, -1, rx664_fail
    jump $I10
  rx664_done:
    rx664_cur."!cursor_fail"()
    if_null rx664_debug, debug_850
    rx664_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_850:
    .return (rx664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1304277427.017") :method
.annotate 'line', 10
    new $P666, "ResizablePMCArray"
    push $P666, ""
    .return ($P666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx669_tgt
    .local int rx669_pos
    .local int rx669_off
    .local int rx669_eos
    .local int rx669_rep
    .local pmc rx669_cur
    .local pmc rx669_debug
    (rx669_cur, rx669_pos, rx669_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx669_cur
    .local pmc match
    .lex "$/", match
    length rx669_eos, rx669_tgt
    gt rx669_pos, rx669_eos, rx669_done
    set rx669_off, 0
    lt rx669_pos, 2, rx669_start
    sub rx669_off, rx669_pos, 1
    substr rx669_tgt, rx669_tgt, rx669_off
  rx669_start:
    eq $I10, 1, rx669_restart
    if_null rx669_debug, debug_851
    rx669_cur."!cursor_debug"("START", "fatarrow")
  debug_851:
    $I10 = self.'from'()
    ne $I10, -1, rxscan673_done
    goto rxscan673_scan
  rxscan673_loop:
    (rx669_pos) = rx669_cur."from"()
    inc rx669_pos
    rx669_cur."!cursor_from"(rx669_pos)
    ge rx669_pos, rx669_eos, rxscan673_done
  rxscan673_scan:
    set_addr $I10, rxscan673_loop
    rx669_cur."!mark_push"(0, rx669_pos, $I10)
  rxscan673_done:
.annotate 'line', 285
  # rx subrule "identifier" subtype=capture negate=
    rx669_cur."!cursor_pos"(rx669_pos)
    $P10 = rx669_cur."identifier"()
    unless $P10, rx669_fail
    rx669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx669_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx669_pos, rx669_off
    set rx669_rep, 0
    sub $I12, rx669_eos, rx669_pos
  rxenumcharlistq674_loop:
    le $I12, 0, rxenumcharlistq674_done
    substr $S10, rx669_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq674_done
    inc rx669_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq674_loop
  rxenumcharlistq674_done:
    add rx669_pos, rx669_pos, rx669_rep
  # rx literal  "=>"
    add $I11, rx669_pos, 2
    gt $I11, rx669_eos, rx669_fail
    sub $I11, rx669_pos, rx669_off
    substr $S10, rx669_tgt, $I11, 2
    ne $S10, "=>", rx669_fail
    add rx669_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx669_cur."!cursor_pos"(rx669_pos)
    $P10 = rx669_cur."ws"()
    unless $P10, rx669_fail
    rx669_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx669_cur."!cursor_pos"(rx669_pos)
    $P10 = rx669_cur."EXPR"("i=")
    unless $P10, rx669_fail
    rx669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx669_pos = $P10."pos"()
.annotate 'line', 284
  # rx pass
    rx669_cur."!cursor_pass"(rx669_pos, "fatarrow")
    if_null rx669_debug, debug_852
    rx669_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx669_pos)
  debug_852:
    .return (rx669_cur)
  rx669_restart:
.annotate 'line', 10
    if_null rx669_debug, debug_853
    rx669_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_853:
  rx669_fail:
    (rx669_rep, rx669_pos, $I10, $P10) = rx669_cur."!mark_fail"(0)
    lt rx669_pos, -1, rx669_done
    eq rx669_pos, -1, rx669_fail
    jump $I10
  rx669_done:
    rx669_cur."!cursor_fail"()
    if_null rx669_debug, debug_854
    rx669_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_854:
    .return (rx669_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1304277427.017") :method
.annotate 'line', 10
    $P671 = self."!PREFIX__!subrule"("identifier", "")
    new $P672, "ResizablePMCArray"
    push $P672, $P671
    .return ($P672)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx676_tgt
    .local int rx676_pos
    .local int rx676_off
    .local int rx676_eos
    .local int rx676_rep
    .local pmc rx676_cur
    .local pmc rx676_debug
    (rx676_cur, rx676_pos, rx676_tgt, $I10) = self."!cursor_start"()
    rx676_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx676_cur
    .local pmc match
    .lex "$/", match
    length rx676_eos, rx676_tgt
    gt rx676_pos, rx676_eos, rx676_done
    set rx676_off, 0
    lt rx676_pos, 2, rx676_start
    sub rx676_off, rx676_pos, 1
    substr rx676_tgt, rx676_tgt, rx676_off
  rx676_start:
    eq $I10, 1, rx676_restart
    if_null rx676_debug, debug_855
    rx676_cur."!cursor_debug"("START", "colonpair")
  debug_855:
    $I10 = self.'from'()
    ne $I10, -1, rxscan682_done
    goto rxscan682_scan
  rxscan682_loop:
    (rx676_pos) = rx676_cur."from"()
    inc rx676_pos
    rx676_cur."!cursor_from"(rx676_pos)
    ge rx676_pos, rx676_eos, rxscan682_done
  rxscan682_scan:
    set_addr $I10, rxscan682_loop
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  rxscan682_done:
.annotate 'line', 289
  # rx literal  ":"
    add $I11, rx676_pos, 1
    gt $I11, rx676_eos, rx676_fail
    sub $I11, rx676_pos, rx676_off
    ord $I11, rx676_tgt, $I11
    ne $I11, 58, rx676_fail
    add rx676_pos, 1
  alt683_0:
.annotate 'line', 290
    set_addr $I10, alt683_1
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
.annotate 'line', 291
  # rx subcapture "not"
    set_addr $I10, rxcap_684_fail
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  # rx literal  "!"
    add $I11, rx676_pos, 1
    gt $I11, rx676_eos, rx676_fail
    sub $I11, rx676_pos, rx676_off
    ord $I11, rx676_tgt, $I11
    ne $I11, 33, rx676_fail
    add rx676_pos, 1
    set_addr $I10, rxcap_684_fail
    ($I12, $I11) = rx676_cur."!mark_peek"($I10)
    rx676_cur."!cursor_pos"($I11)
    ($P10) = rx676_cur."!cursor_start"()
    $P10."!cursor_pass"(rx676_pos, "")
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_684_done
  rxcap_684_fail:
    goto rx676_fail
  rxcap_684_done:
  # rx subrule "identifier" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."identifier"()
    unless $P10, rx676_fail
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx676_pos = $P10."pos"()
    goto alt683_end
  alt683_1:
    set_addr $I10, alt683_2
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
.annotate 'line', 292
  # rx subrule "identifier" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."identifier"()
    unless $P10, rx676_fail
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx676_pos = $P10."pos"()
  # rx rxquantr685 ** 0..1
    set_addr $I10, rxquantr685_done
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  rxquantr685_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."circumfix"()
    unless $P10, rx676_fail
    goto rxsubrule686_pass
  rxsubrule686_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx676_fail
  rxsubrule686_pass:
    set_addr $I10, rxsubrule686_back
    rx676_cur."!mark_push"(0, rx676_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx676_pos = $P10."pos"()
    set_addr $I10, rxquantr685_done
    (rx676_rep) = rx676_cur."!mark_commit"($I10)
  rxquantr685_done:
    goto alt683_end
  alt683_2:
.annotate 'line', 293
  # rx subrule "circumfix" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."circumfix"()
    unless $P10, rx676_fail
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx676_pos = $P10."pos"()
  alt683_end:
.annotate 'line', 288
  # rx pass
    rx676_cur."!cursor_pass"(rx676_pos, "colonpair")
    if_null rx676_debug, debug_856
    rx676_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx676_pos)
  debug_856:
    .return (rx676_cur)
  rx676_restart:
.annotate 'line', 10
    if_null rx676_debug, debug_857
    rx676_cur."!cursor_debug"("NEXT", "colonpair")
  debug_857:
  rx676_fail:
    (rx676_rep, rx676_pos, $I10, $P10) = rx676_cur."!mark_fail"(0)
    lt rx676_pos, -1, rx676_done
    eq rx676_pos, -1, rx676_fail
    jump $I10
  rx676_done:
    rx676_cur."!cursor_fail"()
    if_null rx676_debug, debug_858
    rx676_cur."!cursor_debug"("FAIL", "colonpair")
  debug_858:
    .return (rx676_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1304277427.017") :method
.annotate 'line', 10
    $P678 = self."!PREFIX__!subrule"("circumfix", ":")
    $P679 = self."!PREFIX__!subrule"("identifier", ":")
    $P680 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P681, "ResizablePMCArray"
    push $P681, $P678
    push $P681, $P679
    push $P681, $P680
    .return ($P681)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx688_tgt
    .local int rx688_pos
    .local int rx688_off
    .local int rx688_eos
    .local int rx688_rep
    .local pmc rx688_cur
    .local pmc rx688_debug
    (rx688_cur, rx688_pos, rx688_tgt, $I10) = self."!cursor_start"()
    rx688_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx688_cur
    .local pmc match
    .lex "$/", match
    length rx688_eos, rx688_tgt
    gt rx688_pos, rx688_eos, rx688_done
    set rx688_off, 0
    lt rx688_pos, 2, rx688_start
    sub rx688_off, rx688_pos, 1
    substr rx688_tgt, rx688_tgt, rx688_off
  rx688_start:
    eq $I10, 1, rx688_restart
    if_null rx688_debug, debug_859
    rx688_cur."!cursor_debug"("START", "variable")
  debug_859:
    $I10 = self.'from'()
    ne $I10, -1, rxscan693_done
    goto rxscan693_scan
  rxscan693_loop:
    (rx688_pos) = rx688_cur."from"()
    inc rx688_pos
    rx688_cur."!cursor_from"(rx688_pos)
    ge rx688_pos, rx688_eos, rxscan693_done
  rxscan693_scan:
    set_addr $I10, rxscan693_loop
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxscan693_done:
  alt694_0:
.annotate 'line', 297
    set_addr $I10, alt694_1
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
.annotate 'line', 298
  # rx subrule "sigil" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."sigil"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx688_pos = $P10."pos"()
  # rx rxquantr695 ** 0..1
    set_addr $I10, rxquantr695_done
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxquantr695_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."twigil"()
    unless $P10, rx688_fail
    goto rxsubrule696_pass
  rxsubrule696_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx688_fail
  rxsubrule696_pass:
    set_addr $I10, rxsubrule696_back
    rx688_cur."!mark_push"(0, rx688_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx688_pos = $P10."pos"()
    set_addr $I10, rxquantr695_done
    (rx688_rep) = rx688_cur."!mark_commit"($I10)
  rxquantr695_done:
  # rx subrule "name" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."name"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx688_pos = $P10."pos"()
    goto alt694_end
  alt694_1:
    set_addr $I10, alt694_2
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."sigil"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx688_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx688_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."postcircumfix"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx688_pos = $P10."pos"()
    goto alt694_end
  alt694_2:
.annotate 'line', 300
  # rx subcapture "sigil"
    set_addr $I10, rxcap_697_fail
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  # rx literal  "$"
    add $I11, rx688_pos, 1
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    ord $I11, rx688_tgt, $I11
    ne $I11, 36, rx688_fail
    add rx688_pos, 1
    set_addr $I10, rxcap_697_fail
    ($I12, $I11) = rx688_cur."!mark_peek"($I10)
    rx688_cur."!cursor_pos"($I11)
    ($P10) = rx688_cur."!cursor_start"()
    $P10."!cursor_pass"(rx688_pos, "")
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_697_done
  rxcap_697_fail:
    goto rx688_fail
  rxcap_697_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_698_fail
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx688_pos, rx688_eos, rx688_fail
    sub $I10, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx688_fail
    inc rx688_pos
    set_addr $I10, rxcap_698_fail
    ($I12, $I11) = rx688_cur."!mark_peek"($I10)
    rx688_cur."!cursor_pos"($I11)
    ($P10) = rx688_cur."!cursor_start"()
    $P10."!cursor_pass"(rx688_pos, "")
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_698_done
  rxcap_698_fail:
    goto rx688_fail
  rxcap_698_done:
  alt694_end:
.annotate 'line', 297
  # rx pass
    rx688_cur."!cursor_pass"(rx688_pos, "variable")
    if_null rx688_debug, debug_860
    rx688_cur."!cursor_debug"("PASS", "variable", " at pos=", rx688_pos)
  debug_860:
    .return (rx688_cur)
  rx688_restart:
.annotate 'line', 10
    if_null rx688_debug, debug_861
    rx688_cur."!cursor_debug"("NEXT", "variable")
  debug_861:
  rx688_fail:
    (rx688_rep, rx688_pos, $I10, $P10) = rx688_cur."!mark_fail"(0)
    lt rx688_pos, -1, rx688_done
    eq rx688_pos, -1, rx688_fail
    jump $I10
  rx688_done:
    rx688_cur."!cursor_fail"()
    if_null rx688_debug, debug_862
    rx688_cur."!cursor_debug"("FAIL", "variable")
  debug_862:
    .return (rx688_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1304277427.017") :method
.annotate 'line', 10
    $P690 = self."!PREFIX__!subrule"("sigil", "")
    $P691 = self."!PREFIX__!subrule"("sigil", "")
    new $P692, "ResizablePMCArray"
    push $P692, "$!"
    push $P692, "$_"
    push $P692, "$/"
    push $P692, $P690
    push $P692, $P691
    .return ($P692)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx700_tgt
    .local int rx700_pos
    .local int rx700_off
    .local int rx700_eos
    .local int rx700_rep
    .local pmc rx700_cur
    .local pmc rx700_debug
    (rx700_cur, rx700_pos, rx700_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx700_cur
    .local pmc match
    .lex "$/", match
    length rx700_eos, rx700_tgt
    gt rx700_pos, rx700_eos, rx700_done
    set rx700_off, 0
    lt rx700_pos, 2, rx700_start
    sub rx700_off, rx700_pos, 1
    substr rx700_tgt, rx700_tgt, rx700_off
  rx700_start:
    eq $I10, 1, rx700_restart
    if_null rx700_debug, debug_863
    rx700_cur."!cursor_debug"("START", "sigil")
  debug_863:
    $I10 = self.'from'()
    ne $I10, -1, rxscan703_done
    goto rxscan703_scan
  rxscan703_loop:
    (rx700_pos) = rx700_cur."from"()
    inc rx700_pos
    rx700_cur."!cursor_from"(rx700_pos)
    ge rx700_pos, rx700_eos, rxscan703_done
  rxscan703_scan:
    set_addr $I10, rxscan703_loop
    rx700_cur."!mark_push"(0, rx700_pos, $I10)
  rxscan703_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx700_pos, rx700_eos, rx700_fail
    sub $I10, rx700_pos, rx700_off
    substr $S10, rx700_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx700_fail
    inc rx700_pos
  # rx pass
    rx700_cur."!cursor_pass"(rx700_pos, "sigil")
    if_null rx700_debug, debug_864
    rx700_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx700_pos)
  debug_864:
    .return (rx700_cur)
  rx700_restart:
.annotate 'line', 10
    if_null rx700_debug, debug_865
    rx700_cur."!cursor_debug"("NEXT", "sigil")
  debug_865:
  rx700_fail:
    (rx700_rep, rx700_pos, $I10, $P10) = rx700_cur."!mark_fail"(0)
    lt rx700_pos, -1, rx700_done
    eq rx700_pos, -1, rx700_fail
    jump $I10
  rx700_done:
    rx700_cur."!cursor_fail"()
    if_null rx700_debug, debug_866
    rx700_cur."!cursor_debug"("FAIL", "sigil")
  debug_866:
    .return (rx700_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1304277427.017") :method
.annotate 'line', 10
    new $P702, "ResizablePMCArray"
    push $P702, "&"
    push $P702, "%"
    push $P702, "@"
    push $P702, "$"
    .return ($P702)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_867
    rx705_cur."!cursor_debug"("START", "twigil")
  debug_867:
    $I10 = self.'from'()
    ne $I10, -1, rxscan708_done
    goto rxscan708_scan
  rxscan708_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan708_done
  rxscan708_scan:
    set_addr $I10, rxscan708_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan708_done:
.annotate 'line', 305
  # rx enumcharlist negate=0 
    ge rx705_pos, rx705_eos, rx705_fail
    sub $I10, rx705_pos, rx705_off
    substr $S10, rx705_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx705_fail
    inc rx705_pos
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "twigil")
    if_null rx705_debug, debug_868
    rx705_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx705_pos)
  debug_868:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 10
    if_null rx705_debug, debug_869
    rx705_cur."!cursor_debug"("NEXT", "twigil")
  debug_869:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_870
    rx705_cur."!cursor_debug"("FAIL", "twigil")
  debug_870:
    .return (rx705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1304277427.017") :method
.annotate 'line', 10
    new $P707, "ResizablePMCArray"
    push $P707, "?"
    push $P707, "!"
    push $P707, "*"
    .return ($P707)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1304277427.017")
    .param pmc param_710
.annotate 'line', 307
    .lex "self", param_710
    $P711 = param_710."!protoregex"("package_declarator")
    .return ($P711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1304277427.017")
    .param pmc param_713
.annotate 'line', 307
    .lex "self", param_713
    $P714 = param_713."!PREFIX__!protoregex"("package_declarator")
    .return ($P714)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 309
    new $P716, "Undef"
    .lex "$*OUTERPACKAGE", $P716
.annotate 'line', 310
    new $P717, "Undef"
    .lex "$*PACKAGE-SETUP", $P717
.annotate 'line', 311
    new $P718, "Undef"
    .lex "$*PKGDECL", $P718
.annotate 'line', 10
    .local string rx719_tgt
    .local int rx719_pos
    .local int rx719_off
    .local int rx719_eos
    .local int rx719_rep
    .local pmc rx719_cur
    .local pmc rx719_debug
    (rx719_cur, rx719_pos, rx719_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx719_cur
    .local pmc match
    .lex "$/", match
    length rx719_eos, rx719_tgt
    gt rx719_pos, rx719_eos, rx719_done
    set rx719_off, 0
    lt rx719_pos, 2, rx719_start
    sub rx719_off, rx719_pos, 1
    substr rx719_tgt, rx719_tgt, rx719_off
  rx719_start:
    eq $I10, 1, rx719_restart
    if_null rx719_debug, debug_871
    rx719_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_871:
    $I10 = self.'from'()
    ne $I10, -1, rxscan723_done
    goto rxscan723_scan
  rxscan723_loop:
    (rx719_pos) = rx719_cur."from"()
    inc rx719_pos
    rx719_cur."!cursor_from"(rx719_pos)
    ge rx719_pos, rx719_eos, rxscan723_done
  rxscan723_scan:
    set_addr $I10, rxscan723_loop
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxscan723_done:
.annotate 'line', 309
    rx719_cur."!cursor_pos"(rx719_pos)
    find_dynamic_lex $P726, "$*PACKAGE"
    unless_null $P726, vivify_872
    get_hll_global $P724, "GLOBAL"
    get_who $P725, $P724
    set $P726, $P725["$PACKAGE"]
    unless_null $P726, vivify_873
    die "Contextual $*PACKAGE not found"
  vivify_873:
  vivify_872:
    store_lex "$*OUTERPACKAGE", $P726
.annotate 'line', 310
    rx719_cur."!cursor_pos"(rx719_pos)
    get_hll_global $P727, "GLOBAL"
    nqp_get_package_through_who $P728, $P727, "PAST"
    get_who $P729, $P728
    set $P730, $P729["Stmts"]
    $P731 = $P730."new"()
    store_lex "$*PACKAGE-SETUP", $P731
.annotate 'line', 311
    rx719_cur."!cursor_pos"(rx719_pos)
    new $P732, "String"
    assign $P732, "module"
    store_lex "$*PKGDECL", $P732
.annotate 'line', 312
  # rx subcapture "sym"
    set_addr $I10, rxcap_733_fail
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  # rx literal  "module"
    add $I11, rx719_pos, 6
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 6
    ne $S10, "module", rx719_fail
    add rx719_pos, 6
    set_addr $I10, rxcap_733_fail
    ($I12, $I11) = rx719_cur."!mark_peek"($I10)
    rx719_cur."!cursor_pos"($I11)
    ($P10) = rx719_cur."!cursor_start"()
    $P10."!cursor_pass"(rx719_pos, "")
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_733_done
  rxcap_733_fail:
    goto rx719_fail
  rxcap_733_done:
  # rx subrule "package_def" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."package_def"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx719_pos = $P10."pos"()
.annotate 'line', 308
  # rx pass
    rx719_cur."!cursor_pass"(rx719_pos, "package_declarator:sym<module>")
    if_null rx719_debug, debug_874
    rx719_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx719_pos)
  debug_874:
    .return (rx719_cur)
  rx719_restart:
.annotate 'line', 10
    if_null rx719_debug, debug_875
    rx719_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_875:
  rx719_fail:
    (rx719_rep, rx719_pos, $I10, $P10) = rx719_cur."!mark_fail"(0)
    lt rx719_pos, -1, rx719_done
    eq rx719_pos, -1, rx719_fail
    jump $I10
  rx719_done:
    rx719_cur."!cursor_fail"()
    if_null rx719_debug, debug_876
    rx719_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_876:
    .return (rx719_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1304277427.017") :method
.annotate 'line', 10
    $P721 = self."!PREFIX__!subrule"("package_def", "module")
    new $P722, "ResizablePMCArray"
    push $P722, $P721
    .return ($P722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 315
    new $P735, "Undef"
    .lex "$*OUTERPACKAGE", $P735
.annotate 'line', 316
    new $P736, "Undef"
    .lex "$*PACKAGE-SETUP", $P736
.annotate 'line', 317
    new $P737, "Undef"
    .lex "$*PKGDECL", $P737
.annotate 'line', 10
    .local string rx738_tgt
    .local int rx738_pos
    .local int rx738_off
    .local int rx738_eos
    .local int rx738_rep
    .local pmc rx738_cur
    .local pmc rx738_debug
    (rx738_cur, rx738_pos, rx738_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx738_cur
    .local pmc match
    .lex "$/", match
    length rx738_eos, rx738_tgt
    gt rx738_pos, rx738_eos, rx738_done
    set rx738_off, 0
    lt rx738_pos, 2, rx738_start
    sub rx738_off, rx738_pos, 1
    substr rx738_tgt, rx738_tgt, rx738_off
  rx738_start:
    eq $I10, 1, rx738_restart
    if_null rx738_debug, debug_877
    rx738_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_877:
    $I10 = self.'from'()
    ne $I10, -1, rxscan742_done
    goto rxscan742_scan
  rxscan742_loop:
    (rx738_pos) = rx738_cur."from"()
    inc rx738_pos
    rx738_cur."!cursor_from"(rx738_pos)
    ge rx738_pos, rx738_eos, rxscan742_done
  rxscan742_scan:
    set_addr $I10, rxscan742_loop
    rx738_cur."!mark_push"(0, rx738_pos, $I10)
  rxscan742_done:
.annotate 'line', 315
    rx738_cur."!cursor_pos"(rx738_pos)
    find_dynamic_lex $P745, "$*PACKAGE"
    unless_null $P745, vivify_878
    get_hll_global $P743, "GLOBAL"
    get_who $P744, $P743
    set $P745, $P744["$PACKAGE"]
    unless_null $P745, vivify_879
    die "Contextual $*PACKAGE not found"
  vivify_879:
  vivify_878:
    store_lex "$*OUTERPACKAGE", $P745
.annotate 'line', 316
    rx738_cur."!cursor_pos"(rx738_pos)
    get_hll_global $P746, "GLOBAL"
    nqp_get_package_through_who $P747, $P746, "PAST"
    get_who $P748, $P747
    set $P749, $P748["Stmts"]
    $P750 = $P749."new"()
    store_lex "$*PACKAGE-SETUP", $P750
.annotate 'line', 317
    rx738_cur."!cursor_pos"(rx738_pos)
    new $P751, "String"
    assign $P751, "knowhow"
    store_lex "$*PKGDECL", $P751
.annotate 'line', 318
  # rx subcapture "sym"
    set_addr $I10, rxcap_752_fail
    rx738_cur."!mark_push"(0, rx738_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx738_pos, 7
    gt $I11, rx738_eos, rx738_fail
    sub $I11, rx738_pos, rx738_off
    substr $S10, rx738_tgt, $I11, 7
    ne $S10, "knowhow", rx738_fail
    add rx738_pos, 7
    set_addr $I10, rxcap_752_fail
    ($I12, $I11) = rx738_cur."!mark_peek"($I10)
    rx738_cur."!cursor_pos"($I11)
    ($P10) = rx738_cur."!cursor_start"()
    $P10."!cursor_pass"(rx738_pos, "")
    rx738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_752_done
  rxcap_752_fail:
    goto rx738_fail
  rxcap_752_done:
  # rx subrule "package_def" subtype=capture negate=
    rx738_cur."!cursor_pos"(rx738_pos)
    $P10 = rx738_cur."package_def"()
    unless $P10, rx738_fail
    rx738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx738_pos = $P10."pos"()
.annotate 'line', 314
  # rx pass
    rx738_cur."!cursor_pass"(rx738_pos, "package_declarator:sym<knowhow>")
    if_null rx738_debug, debug_880
    rx738_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx738_pos)
  debug_880:
    .return (rx738_cur)
  rx738_restart:
.annotate 'line', 10
    if_null rx738_debug, debug_881
    rx738_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_881:
  rx738_fail:
    (rx738_rep, rx738_pos, $I10, $P10) = rx738_cur."!mark_fail"(0)
    lt rx738_pos, -1, rx738_done
    eq rx738_pos, -1, rx738_fail
    jump $I10
  rx738_done:
    rx738_cur."!cursor_fail"()
    if_null rx738_debug, debug_882
    rx738_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_882:
    .return (rx738_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1304277427.017") :method
.annotate 'line', 10
    $P740 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P741, "ResizablePMCArray"
    push $P741, $P740
    .return ($P741)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 321
    new $P754, "Undef"
    .lex "$*OUTERPACKAGE", $P754
.annotate 'line', 322
    new $P755, "Undef"
    .lex "$*PACKAGE-SETUP", $P755
.annotate 'line', 323
    new $P756, "Undef"
    .lex "$*PKGDECL", $P756
.annotate 'line', 10
    .local string rx757_tgt
    .local int rx757_pos
    .local int rx757_off
    .local int rx757_eos
    .local int rx757_rep
    .local pmc rx757_cur
    .local pmc rx757_debug
    (rx757_cur, rx757_pos, rx757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx757_cur
    .local pmc match
    .lex "$/", match
    length rx757_eos, rx757_tgt
    gt rx757_pos, rx757_eos, rx757_done
    set rx757_off, 0
    lt rx757_pos, 2, rx757_start
    sub rx757_off, rx757_pos, 1
    substr rx757_tgt, rx757_tgt, rx757_off
  rx757_start:
    eq $I10, 1, rx757_restart
    if_null rx757_debug, debug_883
    rx757_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_883:
    $I10 = self.'from'()
    ne $I10, -1, rxscan761_done
    goto rxscan761_scan
  rxscan761_loop:
    (rx757_pos) = rx757_cur."from"()
    inc rx757_pos
    rx757_cur."!cursor_from"(rx757_pos)
    ge rx757_pos, rx757_eos, rxscan761_done
  rxscan761_scan:
    set_addr $I10, rxscan761_loop
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxscan761_done:
.annotate 'line', 321
    rx757_cur."!cursor_pos"(rx757_pos)
    find_dynamic_lex $P764, "$*PACKAGE"
    unless_null $P764, vivify_884
    get_hll_global $P762, "GLOBAL"
    get_who $P763, $P762
    set $P764, $P763["$PACKAGE"]
    unless_null $P764, vivify_885
    die "Contextual $*PACKAGE not found"
  vivify_885:
  vivify_884:
    store_lex "$*OUTERPACKAGE", $P764
.annotate 'line', 322
    rx757_cur."!cursor_pos"(rx757_pos)
    get_hll_global $P765, "GLOBAL"
    nqp_get_package_through_who $P766, $P765, "PAST"
    get_who $P767, $P766
    set $P768, $P767["Stmts"]
    $P769 = $P768."new"()
    store_lex "$*PACKAGE-SETUP", $P769
.annotate 'line', 323
    rx757_cur."!cursor_pos"(rx757_pos)
    new $P770, "String"
    assign $P770, "class"
    store_lex "$*PKGDECL", $P770
.annotate 'line', 324
  # rx subcapture "sym"
    set_addr $I10, rxcap_771_fail
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx literal  "class"
    add $I11, rx757_pos, 5
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    substr $S10, rx757_tgt, $I11, 5
    ne $S10, "class", rx757_fail
    add rx757_pos, 5
    set_addr $I10, rxcap_771_fail
    ($I12, $I11) = rx757_cur."!mark_peek"($I10)
    rx757_cur."!cursor_pos"($I11)
    ($P10) = rx757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx757_pos, "")
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_771_done
  rxcap_771_fail:
    goto rx757_fail
  rxcap_771_done:
  # rx subrule "package_def" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."package_def"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx757_pos = $P10."pos"()
.annotate 'line', 320
  # rx pass
    rx757_cur."!cursor_pass"(rx757_pos, "package_declarator:sym<class>")
    if_null rx757_debug, debug_886
    rx757_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx757_pos)
  debug_886:
    .return (rx757_cur)
  rx757_restart:
.annotate 'line', 10
    if_null rx757_debug, debug_887
    rx757_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_887:
  rx757_fail:
    (rx757_rep, rx757_pos, $I10, $P10) = rx757_cur."!mark_fail"(0)
    lt rx757_pos, -1, rx757_done
    eq rx757_pos, -1, rx757_fail
    jump $I10
  rx757_done:
    rx757_cur."!cursor_fail"()
    if_null rx757_debug, debug_888
    rx757_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_888:
    .return (rx757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1304277427.017") :method
.annotate 'line', 10
    $P759 = self."!PREFIX__!subrule"("package_def", "class")
    new $P760, "ResizablePMCArray"
    push $P760, $P759
    .return ($P760)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 327
    new $P773, "Undef"
    .lex "$*OUTERPACKAGE", $P773
.annotate 'line', 328
    new $P774, "Undef"
    .lex "$*PACKAGE-SETUP", $P774
.annotate 'line', 329
    new $P775, "Undef"
    .lex "$*PKGDECL", $P775
.annotate 'line', 10
    .local string rx776_tgt
    .local int rx776_pos
    .local int rx776_off
    .local int rx776_eos
    .local int rx776_rep
    .local pmc rx776_cur
    .local pmc rx776_debug
    (rx776_cur, rx776_pos, rx776_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx776_cur
    .local pmc match
    .lex "$/", match
    length rx776_eos, rx776_tgt
    gt rx776_pos, rx776_eos, rx776_done
    set rx776_off, 0
    lt rx776_pos, 2, rx776_start
    sub rx776_off, rx776_pos, 1
    substr rx776_tgt, rx776_tgt, rx776_off
  rx776_start:
    eq $I10, 1, rx776_restart
    if_null rx776_debug, debug_889
    rx776_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan780_done
    goto rxscan780_scan
  rxscan780_loop:
    (rx776_pos) = rx776_cur."from"()
    inc rx776_pos
    rx776_cur."!cursor_from"(rx776_pos)
    ge rx776_pos, rx776_eos, rxscan780_done
  rxscan780_scan:
    set_addr $I10, rxscan780_loop
    rx776_cur."!mark_push"(0, rx776_pos, $I10)
  rxscan780_done:
.annotate 'line', 327
    rx776_cur."!cursor_pos"(rx776_pos)
    find_dynamic_lex $P783, "$*PACKAGE"
    unless_null $P783, vivify_890
    get_hll_global $P781, "GLOBAL"
    get_who $P782, $P781
    set $P783, $P782["$PACKAGE"]
    unless_null $P783, vivify_891
    die "Contextual $*PACKAGE not found"
  vivify_891:
  vivify_890:
    store_lex "$*OUTERPACKAGE", $P783
.annotate 'line', 328
    rx776_cur."!cursor_pos"(rx776_pos)
    get_hll_global $P784, "GLOBAL"
    nqp_get_package_through_who $P785, $P784, "PAST"
    get_who $P786, $P785
    set $P787, $P786["Stmts"]
    $P788 = $P787."new"()
    store_lex "$*PACKAGE-SETUP", $P788
.annotate 'line', 329
    rx776_cur."!cursor_pos"(rx776_pos)
    new $P789, "String"
    assign $P789, "grammar"
    store_lex "$*PKGDECL", $P789
.annotate 'line', 330
  # rx subcapture "sym"
    set_addr $I10, rxcap_790_fail
    rx776_cur."!mark_push"(0, rx776_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx776_pos, 7
    gt $I11, rx776_eos, rx776_fail
    sub $I11, rx776_pos, rx776_off
    substr $S10, rx776_tgt, $I11, 7
    ne $S10, "grammar", rx776_fail
    add rx776_pos, 7
    set_addr $I10, rxcap_790_fail
    ($I12, $I11) = rx776_cur."!mark_peek"($I10)
    rx776_cur."!cursor_pos"($I11)
    ($P10) = rx776_cur."!cursor_start"()
    $P10."!cursor_pass"(rx776_pos, "")
    rx776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_790_done
  rxcap_790_fail:
    goto rx776_fail
  rxcap_790_done:
  # rx subrule "package_def" subtype=capture negate=
    rx776_cur."!cursor_pos"(rx776_pos)
    $P10 = rx776_cur."package_def"()
    unless $P10, rx776_fail
    rx776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx776_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx776_cur."!cursor_pass"(rx776_pos, "package_declarator:sym<grammar>")
    if_null rx776_debug, debug_892
    rx776_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx776_pos)
  debug_892:
    .return (rx776_cur)
  rx776_restart:
.annotate 'line', 10
    if_null rx776_debug, debug_893
    rx776_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_893:
  rx776_fail:
    (rx776_rep, rx776_pos, $I10, $P10) = rx776_cur."!mark_fail"(0)
    lt rx776_pos, -1, rx776_done
    eq rx776_pos, -1, rx776_fail
    jump $I10
  rx776_done:
    rx776_cur."!cursor_fail"()
    if_null rx776_debug, debug_894
    rx776_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_894:
    .return (rx776_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1304277427.017") :method
.annotate 'line', 10
    $P778 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P779, "ResizablePMCArray"
    push $P779, $P778
    .return ($P779)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 333
    new $P792, "Undef"
    .lex "$*OUTERPACKAGE", $P792
.annotate 'line', 334
    new $P793, "Undef"
    .lex "$*PACKAGE-SETUP", $P793
.annotate 'line', 335
    new $P794, "Undef"
    .lex "$*PKGDECL", $P794
.annotate 'line', 10
    .local string rx795_tgt
    .local int rx795_pos
    .local int rx795_off
    .local int rx795_eos
    .local int rx795_rep
    .local pmc rx795_cur
    .local pmc rx795_debug
    (rx795_cur, rx795_pos, rx795_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx795_cur
    .local pmc match
    .lex "$/", match
    length rx795_eos, rx795_tgt
    gt rx795_pos, rx795_eos, rx795_done
    set rx795_off, 0
    lt rx795_pos, 2, rx795_start
    sub rx795_off, rx795_pos, 1
    substr rx795_tgt, rx795_tgt, rx795_off
  rx795_start:
    eq $I10, 1, rx795_restart
    if_null rx795_debug, debug_895
    rx795_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan799_done
    goto rxscan799_scan
  rxscan799_loop:
    (rx795_pos) = rx795_cur."from"()
    inc rx795_pos
    rx795_cur."!cursor_from"(rx795_pos)
    ge rx795_pos, rx795_eos, rxscan799_done
  rxscan799_scan:
    set_addr $I10, rxscan799_loop
    rx795_cur."!mark_push"(0, rx795_pos, $I10)
  rxscan799_done:
.annotate 'line', 333
    rx795_cur."!cursor_pos"(rx795_pos)
    find_dynamic_lex $P802, "$*PACKAGE"
    unless_null $P802, vivify_896
    get_hll_global $P800, "GLOBAL"
    get_who $P801, $P800
    set $P802, $P801["$PACKAGE"]
    unless_null $P802, vivify_897
    die "Contextual $*PACKAGE not found"
  vivify_897:
  vivify_896:
    store_lex "$*OUTERPACKAGE", $P802
.annotate 'line', 334
    rx795_cur."!cursor_pos"(rx795_pos)
    get_hll_global $P803, "GLOBAL"
    nqp_get_package_through_who $P804, $P803, "PAST"
    get_who $P805, $P804
    set $P806, $P805["Stmts"]
    $P807 = $P806."new"()
    store_lex "$*PACKAGE-SETUP", $P807
.annotate 'line', 335
    rx795_cur."!cursor_pos"(rx795_pos)
    new $P808, "String"
    assign $P808, "role"
    store_lex "$*PKGDECL", $P808
.annotate 'line', 336
  # rx subcapture "sym"
    set_addr $I10, rxcap_809_fail
    rx795_cur."!mark_push"(0, rx795_pos, $I10)
  # rx literal  "role"
    add $I11, rx795_pos, 4
    gt $I11, rx795_eos, rx795_fail
    sub $I11, rx795_pos, rx795_off
    substr $S10, rx795_tgt, $I11, 4
    ne $S10, "role", rx795_fail
    add rx795_pos, 4
    set_addr $I10, rxcap_809_fail
    ($I12, $I11) = rx795_cur."!mark_peek"($I10)
    rx795_cur."!cursor_pos"($I11)
    ($P10) = rx795_cur."!cursor_start"()
    $P10."!cursor_pass"(rx795_pos, "")
    rx795_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_809_done
  rxcap_809_fail:
    goto rx795_fail
  rxcap_809_done:
  # rx subrule "package_def" subtype=capture negate=
    rx795_cur."!cursor_pos"(rx795_pos)
    $P10 = rx795_cur."package_def"()
    unless $P10, rx795_fail
    rx795_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx795_pos = $P10."pos"()
.annotate 'line', 332
  # rx pass
    rx795_cur."!cursor_pass"(rx795_pos, "package_declarator:sym<role>")
    if_null rx795_debug, debug_898
    rx795_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx795_pos)
  debug_898:
    .return (rx795_cur)
  rx795_restart:
.annotate 'line', 10
    if_null rx795_debug, debug_899
    rx795_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_899:
  rx795_fail:
    (rx795_rep, rx795_pos, $I10, $P10) = rx795_cur."!mark_fail"(0)
    lt rx795_pos, -1, rx795_done
    eq rx795_pos, -1, rx795_fail
    jump $I10
  rx795_done:
    rx795_cur."!cursor_fail"()
    if_null rx795_debug, debug_900
    rx795_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_900:
    .return (rx795_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1304277427.017") :method
.annotate 'line', 10
    $P797 = self."!PREFIX__!subrule"("package_def", "role")
    new $P798, "ResizablePMCArray"
    push $P798, $P797
    .return ($P798)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 339
    new $P811, "Undef"
    .lex "$*OUTERPACKAGE", $P811
.annotate 'line', 340
    new $P812, "Undef"
    .lex "$*PACKAGE-SETUP", $P812
.annotate 'line', 341
    new $P813, "Undef"
    .lex "$*PKGDECL", $P813
.annotate 'line', 10
    .local string rx814_tgt
    .local int rx814_pos
    .local int rx814_off
    .local int rx814_eos
    .local int rx814_rep
    .local pmc rx814_cur
    .local pmc rx814_debug
    (rx814_cur, rx814_pos, rx814_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx814_cur
    .local pmc match
    .lex "$/", match
    length rx814_eos, rx814_tgt
    gt rx814_pos, rx814_eos, rx814_done
    set rx814_off, 0
    lt rx814_pos, 2, rx814_start
    sub rx814_off, rx814_pos, 1
    substr rx814_tgt, rx814_tgt, rx814_off
  rx814_start:
    eq $I10, 1, rx814_restart
    if_null rx814_debug, debug_901
    rx814_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_901:
    $I10 = self.'from'()
    ne $I10, -1, rxscan818_done
    goto rxscan818_scan
  rxscan818_loop:
    (rx814_pos) = rx814_cur."from"()
    inc rx814_pos
    rx814_cur."!cursor_from"(rx814_pos)
    ge rx814_pos, rx814_eos, rxscan818_done
  rxscan818_scan:
    set_addr $I10, rxscan818_loop
    rx814_cur."!mark_push"(0, rx814_pos, $I10)
  rxscan818_done:
.annotate 'line', 339
    rx814_cur."!cursor_pos"(rx814_pos)
    find_dynamic_lex $P821, "$*PACKAGE"
    unless_null $P821, vivify_902
    get_hll_global $P819, "GLOBAL"
    get_who $P820, $P819
    set $P821, $P820["$PACKAGE"]
    unless_null $P821, vivify_903
    die "Contextual $*PACKAGE not found"
  vivify_903:
  vivify_902:
    store_lex "$*OUTERPACKAGE", $P821
.annotate 'line', 340
    rx814_cur."!cursor_pos"(rx814_pos)
    get_hll_global $P822, "GLOBAL"
    nqp_get_package_through_who $P823, $P822, "PAST"
    get_who $P824, $P823
    set $P825, $P824["Stmts"]
    $P826 = $P825."new"()
    store_lex "$*PACKAGE-SETUP", $P826
.annotate 'line', 341
    rx814_cur."!cursor_pos"(rx814_pos)
    new $P827, "String"
    assign $P827, "native"
    store_lex "$*PKGDECL", $P827
.annotate 'line', 342
  # rx subcapture "sym"
    set_addr $I10, rxcap_828_fail
    rx814_cur."!mark_push"(0, rx814_pos, $I10)
  # rx literal  "native"
    add $I11, rx814_pos, 6
    gt $I11, rx814_eos, rx814_fail
    sub $I11, rx814_pos, rx814_off
    substr $S10, rx814_tgt, $I11, 6
    ne $S10, "native", rx814_fail
    add rx814_pos, 6
    set_addr $I10, rxcap_828_fail
    ($I12, $I11) = rx814_cur."!mark_peek"($I10)
    rx814_cur."!cursor_pos"($I11)
    ($P10) = rx814_cur."!cursor_start"()
    $P10."!cursor_pass"(rx814_pos, "")
    rx814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_828_done
  rxcap_828_fail:
    goto rx814_fail
  rxcap_828_done:
  # rx subrule "package_def" subtype=capture negate=
    rx814_cur."!cursor_pos"(rx814_pos)
    $P10 = rx814_cur."package_def"()
    unless $P10, rx814_fail
    rx814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx814_pos = $P10."pos"()
.annotate 'line', 338
  # rx pass
    rx814_cur."!cursor_pass"(rx814_pos, "package_declarator:sym<native>")
    if_null rx814_debug, debug_904
    rx814_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx814_pos)
  debug_904:
    .return (rx814_cur)
  rx814_restart:
.annotate 'line', 10
    if_null rx814_debug, debug_905
    rx814_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_905:
  rx814_fail:
    (rx814_rep, rx814_pos, $I10, $P10) = rx814_cur."!mark_fail"(0)
    lt rx814_pos, -1, rx814_done
    eq rx814_pos, -1, rx814_fail
    jump $I10
  rx814_done:
    rx814_cur."!cursor_fail"()
    if_null rx814_debug, debug_906
    rx814_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_906:
    .return (rx814_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1304277427.017") :method
.annotate 'line', 10
    $P816 = self."!PREFIX__!subrule"("package_def", "native")
    new $P817, "ResizablePMCArray"
    push $P817, $P816
    .return ($P817)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P857 = "154_1304277427.017" 
    capture_lex $P857
.annotate 'line', 346
    new $P830, "Undef"
    .lex "$*PACKAGE", $P830
.annotate 'line', 347
    $P831 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P831
.annotate 'line', 10
    .local string rx832_tgt
    .local int rx832_pos
    .local int rx832_off
    .local int rx832_eos
    .local int rx832_rep
    .local pmc rx832_cur
    .local pmc rx832_debug
    (rx832_cur, rx832_pos, rx832_tgt, $I10) = self."!cursor_start"()
    rx832_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx832_cur
    .local pmc match
    .lex "$/", match
    length rx832_eos, rx832_tgt
    gt rx832_pos, rx832_eos, rx832_done
    set rx832_off, 0
    lt rx832_pos, 2, rx832_start
    sub rx832_off, rx832_pos, 1
    substr rx832_tgt, rx832_tgt, rx832_off
  rx832_start:
    eq $I10, 1, rx832_restart
    if_null rx832_debug, debug_907
    rx832_cur."!cursor_debug"("START", "package_def")
  debug_907:
    $I10 = self.'from'()
    ne $I10, -1, rxscan836_done
    goto rxscan836_scan
  rxscan836_loop:
    (rx832_pos) = rx832_cur."from"()
    inc rx832_pos
    rx832_cur."!cursor_from"(rx832_pos)
    ge rx832_pos, rx832_eos, rxscan836_done
  rxscan836_scan:
    set_addr $I10, rxscan836_loop
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxscan836_done:
.annotate 'line', 345
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 346
    rx832_cur."!cursor_pos"(rx832_pos)
    find_lex $P840, "$*PACKAGE"
    unless_null $P840, vivify_908
    get_hll_global $P838, "GLOBAL"
    get_who $P839, $P838
    set $P840, $P839["$PACKAGE"]
    unless_null $P840, vivify_909
    die "Contextual $*PACKAGE not found"
  vivify_909:
  vivify_908:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 347
    rx832_cur."!cursor_pos"(rx832_pos)
    find_lex $P844, "%*ATTR-CHECK"
    unless_null $P844, vivify_910
    get_hll_global $P842, "GLOBAL"
    get_who $P843, $P842
    set $P844, $P843["%ATTR-CHECK"]
    unless_null $P844, vivify_911
    die "Contextual %*ATTR-CHECK not found"
  vivify_911:
  vivify_910:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 349
  # rx subrule "name" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."name"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 350
  # rx rxquantr847 ** 0..1
    set_addr $I10, rxquantr847_done
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxquantr847_loop:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx832_pos, 2
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 2
    ne $S10, "is", rx832_fail
    add rx832_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx832_pos, 5
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 5
    ne $S10, "repr(", rx832_fail
    add rx832_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."quote_EXPR"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx832_pos, 1
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    ord $I11, rx832_tgt, $I11
    ne $I11, 41, rx832_fail
    add rx832_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    set_addr $I10, rxquantr847_done
    (rx832_rep) = rx832_cur."!mark_commit"($I10)
  rxquantr847_done:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 352
    rx832_cur."!cursor_pos"(rx832_pos)
    find_lex $P854, unicode:"$\x{a2}"
    $P855 = $P854."MATCH"()
    store_lex "$/", $P855
    .const 'Sub' $P857 = "154_1304277427.017" 
    capture_lex $P857
    $P979 = $P857()
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 380
  # rx rxquantr981 ** 0..1
    set_addr $I10, rxquantr981_done
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxquantr981_loop:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx832_pos, 2
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 2
    ne $S10, "is", rx832_fail
    add rx832_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."name"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    set_addr $I10, rxquantr981_done
    (rx832_rep) = rx832_cur."!mark_commit"($I10)
  rxquantr981_done:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 381
  # rx rxquantr986 ** 0..*
    set_addr $I10, rxquantr986_done
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxquantr986_loop:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx832_pos, 4
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 4
    ne $S10, "does", rx832_fail
    add rx832_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."name"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    set_addr $I10, rxquantr986_done
    (rx832_rep) = rx832_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr986_done
    rx832_cur."!mark_push"(rx832_rep, rx832_pos, $I10)
    goto rxquantr986_loop
  rxquantr986_done:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  alt991_0:
.annotate 'line', 382
    set_addr $I10, alt991_1
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
.annotate 'line', 383
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx832_pos, 1
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    ord $I11, rx832_tgt, $I11
    ne $I11, 59, rx832_fail
    add rx832_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."comp_unit"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    goto alt991_end
  alt991_1:
    set_addr $I10, alt991_2
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx832_fail
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."block"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    goto alt991_end
  alt991_2:
.annotate 'line', 385
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."panic"("Malformed package declaration")
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  alt991_end:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 345
  # rx pass
    rx832_cur."!cursor_pass"(rx832_pos, "package_def")
    if_null rx832_debug, debug_979
    rx832_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx832_pos)
  debug_979:
    .return (rx832_cur)
  rx832_restart:
.annotate 'line', 10
    if_null rx832_debug, debug_980
    rx832_cur."!cursor_debug"("NEXT", "package_def")
  debug_980:
  rx832_fail:
    (rx832_rep, rx832_pos, $I10, $P10) = rx832_cur."!mark_fail"(0)
    lt rx832_pos, -1, rx832_done
    eq rx832_pos, -1, rx832_fail
    jump $I10
  rx832_done:
    rx832_cur."!cursor_fail"()
    if_null rx832_debug, debug_981
    rx832_cur."!cursor_debug"("FAIL", "package_def")
  debug_981:
    .return (rx832_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1304277427.017") :method
.annotate 'line', 10
    $P834 = self."!PREFIX__!subrule"("ws", "")
    new $P835, "ResizablePMCArray"
    push $P835, $P834
    .return ($P835)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block856"  :anon :subid("154_1304277427.017") :outer("152_1304277427.017")
.annotate 'line', 355
    $P858 = root_new ['parrot';'Hash']
    .lex "%args", $P858
.annotate 'line', 352
    find_lex $P859, "%args"
    unless_null $P859, vivify_912
    $P859 = root_new ['parrot';'Hash']
  vivify_912:
.annotate 'line', 356
    find_lex $P860, "$/"
    unless_null $P860, vivify_913
    $P860 = root_new ['parrot';'Hash']
  vivify_913:
    set $P861, $P860["name"]
    unless_null $P861, vivify_914
    new $P861, "Undef"
  vivify_914:
    set $S862, $P861
    new $P863, 'String'
    set $P863, $S862
    find_lex $P864, "%args"
    unless_null $P864, vivify_915
    $P864 = root_new ['parrot';'Hash']
    store_lex "%args", $P864
  vivify_915:
    set $P864["name"], $P863
.annotate 'line', 357
    find_lex $P866, "$/"
    unless_null $P866, vivify_916
    $P866 = root_new ['parrot';'Hash']
  vivify_916:
    set $P867, $P866["repr"]
    unless_null $P867, vivify_917
    new $P867, "Undef"
  vivify_917:
    unless $P867, if_865_end
.annotate 'line', 358
    find_lex $P868, "$/"
    unless_null $P868, vivify_918
    $P868 = root_new ['parrot';'Hash']
  vivify_918:
    set $P869, $P868["repr"]
    unless_null $P869, vivify_919
    $P869 = root_new ['parrot';'ResizablePMCArray']
  vivify_919:
    set $P870, $P869[0]
    unless_null $P870, vivify_920
    $P870 = root_new ['parrot';'Hash']
  vivify_920:
    set $P871, $P870["quote_delimited"]
    unless_null $P871, vivify_921
    $P871 = root_new ['parrot';'Hash']
  vivify_921:
    set $P872, $P871["quote_atom"]
    unless_null $P872, vivify_922
    $P872 = root_new ['parrot';'ResizablePMCArray']
  vivify_922:
    set $P873, $P872[0]
    unless_null $P873, vivify_923
    new $P873, "Undef"
  vivify_923:
    set $S874, $P873
    new $P875, 'String'
    set $P875, $S874
    find_lex $P876, "%args"
    unless_null $P876, vivify_924
    $P876 = root_new ['parrot';'Hash']
    store_lex "%args", $P876
  vivify_924:
    set $P876["repr"], $P875
  if_865_end:
.annotate 'line', 360
    find_dynamic_lex $P879, "$*SC"
    unless_null $P879, vivify_925
    get_hll_global $P877, "GLOBAL"
    get_who $P878, $P877
    set $P879, $P878["$SC"]
    unless_null $P879, vivify_926
    die "Contextual $*SC not found"
  vivify_926:
  vivify_925:
    find_dynamic_lex $P882, "$*PKGDECL"
    unless_null $P882, vivify_927
    get_hll_global $P880, "GLOBAL"
    get_who $P881, $P880
    set $P882, $P881["$PKGDECL"]
    unless_null $P882, vivify_928
    die "Contextual $*PKGDECL not found"
  vivify_928:
  vivify_927:
    find_dynamic_lex $P885, "%*HOW"
    unless_null $P885, vivify_929
    get_hll_global $P883, "GLOBAL"
    get_who $P884, $P883
    set $P885, $P884["%HOW"]
    unless_null $P885, vivify_930
    die "Contextual %*HOW not found"
  vivify_930:
  vivify_929:
    set $P886, $P885[$P882]
    unless_null $P886, vivify_931
    new $P886, "Undef"
  vivify_931:
    find_lex $P887, "%args"
    unless_null $P887, vivify_932
    $P887 = root_new ['parrot';'Hash']
  vivify_932:
    $P888 = $P879."pkg_create_mo"($P886, $P887 :flat)
    store_dynamic_lex "$*PACKAGE", $P888
.annotate 'line', 363
    find_dynamic_lex $P895, "$*SCOPE"
    unless_null $P895, vivify_933
    get_hll_global $P893, "GLOBAL"
    get_who $P894, $P893
    set $P895, $P894["$SCOPE"]
    unless_null $P895, vivify_934
    die "Contextual $*SCOPE not found"
  vivify_934:
  vivify_933:
    set $S896, $P895
    iseq $I897, $S896, "our"
    unless $I897, unless_892
    new $P891, 'Integer'
    set $P891, $I897
    goto unless_892_end
  unless_892:
    find_dynamic_lex $P900, "$*SCOPE"
    unless_null $P900, vivify_935
    get_hll_global $P898, "GLOBAL"
    get_who $P899, $P898
    set $P900, $P899["$SCOPE"]
    unless_null $P900, vivify_936
    die "Contextual $*SCOPE not found"
  vivify_936:
  vivify_935:
    set $S901, $P900
    iseq $I902, $S901, ""
    new $P891, 'Integer'
    set $P891, $I902
  unless_892_end:
    if $P891, if_890
.annotate 'line', 369
    find_dynamic_lex $P943, "$*SCOPE"
    unless_null $P943, vivify_937
    get_hll_global $P941, "GLOBAL"
    get_who $P942, $P941
    set $P943, $P942["$SCOPE"]
    unless_null $P943, vivify_938
    die "Contextual $*SCOPE not found"
  vivify_938:
  vivify_937:
    set $S944, $P943
    iseq $I945, $S944, "my"
    if $I945, if_940
.annotate 'line', 376
    find_lex $P972, "$/"
    unless_null $P972, vivify_939
    new $P972, "Undef"
  vivify_939:
    $P973 = $P972."CURSOR"()
    find_dynamic_lex $P976, "$*SCOPE"
    unless_null $P976, vivify_940
    get_hll_global $P974, "GLOBAL"
    get_who $P975, $P974
    set $P976, $P975["$SCOPE"]
    unless_null $P976, vivify_941
    die "Contextual $*SCOPE not found"
  vivify_941:
  vivify_940:
    concat $P977, $P976, " scoped packages are not supported"
    $P978 = $P973."panic"($P977)
.annotate 'line', 375
    set $P939, $P978
.annotate 'line', 369
    goto if_940_end
  if_940:
.annotate 'line', 370
    find_lex $P947, "$/"
    unless_null $P947, vivify_942
    $P947 = root_new ['parrot';'Hash']
  vivify_942:
    set $P948, $P947["name"]
    unless_null $P948, vivify_943
    $P948 = root_new ['parrot';'Hash']
  vivify_943:
    set $P949, $P948["identifier"]
    unless_null $P949, vivify_944
    new $P949, "Undef"
  vivify_944:
    set $N950, $P949
    isne $I951, $N950, 1.0
    unless $I951, if_946_end
.annotate 'line', 371
    find_lex $P952, "$/"
    unless_null $P952, vivify_945
    $P952 = root_new ['parrot';'Hash']
  vivify_945:
    set $P953, $P952["name"]
    unless_null $P953, vivify_946
    new $P953, "Undef"
  vivify_946:
    $P954 = $P953."CURSOR"()
    $P954."panic"("A my scoped package cannot have a multi-part name yet")
  if_946_end:
.annotate 'line', 373
    find_dynamic_lex $P957, "$*SC"
    unless_null $P957, vivify_947
    get_hll_global $P955, "GLOBAL"
    get_who $P956, $P955
    set $P957, $P956["$SC"]
    unless_null $P957, vivify_948
    die "Contextual $*SC not found"
  vivify_948:
  vivify_947:
    get_hll_global $P958, "GLOBAL"
    nqp_get_package_through_who $P959, $P958, "NQP"
    nqp_get_package_through_who $P960, $P959, "Actions"
    get_who $P961, $P960
    set $P962, $P961["@BLOCK"]
    unless_null $P962, vivify_949
    $P962 = root_new ['parrot';'ResizablePMCArray']
  vivify_949:
    set $P963, $P962[0]
    unless_null $P963, vivify_950
    new $P963, "Undef"
  vivify_950:
    find_lex $P964, "$/"
    unless_null $P964, vivify_951
    $P964 = root_new ['parrot';'Hash']
  vivify_951:
    set $P965, $P964["name"]
    unless_null $P965, vivify_952
    $P965 = root_new ['parrot';'Hash']
  vivify_952:
    set $P966, $P965["identifier"]
    unless_null $P966, vivify_953
    $P966 = root_new ['parrot';'ResizablePMCArray']
  vivify_953:
    set $P967, $P966[0]
    unless_null $P967, vivify_954
    new $P967, "Undef"
  vivify_954:
    find_dynamic_lex $P970, "$*PACKAGE"
    unless_null $P970, vivify_955
    get_hll_global $P968, "GLOBAL"
    get_who $P969, $P968
    set $P970, $P969["$PACKAGE"]
    unless_null $P970, vivify_956
    die "Contextual $*PACKAGE not found"
  vivify_956:
  vivify_955:
    $P971 = $P957."install_lexical_symbol"($P963, $P967, $P970)
.annotate 'line', 369
    set $P939, $P971
  if_940_end:
    set $P889, $P939
.annotate 'line', 363
    goto if_890_end
  if_890:
.annotate 'line', 364
    find_dynamic_lex $P905, "$*SC"
    unless_null $P905, vivify_957
    get_hll_global $P903, "GLOBAL"
    get_who $P904, $P903
    set $P905, $P904["$SC"]
    unless_null $P905, vivify_958
    die "Contextual $*SC not found"
  vivify_958:
  vivify_957:
    find_dynamic_lex $P908, "$*OUTERPACKAGE"
    unless_null $P908, vivify_959
    get_hll_global $P906, "GLOBAL"
    get_who $P907, $P906
    set $P908, $P907["$OUTERPACKAGE"]
    unless_null $P908, vivify_960
    die "Contextual $*OUTERPACKAGE not found"
  vivify_960:
  vivify_959:
    find_lex $P909, "$/"
    unless_null $P909, vivify_961
    $P909 = root_new ['parrot';'Hash']
  vivify_961:
    set $P910, $P909["name"]
    unless_null $P910, vivify_962
    $P910 = root_new ['parrot';'Hash']
  vivify_962:
    set $P911, $P910["identifier"]
    unless_null $P911, vivify_963
    new $P911, "Undef"
  vivify_963:
    find_dynamic_lex $P914, "$*PACKAGE"
    unless_null $P914, vivify_964
    get_hll_global $P912, "GLOBAL"
    get_who $P913, $P912
    set $P914, $P913["$PACKAGE"]
    unless_null $P914, vivify_965
    die "Contextual $*PACKAGE not found"
  vivify_965:
  vivify_964:
    $P905."install_package_symbol"($P908, $P911, $P914)
.annotate 'line', 365
    find_lex $P917, "$/"
    unless_null $P917, vivify_966
    $P917 = root_new ['parrot';'Hash']
  vivify_966:
    set $P918, $P917["name"]
    unless_null $P918, vivify_967
    $P918 = root_new ['parrot';'Hash']
  vivify_967:
    set $P919, $P918["identifier"]
    unless_null $P919, vivify_968
    new $P919, "Undef"
  vivify_968:
    set $N920, $P919
    iseq $I921, $N920, 1.0
    if $I921, if_916
    new $P915, 'Integer'
    set $P915, $I921
    goto if_916_end
  if_916:
.annotate 'line', 366
    find_dynamic_lex $P924, "$*SC"
    unless_null $P924, vivify_969
    get_hll_global $P922, "GLOBAL"
    get_who $P923, $P922
    set $P924, $P923["$SC"]
    unless_null $P924, vivify_970
    die "Contextual $*SC not found"
  vivify_970:
  vivify_969:
    get_hll_global $P925, "GLOBAL"
    nqp_get_package_through_who $P926, $P925, "NQP"
    nqp_get_package_through_who $P927, $P926, "Actions"
    get_who $P928, $P927
    set $P929, $P928["@BLOCK"]
    unless_null $P929, vivify_971
    $P929 = root_new ['parrot';'ResizablePMCArray']
  vivify_971:
    set $P930, $P929[0]
    unless_null $P930, vivify_972
    new $P930, "Undef"
  vivify_972:
    find_lex $P931, "$/"
    unless_null $P931, vivify_973
    $P931 = root_new ['parrot';'Hash']
  vivify_973:
    set $P932, $P931["name"]
    unless_null $P932, vivify_974
    $P932 = root_new ['parrot';'Hash']
  vivify_974:
    set $P933, $P932["identifier"]
    unless_null $P933, vivify_975
    $P933 = root_new ['parrot';'ResizablePMCArray']
  vivify_975:
    set $P934, $P933[0]
    unless_null $P934, vivify_976
    new $P934, "Undef"
  vivify_976:
    find_dynamic_lex $P937, "$*PACKAGE"
    unless_null $P937, vivify_977
    get_hll_global $P935, "GLOBAL"
    get_who $P936, $P935
    set $P937, $P936["$PACKAGE"]
    unless_null $P937, vivify_978
    die "Contextual $*PACKAGE not found"
  vivify_978:
  vivify_977:
    $P938 = $P924."install_lexical_symbol"($P930, $P934, $P937)
.annotate 'line', 365
    set $P915, $P938
  if_916_end:
.annotate 'line', 363
    set $P889, $P915
  if_890_end:
.annotate 'line', 352
    .return ($P889)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1304277427.017")
    .param pmc param_1002
.annotate 'line', 389
    .lex "self", param_1002
    $P1003 = param_1002."!protoregex"("scope_declarator")
    .return ($P1003)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1304277427.017")
    .param pmc param_1005
.annotate 'line', 389
    .lex "self", param_1005
    $P1006 = param_1005."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1006)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1008_tgt
    .local int rx1008_pos
    .local int rx1008_off
    .local int rx1008_eos
    .local int rx1008_rep
    .local pmc rx1008_cur
    .local pmc rx1008_debug
    (rx1008_cur, rx1008_pos, rx1008_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1008_cur
    .local pmc match
    .lex "$/", match
    length rx1008_eos, rx1008_tgt
    gt rx1008_pos, rx1008_eos, rx1008_done
    set rx1008_off, 0
    lt rx1008_pos, 2, rx1008_start
    sub rx1008_off, rx1008_pos, 1
    substr rx1008_tgt, rx1008_tgt, rx1008_off
  rx1008_start:
    eq $I10, 1, rx1008_restart
    if_null rx1008_debug, debug_982
    rx1008_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1012_done
    goto rxscan1012_scan
  rxscan1012_loop:
    (rx1008_pos) = rx1008_cur."from"()
    inc rx1008_pos
    rx1008_cur."!cursor_from"(rx1008_pos)
    ge rx1008_pos, rx1008_eos, rxscan1012_done
  rxscan1012_scan:
    set_addr $I10, rxscan1012_loop
    rx1008_cur."!mark_push"(0, rx1008_pos, $I10)
  rxscan1012_done:
.annotate 'line', 390
  # rx subcapture "sym"
    set_addr $I10, rxcap_1013_fail
    rx1008_cur."!mark_push"(0, rx1008_pos, $I10)
  # rx literal  "my"
    add $I11, rx1008_pos, 2
    gt $I11, rx1008_eos, rx1008_fail
    sub $I11, rx1008_pos, rx1008_off
    substr $S10, rx1008_tgt, $I11, 2
    ne $S10, "my", rx1008_fail
    add rx1008_pos, 2
    set_addr $I10, rxcap_1013_fail
    ($I12, $I11) = rx1008_cur."!mark_peek"($I10)
    rx1008_cur."!cursor_pos"($I11)
    ($P10) = rx1008_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1008_pos, "")
    rx1008_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1013_done
  rxcap_1013_fail:
    goto rx1008_fail
  rxcap_1013_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1008_cur."!cursor_pos"(rx1008_pos)
    $P10 = rx1008_cur."scoped"("my")
    unless $P10, rx1008_fail
    rx1008_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1008_pos = $P10."pos"()
  # rx pass
    rx1008_cur."!cursor_pass"(rx1008_pos, "scope_declarator:sym<my>")
    if_null rx1008_debug, debug_983
    rx1008_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1008_pos)
  debug_983:
    .return (rx1008_cur)
  rx1008_restart:
.annotate 'line', 10
    if_null rx1008_debug, debug_984
    rx1008_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_984:
  rx1008_fail:
    (rx1008_rep, rx1008_pos, $I10, $P10) = rx1008_cur."!mark_fail"(0)
    lt rx1008_pos, -1, rx1008_done
    eq rx1008_pos, -1, rx1008_fail
    jump $I10
  rx1008_done:
    rx1008_cur."!cursor_fail"()
    if_null rx1008_debug, debug_985
    rx1008_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_985:
    .return (rx1008_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1304277427.017") :method
.annotate 'line', 10
    $P1010 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1011, "ResizablePMCArray"
    push $P1011, $P1010
    .return ($P1011)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1015_tgt
    .local int rx1015_pos
    .local int rx1015_off
    .local int rx1015_eos
    .local int rx1015_rep
    .local pmc rx1015_cur
    .local pmc rx1015_debug
    (rx1015_cur, rx1015_pos, rx1015_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1015_cur
    .local pmc match
    .lex "$/", match
    length rx1015_eos, rx1015_tgt
    gt rx1015_pos, rx1015_eos, rx1015_done
    set rx1015_off, 0
    lt rx1015_pos, 2, rx1015_start
    sub rx1015_off, rx1015_pos, 1
    substr rx1015_tgt, rx1015_tgt, rx1015_off
  rx1015_start:
    eq $I10, 1, rx1015_restart
    if_null rx1015_debug, debug_986
    rx1015_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1019_done
    goto rxscan1019_scan
  rxscan1019_loop:
    (rx1015_pos) = rx1015_cur."from"()
    inc rx1015_pos
    rx1015_cur."!cursor_from"(rx1015_pos)
    ge rx1015_pos, rx1015_eos, rxscan1019_done
  rxscan1019_scan:
    set_addr $I10, rxscan1019_loop
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxscan1019_done:
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_1020_fail
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx literal  "our"
    add $I11, rx1015_pos, 3
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    substr $S10, rx1015_tgt, $I11, 3
    ne $S10, "our", rx1015_fail
    add rx1015_pos, 3
    set_addr $I10, rxcap_1020_fail
    ($I12, $I11) = rx1015_cur."!mark_peek"($I10)
    rx1015_cur."!cursor_pos"($I11)
    ($P10) = rx1015_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1015_pos, "")
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1020_done
  rxcap_1020_fail:
    goto rx1015_fail
  rxcap_1020_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."scoped"("our")
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1015_pos = $P10."pos"()
  # rx pass
    rx1015_cur."!cursor_pass"(rx1015_pos, "scope_declarator:sym<our>")
    if_null rx1015_debug, debug_987
    rx1015_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1015_pos)
  debug_987:
    .return (rx1015_cur)
  rx1015_restart:
.annotate 'line', 10
    if_null rx1015_debug, debug_988
    rx1015_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_988:
  rx1015_fail:
    (rx1015_rep, rx1015_pos, $I10, $P10) = rx1015_cur."!mark_fail"(0)
    lt rx1015_pos, -1, rx1015_done
    eq rx1015_pos, -1, rx1015_fail
    jump $I10
  rx1015_done:
    rx1015_cur."!cursor_fail"()
    if_null rx1015_debug, debug_989
    rx1015_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_989:
    .return (rx1015_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1304277427.017") :method
.annotate 'line', 10
    $P1017 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1018, "ResizablePMCArray"
    push $P1018, $P1017
    .return ($P1018)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1022_tgt
    .local int rx1022_pos
    .local int rx1022_off
    .local int rx1022_eos
    .local int rx1022_rep
    .local pmc rx1022_cur
    .local pmc rx1022_debug
    (rx1022_cur, rx1022_pos, rx1022_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1022_cur
    .local pmc match
    .lex "$/", match
    length rx1022_eos, rx1022_tgt
    gt rx1022_pos, rx1022_eos, rx1022_done
    set rx1022_off, 0
    lt rx1022_pos, 2, rx1022_start
    sub rx1022_off, rx1022_pos, 1
    substr rx1022_tgt, rx1022_tgt, rx1022_off
  rx1022_start:
    eq $I10, 1, rx1022_restart
    if_null rx1022_debug, debug_990
    rx1022_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1026_done
    goto rxscan1026_scan
  rxscan1026_loop:
    (rx1022_pos) = rx1022_cur."from"()
    inc rx1022_pos
    rx1022_cur."!cursor_from"(rx1022_pos)
    ge rx1022_pos, rx1022_eos, rxscan1026_done
  rxscan1026_scan:
    set_addr $I10, rxscan1026_loop
    rx1022_cur."!mark_push"(0, rx1022_pos, $I10)
  rxscan1026_done:
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_1027_fail
    rx1022_cur."!mark_push"(0, rx1022_pos, $I10)
  # rx literal  "has"
    add $I11, rx1022_pos, 3
    gt $I11, rx1022_eos, rx1022_fail
    sub $I11, rx1022_pos, rx1022_off
    substr $S10, rx1022_tgt, $I11, 3
    ne $S10, "has", rx1022_fail
    add rx1022_pos, 3
    set_addr $I10, rxcap_1027_fail
    ($I12, $I11) = rx1022_cur."!mark_peek"($I10)
    rx1022_cur."!cursor_pos"($I11)
    ($P10) = rx1022_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1022_pos, "")
    rx1022_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1027_done
  rxcap_1027_fail:
    goto rx1022_fail
  rxcap_1027_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1022_cur."!cursor_pos"(rx1022_pos)
    $P10 = rx1022_cur."scoped"("has")
    unless $P10, rx1022_fail
    rx1022_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1022_pos = $P10."pos"()
  # rx pass
    rx1022_cur."!cursor_pass"(rx1022_pos, "scope_declarator:sym<has>")
    if_null rx1022_debug, debug_991
    rx1022_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1022_pos)
  debug_991:
    .return (rx1022_cur)
  rx1022_restart:
.annotate 'line', 10
    if_null rx1022_debug, debug_992
    rx1022_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_992:
  rx1022_fail:
    (rx1022_rep, rx1022_pos, $I10, $P10) = rx1022_cur."!mark_fail"(0)
    lt rx1022_pos, -1, rx1022_done
    eq rx1022_pos, -1, rx1022_fail
    jump $I10
  rx1022_done:
    rx1022_cur."!cursor_fail"()
    if_null rx1022_debug, debug_993
    rx1022_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_993:
    .return (rx1022_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1304277427.017") :method
.annotate 'line', 10
    $P1024 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1025, "ResizablePMCArray"
    push $P1025, $P1024
    .return ($P1025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1304277427.017") :method :outer("12_1304277427.017")
    .param pmc param_1029
.annotate 'line', 394
    .lex "$*SCOPE", param_1029
.annotate 'line', 10
    .local string rx1030_tgt
    .local int rx1030_pos
    .local int rx1030_off
    .local int rx1030_eos
    .local int rx1030_rep
    .local pmc rx1030_cur
    .local pmc rx1030_debug
    (rx1030_cur, rx1030_pos, rx1030_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1030_cur
    .local pmc match
    .lex "$/", match
    length rx1030_eos, rx1030_tgt
    gt rx1030_pos, rx1030_eos, rx1030_done
    set rx1030_off, 0
    lt rx1030_pos, 2, rx1030_start
    sub rx1030_off, rx1030_pos, 1
    substr rx1030_tgt, rx1030_tgt, rx1030_off
  rx1030_start:
    eq $I10, 1, rx1030_restart
    if_null rx1030_debug, debug_994
    rx1030_cur."!cursor_debug"("START", "scoped")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1036_done
    goto rxscan1036_scan
  rxscan1036_loop:
    (rx1030_pos) = rx1030_cur."from"()
    inc rx1030_pos
    rx1030_cur."!cursor_from"(rx1030_pos)
    ge rx1030_pos, rx1030_eos, rxscan1036_done
  rxscan1036_scan:
    set_addr $I10, rxscan1036_loop
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxscan1036_done:
  alt1037_0:
.annotate 'line', 394
    set_addr $I10, alt1037_1
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
.annotate 'line', 395
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."declarator"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1030_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
    goto alt1037_end
  alt1037_1:
    set_addr $I10, alt1037_2
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."multi_declarator"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1030_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
    goto alt1037_end
  alt1037_2:
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."package_declarator"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1030_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  alt1037_end:
.annotate 'line', 394
  # rx pass
    rx1030_cur."!cursor_pass"(rx1030_pos, "scoped")
    if_null rx1030_debug, debug_995
    rx1030_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1030_pos)
  debug_995:
    .return (rx1030_cur)
  rx1030_restart:
.annotate 'line', 10
    if_null rx1030_debug, debug_996
    rx1030_cur."!cursor_debug"("NEXT", "scoped")
  debug_996:
  rx1030_fail:
    (rx1030_rep, rx1030_pos, $I10, $P10) = rx1030_cur."!mark_fail"(0)
    lt rx1030_pos, -1, rx1030_done
    eq rx1030_pos, -1, rx1030_fail
    jump $I10
  rx1030_done:
    rx1030_cur."!cursor_fail"()
    if_null rx1030_debug, debug_997
    rx1030_cur."!cursor_debug"("FAIL", "scoped")
  debug_997:
    .return (rx1030_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1304277427.017") :method
.annotate 'line', 10
    $P1032 = self."!PREFIX__!subrule"("ws", "")
    $P1033 = self."!PREFIX__!subrule"("ws", "")
    $P1034 = self."!PREFIX__!subrule"("ws", "")
    new $P1035, "ResizablePMCArray"
    push $P1035, $P1032
    push $P1035, $P1033
    push $P1035, $P1034
    .return ($P1035)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P1053 = "167_1304277427.017" 
    capture_lex $P1053
    .local string rx1045_tgt
    .local int rx1045_pos
    .local int rx1045_off
    .local int rx1045_eos
    .local int rx1045_rep
    .local pmc rx1045_cur
    .local pmc rx1045_debug
    (rx1045_cur, rx1045_pos, rx1045_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1045_cur
    .local pmc match
    .lex "$/", match
    length rx1045_eos, rx1045_tgt
    gt rx1045_pos, rx1045_eos, rx1045_done
    set rx1045_off, 0
    lt rx1045_pos, 2, rx1045_start
    sub rx1045_off, rx1045_pos, 1
    substr rx1045_tgt, rx1045_tgt, rx1045_off
  rx1045_start:
    eq $I10, 1, rx1045_restart
    if_null rx1045_debug, debug_998
    rx1045_cur."!cursor_debug"("START", "typename")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1049_done
    goto rxscan1049_scan
  rxscan1049_loop:
    (rx1045_pos) = rx1045_cur."from"()
    inc rx1045_pos
    rx1045_cur."!cursor_from"(rx1045_pos)
    ge rx1045_pos, rx1045_eos, rxscan1049_done
  rxscan1049_scan:
    set_addr $I10, rxscan1049_loop
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  rxscan1049_done:
.annotate 'line', 401
  # rx subrule "name" subtype=capture negate=
    rx1045_cur."!cursor_pos"(rx1045_pos)
    $P10 = rx1045_cur."name"()
    unless $P10, rx1045_fail
    rx1045_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1045_pos = $P10."pos"()
.annotate 'line', 402
    rx1045_cur."!cursor_pos"(rx1045_pos)
    find_lex $P1050, unicode:"$\x{a2}"
    $P1051 = $P1050."MATCH"()
    store_lex "$/", $P1051
    .const 'Sub' $P1053 = "167_1304277427.017" 
    capture_lex $P1053
    $P1062 = $P1053()
    unless $P1062, rx1045_fail
.annotate 'line', 400
  # rx pass
    rx1045_cur."!cursor_pass"(rx1045_pos, "typename")
    if_null rx1045_debug, debug_1005
    rx1045_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1045_pos)
  debug_1005:
    .return (rx1045_cur)
  rx1045_restart:
.annotate 'line', 10
    if_null rx1045_debug, debug_1006
    rx1045_cur."!cursor_debug"("NEXT", "typename")
  debug_1006:
  rx1045_fail:
    (rx1045_rep, rx1045_pos, $I10, $P10) = rx1045_cur."!mark_fail"(0)
    lt rx1045_pos, -1, rx1045_done
    eq rx1045_pos, -1, rx1045_fail
    jump $I10
  rx1045_done:
    rx1045_cur."!cursor_fail"()
    if_null rx1045_debug, debug_1007
    rx1045_cur."!cursor_debug"("FAIL", "typename")
  debug_1007:
    .return (rx1045_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1304277427.017") :method
.annotate 'line', 10
    $P1047 = self."!PREFIX__!subrule"("name", "")
    new $P1048, "ResizablePMCArray"
    push $P1048, $P1047
    .return ($P1048)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1052"  :anon :subid("167_1304277427.017") :outer("165_1304277427.017")
.annotate 'line', 402
    find_dynamic_lex $P1056, "$*ACTIONS"
    unless_null $P1056, vivify_999
    get_hll_global $P1054, "GLOBAL"
    get_who $P1055, $P1054
    set $P1056, $P1055["$ACTIONS"]
    unless_null $P1056, vivify_1000
    die "Contextual $*ACTIONS not found"
  vivify_1000:
  vivify_999:
    find_lex $P1057, "$/"
    unless_null $P1057, vivify_1001
    new $P1057, "Undef"
  vivify_1001:
    find_lex $P1058, "$/"
    unless_null $P1058, vivify_1002
    $P1058 = root_new ['parrot';'Hash']
  vivify_1002:
    set $P1059, $P1058["name"]
    unless_null $P1059, vivify_1003
    $P1059 = root_new ['parrot';'Hash']
  vivify_1003:
    set $P1060, $P1059["identifier"]
    unless_null $P1060, vivify_1004
    new $P1060, "Undef"
  vivify_1004:
    $P1061 = $P1056."known_sym"($P1057, $P1060)
    .return ($P1061)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("168_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1064_tgt
    .local int rx1064_pos
    .local int rx1064_off
    .local int rx1064_eos
    .local int rx1064_rep
    .local pmc rx1064_cur
    .local pmc rx1064_debug
    (rx1064_cur, rx1064_pos, rx1064_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1064_cur
    .local pmc match
    .lex "$/", match
    length rx1064_eos, rx1064_tgt
    gt rx1064_pos, rx1064_eos, rx1064_done
    set rx1064_off, 0
    lt rx1064_pos, 2, rx1064_start
    sub rx1064_off, rx1064_pos, 1
    substr rx1064_tgt, rx1064_tgt, rx1064_off
  rx1064_start:
    eq $I10, 1, rx1064_restart
    if_null rx1064_debug, debug_1008
    rx1064_cur."!cursor_debug"("START", "declarator")
  debug_1008:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    (rx1064_pos) = rx1064_cur."from"()
    inc rx1064_pos
    rx1064_cur."!cursor_from"(rx1064_pos)
    ge rx1064_pos, rx1064_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1064_cur."!mark_push"(0, rx1064_pos, $I10)
  rxscan1069_done:
  alt1070_0:
.annotate 'line', 405
    set_addr $I10, alt1070_1
    rx1064_cur."!mark_push"(0, rx1064_pos, $I10)
.annotate 'line', 406
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1064_cur."!cursor_pos"(rx1064_pos)
    $P10 = rx1064_cur."variable_declarator"()
    unless $P10, rx1064_fail
    rx1064_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1064_pos = $P10."pos"()
    goto alt1070_end
  alt1070_1:
.annotate 'line', 407
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1064_cur."!cursor_pos"(rx1064_pos)
    $P10 = rx1064_cur."routine_declarator"()
    unless $P10, rx1064_fail
    rx1064_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1064_pos = $P10."pos"()
  alt1070_end:
.annotate 'line', 405
  # rx pass
    rx1064_cur."!cursor_pass"(rx1064_pos, "declarator")
    if_null rx1064_debug, debug_1009
    rx1064_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1064_pos)
  debug_1009:
    .return (rx1064_cur)
  rx1064_restart:
.annotate 'line', 10
    if_null rx1064_debug, debug_1010
    rx1064_cur."!cursor_debug"("NEXT", "declarator")
  debug_1010:
  rx1064_fail:
    (rx1064_rep, rx1064_pos, $I10, $P10) = rx1064_cur."!mark_fail"(0)
    lt rx1064_pos, -1, rx1064_done
    eq rx1064_pos, -1, rx1064_fail
    jump $I10
  rx1064_done:
    rx1064_cur."!cursor_fail"()
    if_null rx1064_debug, debug_1011
    rx1064_cur."!cursor_debug"("FAIL", "declarator")
  debug_1011:
    .return (rx1064_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("169_1304277427.017") :method
.annotate 'line', 10
    $P1066 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1067 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1068, "ResizablePMCArray"
    push $P1068, $P1066
    push $P1068, $P1067
    .return ($P1068)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("170_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P1088 = "172_1304277427.017" 
    capture_lex $P1088
.annotate 'line', 412
    new $P1072, "Undef"
    .lex "$*IN_DECL", $P1072
.annotate 'line', 10
    .local string rx1073_tgt
    .local int rx1073_pos
    .local int rx1073_off
    .local int rx1073_eos
    .local int rx1073_rep
    .local pmc rx1073_cur
    .local pmc rx1073_debug
    (rx1073_cur, rx1073_pos, rx1073_tgt, $I10) = self."!cursor_start"()
    rx1073_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1073_cur
    .local pmc match
    .lex "$/", match
    length rx1073_eos, rx1073_tgt
    gt rx1073_pos, rx1073_eos, rx1073_done
    set rx1073_off, 0
    lt rx1073_pos, 2, rx1073_start
    sub rx1073_off, rx1073_pos, 1
    substr rx1073_tgt, rx1073_tgt, rx1073_off
  rx1073_start:
    eq $I10, 1, rx1073_restart
    if_null rx1073_debug, debug_1012
    rx1073_cur."!cursor_debug"("START", "variable_declarator")
  debug_1012:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1077_done
    goto rxscan1077_scan
  rxscan1077_loop:
    (rx1073_pos) = rx1073_cur."from"()
    inc rx1073_pos
    rx1073_cur."!cursor_from"(rx1073_pos)
    ge rx1073_pos, rx1073_eos, rxscan1077_done
  rxscan1077_scan:
    set_addr $I10, rxscan1077_loop
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
  rxscan1077_done:
.annotate 'line', 410
  # rx subrule "ws" subtype=method negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."ws"()
    unless $P10, rx1073_fail
    rx1073_pos = $P10."pos"()
.annotate 'line', 411
  # rx rxquantr1079 ** 0..1
    set_addr $I10, rxquantr1079_done
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
  rxquantr1079_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."typename"()
    unless $P10, rx1073_fail
    goto rxsubrule1080_pass
  rxsubrule1080_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1073_fail
  rxsubrule1080_pass:
    set_addr $I10, rxsubrule1080_back
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1073_pos = $P10."pos"()
    set_addr $I10, rxquantr1079_done
    (rx1073_rep) = rx1073_cur."!mark_commit"($I10)
  rxquantr1079_done:
  # rx subrule "ws" subtype=method negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."ws"()
    unless $P10, rx1073_fail
    rx1073_pos = $P10."pos"()
.annotate 'line', 412
    rx1073_cur."!cursor_pos"(rx1073_pos)
    new $P1082, "String"
    assign $P1082, "variable"
    store_lex "$*IN_DECL", $P1082
  # rx subrule "ws" subtype=method negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."ws"()
    unless $P10, rx1073_fail
    rx1073_pos = $P10."pos"()
.annotate 'line', 413
  # rx subrule "variable" subtype=capture negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."variable"()
    unless $P10, rx1073_fail
    rx1073_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1073_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."ws"()
    unless $P10, rx1073_fail
    rx1073_pos = $P10."pos"()
.annotate 'line', 414
    rx1073_cur."!cursor_pos"(rx1073_pos)
    find_lex $P1085, unicode:"$\x{a2}"
    $P1086 = $P1085."MATCH"()
    store_lex "$/", $P1086
    .const 'Sub' $P1088 = "172_1304277427.017" 
    capture_lex $P1088
    $P1090 = $P1088()
  # rx subrule "ws" subtype=method negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."ws"()
    unless $P10, rx1073_fail
    rx1073_pos = $P10."pos"()
.annotate 'line', 410
  # rx pass
    rx1073_cur."!cursor_pass"(rx1073_pos, "variable_declarator")
    if_null rx1073_debug, debug_1013
    rx1073_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1073_pos)
  debug_1013:
    .return (rx1073_cur)
  rx1073_restart:
.annotate 'line', 10
    if_null rx1073_debug, debug_1014
    rx1073_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1014:
  rx1073_fail:
    (rx1073_rep, rx1073_pos, $I10, $P10) = rx1073_cur."!mark_fail"(0)
    lt rx1073_pos, -1, rx1073_done
    eq rx1073_pos, -1, rx1073_fail
    jump $I10
  rx1073_done:
    rx1073_cur."!cursor_fail"()
    if_null rx1073_debug, debug_1015
    rx1073_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1015:
    .return (rx1073_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("171_1304277427.017") :method
.annotate 'line', 10
    $P1075 = self."!PREFIX__!subrule"("ws", "")
    new $P1076, "ResizablePMCArray"
    push $P1076, $P1075
    .return ($P1076)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1087"  :anon :subid("172_1304277427.017") :outer("170_1304277427.017")
.annotate 'line', 414
    new $P1089, "Integer"
    assign $P1089, 0
    store_dynamic_lex "$*IN_DECL", $P1089
    .return ($P1089)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("173_1304277427.017")
    .param pmc param_1093
.annotate 'line', 417
    .lex "self", param_1093
    $P1094 = param_1093."!protoregex"("routine_declarator")
    .return ($P1094)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("174_1304277427.017")
    .param pmc param_1096
.annotate 'line', 417
    .lex "self", param_1096
    $P1097 = param_1096."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1097)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("175_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1099_tgt
    .local int rx1099_pos
    .local int rx1099_off
    .local int rx1099_eos
    .local int rx1099_rep
    .local pmc rx1099_cur
    .local pmc rx1099_debug
    (rx1099_cur, rx1099_pos, rx1099_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1099_cur
    .local pmc match
    .lex "$/", match
    length rx1099_eos, rx1099_tgt
    gt rx1099_pos, rx1099_eos, rx1099_done
    set rx1099_off, 0
    lt rx1099_pos, 2, rx1099_start
    sub rx1099_off, rx1099_pos, 1
    substr rx1099_tgt, rx1099_tgt, rx1099_off
  rx1099_start:
    eq $I10, 1, rx1099_restart
    if_null rx1099_debug, debug_1016
    rx1099_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1016:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1103_done
    goto rxscan1103_scan
  rxscan1103_loop:
    (rx1099_pos) = rx1099_cur."from"()
    inc rx1099_pos
    rx1099_cur."!cursor_from"(rx1099_pos)
    ge rx1099_pos, rx1099_eos, rxscan1103_done
  rxscan1103_scan:
    set_addr $I10, rxscan1103_loop
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
  rxscan1103_done:
.annotate 'line', 418
  # rx subcapture "sym"
    set_addr $I10, rxcap_1104_fail
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1099_pos, 3
    gt $I11, rx1099_eos, rx1099_fail
    sub $I11, rx1099_pos, rx1099_off
    substr $S10, rx1099_tgt, $I11, 3
    ne $S10, "sub", rx1099_fail
    add rx1099_pos, 3
    set_addr $I10, rxcap_1104_fail
    ($I12, $I11) = rx1099_cur."!mark_peek"($I10)
    rx1099_cur."!cursor_pos"($I11)
    ($P10) = rx1099_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1099_pos, "")
    rx1099_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1104_done
  rxcap_1104_fail:
    goto rx1099_fail
  rxcap_1104_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1099_cur."!cursor_pos"(rx1099_pos)
    $P10 = rx1099_cur."routine_def"()
    unless $P10, rx1099_fail
    rx1099_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1099_pos = $P10."pos"()
  # rx pass
    rx1099_cur."!cursor_pass"(rx1099_pos, "routine_declarator:sym<sub>")
    if_null rx1099_debug, debug_1017
    rx1099_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1099_pos)
  debug_1017:
    .return (rx1099_cur)
  rx1099_restart:
.annotate 'line', 10
    if_null rx1099_debug, debug_1018
    rx1099_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1018:
  rx1099_fail:
    (rx1099_rep, rx1099_pos, $I10, $P10) = rx1099_cur."!mark_fail"(0)
    lt rx1099_pos, -1, rx1099_done
    eq rx1099_pos, -1, rx1099_fail
    jump $I10
  rx1099_done:
    rx1099_cur."!cursor_fail"()
    if_null rx1099_debug, debug_1019
    rx1099_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1019:
    .return (rx1099_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("176_1304277427.017") :method
.annotate 'line', 10
    $P1101 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1102, "ResizablePMCArray"
    push $P1102, $P1101
    .return ($P1102)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("177_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1106_tgt
    .local int rx1106_pos
    .local int rx1106_off
    .local int rx1106_eos
    .local int rx1106_rep
    .local pmc rx1106_cur
    .local pmc rx1106_debug
    (rx1106_cur, rx1106_pos, rx1106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1106_cur
    .local pmc match
    .lex "$/", match
    length rx1106_eos, rx1106_tgt
    gt rx1106_pos, rx1106_eos, rx1106_done
    set rx1106_off, 0
    lt rx1106_pos, 2, rx1106_start
    sub rx1106_off, rx1106_pos, 1
    substr rx1106_tgt, rx1106_tgt, rx1106_off
  rx1106_start:
    eq $I10, 1, rx1106_restart
    if_null rx1106_debug, debug_1020
    rx1106_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1020:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1110_done
    goto rxscan1110_scan
  rxscan1110_loop:
    (rx1106_pos) = rx1106_cur."from"()
    inc rx1106_pos
    rx1106_cur."!cursor_from"(rx1106_pos)
    ge rx1106_pos, rx1106_eos, rxscan1110_done
  rxscan1110_scan:
    set_addr $I10, rxscan1110_loop
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxscan1110_done:
.annotate 'line', 419
  # rx subcapture "sym"
    set_addr $I10, rxcap_1111_fail
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  # rx literal  "method"
    add $I11, rx1106_pos, 6
    gt $I11, rx1106_eos, rx1106_fail
    sub $I11, rx1106_pos, rx1106_off
    substr $S10, rx1106_tgt, $I11, 6
    ne $S10, "method", rx1106_fail
    add rx1106_pos, 6
    set_addr $I10, rxcap_1111_fail
    ($I12, $I11) = rx1106_cur."!mark_peek"($I10)
    rx1106_cur."!cursor_pos"($I11)
    ($P10) = rx1106_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1106_pos, "")
    rx1106_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1111_done
  rxcap_1111_fail:
    goto rx1106_fail
  rxcap_1111_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."method_def"()
    unless $P10, rx1106_fail
    rx1106_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1106_pos = $P10."pos"()
  # rx pass
    rx1106_cur."!cursor_pass"(rx1106_pos, "routine_declarator:sym<method>")
    if_null rx1106_debug, debug_1021
    rx1106_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1106_pos)
  debug_1021:
    .return (rx1106_cur)
  rx1106_restart:
.annotate 'line', 10
    if_null rx1106_debug, debug_1022
    rx1106_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1022:
  rx1106_fail:
    (rx1106_rep, rx1106_pos, $I10, $P10) = rx1106_cur."!mark_fail"(0)
    lt rx1106_pos, -1, rx1106_done
    eq rx1106_pos, -1, rx1106_fail
    jump $I10
  rx1106_done:
    rx1106_cur."!cursor_fail"()
    if_null rx1106_debug, debug_1023
    rx1106_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1023:
    .return (rx1106_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("178_1304277427.017") :method
.annotate 'line', 10
    $P1108 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1109, "ResizablePMCArray"
    push $P1109, $P1108
    .return ($P1109)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("179_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 422
    new $P1113, "Undef"
    .lex "$*RETURN_USED", $P1113
.annotate 'line', 10
    .local string rx1114_tgt
    .local int rx1114_pos
    .local int rx1114_off
    .local int rx1114_eos
    .local int rx1114_rep
    .local pmc rx1114_cur
    .local pmc rx1114_debug
    (rx1114_cur, rx1114_pos, rx1114_tgt, $I10) = self."!cursor_start"()
    rx1114_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1114_cur
    .local pmc match
    .lex "$/", match
    length rx1114_eos, rx1114_tgt
    gt rx1114_pos, rx1114_eos, rx1114_done
    set rx1114_off, 0
    lt rx1114_pos, 2, rx1114_start
    sub rx1114_off, rx1114_pos, 1
    substr rx1114_tgt, rx1114_tgt, rx1114_off
  rx1114_start:
    eq $I10, 1, rx1114_restart
    if_null rx1114_debug, debug_1024
    rx1114_cur."!cursor_debug"("START", "routine_def")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1118_done
    goto rxscan1118_scan
  rxscan1118_loop:
    (rx1114_pos) = rx1114_cur."from"()
    inc rx1114_pos
    rx1114_cur."!cursor_from"(rx1114_pos)
    ge rx1114_pos, rx1114_eos, rxscan1118_done
  rxscan1118_scan:
    set_addr $I10, rxscan1118_loop
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
  rxscan1118_done:
.annotate 'line', 421
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
.annotate 'line', 422
    rx1114_cur."!cursor_pos"(rx1114_pos)
    new $P1120, "Integer"
    assign $P1120, 0
    store_lex "$*RETURN_USED", $P1120
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
.annotate 'line', 423
  # rx rxquantr1122 ** 0..1
    set_addr $I10, rxquantr1122_done
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
  rxquantr1122_loop:
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1125_fail
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
  # rx rxquantr1124 ** 0..1
    set_addr $I10, rxquantr1124_done
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
  rxquantr1124_loop:
  # rx literal  "&"
    add $I11, rx1114_pos, 1
    gt $I11, rx1114_eos, rx1114_fail
    sub $I11, rx1114_pos, rx1114_off
    ord $I11, rx1114_tgt, $I11
    ne $I11, 38, rx1114_fail
    add rx1114_pos, 1
    set_addr $I10, rxquantr1124_done
    (rx1114_rep) = rx1114_cur."!mark_commit"($I10)
  rxquantr1124_done:
    set_addr $I10, rxcap_1125_fail
    ($I12, $I11) = rx1114_cur."!mark_peek"($I10)
    rx1114_cur."!cursor_pos"($I11)
    ($P10) = rx1114_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1114_pos, "")
    rx1114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1125_done
  rxcap_1125_fail:
    goto rx1114_fail
  rxcap_1125_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."deflongname"()
    unless $P10, rx1114_fail
    rx1114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1114_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
    set_addr $I10, rxquantr1122_done
    (rx1114_rep) = rx1114_cur."!mark_commit"($I10)
  rxquantr1122_done:
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
.annotate 'line', 424
  # rx subrule "newpad" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."newpad"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  alt1129_0:
.annotate 'line', 425
    set_addr $I10, alt1129_1
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1114_pos, 1
    gt $I11, rx1114_eos, rx1114_fail
    sub $I11, rx1114_pos, rx1114_off
    ord $I11, rx1114_tgt, $I11
    ne $I11, 40, rx1114_fail
    add rx1114_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."signature"()
    unless $P10, rx1114_fail
    rx1114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1114_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1114_pos, 1
    gt $I11, rx1114_eos, rx1114_fail
    sub $I11, rx1114_pos, rx1114_off
    ord $I11, rx1114_tgt, $I11
    ne $I11, 41, rx1114_fail
    add rx1114_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
    goto alt1129_end
  alt1129_1:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  alt1129_end:
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
.annotate 'line', 427
  # rx rxquantr1137 ** 0..*
    set_addr $I10, rxquantr1137_done
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
  rxquantr1137_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."trait"()
    unless $P10, rx1114_fail
    goto rxsubrule1138_pass
  rxsubrule1138_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1114_fail
  rxsubrule1138_pass:
    set_addr $I10, rxsubrule1138_back
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1114_pos = $P10."pos"()
    set_addr $I10, rxquantr1137_done
    (rx1114_rep) = rx1114_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1137_done
    rx1114_cur."!mark_push"(rx1114_rep, rx1114_pos, $I10)
    goto rxquantr1137_loop
  rxquantr1137_done:
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  alt1140_0:
.annotate 'line', 428
    set_addr $I10, alt1140_1
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
.annotate 'line', 429
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."onlystar"()
    unless $P10, rx1114_fail
    rx1114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1114_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
    goto alt1140_end
  alt1140_1:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."blockoid"()
    unless $P10, rx1114_fail
    rx1114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1114_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
  alt1140_end:
.annotate 'line', 431
  # rx subrule "ws" subtype=method negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."ws"()
    unless $P10, rx1114_fail
    rx1114_pos = $P10."pos"()
.annotate 'line', 421
  # rx pass
    rx1114_cur."!cursor_pass"(rx1114_pos, "routine_def")
    if_null rx1114_debug, debug_1025
    rx1114_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1114_pos)
  debug_1025:
    .return (rx1114_cur)
  rx1114_restart:
.annotate 'line', 10
    if_null rx1114_debug, debug_1026
    rx1114_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1026:
  rx1114_fail:
    (rx1114_rep, rx1114_pos, $I10, $P10) = rx1114_cur."!mark_fail"(0)
    lt rx1114_pos, -1, rx1114_done
    eq rx1114_pos, -1, rx1114_fail
    jump $I10
  rx1114_done:
    rx1114_cur."!cursor_fail"()
    if_null rx1114_debug, debug_1027
    rx1114_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1027:
    .return (rx1114_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("180_1304277427.017") :method
.annotate 'line', 10
    $P1116 = self."!PREFIX__!subrule"("ws", "")
    new $P1117, "ResizablePMCArray"
    push $P1117, $P1116
    .return ($P1117)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("181_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P1177 = "183_1304277427.017" 
    capture_lex $P1177
.annotate 'line', 435
    new $P1147, "Undef"
    .lex "$*RETURN_USED", $P1147
.annotate 'line', 436
    new $P1148, "Undef"
    .lex "$*INVOCANT_OK", $P1148
.annotate 'line', 10
    .local string rx1149_tgt
    .local int rx1149_pos
    .local int rx1149_off
    .local int rx1149_eos
    .local int rx1149_rep
    .local pmc rx1149_cur
    .local pmc rx1149_debug
    (rx1149_cur, rx1149_pos, rx1149_tgt, $I10) = self."!cursor_start"()
    rx1149_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1149_cur
    .local pmc match
    .lex "$/", match
    length rx1149_eos, rx1149_tgt
    gt rx1149_pos, rx1149_eos, rx1149_done
    set rx1149_off, 0
    lt rx1149_pos, 2, rx1149_start
    sub rx1149_off, rx1149_pos, 1
    substr rx1149_tgt, rx1149_tgt, rx1149_off
  rx1149_start:
    eq $I10, 1, rx1149_restart
    if_null rx1149_debug, debug_1028
    rx1149_cur."!cursor_debug"("START", "method_def")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1153_done
    goto rxscan1153_scan
  rxscan1153_loop:
    (rx1149_pos) = rx1149_cur."from"()
    inc rx1149_pos
    rx1149_cur."!cursor_from"(rx1149_pos)
    ge rx1149_pos, rx1149_eos, rxscan1153_done
  rxscan1153_scan:
    set_addr $I10, rxscan1153_loop
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  rxscan1153_done:
.annotate 'line', 434
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 435
    rx1149_cur."!cursor_pos"(rx1149_pos)
    new $P1155, "Integer"
    assign $P1155, 0
    store_lex "$*RETURN_USED", $P1155
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 436
    rx1149_cur."!cursor_pos"(rx1149_pos)
    new $P1157, "Integer"
    assign $P1157, 1
    store_lex "$*INVOCANT_OK", $P1157
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 437
  # rx subcapture "private"
    set_addr $I10, rxcap_1160_fail
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  # rx rxquantr1159 ** 0..1
    set_addr $I10, rxquantr1159_done
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  rxquantr1159_loop:
  # rx literal  "!"
    add $I11, rx1149_pos, 1
    gt $I11, rx1149_eos, rx1149_fail
    sub $I11, rx1149_pos, rx1149_off
    ord $I11, rx1149_tgt, $I11
    ne $I11, 33, rx1149_fail
    add rx1149_pos, 1
    set_addr $I10, rxquantr1159_done
    (rx1149_rep) = rx1149_cur."!mark_commit"($I10)
  rxquantr1159_done:
    set_addr $I10, rxcap_1160_fail
    ($I12, $I11) = rx1149_cur."!mark_peek"($I10)
    rx1149_cur."!cursor_pos"($I11)
    ($P10) = rx1149_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1149_pos, "")
    rx1149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1160_done
  rxcap_1160_fail:
    goto rx1149_fail
  rxcap_1160_done:
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 438
  # rx rxquantr1162 ** 0..1
    set_addr $I10, rxquantr1162_done
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  rxquantr1162_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."deflongname"()
    unless $P10, rx1149_fail
    goto rxsubrule1163_pass
  rxsubrule1163_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1149_fail
  rxsubrule1163_pass:
    set_addr $I10, rxsubrule1163_back
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1149_pos = $P10."pos"()
    set_addr $I10, rxquantr1162_done
    (rx1149_rep) = rx1149_cur."!mark_commit"($I10)
  rxquantr1162_done:
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 439
  # rx subrule "newpad" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."newpad"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  alt1166_0:
.annotate 'line', 440
    set_addr $I10, alt1166_1
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1149_pos, 1
    gt $I11, rx1149_eos, rx1149_fail
    sub $I11, rx1149_pos, rx1149_off
    ord $I11, rx1149_tgt, $I11
    ne $I11, 40, rx1149_fail
    add rx1149_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."signature"()
    unless $P10, rx1149_fail
    rx1149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1149_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1149_pos, 1
    gt $I11, rx1149_eos, rx1149_fail
    sub $I11, rx1149_pos, rx1149_off
    ord $I11, rx1149_tgt, $I11
    ne $I11, 41, rx1149_fail
    add rx1149_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
    goto alt1166_end
  alt1166_1:
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  alt1166_end:
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 442
    rx1149_cur."!cursor_pos"(rx1149_pos)
    find_lex $P1174, unicode:"$\x{a2}"
    $P1175 = $P1174."MATCH"()
    store_lex "$/", $P1175
    .const 'Sub' $P1177 = "183_1304277427.017" 
    capture_lex $P1177
    $P1179 = $P1177()
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 443
  # rx rxquantr1181 ** 0..*
    set_addr $I10, rxquantr1181_done
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  rxquantr1181_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."trait"()
    unless $P10, rx1149_fail
    goto rxsubrule1182_pass
  rxsubrule1182_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1149_fail
  rxsubrule1182_pass:
    set_addr $I10, rxsubrule1182_back
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1149_pos = $P10."pos"()
    set_addr $I10, rxquantr1181_done
    (rx1149_rep) = rx1149_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1181_done
    rx1149_cur."!mark_push"(rx1149_rep, rx1149_pos, $I10)
    goto rxquantr1181_loop
  rxquantr1181_done:
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  alt1184_0:
.annotate 'line', 444
    set_addr $I10, alt1184_1
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
.annotate 'line', 445
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."onlystar"()
    unless $P10, rx1149_fail
    rx1149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1149_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
    goto alt1184_end
  alt1184_1:
.annotate 'line', 446
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."blockoid"()
    unless $P10, rx1149_fail
    rx1149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1149_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
  alt1184_end:
.annotate 'line', 447
  # rx subrule "ws" subtype=method negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."ws"()
    unless $P10, rx1149_fail
    rx1149_pos = $P10."pos"()
.annotate 'line', 434
  # rx pass
    rx1149_cur."!cursor_pass"(rx1149_pos, "method_def")
    if_null rx1149_debug, debug_1029
    rx1149_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1149_pos)
  debug_1029:
    .return (rx1149_cur)
  rx1149_restart:
.annotate 'line', 10
    if_null rx1149_debug, debug_1030
    rx1149_cur."!cursor_debug"("NEXT", "method_def")
  debug_1030:
  rx1149_fail:
    (rx1149_rep, rx1149_pos, $I10, $P10) = rx1149_cur."!mark_fail"(0)
    lt rx1149_pos, -1, rx1149_done
    eq rx1149_pos, -1, rx1149_fail
    jump $I10
  rx1149_done:
    rx1149_cur."!cursor_fail"()
    if_null rx1149_debug, debug_1031
    rx1149_cur."!cursor_debug"("FAIL", "method_def")
  debug_1031:
    .return (rx1149_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("182_1304277427.017") :method
.annotate 'line', 10
    $P1151 = self."!PREFIX__!subrule"("ws", "")
    new $P1152, "ResizablePMCArray"
    push $P1152, $P1151
    .return ($P1152)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1176"  :anon :subid("183_1304277427.017") :outer("181_1304277427.017")
.annotate 'line', 442
    new $P1178, "Integer"
    assign $P1178, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1178
    .return ($P1178)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("184_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P1198 = "186_1304277427.017" 
    capture_lex $P1198
    .local string rx1191_tgt
    .local int rx1191_pos
    .local int rx1191_off
    .local int rx1191_eos
    .local int rx1191_rep
    .local pmc rx1191_cur
    .local pmc rx1191_debug
    (rx1191_cur, rx1191_pos, rx1191_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1191_cur
    .local pmc match
    .lex "$/", match
    length rx1191_eos, rx1191_tgt
    gt rx1191_pos, rx1191_eos, rx1191_done
    set rx1191_off, 0
    lt rx1191_pos, 2, rx1191_start
    sub rx1191_off, rx1191_pos, 1
    substr rx1191_tgt, rx1191_tgt, rx1191_off
  rx1191_start:
    eq $I10, 1, rx1191_restart
    if_null rx1191_debug, debug_1032
    rx1191_cur."!cursor_debug"("START", "onlystar")
  debug_1032:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1194_done
    goto rxscan1194_scan
  rxscan1194_loop:
    (rx1191_pos) = rx1191_cur."from"()
    inc rx1191_pos
    rx1191_cur."!cursor_from"(rx1191_pos)
    ge rx1191_pos, rx1191_eos, rxscan1194_done
  rxscan1194_scan:
    set_addr $I10, rxscan1194_loop
    rx1191_cur."!mark_push"(0, rx1191_pos, $I10)
  rxscan1194_done:
.annotate 'line', 451
    rx1191_cur."!cursor_pos"(rx1191_pos)
    find_lex $P1195, unicode:"$\x{a2}"
    $P1196 = $P1195."MATCH"()
    store_lex "$/", $P1196
    .const 'Sub' $P1198 = "186_1304277427.017" 
    capture_lex $P1198
    $P1204 = $P1198()
    unless $P1204, rx1191_fail
.annotate 'line', 452
  # rx literal  "{"
    add $I11, rx1191_pos, 1
    gt $I11, rx1191_eos, rx1191_fail
    sub $I11, rx1191_pos, rx1191_off
    ord $I11, rx1191_tgt, $I11
    ne $I11, 123, rx1191_fail
    add rx1191_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ws"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1191_pos, 1
    gt $I11, rx1191_eos, rx1191_fail
    sub $I11, rx1191_pos, rx1191_off
    ord $I11, rx1191_tgt, $I11
    ne $I11, 42, rx1191_fail
    add rx1191_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ws"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1191_pos, 1
    gt $I11, rx1191_eos, rx1191_fail
    sub $I11, rx1191_pos, rx1191_off
    ord $I11, rx1191_tgt, $I11
    ne $I11, 125, rx1191_fail
    add rx1191_pos, 1
.annotate 'line', 453
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ENDSTMT"()
    unless $P10, rx1191_fail
.annotate 'line', 454
  # rx subrule "finishpad" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."finishpad"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
.annotate 'line', 450
  # rx pass
    rx1191_cur."!cursor_pass"(rx1191_pos, "onlystar")
    if_null rx1191_debug, debug_1035
    rx1191_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1191_pos)
  debug_1035:
    .return (rx1191_cur)
  rx1191_restart:
.annotate 'line', 10
    if_null rx1191_debug, debug_1036
    rx1191_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1036:
  rx1191_fail:
    (rx1191_rep, rx1191_pos, $I10, $P10) = rx1191_cur."!mark_fail"(0)
    lt rx1191_pos, -1, rx1191_done
    eq rx1191_pos, -1, rx1191_fail
    jump $I10
  rx1191_done:
    rx1191_cur."!cursor_fail"()
    if_null rx1191_debug, debug_1037
    rx1191_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1037:
    .return (rx1191_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("185_1304277427.017") :method
.annotate 'line', 10
    new $P1193, "ResizablePMCArray"
    push $P1193, ""
    .return ($P1193)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1197"  :anon :subid("186_1304277427.017") :outer("184_1304277427.017")
.annotate 'line', 451
    find_dynamic_lex $P1201, "$*MULTINESS"
    unless_null $P1201, vivify_1033
    get_hll_global $P1199, "GLOBAL"
    get_who $P1200, $P1199
    set $P1201, $P1200["$MULTINESS"]
    unless_null $P1201, vivify_1034
    die "Contextual $*MULTINESS not found"
  vivify_1034:
  vivify_1033:
    set $S1202, $P1201
    iseq $I1203, $S1202, "proto"
    .return ($I1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("187_1304277427.017")
    .param pmc param_1206
.annotate 'line', 457
    .lex "self", param_1206
    $P1207 = param_1206."!protoregex"("multi_declarator")
    .return ($P1207)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("188_1304277427.017")
    .param pmc param_1209
.annotate 'line', 457
    .lex "self", param_1209
    $P1210 = param_1209."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("189_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 459
    new $P1212, "Undef"
    .lex "$*MULTINESS", $P1212
.annotate 'line', 10
    .local string rx1213_tgt
    .local int rx1213_pos
    .local int rx1213_off
    .local int rx1213_eos
    .local int rx1213_rep
    .local pmc rx1213_cur
    .local pmc rx1213_debug
    (rx1213_cur, rx1213_pos, rx1213_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1213_cur
    .local pmc match
    .lex "$/", match
    length rx1213_eos, rx1213_tgt
    gt rx1213_pos, rx1213_eos, rx1213_done
    set rx1213_off, 0
    lt rx1213_pos, 2, rx1213_start
    sub rx1213_off, rx1213_pos, 1
    substr rx1213_tgt, rx1213_tgt, rx1213_off
  rx1213_start:
    eq $I10, 1, rx1213_restart
    if_null rx1213_debug, debug_1038
    rx1213_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1217_done
    goto rxscan1217_scan
  rxscan1217_loop:
    (rx1213_pos) = rx1213_cur."from"()
    inc rx1213_pos
    rx1213_cur."!cursor_from"(rx1213_pos)
    ge rx1213_pos, rx1213_eos, rxscan1217_done
  rxscan1217_scan:
    set_addr $I10, rxscan1217_loop
    rx1213_cur."!mark_push"(0, rx1213_pos, $I10)
  rxscan1217_done:
.annotate 'line', 459
    rx1213_cur."!cursor_pos"(rx1213_pos)
    new $P1218, "String"
    assign $P1218, "multi"
    store_lex "$*MULTINESS", $P1218
.annotate 'line', 460
  # rx subcapture "sym"
    set_addr $I10, rxcap_1219_fail
    rx1213_cur."!mark_push"(0, rx1213_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1213_pos, 5
    gt $I11, rx1213_eos, rx1213_fail
    sub $I11, rx1213_pos, rx1213_off
    substr $S10, rx1213_tgt, $I11, 5
    ne $S10, "multi", rx1213_fail
    add rx1213_pos, 5
    set_addr $I10, rxcap_1219_fail
    ($I12, $I11) = rx1213_cur."!mark_peek"($I10)
    rx1213_cur."!cursor_pos"($I11)
    ($P10) = rx1213_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1213_pos, "")
    rx1213_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1219_done
  rxcap_1219_fail:
    goto rx1213_fail
  rxcap_1219_done:
.annotate 'line', 461
  # rx subrule "ws" subtype=method negate=
    rx1213_cur."!cursor_pos"(rx1213_pos)
    $P10 = rx1213_cur."ws"()
    unless $P10, rx1213_fail
    rx1213_pos = $P10."pos"()
  alt1220_0:
    set_addr $I10, alt1220_1
    rx1213_cur."!mark_push"(0, rx1213_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1213_cur."!cursor_pos"(rx1213_pos)
    $P10 = rx1213_cur."declarator"()
    unless $P10, rx1213_fail
    rx1213_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1213_pos = $P10."pos"()
    goto alt1220_end
  alt1220_1:
    set_addr $I10, alt1220_2
    rx1213_cur."!mark_push"(0, rx1213_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1213_cur."!cursor_pos"(rx1213_pos)
    $P10 = rx1213_cur."routine_def"()
    unless $P10, rx1213_fail
    rx1213_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1213_pos = $P10."pos"()
    goto alt1220_end
  alt1220_2:
  # rx subrule "panic" subtype=method negate=
    rx1213_cur."!cursor_pos"(rx1213_pos)
    $P10 = rx1213_cur."panic"("Malformed multi")
    unless $P10, rx1213_fail
    rx1213_pos = $P10."pos"()
  alt1220_end:
.annotate 'line', 458
  # rx pass
    rx1213_cur."!cursor_pass"(rx1213_pos, "multi_declarator:sym<multi>")
    if_null rx1213_debug, debug_1039
    rx1213_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1213_pos)
  debug_1039:
    .return (rx1213_cur)
  rx1213_restart:
.annotate 'line', 10
    if_null rx1213_debug, debug_1040
    rx1213_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1040:
  rx1213_fail:
    (rx1213_rep, rx1213_pos, $I10, $P10) = rx1213_cur."!mark_fail"(0)
    lt rx1213_pos, -1, rx1213_done
    eq rx1213_pos, -1, rx1213_fail
    jump $I10
  rx1213_done:
    rx1213_cur."!cursor_fail"()
    if_null rx1213_debug, debug_1041
    rx1213_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1041:
    .return (rx1213_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("190_1304277427.017") :method
.annotate 'line', 10
    $P1215 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1216, "ResizablePMCArray"
    push $P1216, $P1215
    .return ($P1216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("191_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 464
    new $P1222, "Undef"
    .lex "$*MULTINESS", $P1222
.annotate 'line', 10
    .local string rx1223_tgt
    .local int rx1223_pos
    .local int rx1223_off
    .local int rx1223_eos
    .local int rx1223_rep
    .local pmc rx1223_cur
    .local pmc rx1223_debug
    (rx1223_cur, rx1223_pos, rx1223_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1223_cur
    .local pmc match
    .lex "$/", match
    length rx1223_eos, rx1223_tgt
    gt rx1223_pos, rx1223_eos, rx1223_done
    set rx1223_off, 0
    lt rx1223_pos, 2, rx1223_start
    sub rx1223_off, rx1223_pos, 1
    substr rx1223_tgt, rx1223_tgt, rx1223_off
  rx1223_start:
    eq $I10, 1, rx1223_restart
    if_null rx1223_debug, debug_1042
    rx1223_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1227_done
    goto rxscan1227_scan
  rxscan1227_loop:
    (rx1223_pos) = rx1223_cur."from"()
    inc rx1223_pos
    rx1223_cur."!cursor_from"(rx1223_pos)
    ge rx1223_pos, rx1223_eos, rxscan1227_done
  rxscan1227_scan:
    set_addr $I10, rxscan1227_loop
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  rxscan1227_done:
.annotate 'line', 464
    rx1223_cur."!cursor_pos"(rx1223_pos)
    new $P1228, "String"
    assign $P1228, "proto"
    store_lex "$*MULTINESS", $P1228
.annotate 'line', 465
  # rx subcapture "sym"
    set_addr $I10, rxcap_1229_fail
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1223_pos, 5
    gt $I11, rx1223_eos, rx1223_fail
    sub $I11, rx1223_pos, rx1223_off
    substr $S10, rx1223_tgt, $I11, 5
    ne $S10, "proto", rx1223_fail
    add rx1223_pos, 5
    set_addr $I10, rxcap_1229_fail
    ($I12, $I11) = rx1223_cur."!mark_peek"($I10)
    rx1223_cur."!cursor_pos"($I11)
    ($P10) = rx1223_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1223_pos, "")
    rx1223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1229_done
  rxcap_1229_fail:
    goto rx1223_fail
  rxcap_1229_done:
.annotate 'line', 466
  # rx subrule "ws" subtype=method negate=
    rx1223_cur."!cursor_pos"(rx1223_pos)
    $P10 = rx1223_cur."ws"()
    unless $P10, rx1223_fail
    rx1223_pos = $P10."pos"()
  alt1230_0:
    set_addr $I10, alt1230_1
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1223_cur."!cursor_pos"(rx1223_pos)
    $P10 = rx1223_cur."declarator"()
    unless $P10, rx1223_fail
    rx1223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1223_pos = $P10."pos"()
    goto alt1230_end
  alt1230_1:
    set_addr $I10, alt1230_2
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1223_cur."!cursor_pos"(rx1223_pos)
    $P10 = rx1223_cur."routine_def"()
    unless $P10, rx1223_fail
    rx1223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1223_pos = $P10."pos"()
    goto alt1230_end
  alt1230_2:
  # rx subrule "panic" subtype=method negate=
    rx1223_cur."!cursor_pos"(rx1223_pos)
    $P10 = rx1223_cur."panic"("Malformed proto")
    unless $P10, rx1223_fail
    rx1223_pos = $P10."pos"()
  alt1230_end:
.annotate 'line', 463
  # rx pass
    rx1223_cur."!cursor_pass"(rx1223_pos, "multi_declarator:sym<proto>")
    if_null rx1223_debug, debug_1043
    rx1223_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1223_pos)
  debug_1043:
    .return (rx1223_cur)
  rx1223_restart:
.annotate 'line', 10
    if_null rx1223_debug, debug_1044
    rx1223_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1044:
  rx1223_fail:
    (rx1223_rep, rx1223_pos, $I10, $P10) = rx1223_cur."!mark_fail"(0)
    lt rx1223_pos, -1, rx1223_done
    eq rx1223_pos, -1, rx1223_fail
    jump $I10
  rx1223_done:
    rx1223_cur."!cursor_fail"()
    if_null rx1223_debug, debug_1045
    rx1223_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1045:
    .return (rx1223_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("192_1304277427.017") :method
.annotate 'line', 10
    $P1225 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1226, "ResizablePMCArray"
    push $P1226, $P1225
    .return ($P1226)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("193_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 469
    new $P1232, "Undef"
    .lex "$*MULTINESS", $P1232
.annotate 'line', 10
    .local string rx1233_tgt
    .local int rx1233_pos
    .local int rx1233_off
    .local int rx1233_eos
    .local int rx1233_rep
    .local pmc rx1233_cur
    .local pmc rx1233_debug
    (rx1233_cur, rx1233_pos, rx1233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1233_cur
    .local pmc match
    .lex "$/", match
    length rx1233_eos, rx1233_tgt
    gt rx1233_pos, rx1233_eos, rx1233_done
    set rx1233_off, 0
    lt rx1233_pos, 2, rx1233_start
    sub rx1233_off, rx1233_pos, 1
    substr rx1233_tgt, rx1233_tgt, rx1233_off
  rx1233_start:
    eq $I10, 1, rx1233_restart
    if_null rx1233_debug, debug_1046
    rx1233_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1237_done
    goto rxscan1237_scan
  rxscan1237_loop:
    (rx1233_pos) = rx1233_cur."from"()
    inc rx1233_pos
    rx1233_cur."!cursor_from"(rx1233_pos)
    ge rx1233_pos, rx1233_eos, rxscan1237_done
  rxscan1237_scan:
    set_addr $I10, rxscan1237_loop
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  rxscan1237_done:
.annotate 'line', 469
    rx1233_cur."!cursor_pos"(rx1233_pos)
    new $P1238, "String"
    assign $P1238, ""
    store_lex "$*MULTINESS", $P1238
.annotate 'line', 470
  # rx subrule "declarator" subtype=capture negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."declarator"()
    unless $P10, rx1233_fail
    rx1233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1233_pos = $P10."pos"()
.annotate 'line', 468
  # rx pass
    rx1233_cur."!cursor_pass"(rx1233_pos, "multi_declarator:sym<null>")
    if_null rx1233_debug, debug_1047
    rx1233_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1233_pos)
  debug_1047:
    .return (rx1233_cur)
  rx1233_restart:
.annotate 'line', 10
    if_null rx1233_debug, debug_1048
    rx1233_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1048:
  rx1233_fail:
    (rx1233_rep, rx1233_pos, $I10, $P10) = rx1233_cur."!mark_fail"(0)
    lt rx1233_pos, -1, rx1233_done
    eq rx1233_pos, -1, rx1233_fail
    jump $I10
  rx1233_done:
    rx1233_cur."!cursor_fail"()
    if_null rx1233_debug, debug_1049
    rx1233_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1049:
    .return (rx1233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("194_1304277427.017") :method
.annotate 'line', 10
    $P1235 = self."!PREFIX__!subrule"("declarator", "")
    new $P1236, "ResizablePMCArray"
    push $P1236, $P1235
    .return ($P1236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("195_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P1248 = "197_1304277427.017" 
    capture_lex $P1248
    .local string rx1240_tgt
    .local int rx1240_pos
    .local int rx1240_off
    .local int rx1240_eos
    .local int rx1240_rep
    .local pmc rx1240_cur
    .local pmc rx1240_debug
    (rx1240_cur, rx1240_pos, rx1240_tgt, $I10) = self."!cursor_start"()
    rx1240_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1240_cur
    .local pmc match
    .lex "$/", match
    length rx1240_eos, rx1240_tgt
    gt rx1240_pos, rx1240_eos, rx1240_done
    set rx1240_off, 0
    lt rx1240_pos, 2, rx1240_start
    sub rx1240_off, rx1240_pos, 1
    substr rx1240_tgt, rx1240_tgt, rx1240_off
  rx1240_start:
    eq $I10, 1, rx1240_restart
    if_null rx1240_debug, debug_1050
    rx1240_cur."!cursor_debug"("START", "signature")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1243_done
    goto rxscan1243_scan
  rxscan1243_loop:
    (rx1240_pos) = rx1240_cur."from"()
    inc rx1240_pos
    rx1240_cur."!cursor_from"(rx1240_pos)
    ge rx1240_pos, rx1240_eos, rxscan1243_done
  rxscan1243_scan:
    set_addr $I10, rxscan1243_loop
    rx1240_cur."!mark_push"(0, rx1240_pos, $I10)
  rxscan1243_done:
.annotate 'line', 474
  # rx rxquantr1244 ** 0..1
    set_addr $I10, rxquantr1244_done
    rx1240_cur."!mark_push"(0, rx1240_pos, $I10)
  rxquantr1244_loop:
    rx1240_cur."!cursor_pos"(rx1240_pos)
    find_lex $P1245, unicode:"$\x{a2}"
    $P1246 = $P1245."MATCH"()
    store_lex "$/", $P1246
    .const 'Sub' $P1248 = "197_1304277427.017" 
    capture_lex $P1248
    $P1252 = $P1248()
    unless $P1252, rx1240_fail
  # rx subrule "ws" subtype=method negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."ws"()
    unless $P10, rx1240_fail
    rx1240_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."parameter"()
    unless $P10, rx1240_fail
    rx1240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1240_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."ws"()
    unless $P10, rx1240_fail
    rx1240_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1240_pos, 1
    gt $I11, rx1240_eos, rx1240_fail
    sub $I11, rx1240_pos, rx1240_off
    ord $I11, rx1240_tgt, $I11
    ne $I11, 58, rx1240_fail
    add rx1240_pos, 1
    set_addr $I10, rxquantr1244_done
    (rx1240_rep) = rx1240_cur."!mark_commit"($I10)
  rxquantr1244_done:
.annotate 'line', 475
  # rx rxquantr1253 ** 0..1
    set_addr $I10, rxquantr1253_done
    rx1240_cur."!mark_push"(0, rx1240_pos, $I10)
  rxquantr1253_loop:
  # rx rxquantr1254 ** 1..*
    set_addr $I10, rxquantr1254_done
    rx1240_cur."!mark_push"(0, -1, $I10)
  rxquantr1254_loop:
  # rx subrule "ws" subtype=method negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."ws"()
    unless $P10, rx1240_fail
    rx1240_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."parameter"()
    unless $P10, rx1240_fail
    rx1240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1240_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."ws"()
    unless $P10, rx1240_fail
    rx1240_pos = $P10."pos"()
    set_addr $I10, rxquantr1254_done
    (rx1240_rep) = rx1240_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1254_done
    rx1240_cur."!mark_push"(rx1240_rep, rx1240_pos, $I10)
  # rx literal  ","
    add $I11, rx1240_pos, 1
    gt $I11, rx1240_eos, rx1240_fail
    sub $I11, rx1240_pos, rx1240_off
    ord $I11, rx1240_tgt, $I11
    ne $I11, 44, rx1240_fail
    add rx1240_pos, 1
    goto rxquantr1254_loop
  rxquantr1254_done:
    set_addr $I10, rxquantr1253_done
    (rx1240_rep) = rx1240_cur."!mark_commit"($I10)
  rxquantr1253_done:
.annotate 'line', 473
  # rx pass
    rx1240_cur."!cursor_pass"(rx1240_pos, "signature")
    if_null rx1240_debug, debug_1053
    rx1240_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1240_pos)
  debug_1053:
    .return (rx1240_cur)
  rx1240_restart:
.annotate 'line', 10
    if_null rx1240_debug, debug_1054
    rx1240_cur."!cursor_debug"("NEXT", "signature")
  debug_1054:
  rx1240_fail:
    (rx1240_rep, rx1240_pos, $I10, $P10) = rx1240_cur."!mark_fail"(0)
    lt rx1240_pos, -1, rx1240_done
    eq rx1240_pos, -1, rx1240_fail
    jump $I10
  rx1240_done:
    rx1240_cur."!cursor_fail"()
    if_null rx1240_debug, debug_1055
    rx1240_cur."!cursor_debug"("FAIL", "signature")
  debug_1055:
    .return (rx1240_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("196_1304277427.017") :method
.annotate 'line', 10
    new $P1242, "ResizablePMCArray"
    push $P1242, ""
    .return ($P1242)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1247"  :anon :subid("197_1304277427.017") :outer("195_1304277427.017")
.annotate 'line', 474
    find_dynamic_lex $P1251, "$*INVOCANT_OK"
    unless_null $P1251, vivify_1051
    get_hll_global $P1249, "GLOBAL"
    get_who $P1250, $P1249
    set $P1251, $P1250["$INVOCANT_OK"]
    unless_null $P1251, vivify_1052
    die "Contextual $*INVOCANT_OK not found"
  vivify_1052:
  vivify_1051:
    .return ($P1251)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("198_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1256_tgt
    .local int rx1256_pos
    .local int rx1256_off
    .local int rx1256_eos
    .local int rx1256_rep
    .local pmc rx1256_cur
    .local pmc rx1256_debug
    (rx1256_cur, rx1256_pos, rx1256_tgt, $I10) = self."!cursor_start"()
    rx1256_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1256_cur
    .local pmc match
    .lex "$/", match
    length rx1256_eos, rx1256_tgt
    gt rx1256_pos, rx1256_eos, rx1256_done
    set rx1256_off, 0
    lt rx1256_pos, 2, rx1256_start
    sub rx1256_off, rx1256_pos, 1
    substr rx1256_tgt, rx1256_tgt, rx1256_off
  rx1256_start:
    eq $I10, 1, rx1256_restart
    if_null rx1256_debug, debug_1056
    rx1256_cur."!cursor_debug"("START", "parameter")
  debug_1056:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1256_pos) = rx1256_cur."from"()
    inc rx1256_pos
    rx1256_cur."!cursor_from"(rx1256_pos)
    ge rx1256_pos, rx1256_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxscan1259_done:
.annotate 'line', 479
  # rx rxquantr1260 ** 0..*
    set_addr $I10, rxquantr1260_done
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxquantr1260_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."typename"()
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1256_pos = $P10."pos"()
  # rx rxquantr1261 ** 0..1
    set_addr $I10, rxquantr1261_done
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxquantr1261_loop:
  # rx literal  ":"
    add $I11, rx1256_pos, 1
    gt $I11, rx1256_eos, rx1256_fail
    sub $I11, rx1256_pos, rx1256_off
    ord $I11, rx1256_tgt, $I11
    ne $I11, 58, rx1256_fail
    add rx1256_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1262_fail
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1256_pos, rx1256_eos, rx1256_fail
    sub $I10, rx1256_pos, rx1256_off
    substr $S10, rx1256_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1256_fail
    inc rx1256_pos
    set_addr $I10, rxcap_1262_fail
    ($I12, $I11) = rx1256_cur."!mark_peek"($I10)
    rx1256_cur."!cursor_pos"($I11)
    ($P10) = rx1256_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1256_pos, "")
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1262_done
  rxcap_1262_fail:
    goto rx1256_fail
  rxcap_1262_done:
    set_addr $I10, rxquantr1261_done
    (rx1256_rep) = rx1256_cur."!mark_commit"($I10)
  rxquantr1261_done:
  # rx subrule "ws" subtype=method negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."ws"()
    unless $P10, rx1256_fail
    rx1256_pos = $P10."pos"()
    set_addr $I10, rxquantr1260_done
    (rx1256_rep) = rx1256_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1260_done
    rx1256_cur."!mark_push"(rx1256_rep, rx1256_pos, $I10)
    goto rxquantr1260_loop
  rxquantr1260_done:
  alt1263_0:
.annotate 'line', 480
    set_addr $I10, alt1263_1
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
.annotate 'line', 481
  # rx subcapture "quant"
    set_addr $I10, rxcap_1264_fail
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  # rx literal  "*"
    add $I11, rx1256_pos, 1
    gt $I11, rx1256_eos, rx1256_fail
    sub $I11, rx1256_pos, rx1256_off
    ord $I11, rx1256_tgt, $I11
    ne $I11, 42, rx1256_fail
    add rx1256_pos, 1
    set_addr $I10, rxcap_1264_fail
    ($I12, $I11) = rx1256_cur."!mark_peek"($I10)
    rx1256_cur."!cursor_pos"($I11)
    ($P10) = rx1256_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1256_pos, "")
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1264_done
  rxcap_1264_fail:
    goto rx1256_fail
  rxcap_1264_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."param_var"()
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1256_pos = $P10."pos"()
    goto alt1263_end
  alt1263_1:
  alt1265_0:
.annotate 'line', 482
    set_addr $I10, alt1265_1
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."param_var"()
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1256_pos = $P10."pos"()
    goto alt1265_end
  alt1265_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."named_param"()
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1256_pos = $P10."pos"()
  alt1265_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1267_fail
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  alt1266_0:
    set_addr $I10, alt1266_1
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  # rx literal  "?"
    add $I11, rx1256_pos, 1
    gt $I11, rx1256_eos, rx1256_fail
    sub $I11, rx1256_pos, rx1256_off
    ord $I11, rx1256_tgt, $I11
    ne $I11, 63, rx1256_fail
    add rx1256_pos, 1
    goto alt1266_end
  alt1266_1:
    set_addr $I10, alt1266_2
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  # rx literal  "!"
    add $I11, rx1256_pos, 1
    gt $I11, rx1256_eos, rx1256_fail
    sub $I11, rx1256_pos, rx1256_off
    ord $I11, rx1256_tgt, $I11
    ne $I11, 33, rx1256_fail
    add rx1256_pos, 1
    goto alt1266_end
  alt1266_2:
  alt1266_end:
    set_addr $I10, rxcap_1267_fail
    ($I12, $I11) = rx1256_cur."!mark_peek"($I10)
    rx1256_cur."!cursor_pos"($I11)
    ($P10) = rx1256_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1256_pos, "")
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1267_done
  rxcap_1267_fail:
    goto rx1256_fail
  rxcap_1267_done:
  alt1263_end:
.annotate 'line', 484
  # rx rxquantr1268 ** 0..1
    set_addr $I10, rxquantr1268_done
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxquantr1268_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."default_value"()
    unless $P10, rx1256_fail
    goto rxsubrule1269_pass
  rxsubrule1269_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1256_fail
  rxsubrule1269_pass:
    set_addr $I10, rxsubrule1269_back
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1256_pos = $P10."pos"()
    set_addr $I10, rxquantr1268_done
    (rx1256_rep) = rx1256_cur."!mark_commit"($I10)
  rxquantr1268_done:
.annotate 'line', 478
  # rx pass
    rx1256_cur."!cursor_pass"(rx1256_pos, "parameter")
    if_null rx1256_debug, debug_1057
    rx1256_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1256_pos)
  debug_1057:
    .return (rx1256_cur)
  rx1256_restart:
.annotate 'line', 10
    if_null rx1256_debug, debug_1058
    rx1256_cur."!cursor_debug"("NEXT", "parameter")
  debug_1058:
  rx1256_fail:
    (rx1256_rep, rx1256_pos, $I10, $P10) = rx1256_cur."!mark_fail"(0)
    lt rx1256_pos, -1, rx1256_done
    eq rx1256_pos, -1, rx1256_fail
    jump $I10
  rx1256_done:
    rx1256_cur."!cursor_fail"()
    if_null rx1256_debug, debug_1059
    rx1256_cur."!cursor_debug"("FAIL", "parameter")
  debug_1059:
    .return (rx1256_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("199_1304277427.017") :method
.annotate 'line', 10
    new $P1258, "ResizablePMCArray"
    push $P1258, ""
    .return ($P1258)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("200_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1271_tgt
    .local int rx1271_pos
    .local int rx1271_off
    .local int rx1271_eos
    .local int rx1271_rep
    .local pmc rx1271_cur
    .local pmc rx1271_debug
    (rx1271_cur, rx1271_pos, rx1271_tgt, $I10) = self."!cursor_start"()
    rx1271_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1271_cur
    .local pmc match
    .lex "$/", match
    length rx1271_eos, rx1271_tgt
    gt rx1271_pos, rx1271_eos, rx1271_done
    set rx1271_off, 0
    lt rx1271_pos, 2, rx1271_start
    sub rx1271_off, rx1271_pos, 1
    substr rx1271_tgt, rx1271_tgt, rx1271_off
  rx1271_start:
    eq $I10, 1, rx1271_restart
    if_null rx1271_debug, debug_1060
    rx1271_cur."!cursor_debug"("START", "param_var")
  debug_1060:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1275_done
    goto rxscan1275_scan
  rxscan1275_loop:
    (rx1271_pos) = rx1271_cur."from"()
    inc rx1271_pos
    rx1271_cur."!cursor_from"(rx1271_pos)
    ge rx1271_pos, rx1271_eos, rxscan1275_done
  rxscan1275_scan:
    set_addr $I10, rxscan1275_loop
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  rxscan1275_done:
.annotate 'line', 488
  # rx subrule "sigil" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."sigil"()
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1271_pos = $P10."pos"()
  # rx rxquantr1276 ** 0..1
    set_addr $I10, rxquantr1276_done
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  rxquantr1276_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."twigil"()
    unless $P10, rx1271_fail
    goto rxsubrule1277_pass
  rxsubrule1277_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1271_fail
  rxsubrule1277_pass:
    set_addr $I10, rxsubrule1277_back
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1271_pos = $P10."pos"()
    set_addr $I10, rxquantr1276_done
    (rx1271_rep) = rx1271_cur."!mark_commit"($I10)
  rxquantr1276_done:
  alt1278_0:
.annotate 'line', 489
    set_addr $I10, alt1278_1
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."ident"()
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1271_pos = $P10."pos"()
    goto alt1278_end
  alt1278_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1279_fail
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1271_pos, rx1271_eos, rx1271_fail
    sub $I10, rx1271_pos, rx1271_off
    substr $S10, rx1271_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1271_fail
    inc rx1271_pos
    set_addr $I10, rxcap_1279_fail
    ($I12, $I11) = rx1271_cur."!mark_peek"($I10)
    rx1271_cur."!cursor_pos"($I11)
    ($P10) = rx1271_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1271_pos, "")
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1279_done
  rxcap_1279_fail:
    goto rx1271_fail
  rxcap_1279_done:
  alt1278_end:
.annotate 'line', 487
  # rx pass
    rx1271_cur."!cursor_pass"(rx1271_pos, "param_var")
    if_null rx1271_debug, debug_1061
    rx1271_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1271_pos)
  debug_1061:
    .return (rx1271_cur)
  rx1271_restart:
.annotate 'line', 10
    if_null rx1271_debug, debug_1062
    rx1271_cur."!cursor_debug"("NEXT", "param_var")
  debug_1062:
  rx1271_fail:
    (rx1271_rep, rx1271_pos, $I10, $P10) = rx1271_cur."!mark_fail"(0)
    lt rx1271_pos, -1, rx1271_done
    eq rx1271_pos, -1, rx1271_fail
    jump $I10
  rx1271_done:
    rx1271_cur."!cursor_fail"()
    if_null rx1271_debug, debug_1063
    rx1271_cur."!cursor_debug"("FAIL", "param_var")
  debug_1063:
    .return (rx1271_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("201_1304277427.017") :method
.annotate 'line', 10
    $P1273 = self."!PREFIX__!subrule"("sigil", "")
    new $P1274, "ResizablePMCArray"
    push $P1274, $P1273
    .return ($P1274)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("202_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1281_tgt
    .local int rx1281_pos
    .local int rx1281_off
    .local int rx1281_eos
    .local int rx1281_rep
    .local pmc rx1281_cur
    .local pmc rx1281_debug
    (rx1281_cur, rx1281_pos, rx1281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1281_cur
    .local pmc match
    .lex "$/", match
    length rx1281_eos, rx1281_tgt
    gt rx1281_pos, rx1281_eos, rx1281_done
    set rx1281_off, 0
    lt rx1281_pos, 2, rx1281_start
    sub rx1281_off, rx1281_pos, 1
    substr rx1281_tgt, rx1281_tgt, rx1281_off
  rx1281_start:
    eq $I10, 1, rx1281_restart
    if_null rx1281_debug, debug_1064
    rx1281_cur."!cursor_debug"("START", "named_param")
  debug_1064:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1285_done
    goto rxscan1285_scan
  rxscan1285_loop:
    (rx1281_pos) = rx1281_cur."from"()
    inc rx1281_pos
    rx1281_cur."!cursor_from"(rx1281_pos)
    ge rx1281_pos, rx1281_eos, rxscan1285_done
  rxscan1285_scan:
    set_addr $I10, rxscan1285_loop
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  rxscan1285_done:
.annotate 'line', 493
  # rx literal  ":"
    add $I11, rx1281_pos, 1
    gt $I11, rx1281_eos, rx1281_fail
    sub $I11, rx1281_pos, rx1281_off
    ord $I11, rx1281_tgt, $I11
    ne $I11, 58, rx1281_fail
    add rx1281_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1281_cur."!cursor_pos"(rx1281_pos)
    $P10 = rx1281_cur."param_var"()
    unless $P10, rx1281_fail
    rx1281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1281_pos = $P10."pos"()
.annotate 'line', 492
  # rx pass
    rx1281_cur."!cursor_pass"(rx1281_pos, "named_param")
    if_null rx1281_debug, debug_1065
    rx1281_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1281_pos)
  debug_1065:
    .return (rx1281_cur)
  rx1281_restart:
.annotate 'line', 10
    if_null rx1281_debug, debug_1066
    rx1281_cur."!cursor_debug"("NEXT", "named_param")
  debug_1066:
  rx1281_fail:
    (rx1281_rep, rx1281_pos, $I10, $P10) = rx1281_cur."!mark_fail"(0)
    lt rx1281_pos, -1, rx1281_done
    eq rx1281_pos, -1, rx1281_fail
    jump $I10
  rx1281_done:
    rx1281_cur."!cursor_fail"()
    if_null rx1281_debug, debug_1067
    rx1281_cur."!cursor_debug"("FAIL", "named_param")
  debug_1067:
    .return (rx1281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("203_1304277427.017") :method
.annotate 'line', 10
    $P1283 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1284, "ResizablePMCArray"
    push $P1284, $P1283
    .return ($P1284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("204_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1287_tgt
    .local int rx1287_pos
    .local int rx1287_off
    .local int rx1287_eos
    .local int rx1287_rep
    .local pmc rx1287_cur
    .local pmc rx1287_debug
    (rx1287_cur, rx1287_pos, rx1287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1287_cur
    .local pmc match
    .lex "$/", match
    length rx1287_eos, rx1287_tgt
    gt rx1287_pos, rx1287_eos, rx1287_done
    set rx1287_off, 0
    lt rx1287_pos, 2, rx1287_start
    sub rx1287_off, rx1287_pos, 1
    substr rx1287_tgt, rx1287_tgt, rx1287_off
  rx1287_start:
    eq $I10, 1, rx1287_restart
    if_null rx1287_debug, debug_1068
    rx1287_cur."!cursor_debug"("START", "default_value")
  debug_1068:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1291_done
    goto rxscan1291_scan
  rxscan1291_loop:
    (rx1287_pos) = rx1287_cur."from"()
    inc rx1287_pos
    rx1287_cur."!cursor_from"(rx1287_pos)
    ge rx1287_pos, rx1287_eos, rxscan1291_done
  rxscan1291_scan:
    set_addr $I10, rxscan1291_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxscan1291_done:
.annotate 'line', 496
  # rx subrule "ws" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."ws"()
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1287_pos, 1
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    ord $I11, rx1287_tgt, $I11
    ne $I11, 61, rx1287_fail
    add rx1287_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."ws"()
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."EXPR"("i=")
    unless $P10, rx1287_fail
    rx1287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1287_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."ws"()
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  # rx pass
    rx1287_cur."!cursor_pass"(rx1287_pos, "default_value")
    if_null rx1287_debug, debug_1069
    rx1287_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1287_pos)
  debug_1069:
    .return (rx1287_cur)
  rx1287_restart:
.annotate 'line', 10
    if_null rx1287_debug, debug_1070
    rx1287_cur."!cursor_debug"("NEXT", "default_value")
  debug_1070:
  rx1287_fail:
    (rx1287_rep, rx1287_pos, $I10, $P10) = rx1287_cur."!mark_fail"(0)
    lt rx1287_pos, -1, rx1287_done
    eq rx1287_pos, -1, rx1287_fail
    jump $I10
  rx1287_done:
    rx1287_cur."!cursor_fail"()
    if_null rx1287_debug, debug_1071
    rx1287_cur."!cursor_debug"("FAIL", "default_value")
  debug_1071:
    .return (rx1287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("205_1304277427.017") :method
.annotate 'line', 10
    $P1289 = self."!PREFIX__!subrule"("ws", "")
    new $P1290, "ResizablePMCArray"
    push $P1290, $P1289
    .return ($P1290)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("206_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1296_tgt
    .local int rx1296_pos
    .local int rx1296_off
    .local int rx1296_eos
    .local int rx1296_rep
    .local pmc rx1296_cur
    .local pmc rx1296_debug
    (rx1296_cur, rx1296_pos, rx1296_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1296_cur
    .local pmc match
    .lex "$/", match
    length rx1296_eos, rx1296_tgt
    gt rx1296_pos, rx1296_eos, rx1296_done
    set rx1296_off, 0
    lt rx1296_pos, 2, rx1296_start
    sub rx1296_off, rx1296_pos, 1
    substr rx1296_tgt, rx1296_tgt, rx1296_off
  rx1296_start:
    eq $I10, 1, rx1296_restart
    if_null rx1296_debug, debug_1072
    rx1296_cur."!cursor_debug"("START", "trait")
  debug_1072:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1300_done
    goto rxscan1300_scan
  rxscan1300_loop:
    (rx1296_pos) = rx1296_cur."from"()
    inc rx1296_pos
    rx1296_cur."!cursor_from"(rx1296_pos)
    ge rx1296_pos, rx1296_eos, rxscan1300_done
  rxscan1300_scan:
    set_addr $I10, rxscan1300_loop
    rx1296_cur."!mark_push"(0, rx1296_pos, $I10)
  rxscan1300_done:
.annotate 'line', 498
  # rx subrule "ws" subtype=method negate=
    rx1296_cur."!cursor_pos"(rx1296_pos)
    $P10 = rx1296_cur."ws"()
    unless $P10, rx1296_fail
    rx1296_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1296_cur."!cursor_pos"(rx1296_pos)
    $P10 = rx1296_cur."trait_mod"()
    unless $P10, rx1296_fail
    rx1296_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1296_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1296_cur."!cursor_pos"(rx1296_pos)
    $P10 = rx1296_cur."ws"()
    unless $P10, rx1296_fail
    rx1296_pos = $P10."pos"()
  # rx pass
    rx1296_cur."!cursor_pass"(rx1296_pos, "trait")
    if_null rx1296_debug, debug_1073
    rx1296_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1296_pos)
  debug_1073:
    .return (rx1296_cur)
  rx1296_restart:
.annotate 'line', 10
    if_null rx1296_debug, debug_1074
    rx1296_cur."!cursor_debug"("NEXT", "trait")
  debug_1074:
  rx1296_fail:
    (rx1296_rep, rx1296_pos, $I10, $P10) = rx1296_cur."!mark_fail"(0)
    lt rx1296_pos, -1, rx1296_done
    eq rx1296_pos, -1, rx1296_fail
    jump $I10
  rx1296_done:
    rx1296_cur."!cursor_fail"()
    if_null rx1296_debug, debug_1075
    rx1296_cur."!cursor_debug"("FAIL", "trait")
  debug_1075:
    .return (rx1296_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("207_1304277427.017") :method
.annotate 'line', 10
    $P1298 = self."!PREFIX__!subrule"("ws", "")
    new $P1299, "ResizablePMCArray"
    push $P1299, $P1298
    .return ($P1299)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("208_1304277427.017")
    .param pmc param_1304
.annotate 'line', 500
    .lex "self", param_1304
    $P1305 = param_1304."!protoregex"("trait_mod")
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("209_1304277427.017")
    .param pmc param_1307
.annotate 'line', 500
    .lex "self", param_1307
    $P1308 = param_1307."!PREFIX__!protoregex"("trait_mod")
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("210_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    rx1310_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_1076
    rx1310_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1076:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1314_done
    goto rxscan1314_scan
  rxscan1314_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1314_done
  rxscan1314_scan:
    set_addr $I10, rxscan1314_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1314_done:
.annotate 'line', 501
  # rx subcapture "sym"
    set_addr $I10, rxcap_1315_fail
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rx literal  "is"
    add $I11, rx1310_pos, 2
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 2
    ne $S10, "is", rx1310_fail
    add rx1310_pos, 2
    set_addr $I10, rxcap_1315_fail
    ($I12, $I11) = rx1310_cur."!mark_peek"($I10)
    rx1310_cur."!cursor_pos"($I11)
    ($P10) = rx1310_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1310_pos, "")
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1315_done
  rxcap_1315_fail:
    goto rx1310_fail
  rxcap_1315_done:
  # rx subrule "ws" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."ws"()
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."deflongname"()
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1310_pos = $P10."pos"()
  # rx rxquantr1317 ** 0..1
    set_addr $I10, rxquantr1317_done
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxquantr1317_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."circumfix"()
    unless $P10, rx1310_fail
    goto rxsubrule1318_pass
  rxsubrule1318_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1310_fail
  rxsubrule1318_pass:
    set_addr $I10, rxsubrule1318_back
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1310_pos = $P10."pos"()
    set_addr $I10, rxquantr1317_done
    (rx1310_rep) = rx1310_cur."!mark_commit"($I10)
  rxquantr1317_done:
  # rx subrule "ws" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."ws"()
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "trait_mod:sym<is>")
    if_null rx1310_debug, debug_1077
    rx1310_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1310_pos)
  debug_1077:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 10
    if_null rx1310_debug, debug_1078
    rx1310_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1078:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_1079
    rx1310_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1079:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("211_1304277427.017") :method
.annotate 'line', 10
    $P1312 = self."!PREFIX__!subrule"("ws", "is")
    new $P1313, "ResizablePMCArray"
    push $P1313, $P1312
    .return ($P1313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("212_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1321_tgt
    .local int rx1321_pos
    .local int rx1321_off
    .local int rx1321_eos
    .local int rx1321_rep
    .local pmc rx1321_cur
    .local pmc rx1321_debug
    (rx1321_cur, rx1321_pos, rx1321_tgt, $I10) = self."!cursor_start"()
    rx1321_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1321_cur
    .local pmc match
    .lex "$/", match
    length rx1321_eos, rx1321_tgt
    gt rx1321_pos, rx1321_eos, rx1321_done
    set rx1321_off, 0
    lt rx1321_pos, 2, rx1321_start
    sub rx1321_off, rx1321_pos, 1
    substr rx1321_tgt, rx1321_tgt, rx1321_off
  rx1321_start:
    eq $I10, 1, rx1321_restart
    if_null rx1321_debug, debug_1080
    rx1321_cur."!cursor_debug"("START", "regex_declarator")
  debug_1080:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1325_done
    goto rxscan1325_scan
  rxscan1325_loop:
    (rx1321_pos) = rx1321_cur."from"()
    inc rx1321_pos
    rx1321_cur."!cursor_from"(rx1321_pos)
    ge rx1321_pos, rx1321_eos, rxscan1325_done
  rxscan1325_scan:
    set_addr $I10, rxscan1325_loop
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  rxscan1325_done:
.annotate 'line', 503
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  alt1327_0:
.annotate 'line', 504
    set_addr $I10, alt1327_1
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1329_fail
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1321_pos, 5
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 5
    ne $S10, "proto", rx1321_fail
    add rx1321_pos, 5
    set_addr $I10, rxcap_1329_fail
    ($I12, $I11) = rx1321_cur."!mark_peek"($I10)
    rx1321_cur."!cursor_pos"($I11)
    ($P10) = rx1321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1321_pos, "")
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1329_done
  rxcap_1329_fail:
    goto rx1321_fail
  rxcap_1329_done:
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  alt1331_0:
    set_addr $I10, alt1331_1
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1321_pos, 5
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 5
    ne $S10, "regex", rx1321_fail
    add rx1321_pos, 5
    goto alt1331_end
  alt1331_1:
    set_addr $I10, alt1331_2
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "token"
    add $I11, rx1321_pos, 5
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 5
    ne $S10, "token", rx1321_fail
    add rx1321_pos, 5
    goto alt1331_end
  alt1331_2:
  # rx literal  "rule"
    add $I11, rx1321_pos, 4
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 4
    ne $S10, "rule", rx1321_fail
    add rx1321_pos, 4
  alt1331_end:
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 506
  # rx subrule "deflongname" subtype=capture negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."deflongname"()
    unless $P10, rx1321_fail
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  alt1334_0:
.annotate 'line', 507
    set_addr $I10, alt1334_1
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
.annotate 'line', 508
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 123, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1321_pos, 5
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 5
    ne $S10, "<...>", rx1321_fail
    add rx1321_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 125, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ENDSTMT"()
    unless $P10, rx1321_fail
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
    goto alt1334_end
  alt1334_1:
    set_addr $I10, alt1334_2
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
.annotate 'line', 509
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 123, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1321_pos, 3
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 3
    ne $S10, "<*>", rx1321_fail
    add rx1321_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 125, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ENDSTMT"()
    unless $P10, rx1321_fail
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
    goto alt1334_end
  alt1334_2:
.annotate 'line', 510
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  alt1334_end:
.annotate 'line', 511
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 505
    goto alt1327_end
  alt1327_1:
.annotate 'line', 512
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1348_fail
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  alt1347_0:
    set_addr $I10, alt1347_1
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1321_pos, 5
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 5
    ne $S10, "regex", rx1321_fail
    add rx1321_pos, 5
    goto alt1347_end
  alt1347_1:
    set_addr $I10, alt1347_2
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "token"
    add $I11, rx1321_pos, 5
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 5
    ne $S10, "token", rx1321_fail
    add rx1321_pos, 5
    goto alt1347_end
  alt1347_2:
  # rx literal  "rule"
    add $I11, rx1321_pos, 4
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 4
    ne $S10, "rule", rx1321_fail
    add rx1321_pos, 4
  alt1347_end:
    set_addr $I10, rxcap_1348_fail
    ($I12, $I11) = rx1321_cur."!mark_peek"($I10)
    rx1321_cur."!cursor_pos"($I11)
    ($P10) = rx1321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1321_pos, "")
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1348_done
  rxcap_1348_fail:
    goto rx1321_fail
  rxcap_1348_done:
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 513
  # rx subrule "deflongname" subtype=capture negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."deflongname"()
    unless $P10, rx1321_fail
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 514
  # rx subrule "newpad" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."newpad"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 515
  # rx rxquantr1352 ** 0..1
    set_addr $I10, rxquantr1352_done
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  rxquantr1352_loop:
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 40, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."signature"()
    unless $P10, rx1321_fail
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 41, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
    set_addr $I10, rxquantr1352_done
    (rx1321_rep) = rx1321_cur."!mark_commit"($I10)
  rxquantr1352_done:
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 516
  # rx reduce name="regex_declarator" key="open"
    rx1321_cur."!cursor_pos"(rx1321_pos)
    rx1321_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 517
  # rx literal  "{"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 123, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1321_fail
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1321_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 125, rx1321_fail
    add rx1321_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ENDSTMT"()
    unless $P10, rx1321_fail
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
  alt1327_end:
.annotate 'line', 518
  # rx subrule "ws" subtype=method negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."ws"()
    unless $P10, rx1321_fail
    rx1321_pos = $P10."pos"()
.annotate 'line', 503
  # rx pass
    rx1321_cur."!cursor_pass"(rx1321_pos, "regex_declarator")
    if_null rx1321_debug, debug_1081
    rx1321_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1321_pos)
  debug_1081:
    .return (rx1321_cur)
  rx1321_restart:
.annotate 'line', 10
    if_null rx1321_debug, debug_1082
    rx1321_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1082:
  rx1321_fail:
    (rx1321_rep, rx1321_pos, $I10, $P10) = rx1321_cur."!mark_fail"(0)
    lt rx1321_pos, -1, rx1321_done
    eq rx1321_pos, -1, rx1321_fail
    jump $I10
  rx1321_done:
    rx1321_cur."!cursor_fail"()
    if_null rx1321_debug, debug_1083
    rx1321_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1083:
    .return (rx1321_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("213_1304277427.017") :method
.annotate 'line', 10
    $P1323 = self."!PREFIX__!subrule"("ws", "")
    new $P1324, "ResizablePMCArray"
    push $P1324, $P1323
    .return ($P1324)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("214_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1362_tgt
    .local int rx1362_pos
    .local int rx1362_off
    .local int rx1362_eos
    .local int rx1362_rep
    .local pmc rx1362_cur
    .local pmc rx1362_debug
    (rx1362_cur, rx1362_pos, rx1362_tgt, $I10) = self."!cursor_start"()
    rx1362_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1362_cur
    .local pmc match
    .lex "$/", match
    length rx1362_eos, rx1362_tgt
    gt rx1362_pos, rx1362_eos, rx1362_done
    set rx1362_off, 0
    lt rx1362_pos, 2, rx1362_start
    sub rx1362_off, rx1362_pos, 1
    substr rx1362_tgt, rx1362_tgt, rx1362_off
  rx1362_start:
    eq $I10, 1, rx1362_restart
    if_null rx1362_debug, debug_1084
    rx1362_cur."!cursor_debug"("START", "dotty")
  debug_1084:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1366_done
    goto rxscan1366_scan
  rxscan1366_loop:
    (rx1362_pos) = rx1362_cur."from"()
    inc rx1362_pos
    rx1362_cur."!cursor_from"(rx1362_pos)
    ge rx1362_pos, rx1362_eos, rxscan1366_done
  rxscan1366_scan:
    set_addr $I10, rxscan1366_loop
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  rxscan1366_done:
.annotate 'line', 522
  # rx literal  "."
    add $I11, rx1362_pos, 1
    gt $I11, rx1362_eos, rx1362_fail
    sub $I11, rx1362_pos, rx1362_off
    ord $I11, rx1362_tgt, $I11
    ne $I11, 46, rx1362_fail
    add rx1362_pos, 1
  alt1367_0:
.annotate 'line', 523
    set_addr $I10, alt1367_1
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."deflongname"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1362_pos = $P10."pos"()
    goto alt1367_end
  alt1367_1:
.annotate 'line', 524
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1362_pos, rx1362_off
    substr $S10, rx1362_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1362_fail
  # rx subrule "quote" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."quote"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1362_pos = $P10."pos"()
  alt1368_0:
.annotate 'line', 525
    set_addr $I10, alt1368_1
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1362_pos, rx1362_off
    substr $S10, rx1362_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1362_fail
    goto alt1368_end
  alt1368_1:
  # rx subrule "panic" subtype=method negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1362_fail
    rx1362_pos = $P10."pos"()
  alt1368_end:
  alt1367_end:
.annotate 'line', 531
  # rx rxquantr1369 ** 0..1
    set_addr $I10, rxquantr1369_done
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  rxquantr1369_loop:
  alt1370_0:
.annotate 'line', 528
    set_addr $I10, alt1370_1
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
.annotate 'line', 529
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1362_pos, rx1362_off
    substr $S10, rx1362_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1362_fail
  # rx subrule "args" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."args"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1362_pos = $P10."pos"()
    goto alt1370_end
  alt1370_1:
.annotate 'line', 530
  # rx literal  ":"
    add $I11, rx1362_pos, 1
    gt $I11, rx1362_eos, rx1362_fail
    sub $I11, rx1362_pos, rx1362_off
    ord $I11, rx1362_tgt, $I11
    ne $I11, 58, rx1362_fail
    add rx1362_pos, 1
  # rx charclass s
    ge rx1362_pos, rx1362_eos, rx1362_fail
    sub $I10, rx1362_pos, rx1362_off
    is_cclass $I11, 32, rx1362_tgt, $I10
    unless $I11, rx1362_fail
    inc rx1362_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."arglist"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1362_pos = $P10."pos"()
  alt1370_end:
.annotate 'line', 531
    set_addr $I10, rxquantr1369_done
    (rx1362_rep) = rx1362_cur."!mark_commit"($I10)
  rxquantr1369_done:
.annotate 'line', 521
  # rx pass
    rx1362_cur."!cursor_pass"(rx1362_pos, "dotty")
    if_null rx1362_debug, debug_1085
    rx1362_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1362_pos)
  debug_1085:
    .return (rx1362_cur)
  rx1362_restart:
.annotate 'line', 10
    if_null rx1362_debug, debug_1086
    rx1362_cur."!cursor_debug"("NEXT", "dotty")
  debug_1086:
  rx1362_fail:
    (rx1362_rep, rx1362_pos, $I10, $P10) = rx1362_cur."!mark_fail"(0)
    lt rx1362_pos, -1, rx1362_done
    eq rx1362_pos, -1, rx1362_fail
    jump $I10
  rx1362_done:
    rx1362_cur."!cursor_fail"()
    if_null rx1362_debug, debug_1087
    rx1362_cur."!cursor_debug"("FAIL", "dotty")
  debug_1087:
    .return (rx1362_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("215_1304277427.017") :method
.annotate 'line', 10
    $P1364 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1365, "ResizablePMCArray"
    push $P1365, "'"
    push $P1365, "\""
    push $P1365, $P1364
    .return ($P1365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("216_1304277427.017")
    .param pmc param_1372
.annotate 'line', 535
    .lex "self", param_1372
    $P1373 = param_1372."!protoregex"("term")
    .return ($P1373)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("217_1304277427.017")
    .param pmc param_1375
.annotate 'line', 535
    .lex "self", param_1375
    $P1376 = param_1375."!PREFIX__!protoregex"("term")
    .return ($P1376)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("218_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1378_tgt
    .local int rx1378_pos
    .local int rx1378_off
    .local int rx1378_eos
    .local int rx1378_rep
    .local pmc rx1378_cur
    .local pmc rx1378_debug
    (rx1378_cur, rx1378_pos, rx1378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1378_cur
    .local pmc match
    .lex "$/", match
    length rx1378_eos, rx1378_tgt
    gt rx1378_pos, rx1378_eos, rx1378_done
    set rx1378_off, 0
    lt rx1378_pos, 2, rx1378_start
    sub rx1378_off, rx1378_pos, 1
    substr rx1378_tgt, rx1378_tgt, rx1378_off
  rx1378_start:
    eq $I10, 1, rx1378_restart
    if_null rx1378_debug, debug_1088
    rx1378_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1088:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    (rx1378_pos) = rx1378_cur."from"()
    inc rx1378_pos
    rx1378_cur."!cursor_from"(rx1378_pos)
    ge rx1378_pos, rx1378_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  rxscan1381_done:
.annotate 'line', 537
  # rx subcapture "sym"
    set_addr $I10, rxcap_1382_fail
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  # rx literal  "self"
    add $I11, rx1378_pos, 4
    gt $I11, rx1378_eos, rx1378_fail
    sub $I11, rx1378_pos, rx1378_off
    substr $S10, rx1378_tgt, $I11, 4
    ne $S10, "self", rx1378_fail
    add rx1378_pos, 4
    set_addr $I10, rxcap_1382_fail
    ($I12, $I11) = rx1378_cur."!mark_peek"($I10)
    rx1378_cur."!cursor_pos"($I11)
    ($P10) = rx1378_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1378_pos, "")
    rx1378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1382_done
  rxcap_1382_fail:
    goto rx1378_fail
  rxcap_1382_done:
  # rxanchor rwb
    le rx1378_pos, 0, rx1378_fail
    sub $I10, rx1378_pos, rx1378_off
    is_cclass $I11, 8192, rx1378_tgt, $I10
    if $I11, rx1378_fail
    dec $I10
    is_cclass $I11, 8192, rx1378_tgt, $I10
    unless $I11, rx1378_fail
  # rx pass
    rx1378_cur."!cursor_pass"(rx1378_pos, "term:sym<self>")
    if_null rx1378_debug, debug_1089
    rx1378_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1378_pos)
  debug_1089:
    .return (rx1378_cur)
  rx1378_restart:
.annotate 'line', 10
    if_null rx1378_debug, debug_1090
    rx1378_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1090:
  rx1378_fail:
    (rx1378_rep, rx1378_pos, $I10, $P10) = rx1378_cur."!mark_fail"(0)
    lt rx1378_pos, -1, rx1378_done
    eq rx1378_pos, -1, rx1378_fail
    jump $I10
  rx1378_done:
    rx1378_cur."!cursor_fail"()
    if_null rx1378_debug, debug_1091
    rx1378_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1091:
    .return (rx1378_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("219_1304277427.017") :method
.annotate 'line', 10
    new $P1380, "ResizablePMCArray"
    push $P1380, "self"
    .return ($P1380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("220_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1092
    rx1384_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1092:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 540
  # rx subrule "deflongname" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."deflongname"()
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1384_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1384_pos, rx1384_off
    substr $S10, rx1384_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1384_fail
  # rx subrule "args" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."args"()
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1384_pos = $P10."pos"()
.annotate 'line', 539
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "term:sym<identifier>")
    if_null rx1384_debug, debug_1093
    rx1384_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1384_pos)
  debug_1093:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 10
    if_null rx1384_debug, debug_1094
    rx1384_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1094:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1095
    rx1384_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1095:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("221_1304277427.017") :method
.annotate 'line', 10
    $P1386 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("222_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1390_tgt
    .local int rx1390_pos
    .local int rx1390_off
    .local int rx1390_eos
    .local int rx1390_rep
    .local pmc rx1390_cur
    .local pmc rx1390_debug
    (rx1390_cur, rx1390_pos, rx1390_tgt, $I10) = self."!cursor_start"()
    rx1390_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1390_cur
    .local pmc match
    .lex "$/", match
    length rx1390_eos, rx1390_tgt
    gt rx1390_pos, rx1390_eos, rx1390_done
    set rx1390_off, 0
    lt rx1390_pos, 2, rx1390_start
    sub rx1390_off, rx1390_pos, 1
    substr rx1390_tgt, rx1390_tgt, rx1390_off
  rx1390_start:
    eq $I10, 1, rx1390_restart
    if_null rx1390_debug, debug_1096
    rx1390_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1096:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1394_done
    goto rxscan1394_scan
  rxscan1394_loop:
    (rx1390_pos) = rx1390_cur."from"()
    inc rx1390_pos
    rx1390_cur."!cursor_from"(rx1390_pos)
    ge rx1390_pos, rx1390_eos, rxscan1394_done
  rxscan1394_scan:
    set_addr $I10, rxscan1394_loop
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  rxscan1394_done:
.annotate 'line', 544
  # rx subrule "name" subtype=capture negate=
    rx1390_cur."!cursor_pos"(rx1390_pos)
    $P10 = rx1390_cur."name"()
    unless $P10, rx1390_fail
    rx1390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1390_pos = $P10."pos"()
  # rx rxquantr1395 ** 0..1
    set_addr $I10, rxquantr1395_done
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  rxquantr1395_loop:
  # rx subrule "args" subtype=capture negate=
    rx1390_cur."!cursor_pos"(rx1390_pos)
    $P10 = rx1390_cur."args"()
    unless $P10, rx1390_fail
    goto rxsubrule1396_pass
  rxsubrule1396_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1390_fail
  rxsubrule1396_pass:
    set_addr $I10, rxsubrule1396_back
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1390_pos = $P10."pos"()
    set_addr $I10, rxquantr1395_done
    (rx1390_rep) = rx1390_cur."!mark_commit"($I10)
  rxquantr1395_done:
.annotate 'line', 543
  # rx pass
    rx1390_cur."!cursor_pass"(rx1390_pos, "term:sym<name>")
    if_null rx1390_debug, debug_1097
    rx1390_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1390_pos)
  debug_1097:
    .return (rx1390_cur)
  rx1390_restart:
.annotate 'line', 10
    if_null rx1390_debug, debug_1098
    rx1390_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1098:
  rx1390_fail:
    (rx1390_rep, rx1390_pos, $I10, $P10) = rx1390_cur."!mark_fail"(0)
    lt rx1390_pos, -1, rx1390_done
    eq rx1390_pos, -1, rx1390_fail
    jump $I10
  rx1390_done:
    rx1390_cur."!cursor_fail"()
    if_null rx1390_debug, debug_1099
    rx1390_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1099:
    .return (rx1390_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("223_1304277427.017") :method
.annotate 'line', 10
    $P1392 = self."!PREFIX__!subrule"("name", "")
    new $P1393, "ResizablePMCArray"
    push $P1393, $P1392
    .return ($P1393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("224_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    rx1398_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1100
    rx1398_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1100:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1401_done
    goto rxscan1401_scan
  rxscan1401_loop:
    (rx1398_pos) = rx1398_cur."from"()
    inc rx1398_pos
    rx1398_cur."!cursor_from"(rx1398_pos)
    ge rx1398_pos, rx1398_eos, rxscan1401_done
  rxscan1401_scan:
    set_addr $I10, rxscan1401_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1401_done:
.annotate 'line', 548
  # rx literal  "pir::"
    add $I11, rx1398_pos, 5
    gt $I11, rx1398_eos, rx1398_fail
    sub $I11, rx1398_pos, rx1398_off
    substr $S10, rx1398_tgt, $I11, 5
    ne $S10, "pir::", rx1398_fail
    add rx1398_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1402_fail
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1398_pos, rx1398_off
    find_not_cclass $I11, 8192, rx1398_tgt, $I10, rx1398_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1398_fail
    add rx1398_pos, rx1398_off, $I11
    set_addr $I10, rxcap_1402_fail
    ($I12, $I11) = rx1398_cur."!mark_peek"($I10)
    rx1398_cur."!cursor_pos"($I11)
    ($P10) = rx1398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1398_pos, "")
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1402_done
  rxcap_1402_fail:
    goto rx1398_fail
  rxcap_1402_done:
  # rx rxquantr1403 ** 0..1
    set_addr $I10, rxquantr1403_done
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxquantr1403_loop:
  # rx subrule "args" subtype=capture negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."args"()
    unless $P10, rx1398_fail
    goto rxsubrule1404_pass
  rxsubrule1404_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1398_fail
  rxsubrule1404_pass:
    set_addr $I10, rxsubrule1404_back
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1398_pos = $P10."pos"()
    set_addr $I10, rxquantr1403_done
    (rx1398_rep) = rx1398_cur."!mark_commit"($I10)
  rxquantr1403_done:
.annotate 'line', 547
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "term:sym<pir::op>")
    if_null rx1398_debug, debug_1101
    rx1398_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1398_pos)
  debug_1101:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 10
    if_null rx1398_debug, debug_1102
    rx1398_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1102:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1103
    rx1398_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1103:
    .return (rx1398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("225_1304277427.017") :method
.annotate 'line', 10
    new $P1400, "ResizablePMCArray"
    push $P1400, "pir::"
    .return ($P1400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("226_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P1414 = "228_1304277427.017" 
    capture_lex $P1414
    .local string rx1406_tgt
    .local int rx1406_pos
    .local int rx1406_off
    .local int rx1406_eos
    .local int rx1406_rep
    .local pmc rx1406_cur
    .local pmc rx1406_debug
    (rx1406_cur, rx1406_pos, rx1406_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1406_cur
    .local pmc match
    .lex "$/", match
    length rx1406_eos, rx1406_tgt
    gt rx1406_pos, rx1406_eos, rx1406_done
    set rx1406_off, 0
    lt rx1406_pos, 2, rx1406_start
    sub rx1406_off, rx1406_pos, 1
    substr rx1406_tgt, rx1406_tgt, rx1406_off
  rx1406_start:
    eq $I10, 1, rx1406_restart
    if_null rx1406_debug, debug_1104
    rx1406_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1409_done
    goto rxscan1409_scan
  rxscan1409_loop:
    (rx1406_pos) = rx1406_cur."from"()
    inc rx1406_pos
    rx1406_cur."!cursor_from"(rx1406_pos)
    ge rx1406_pos, rx1406_eos, rxscan1409_done
  rxscan1409_scan:
    set_addr $I10, rxscan1409_loop
    rx1406_cur."!mark_push"(0, rx1406_pos, $I10)
  rxscan1409_done:
.annotate 'line', 552
  # rx literal  "{*}"
    add $I11, rx1406_pos, 3
    gt $I11, rx1406_eos, rx1406_fail
    sub $I11, rx1406_pos, rx1406_off
    substr $S10, rx1406_tgt, $I11, 3
    ne $S10, "{*}", rx1406_fail
    add rx1406_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1406_cur."!cursor_pos"(rx1406_pos)
    $P10 = rx1406_cur."ENDSTMT"()
    unless $P10, rx1406_fail
  alt1410_0:
.annotate 'line', 553
    set_addr $I10, alt1410_1
    rx1406_cur."!mark_push"(0, rx1406_pos, $I10)
    rx1406_cur."!cursor_pos"(rx1406_pos)
    find_lex $P1411, unicode:"$\x{a2}"
    $P1412 = $P1411."MATCH"()
    store_lex "$/", $P1412
    .const 'Sub' $P1414 = "228_1304277427.017" 
    capture_lex $P1414
    $P1420 = $P1414()
    unless $P1420, rx1406_fail
    goto alt1410_end
  alt1410_1:
  # rx subrule "panic" subtype=method negate=
    rx1406_cur."!cursor_pos"(rx1406_pos)
    $P10 = rx1406_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1406_fail
    rx1406_pos = $P10."pos"()
  alt1410_end:
.annotate 'line', 551
  # rx pass
    rx1406_cur."!cursor_pass"(rx1406_pos, "term:sym<onlystar>")
    if_null rx1406_debug, debug_1107
    rx1406_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1406_pos)
  debug_1107:
    .return (rx1406_cur)
  rx1406_restart:
.annotate 'line', 10
    if_null rx1406_debug, debug_1108
    rx1406_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1108:
  rx1406_fail:
    (rx1406_rep, rx1406_pos, $I10, $P10) = rx1406_cur."!mark_fail"(0)
    lt rx1406_pos, -1, rx1406_done
    eq rx1406_pos, -1, rx1406_fail
    jump $I10
  rx1406_done:
    rx1406_cur."!cursor_fail"()
    if_null rx1406_debug, debug_1109
    rx1406_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1109:
    .return (rx1406_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("227_1304277427.017") :method
.annotate 'line', 10
    new $P1408, "ResizablePMCArray"
    push $P1408, "{*}"
    .return ($P1408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1413"  :anon :subid("228_1304277427.017") :outer("226_1304277427.017")
.annotate 'line', 553
    find_dynamic_lex $P1417, "$*MULTINESS"
    unless_null $P1417, vivify_1105
    get_hll_global $P1415, "GLOBAL"
    get_who $P1416, $P1415
    set $P1417, $P1416["$MULTINESS"]
    unless_null $P1417, vivify_1106
    die "Contextual $*MULTINESS not found"
  vivify_1106:
  vivify_1105:
    set $S1418, $P1417
    iseq $I1419, $S1418, "proto"
    .return ($I1419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("229_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1422_tgt
    .local int rx1422_pos
    .local int rx1422_off
    .local int rx1422_eos
    .local int rx1422_rep
    .local pmc rx1422_cur
    .local pmc rx1422_debug
    (rx1422_cur, rx1422_pos, rx1422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1422_cur
    .local pmc match
    .lex "$/", match
    length rx1422_eos, rx1422_tgt
    gt rx1422_pos, rx1422_eos, rx1422_done
    set rx1422_off, 0
    lt rx1422_pos, 2, rx1422_start
    sub rx1422_off, rx1422_pos, 1
    substr rx1422_tgt, rx1422_tgt, rx1422_off
  rx1422_start:
    eq $I10, 1, rx1422_restart
    if_null rx1422_debug, debug_1110
    rx1422_cur."!cursor_debug"("START", "args")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1426_done
    goto rxscan1426_scan
  rxscan1426_loop:
    (rx1422_pos) = rx1422_cur."from"()
    inc rx1422_pos
    rx1422_cur."!cursor_from"(rx1422_pos)
    ge rx1422_pos, rx1422_eos, rxscan1426_done
  rxscan1426_scan:
    set_addr $I10, rxscan1426_loop
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
  rxscan1426_done:
.annotate 'line', 557
  # rx literal  "("
    add $I11, rx1422_pos, 1
    gt $I11, rx1422_eos, rx1422_fail
    sub $I11, rx1422_pos, rx1422_off
    ord $I11, rx1422_tgt, $I11
    ne $I11, 40, rx1422_fail
    add rx1422_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."arglist"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1422_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1422_pos, 1
    gt $I11, rx1422_eos, rx1422_fail
    sub $I11, rx1422_pos, rx1422_off
    ord $I11, rx1422_tgt, $I11
    ne $I11, 41, rx1422_fail
    add rx1422_pos, 1
  # rx pass
    rx1422_cur."!cursor_pass"(rx1422_pos, "args")
    if_null rx1422_debug, debug_1111
    rx1422_cur."!cursor_debug"("PASS", "args", " at pos=", rx1422_pos)
  debug_1111:
    .return (rx1422_cur)
  rx1422_restart:
.annotate 'line', 10
    if_null rx1422_debug, debug_1112
    rx1422_cur."!cursor_debug"("NEXT", "args")
  debug_1112:
  rx1422_fail:
    (rx1422_rep, rx1422_pos, $I10, $P10) = rx1422_cur."!mark_fail"(0)
    lt rx1422_pos, -1, rx1422_done
    eq rx1422_pos, -1, rx1422_fail
    jump $I10
  rx1422_done:
    rx1422_cur."!cursor_fail"()
    if_null rx1422_debug, debug_1113
    rx1422_cur."!cursor_debug"("FAIL", "args")
  debug_1113:
    .return (rx1422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("230_1304277427.017") :method
.annotate 'line', 10
    $P1424 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1425, "ResizablePMCArray"
    push $P1425, $P1424
    .return ($P1425)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("231_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1428_tgt
    .local int rx1428_pos
    .local int rx1428_off
    .local int rx1428_eos
    .local int rx1428_rep
    .local pmc rx1428_cur
    .local pmc rx1428_debug
    (rx1428_cur, rx1428_pos, rx1428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1428_cur
    .local pmc match
    .lex "$/", match
    length rx1428_eos, rx1428_tgt
    gt rx1428_pos, rx1428_eos, rx1428_done
    set rx1428_off, 0
    lt rx1428_pos, 2, rx1428_start
    sub rx1428_off, rx1428_pos, 1
    substr rx1428_tgt, rx1428_tgt, rx1428_off
  rx1428_start:
    eq $I10, 1, rx1428_restart
    if_null rx1428_debug, debug_1114
    rx1428_cur."!cursor_debug"("START", "arglist")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1432_done
    goto rxscan1432_scan
  rxscan1432_loop:
    (rx1428_pos) = rx1428_cur."from"()
    inc rx1428_pos
    rx1428_cur."!cursor_from"(rx1428_pos)
    ge rx1428_pos, rx1428_eos, rxscan1432_done
  rxscan1432_scan:
    set_addr $I10, rxscan1432_loop
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxscan1432_done:
.annotate 'line', 561
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
  alt1433_0:
.annotate 'line', 562
    set_addr $I10, alt1433_1
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
.annotate 'line', 563
  # rx subrule "EXPR" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."EXPR"("f=")
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1428_pos = $P10."pos"()
    goto alt1433_end
  alt1433_1:
  alt1433_end:
.annotate 'line', 560
  # rx pass
    rx1428_cur."!cursor_pass"(rx1428_pos, "arglist")
    if_null rx1428_debug, debug_1115
    rx1428_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1428_pos)
  debug_1115:
    .return (rx1428_cur)
  rx1428_restart:
.annotate 'line', 10
    if_null rx1428_debug, debug_1116
    rx1428_cur."!cursor_debug"("NEXT", "arglist")
  debug_1116:
  rx1428_fail:
    (rx1428_rep, rx1428_pos, $I10, $P10) = rx1428_cur."!mark_fail"(0)
    lt rx1428_pos, -1, rx1428_done
    eq rx1428_pos, -1, rx1428_fail
    jump $I10
  rx1428_done:
    rx1428_cur."!cursor_fail"()
    if_null rx1428_debug, debug_1117
    rx1428_cur."!cursor_debug"("FAIL", "arglist")
  debug_1117:
    .return (rx1428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("232_1304277427.017") :method
.annotate 'line', 10
    $P1430 = self."!PREFIX__!subrule"("ws", "")
    new $P1431, "ResizablePMCArray"
    push $P1431, $P1430
    .return ($P1431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("233_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_1118
    rx1435_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1439_done
    goto rxscan1439_scan
  rxscan1439_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1439_done
  rxscan1439_scan:
    set_addr $I10, rxscan1439_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1439_done:
.annotate 'line', 569
  # rx subrule "value" subtype=capture negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."value"()
    unless $P10, rx1435_fail
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1435_pos = $P10."pos"()
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "term:sym<value>")
    if_null rx1435_debug, debug_1119
    rx1435_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1435_pos)
  debug_1119:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 10
    if_null rx1435_debug, debug_1120
    rx1435_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1120:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_1121
    rx1435_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1121:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("234_1304277427.017") :method
.annotate 'line', 10
    $P1437 = self."!PREFIX__!subrule"("value", "")
    new $P1438, "ResizablePMCArray"
    push $P1438, $P1437
    .return ($P1438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("235_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1441_tgt
    .local int rx1441_pos
    .local int rx1441_off
    .local int rx1441_eos
    .local int rx1441_rep
    .local pmc rx1441_cur
    .local pmc rx1441_debug
    (rx1441_cur, rx1441_pos, rx1441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1441_cur
    .local pmc match
    .lex "$/", match
    length rx1441_eos, rx1441_tgt
    gt rx1441_pos, rx1441_eos, rx1441_done
    set rx1441_off, 0
    lt rx1441_pos, 2, rx1441_start
    sub rx1441_off, rx1441_pos, 1
    substr rx1441_tgt, rx1441_tgt, rx1441_off
  rx1441_start:
    eq $I10, 1, rx1441_restart
    if_null rx1441_debug, debug_1122
    rx1441_cur."!cursor_debug"("START", "value")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1446_done
    goto rxscan1446_scan
  rxscan1446_loop:
    (rx1441_pos) = rx1441_cur."from"()
    inc rx1441_pos
    rx1441_cur."!cursor_from"(rx1441_pos)
    ge rx1441_pos, rx1441_eos, rxscan1446_done
  rxscan1446_scan:
    set_addr $I10, rxscan1446_loop
    rx1441_cur."!mark_push"(0, rx1441_pos, $I10)
  rxscan1446_done:
  alt1447_0:
.annotate 'line', 571
    set_addr $I10, alt1447_1
    rx1441_cur."!mark_push"(0, rx1441_pos, $I10)
.annotate 'line', 572
  # rx subrule "quote" subtype=capture negate=
    rx1441_cur."!cursor_pos"(rx1441_pos)
    $P10 = rx1441_cur."quote"()
    unless $P10, rx1441_fail
    rx1441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1441_pos = $P10."pos"()
    goto alt1447_end
  alt1447_1:
.annotate 'line', 573
  # rx subrule "number" subtype=capture negate=
    rx1441_cur."!cursor_pos"(rx1441_pos)
    $P10 = rx1441_cur."number"()
    unless $P10, rx1441_fail
    rx1441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1441_pos = $P10."pos"()
  alt1447_end:
.annotate 'line', 571
  # rx pass
    rx1441_cur."!cursor_pass"(rx1441_pos, "value")
    if_null rx1441_debug, debug_1123
    rx1441_cur."!cursor_debug"("PASS", "value", " at pos=", rx1441_pos)
  debug_1123:
    .return (rx1441_cur)
  rx1441_restart:
.annotate 'line', 10
    if_null rx1441_debug, debug_1124
    rx1441_cur."!cursor_debug"("NEXT", "value")
  debug_1124:
  rx1441_fail:
    (rx1441_rep, rx1441_pos, $I10, $P10) = rx1441_cur."!mark_fail"(0)
    lt rx1441_pos, -1, rx1441_done
    eq rx1441_pos, -1, rx1441_fail
    jump $I10
  rx1441_done:
    rx1441_cur."!cursor_fail"()
    if_null rx1441_debug, debug_1125
    rx1441_cur."!cursor_debug"("FAIL", "value")
  debug_1125:
    .return (rx1441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("236_1304277427.017") :method
.annotate 'line', 10
    $P1443 = self."!PREFIX__!subrule"("number", "")
    $P1444 = self."!PREFIX__!subrule"("quote", "")
    new $P1445, "ResizablePMCArray"
    push $P1445, $P1443
    push $P1445, $P1444
    .return ($P1445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("237_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1126
    rx1449_cur."!cursor_debug"("START", "number")
  debug_1126:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1452_done
    goto rxscan1452_scan
  rxscan1452_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1452_done
  rxscan1452_scan:
    set_addr $I10, rxscan1452_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1452_done:
.annotate 'line', 577
  # rx subcapture "sign"
    set_addr $I10, rxcap_1454_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1449_pos, rx1449_off
    set rx1449_rep, 0
    sub $I12, rx1449_eos, rx1449_pos
    le $I12, 1, rxenumcharlistq1453_loop
    set $I12, 1
  rxenumcharlistq1453_loop:
    le $I12, 0, rxenumcharlistq1453_done
    substr $S10, rx1449_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1453_done
    inc rx1449_rep
  rxenumcharlistq1453_done:
    add rx1449_pos, rx1449_pos, rx1449_rep
    set_addr $I10, rxcap_1454_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1454_done
  rxcap_1454_fail:
    goto rx1449_fail
  rxcap_1454_done:
  alt1455_0:
.annotate 'line', 578
    set_addr $I10, alt1455_1
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."dec_number"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1449_pos = $P10."pos"()
    goto alt1455_end
  alt1455_1:
  # rx subrule "integer" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."integer"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1449_pos = $P10."pos"()
  alt1455_end:
.annotate 'line', 576
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "number")
    if_null rx1449_debug, debug_1127
    rx1449_cur."!cursor_debug"("PASS", "number", " at pos=", rx1449_pos)
  debug_1127:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 10
    if_null rx1449_debug, debug_1128
    rx1449_cur."!cursor_debug"("NEXT", "number")
  debug_1128:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1129
    rx1449_cur."!cursor_debug"("FAIL", "number")
  debug_1129:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("238_1304277427.017") :method
.annotate 'line', 10
    new $P1451, "ResizablePMCArray"
    push $P1451, ""
    .return ($P1451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("239_1304277427.017")
    .param pmc param_1457
.annotate 'line', 581
    .lex "self", param_1457
    $P1458 = param_1457."!protoregex"("quote")
    .return ($P1458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("240_1304277427.017")
    .param pmc param_1460
.annotate 'line', 581
    .lex "self", param_1460
    $P1461 = param_1460."!PREFIX__!protoregex"("quote")
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("241_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1463_tgt
    .local int rx1463_pos
    .local int rx1463_off
    .local int rx1463_eos
    .local int rx1463_rep
    .local pmc rx1463_cur
    .local pmc rx1463_debug
    (rx1463_cur, rx1463_pos, rx1463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1463_cur
    .local pmc match
    .lex "$/", match
    length rx1463_eos, rx1463_tgt
    gt rx1463_pos, rx1463_eos, rx1463_done
    set rx1463_off, 0
    lt rx1463_pos, 2, rx1463_start
    sub rx1463_off, rx1463_pos, 1
    substr rx1463_tgt, rx1463_tgt, rx1463_off
  rx1463_start:
    eq $I10, 1, rx1463_restart
    if_null rx1463_debug, debug_1130
    rx1463_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1466_done
    goto rxscan1466_scan
  rxscan1466_loop:
    (rx1463_pos) = rx1463_cur."from"()
    inc rx1463_pos
    rx1463_cur."!cursor_from"(rx1463_pos)
    ge rx1463_pos, rx1463_eos, rxscan1466_done
  rxscan1466_scan:
    set_addr $I10, rxscan1466_loop
    rx1463_cur."!mark_push"(0, rx1463_pos, $I10)
  rxscan1466_done:
.annotate 'line', 582
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1463_pos, rx1463_off
    substr $S10, rx1463_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1463_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1463_cur."!cursor_pos"(rx1463_pos)
    $P10 = rx1463_cur."quote_EXPR"(":q")
    unless $P10, rx1463_fail
    rx1463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1463_pos = $P10."pos"()
  # rx pass
    rx1463_cur."!cursor_pass"(rx1463_pos, "quote:sym<apos>")
    if_null rx1463_debug, debug_1131
    rx1463_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1463_pos)
  debug_1131:
    .return (rx1463_cur)
  rx1463_restart:
.annotate 'line', 10
    if_null rx1463_debug, debug_1132
    rx1463_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1132:
  rx1463_fail:
    (rx1463_rep, rx1463_pos, $I10, $P10) = rx1463_cur."!mark_fail"(0)
    lt rx1463_pos, -1, rx1463_done
    eq rx1463_pos, -1, rx1463_fail
    jump $I10
  rx1463_done:
    rx1463_cur."!cursor_fail"()
    if_null rx1463_debug, debug_1133
    rx1463_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1133:
    .return (rx1463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("242_1304277427.017") :method
.annotate 'line', 10
    new $P1465, "ResizablePMCArray"
    push $P1465, "'"
    .return ($P1465)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("243_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1134
    rx1468_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1471_done
    goto rxscan1471_scan
  rxscan1471_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1471_done
  rxscan1471_scan:
    set_addr $I10, rxscan1471_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1471_done:
.annotate 'line', 583
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1468_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."quote_EXPR"(":qq")
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "quote:sym<dblq>")
    if_null rx1468_debug, debug_1135
    rx1468_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1468_pos)
  debug_1135:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 10
    if_null rx1468_debug, debug_1136
    rx1468_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1136:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1137
    rx1468_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1137:
    .return (rx1468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("244_1304277427.017") :method
.annotate 'line', 10
    new $P1470, "ResizablePMCArray"
    push $P1470, "\""
    .return ($P1470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("245_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1473_tgt
    .local int rx1473_pos
    .local int rx1473_off
    .local int rx1473_eos
    .local int rx1473_rep
    .local pmc rx1473_cur
    .local pmc rx1473_debug
    (rx1473_cur, rx1473_pos, rx1473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1473_cur
    .local pmc match
    .lex "$/", match
    length rx1473_eos, rx1473_tgt
    gt rx1473_pos, rx1473_eos, rx1473_done
    set rx1473_off, 0
    lt rx1473_pos, 2, rx1473_start
    sub rx1473_off, rx1473_pos, 1
    substr rx1473_tgt, rx1473_tgt, rx1473_off
  rx1473_start:
    eq $I10, 1, rx1473_restart
    if_null rx1473_debug, debug_1138
    rx1473_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1138:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1477_done
    goto rxscan1477_scan
  rxscan1477_loop:
    (rx1473_pos) = rx1473_cur."from"()
    inc rx1473_pos
    rx1473_cur."!cursor_from"(rx1473_pos)
    ge rx1473_pos, rx1473_eos, rxscan1477_done
  rxscan1477_scan:
    set_addr $I10, rxscan1477_loop
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  rxscan1477_done:
.annotate 'line', 584
  # rx subcapture "sym"
    set_addr $I10, rxcap_1478_fail
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  # rx literal  "q"
    add $I11, rx1473_pos, 1
    gt $I11, rx1473_eos, rx1473_fail
    sub $I11, rx1473_pos, rx1473_off
    ord $I11, rx1473_tgt, $I11
    ne $I11, 113, rx1473_fail
    add rx1473_pos, 1
    set_addr $I10, rxcap_1478_fail
    ($I12, $I11) = rx1473_cur."!mark_peek"($I10)
    rx1473_cur."!cursor_pos"($I11)
    ($P10) = rx1473_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1473_pos, "")
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1478_done
  rxcap_1478_fail:
    goto rx1473_fail
  rxcap_1478_done:
  # rxanchor rwb
    le rx1473_pos, 0, rx1473_fail
    sub $I10, rx1473_pos, rx1473_off
    is_cclass $I11, 8192, rx1473_tgt, $I10
    if $I11, rx1473_fail
    dec $I10
    is_cclass $I11, 8192, rx1473_tgt, $I10
    unless $I11, rx1473_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1473_pos, rx1473_off
    substr $S10, rx1473_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1473_fail
  # rx subrule "ws" subtype=method negate=
    rx1473_cur."!cursor_pos"(rx1473_pos)
    $P10 = rx1473_cur."ws"()
    unless $P10, rx1473_fail
    rx1473_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1473_cur."!cursor_pos"(rx1473_pos)
    $P10 = rx1473_cur."quote_EXPR"(":q")
    unless $P10, rx1473_fail
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1473_pos = $P10."pos"()
  # rx pass
    rx1473_cur."!cursor_pass"(rx1473_pos, "quote:sym<q>")
    if_null rx1473_debug, debug_1139
    rx1473_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1473_pos)
  debug_1139:
    .return (rx1473_cur)
  rx1473_restart:
.annotate 'line', 10
    if_null rx1473_debug, debug_1140
    rx1473_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1140:
  rx1473_fail:
    (rx1473_rep, rx1473_pos, $I10, $P10) = rx1473_cur."!mark_fail"(0)
    lt rx1473_pos, -1, rx1473_done
    eq rx1473_pos, -1, rx1473_fail
    jump $I10
  rx1473_done:
    rx1473_cur."!cursor_fail"()
    if_null rx1473_debug, debug_1141
    rx1473_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1141:
    .return (rx1473_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("246_1304277427.017") :method
.annotate 'line', 10
    $P1475 = self."!PREFIX__!subrule"("ws", "q")
    new $P1476, "ResizablePMCArray"
    push $P1476, $P1475
    .return ($P1476)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("247_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1480_tgt
    .local int rx1480_pos
    .local int rx1480_off
    .local int rx1480_eos
    .local int rx1480_rep
    .local pmc rx1480_cur
    .local pmc rx1480_debug
    (rx1480_cur, rx1480_pos, rx1480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1480_cur
    .local pmc match
    .lex "$/", match
    length rx1480_eos, rx1480_tgt
    gt rx1480_pos, rx1480_eos, rx1480_done
    set rx1480_off, 0
    lt rx1480_pos, 2, rx1480_start
    sub rx1480_off, rx1480_pos, 1
    substr rx1480_tgt, rx1480_tgt, rx1480_off
  rx1480_start:
    eq $I10, 1, rx1480_restart
    if_null rx1480_debug, debug_1142
    rx1480_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1484_done
    goto rxscan1484_scan
  rxscan1484_loop:
    (rx1480_pos) = rx1480_cur."from"()
    inc rx1480_pos
    rx1480_cur."!cursor_from"(rx1480_pos)
    ge rx1480_pos, rx1480_eos, rxscan1484_done
  rxscan1484_scan:
    set_addr $I10, rxscan1484_loop
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  rxscan1484_done:
.annotate 'line', 585
  # rx subcapture "sym"
    set_addr $I10, rxcap_1485_fail
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1480_pos, 2
    gt $I11, rx1480_eos, rx1480_fail
    sub $I11, rx1480_pos, rx1480_off
    substr $S10, rx1480_tgt, $I11, 2
    ne $S10, "qq", rx1480_fail
    add rx1480_pos, 2
    set_addr $I10, rxcap_1485_fail
    ($I12, $I11) = rx1480_cur."!mark_peek"($I10)
    rx1480_cur."!cursor_pos"($I11)
    ($P10) = rx1480_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1480_pos, "")
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1485_done
  rxcap_1485_fail:
    goto rx1480_fail
  rxcap_1485_done:
  # rxanchor rwb
    le rx1480_pos, 0, rx1480_fail
    sub $I10, rx1480_pos, rx1480_off
    is_cclass $I11, 8192, rx1480_tgt, $I10
    if $I11, rx1480_fail
    dec $I10
    is_cclass $I11, 8192, rx1480_tgt, $I10
    unless $I11, rx1480_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1480_pos, rx1480_off
    substr $S10, rx1480_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1480_fail
  # rx subrule "ws" subtype=method negate=
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."ws"()
    unless $P10, rx1480_fail
    rx1480_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."quote_EXPR"(":qq")
    unless $P10, rx1480_fail
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1480_pos = $P10."pos"()
  # rx pass
    rx1480_cur."!cursor_pass"(rx1480_pos, "quote:sym<qq>")
    if_null rx1480_debug, debug_1143
    rx1480_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1480_pos)
  debug_1143:
    .return (rx1480_cur)
  rx1480_restart:
.annotate 'line', 10
    if_null rx1480_debug, debug_1144
    rx1480_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1144:
  rx1480_fail:
    (rx1480_rep, rx1480_pos, $I10, $P10) = rx1480_cur."!mark_fail"(0)
    lt rx1480_pos, -1, rx1480_done
    eq rx1480_pos, -1, rx1480_fail
    jump $I10
  rx1480_done:
    rx1480_cur."!cursor_fail"()
    if_null rx1480_debug, debug_1145
    rx1480_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1145:
    .return (rx1480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("248_1304277427.017") :method
.annotate 'line', 10
    $P1482 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1483, "ResizablePMCArray"
    push $P1483, $P1482
    .return ($P1483)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("249_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1487_tgt
    .local int rx1487_pos
    .local int rx1487_off
    .local int rx1487_eos
    .local int rx1487_rep
    .local pmc rx1487_cur
    .local pmc rx1487_debug
    (rx1487_cur, rx1487_pos, rx1487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1487_cur
    .local pmc match
    .lex "$/", match
    length rx1487_eos, rx1487_tgt
    gt rx1487_pos, rx1487_eos, rx1487_done
    set rx1487_off, 0
    lt rx1487_pos, 2, rx1487_start
    sub rx1487_off, rx1487_pos, 1
    substr rx1487_tgt, rx1487_tgt, rx1487_off
  rx1487_start:
    eq $I10, 1, rx1487_restart
    if_null rx1487_debug, debug_1146
    rx1487_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1487_pos) = rx1487_cur."from"()
    inc rx1487_pos
    rx1487_cur."!cursor_from"(rx1487_pos)
    ge rx1487_pos, rx1487_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  rxscan1491_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1492_fail
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1487_pos, 1
    gt $I11, rx1487_eos, rx1487_fail
    sub $I11, rx1487_pos, rx1487_off
    ord $I11, rx1487_tgt, $I11
    ne $I11, 81, rx1487_fail
    add rx1487_pos, 1
    set_addr $I10, rxcap_1492_fail
    ($I12, $I11) = rx1487_cur."!mark_peek"($I10)
    rx1487_cur."!cursor_pos"($I11)
    ($P10) = rx1487_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1487_pos, "")
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1492_done
  rxcap_1492_fail:
    goto rx1487_fail
  rxcap_1492_done:
  # rxanchor rwb
    le rx1487_pos, 0, rx1487_fail
    sub $I10, rx1487_pos, rx1487_off
    is_cclass $I11, 8192, rx1487_tgt, $I10
    if $I11, rx1487_fail
    dec $I10
    is_cclass $I11, 8192, rx1487_tgt, $I10
    unless $I11, rx1487_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1487_pos, rx1487_off
    substr $S10, rx1487_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1487_fail
  # rx subrule "ws" subtype=method negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."ws"()
    unless $P10, rx1487_fail
    rx1487_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."quote_EXPR"()
    unless $P10, rx1487_fail
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1487_pos = $P10."pos"()
  # rx pass
    rx1487_cur."!cursor_pass"(rx1487_pos, "quote:sym<Q>")
    if_null rx1487_debug, debug_1147
    rx1487_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1487_pos)
  debug_1147:
    .return (rx1487_cur)
  rx1487_restart:
.annotate 'line', 10
    if_null rx1487_debug, debug_1148
    rx1487_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1148:
  rx1487_fail:
    (rx1487_rep, rx1487_pos, $I10, $P10) = rx1487_cur."!mark_fail"(0)
    lt rx1487_pos, -1, rx1487_done
    eq rx1487_pos, -1, rx1487_fail
    jump $I10
  rx1487_done:
    rx1487_cur."!cursor_fail"()
    if_null rx1487_debug, debug_1149
    rx1487_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1149:
    .return (rx1487_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("250_1304277427.017") :method
.annotate 'line', 10
    $P1489 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1490, "ResizablePMCArray"
    push $P1490, $P1489
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("251_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1494_tgt
    .local int rx1494_pos
    .local int rx1494_off
    .local int rx1494_eos
    .local int rx1494_rep
    .local pmc rx1494_cur
    .local pmc rx1494_debug
    (rx1494_cur, rx1494_pos, rx1494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1494_cur
    .local pmc match
    .lex "$/", match
    length rx1494_eos, rx1494_tgt
    gt rx1494_pos, rx1494_eos, rx1494_done
    set rx1494_off, 0
    lt rx1494_pos, 2, rx1494_start
    sub rx1494_off, rx1494_pos, 1
    substr rx1494_tgt, rx1494_tgt, rx1494_off
  rx1494_start:
    eq $I10, 1, rx1494_restart
    if_null rx1494_debug, debug_1150
    rx1494_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1150:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1498_done
    goto rxscan1498_scan
  rxscan1498_loop:
    (rx1494_pos) = rx1494_cur."from"()
    inc rx1494_pos
    rx1494_cur."!cursor_from"(rx1494_pos)
    ge rx1494_pos, rx1494_eos, rxscan1498_done
  rxscan1498_scan:
    set_addr $I10, rxscan1498_loop
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  rxscan1498_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1499_fail
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1494_pos, 5
    gt $I11, rx1494_eos, rx1494_fail
    sub $I11, rx1494_pos, rx1494_off
    substr $S10, rx1494_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1494_fail
    add rx1494_pos, 5
    set_addr $I10, rxcap_1499_fail
    ($I12, $I11) = rx1494_cur."!mark_peek"($I10)
    rx1494_cur."!cursor_pos"($I11)
    ($P10) = rx1494_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1494_pos, "")
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1499_done
  rxcap_1499_fail:
    goto rx1494_fail
  rxcap_1499_done:
  # rx subrule "ws" subtype=method negate=
    rx1494_cur."!cursor_pos"(rx1494_pos)
    $P10 = rx1494_cur."ws"()
    unless $P10, rx1494_fail
    rx1494_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1494_cur."!cursor_pos"(rx1494_pos)
    $P10 = rx1494_cur."quote_EXPR"()
    unless $P10, rx1494_fail
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1494_pos = $P10."pos"()
  # rx pass
    rx1494_cur."!cursor_pass"(rx1494_pos, "quote:sym<Q:PIR>")
    if_null rx1494_debug, debug_1151
    rx1494_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1494_pos)
  debug_1151:
    .return (rx1494_cur)
  rx1494_restart:
.annotate 'line', 10
    if_null rx1494_debug, debug_1152
    rx1494_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1152:
  rx1494_fail:
    (rx1494_rep, rx1494_pos, $I10, $P10) = rx1494_cur."!mark_fail"(0)
    lt rx1494_pos, -1, rx1494_done
    eq rx1494_pos, -1, rx1494_fail
    jump $I10
  rx1494_done:
    rx1494_cur."!cursor_fail"()
    if_null rx1494_debug, debug_1153
    rx1494_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1153:
    .return (rx1494_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("252_1304277427.017") :method
.annotate 'line', 10
    $P1496 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1497, "ResizablePMCArray"
    push $P1497, $P1496
    .return ($P1497)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("253_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1501_tgt
    .local int rx1501_pos
    .local int rx1501_off
    .local int rx1501_eos
    .local int rx1501_rep
    .local pmc rx1501_cur
    .local pmc rx1501_debug
    (rx1501_cur, rx1501_pos, rx1501_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1501_cur
    .local pmc match
    .lex "$/", match
    length rx1501_eos, rx1501_tgt
    gt rx1501_pos, rx1501_eos, rx1501_done
    set rx1501_off, 0
    lt rx1501_pos, 2, rx1501_start
    sub rx1501_off, rx1501_pos, 1
    substr rx1501_tgt, rx1501_tgt, rx1501_off
  rx1501_start:
    eq $I10, 1, rx1501_restart
    if_null rx1501_debug, debug_1154
    rx1501_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1505_done
    goto rxscan1505_scan
  rxscan1505_loop:
    (rx1501_pos) = rx1501_cur."from"()
    inc rx1501_pos
    rx1501_cur."!cursor_from"(rx1501_pos)
    ge rx1501_pos, rx1501_eos, rxscan1505_done
  rxscan1505_scan:
    set_addr $I10, rxscan1505_loop
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  rxscan1505_done:
.annotate 'line', 589
  # rx literal  "/"
    add $I11, rx1501_pos, 1
    gt $I11, rx1501_eos, rx1501_fail
    sub $I11, rx1501_pos, rx1501_off
    ord $I11, rx1501_tgt, $I11
    ne $I11, 47, rx1501_fail
    add rx1501_pos, 1
.annotate 'line', 590
  # rx subrule "newpad" subtype=method negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."newpad"()
    unless $P10, rx1501_fail
    rx1501_pos = $P10."pos"()
.annotate 'line', 591
  # rx reduce name="quote:sym</ />" key="open"
    rx1501_cur."!cursor_pos"(rx1501_pos)
    rx1501_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 592
  # rx subrule "LANG" subtype=capture negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1501_fail
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1501_pos = $P10."pos"()
.annotate 'line', 593
  # rx literal  "/"
    add $I11, rx1501_pos, 1
    gt $I11, rx1501_eos, rx1501_fail
    sub $I11, rx1501_pos, rx1501_off
    ord $I11, rx1501_tgt, $I11
    ne $I11, 47, rx1501_fail
    add rx1501_pos, 1
.annotate 'line', 588
  # rx pass
    rx1501_cur."!cursor_pass"(rx1501_pos, "quote:sym</ />")
    if_null rx1501_debug, debug_1155
    rx1501_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1501_pos)
  debug_1155:
    .return (rx1501_cur)
  rx1501_restart:
.annotate 'line', 10
    if_null rx1501_debug, debug_1156
    rx1501_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1156:
  rx1501_fail:
    (rx1501_rep, rx1501_pos, $I10, $P10) = rx1501_cur."!mark_fail"(0)
    lt rx1501_pos, -1, rx1501_done
    eq rx1501_pos, -1, rx1501_fail
    jump $I10
  rx1501_done:
    rx1501_cur."!cursor_fail"()
    if_null rx1501_debug, debug_1157
    rx1501_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1157:
    .return (rx1501_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("254_1304277427.017") :method
.annotate 'line', 10
    $P1503 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1504, "ResizablePMCArray"
    push $P1504, $P1503
    .return ($P1504)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("255_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1507_tgt
    .local int rx1507_pos
    .local int rx1507_off
    .local int rx1507_eos
    .local int rx1507_rep
    .local pmc rx1507_cur
    .local pmc rx1507_debug
    (rx1507_cur, rx1507_pos, rx1507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1507_cur
    .local pmc match
    .lex "$/", match
    length rx1507_eos, rx1507_tgt
    gt rx1507_pos, rx1507_eos, rx1507_done
    set rx1507_off, 0
    lt rx1507_pos, 2, rx1507_start
    sub rx1507_off, rx1507_pos, 1
    substr rx1507_tgt, rx1507_tgt, rx1507_off
  rx1507_start:
    eq $I10, 1, rx1507_restart
    if_null rx1507_debug, debug_1158
    rx1507_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1158:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1510_done
    goto rxscan1510_scan
  rxscan1510_loop:
    (rx1507_pos) = rx1507_cur."from"()
    inc rx1507_pos
    rx1507_cur."!cursor_from"(rx1507_pos)
    ge rx1507_pos, rx1507_eos, rxscan1510_done
  rxscan1510_scan:
    set_addr $I10, rxscan1510_loop
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  rxscan1510_done:
.annotate 'line', 596
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1507_pos, rx1507_off
    substr $S10, rx1507_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1507_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."quotemod_check"("s")
    unless $P10, rx1507_fail
  # rx subrule "variable" subtype=capture negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."variable"()
    unless $P10, rx1507_fail
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1507_pos = $P10."pos"()
  # rx pass
    rx1507_cur."!cursor_pass"(rx1507_pos, "quote_escape:sym<$>")
    if_null rx1507_debug, debug_1159
    rx1507_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1507_pos)
  debug_1159:
    .return (rx1507_cur)
  rx1507_restart:
.annotate 'line', 10
    if_null rx1507_debug, debug_1160
    rx1507_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1160:
  rx1507_fail:
    (rx1507_rep, rx1507_pos, $I10, $P10) = rx1507_cur."!mark_fail"(0)
    lt rx1507_pos, -1, rx1507_done
    eq rx1507_pos, -1, rx1507_fail
    jump $I10
  rx1507_done:
    rx1507_cur."!cursor_fail"()
    if_null rx1507_debug, debug_1161
    rx1507_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1161:
    .return (rx1507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("256_1304277427.017") :method
.annotate 'line', 10
    new $P1509, "ResizablePMCArray"
    push $P1509, "$"
    .return ($P1509)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("257_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1512_tgt
    .local int rx1512_pos
    .local int rx1512_off
    .local int rx1512_eos
    .local int rx1512_rep
    .local pmc rx1512_cur
    .local pmc rx1512_debug
    (rx1512_cur, rx1512_pos, rx1512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1512_cur
    .local pmc match
    .lex "$/", match
    length rx1512_eos, rx1512_tgt
    gt rx1512_pos, rx1512_eos, rx1512_done
    set rx1512_off, 0
    lt rx1512_pos, 2, rx1512_start
    sub rx1512_off, rx1512_pos, 1
    substr rx1512_tgt, rx1512_tgt, rx1512_off
  rx1512_start:
    eq $I10, 1, rx1512_restart
    if_null rx1512_debug, debug_1162
    rx1512_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1162:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1515_done
    goto rxscan1515_scan
  rxscan1515_loop:
    (rx1512_pos) = rx1512_cur."from"()
    inc rx1512_pos
    rx1512_cur."!cursor_from"(rx1512_pos)
    ge rx1512_pos, rx1512_eos, rxscan1515_done
  rxscan1515_scan:
    set_addr $I10, rxscan1515_loop
    rx1512_cur."!mark_push"(0, rx1512_pos, $I10)
  rxscan1515_done:
.annotate 'line', 597
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1512_pos, rx1512_off
    substr $S10, rx1512_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1512_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1512_cur."!cursor_pos"(rx1512_pos)
    $P10 = rx1512_cur."quotemod_check"("c")
    unless $P10, rx1512_fail
  # rx subrule "block" subtype=capture negate=
    rx1512_cur."!cursor_pos"(rx1512_pos)
    $P10 = rx1512_cur."block"()
    unless $P10, rx1512_fail
    rx1512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1512_pos = $P10."pos"()
  # rx pass
    rx1512_cur."!cursor_pass"(rx1512_pos, "quote_escape:sym<{ }>")
    if_null rx1512_debug, debug_1163
    rx1512_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1512_pos)
  debug_1163:
    .return (rx1512_cur)
  rx1512_restart:
.annotate 'line', 10
    if_null rx1512_debug, debug_1164
    rx1512_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1164:
  rx1512_fail:
    (rx1512_rep, rx1512_pos, $I10, $P10) = rx1512_cur."!mark_fail"(0)
    lt rx1512_pos, -1, rx1512_done
    eq rx1512_pos, -1, rx1512_fail
    jump $I10
  rx1512_done:
    rx1512_cur."!cursor_fail"()
    if_null rx1512_debug, debug_1165
    rx1512_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1165:
    .return (rx1512_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("258_1304277427.017") :method
.annotate 'line', 10
    new $P1514, "ResizablePMCArray"
    push $P1514, "{"
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("259_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1517_tgt
    .local int rx1517_pos
    .local int rx1517_off
    .local int rx1517_eos
    .local int rx1517_rep
    .local pmc rx1517_cur
    .local pmc rx1517_debug
    (rx1517_cur, rx1517_pos, rx1517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1517_cur
    .local pmc match
    .lex "$/", match
    length rx1517_eos, rx1517_tgt
    gt rx1517_pos, rx1517_eos, rx1517_done
    set rx1517_off, 0
    lt rx1517_pos, 2, rx1517_start
    sub rx1517_off, rx1517_pos, 1
    substr rx1517_tgt, rx1517_tgt, rx1517_off
  rx1517_start:
    eq $I10, 1, rx1517_restart
    if_null rx1517_debug, debug_1166
    rx1517_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1520_done
    goto rxscan1520_scan
  rxscan1520_loop:
    (rx1517_pos) = rx1517_cur."from"()
    inc rx1517_pos
    rx1517_cur."!cursor_from"(rx1517_pos)
    ge rx1517_pos, rx1517_eos, rxscan1520_done
  rxscan1520_scan:
    set_addr $I10, rxscan1520_loop
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  rxscan1520_done:
.annotate 'line', 598
  # rx literal  "\\e"
    add $I11, rx1517_pos, 2
    gt $I11, rx1517_eos, rx1517_fail
    sub $I11, rx1517_pos, rx1517_off
    substr $S10, rx1517_tgt, $I11, 2
    ne $S10, "\\e", rx1517_fail
    add rx1517_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."quotemod_check"("b")
    unless $P10, rx1517_fail
  # rx pass
    rx1517_cur."!cursor_pass"(rx1517_pos, "quote_escape:sym<esc>")
    if_null rx1517_debug, debug_1167
    rx1517_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1517_pos)
  debug_1167:
    .return (rx1517_cur)
  rx1517_restart:
.annotate 'line', 10
    if_null rx1517_debug, debug_1168
    rx1517_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1168:
  rx1517_fail:
    (rx1517_rep, rx1517_pos, $I10, $P10) = rx1517_cur."!mark_fail"(0)
    lt rx1517_pos, -1, rx1517_done
    eq rx1517_pos, -1, rx1517_fail
    jump $I10
  rx1517_done:
    rx1517_cur."!cursor_fail"()
    if_null rx1517_debug, debug_1169
    rx1517_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1169:
    .return (rx1517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("260_1304277427.017") :method
.annotate 'line', 10
    new $P1519, "ResizablePMCArray"
    push $P1519, "\\e"
    .return ($P1519)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("261_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1522_tgt
    .local int rx1522_pos
    .local int rx1522_off
    .local int rx1522_eos
    .local int rx1522_rep
    .local pmc rx1522_cur
    .local pmc rx1522_debug
    (rx1522_cur, rx1522_pos, rx1522_tgt, $I10) = self."!cursor_start"()
    rx1522_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1522_cur
    .local pmc match
    .lex "$/", match
    length rx1522_eos, rx1522_tgt
    gt rx1522_pos, rx1522_eos, rx1522_done
    set rx1522_off, 0
    lt rx1522_pos, 2, rx1522_start
    sub rx1522_off, rx1522_pos, 1
    substr rx1522_tgt, rx1522_tgt, rx1522_off
  rx1522_start:
    eq $I10, 1, rx1522_restart
    if_null rx1522_debug, debug_1170
    rx1522_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1170:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1526_done
    goto rxscan1526_scan
  rxscan1526_loop:
    (rx1522_pos) = rx1522_cur."from"()
    inc rx1522_pos
    rx1522_cur."!cursor_from"(rx1522_pos)
    ge rx1522_pos, rx1522_eos, rxscan1526_done
  rxscan1526_scan:
    set_addr $I10, rxscan1526_loop
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10)
  rxscan1526_done:
.annotate 'line', 600
  # rx literal  "("
    add $I11, rx1522_pos, 1
    gt $I11, rx1522_eos, rx1522_fail
    sub $I11, rx1522_pos, rx1522_off
    ord $I11, rx1522_tgt, $I11
    ne $I11, 40, rx1522_fail
    add rx1522_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1522_cur."!cursor_pos"(rx1522_pos)
    $P10 = rx1522_cur."ws"()
    unless $P10, rx1522_fail
    rx1522_pos = $P10."pos"()
  # rx rxquantr1527 ** 0..1
    set_addr $I10, rxquantr1527_done
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10)
  rxquantr1527_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1522_cur."!cursor_pos"(rx1522_pos)
    $P10 = rx1522_cur."EXPR"()
    unless $P10, rx1522_fail
    goto rxsubrule1528_pass
  rxsubrule1528_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1522_fail
  rxsubrule1528_pass:
    set_addr $I10, rxsubrule1528_back
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1522_pos = $P10."pos"()
    set_addr $I10, rxquantr1527_done
    (rx1522_rep) = rx1522_cur."!mark_commit"($I10)
  rxquantr1527_done:
  # rx literal  ")"
    add $I11, rx1522_pos, 1
    gt $I11, rx1522_eos, rx1522_fail
    sub $I11, rx1522_pos, rx1522_off
    ord $I11, rx1522_tgt, $I11
    ne $I11, 41, rx1522_fail
    add rx1522_pos, 1
  # rx pass
    rx1522_cur."!cursor_pass"(rx1522_pos, "circumfix:sym<( )>")
    if_null rx1522_debug, debug_1171
    rx1522_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1522_pos)
  debug_1171:
    .return (rx1522_cur)
  rx1522_restart:
.annotate 'line', 10
    if_null rx1522_debug, debug_1172
    rx1522_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1172:
  rx1522_fail:
    (rx1522_rep, rx1522_pos, $I10, $P10) = rx1522_cur."!mark_fail"(0)
    lt rx1522_pos, -1, rx1522_done
    eq rx1522_pos, -1, rx1522_fail
    jump $I10
  rx1522_done:
    rx1522_cur."!cursor_fail"()
    if_null rx1522_debug, debug_1173
    rx1522_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1173:
    .return (rx1522_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("262_1304277427.017") :method
.annotate 'line', 10
    $P1524 = self."!PREFIX__!subrule"("ws", "(")
    new $P1525, "ResizablePMCArray"
    push $P1525, $P1524
    .return ($P1525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("263_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1530_tgt
    .local int rx1530_pos
    .local int rx1530_off
    .local int rx1530_eos
    .local int rx1530_rep
    .local pmc rx1530_cur
    .local pmc rx1530_debug
    (rx1530_cur, rx1530_pos, rx1530_tgt, $I10) = self."!cursor_start"()
    rx1530_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1530_cur
    .local pmc match
    .lex "$/", match
    length rx1530_eos, rx1530_tgt
    gt rx1530_pos, rx1530_eos, rx1530_done
    set rx1530_off, 0
    lt rx1530_pos, 2, rx1530_start
    sub rx1530_off, rx1530_pos, 1
    substr rx1530_tgt, rx1530_tgt, rx1530_off
  rx1530_start:
    eq $I10, 1, rx1530_restart
    if_null rx1530_debug, debug_1174
    rx1530_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1174:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1534_done
    goto rxscan1534_scan
  rxscan1534_loop:
    (rx1530_pos) = rx1530_cur."from"()
    inc rx1530_pos
    rx1530_cur."!cursor_from"(rx1530_pos)
    ge rx1530_pos, rx1530_eos, rxscan1534_done
  rxscan1534_scan:
    set_addr $I10, rxscan1534_loop
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  rxscan1534_done:
.annotate 'line', 601
  # rx literal  "["
    add $I11, rx1530_pos, 1
    gt $I11, rx1530_eos, rx1530_fail
    sub $I11, rx1530_pos, rx1530_off
    ord $I11, rx1530_tgt, $I11
    ne $I11, 91, rx1530_fail
    add rx1530_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1530_cur."!cursor_pos"(rx1530_pos)
    $P10 = rx1530_cur."ws"()
    unless $P10, rx1530_fail
    rx1530_pos = $P10."pos"()
  # rx rxquantr1535 ** 0..1
    set_addr $I10, rxquantr1535_done
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  rxquantr1535_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1530_cur."!cursor_pos"(rx1530_pos)
    $P10 = rx1530_cur."EXPR"()
    unless $P10, rx1530_fail
    goto rxsubrule1536_pass
  rxsubrule1536_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1530_fail
  rxsubrule1536_pass:
    set_addr $I10, rxsubrule1536_back
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1530_pos = $P10."pos"()
    set_addr $I10, rxquantr1535_done
    (rx1530_rep) = rx1530_cur."!mark_commit"($I10)
  rxquantr1535_done:
  # rx literal  "]"
    add $I11, rx1530_pos, 1
    gt $I11, rx1530_eos, rx1530_fail
    sub $I11, rx1530_pos, rx1530_off
    ord $I11, rx1530_tgt, $I11
    ne $I11, 93, rx1530_fail
    add rx1530_pos, 1
  # rx pass
    rx1530_cur."!cursor_pass"(rx1530_pos, "circumfix:sym<[ ]>")
    if_null rx1530_debug, debug_1175
    rx1530_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1530_pos)
  debug_1175:
    .return (rx1530_cur)
  rx1530_restart:
.annotate 'line', 10
    if_null rx1530_debug, debug_1176
    rx1530_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1176:
  rx1530_fail:
    (rx1530_rep, rx1530_pos, $I10, $P10) = rx1530_cur."!mark_fail"(0)
    lt rx1530_pos, -1, rx1530_done
    eq rx1530_pos, -1, rx1530_fail
    jump $I10
  rx1530_done:
    rx1530_cur."!cursor_fail"()
    if_null rx1530_debug, debug_1177
    rx1530_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1177:
    .return (rx1530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("264_1304277427.017") :method
.annotate 'line', 10
    $P1532 = self."!PREFIX__!subrule"("ws", "[")
    new $P1533, "ResizablePMCArray"
    push $P1533, $P1532
    .return ($P1533)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("265_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1538_tgt
    .local int rx1538_pos
    .local int rx1538_off
    .local int rx1538_eos
    .local int rx1538_rep
    .local pmc rx1538_cur
    .local pmc rx1538_debug
    (rx1538_cur, rx1538_pos, rx1538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1538_cur
    .local pmc match
    .lex "$/", match
    length rx1538_eos, rx1538_tgt
    gt rx1538_pos, rx1538_eos, rx1538_done
    set rx1538_off, 0
    lt rx1538_pos, 2, rx1538_start
    sub rx1538_off, rx1538_pos, 1
    substr rx1538_tgt, rx1538_tgt, rx1538_off
  rx1538_start:
    eq $I10, 1, rx1538_restart
    if_null rx1538_debug, debug_1178
    rx1538_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1178:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1541_done
    goto rxscan1541_scan
  rxscan1541_loop:
    (rx1538_pos) = rx1538_cur."from"()
    inc rx1538_pos
    rx1538_cur."!cursor_from"(rx1538_pos)
    ge rx1538_pos, rx1538_eos, rxscan1541_done
  rxscan1541_scan:
    set_addr $I10, rxscan1541_loop
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  rxscan1541_done:
.annotate 'line', 602
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1538_pos, rx1538_off
    substr $S10, rx1538_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1538_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1538_fail
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1538_pos = $P10."pos"()
  # rx pass
    rx1538_cur."!cursor_pass"(rx1538_pos, "circumfix:sym<ang>")
    if_null rx1538_debug, debug_1179
    rx1538_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1538_pos)
  debug_1179:
    .return (rx1538_cur)
  rx1538_restart:
.annotate 'line', 10
    if_null rx1538_debug, debug_1180
    rx1538_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1180:
  rx1538_fail:
    (rx1538_rep, rx1538_pos, $I10, $P10) = rx1538_cur."!mark_fail"(0)
    lt rx1538_pos, -1, rx1538_done
    eq rx1538_pos, -1, rx1538_fail
    jump $I10
  rx1538_done:
    rx1538_cur."!cursor_fail"()
    if_null rx1538_debug, debug_1181
    rx1538_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1181:
    .return (rx1538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("266_1304277427.017") :method
.annotate 'line', 10
    new $P1540, "ResizablePMCArray"
    push $P1540, "<"
    .return ($P1540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("267_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1182
    rx1543_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1182:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1546_done
    goto rxscan1546_scan
  rxscan1546_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1546_done
  rxscan1546_scan:
    set_addr $I10, rxscan1546_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1546_done:
.annotate 'line', 603
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1543_pos, rx1543_off
    substr $S10, rx1543_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1543_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1543_debug, debug_1183
    rx1543_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1543_pos)
  debug_1183:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 10
    if_null rx1543_debug, debug_1184
    rx1543_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1184:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1185
    rx1543_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1185:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("268_1304277427.017") :method
.annotate 'line', 10
    new $P1545, "ResizablePMCArray"
    push $P1545, unicode:"\x{ab}"
    .return ($P1545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("269_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1548_tgt
    .local int rx1548_pos
    .local int rx1548_off
    .local int rx1548_eos
    .local int rx1548_rep
    .local pmc rx1548_cur
    .local pmc rx1548_debug
    (rx1548_cur, rx1548_pos, rx1548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1548_cur
    .local pmc match
    .lex "$/", match
    length rx1548_eos, rx1548_tgt
    gt rx1548_pos, rx1548_eos, rx1548_done
    set rx1548_off, 0
    lt rx1548_pos, 2, rx1548_start
    sub rx1548_off, rx1548_pos, 1
    substr rx1548_tgt, rx1548_tgt, rx1548_off
  rx1548_start:
    eq $I10, 1, rx1548_restart
    if_null rx1548_debug, debug_1186
    rx1548_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1186:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1551_done
    goto rxscan1551_scan
  rxscan1551_loop:
    (rx1548_pos) = rx1548_cur."from"()
    inc rx1548_pos
    rx1548_cur."!cursor_from"(rx1548_pos)
    ge rx1548_pos, rx1548_eos, rxscan1551_done
  rxscan1551_scan:
    set_addr $I10, rxscan1551_loop
    rx1548_cur."!mark_push"(0, rx1548_pos, $I10)
  rxscan1551_done:
.annotate 'line', 604
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1548_pos, rx1548_off
    substr $S10, rx1548_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1548_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."pblock"()
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1548_pos = $P10."pos"()
  # rx pass
    rx1548_cur."!cursor_pass"(rx1548_pos, "circumfix:sym<{ }>")
    if_null rx1548_debug, debug_1187
    rx1548_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1548_pos)
  debug_1187:
    .return (rx1548_cur)
  rx1548_restart:
.annotate 'line', 10
    if_null rx1548_debug, debug_1188
    rx1548_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1188:
  rx1548_fail:
    (rx1548_rep, rx1548_pos, $I10, $P10) = rx1548_cur."!mark_fail"(0)
    lt rx1548_pos, -1, rx1548_done
    eq rx1548_pos, -1, rx1548_fail
    jump $I10
  rx1548_done:
    rx1548_cur."!cursor_fail"()
    if_null rx1548_debug, debug_1189
    rx1548_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1189:
    .return (rx1548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("270_1304277427.017") :method
.annotate 'line', 10
    new $P1550, "ResizablePMCArray"
    push $P1550, "{"
    .return ($P1550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("271_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1553_tgt
    .local int rx1553_pos
    .local int rx1553_off
    .local int rx1553_eos
    .local int rx1553_rep
    .local pmc rx1553_cur
    .local pmc rx1553_debug
    (rx1553_cur, rx1553_pos, rx1553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1553_cur
    .local pmc match
    .lex "$/", match
    length rx1553_eos, rx1553_tgt
    gt rx1553_pos, rx1553_eos, rx1553_done
    set rx1553_off, 0
    lt rx1553_pos, 2, rx1553_start
    sub rx1553_off, rx1553_pos, 1
    substr rx1553_tgt, rx1553_tgt, rx1553_off
  rx1553_start:
    eq $I10, 1, rx1553_restart
    if_null rx1553_debug, debug_1190
    rx1553_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1190:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1557_done
    goto rxscan1557_scan
  rxscan1557_loop:
    (rx1553_pos) = rx1553_cur."from"()
    inc rx1553_pos
    rx1553_cur."!cursor_from"(rx1553_pos)
    ge rx1553_pos, rx1553_eos, rxscan1557_done
  rxscan1557_scan:
    set_addr $I10, rxscan1557_loop
    rx1553_cur."!mark_push"(0, rx1553_pos, $I10)
  rxscan1557_done:
.annotate 'line', 605
  # rx subrule "sigil" subtype=capture negate=
    rx1553_cur."!cursor_pos"(rx1553_pos)
    $P10 = rx1553_cur."sigil"()
    unless $P10, rx1553_fail
    rx1553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1553_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1553_pos, 1
    gt $I11, rx1553_eos, rx1553_fail
    sub $I11, rx1553_pos, rx1553_off
    ord $I11, rx1553_tgt, $I11
    ne $I11, 40, rx1553_fail
    add rx1553_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1553_cur."!cursor_pos"(rx1553_pos)
    $P10 = rx1553_cur."semilist"()
    unless $P10, rx1553_fail
    rx1553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1553_pos = $P10."pos"()
  alt1558_0:
    set_addr $I10, alt1558_1
    rx1553_cur."!mark_push"(0, rx1553_pos, $I10)
  # rx literal  ")"
    add $I11, rx1553_pos, 1
    gt $I11, rx1553_eos, rx1553_fail
    sub $I11, rx1553_pos, rx1553_off
    ord $I11, rx1553_tgt, $I11
    ne $I11, 41, rx1553_fail
    add rx1553_pos, 1
    goto alt1558_end
  alt1558_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1553_cur."!cursor_pos"(rx1553_pos)
    $P10 = rx1553_cur."FAILGOAL"("')'")
    unless $P10, rx1553_fail
    goto rxsubrule1560_pass
  rxsubrule1560_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1553_fail
  rxsubrule1560_pass:
    set_addr $I10, rxsubrule1560_back
    rx1553_cur."!mark_push"(0, rx1553_pos, $I10, $P10)
    rx1553_pos = $P10."pos"()
  alt1558_end:
  # rx pass
    rx1553_cur."!cursor_pass"(rx1553_pos, "circumfix:sym<sigil>")
    if_null rx1553_debug, debug_1191
    rx1553_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1553_pos)
  debug_1191:
    .return (rx1553_cur)
  rx1553_restart:
.annotate 'line', 10
    if_null rx1553_debug, debug_1192
    rx1553_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1192:
  rx1553_fail:
    (rx1553_rep, rx1553_pos, $I10, $P10) = rx1553_cur."!mark_fail"(0)
    lt rx1553_pos, -1, rx1553_done
    eq rx1553_pos, -1, rx1553_fail
    jump $I10
  rx1553_done:
    rx1553_cur."!cursor_fail"()
    if_null rx1553_debug, debug_1193
    rx1553_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1193:
    .return (rx1553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("272_1304277427.017") :method
.annotate 'line', 10
    $P1555 = self."!PREFIX__!subrule"("sigil", "")
    new $P1556, "ResizablePMCArray"
    push $P1556, $P1555
    .return ($P1556)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("273_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1562_tgt
    .local int rx1562_pos
    .local int rx1562_off
    .local int rx1562_eos
    .local int rx1562_rep
    .local pmc rx1562_cur
    .local pmc rx1562_debug
    (rx1562_cur, rx1562_pos, rx1562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1562_cur
    .local pmc match
    .lex "$/", match
    length rx1562_eos, rx1562_tgt
    gt rx1562_pos, rx1562_eos, rx1562_done
    set rx1562_off, 0
    lt rx1562_pos, 2, rx1562_start
    sub rx1562_off, rx1562_pos, 1
    substr rx1562_tgt, rx1562_tgt, rx1562_off
  rx1562_start:
    eq $I10, 1, rx1562_restart
    if_null rx1562_debug, debug_1194
    rx1562_cur."!cursor_debug"("START", "semilist")
  debug_1194:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1566_done
    goto rxscan1566_scan
  rxscan1566_loop:
    (rx1562_pos) = rx1562_cur."from"()
    inc rx1562_pos
    rx1562_cur."!cursor_from"(rx1562_pos)
    ge rx1562_pos, rx1562_eos, rxscan1566_done
  rxscan1566_scan:
    set_addr $I10, rxscan1566_loop
    rx1562_cur."!mark_push"(0, rx1562_pos, $I10)
  rxscan1566_done:
.annotate 'line', 607
  # rx subrule "ws" subtype=method negate=
    rx1562_cur."!cursor_pos"(rx1562_pos)
    $P10 = rx1562_cur."ws"()
    unless $P10, rx1562_fail
    rx1562_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1562_cur."!cursor_pos"(rx1562_pos)
    $P10 = rx1562_cur."statement"()
    unless $P10, rx1562_fail
    rx1562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1562_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1562_cur."!cursor_pos"(rx1562_pos)
    $P10 = rx1562_cur."ws"()
    unless $P10, rx1562_fail
    rx1562_pos = $P10."pos"()
  # rx pass
    rx1562_cur."!cursor_pass"(rx1562_pos, "semilist")
    if_null rx1562_debug, debug_1195
    rx1562_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1562_pos)
  debug_1195:
    .return (rx1562_cur)
  rx1562_restart:
.annotate 'line', 10
    if_null rx1562_debug, debug_1196
    rx1562_cur."!cursor_debug"("NEXT", "semilist")
  debug_1196:
  rx1562_fail:
    (rx1562_rep, rx1562_pos, $I10, $P10) = rx1562_cur."!mark_fail"(0)
    lt rx1562_pos, -1, rx1562_done
    eq rx1562_pos, -1, rx1562_fail
    jump $I10
  rx1562_done:
    rx1562_cur."!cursor_fail"()
    if_null rx1562_debug, debug_1197
    rx1562_cur."!cursor_debug"("FAIL", "semilist")
  debug_1197:
    .return (rx1562_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("274_1304277427.017") :method
.annotate 'line', 10
    $P1564 = self."!PREFIX__!subrule"("ws", "")
    new $P1565, "ResizablePMCArray"
    push $P1565, $P1564
    .return ($P1565)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("275_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1570_tgt
    .local int rx1570_pos
    .local int rx1570_off
    .local int rx1570_eos
    .local int rx1570_rep
    .local pmc rx1570_cur
    .local pmc rx1570_debug
    (rx1570_cur, rx1570_pos, rx1570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1570_cur
    .local pmc match
    .lex "$/", match
    length rx1570_eos, rx1570_tgt
    gt rx1570_pos, rx1570_eos, rx1570_done
    set rx1570_off, 0
    lt rx1570_pos, 2, rx1570_start
    sub rx1570_off, rx1570_pos, 1
    substr rx1570_tgt, rx1570_tgt, rx1570_off
  rx1570_start:
    eq $I10, 1, rx1570_restart
    if_null rx1570_debug, debug_1198
    rx1570_cur."!cursor_debug"("START", "infixish")
  debug_1198:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1573_done
    goto rxscan1573_scan
  rxscan1573_loop:
    (rx1570_pos) = rx1570_cur."from"()
    inc rx1570_pos
    rx1570_cur."!cursor_from"(rx1570_pos)
    ge rx1570_pos, rx1570_eos, rxscan1573_done
  rxscan1573_scan:
    set_addr $I10, rxscan1573_loop
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  rxscan1573_done:
.annotate 'line', 630
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."infixstopper"()
    if $P10, rx1570_fail
  # rx subrule "infix" subtype=capture negate=
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."infix"()
    unless $P10, rx1570_fail
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1570_pos = $P10."pos"()
  # rx pass
    rx1570_cur."!cursor_pass"(rx1570_pos, "infixish")
    if_null rx1570_debug, debug_1199
    rx1570_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1570_pos)
  debug_1199:
    .return (rx1570_cur)
  rx1570_restart:
.annotate 'line', 10
    if_null rx1570_debug, debug_1200
    rx1570_cur."!cursor_debug"("NEXT", "infixish")
  debug_1200:
  rx1570_fail:
    (rx1570_rep, rx1570_pos, $I10, $P10) = rx1570_cur."!mark_fail"(0)
    lt rx1570_pos, -1, rx1570_done
    eq rx1570_pos, -1, rx1570_fail
    jump $I10
  rx1570_done:
    rx1570_cur."!cursor_fail"()
    if_null rx1570_debug, debug_1201
    rx1570_cur."!cursor_debug"("FAIL", "infixish")
  debug_1201:
    .return (rx1570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("276_1304277427.017") :method
.annotate 'line', 10
    new $P1572, "ResizablePMCArray"
    push $P1572, ""
    .return ($P1572)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("277_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1575_tgt
    .local int rx1575_pos
    .local int rx1575_off
    .local int rx1575_eos
    .local int rx1575_rep
    .local pmc rx1575_cur
    .local pmc rx1575_debug
    (rx1575_cur, rx1575_pos, rx1575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1575_cur
    .local pmc match
    .lex "$/", match
    length rx1575_eos, rx1575_tgt
    gt rx1575_pos, rx1575_eos, rx1575_done
    set rx1575_off, 0
    lt rx1575_pos, 2, rx1575_start
    sub rx1575_off, rx1575_pos, 1
    substr rx1575_tgt, rx1575_tgt, rx1575_off
  rx1575_start:
    eq $I10, 1, rx1575_restart
    if_null rx1575_debug, debug_1202
    rx1575_cur."!cursor_debug"("START", "infixstopper")
  debug_1202:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1578_done
    goto rxscan1578_scan
  rxscan1578_loop:
    (rx1575_pos) = rx1575_cur."from"()
    inc rx1575_pos
    rx1575_cur."!cursor_from"(rx1575_pos)
    ge rx1575_pos, rx1575_eos, rxscan1578_done
  rxscan1578_scan:
    set_addr $I10, rxscan1578_loop
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  rxscan1578_done:
.annotate 'line', 631
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1575_cur."!cursor_pos"(rx1575_pos)
    $P10 = rx1575_cur."lambda"()
    unless $P10, rx1575_fail
  # rx pass
    rx1575_cur."!cursor_pass"(rx1575_pos, "infixstopper")
    if_null rx1575_debug, debug_1203
    rx1575_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1575_pos)
  debug_1203:
    .return (rx1575_cur)
  rx1575_restart:
.annotate 'line', 10
    if_null rx1575_debug, debug_1204
    rx1575_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1204:
  rx1575_fail:
    (rx1575_rep, rx1575_pos, $I10, $P10) = rx1575_cur."!mark_fail"(0)
    lt rx1575_pos, -1, rx1575_done
    eq rx1575_pos, -1, rx1575_fail
    jump $I10
  rx1575_done:
    rx1575_cur."!cursor_fail"()
    if_null rx1575_debug, debug_1205
    rx1575_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1205:
    .return (rx1575_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("278_1304277427.017") :method
.annotate 'line', 10
    new $P1577, "ResizablePMCArray"
    push $P1577, ""
    .return ($P1577)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("279_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1580_tgt
    .local int rx1580_pos
    .local int rx1580_off
    .local int rx1580_eos
    .local int rx1580_rep
    .local pmc rx1580_cur
    .local pmc rx1580_debug
    (rx1580_cur, rx1580_pos, rx1580_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1580_cur
    .local pmc match
    .lex "$/", match
    length rx1580_eos, rx1580_tgt
    gt rx1580_pos, rx1580_eos, rx1580_done
    set rx1580_off, 0
    lt rx1580_pos, 2, rx1580_start
    sub rx1580_off, rx1580_pos, 1
    substr rx1580_tgt, rx1580_tgt, rx1580_off
  rx1580_start:
    eq $I10, 1, rx1580_restart
    if_null rx1580_debug, debug_1206
    rx1580_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1206:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1584_done
    goto rxscan1584_scan
  rxscan1584_loop:
    (rx1580_pos) = rx1580_cur."from"()
    inc rx1580_pos
    rx1580_cur."!cursor_from"(rx1580_pos)
    ge rx1580_pos, rx1580_eos, rxscan1584_done
  rxscan1584_scan:
    set_addr $I10, rxscan1584_loop
    rx1580_cur."!mark_push"(0, rx1580_pos, $I10)
  rxscan1584_done:
.annotate 'line', 634
  # rx literal  "["
    add $I11, rx1580_pos, 1
    gt $I11, rx1580_eos, rx1580_fail
    sub $I11, rx1580_pos, rx1580_off
    ord $I11, rx1580_tgt, $I11
    ne $I11, 91, rx1580_fail
    add rx1580_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1580_cur."!cursor_pos"(rx1580_pos)
    $P10 = rx1580_cur."ws"()
    unless $P10, rx1580_fail
    rx1580_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1580_cur."!cursor_pos"(rx1580_pos)
    $P10 = rx1580_cur."EXPR"()
    unless $P10, rx1580_fail
    rx1580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1580_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1580_pos, 1
    gt $I11, rx1580_eos, rx1580_fail
    sub $I11, rx1580_pos, rx1580_off
    ord $I11, rx1580_tgt, $I11
    ne $I11, 93, rx1580_fail
    add rx1580_pos, 1
.annotate 'line', 635
  # rx subrule "O" subtype=capture negate=
    rx1580_cur."!cursor_pos"(rx1580_pos)
    $P10 = rx1580_cur."O"("%methodop")
    unless $P10, rx1580_fail
    rx1580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1580_pos = $P10."pos"()
.annotate 'line', 633
  # rx pass
    rx1580_cur."!cursor_pass"(rx1580_pos, "postcircumfix:sym<[ ]>")
    if_null rx1580_debug, debug_1207
    rx1580_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1580_pos)
  debug_1207:
    .return (rx1580_cur)
  rx1580_restart:
.annotate 'line', 10
    if_null rx1580_debug, debug_1208
    rx1580_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1208:
  rx1580_fail:
    (rx1580_rep, rx1580_pos, $I10, $P10) = rx1580_cur."!mark_fail"(0)
    lt rx1580_pos, -1, rx1580_done
    eq rx1580_pos, -1, rx1580_fail
    jump $I10
  rx1580_done:
    rx1580_cur."!cursor_fail"()
    if_null rx1580_debug, debug_1209
    rx1580_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1209:
    .return (rx1580_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("280_1304277427.017") :method
.annotate 'line', 10
    $P1582 = self."!PREFIX__!subrule"("ws", "[")
    new $P1583, "ResizablePMCArray"
    push $P1583, $P1582
    .return ($P1583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("281_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1586_tgt
    .local int rx1586_pos
    .local int rx1586_off
    .local int rx1586_eos
    .local int rx1586_rep
    .local pmc rx1586_cur
    .local pmc rx1586_debug
    (rx1586_cur, rx1586_pos, rx1586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1586_cur
    .local pmc match
    .lex "$/", match
    length rx1586_eos, rx1586_tgt
    gt rx1586_pos, rx1586_eos, rx1586_done
    set rx1586_off, 0
    lt rx1586_pos, 2, rx1586_start
    sub rx1586_off, rx1586_pos, 1
    substr rx1586_tgt, rx1586_tgt, rx1586_off
  rx1586_start:
    eq $I10, 1, rx1586_restart
    if_null rx1586_debug, debug_1210
    rx1586_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1210:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1590_done
    goto rxscan1590_scan
  rxscan1590_loop:
    (rx1586_pos) = rx1586_cur."from"()
    inc rx1586_pos
    rx1586_cur."!cursor_from"(rx1586_pos)
    ge rx1586_pos, rx1586_eos, rxscan1590_done
  rxscan1590_scan:
    set_addr $I10, rxscan1590_loop
    rx1586_cur."!mark_push"(0, rx1586_pos, $I10)
  rxscan1590_done:
.annotate 'line', 639
  # rx literal  "{"
    add $I11, rx1586_pos, 1
    gt $I11, rx1586_eos, rx1586_fail
    sub $I11, rx1586_pos, rx1586_off
    ord $I11, rx1586_tgt, $I11
    ne $I11, 123, rx1586_fail
    add rx1586_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1586_cur."!cursor_pos"(rx1586_pos)
    $P10 = rx1586_cur."ws"()
    unless $P10, rx1586_fail
    rx1586_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1586_cur."!cursor_pos"(rx1586_pos)
    $P10 = rx1586_cur."EXPR"()
    unless $P10, rx1586_fail
    rx1586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1586_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1586_pos, 1
    gt $I11, rx1586_eos, rx1586_fail
    sub $I11, rx1586_pos, rx1586_off
    ord $I11, rx1586_tgt, $I11
    ne $I11, 125, rx1586_fail
    add rx1586_pos, 1
.annotate 'line', 640
  # rx subrule "O" subtype=capture negate=
    rx1586_cur."!cursor_pos"(rx1586_pos)
    $P10 = rx1586_cur."O"("%methodop")
    unless $P10, rx1586_fail
    rx1586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1586_pos = $P10."pos"()
.annotate 'line', 638
  # rx pass
    rx1586_cur."!cursor_pass"(rx1586_pos, "postcircumfix:sym<{ }>")
    if_null rx1586_debug, debug_1211
    rx1586_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1586_pos)
  debug_1211:
    .return (rx1586_cur)
  rx1586_restart:
.annotate 'line', 10
    if_null rx1586_debug, debug_1212
    rx1586_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1212:
  rx1586_fail:
    (rx1586_rep, rx1586_pos, $I10, $P10) = rx1586_cur."!mark_fail"(0)
    lt rx1586_pos, -1, rx1586_done
    eq rx1586_pos, -1, rx1586_fail
    jump $I10
  rx1586_done:
    rx1586_cur."!cursor_fail"()
    if_null rx1586_debug, debug_1213
    rx1586_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1213:
    .return (rx1586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("282_1304277427.017") :method
.annotate 'line', 10
    $P1588 = self."!PREFIX__!subrule"("ws", "{")
    new $P1589, "ResizablePMCArray"
    push $P1589, $P1588
    .return ($P1589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("283_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1592_tgt
    .local int rx1592_pos
    .local int rx1592_off
    .local int rx1592_eos
    .local int rx1592_rep
    .local pmc rx1592_cur
    .local pmc rx1592_debug
    (rx1592_cur, rx1592_pos, rx1592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1592_cur
    .local pmc match
    .lex "$/", match
    length rx1592_eos, rx1592_tgt
    gt rx1592_pos, rx1592_eos, rx1592_done
    set rx1592_off, 0
    lt rx1592_pos, 2, rx1592_start
    sub rx1592_off, rx1592_pos, 1
    substr rx1592_tgt, rx1592_tgt, rx1592_off
  rx1592_start:
    eq $I10, 1, rx1592_restart
    if_null rx1592_debug, debug_1214
    rx1592_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1214:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1592_pos) = rx1592_cur."from"()
    inc rx1592_pos
    rx1592_cur."!cursor_from"(rx1592_pos)
    ge rx1592_pos, rx1592_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1592_cur."!mark_push"(0, rx1592_pos, $I10)
  rxscan1595_done:
.annotate 'line', 644
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1592_pos, rx1592_off
    substr $S10, rx1592_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1592_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1592_cur."!cursor_pos"(rx1592_pos)
    $P10 = rx1592_cur."quote_EXPR"(":q")
    unless $P10, rx1592_fail
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1592_pos = $P10."pos"()
.annotate 'line', 645
  # rx subrule "O" subtype=capture negate=
    rx1592_cur."!cursor_pos"(rx1592_pos)
    $P10 = rx1592_cur."O"("%methodop")
    unless $P10, rx1592_fail
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1592_pos = $P10."pos"()
.annotate 'line', 643
  # rx pass
    rx1592_cur."!cursor_pass"(rx1592_pos, "postcircumfix:sym<ang>")
    if_null rx1592_debug, debug_1215
    rx1592_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1592_pos)
  debug_1215:
    .return (rx1592_cur)
  rx1592_restart:
.annotate 'line', 10
    if_null rx1592_debug, debug_1216
    rx1592_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1216:
  rx1592_fail:
    (rx1592_rep, rx1592_pos, $I10, $P10) = rx1592_cur."!mark_fail"(0)
    lt rx1592_pos, -1, rx1592_done
    eq rx1592_pos, -1, rx1592_fail
    jump $I10
  rx1592_done:
    rx1592_cur."!cursor_fail"()
    if_null rx1592_debug, debug_1217
    rx1592_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1217:
    .return (rx1592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("284_1304277427.017") :method
.annotate 'line', 10
    new $P1594, "ResizablePMCArray"
    push $P1594, "<"
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("285_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1597_tgt
    .local int rx1597_pos
    .local int rx1597_off
    .local int rx1597_eos
    .local int rx1597_rep
    .local pmc rx1597_cur
    .local pmc rx1597_debug
    (rx1597_cur, rx1597_pos, rx1597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1597_cur
    .local pmc match
    .lex "$/", match
    length rx1597_eos, rx1597_tgt
    gt rx1597_pos, rx1597_eos, rx1597_done
    set rx1597_off, 0
    lt rx1597_pos, 2, rx1597_start
    sub rx1597_off, rx1597_pos, 1
    substr rx1597_tgt, rx1597_tgt, rx1597_off
  rx1597_start:
    eq $I10, 1, rx1597_restart
    if_null rx1597_debug, debug_1218
    rx1597_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1218:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1597_pos) = rx1597_cur."from"()
    inc rx1597_pos
    rx1597_cur."!cursor_from"(rx1597_pos)
    ge rx1597_pos, rx1597_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  rxscan1601_done:
.annotate 'line', 649
  # rx literal  "("
    add $I11, rx1597_pos, 1
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    ord $I11, rx1597_tgt, $I11
    ne $I11, 40, rx1597_fail
    add rx1597_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."ws"()
    unless $P10, rx1597_fail
    rx1597_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."arglist"()
    unless $P10, rx1597_fail
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1597_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1597_pos, 1
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    ord $I11, rx1597_tgt, $I11
    ne $I11, 41, rx1597_fail
    add rx1597_pos, 1
.annotate 'line', 650
  # rx subrule "O" subtype=capture negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."O"("%methodop")
    unless $P10, rx1597_fail
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1597_pos = $P10."pos"()
.annotate 'line', 648
  # rx pass
    rx1597_cur."!cursor_pass"(rx1597_pos, "postcircumfix:sym<( )>")
    if_null rx1597_debug, debug_1219
    rx1597_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1597_pos)
  debug_1219:
    .return (rx1597_cur)
  rx1597_restart:
.annotate 'line', 10
    if_null rx1597_debug, debug_1220
    rx1597_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1220:
  rx1597_fail:
    (rx1597_rep, rx1597_pos, $I10, $P10) = rx1597_cur."!mark_fail"(0)
    lt rx1597_pos, -1, rx1597_done
    eq rx1597_pos, -1, rx1597_fail
    jump $I10
  rx1597_done:
    rx1597_cur."!cursor_fail"()
    if_null rx1597_debug, debug_1221
    rx1597_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1221:
    .return (rx1597_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("286_1304277427.017") :method
.annotate 'line', 10
    $P1599 = self."!PREFIX__!subrule"("ws", "(")
    new $P1600, "ResizablePMCArray"
    push $P1600, $P1599
    .return ($P1600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("287_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1603_tgt
    .local int rx1603_pos
    .local int rx1603_off
    .local int rx1603_eos
    .local int rx1603_rep
    .local pmc rx1603_cur
    .local pmc rx1603_debug
    (rx1603_cur, rx1603_pos, rx1603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1603_cur
    .local pmc match
    .lex "$/", match
    length rx1603_eos, rx1603_tgt
    gt rx1603_pos, rx1603_eos, rx1603_done
    set rx1603_off, 0
    lt rx1603_pos, 2, rx1603_start
    sub rx1603_off, rx1603_pos, 1
    substr rx1603_tgt, rx1603_tgt, rx1603_off
  rx1603_start:
    eq $I10, 1, rx1603_restart
    if_null rx1603_debug, debug_1222
    rx1603_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1222:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1607_done
    goto rxscan1607_scan
  rxscan1607_loop:
    (rx1603_pos) = rx1603_cur."from"()
    inc rx1603_pos
    rx1603_cur."!cursor_from"(rx1603_pos)
    ge rx1603_pos, rx1603_eos, rxscan1607_done
  rxscan1607_scan:
    set_addr $I10, rxscan1607_loop
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  rxscan1607_done:
.annotate 'line', 653
  # rx subrule "dotty" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."dotty"()
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1603_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."O"("%methodop")
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1603_pos = $P10."pos"()
  # rx pass
    rx1603_cur."!cursor_pass"(rx1603_pos, "postfix:sym<.>")
    if_null rx1603_debug, debug_1223
    rx1603_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1603_pos)
  debug_1223:
    .return (rx1603_cur)
  rx1603_restart:
.annotate 'line', 10
    if_null rx1603_debug, debug_1224
    rx1603_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1224:
  rx1603_fail:
    (rx1603_rep, rx1603_pos, $I10, $P10) = rx1603_cur."!mark_fail"(0)
    lt rx1603_pos, -1, rx1603_done
    eq rx1603_pos, -1, rx1603_fail
    jump $I10
  rx1603_done:
    rx1603_cur."!cursor_fail"()
    if_null rx1603_debug, debug_1225
    rx1603_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1225:
    .return (rx1603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("288_1304277427.017") :method
.annotate 'line', 10
    $P1605 = self."!PREFIX__!subrule"("dotty", "")
    new $P1606, "ResizablePMCArray"
    push $P1606, $P1605
    .return ($P1606)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("289_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1609_tgt
    .local int rx1609_pos
    .local int rx1609_off
    .local int rx1609_eos
    .local int rx1609_rep
    .local pmc rx1609_cur
    .local pmc rx1609_debug
    (rx1609_cur, rx1609_pos, rx1609_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1609_cur
    .local pmc match
    .lex "$/", match
    length rx1609_eos, rx1609_tgt
    gt rx1609_pos, rx1609_eos, rx1609_done
    set rx1609_off, 0
    lt rx1609_pos, 2, rx1609_start
    sub rx1609_off, rx1609_pos, 1
    substr rx1609_tgt, rx1609_tgt, rx1609_off
  rx1609_start:
    eq $I10, 1, rx1609_restart
    if_null rx1609_debug, debug_1226
    rx1609_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1226:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1609_pos) = rx1609_cur."from"()
    inc rx1609_pos
    rx1609_cur."!cursor_from"(rx1609_pos)
    ge rx1609_pos, rx1609_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1609_cur."!mark_push"(0, rx1609_pos, $I10)
  rxscan1613_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1614_fail
    rx1609_cur."!mark_push"(0, rx1609_pos, $I10)
  # rx literal  "++"
    add $I11, rx1609_pos, 2
    gt $I11, rx1609_eos, rx1609_fail
    sub $I11, rx1609_pos, rx1609_off
    substr $S10, rx1609_tgt, $I11, 2
    ne $S10, "++", rx1609_fail
    add rx1609_pos, 2
    set_addr $I10, rxcap_1614_fail
    ($I12, $I11) = rx1609_cur."!mark_peek"($I10)
    rx1609_cur."!cursor_pos"($I11)
    ($P10) = rx1609_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1609_pos, "")
    rx1609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1614_done
  rxcap_1614_fail:
    goto rx1609_fail
  rxcap_1614_done:
  # rx subrule "O" subtype=capture negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    $P10 = rx1609_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1609_fail
    rx1609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1609_pos = $P10."pos"()
  # rx pass
    rx1609_cur."!cursor_pass"(rx1609_pos, "prefix:sym<++>")
    if_null rx1609_debug, debug_1227
    rx1609_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1609_pos)
  debug_1227:
    .return (rx1609_cur)
  rx1609_restart:
.annotate 'line', 10
    if_null rx1609_debug, debug_1228
    rx1609_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1228:
  rx1609_fail:
    (rx1609_rep, rx1609_pos, $I10, $P10) = rx1609_cur."!mark_fail"(0)
    lt rx1609_pos, -1, rx1609_done
    eq rx1609_pos, -1, rx1609_fail
    jump $I10
  rx1609_done:
    rx1609_cur."!cursor_fail"()
    if_null rx1609_debug, debug_1229
    rx1609_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1229:
    .return (rx1609_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("290_1304277427.017") :method
.annotate 'line', 10
    $P1611 = self."!PREFIX__!subrule"("O", "++")
    new $P1612, "ResizablePMCArray"
    push $P1612, $P1611
    .return ($P1612)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("291_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1616_tgt
    .local int rx1616_pos
    .local int rx1616_off
    .local int rx1616_eos
    .local int rx1616_rep
    .local pmc rx1616_cur
    .local pmc rx1616_debug
    (rx1616_cur, rx1616_pos, rx1616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1616_cur
    .local pmc match
    .lex "$/", match
    length rx1616_eos, rx1616_tgt
    gt rx1616_pos, rx1616_eos, rx1616_done
    set rx1616_off, 0
    lt rx1616_pos, 2, rx1616_start
    sub rx1616_off, rx1616_pos, 1
    substr rx1616_tgt, rx1616_tgt, rx1616_off
  rx1616_start:
    eq $I10, 1, rx1616_restart
    if_null rx1616_debug, debug_1230
    rx1616_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1230:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1620_done
    goto rxscan1620_scan
  rxscan1620_loop:
    (rx1616_pos) = rx1616_cur."from"()
    inc rx1616_pos
    rx1616_cur."!cursor_from"(rx1616_pos)
    ge rx1616_pos, rx1616_eos, rxscan1620_done
  rxscan1620_scan:
    set_addr $I10, rxscan1620_loop
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  rxscan1620_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1621_fail
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  # rx literal  "--"
    add $I11, rx1616_pos, 2
    gt $I11, rx1616_eos, rx1616_fail
    sub $I11, rx1616_pos, rx1616_off
    substr $S10, rx1616_tgt, $I11, 2
    ne $S10, "--", rx1616_fail
    add rx1616_pos, 2
    set_addr $I10, rxcap_1621_fail
    ($I12, $I11) = rx1616_cur."!mark_peek"($I10)
    rx1616_cur."!cursor_pos"($I11)
    ($P10) = rx1616_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1616_pos, "")
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1621_done
  rxcap_1621_fail:
    goto rx1616_fail
  rxcap_1621_done:
  # rx subrule "O" subtype=capture negate=
    rx1616_cur."!cursor_pos"(rx1616_pos)
    $P10 = rx1616_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1616_fail
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1616_pos = $P10."pos"()
  # rx pass
    rx1616_cur."!cursor_pass"(rx1616_pos, "prefix:sym<-->")
    if_null rx1616_debug, debug_1231
    rx1616_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1616_pos)
  debug_1231:
    .return (rx1616_cur)
  rx1616_restart:
.annotate 'line', 10
    if_null rx1616_debug, debug_1232
    rx1616_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1232:
  rx1616_fail:
    (rx1616_rep, rx1616_pos, $I10, $P10) = rx1616_cur."!mark_fail"(0)
    lt rx1616_pos, -1, rx1616_done
    eq rx1616_pos, -1, rx1616_fail
    jump $I10
  rx1616_done:
    rx1616_cur."!cursor_fail"()
    if_null rx1616_debug, debug_1233
    rx1616_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1233:
    .return (rx1616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("292_1304277427.017") :method
.annotate 'line', 10
    $P1618 = self."!PREFIX__!subrule"("O", "--")
    new $P1619, "ResizablePMCArray"
    push $P1619, $P1618
    .return ($P1619)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("293_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1623_tgt
    .local int rx1623_pos
    .local int rx1623_off
    .local int rx1623_eos
    .local int rx1623_rep
    .local pmc rx1623_cur
    .local pmc rx1623_debug
    (rx1623_cur, rx1623_pos, rx1623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1623_cur
    .local pmc match
    .lex "$/", match
    length rx1623_eos, rx1623_tgt
    gt rx1623_pos, rx1623_eos, rx1623_done
    set rx1623_off, 0
    lt rx1623_pos, 2, rx1623_start
    sub rx1623_off, rx1623_pos, 1
    substr rx1623_tgt, rx1623_tgt, rx1623_off
  rx1623_start:
    eq $I10, 1, rx1623_restart
    if_null rx1623_debug, debug_1234
    rx1623_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1234:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1623_pos) = rx1623_cur."from"()
    inc rx1623_pos
    rx1623_cur."!cursor_from"(rx1623_pos)
    ge rx1623_pos, rx1623_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
  rxscan1627_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1628_fail
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
  # rx literal  "++"
    add $I11, rx1623_pos, 2
    gt $I11, rx1623_eos, rx1623_fail
    sub $I11, rx1623_pos, rx1623_off
    substr $S10, rx1623_tgt, $I11, 2
    ne $S10, "++", rx1623_fail
    add rx1623_pos, 2
    set_addr $I10, rxcap_1628_fail
    ($I12, $I11) = rx1623_cur."!mark_peek"($I10)
    rx1623_cur."!cursor_pos"($I11)
    ($P10) = rx1623_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1623_pos, "")
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1628_done
  rxcap_1628_fail:
    goto rx1623_fail
  rxcap_1628_done:
  # rx subrule "O" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."O"("%autoincrement")
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1623_pos = $P10."pos"()
  # rx pass
    rx1623_cur."!cursor_pass"(rx1623_pos, "postfix:sym<++>")
    if_null rx1623_debug, debug_1235
    rx1623_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1623_pos)
  debug_1235:
    .return (rx1623_cur)
  rx1623_restart:
.annotate 'line', 10
    if_null rx1623_debug, debug_1236
    rx1623_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1236:
  rx1623_fail:
    (rx1623_rep, rx1623_pos, $I10, $P10) = rx1623_cur."!mark_fail"(0)
    lt rx1623_pos, -1, rx1623_done
    eq rx1623_pos, -1, rx1623_fail
    jump $I10
  rx1623_done:
    rx1623_cur."!cursor_fail"()
    if_null rx1623_debug, debug_1237
    rx1623_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1237:
    .return (rx1623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("294_1304277427.017") :method
.annotate 'line', 10
    $P1625 = self."!PREFIX__!subrule"("O", "++")
    new $P1626, "ResizablePMCArray"
    push $P1626, $P1625
    .return ($P1626)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("295_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1630_tgt
    .local int rx1630_pos
    .local int rx1630_off
    .local int rx1630_eos
    .local int rx1630_rep
    .local pmc rx1630_cur
    .local pmc rx1630_debug
    (rx1630_cur, rx1630_pos, rx1630_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1630_cur
    .local pmc match
    .lex "$/", match
    length rx1630_eos, rx1630_tgt
    gt rx1630_pos, rx1630_eos, rx1630_done
    set rx1630_off, 0
    lt rx1630_pos, 2, rx1630_start
    sub rx1630_off, rx1630_pos, 1
    substr rx1630_tgt, rx1630_tgt, rx1630_off
  rx1630_start:
    eq $I10, 1, rx1630_restart
    if_null rx1630_debug, debug_1238
    rx1630_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1238:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1634_done
    goto rxscan1634_scan
  rxscan1634_loop:
    (rx1630_pos) = rx1630_cur."from"()
    inc rx1630_pos
    rx1630_cur."!cursor_from"(rx1630_pos)
    ge rx1630_pos, rx1630_eos, rxscan1634_done
  rxscan1634_scan:
    set_addr $I10, rxscan1634_loop
    rx1630_cur."!mark_push"(0, rx1630_pos, $I10)
  rxscan1634_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1635_fail
    rx1630_cur."!mark_push"(0, rx1630_pos, $I10)
  # rx literal  "--"
    add $I11, rx1630_pos, 2
    gt $I11, rx1630_eos, rx1630_fail
    sub $I11, rx1630_pos, rx1630_off
    substr $S10, rx1630_tgt, $I11, 2
    ne $S10, "--", rx1630_fail
    add rx1630_pos, 2
    set_addr $I10, rxcap_1635_fail
    ($I12, $I11) = rx1630_cur."!mark_peek"($I10)
    rx1630_cur."!cursor_pos"($I11)
    ($P10) = rx1630_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1630_pos, "")
    rx1630_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1635_done
  rxcap_1635_fail:
    goto rx1630_fail
  rxcap_1635_done:
  # rx subrule "O" subtype=capture negate=
    rx1630_cur."!cursor_pos"(rx1630_pos)
    $P10 = rx1630_cur."O"("%autoincrement")
    unless $P10, rx1630_fail
    rx1630_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1630_pos = $P10."pos"()
  # rx pass
    rx1630_cur."!cursor_pass"(rx1630_pos, "postfix:sym<-->")
    if_null rx1630_debug, debug_1239
    rx1630_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1630_pos)
  debug_1239:
    .return (rx1630_cur)
  rx1630_restart:
.annotate 'line', 10
    if_null rx1630_debug, debug_1240
    rx1630_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1240:
  rx1630_fail:
    (rx1630_rep, rx1630_pos, $I10, $P10) = rx1630_cur."!mark_fail"(0)
    lt rx1630_pos, -1, rx1630_done
    eq rx1630_pos, -1, rx1630_fail
    jump $I10
  rx1630_done:
    rx1630_cur."!cursor_fail"()
    if_null rx1630_debug, debug_1241
    rx1630_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1241:
    .return (rx1630_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("296_1304277427.017") :method
.annotate 'line', 10
    $P1632 = self."!PREFIX__!subrule"("O", "--")
    new $P1633, "ResizablePMCArray"
    push $P1633, $P1632
    .return ($P1633)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("297_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1637_tgt
    .local int rx1637_pos
    .local int rx1637_off
    .local int rx1637_eos
    .local int rx1637_rep
    .local pmc rx1637_cur
    .local pmc rx1637_debug
    (rx1637_cur, rx1637_pos, rx1637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1637_cur
    .local pmc match
    .lex "$/", match
    length rx1637_eos, rx1637_tgt
    gt rx1637_pos, rx1637_eos, rx1637_done
    set rx1637_off, 0
    lt rx1637_pos, 2, rx1637_start
    sub rx1637_off, rx1637_pos, 1
    substr rx1637_tgt, rx1637_tgt, rx1637_off
  rx1637_start:
    eq $I10, 1, rx1637_restart
    if_null rx1637_debug, debug_1242
    rx1637_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1242:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1641_done
    goto rxscan1641_scan
  rxscan1641_loop:
    (rx1637_pos) = rx1637_cur."from"()
    inc rx1637_pos
    rx1637_cur."!cursor_from"(rx1637_pos)
    ge rx1637_pos, rx1637_eos, rxscan1641_done
  rxscan1641_scan:
    set_addr $I10, rxscan1641_loop
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  rxscan1641_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1642_fail
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  # rx literal  "**"
    add $I11, rx1637_pos, 2
    gt $I11, rx1637_eos, rx1637_fail
    sub $I11, rx1637_pos, rx1637_off
    substr $S10, rx1637_tgt, $I11, 2
    ne $S10, "**", rx1637_fail
    add rx1637_pos, 2
    set_addr $I10, rxcap_1642_fail
    ($I12, $I11) = rx1637_cur."!mark_peek"($I10)
    rx1637_cur."!cursor_pos"($I11)
    ($P10) = rx1637_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1637_pos, "")
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1642_done
  rxcap_1642_fail:
    goto rx1637_fail
  rxcap_1642_done:
  # rx subrule "O" subtype=capture negate=
    rx1637_cur."!cursor_pos"(rx1637_pos)
    $P10 = rx1637_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1637_fail
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1637_pos = $P10."pos"()
  # rx pass
    rx1637_cur."!cursor_pass"(rx1637_pos, "infix:sym<**>")
    if_null rx1637_debug, debug_1243
    rx1637_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1637_pos)
  debug_1243:
    .return (rx1637_cur)
  rx1637_restart:
.annotate 'line', 10
    if_null rx1637_debug, debug_1244
    rx1637_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1244:
  rx1637_fail:
    (rx1637_rep, rx1637_pos, $I10, $P10) = rx1637_cur."!mark_fail"(0)
    lt rx1637_pos, -1, rx1637_done
    eq rx1637_pos, -1, rx1637_fail
    jump $I10
  rx1637_done:
    rx1637_cur."!cursor_fail"()
    if_null rx1637_debug, debug_1245
    rx1637_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1245:
    .return (rx1637_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("298_1304277427.017") :method
.annotate 'line', 10
    $P1639 = self."!PREFIX__!subrule"("O", "**")
    new $P1640, "ResizablePMCArray"
    push $P1640, $P1639
    .return ($P1640)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("299_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1644_tgt
    .local int rx1644_pos
    .local int rx1644_off
    .local int rx1644_eos
    .local int rx1644_rep
    .local pmc rx1644_cur
    .local pmc rx1644_debug
    (rx1644_cur, rx1644_pos, rx1644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1644_cur
    .local pmc match
    .lex "$/", match
    length rx1644_eos, rx1644_tgt
    gt rx1644_pos, rx1644_eos, rx1644_done
    set rx1644_off, 0
    lt rx1644_pos, 2, rx1644_start
    sub rx1644_off, rx1644_pos, 1
    substr rx1644_tgt, rx1644_tgt, rx1644_off
  rx1644_start:
    eq $I10, 1, rx1644_restart
    if_null rx1644_debug, debug_1246
    rx1644_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1246:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1648_done
    goto rxscan1648_scan
  rxscan1648_loop:
    (rx1644_pos) = rx1644_cur."from"()
    inc rx1644_pos
    rx1644_cur."!cursor_from"(rx1644_pos)
    ge rx1644_pos, rx1644_eos, rxscan1648_done
  rxscan1648_scan:
    set_addr $I10, rxscan1648_loop
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  rxscan1648_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1649_fail
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  # rx literal  "+"
    add $I11, rx1644_pos, 1
    gt $I11, rx1644_eos, rx1644_fail
    sub $I11, rx1644_pos, rx1644_off
    ord $I11, rx1644_tgt, $I11
    ne $I11, 43, rx1644_fail
    add rx1644_pos, 1
    set_addr $I10, rxcap_1649_fail
    ($I12, $I11) = rx1644_cur."!mark_peek"($I10)
    rx1644_cur."!cursor_pos"($I11)
    ($P10) = rx1644_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1644_pos, "")
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1649_done
  rxcap_1649_fail:
    goto rx1644_fail
  rxcap_1649_done:
  # rx subrule "O" subtype=capture negate=
    rx1644_cur."!cursor_pos"(rx1644_pos)
    $P10 = rx1644_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1644_fail
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1644_pos = $P10."pos"()
  # rx pass
    rx1644_cur."!cursor_pass"(rx1644_pos, "prefix:sym<+>")
    if_null rx1644_debug, debug_1247
    rx1644_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1644_pos)
  debug_1247:
    .return (rx1644_cur)
  rx1644_restart:
.annotate 'line', 10
    if_null rx1644_debug, debug_1248
    rx1644_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1248:
  rx1644_fail:
    (rx1644_rep, rx1644_pos, $I10, $P10) = rx1644_cur."!mark_fail"(0)
    lt rx1644_pos, -1, rx1644_done
    eq rx1644_pos, -1, rx1644_fail
    jump $I10
  rx1644_done:
    rx1644_cur."!cursor_fail"()
    if_null rx1644_debug, debug_1249
    rx1644_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1249:
    .return (rx1644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("300_1304277427.017") :method
.annotate 'line', 10
    $P1646 = self."!PREFIX__!subrule"("O", "+")
    new $P1647, "ResizablePMCArray"
    push $P1647, $P1646
    .return ($P1647)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("301_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1651_tgt
    .local int rx1651_pos
    .local int rx1651_off
    .local int rx1651_eos
    .local int rx1651_rep
    .local pmc rx1651_cur
    .local pmc rx1651_debug
    (rx1651_cur, rx1651_pos, rx1651_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1651_cur
    .local pmc match
    .lex "$/", match
    length rx1651_eos, rx1651_tgt
    gt rx1651_pos, rx1651_eos, rx1651_done
    set rx1651_off, 0
    lt rx1651_pos, 2, rx1651_start
    sub rx1651_off, rx1651_pos, 1
    substr rx1651_tgt, rx1651_tgt, rx1651_off
  rx1651_start:
    eq $I10, 1, rx1651_restart
    if_null rx1651_debug, debug_1250
    rx1651_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1250:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1651_pos) = rx1651_cur."from"()
    inc rx1651_pos
    rx1651_cur."!cursor_from"(rx1651_pos)
    ge rx1651_pos, rx1651_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1651_cur."!mark_push"(0, rx1651_pos, $I10)
  rxscan1655_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1656_fail
    rx1651_cur."!mark_push"(0, rx1651_pos, $I10)
  # rx literal  "~"
    add $I11, rx1651_pos, 1
    gt $I11, rx1651_eos, rx1651_fail
    sub $I11, rx1651_pos, rx1651_off
    ord $I11, rx1651_tgt, $I11
    ne $I11, 126, rx1651_fail
    add rx1651_pos, 1
    set_addr $I10, rxcap_1656_fail
    ($I12, $I11) = rx1651_cur."!mark_peek"($I10)
    rx1651_cur."!cursor_pos"($I11)
    ($P10) = rx1651_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1651_pos, "")
    rx1651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1656_done
  rxcap_1656_fail:
    goto rx1651_fail
  rxcap_1656_done:
  # rx subrule "O" subtype=capture negate=
    rx1651_cur."!cursor_pos"(rx1651_pos)
    $P10 = rx1651_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1651_fail
    rx1651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1651_pos = $P10."pos"()
  # rx pass
    rx1651_cur."!cursor_pass"(rx1651_pos, "prefix:sym<~>")
    if_null rx1651_debug, debug_1251
    rx1651_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1651_pos)
  debug_1251:
    .return (rx1651_cur)
  rx1651_restart:
.annotate 'line', 10
    if_null rx1651_debug, debug_1252
    rx1651_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1252:
  rx1651_fail:
    (rx1651_rep, rx1651_pos, $I10, $P10) = rx1651_cur."!mark_fail"(0)
    lt rx1651_pos, -1, rx1651_done
    eq rx1651_pos, -1, rx1651_fail
    jump $I10
  rx1651_done:
    rx1651_cur."!cursor_fail"()
    if_null rx1651_debug, debug_1253
    rx1651_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1253:
    .return (rx1651_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("302_1304277427.017") :method
.annotate 'line', 10
    $P1653 = self."!PREFIX__!subrule"("O", "~")
    new $P1654, "ResizablePMCArray"
    push $P1654, $P1653
    .return ($P1654)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("303_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1658_tgt
    .local int rx1658_pos
    .local int rx1658_off
    .local int rx1658_eos
    .local int rx1658_rep
    .local pmc rx1658_cur
    .local pmc rx1658_debug
    (rx1658_cur, rx1658_pos, rx1658_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1658_cur
    .local pmc match
    .lex "$/", match
    length rx1658_eos, rx1658_tgt
    gt rx1658_pos, rx1658_eos, rx1658_done
    set rx1658_off, 0
    lt rx1658_pos, 2, rx1658_start
    sub rx1658_off, rx1658_pos, 1
    substr rx1658_tgt, rx1658_tgt, rx1658_off
  rx1658_start:
    eq $I10, 1, rx1658_restart
    if_null rx1658_debug, debug_1254
    rx1658_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1254:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1661_done
    goto rxscan1661_scan
  rxscan1661_loop:
    (rx1658_pos) = rx1658_cur."from"()
    inc rx1658_pos
    rx1658_cur."!cursor_from"(rx1658_pos)
    ge rx1658_pos, rx1658_eos, rxscan1661_done
  rxscan1661_scan:
    set_addr $I10, rxscan1661_loop
    rx1658_cur."!mark_push"(0, rx1658_pos, $I10)
  rxscan1661_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1662_fail
    rx1658_cur."!mark_push"(0, rx1658_pos, $I10)
  # rx literal  "-"
    add $I11, rx1658_pos, 1
    gt $I11, rx1658_eos, rx1658_fail
    sub $I11, rx1658_pos, rx1658_off
    ord $I11, rx1658_tgt, $I11
    ne $I11, 45, rx1658_fail
    add rx1658_pos, 1
    set_addr $I10, rxcap_1662_fail
    ($I12, $I11) = rx1658_cur."!mark_peek"($I10)
    rx1658_cur."!cursor_pos"($I11)
    ($P10) = rx1658_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1658_pos, "")
    rx1658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1662_done
  rxcap_1662_fail:
    goto rx1658_fail
  rxcap_1662_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1658_pos, rx1658_off
    substr $S10, rx1658_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1658_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1658_cur."!cursor_pos"(rx1658_pos)
    $P10 = rx1658_cur."number"()
    if $P10, rx1658_fail
  # rx subrule "O" subtype=capture negate=
    rx1658_cur."!cursor_pos"(rx1658_pos)
    $P10 = rx1658_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1658_fail
    rx1658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1658_pos = $P10."pos"()
  # rx pass
    rx1658_cur."!cursor_pass"(rx1658_pos, "prefix:sym<->")
    if_null rx1658_debug, debug_1255
    rx1658_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1658_pos)
  debug_1255:
    .return (rx1658_cur)
  rx1658_restart:
.annotate 'line', 10
    if_null rx1658_debug, debug_1256
    rx1658_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1256:
  rx1658_fail:
    (rx1658_rep, rx1658_pos, $I10, $P10) = rx1658_cur."!mark_fail"(0)
    lt rx1658_pos, -1, rx1658_done
    eq rx1658_pos, -1, rx1658_fail
    jump $I10
  rx1658_done:
    rx1658_cur."!cursor_fail"()
    if_null rx1658_debug, debug_1257
    rx1658_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1257:
    .return (rx1658_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("304_1304277427.017") :method
.annotate 'line', 10
    new $P1660, "ResizablePMCArray"
    push $P1660, "-"
    .return ($P1660)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("305_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1664_tgt
    .local int rx1664_pos
    .local int rx1664_off
    .local int rx1664_eos
    .local int rx1664_rep
    .local pmc rx1664_cur
    .local pmc rx1664_debug
    (rx1664_cur, rx1664_pos, rx1664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1664_cur
    .local pmc match
    .lex "$/", match
    length rx1664_eos, rx1664_tgt
    gt rx1664_pos, rx1664_eos, rx1664_done
    set rx1664_off, 0
    lt rx1664_pos, 2, rx1664_start
    sub rx1664_off, rx1664_pos, 1
    substr rx1664_tgt, rx1664_tgt, rx1664_off
  rx1664_start:
    eq $I10, 1, rx1664_restart
    if_null rx1664_debug, debug_1258
    rx1664_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1258:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1668_done
    goto rxscan1668_scan
  rxscan1668_loop:
    (rx1664_pos) = rx1664_cur."from"()
    inc rx1664_pos
    rx1664_cur."!cursor_from"(rx1664_pos)
    ge rx1664_pos, rx1664_eos, rxscan1668_done
  rxscan1668_scan:
    set_addr $I10, rxscan1668_loop
    rx1664_cur."!mark_push"(0, rx1664_pos, $I10)
  rxscan1668_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1669_fail
    rx1664_cur."!mark_push"(0, rx1664_pos, $I10)
  # rx literal  "?"
    add $I11, rx1664_pos, 1
    gt $I11, rx1664_eos, rx1664_fail
    sub $I11, rx1664_pos, rx1664_off
    ord $I11, rx1664_tgt, $I11
    ne $I11, 63, rx1664_fail
    add rx1664_pos, 1
    set_addr $I10, rxcap_1669_fail
    ($I12, $I11) = rx1664_cur."!mark_peek"($I10)
    rx1664_cur."!cursor_pos"($I11)
    ($P10) = rx1664_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1664_pos, "")
    rx1664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1669_done
  rxcap_1669_fail:
    goto rx1664_fail
  rxcap_1669_done:
  # rx subrule "O" subtype=capture negate=
    rx1664_cur."!cursor_pos"(rx1664_pos)
    $P10 = rx1664_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1664_fail
    rx1664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1664_pos = $P10."pos"()
  # rx pass
    rx1664_cur."!cursor_pass"(rx1664_pos, "prefix:sym<?>")
    if_null rx1664_debug, debug_1259
    rx1664_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1664_pos)
  debug_1259:
    .return (rx1664_cur)
  rx1664_restart:
.annotate 'line', 10
    if_null rx1664_debug, debug_1260
    rx1664_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1260:
  rx1664_fail:
    (rx1664_rep, rx1664_pos, $I10, $P10) = rx1664_cur."!mark_fail"(0)
    lt rx1664_pos, -1, rx1664_done
    eq rx1664_pos, -1, rx1664_fail
    jump $I10
  rx1664_done:
    rx1664_cur."!cursor_fail"()
    if_null rx1664_debug, debug_1261
    rx1664_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1261:
    .return (rx1664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("306_1304277427.017") :method
.annotate 'line', 10
    $P1666 = self."!PREFIX__!subrule"("O", "?")
    new $P1667, "ResizablePMCArray"
    push $P1667, $P1666
    .return ($P1667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("307_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1671_tgt
    .local int rx1671_pos
    .local int rx1671_off
    .local int rx1671_eos
    .local int rx1671_rep
    .local pmc rx1671_cur
    .local pmc rx1671_debug
    (rx1671_cur, rx1671_pos, rx1671_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1671_cur
    .local pmc match
    .lex "$/", match
    length rx1671_eos, rx1671_tgt
    gt rx1671_pos, rx1671_eos, rx1671_done
    set rx1671_off, 0
    lt rx1671_pos, 2, rx1671_start
    sub rx1671_off, rx1671_pos, 1
    substr rx1671_tgt, rx1671_tgt, rx1671_off
  rx1671_start:
    eq $I10, 1, rx1671_restart
    if_null rx1671_debug, debug_1262
    rx1671_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1262:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1675_done
    goto rxscan1675_scan
  rxscan1675_loop:
    (rx1671_pos) = rx1671_cur."from"()
    inc rx1671_pos
    rx1671_cur."!cursor_from"(rx1671_pos)
    ge rx1671_pos, rx1671_eos, rxscan1675_done
  rxscan1675_scan:
    set_addr $I10, rxscan1675_loop
    rx1671_cur."!mark_push"(0, rx1671_pos, $I10)
  rxscan1675_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1676_fail
    rx1671_cur."!mark_push"(0, rx1671_pos, $I10)
  # rx literal  "!"
    add $I11, rx1671_pos, 1
    gt $I11, rx1671_eos, rx1671_fail
    sub $I11, rx1671_pos, rx1671_off
    ord $I11, rx1671_tgt, $I11
    ne $I11, 33, rx1671_fail
    add rx1671_pos, 1
    set_addr $I10, rxcap_1676_fail
    ($I12, $I11) = rx1671_cur."!mark_peek"($I10)
    rx1671_cur."!cursor_pos"($I11)
    ($P10) = rx1671_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1671_pos, "")
    rx1671_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1676_done
  rxcap_1676_fail:
    goto rx1671_fail
  rxcap_1676_done:
  # rx subrule "O" subtype=capture negate=
    rx1671_cur."!cursor_pos"(rx1671_pos)
    $P10 = rx1671_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1671_fail
    rx1671_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1671_pos = $P10."pos"()
  # rx pass
    rx1671_cur."!cursor_pass"(rx1671_pos, "prefix:sym<!>")
    if_null rx1671_debug, debug_1263
    rx1671_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1671_pos)
  debug_1263:
    .return (rx1671_cur)
  rx1671_restart:
.annotate 'line', 10
    if_null rx1671_debug, debug_1264
    rx1671_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1264:
  rx1671_fail:
    (rx1671_rep, rx1671_pos, $I10, $P10) = rx1671_cur."!mark_fail"(0)
    lt rx1671_pos, -1, rx1671_done
    eq rx1671_pos, -1, rx1671_fail
    jump $I10
  rx1671_done:
    rx1671_cur."!cursor_fail"()
    if_null rx1671_debug, debug_1265
    rx1671_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1265:
    .return (rx1671_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("308_1304277427.017") :method
.annotate 'line', 10
    $P1673 = self."!PREFIX__!subrule"("O", "!")
    new $P1674, "ResizablePMCArray"
    push $P1674, $P1673
    .return ($P1674)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("309_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1678_tgt
    .local int rx1678_pos
    .local int rx1678_off
    .local int rx1678_eos
    .local int rx1678_rep
    .local pmc rx1678_cur
    .local pmc rx1678_debug
    (rx1678_cur, rx1678_pos, rx1678_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1678_cur
    .local pmc match
    .lex "$/", match
    length rx1678_eos, rx1678_tgt
    gt rx1678_pos, rx1678_eos, rx1678_done
    set rx1678_off, 0
    lt rx1678_pos, 2, rx1678_start
    sub rx1678_off, rx1678_pos, 1
    substr rx1678_tgt, rx1678_tgt, rx1678_off
  rx1678_start:
    eq $I10, 1, rx1678_restart
    if_null rx1678_debug, debug_1266
    rx1678_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1266:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1682_done
    goto rxscan1682_scan
  rxscan1682_loop:
    (rx1678_pos) = rx1678_cur."from"()
    inc rx1678_pos
    rx1678_cur."!cursor_from"(rx1678_pos)
    ge rx1678_pos, rx1678_eos, rxscan1682_done
  rxscan1682_scan:
    set_addr $I10, rxscan1682_loop
    rx1678_cur."!mark_push"(0, rx1678_pos, $I10)
  rxscan1682_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1683_fail
    rx1678_cur."!mark_push"(0, rx1678_pos, $I10)
  # rx literal  "|"
    add $I11, rx1678_pos, 1
    gt $I11, rx1678_eos, rx1678_fail
    sub $I11, rx1678_pos, rx1678_off
    ord $I11, rx1678_tgt, $I11
    ne $I11, 124, rx1678_fail
    add rx1678_pos, 1
    set_addr $I10, rxcap_1683_fail
    ($I12, $I11) = rx1678_cur."!mark_peek"($I10)
    rx1678_cur."!cursor_pos"($I11)
    ($P10) = rx1678_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1678_pos, "")
    rx1678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1683_done
  rxcap_1683_fail:
    goto rx1678_fail
  rxcap_1683_done:
  # rx subrule "O" subtype=capture negate=
    rx1678_cur."!cursor_pos"(rx1678_pos)
    $P10 = rx1678_cur."O"("%symbolic_unary")
    unless $P10, rx1678_fail
    rx1678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1678_pos = $P10."pos"()
  # rx pass
    rx1678_cur."!cursor_pass"(rx1678_pos, "prefix:sym<|>")
    if_null rx1678_debug, debug_1267
    rx1678_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1678_pos)
  debug_1267:
    .return (rx1678_cur)
  rx1678_restart:
.annotate 'line', 10
    if_null rx1678_debug, debug_1268
    rx1678_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1268:
  rx1678_fail:
    (rx1678_rep, rx1678_pos, $I10, $P10) = rx1678_cur."!mark_fail"(0)
    lt rx1678_pos, -1, rx1678_done
    eq rx1678_pos, -1, rx1678_fail
    jump $I10
  rx1678_done:
    rx1678_cur."!cursor_fail"()
    if_null rx1678_debug, debug_1269
    rx1678_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1269:
    .return (rx1678_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("310_1304277427.017") :method
.annotate 'line', 10
    $P1680 = self."!PREFIX__!subrule"("O", "|")
    new $P1681, "ResizablePMCArray"
    push $P1681, $P1680
    .return ($P1681)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("311_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1685_tgt
    .local int rx1685_pos
    .local int rx1685_off
    .local int rx1685_eos
    .local int rx1685_rep
    .local pmc rx1685_cur
    .local pmc rx1685_debug
    (rx1685_cur, rx1685_pos, rx1685_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1685_cur
    .local pmc match
    .lex "$/", match
    length rx1685_eos, rx1685_tgt
    gt rx1685_pos, rx1685_eos, rx1685_done
    set rx1685_off, 0
    lt rx1685_pos, 2, rx1685_start
    sub rx1685_off, rx1685_pos, 1
    substr rx1685_tgt, rx1685_tgt, rx1685_off
  rx1685_start:
    eq $I10, 1, rx1685_restart
    if_null rx1685_debug, debug_1270
    rx1685_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1270:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1689_done
    goto rxscan1689_scan
  rxscan1689_loop:
    (rx1685_pos) = rx1685_cur."from"()
    inc rx1685_pos
    rx1685_cur."!cursor_from"(rx1685_pos)
    ge rx1685_pos, rx1685_eos, rxscan1689_done
  rxscan1689_scan:
    set_addr $I10, rxscan1689_loop
    rx1685_cur."!mark_push"(0, rx1685_pos, $I10)
  rxscan1689_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1690_fail
    rx1685_cur."!mark_push"(0, rx1685_pos, $I10)
  # rx literal  "*"
    add $I11, rx1685_pos, 1
    gt $I11, rx1685_eos, rx1685_fail
    sub $I11, rx1685_pos, rx1685_off
    ord $I11, rx1685_tgt, $I11
    ne $I11, 42, rx1685_fail
    add rx1685_pos, 1
    set_addr $I10, rxcap_1690_fail
    ($I12, $I11) = rx1685_cur."!mark_peek"($I10)
    rx1685_cur."!cursor_pos"($I11)
    ($P10) = rx1685_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1685_pos, "")
    rx1685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1690_done
  rxcap_1690_fail:
    goto rx1685_fail
  rxcap_1690_done:
  # rx subrule "O" subtype=capture negate=
    rx1685_cur."!cursor_pos"(rx1685_pos)
    $P10 = rx1685_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1685_fail
    rx1685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1685_pos = $P10."pos"()
  # rx pass
    rx1685_cur."!cursor_pass"(rx1685_pos, "infix:sym<*>")
    if_null rx1685_debug, debug_1271
    rx1685_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1685_pos)
  debug_1271:
    .return (rx1685_cur)
  rx1685_restart:
.annotate 'line', 10
    if_null rx1685_debug, debug_1272
    rx1685_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1272:
  rx1685_fail:
    (rx1685_rep, rx1685_pos, $I10, $P10) = rx1685_cur."!mark_fail"(0)
    lt rx1685_pos, -1, rx1685_done
    eq rx1685_pos, -1, rx1685_fail
    jump $I10
  rx1685_done:
    rx1685_cur."!cursor_fail"()
    if_null rx1685_debug, debug_1273
    rx1685_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1273:
    .return (rx1685_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("312_1304277427.017") :method
.annotate 'line', 10
    $P1687 = self."!PREFIX__!subrule"("O", "*")
    new $P1688, "ResizablePMCArray"
    push $P1688, $P1687
    .return ($P1688)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("313_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1692_tgt
    .local int rx1692_pos
    .local int rx1692_off
    .local int rx1692_eos
    .local int rx1692_rep
    .local pmc rx1692_cur
    .local pmc rx1692_debug
    (rx1692_cur, rx1692_pos, rx1692_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1692_cur
    .local pmc match
    .lex "$/", match
    length rx1692_eos, rx1692_tgt
    gt rx1692_pos, rx1692_eos, rx1692_done
    set rx1692_off, 0
    lt rx1692_pos, 2, rx1692_start
    sub rx1692_off, rx1692_pos, 1
    substr rx1692_tgt, rx1692_tgt, rx1692_off
  rx1692_start:
    eq $I10, 1, rx1692_restart
    if_null rx1692_debug, debug_1274
    rx1692_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1274:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1696_done
    goto rxscan1696_scan
  rxscan1696_loop:
    (rx1692_pos) = rx1692_cur."from"()
    inc rx1692_pos
    rx1692_cur."!cursor_from"(rx1692_pos)
    ge rx1692_pos, rx1692_eos, rxscan1696_done
  rxscan1696_scan:
    set_addr $I10, rxscan1696_loop
    rx1692_cur."!mark_push"(0, rx1692_pos, $I10)
  rxscan1696_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1697_fail
    rx1692_cur."!mark_push"(0, rx1692_pos, $I10)
  # rx literal  "/"
    add $I11, rx1692_pos, 1
    gt $I11, rx1692_eos, rx1692_fail
    sub $I11, rx1692_pos, rx1692_off
    ord $I11, rx1692_tgt, $I11
    ne $I11, 47, rx1692_fail
    add rx1692_pos, 1
    set_addr $I10, rxcap_1697_fail
    ($I12, $I11) = rx1692_cur."!mark_peek"($I10)
    rx1692_cur."!cursor_pos"($I11)
    ($P10) = rx1692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1692_pos, "")
    rx1692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1697_done
  rxcap_1697_fail:
    goto rx1692_fail
  rxcap_1697_done:
  # rx subrule "O" subtype=capture negate=
    rx1692_cur."!cursor_pos"(rx1692_pos)
    $P10 = rx1692_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1692_fail
    rx1692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1692_pos = $P10."pos"()
  # rx pass
    rx1692_cur."!cursor_pass"(rx1692_pos, "infix:sym</>")
    if_null rx1692_debug, debug_1275
    rx1692_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1692_pos)
  debug_1275:
    .return (rx1692_cur)
  rx1692_restart:
.annotate 'line', 10
    if_null rx1692_debug, debug_1276
    rx1692_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1276:
  rx1692_fail:
    (rx1692_rep, rx1692_pos, $I10, $P10) = rx1692_cur."!mark_fail"(0)
    lt rx1692_pos, -1, rx1692_done
    eq rx1692_pos, -1, rx1692_fail
    jump $I10
  rx1692_done:
    rx1692_cur."!cursor_fail"()
    if_null rx1692_debug, debug_1277
    rx1692_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1277:
    .return (rx1692_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("314_1304277427.017") :method
.annotate 'line', 10
    $P1694 = self."!PREFIX__!subrule"("O", "/")
    new $P1695, "ResizablePMCArray"
    push $P1695, $P1694
    .return ($P1695)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("315_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1699_tgt
    .local int rx1699_pos
    .local int rx1699_off
    .local int rx1699_eos
    .local int rx1699_rep
    .local pmc rx1699_cur
    .local pmc rx1699_debug
    (rx1699_cur, rx1699_pos, rx1699_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1699_cur
    .local pmc match
    .lex "$/", match
    length rx1699_eos, rx1699_tgt
    gt rx1699_pos, rx1699_eos, rx1699_done
    set rx1699_off, 0
    lt rx1699_pos, 2, rx1699_start
    sub rx1699_off, rx1699_pos, 1
    substr rx1699_tgt, rx1699_tgt, rx1699_off
  rx1699_start:
    eq $I10, 1, rx1699_restart
    if_null rx1699_debug, debug_1278
    rx1699_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1278:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1703_done
    goto rxscan1703_scan
  rxscan1703_loop:
    (rx1699_pos) = rx1699_cur."from"()
    inc rx1699_pos
    rx1699_cur."!cursor_from"(rx1699_pos)
    ge rx1699_pos, rx1699_eos, rxscan1703_done
  rxscan1703_scan:
    set_addr $I10, rxscan1703_loop
    rx1699_cur."!mark_push"(0, rx1699_pos, $I10)
  rxscan1703_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1704_fail
    rx1699_cur."!mark_push"(0, rx1699_pos, $I10)
  # rx literal  "%"
    add $I11, rx1699_pos, 1
    gt $I11, rx1699_eos, rx1699_fail
    sub $I11, rx1699_pos, rx1699_off
    ord $I11, rx1699_tgt, $I11
    ne $I11, 37, rx1699_fail
    add rx1699_pos, 1
    set_addr $I10, rxcap_1704_fail
    ($I12, $I11) = rx1699_cur."!mark_peek"($I10)
    rx1699_cur."!cursor_pos"($I11)
    ($P10) = rx1699_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1699_pos, "")
    rx1699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1704_done
  rxcap_1704_fail:
    goto rx1699_fail
  rxcap_1704_done:
  # rx subrule "O" subtype=capture negate=
    rx1699_cur."!cursor_pos"(rx1699_pos)
    $P10 = rx1699_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1699_fail
    rx1699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1699_pos = $P10."pos"()
  # rx pass
    rx1699_cur."!cursor_pass"(rx1699_pos, "infix:sym<%>")
    if_null rx1699_debug, debug_1279
    rx1699_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1699_pos)
  debug_1279:
    .return (rx1699_cur)
  rx1699_restart:
.annotate 'line', 10
    if_null rx1699_debug, debug_1280
    rx1699_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1280:
  rx1699_fail:
    (rx1699_rep, rx1699_pos, $I10, $P10) = rx1699_cur."!mark_fail"(0)
    lt rx1699_pos, -1, rx1699_done
    eq rx1699_pos, -1, rx1699_fail
    jump $I10
  rx1699_done:
    rx1699_cur."!cursor_fail"()
    if_null rx1699_debug, debug_1281
    rx1699_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1281:
    .return (rx1699_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("316_1304277427.017") :method
.annotate 'line', 10
    $P1701 = self."!PREFIX__!subrule"("O", "%")
    new $P1702, "ResizablePMCArray"
    push $P1702, $P1701
    .return ($P1702)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("317_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1706_tgt
    .local int rx1706_pos
    .local int rx1706_off
    .local int rx1706_eos
    .local int rx1706_rep
    .local pmc rx1706_cur
    .local pmc rx1706_debug
    (rx1706_cur, rx1706_pos, rx1706_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1706_cur
    .local pmc match
    .lex "$/", match
    length rx1706_eos, rx1706_tgt
    gt rx1706_pos, rx1706_eos, rx1706_done
    set rx1706_off, 0
    lt rx1706_pos, 2, rx1706_start
    sub rx1706_off, rx1706_pos, 1
    substr rx1706_tgt, rx1706_tgt, rx1706_off
  rx1706_start:
    eq $I10, 1, rx1706_restart
    if_null rx1706_debug, debug_1282
    rx1706_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1282:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1710_done
    goto rxscan1710_scan
  rxscan1710_loop:
    (rx1706_pos) = rx1706_cur."from"()
    inc rx1706_pos
    rx1706_cur."!cursor_from"(rx1706_pos)
    ge rx1706_pos, rx1706_eos, rxscan1710_done
  rxscan1710_scan:
    set_addr $I10, rxscan1710_loop
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  rxscan1710_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1711_fail
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1706_pos, 2
    gt $I11, rx1706_eos, rx1706_fail
    sub $I11, rx1706_pos, rx1706_off
    substr $S10, rx1706_tgt, $I11, 2
    ne $S10, "+&", rx1706_fail
    add rx1706_pos, 2
    set_addr $I10, rxcap_1711_fail
    ($I12, $I11) = rx1706_cur."!mark_peek"($I10)
    rx1706_cur."!cursor_pos"($I11)
    ($P10) = rx1706_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1706_pos, "")
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1711_done
  rxcap_1711_fail:
    goto rx1706_fail
  rxcap_1711_done:
  # rx subrule "O" subtype=capture negate=
    rx1706_cur."!cursor_pos"(rx1706_pos)
    $P10 = rx1706_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1706_fail
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1706_pos = $P10."pos"()
  # rx pass
    rx1706_cur."!cursor_pass"(rx1706_pos, "infix:sym<+&>")
    if_null rx1706_debug, debug_1283
    rx1706_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1706_pos)
  debug_1283:
    .return (rx1706_cur)
  rx1706_restart:
.annotate 'line', 10
    if_null rx1706_debug, debug_1284
    rx1706_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1284:
  rx1706_fail:
    (rx1706_rep, rx1706_pos, $I10, $P10) = rx1706_cur."!mark_fail"(0)
    lt rx1706_pos, -1, rx1706_done
    eq rx1706_pos, -1, rx1706_fail
    jump $I10
  rx1706_done:
    rx1706_cur."!cursor_fail"()
    if_null rx1706_debug, debug_1285
    rx1706_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1285:
    .return (rx1706_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("318_1304277427.017") :method
.annotate 'line', 10
    $P1708 = self."!PREFIX__!subrule"("O", "+&")
    new $P1709, "ResizablePMCArray"
    push $P1709, $P1708
    .return ($P1709)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("319_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1713_tgt
    .local int rx1713_pos
    .local int rx1713_off
    .local int rx1713_eos
    .local int rx1713_rep
    .local pmc rx1713_cur
    .local pmc rx1713_debug
    (rx1713_cur, rx1713_pos, rx1713_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1713_cur
    .local pmc match
    .lex "$/", match
    length rx1713_eos, rx1713_tgt
    gt rx1713_pos, rx1713_eos, rx1713_done
    set rx1713_off, 0
    lt rx1713_pos, 2, rx1713_start
    sub rx1713_off, rx1713_pos, 1
    substr rx1713_tgt, rx1713_tgt, rx1713_off
  rx1713_start:
    eq $I10, 1, rx1713_restart
    if_null rx1713_debug, debug_1286
    rx1713_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1286:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1717_done
    goto rxscan1717_scan
  rxscan1717_loop:
    (rx1713_pos) = rx1713_cur."from"()
    inc rx1713_pos
    rx1713_cur."!cursor_from"(rx1713_pos)
    ge rx1713_pos, rx1713_eos, rxscan1717_done
  rxscan1717_scan:
    set_addr $I10, rxscan1717_loop
    rx1713_cur."!mark_push"(0, rx1713_pos, $I10)
  rxscan1717_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1718_fail
    rx1713_cur."!mark_push"(0, rx1713_pos, $I10)
  # rx literal  "+"
    add $I11, rx1713_pos, 1
    gt $I11, rx1713_eos, rx1713_fail
    sub $I11, rx1713_pos, rx1713_off
    ord $I11, rx1713_tgt, $I11
    ne $I11, 43, rx1713_fail
    add rx1713_pos, 1
    set_addr $I10, rxcap_1718_fail
    ($I12, $I11) = rx1713_cur."!mark_peek"($I10)
    rx1713_cur."!cursor_pos"($I11)
    ($P10) = rx1713_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1713_pos, "")
    rx1713_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1718_done
  rxcap_1718_fail:
    goto rx1713_fail
  rxcap_1718_done:
  # rx subrule "O" subtype=capture negate=
    rx1713_cur."!cursor_pos"(rx1713_pos)
    $P10 = rx1713_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1713_fail
    rx1713_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1713_pos = $P10."pos"()
  # rx pass
    rx1713_cur."!cursor_pass"(rx1713_pos, "infix:sym<+>")
    if_null rx1713_debug, debug_1287
    rx1713_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1713_pos)
  debug_1287:
    .return (rx1713_cur)
  rx1713_restart:
.annotate 'line', 10
    if_null rx1713_debug, debug_1288
    rx1713_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1288:
  rx1713_fail:
    (rx1713_rep, rx1713_pos, $I10, $P10) = rx1713_cur."!mark_fail"(0)
    lt rx1713_pos, -1, rx1713_done
    eq rx1713_pos, -1, rx1713_fail
    jump $I10
  rx1713_done:
    rx1713_cur."!cursor_fail"()
    if_null rx1713_debug, debug_1289
    rx1713_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1289:
    .return (rx1713_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("320_1304277427.017") :method
.annotate 'line', 10
    $P1715 = self."!PREFIX__!subrule"("O", "+")
    new $P1716, "ResizablePMCArray"
    push $P1716, $P1715
    .return ($P1716)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("321_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1720_tgt
    .local int rx1720_pos
    .local int rx1720_off
    .local int rx1720_eos
    .local int rx1720_rep
    .local pmc rx1720_cur
    .local pmc rx1720_debug
    (rx1720_cur, rx1720_pos, rx1720_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1720_cur
    .local pmc match
    .lex "$/", match
    length rx1720_eos, rx1720_tgt
    gt rx1720_pos, rx1720_eos, rx1720_done
    set rx1720_off, 0
    lt rx1720_pos, 2, rx1720_start
    sub rx1720_off, rx1720_pos, 1
    substr rx1720_tgt, rx1720_tgt, rx1720_off
  rx1720_start:
    eq $I10, 1, rx1720_restart
    if_null rx1720_debug, debug_1290
    rx1720_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1290:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1724_done
    goto rxscan1724_scan
  rxscan1724_loop:
    (rx1720_pos) = rx1720_cur."from"()
    inc rx1720_pos
    rx1720_cur."!cursor_from"(rx1720_pos)
    ge rx1720_pos, rx1720_eos, rxscan1724_done
  rxscan1724_scan:
    set_addr $I10, rxscan1724_loop
    rx1720_cur."!mark_push"(0, rx1720_pos, $I10)
  rxscan1724_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1725_fail
    rx1720_cur."!mark_push"(0, rx1720_pos, $I10)
  # rx literal  "-"
    add $I11, rx1720_pos, 1
    gt $I11, rx1720_eos, rx1720_fail
    sub $I11, rx1720_pos, rx1720_off
    ord $I11, rx1720_tgt, $I11
    ne $I11, 45, rx1720_fail
    add rx1720_pos, 1
    set_addr $I10, rxcap_1725_fail
    ($I12, $I11) = rx1720_cur."!mark_peek"($I10)
    rx1720_cur."!cursor_pos"($I11)
    ($P10) = rx1720_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1720_pos, "")
    rx1720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1725_done
  rxcap_1725_fail:
    goto rx1720_fail
  rxcap_1725_done:
  # rx subrule "O" subtype=capture negate=
    rx1720_cur."!cursor_pos"(rx1720_pos)
    $P10 = rx1720_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1720_fail
    rx1720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1720_pos = $P10."pos"()
  # rx pass
    rx1720_cur."!cursor_pass"(rx1720_pos, "infix:sym<->")
    if_null rx1720_debug, debug_1291
    rx1720_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1720_pos)
  debug_1291:
    .return (rx1720_cur)
  rx1720_restart:
.annotate 'line', 10
    if_null rx1720_debug, debug_1292
    rx1720_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1292:
  rx1720_fail:
    (rx1720_rep, rx1720_pos, $I10, $P10) = rx1720_cur."!mark_fail"(0)
    lt rx1720_pos, -1, rx1720_done
    eq rx1720_pos, -1, rx1720_fail
    jump $I10
  rx1720_done:
    rx1720_cur."!cursor_fail"()
    if_null rx1720_debug, debug_1293
    rx1720_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1293:
    .return (rx1720_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("322_1304277427.017") :method
.annotate 'line', 10
    $P1722 = self."!PREFIX__!subrule"("O", "-")
    new $P1723, "ResizablePMCArray"
    push $P1723, $P1722
    .return ($P1723)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("323_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1727_tgt
    .local int rx1727_pos
    .local int rx1727_off
    .local int rx1727_eos
    .local int rx1727_rep
    .local pmc rx1727_cur
    .local pmc rx1727_debug
    (rx1727_cur, rx1727_pos, rx1727_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1727_cur
    .local pmc match
    .lex "$/", match
    length rx1727_eos, rx1727_tgt
    gt rx1727_pos, rx1727_eos, rx1727_done
    set rx1727_off, 0
    lt rx1727_pos, 2, rx1727_start
    sub rx1727_off, rx1727_pos, 1
    substr rx1727_tgt, rx1727_tgt, rx1727_off
  rx1727_start:
    eq $I10, 1, rx1727_restart
    if_null rx1727_debug, debug_1294
    rx1727_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1294:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1731_done
    goto rxscan1731_scan
  rxscan1731_loop:
    (rx1727_pos) = rx1727_cur."from"()
    inc rx1727_pos
    rx1727_cur."!cursor_from"(rx1727_pos)
    ge rx1727_pos, rx1727_eos, rxscan1731_done
  rxscan1731_scan:
    set_addr $I10, rxscan1731_loop
    rx1727_cur."!mark_push"(0, rx1727_pos, $I10)
  rxscan1731_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1732_fail
    rx1727_cur."!mark_push"(0, rx1727_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1727_pos, 2
    gt $I11, rx1727_eos, rx1727_fail
    sub $I11, rx1727_pos, rx1727_off
    substr $S10, rx1727_tgt, $I11, 2
    ne $S10, "+|", rx1727_fail
    add rx1727_pos, 2
    set_addr $I10, rxcap_1732_fail
    ($I12, $I11) = rx1727_cur."!mark_peek"($I10)
    rx1727_cur."!cursor_pos"($I11)
    ($P10) = rx1727_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1727_pos, "")
    rx1727_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1732_done
  rxcap_1732_fail:
    goto rx1727_fail
  rxcap_1732_done:
  # rx subrule "O" subtype=capture negate=
    rx1727_cur."!cursor_pos"(rx1727_pos)
    $P10 = rx1727_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1727_fail
    rx1727_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1727_pos = $P10."pos"()
  # rx pass
    rx1727_cur."!cursor_pass"(rx1727_pos, "infix:sym<+|>")
    if_null rx1727_debug, debug_1295
    rx1727_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1727_pos)
  debug_1295:
    .return (rx1727_cur)
  rx1727_restart:
.annotate 'line', 10
    if_null rx1727_debug, debug_1296
    rx1727_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1296:
  rx1727_fail:
    (rx1727_rep, rx1727_pos, $I10, $P10) = rx1727_cur."!mark_fail"(0)
    lt rx1727_pos, -1, rx1727_done
    eq rx1727_pos, -1, rx1727_fail
    jump $I10
  rx1727_done:
    rx1727_cur."!cursor_fail"()
    if_null rx1727_debug, debug_1297
    rx1727_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1297:
    .return (rx1727_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("324_1304277427.017") :method
.annotate 'line', 10
    $P1729 = self."!PREFIX__!subrule"("O", "+|")
    new $P1730, "ResizablePMCArray"
    push $P1730, $P1729
    .return ($P1730)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("325_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1734_tgt
    .local int rx1734_pos
    .local int rx1734_off
    .local int rx1734_eos
    .local int rx1734_rep
    .local pmc rx1734_cur
    .local pmc rx1734_debug
    (rx1734_cur, rx1734_pos, rx1734_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1734_cur
    .local pmc match
    .lex "$/", match
    length rx1734_eos, rx1734_tgt
    gt rx1734_pos, rx1734_eos, rx1734_done
    set rx1734_off, 0
    lt rx1734_pos, 2, rx1734_start
    sub rx1734_off, rx1734_pos, 1
    substr rx1734_tgt, rx1734_tgt, rx1734_off
  rx1734_start:
    eq $I10, 1, rx1734_restart
    if_null rx1734_debug, debug_1298
    rx1734_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1298:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1738_done
    goto rxscan1738_scan
  rxscan1738_loop:
    (rx1734_pos) = rx1734_cur."from"()
    inc rx1734_pos
    rx1734_cur."!cursor_from"(rx1734_pos)
    ge rx1734_pos, rx1734_eos, rxscan1738_done
  rxscan1738_scan:
    set_addr $I10, rxscan1738_loop
    rx1734_cur."!mark_push"(0, rx1734_pos, $I10)
  rxscan1738_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1739_fail
    rx1734_cur."!mark_push"(0, rx1734_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1734_pos, 2
    gt $I11, rx1734_eos, rx1734_fail
    sub $I11, rx1734_pos, rx1734_off
    substr $S10, rx1734_tgt, $I11, 2
    ne $S10, "+^", rx1734_fail
    add rx1734_pos, 2
    set_addr $I10, rxcap_1739_fail
    ($I12, $I11) = rx1734_cur."!mark_peek"($I10)
    rx1734_cur."!cursor_pos"($I11)
    ($P10) = rx1734_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1734_pos, "")
    rx1734_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1739_done
  rxcap_1739_fail:
    goto rx1734_fail
  rxcap_1739_done:
  # rx subrule "O" subtype=capture negate=
    rx1734_cur."!cursor_pos"(rx1734_pos)
    $P10 = rx1734_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1734_fail
    rx1734_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1734_pos = $P10."pos"()
  # rx pass
    rx1734_cur."!cursor_pass"(rx1734_pos, "infix:sym<+^>")
    if_null rx1734_debug, debug_1299
    rx1734_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1734_pos)
  debug_1299:
    .return (rx1734_cur)
  rx1734_restart:
.annotate 'line', 10
    if_null rx1734_debug, debug_1300
    rx1734_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1300:
  rx1734_fail:
    (rx1734_rep, rx1734_pos, $I10, $P10) = rx1734_cur."!mark_fail"(0)
    lt rx1734_pos, -1, rx1734_done
    eq rx1734_pos, -1, rx1734_fail
    jump $I10
  rx1734_done:
    rx1734_cur."!cursor_fail"()
    if_null rx1734_debug, debug_1301
    rx1734_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1301:
    .return (rx1734_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("326_1304277427.017") :method
.annotate 'line', 10
    $P1736 = self."!PREFIX__!subrule"("O", "+^")
    new $P1737, "ResizablePMCArray"
    push $P1737, $P1736
    .return ($P1737)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("327_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1741_tgt
    .local int rx1741_pos
    .local int rx1741_off
    .local int rx1741_eos
    .local int rx1741_rep
    .local pmc rx1741_cur
    .local pmc rx1741_debug
    (rx1741_cur, rx1741_pos, rx1741_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1741_cur
    .local pmc match
    .lex "$/", match
    length rx1741_eos, rx1741_tgt
    gt rx1741_pos, rx1741_eos, rx1741_done
    set rx1741_off, 0
    lt rx1741_pos, 2, rx1741_start
    sub rx1741_off, rx1741_pos, 1
    substr rx1741_tgt, rx1741_tgt, rx1741_off
  rx1741_start:
    eq $I10, 1, rx1741_restart
    if_null rx1741_debug, debug_1302
    rx1741_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1302:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1745_done
    goto rxscan1745_scan
  rxscan1745_loop:
    (rx1741_pos) = rx1741_cur."from"()
    inc rx1741_pos
    rx1741_cur."!cursor_from"(rx1741_pos)
    ge rx1741_pos, rx1741_eos, rxscan1745_done
  rxscan1745_scan:
    set_addr $I10, rxscan1745_loop
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  rxscan1745_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1746_fail
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  # rx literal  "~"
    add $I11, rx1741_pos, 1
    gt $I11, rx1741_eos, rx1741_fail
    sub $I11, rx1741_pos, rx1741_off
    ord $I11, rx1741_tgt, $I11
    ne $I11, 126, rx1741_fail
    add rx1741_pos, 1
    set_addr $I10, rxcap_1746_fail
    ($I12, $I11) = rx1741_cur."!mark_peek"($I10)
    rx1741_cur."!cursor_pos"($I11)
    ($P10) = rx1741_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1741_pos, "")
    rx1741_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1746_done
  rxcap_1746_fail:
    goto rx1741_fail
  rxcap_1746_done:
  # rx subrule "O" subtype=capture negate=
    rx1741_cur."!cursor_pos"(rx1741_pos)
    $P10 = rx1741_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1741_fail
    rx1741_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1741_pos = $P10."pos"()
  # rx pass
    rx1741_cur."!cursor_pass"(rx1741_pos, "infix:sym<~>")
    if_null rx1741_debug, debug_1303
    rx1741_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1741_pos)
  debug_1303:
    .return (rx1741_cur)
  rx1741_restart:
.annotate 'line', 10
    if_null rx1741_debug, debug_1304
    rx1741_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1304:
  rx1741_fail:
    (rx1741_rep, rx1741_pos, $I10, $P10) = rx1741_cur."!mark_fail"(0)
    lt rx1741_pos, -1, rx1741_done
    eq rx1741_pos, -1, rx1741_fail
    jump $I10
  rx1741_done:
    rx1741_cur."!cursor_fail"()
    if_null rx1741_debug, debug_1305
    rx1741_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1305:
    .return (rx1741_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("328_1304277427.017") :method
.annotate 'line', 10
    $P1743 = self."!PREFIX__!subrule"("O", "~")
    new $P1744, "ResizablePMCArray"
    push $P1744, $P1743
    .return ($P1744)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("329_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1748_tgt
    .local int rx1748_pos
    .local int rx1748_off
    .local int rx1748_eos
    .local int rx1748_rep
    .local pmc rx1748_cur
    .local pmc rx1748_debug
    (rx1748_cur, rx1748_pos, rx1748_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1748_cur
    .local pmc match
    .lex "$/", match
    length rx1748_eos, rx1748_tgt
    gt rx1748_pos, rx1748_eos, rx1748_done
    set rx1748_off, 0
    lt rx1748_pos, 2, rx1748_start
    sub rx1748_off, rx1748_pos, 1
    substr rx1748_tgt, rx1748_tgt, rx1748_off
  rx1748_start:
    eq $I10, 1, rx1748_restart
    if_null rx1748_debug, debug_1306
    rx1748_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1306:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1752_done
    goto rxscan1752_scan
  rxscan1752_loop:
    (rx1748_pos) = rx1748_cur."from"()
    inc rx1748_pos
    rx1748_cur."!cursor_from"(rx1748_pos)
    ge rx1748_pos, rx1748_eos, rxscan1752_done
  rxscan1752_scan:
    set_addr $I10, rxscan1752_loop
    rx1748_cur."!mark_push"(0, rx1748_pos, $I10)
  rxscan1752_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1753_fail
    rx1748_cur."!mark_push"(0, rx1748_pos, $I10)
  # rx literal  "=="
    add $I11, rx1748_pos, 2
    gt $I11, rx1748_eos, rx1748_fail
    sub $I11, rx1748_pos, rx1748_off
    substr $S10, rx1748_tgt, $I11, 2
    ne $S10, "==", rx1748_fail
    add rx1748_pos, 2
    set_addr $I10, rxcap_1753_fail
    ($I12, $I11) = rx1748_cur."!mark_peek"($I10)
    rx1748_cur."!cursor_pos"($I11)
    ($P10) = rx1748_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1748_pos, "")
    rx1748_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1753_done
  rxcap_1753_fail:
    goto rx1748_fail
  rxcap_1753_done:
  # rx subrule "O" subtype=capture negate=
    rx1748_cur."!cursor_pos"(rx1748_pos)
    $P10 = rx1748_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1748_fail
    rx1748_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1748_pos = $P10."pos"()
  # rx pass
    rx1748_cur."!cursor_pass"(rx1748_pos, "infix:sym<==>")
    if_null rx1748_debug, debug_1307
    rx1748_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1748_pos)
  debug_1307:
    .return (rx1748_cur)
  rx1748_restart:
.annotate 'line', 10
    if_null rx1748_debug, debug_1308
    rx1748_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1308:
  rx1748_fail:
    (rx1748_rep, rx1748_pos, $I10, $P10) = rx1748_cur."!mark_fail"(0)
    lt rx1748_pos, -1, rx1748_done
    eq rx1748_pos, -1, rx1748_fail
    jump $I10
  rx1748_done:
    rx1748_cur."!cursor_fail"()
    if_null rx1748_debug, debug_1309
    rx1748_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1309:
    .return (rx1748_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("330_1304277427.017") :method
.annotate 'line', 10
    $P1750 = self."!PREFIX__!subrule"("O", "==")
    new $P1751, "ResizablePMCArray"
    push $P1751, $P1750
    .return ($P1751)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("331_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1755_tgt
    .local int rx1755_pos
    .local int rx1755_off
    .local int rx1755_eos
    .local int rx1755_rep
    .local pmc rx1755_cur
    .local pmc rx1755_debug
    (rx1755_cur, rx1755_pos, rx1755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1755_cur
    .local pmc match
    .lex "$/", match
    length rx1755_eos, rx1755_tgt
    gt rx1755_pos, rx1755_eos, rx1755_done
    set rx1755_off, 0
    lt rx1755_pos, 2, rx1755_start
    sub rx1755_off, rx1755_pos, 1
    substr rx1755_tgt, rx1755_tgt, rx1755_off
  rx1755_start:
    eq $I10, 1, rx1755_restart
    if_null rx1755_debug, debug_1310
    rx1755_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1310:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1759_done
    goto rxscan1759_scan
  rxscan1759_loop:
    (rx1755_pos) = rx1755_cur."from"()
    inc rx1755_pos
    rx1755_cur."!cursor_from"(rx1755_pos)
    ge rx1755_pos, rx1755_eos, rxscan1759_done
  rxscan1759_scan:
    set_addr $I10, rxscan1759_loop
    rx1755_cur."!mark_push"(0, rx1755_pos, $I10)
  rxscan1759_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1760_fail
    rx1755_cur."!mark_push"(0, rx1755_pos, $I10)
  # rx literal  "!="
    add $I11, rx1755_pos, 2
    gt $I11, rx1755_eos, rx1755_fail
    sub $I11, rx1755_pos, rx1755_off
    substr $S10, rx1755_tgt, $I11, 2
    ne $S10, "!=", rx1755_fail
    add rx1755_pos, 2
    set_addr $I10, rxcap_1760_fail
    ($I12, $I11) = rx1755_cur."!mark_peek"($I10)
    rx1755_cur."!cursor_pos"($I11)
    ($P10) = rx1755_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1755_pos, "")
    rx1755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1760_done
  rxcap_1760_fail:
    goto rx1755_fail
  rxcap_1760_done:
  # rx subrule "O" subtype=capture negate=
    rx1755_cur."!cursor_pos"(rx1755_pos)
    $P10 = rx1755_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1755_fail
    rx1755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1755_pos = $P10."pos"()
  # rx pass
    rx1755_cur."!cursor_pass"(rx1755_pos, "infix:sym<!=>")
    if_null rx1755_debug, debug_1311
    rx1755_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1755_pos)
  debug_1311:
    .return (rx1755_cur)
  rx1755_restart:
.annotate 'line', 10
    if_null rx1755_debug, debug_1312
    rx1755_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1312:
  rx1755_fail:
    (rx1755_rep, rx1755_pos, $I10, $P10) = rx1755_cur."!mark_fail"(0)
    lt rx1755_pos, -1, rx1755_done
    eq rx1755_pos, -1, rx1755_fail
    jump $I10
  rx1755_done:
    rx1755_cur."!cursor_fail"()
    if_null rx1755_debug, debug_1313
    rx1755_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1313:
    .return (rx1755_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("332_1304277427.017") :method
.annotate 'line', 10
    $P1757 = self."!PREFIX__!subrule"("O", "!=")
    new $P1758, "ResizablePMCArray"
    push $P1758, $P1757
    .return ($P1758)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("333_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1762_tgt
    .local int rx1762_pos
    .local int rx1762_off
    .local int rx1762_eos
    .local int rx1762_rep
    .local pmc rx1762_cur
    .local pmc rx1762_debug
    (rx1762_cur, rx1762_pos, rx1762_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1762_cur
    .local pmc match
    .lex "$/", match
    length rx1762_eos, rx1762_tgt
    gt rx1762_pos, rx1762_eos, rx1762_done
    set rx1762_off, 0
    lt rx1762_pos, 2, rx1762_start
    sub rx1762_off, rx1762_pos, 1
    substr rx1762_tgt, rx1762_tgt, rx1762_off
  rx1762_start:
    eq $I10, 1, rx1762_restart
    if_null rx1762_debug, debug_1314
    rx1762_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1314:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1766_done
    goto rxscan1766_scan
  rxscan1766_loop:
    (rx1762_pos) = rx1762_cur."from"()
    inc rx1762_pos
    rx1762_cur."!cursor_from"(rx1762_pos)
    ge rx1762_pos, rx1762_eos, rxscan1766_done
  rxscan1766_scan:
    set_addr $I10, rxscan1766_loop
    rx1762_cur."!mark_push"(0, rx1762_pos, $I10)
  rxscan1766_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1767_fail
    rx1762_cur."!mark_push"(0, rx1762_pos, $I10)
  # rx literal  "<="
    add $I11, rx1762_pos, 2
    gt $I11, rx1762_eos, rx1762_fail
    sub $I11, rx1762_pos, rx1762_off
    substr $S10, rx1762_tgt, $I11, 2
    ne $S10, "<=", rx1762_fail
    add rx1762_pos, 2
    set_addr $I10, rxcap_1767_fail
    ($I12, $I11) = rx1762_cur."!mark_peek"($I10)
    rx1762_cur."!cursor_pos"($I11)
    ($P10) = rx1762_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1762_pos, "")
    rx1762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1767_done
  rxcap_1767_fail:
    goto rx1762_fail
  rxcap_1767_done:
  # rx subrule "O" subtype=capture negate=
    rx1762_cur."!cursor_pos"(rx1762_pos)
    $P10 = rx1762_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1762_fail
    rx1762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1762_pos = $P10."pos"()
  # rx pass
    rx1762_cur."!cursor_pass"(rx1762_pos, "infix:sym<<=>")
    if_null rx1762_debug, debug_1315
    rx1762_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1762_pos)
  debug_1315:
    .return (rx1762_cur)
  rx1762_restart:
.annotate 'line', 10
    if_null rx1762_debug, debug_1316
    rx1762_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1316:
  rx1762_fail:
    (rx1762_rep, rx1762_pos, $I10, $P10) = rx1762_cur."!mark_fail"(0)
    lt rx1762_pos, -1, rx1762_done
    eq rx1762_pos, -1, rx1762_fail
    jump $I10
  rx1762_done:
    rx1762_cur."!cursor_fail"()
    if_null rx1762_debug, debug_1317
    rx1762_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1317:
    .return (rx1762_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("334_1304277427.017") :method
.annotate 'line', 10
    $P1764 = self."!PREFIX__!subrule"("O", "<=")
    new $P1765, "ResizablePMCArray"
    push $P1765, $P1764
    .return ($P1765)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("335_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1769_tgt
    .local int rx1769_pos
    .local int rx1769_off
    .local int rx1769_eos
    .local int rx1769_rep
    .local pmc rx1769_cur
    .local pmc rx1769_debug
    (rx1769_cur, rx1769_pos, rx1769_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1769_cur
    .local pmc match
    .lex "$/", match
    length rx1769_eos, rx1769_tgt
    gt rx1769_pos, rx1769_eos, rx1769_done
    set rx1769_off, 0
    lt rx1769_pos, 2, rx1769_start
    sub rx1769_off, rx1769_pos, 1
    substr rx1769_tgt, rx1769_tgt, rx1769_off
  rx1769_start:
    eq $I10, 1, rx1769_restart
    if_null rx1769_debug, debug_1318
    rx1769_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1318:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1773_done
    goto rxscan1773_scan
  rxscan1773_loop:
    (rx1769_pos) = rx1769_cur."from"()
    inc rx1769_pos
    rx1769_cur."!cursor_from"(rx1769_pos)
    ge rx1769_pos, rx1769_eos, rxscan1773_done
  rxscan1773_scan:
    set_addr $I10, rxscan1773_loop
    rx1769_cur."!mark_push"(0, rx1769_pos, $I10)
  rxscan1773_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1774_fail
    rx1769_cur."!mark_push"(0, rx1769_pos, $I10)
  # rx literal  ">="
    add $I11, rx1769_pos, 2
    gt $I11, rx1769_eos, rx1769_fail
    sub $I11, rx1769_pos, rx1769_off
    substr $S10, rx1769_tgt, $I11, 2
    ne $S10, ">=", rx1769_fail
    add rx1769_pos, 2
    set_addr $I10, rxcap_1774_fail
    ($I12, $I11) = rx1769_cur."!mark_peek"($I10)
    rx1769_cur."!cursor_pos"($I11)
    ($P10) = rx1769_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1769_pos, "")
    rx1769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1774_done
  rxcap_1774_fail:
    goto rx1769_fail
  rxcap_1774_done:
  # rx subrule "O" subtype=capture negate=
    rx1769_cur."!cursor_pos"(rx1769_pos)
    $P10 = rx1769_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1769_fail
    rx1769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1769_pos = $P10."pos"()
  # rx pass
    rx1769_cur."!cursor_pass"(rx1769_pos, "infix:sym<>=>")
    if_null rx1769_debug, debug_1319
    rx1769_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1769_pos)
  debug_1319:
    .return (rx1769_cur)
  rx1769_restart:
.annotate 'line', 10
    if_null rx1769_debug, debug_1320
    rx1769_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1320:
  rx1769_fail:
    (rx1769_rep, rx1769_pos, $I10, $P10) = rx1769_cur."!mark_fail"(0)
    lt rx1769_pos, -1, rx1769_done
    eq rx1769_pos, -1, rx1769_fail
    jump $I10
  rx1769_done:
    rx1769_cur."!cursor_fail"()
    if_null rx1769_debug, debug_1321
    rx1769_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1321:
    .return (rx1769_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("336_1304277427.017") :method
.annotate 'line', 10
    $P1771 = self."!PREFIX__!subrule"("O", ">=")
    new $P1772, "ResizablePMCArray"
    push $P1772, $P1771
    .return ($P1772)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("337_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1776_tgt
    .local int rx1776_pos
    .local int rx1776_off
    .local int rx1776_eos
    .local int rx1776_rep
    .local pmc rx1776_cur
    .local pmc rx1776_debug
    (rx1776_cur, rx1776_pos, rx1776_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1776_cur
    .local pmc match
    .lex "$/", match
    length rx1776_eos, rx1776_tgt
    gt rx1776_pos, rx1776_eos, rx1776_done
    set rx1776_off, 0
    lt rx1776_pos, 2, rx1776_start
    sub rx1776_off, rx1776_pos, 1
    substr rx1776_tgt, rx1776_tgt, rx1776_off
  rx1776_start:
    eq $I10, 1, rx1776_restart
    if_null rx1776_debug, debug_1322
    rx1776_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1322:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1780_done
    goto rxscan1780_scan
  rxscan1780_loop:
    (rx1776_pos) = rx1776_cur."from"()
    inc rx1776_pos
    rx1776_cur."!cursor_from"(rx1776_pos)
    ge rx1776_pos, rx1776_eos, rxscan1780_done
  rxscan1780_scan:
    set_addr $I10, rxscan1780_loop
    rx1776_cur."!mark_push"(0, rx1776_pos, $I10)
  rxscan1780_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1781_fail
    rx1776_cur."!mark_push"(0, rx1776_pos, $I10)
  # rx literal  "<"
    add $I11, rx1776_pos, 1
    gt $I11, rx1776_eos, rx1776_fail
    sub $I11, rx1776_pos, rx1776_off
    ord $I11, rx1776_tgt, $I11
    ne $I11, 60, rx1776_fail
    add rx1776_pos, 1
    set_addr $I10, rxcap_1781_fail
    ($I12, $I11) = rx1776_cur."!mark_peek"($I10)
    rx1776_cur."!cursor_pos"($I11)
    ($P10) = rx1776_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1776_pos, "")
    rx1776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1781_done
  rxcap_1781_fail:
    goto rx1776_fail
  rxcap_1781_done:
  # rx subrule "O" subtype=capture negate=
    rx1776_cur."!cursor_pos"(rx1776_pos)
    $P10 = rx1776_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1776_fail
    rx1776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1776_pos = $P10."pos"()
  # rx pass
    rx1776_cur."!cursor_pass"(rx1776_pos, "infix:sym<<>")
    if_null rx1776_debug, debug_1323
    rx1776_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1776_pos)
  debug_1323:
    .return (rx1776_cur)
  rx1776_restart:
.annotate 'line', 10
    if_null rx1776_debug, debug_1324
    rx1776_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1324:
  rx1776_fail:
    (rx1776_rep, rx1776_pos, $I10, $P10) = rx1776_cur."!mark_fail"(0)
    lt rx1776_pos, -1, rx1776_done
    eq rx1776_pos, -1, rx1776_fail
    jump $I10
  rx1776_done:
    rx1776_cur."!cursor_fail"()
    if_null rx1776_debug, debug_1325
    rx1776_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1325:
    .return (rx1776_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("338_1304277427.017") :method
.annotate 'line', 10
    $P1778 = self."!PREFIX__!subrule"("O", "<")
    new $P1779, "ResizablePMCArray"
    push $P1779, $P1778
    .return ($P1779)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("339_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1783_tgt
    .local int rx1783_pos
    .local int rx1783_off
    .local int rx1783_eos
    .local int rx1783_rep
    .local pmc rx1783_cur
    .local pmc rx1783_debug
    (rx1783_cur, rx1783_pos, rx1783_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1783_cur
    .local pmc match
    .lex "$/", match
    length rx1783_eos, rx1783_tgt
    gt rx1783_pos, rx1783_eos, rx1783_done
    set rx1783_off, 0
    lt rx1783_pos, 2, rx1783_start
    sub rx1783_off, rx1783_pos, 1
    substr rx1783_tgt, rx1783_tgt, rx1783_off
  rx1783_start:
    eq $I10, 1, rx1783_restart
    if_null rx1783_debug, debug_1326
    rx1783_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1326:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1787_done
    goto rxscan1787_scan
  rxscan1787_loop:
    (rx1783_pos) = rx1783_cur."from"()
    inc rx1783_pos
    rx1783_cur."!cursor_from"(rx1783_pos)
    ge rx1783_pos, rx1783_eos, rxscan1787_done
  rxscan1787_scan:
    set_addr $I10, rxscan1787_loop
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  rxscan1787_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1788_fail
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  # rx literal  ">"
    add $I11, rx1783_pos, 1
    gt $I11, rx1783_eos, rx1783_fail
    sub $I11, rx1783_pos, rx1783_off
    ord $I11, rx1783_tgt, $I11
    ne $I11, 62, rx1783_fail
    add rx1783_pos, 1
    set_addr $I10, rxcap_1788_fail
    ($I12, $I11) = rx1783_cur."!mark_peek"($I10)
    rx1783_cur."!cursor_pos"($I11)
    ($P10) = rx1783_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1783_pos, "")
    rx1783_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1788_done
  rxcap_1788_fail:
    goto rx1783_fail
  rxcap_1788_done:
  # rx subrule "O" subtype=capture negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1783_fail
    rx1783_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1783_pos = $P10."pos"()
  # rx pass
    rx1783_cur."!cursor_pass"(rx1783_pos, "infix:sym<>>")
    if_null rx1783_debug, debug_1327
    rx1783_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1783_pos)
  debug_1327:
    .return (rx1783_cur)
  rx1783_restart:
.annotate 'line', 10
    if_null rx1783_debug, debug_1328
    rx1783_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1328:
  rx1783_fail:
    (rx1783_rep, rx1783_pos, $I10, $P10) = rx1783_cur."!mark_fail"(0)
    lt rx1783_pos, -1, rx1783_done
    eq rx1783_pos, -1, rx1783_fail
    jump $I10
  rx1783_done:
    rx1783_cur."!cursor_fail"()
    if_null rx1783_debug, debug_1329
    rx1783_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1329:
    .return (rx1783_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("340_1304277427.017") :method
.annotate 'line', 10
    $P1785 = self."!PREFIX__!subrule"("O", ">")
    new $P1786, "ResizablePMCArray"
    push $P1786, $P1785
    .return ($P1786)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("341_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1790_tgt
    .local int rx1790_pos
    .local int rx1790_off
    .local int rx1790_eos
    .local int rx1790_rep
    .local pmc rx1790_cur
    .local pmc rx1790_debug
    (rx1790_cur, rx1790_pos, rx1790_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1790_cur
    .local pmc match
    .lex "$/", match
    length rx1790_eos, rx1790_tgt
    gt rx1790_pos, rx1790_eos, rx1790_done
    set rx1790_off, 0
    lt rx1790_pos, 2, rx1790_start
    sub rx1790_off, rx1790_pos, 1
    substr rx1790_tgt, rx1790_tgt, rx1790_off
  rx1790_start:
    eq $I10, 1, rx1790_restart
    if_null rx1790_debug, debug_1330
    rx1790_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1330:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1794_done
    goto rxscan1794_scan
  rxscan1794_loop:
    (rx1790_pos) = rx1790_cur."from"()
    inc rx1790_pos
    rx1790_cur."!cursor_from"(rx1790_pos)
    ge rx1790_pos, rx1790_eos, rxscan1794_done
  rxscan1794_scan:
    set_addr $I10, rxscan1794_loop
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  rxscan1794_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1795_fail
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1790_pos, 2
    gt $I11, rx1790_eos, rx1790_fail
    sub $I11, rx1790_pos, rx1790_off
    substr $S10, rx1790_tgt, $I11, 2
    ne $S10, "eq", rx1790_fail
    add rx1790_pos, 2
    set_addr $I10, rxcap_1795_fail
    ($I12, $I11) = rx1790_cur."!mark_peek"($I10)
    rx1790_cur."!cursor_pos"($I11)
    ($P10) = rx1790_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1790_pos, "")
    rx1790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1795_done
  rxcap_1795_fail:
    goto rx1790_fail
  rxcap_1795_done:
  # rx subrule "O" subtype=capture negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1790_fail
    rx1790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1790_pos = $P10."pos"()
  # rx pass
    rx1790_cur."!cursor_pass"(rx1790_pos, "infix:sym<eq>")
    if_null rx1790_debug, debug_1331
    rx1790_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1790_pos)
  debug_1331:
    .return (rx1790_cur)
  rx1790_restart:
.annotate 'line', 10
    if_null rx1790_debug, debug_1332
    rx1790_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1332:
  rx1790_fail:
    (rx1790_rep, rx1790_pos, $I10, $P10) = rx1790_cur."!mark_fail"(0)
    lt rx1790_pos, -1, rx1790_done
    eq rx1790_pos, -1, rx1790_fail
    jump $I10
  rx1790_done:
    rx1790_cur."!cursor_fail"()
    if_null rx1790_debug, debug_1333
    rx1790_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1333:
    .return (rx1790_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("342_1304277427.017") :method
.annotate 'line', 10
    $P1792 = self."!PREFIX__!subrule"("O", "eq")
    new $P1793, "ResizablePMCArray"
    push $P1793, $P1792
    .return ($P1793)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("343_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1797_tgt
    .local int rx1797_pos
    .local int rx1797_off
    .local int rx1797_eos
    .local int rx1797_rep
    .local pmc rx1797_cur
    .local pmc rx1797_debug
    (rx1797_cur, rx1797_pos, rx1797_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1797_cur
    .local pmc match
    .lex "$/", match
    length rx1797_eos, rx1797_tgt
    gt rx1797_pos, rx1797_eos, rx1797_done
    set rx1797_off, 0
    lt rx1797_pos, 2, rx1797_start
    sub rx1797_off, rx1797_pos, 1
    substr rx1797_tgt, rx1797_tgt, rx1797_off
  rx1797_start:
    eq $I10, 1, rx1797_restart
    if_null rx1797_debug, debug_1334
    rx1797_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1334:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1801_done
    goto rxscan1801_scan
  rxscan1801_loop:
    (rx1797_pos) = rx1797_cur."from"()
    inc rx1797_pos
    rx1797_cur."!cursor_from"(rx1797_pos)
    ge rx1797_pos, rx1797_eos, rxscan1801_done
  rxscan1801_scan:
    set_addr $I10, rxscan1801_loop
    rx1797_cur."!mark_push"(0, rx1797_pos, $I10)
  rxscan1801_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1802_fail
    rx1797_cur."!mark_push"(0, rx1797_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1797_pos, 2
    gt $I11, rx1797_eos, rx1797_fail
    sub $I11, rx1797_pos, rx1797_off
    substr $S10, rx1797_tgt, $I11, 2
    ne $S10, "ne", rx1797_fail
    add rx1797_pos, 2
    set_addr $I10, rxcap_1802_fail
    ($I12, $I11) = rx1797_cur."!mark_peek"($I10)
    rx1797_cur."!cursor_pos"($I11)
    ($P10) = rx1797_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1797_pos, "")
    rx1797_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1802_done
  rxcap_1802_fail:
    goto rx1797_fail
  rxcap_1802_done:
  # rx subrule "O" subtype=capture negate=
    rx1797_cur."!cursor_pos"(rx1797_pos)
    $P10 = rx1797_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1797_fail
    rx1797_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1797_pos = $P10."pos"()
  # rx pass
    rx1797_cur."!cursor_pass"(rx1797_pos, "infix:sym<ne>")
    if_null rx1797_debug, debug_1335
    rx1797_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1797_pos)
  debug_1335:
    .return (rx1797_cur)
  rx1797_restart:
.annotate 'line', 10
    if_null rx1797_debug, debug_1336
    rx1797_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1336:
  rx1797_fail:
    (rx1797_rep, rx1797_pos, $I10, $P10) = rx1797_cur."!mark_fail"(0)
    lt rx1797_pos, -1, rx1797_done
    eq rx1797_pos, -1, rx1797_fail
    jump $I10
  rx1797_done:
    rx1797_cur."!cursor_fail"()
    if_null rx1797_debug, debug_1337
    rx1797_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1337:
    .return (rx1797_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("344_1304277427.017") :method
.annotate 'line', 10
    $P1799 = self."!PREFIX__!subrule"("O", "ne")
    new $P1800, "ResizablePMCArray"
    push $P1800, $P1799
    .return ($P1800)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("345_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1804_tgt
    .local int rx1804_pos
    .local int rx1804_off
    .local int rx1804_eos
    .local int rx1804_rep
    .local pmc rx1804_cur
    .local pmc rx1804_debug
    (rx1804_cur, rx1804_pos, rx1804_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1804_cur
    .local pmc match
    .lex "$/", match
    length rx1804_eos, rx1804_tgt
    gt rx1804_pos, rx1804_eos, rx1804_done
    set rx1804_off, 0
    lt rx1804_pos, 2, rx1804_start
    sub rx1804_off, rx1804_pos, 1
    substr rx1804_tgt, rx1804_tgt, rx1804_off
  rx1804_start:
    eq $I10, 1, rx1804_restart
    if_null rx1804_debug, debug_1338
    rx1804_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1338:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1808_done
    goto rxscan1808_scan
  rxscan1808_loop:
    (rx1804_pos) = rx1804_cur."from"()
    inc rx1804_pos
    rx1804_cur."!cursor_from"(rx1804_pos)
    ge rx1804_pos, rx1804_eos, rxscan1808_done
  rxscan1808_scan:
    set_addr $I10, rxscan1808_loop
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  rxscan1808_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1809_fail
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  # rx literal  "le"
    add $I11, rx1804_pos, 2
    gt $I11, rx1804_eos, rx1804_fail
    sub $I11, rx1804_pos, rx1804_off
    substr $S10, rx1804_tgt, $I11, 2
    ne $S10, "le", rx1804_fail
    add rx1804_pos, 2
    set_addr $I10, rxcap_1809_fail
    ($I12, $I11) = rx1804_cur."!mark_peek"($I10)
    rx1804_cur."!cursor_pos"($I11)
    ($P10) = rx1804_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1804_pos, "")
    rx1804_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1809_done
  rxcap_1809_fail:
    goto rx1804_fail
  rxcap_1809_done:
  # rx subrule "O" subtype=capture negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1804_fail
    rx1804_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1804_pos = $P10."pos"()
  # rx pass
    rx1804_cur."!cursor_pass"(rx1804_pos, "infix:sym<le>")
    if_null rx1804_debug, debug_1339
    rx1804_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1804_pos)
  debug_1339:
    .return (rx1804_cur)
  rx1804_restart:
.annotate 'line', 10
    if_null rx1804_debug, debug_1340
    rx1804_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1340:
  rx1804_fail:
    (rx1804_rep, rx1804_pos, $I10, $P10) = rx1804_cur."!mark_fail"(0)
    lt rx1804_pos, -1, rx1804_done
    eq rx1804_pos, -1, rx1804_fail
    jump $I10
  rx1804_done:
    rx1804_cur."!cursor_fail"()
    if_null rx1804_debug, debug_1341
    rx1804_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1341:
    .return (rx1804_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("346_1304277427.017") :method
.annotate 'line', 10
    $P1806 = self."!PREFIX__!subrule"("O", "le")
    new $P1807, "ResizablePMCArray"
    push $P1807, $P1806
    .return ($P1807)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("347_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1811_tgt
    .local int rx1811_pos
    .local int rx1811_off
    .local int rx1811_eos
    .local int rx1811_rep
    .local pmc rx1811_cur
    .local pmc rx1811_debug
    (rx1811_cur, rx1811_pos, rx1811_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1811_cur
    .local pmc match
    .lex "$/", match
    length rx1811_eos, rx1811_tgt
    gt rx1811_pos, rx1811_eos, rx1811_done
    set rx1811_off, 0
    lt rx1811_pos, 2, rx1811_start
    sub rx1811_off, rx1811_pos, 1
    substr rx1811_tgt, rx1811_tgt, rx1811_off
  rx1811_start:
    eq $I10, 1, rx1811_restart
    if_null rx1811_debug, debug_1342
    rx1811_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1342:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1815_done
    goto rxscan1815_scan
  rxscan1815_loop:
    (rx1811_pos) = rx1811_cur."from"()
    inc rx1811_pos
    rx1811_cur."!cursor_from"(rx1811_pos)
    ge rx1811_pos, rx1811_eos, rxscan1815_done
  rxscan1815_scan:
    set_addr $I10, rxscan1815_loop
    rx1811_cur."!mark_push"(0, rx1811_pos, $I10)
  rxscan1815_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1816_fail
    rx1811_cur."!mark_push"(0, rx1811_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1811_pos, 2
    gt $I11, rx1811_eos, rx1811_fail
    sub $I11, rx1811_pos, rx1811_off
    substr $S10, rx1811_tgt, $I11, 2
    ne $S10, "ge", rx1811_fail
    add rx1811_pos, 2
    set_addr $I10, rxcap_1816_fail
    ($I12, $I11) = rx1811_cur."!mark_peek"($I10)
    rx1811_cur."!cursor_pos"($I11)
    ($P10) = rx1811_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1811_pos, "")
    rx1811_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1816_done
  rxcap_1816_fail:
    goto rx1811_fail
  rxcap_1816_done:
  # rx subrule "O" subtype=capture negate=
    rx1811_cur."!cursor_pos"(rx1811_pos)
    $P10 = rx1811_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1811_fail
    rx1811_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1811_pos = $P10."pos"()
  # rx pass
    rx1811_cur."!cursor_pass"(rx1811_pos, "infix:sym<ge>")
    if_null rx1811_debug, debug_1343
    rx1811_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1811_pos)
  debug_1343:
    .return (rx1811_cur)
  rx1811_restart:
.annotate 'line', 10
    if_null rx1811_debug, debug_1344
    rx1811_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1344:
  rx1811_fail:
    (rx1811_rep, rx1811_pos, $I10, $P10) = rx1811_cur."!mark_fail"(0)
    lt rx1811_pos, -1, rx1811_done
    eq rx1811_pos, -1, rx1811_fail
    jump $I10
  rx1811_done:
    rx1811_cur."!cursor_fail"()
    if_null rx1811_debug, debug_1345
    rx1811_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1345:
    .return (rx1811_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("348_1304277427.017") :method
.annotate 'line', 10
    $P1813 = self."!PREFIX__!subrule"("O", "ge")
    new $P1814, "ResizablePMCArray"
    push $P1814, $P1813
    .return ($P1814)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("349_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1818_tgt
    .local int rx1818_pos
    .local int rx1818_off
    .local int rx1818_eos
    .local int rx1818_rep
    .local pmc rx1818_cur
    .local pmc rx1818_debug
    (rx1818_cur, rx1818_pos, rx1818_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1818_cur
    .local pmc match
    .lex "$/", match
    length rx1818_eos, rx1818_tgt
    gt rx1818_pos, rx1818_eos, rx1818_done
    set rx1818_off, 0
    lt rx1818_pos, 2, rx1818_start
    sub rx1818_off, rx1818_pos, 1
    substr rx1818_tgt, rx1818_tgt, rx1818_off
  rx1818_start:
    eq $I10, 1, rx1818_restart
    if_null rx1818_debug, debug_1346
    rx1818_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1346:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1822_done
    goto rxscan1822_scan
  rxscan1822_loop:
    (rx1818_pos) = rx1818_cur."from"()
    inc rx1818_pos
    rx1818_cur."!cursor_from"(rx1818_pos)
    ge rx1818_pos, rx1818_eos, rxscan1822_done
  rxscan1822_scan:
    set_addr $I10, rxscan1822_loop
    rx1818_cur."!mark_push"(0, rx1818_pos, $I10)
  rxscan1822_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1823_fail
    rx1818_cur."!mark_push"(0, rx1818_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1818_pos, 2
    gt $I11, rx1818_eos, rx1818_fail
    sub $I11, rx1818_pos, rx1818_off
    substr $S10, rx1818_tgt, $I11, 2
    ne $S10, "lt", rx1818_fail
    add rx1818_pos, 2
    set_addr $I10, rxcap_1823_fail
    ($I12, $I11) = rx1818_cur."!mark_peek"($I10)
    rx1818_cur."!cursor_pos"($I11)
    ($P10) = rx1818_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1818_pos, "")
    rx1818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1823_done
  rxcap_1823_fail:
    goto rx1818_fail
  rxcap_1823_done:
  # rx subrule "O" subtype=capture negate=
    rx1818_cur."!cursor_pos"(rx1818_pos)
    $P10 = rx1818_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1818_fail
    rx1818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1818_pos = $P10."pos"()
  # rx pass
    rx1818_cur."!cursor_pass"(rx1818_pos, "infix:sym<lt>")
    if_null rx1818_debug, debug_1347
    rx1818_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1818_pos)
  debug_1347:
    .return (rx1818_cur)
  rx1818_restart:
.annotate 'line', 10
    if_null rx1818_debug, debug_1348
    rx1818_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1348:
  rx1818_fail:
    (rx1818_rep, rx1818_pos, $I10, $P10) = rx1818_cur."!mark_fail"(0)
    lt rx1818_pos, -1, rx1818_done
    eq rx1818_pos, -1, rx1818_fail
    jump $I10
  rx1818_done:
    rx1818_cur."!cursor_fail"()
    if_null rx1818_debug, debug_1349
    rx1818_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1349:
    .return (rx1818_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("350_1304277427.017") :method
.annotate 'line', 10
    $P1820 = self."!PREFIX__!subrule"("O", "lt")
    new $P1821, "ResizablePMCArray"
    push $P1821, $P1820
    .return ($P1821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("351_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1825_tgt
    .local int rx1825_pos
    .local int rx1825_off
    .local int rx1825_eos
    .local int rx1825_rep
    .local pmc rx1825_cur
    .local pmc rx1825_debug
    (rx1825_cur, rx1825_pos, rx1825_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1825_cur
    .local pmc match
    .lex "$/", match
    length rx1825_eos, rx1825_tgt
    gt rx1825_pos, rx1825_eos, rx1825_done
    set rx1825_off, 0
    lt rx1825_pos, 2, rx1825_start
    sub rx1825_off, rx1825_pos, 1
    substr rx1825_tgt, rx1825_tgt, rx1825_off
  rx1825_start:
    eq $I10, 1, rx1825_restart
    if_null rx1825_debug, debug_1350
    rx1825_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1350:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1829_done
    goto rxscan1829_scan
  rxscan1829_loop:
    (rx1825_pos) = rx1825_cur."from"()
    inc rx1825_pos
    rx1825_cur."!cursor_from"(rx1825_pos)
    ge rx1825_pos, rx1825_eos, rxscan1829_done
  rxscan1829_scan:
    set_addr $I10, rxscan1829_loop
    rx1825_cur."!mark_push"(0, rx1825_pos, $I10)
  rxscan1829_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1830_fail
    rx1825_cur."!mark_push"(0, rx1825_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1825_pos, 2
    gt $I11, rx1825_eos, rx1825_fail
    sub $I11, rx1825_pos, rx1825_off
    substr $S10, rx1825_tgt, $I11, 2
    ne $S10, "gt", rx1825_fail
    add rx1825_pos, 2
    set_addr $I10, rxcap_1830_fail
    ($I12, $I11) = rx1825_cur."!mark_peek"($I10)
    rx1825_cur."!cursor_pos"($I11)
    ($P10) = rx1825_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1825_pos, "")
    rx1825_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1830_done
  rxcap_1830_fail:
    goto rx1825_fail
  rxcap_1830_done:
  # rx subrule "O" subtype=capture negate=
    rx1825_cur."!cursor_pos"(rx1825_pos)
    $P10 = rx1825_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1825_fail
    rx1825_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1825_pos = $P10."pos"()
  # rx pass
    rx1825_cur."!cursor_pass"(rx1825_pos, "infix:sym<gt>")
    if_null rx1825_debug, debug_1351
    rx1825_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1825_pos)
  debug_1351:
    .return (rx1825_cur)
  rx1825_restart:
.annotate 'line', 10
    if_null rx1825_debug, debug_1352
    rx1825_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1352:
  rx1825_fail:
    (rx1825_rep, rx1825_pos, $I10, $P10) = rx1825_cur."!mark_fail"(0)
    lt rx1825_pos, -1, rx1825_done
    eq rx1825_pos, -1, rx1825_fail
    jump $I10
  rx1825_done:
    rx1825_cur."!cursor_fail"()
    if_null rx1825_debug, debug_1353
    rx1825_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1353:
    .return (rx1825_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("352_1304277427.017") :method
.annotate 'line', 10
    $P1827 = self."!PREFIX__!subrule"("O", "gt")
    new $P1828, "ResizablePMCArray"
    push $P1828, $P1827
    .return ($P1828)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("353_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1832_tgt
    .local int rx1832_pos
    .local int rx1832_off
    .local int rx1832_eos
    .local int rx1832_rep
    .local pmc rx1832_cur
    .local pmc rx1832_debug
    (rx1832_cur, rx1832_pos, rx1832_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1832_cur
    .local pmc match
    .lex "$/", match
    length rx1832_eos, rx1832_tgt
    gt rx1832_pos, rx1832_eos, rx1832_done
    set rx1832_off, 0
    lt rx1832_pos, 2, rx1832_start
    sub rx1832_off, rx1832_pos, 1
    substr rx1832_tgt, rx1832_tgt, rx1832_off
  rx1832_start:
    eq $I10, 1, rx1832_restart
    if_null rx1832_debug, debug_1354
    rx1832_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1354:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1836_done
    goto rxscan1836_scan
  rxscan1836_loop:
    (rx1832_pos) = rx1832_cur."from"()
    inc rx1832_pos
    rx1832_cur."!cursor_from"(rx1832_pos)
    ge rx1832_pos, rx1832_eos, rxscan1836_done
  rxscan1836_scan:
    set_addr $I10, rxscan1836_loop
    rx1832_cur."!mark_push"(0, rx1832_pos, $I10)
  rxscan1836_done:
.annotate 'line', 695
  # rx subcapture "sym"
    set_addr $I10, rxcap_1837_fail
    rx1832_cur."!mark_push"(0, rx1832_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1832_pos, 3
    gt $I11, rx1832_eos, rx1832_fail
    sub $I11, rx1832_pos, rx1832_off
    substr $S10, rx1832_tgt, $I11, 3
    ne $S10, "=:=", rx1832_fail
    add rx1832_pos, 3
    set_addr $I10, rxcap_1837_fail
    ($I12, $I11) = rx1832_cur."!mark_peek"($I10)
    rx1832_cur."!cursor_pos"($I11)
    ($P10) = rx1832_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1832_pos, "")
    rx1832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1837_done
  rxcap_1837_fail:
    goto rx1832_fail
  rxcap_1837_done:
  # rx subrule "O" subtype=capture negate=
    rx1832_cur."!cursor_pos"(rx1832_pos)
    $P10 = rx1832_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1832_fail
    rx1832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1832_pos = $P10."pos"()
  # rx pass
    rx1832_cur."!cursor_pass"(rx1832_pos, "infix:sym<=:=>")
    if_null rx1832_debug, debug_1355
    rx1832_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1832_pos)
  debug_1355:
    .return (rx1832_cur)
  rx1832_restart:
.annotate 'line', 10
    if_null rx1832_debug, debug_1356
    rx1832_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1356:
  rx1832_fail:
    (rx1832_rep, rx1832_pos, $I10, $P10) = rx1832_cur."!mark_fail"(0)
    lt rx1832_pos, -1, rx1832_done
    eq rx1832_pos, -1, rx1832_fail
    jump $I10
  rx1832_done:
    rx1832_cur."!cursor_fail"()
    if_null rx1832_debug, debug_1357
    rx1832_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1357:
    .return (rx1832_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("354_1304277427.017") :method
.annotate 'line', 10
    $P1834 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1835, "ResizablePMCArray"
    push $P1835, $P1834
    .return ($P1835)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("355_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1839_tgt
    .local int rx1839_pos
    .local int rx1839_off
    .local int rx1839_eos
    .local int rx1839_rep
    .local pmc rx1839_cur
    .local pmc rx1839_debug
    (rx1839_cur, rx1839_pos, rx1839_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1839_cur
    .local pmc match
    .lex "$/", match
    length rx1839_eos, rx1839_tgt
    gt rx1839_pos, rx1839_eos, rx1839_done
    set rx1839_off, 0
    lt rx1839_pos, 2, rx1839_start
    sub rx1839_off, rx1839_pos, 1
    substr rx1839_tgt, rx1839_tgt, rx1839_off
  rx1839_start:
    eq $I10, 1, rx1839_restart
    if_null rx1839_debug, debug_1358
    rx1839_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1358:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1843_done
    goto rxscan1843_scan
  rxscan1843_loop:
    (rx1839_pos) = rx1839_cur."from"()
    inc rx1839_pos
    rx1839_cur."!cursor_from"(rx1839_pos)
    ge rx1839_pos, rx1839_eos, rxscan1843_done
  rxscan1843_scan:
    set_addr $I10, rxscan1843_loop
    rx1839_cur."!mark_push"(0, rx1839_pos, $I10)
  rxscan1843_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_1844_fail
    rx1839_cur."!mark_push"(0, rx1839_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1839_pos, 2
    gt $I11, rx1839_eos, rx1839_fail
    sub $I11, rx1839_pos, rx1839_off
    substr $S10, rx1839_tgt, $I11, 2
    ne $S10, "~~", rx1839_fail
    add rx1839_pos, 2
    set_addr $I10, rxcap_1844_fail
    ($I12, $I11) = rx1839_cur."!mark_peek"($I10)
    rx1839_cur."!cursor_pos"($I11)
    ($P10) = rx1839_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1839_pos, "")
    rx1839_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1844_done
  rxcap_1844_fail:
    goto rx1839_fail
  rxcap_1844_done:
  # rx subrule "O" subtype=capture negate=
    rx1839_cur."!cursor_pos"(rx1839_pos)
    $P10 = rx1839_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1839_fail
    rx1839_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1839_pos = $P10."pos"()
  # rx pass
    rx1839_cur."!cursor_pass"(rx1839_pos, "infix:sym<~~>")
    if_null rx1839_debug, debug_1359
    rx1839_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1839_pos)
  debug_1359:
    .return (rx1839_cur)
  rx1839_restart:
.annotate 'line', 10
    if_null rx1839_debug, debug_1360
    rx1839_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1360:
  rx1839_fail:
    (rx1839_rep, rx1839_pos, $I10, $P10) = rx1839_cur."!mark_fail"(0)
    lt rx1839_pos, -1, rx1839_done
    eq rx1839_pos, -1, rx1839_fail
    jump $I10
  rx1839_done:
    rx1839_cur."!cursor_fail"()
    if_null rx1839_debug, debug_1361
    rx1839_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1361:
    .return (rx1839_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("356_1304277427.017") :method
.annotate 'line', 10
    $P1841 = self."!PREFIX__!subrule"("O", "~~")
    new $P1842, "ResizablePMCArray"
    push $P1842, $P1841
    .return ($P1842)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("357_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1846_tgt
    .local int rx1846_pos
    .local int rx1846_off
    .local int rx1846_eos
    .local int rx1846_rep
    .local pmc rx1846_cur
    .local pmc rx1846_debug
    (rx1846_cur, rx1846_pos, rx1846_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1846_cur
    .local pmc match
    .lex "$/", match
    length rx1846_eos, rx1846_tgt
    gt rx1846_pos, rx1846_eos, rx1846_done
    set rx1846_off, 0
    lt rx1846_pos, 2, rx1846_start
    sub rx1846_off, rx1846_pos, 1
    substr rx1846_tgt, rx1846_tgt, rx1846_off
  rx1846_start:
    eq $I10, 1, rx1846_restart
    if_null rx1846_debug, debug_1362
    rx1846_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1362:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1850_done
    goto rxscan1850_scan
  rxscan1850_loop:
    (rx1846_pos) = rx1846_cur."from"()
    inc rx1846_pos
    rx1846_cur."!cursor_from"(rx1846_pos)
    ge rx1846_pos, rx1846_eos, rxscan1850_done
  rxscan1850_scan:
    set_addr $I10, rxscan1850_loop
    rx1846_cur."!mark_push"(0, rx1846_pos, $I10)
  rxscan1850_done:
.annotate 'line', 698
  # rx subcapture "sym"
    set_addr $I10, rxcap_1851_fail
    rx1846_cur."!mark_push"(0, rx1846_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1846_pos, 2
    gt $I11, rx1846_eos, rx1846_fail
    sub $I11, rx1846_pos, rx1846_off
    substr $S10, rx1846_tgt, $I11, 2
    ne $S10, "&&", rx1846_fail
    add rx1846_pos, 2
    set_addr $I10, rxcap_1851_fail
    ($I12, $I11) = rx1846_cur."!mark_peek"($I10)
    rx1846_cur."!cursor_pos"($I11)
    ($P10) = rx1846_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1846_pos, "")
    rx1846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1851_done
  rxcap_1851_fail:
    goto rx1846_fail
  rxcap_1851_done:
  # rx subrule "O" subtype=capture negate=
    rx1846_cur."!cursor_pos"(rx1846_pos)
    $P10 = rx1846_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1846_fail
    rx1846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1846_pos = $P10."pos"()
  # rx pass
    rx1846_cur."!cursor_pass"(rx1846_pos, "infix:sym<&&>")
    if_null rx1846_debug, debug_1363
    rx1846_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1846_pos)
  debug_1363:
    .return (rx1846_cur)
  rx1846_restart:
.annotate 'line', 10
    if_null rx1846_debug, debug_1364
    rx1846_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1364:
  rx1846_fail:
    (rx1846_rep, rx1846_pos, $I10, $P10) = rx1846_cur."!mark_fail"(0)
    lt rx1846_pos, -1, rx1846_done
    eq rx1846_pos, -1, rx1846_fail
    jump $I10
  rx1846_done:
    rx1846_cur."!cursor_fail"()
    if_null rx1846_debug, debug_1365
    rx1846_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1365:
    .return (rx1846_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("358_1304277427.017") :method
.annotate 'line', 10
    $P1848 = self."!PREFIX__!subrule"("O", "&&")
    new $P1849, "ResizablePMCArray"
    push $P1849, $P1848
    .return ($P1849)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("359_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1853_tgt
    .local int rx1853_pos
    .local int rx1853_off
    .local int rx1853_eos
    .local int rx1853_rep
    .local pmc rx1853_cur
    .local pmc rx1853_debug
    (rx1853_cur, rx1853_pos, rx1853_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1853_cur
    .local pmc match
    .lex "$/", match
    length rx1853_eos, rx1853_tgt
    gt rx1853_pos, rx1853_eos, rx1853_done
    set rx1853_off, 0
    lt rx1853_pos, 2, rx1853_start
    sub rx1853_off, rx1853_pos, 1
    substr rx1853_tgt, rx1853_tgt, rx1853_off
  rx1853_start:
    eq $I10, 1, rx1853_restart
    if_null rx1853_debug, debug_1366
    rx1853_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1366:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1857_done
    goto rxscan1857_scan
  rxscan1857_loop:
    (rx1853_pos) = rx1853_cur."from"()
    inc rx1853_pos
    rx1853_cur."!cursor_from"(rx1853_pos)
    ge rx1853_pos, rx1853_eos, rxscan1857_done
  rxscan1857_scan:
    set_addr $I10, rxscan1857_loop
    rx1853_cur."!mark_push"(0, rx1853_pos, $I10)
  rxscan1857_done:
.annotate 'line', 700
  # rx subcapture "sym"
    set_addr $I10, rxcap_1858_fail
    rx1853_cur."!mark_push"(0, rx1853_pos, $I10)
  # rx literal  "||"
    add $I11, rx1853_pos, 2
    gt $I11, rx1853_eos, rx1853_fail
    sub $I11, rx1853_pos, rx1853_off
    substr $S10, rx1853_tgt, $I11, 2
    ne $S10, "||", rx1853_fail
    add rx1853_pos, 2
    set_addr $I10, rxcap_1858_fail
    ($I12, $I11) = rx1853_cur."!mark_peek"($I10)
    rx1853_cur."!cursor_pos"($I11)
    ($P10) = rx1853_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1853_pos, "")
    rx1853_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1858_done
  rxcap_1858_fail:
    goto rx1853_fail
  rxcap_1858_done:
  # rx subrule "O" subtype=capture negate=
    rx1853_cur."!cursor_pos"(rx1853_pos)
    $P10 = rx1853_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1853_fail
    rx1853_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1853_pos = $P10."pos"()
  # rx pass
    rx1853_cur."!cursor_pass"(rx1853_pos, "infix:sym<||>")
    if_null rx1853_debug, debug_1367
    rx1853_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1853_pos)
  debug_1367:
    .return (rx1853_cur)
  rx1853_restart:
.annotate 'line', 10
    if_null rx1853_debug, debug_1368
    rx1853_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1368:
  rx1853_fail:
    (rx1853_rep, rx1853_pos, $I10, $P10) = rx1853_cur."!mark_fail"(0)
    lt rx1853_pos, -1, rx1853_done
    eq rx1853_pos, -1, rx1853_fail
    jump $I10
  rx1853_done:
    rx1853_cur."!cursor_fail"()
    if_null rx1853_debug, debug_1369
    rx1853_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1369:
    .return (rx1853_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("360_1304277427.017") :method
.annotate 'line', 10
    $P1855 = self."!PREFIX__!subrule"("O", "||")
    new $P1856, "ResizablePMCArray"
    push $P1856, $P1855
    .return ($P1856)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("361_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1860_tgt
    .local int rx1860_pos
    .local int rx1860_off
    .local int rx1860_eos
    .local int rx1860_rep
    .local pmc rx1860_cur
    .local pmc rx1860_debug
    (rx1860_cur, rx1860_pos, rx1860_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1860_cur
    .local pmc match
    .lex "$/", match
    length rx1860_eos, rx1860_tgt
    gt rx1860_pos, rx1860_eos, rx1860_done
    set rx1860_off, 0
    lt rx1860_pos, 2, rx1860_start
    sub rx1860_off, rx1860_pos, 1
    substr rx1860_tgt, rx1860_tgt, rx1860_off
  rx1860_start:
    eq $I10, 1, rx1860_restart
    if_null rx1860_debug, debug_1370
    rx1860_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1370:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1864_done
    goto rxscan1864_scan
  rxscan1864_loop:
    (rx1860_pos) = rx1860_cur."from"()
    inc rx1860_pos
    rx1860_cur."!cursor_from"(rx1860_pos)
    ge rx1860_pos, rx1860_eos, rxscan1864_done
  rxscan1864_scan:
    set_addr $I10, rxscan1864_loop
    rx1860_cur."!mark_push"(0, rx1860_pos, $I10)
  rxscan1864_done:
.annotate 'line', 701
  # rx subcapture "sym"
    set_addr $I10, rxcap_1865_fail
    rx1860_cur."!mark_push"(0, rx1860_pos, $I10)
  # rx literal  "//"
    add $I11, rx1860_pos, 2
    gt $I11, rx1860_eos, rx1860_fail
    sub $I11, rx1860_pos, rx1860_off
    substr $S10, rx1860_tgt, $I11, 2
    ne $S10, "//", rx1860_fail
    add rx1860_pos, 2
    set_addr $I10, rxcap_1865_fail
    ($I12, $I11) = rx1860_cur."!mark_peek"($I10)
    rx1860_cur."!cursor_pos"($I11)
    ($P10) = rx1860_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1860_pos, "")
    rx1860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1865_done
  rxcap_1865_fail:
    goto rx1860_fail
  rxcap_1865_done:
  # rx subrule "O" subtype=capture negate=
    rx1860_cur."!cursor_pos"(rx1860_pos)
    $P10 = rx1860_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1860_fail
    rx1860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1860_pos = $P10."pos"()
  # rx pass
    rx1860_cur."!cursor_pass"(rx1860_pos, "infix:sym<//>")
    if_null rx1860_debug, debug_1371
    rx1860_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1860_pos)
  debug_1371:
    .return (rx1860_cur)
  rx1860_restart:
.annotate 'line', 10
    if_null rx1860_debug, debug_1372
    rx1860_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1372:
  rx1860_fail:
    (rx1860_rep, rx1860_pos, $I10, $P10) = rx1860_cur."!mark_fail"(0)
    lt rx1860_pos, -1, rx1860_done
    eq rx1860_pos, -1, rx1860_fail
    jump $I10
  rx1860_done:
    rx1860_cur."!cursor_fail"()
    if_null rx1860_debug, debug_1373
    rx1860_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1373:
    .return (rx1860_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("362_1304277427.017") :method
.annotate 'line', 10
    $P1862 = self."!PREFIX__!subrule"("O", "//")
    new $P1863, "ResizablePMCArray"
    push $P1863, $P1862
    .return ($P1863)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("363_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1867_tgt
    .local int rx1867_pos
    .local int rx1867_off
    .local int rx1867_eos
    .local int rx1867_rep
    .local pmc rx1867_cur
    .local pmc rx1867_debug
    (rx1867_cur, rx1867_pos, rx1867_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1867_cur
    .local pmc match
    .lex "$/", match
    length rx1867_eos, rx1867_tgt
    gt rx1867_pos, rx1867_eos, rx1867_done
    set rx1867_off, 0
    lt rx1867_pos, 2, rx1867_start
    sub rx1867_off, rx1867_pos, 1
    substr rx1867_tgt, rx1867_tgt, rx1867_off
  rx1867_start:
    eq $I10, 1, rx1867_restart
    if_null rx1867_debug, debug_1374
    rx1867_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1374:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1871_done
    goto rxscan1871_scan
  rxscan1871_loop:
    (rx1867_pos) = rx1867_cur."from"()
    inc rx1867_pos
    rx1867_cur."!cursor_from"(rx1867_pos)
    ge rx1867_pos, rx1867_eos, rxscan1871_done
  rxscan1871_scan:
    set_addr $I10, rxscan1871_loop
    rx1867_cur."!mark_push"(0, rx1867_pos, $I10)
  rxscan1871_done:
.annotate 'line', 704
  # rx literal  "??"
    add $I11, rx1867_pos, 2
    gt $I11, rx1867_eos, rx1867_fail
    sub $I11, rx1867_pos, rx1867_off
    substr $S10, rx1867_tgt, $I11, 2
    ne $S10, "??", rx1867_fail
    add rx1867_pos, 2
.annotate 'line', 705
  # rx subrule "ws" subtype=method negate=
    rx1867_cur."!cursor_pos"(rx1867_pos)
    $P10 = rx1867_cur."ws"()
    unless $P10, rx1867_fail
    rx1867_pos = $P10."pos"()
.annotate 'line', 706
  # rx subrule "EXPR" subtype=capture negate=
    rx1867_cur."!cursor_pos"(rx1867_pos)
    $P10 = rx1867_cur."EXPR"("i=")
    unless $P10, rx1867_fail
    rx1867_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1867_pos = $P10."pos"()
.annotate 'line', 707
  # rx literal  "!!"
    add $I11, rx1867_pos, 2
    gt $I11, rx1867_eos, rx1867_fail
    sub $I11, rx1867_pos, rx1867_off
    substr $S10, rx1867_tgt, $I11, 2
    ne $S10, "!!", rx1867_fail
    add rx1867_pos, 2
.annotate 'line', 708
  # rx subrule "O" subtype=capture negate=
    rx1867_cur."!cursor_pos"(rx1867_pos)
    $P10 = rx1867_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1867_fail
    rx1867_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1867_pos = $P10."pos"()
.annotate 'line', 703
  # rx pass
    rx1867_cur."!cursor_pass"(rx1867_pos, "infix:sym<?? !!>")
    if_null rx1867_debug, debug_1375
    rx1867_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1867_pos)
  debug_1375:
    .return (rx1867_cur)
  rx1867_restart:
.annotate 'line', 10
    if_null rx1867_debug, debug_1376
    rx1867_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1376:
  rx1867_fail:
    (rx1867_rep, rx1867_pos, $I10, $P10) = rx1867_cur."!mark_fail"(0)
    lt rx1867_pos, -1, rx1867_done
    eq rx1867_pos, -1, rx1867_fail
    jump $I10
  rx1867_done:
    rx1867_cur."!cursor_fail"()
    if_null rx1867_debug, debug_1377
    rx1867_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1377:
    .return (rx1867_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("364_1304277427.017") :method
.annotate 'line', 10
    $P1869 = self."!PREFIX__!subrule"("ws", "??")
    new $P1870, "ResizablePMCArray"
    push $P1870, $P1869
    .return ($P1870)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("365_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1873_tgt
    .local int rx1873_pos
    .local int rx1873_off
    .local int rx1873_eos
    .local int rx1873_rep
    .local pmc rx1873_cur
    .local pmc rx1873_debug
    (rx1873_cur, rx1873_pos, rx1873_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1873_cur
    .local pmc match
    .lex "$/", match
    length rx1873_eos, rx1873_tgt
    gt rx1873_pos, rx1873_eos, rx1873_done
    set rx1873_off, 0
    lt rx1873_pos, 2, rx1873_start
    sub rx1873_off, rx1873_pos, 1
    substr rx1873_tgt, rx1873_tgt, rx1873_off
  rx1873_start:
    eq $I10, 1, rx1873_restart
    if_null rx1873_debug, debug_1378
    rx1873_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1378:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1877_done
    goto rxscan1877_scan
  rxscan1877_loop:
    (rx1873_pos) = rx1873_cur."from"()
    inc rx1873_pos
    rx1873_cur."!cursor_from"(rx1873_pos)
    ge rx1873_pos, rx1873_eos, rxscan1877_done
  rxscan1877_scan:
    set_addr $I10, rxscan1877_loop
    rx1873_cur."!mark_push"(0, rx1873_pos, $I10)
  rxscan1877_done:
.annotate 'line', 712
  # rx subcapture "sym"
    set_addr $I10, rxcap_1878_fail
    rx1873_cur."!mark_push"(0, rx1873_pos, $I10)
  # rx literal  "="
    add $I11, rx1873_pos, 1
    gt $I11, rx1873_eos, rx1873_fail
    sub $I11, rx1873_pos, rx1873_off
    ord $I11, rx1873_tgt, $I11
    ne $I11, 61, rx1873_fail
    add rx1873_pos, 1
    set_addr $I10, rxcap_1878_fail
    ($I12, $I11) = rx1873_cur."!mark_peek"($I10)
    rx1873_cur."!cursor_pos"($I11)
    ($P10) = rx1873_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1873_pos, "")
    rx1873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1878_done
  rxcap_1878_fail:
    goto rx1873_fail
  rxcap_1878_done:
  # rx subrule "panic" subtype=method negate=
    rx1873_cur."!cursor_pos"(rx1873_pos)
    $P10 = rx1873_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1873_fail
    rx1873_pos = $P10."pos"()
.annotate 'line', 711
  # rx pass
    rx1873_cur."!cursor_pass"(rx1873_pos, "infix:sym<=>")
    if_null rx1873_debug, debug_1379
    rx1873_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1873_pos)
  debug_1379:
    .return (rx1873_cur)
  rx1873_restart:
.annotate 'line', 10
    if_null rx1873_debug, debug_1380
    rx1873_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1380:
  rx1873_fail:
    (rx1873_rep, rx1873_pos, $I10, $P10) = rx1873_cur."!mark_fail"(0)
    lt rx1873_pos, -1, rx1873_done
    eq rx1873_pos, -1, rx1873_fail
    jump $I10
  rx1873_done:
    rx1873_cur."!cursor_fail"()
    if_null rx1873_debug, debug_1381
    rx1873_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1381:
    .return (rx1873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("366_1304277427.017") :method
.annotate 'line', 10
    $P1875 = self."!PREFIX__!subrule"("panic", "=")
    new $P1876, "ResizablePMCArray"
    push $P1876, $P1875
    .return ($P1876)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("367_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1880_tgt
    .local int rx1880_pos
    .local int rx1880_off
    .local int rx1880_eos
    .local int rx1880_rep
    .local pmc rx1880_cur
    .local pmc rx1880_debug
    (rx1880_cur, rx1880_pos, rx1880_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1880_cur
    .local pmc match
    .lex "$/", match
    length rx1880_eos, rx1880_tgt
    gt rx1880_pos, rx1880_eos, rx1880_done
    set rx1880_off, 0
    lt rx1880_pos, 2, rx1880_start
    sub rx1880_off, rx1880_pos, 1
    substr rx1880_tgt, rx1880_tgt, rx1880_off
  rx1880_start:
    eq $I10, 1, rx1880_restart
    if_null rx1880_debug, debug_1382
    rx1880_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1382:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1884_done
    goto rxscan1884_scan
  rxscan1884_loop:
    (rx1880_pos) = rx1880_cur."from"()
    inc rx1880_pos
    rx1880_cur."!cursor_from"(rx1880_pos)
    ge rx1880_pos, rx1880_eos, rxscan1884_done
  rxscan1884_scan:
    set_addr $I10, rxscan1884_loop
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  rxscan1884_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1885_fail
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  # rx literal  ":="
    add $I11, rx1880_pos, 2
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 2
    ne $S10, ":=", rx1880_fail
    add rx1880_pos, 2
    set_addr $I10, rxcap_1885_fail
    ($I12, $I11) = rx1880_cur."!mark_peek"($I10)
    rx1880_cur."!cursor_pos"($I11)
    ($P10) = rx1880_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1880_pos, "")
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1885_done
  rxcap_1885_fail:
    goto rx1880_fail
  rxcap_1885_done:
  # rx subrule "O" subtype=capture negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1880_fail
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1880_pos = $P10."pos"()
  # rx pass
    rx1880_cur."!cursor_pass"(rx1880_pos, "infix:sym<:=>")
    if_null rx1880_debug, debug_1383
    rx1880_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1880_pos)
  debug_1383:
    .return (rx1880_cur)
  rx1880_restart:
.annotate 'line', 10
    if_null rx1880_debug, debug_1384
    rx1880_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1384:
  rx1880_fail:
    (rx1880_rep, rx1880_pos, $I10, $P10) = rx1880_cur."!mark_fail"(0)
    lt rx1880_pos, -1, rx1880_done
    eq rx1880_pos, -1, rx1880_fail
    jump $I10
  rx1880_done:
    rx1880_cur."!cursor_fail"()
    if_null rx1880_debug, debug_1385
    rx1880_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1385:
    .return (rx1880_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("368_1304277427.017") :method
.annotate 'line', 10
    $P1882 = self."!PREFIX__!subrule"("O", ":=")
    new $P1883, "ResizablePMCArray"
    push $P1883, $P1882
    .return ($P1883)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("369_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1887_tgt
    .local int rx1887_pos
    .local int rx1887_off
    .local int rx1887_eos
    .local int rx1887_rep
    .local pmc rx1887_cur
    .local pmc rx1887_debug
    (rx1887_cur, rx1887_pos, rx1887_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1887_cur
    .local pmc match
    .lex "$/", match
    length rx1887_eos, rx1887_tgt
    gt rx1887_pos, rx1887_eos, rx1887_done
    set rx1887_off, 0
    lt rx1887_pos, 2, rx1887_start
    sub rx1887_off, rx1887_pos, 1
    substr rx1887_tgt, rx1887_tgt, rx1887_off
  rx1887_start:
    eq $I10, 1, rx1887_restart
    if_null rx1887_debug, debug_1386
    rx1887_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1386:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1891_done
    goto rxscan1891_scan
  rxscan1891_loop:
    (rx1887_pos) = rx1887_cur."from"()
    inc rx1887_pos
    rx1887_cur."!cursor_from"(rx1887_pos)
    ge rx1887_pos, rx1887_eos, rxscan1891_done
  rxscan1891_scan:
    set_addr $I10, rxscan1891_loop
    rx1887_cur."!mark_push"(0, rx1887_pos, $I10)
  rxscan1891_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1892_fail
    rx1887_cur."!mark_push"(0, rx1887_pos, $I10)
  # rx literal  "::="
    add $I11, rx1887_pos, 3
    gt $I11, rx1887_eos, rx1887_fail
    sub $I11, rx1887_pos, rx1887_off
    substr $S10, rx1887_tgt, $I11, 3
    ne $S10, "::=", rx1887_fail
    add rx1887_pos, 3
    set_addr $I10, rxcap_1892_fail
    ($I12, $I11) = rx1887_cur."!mark_peek"($I10)
    rx1887_cur."!cursor_pos"($I11)
    ($P10) = rx1887_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1887_pos, "")
    rx1887_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1892_done
  rxcap_1892_fail:
    goto rx1887_fail
  rxcap_1892_done:
  # rx subrule "O" subtype=capture negate=
    rx1887_cur."!cursor_pos"(rx1887_pos)
    $P10 = rx1887_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1887_fail
    rx1887_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1887_pos = $P10."pos"()
  # rx pass
    rx1887_cur."!cursor_pass"(rx1887_pos, "infix:sym<::=>")
    if_null rx1887_debug, debug_1387
    rx1887_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1887_pos)
  debug_1387:
    .return (rx1887_cur)
  rx1887_restart:
.annotate 'line', 10
    if_null rx1887_debug, debug_1388
    rx1887_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1388:
  rx1887_fail:
    (rx1887_rep, rx1887_pos, $I10, $P10) = rx1887_cur."!mark_fail"(0)
    lt rx1887_pos, -1, rx1887_done
    eq rx1887_pos, -1, rx1887_fail
    jump $I10
  rx1887_done:
    rx1887_cur."!cursor_fail"()
    if_null rx1887_debug, debug_1389
    rx1887_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1389:
    .return (rx1887_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("370_1304277427.017") :method
.annotate 'line', 10
    $P1889 = self."!PREFIX__!subrule"("O", "::=")
    new $P1890, "ResizablePMCArray"
    push $P1890, $P1889
    .return ($P1890)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("371_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1894_tgt
    .local int rx1894_pos
    .local int rx1894_off
    .local int rx1894_eos
    .local int rx1894_rep
    .local pmc rx1894_cur
    .local pmc rx1894_debug
    (rx1894_cur, rx1894_pos, rx1894_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1894_cur
    .local pmc match
    .lex "$/", match
    length rx1894_eos, rx1894_tgt
    gt rx1894_pos, rx1894_eos, rx1894_done
    set rx1894_off, 0
    lt rx1894_pos, 2, rx1894_start
    sub rx1894_off, rx1894_pos, 1
    substr rx1894_tgt, rx1894_tgt, rx1894_off
  rx1894_start:
    eq $I10, 1, rx1894_restart
    if_null rx1894_debug, debug_1390
    rx1894_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1390:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1898_done
    goto rxscan1898_scan
  rxscan1898_loop:
    (rx1894_pos) = rx1894_cur."from"()
    inc rx1894_pos
    rx1894_cur."!cursor_from"(rx1894_pos)
    ge rx1894_pos, rx1894_eos, rxscan1898_done
  rxscan1898_scan:
    set_addr $I10, rxscan1898_loop
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  rxscan1898_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1899_fail
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  # rx literal  ","
    add $I11, rx1894_pos, 1
    gt $I11, rx1894_eos, rx1894_fail
    sub $I11, rx1894_pos, rx1894_off
    ord $I11, rx1894_tgt, $I11
    ne $I11, 44, rx1894_fail
    add rx1894_pos, 1
    set_addr $I10, rxcap_1899_fail
    ($I12, $I11) = rx1894_cur."!mark_peek"($I10)
    rx1894_cur."!cursor_pos"($I11)
    ($P10) = rx1894_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1894_pos, "")
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1899_done
  rxcap_1899_fail:
    goto rx1894_fail
  rxcap_1899_done:
  # rx subrule "O" subtype=capture negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1894_fail
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1894_pos = $P10."pos"()
  # rx pass
    rx1894_cur."!cursor_pass"(rx1894_pos, "infix:sym<,>")
    if_null rx1894_debug, debug_1391
    rx1894_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1894_pos)
  debug_1391:
    .return (rx1894_cur)
  rx1894_restart:
.annotate 'line', 10
    if_null rx1894_debug, debug_1392
    rx1894_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1392:
  rx1894_fail:
    (rx1894_rep, rx1894_pos, $I10, $P10) = rx1894_cur."!mark_fail"(0)
    lt rx1894_pos, -1, rx1894_done
    eq rx1894_pos, -1, rx1894_fail
    jump $I10
  rx1894_done:
    rx1894_cur."!cursor_fail"()
    if_null rx1894_debug, debug_1393
    rx1894_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1393:
    .return (rx1894_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("372_1304277427.017") :method
.annotate 'line', 10
    $P1896 = self."!PREFIX__!subrule"("O", ",")
    new $P1897, "ResizablePMCArray"
    push $P1897, $P1896
    .return ($P1897)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("373_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .const 'Sub' $P1909 = "375_1304277427.017" 
    capture_lex $P1909
    .local string rx1901_tgt
    .local int rx1901_pos
    .local int rx1901_off
    .local int rx1901_eos
    .local int rx1901_rep
    .local pmc rx1901_cur
    .local pmc rx1901_debug
    (rx1901_cur, rx1901_pos, rx1901_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1901_cur
    .local pmc match
    .lex "$/", match
    length rx1901_eos, rx1901_tgt
    gt rx1901_pos, rx1901_eos, rx1901_done
    set rx1901_off, 0
    lt rx1901_pos, 2, rx1901_start
    sub rx1901_off, rx1901_pos, 1
    substr rx1901_tgt, rx1901_tgt, rx1901_off
  rx1901_start:
    eq $I10, 1, rx1901_restart
    if_null rx1901_debug, debug_1394
    rx1901_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1394:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1904_done
    goto rxscan1904_scan
  rxscan1904_loop:
    (rx1901_pos) = rx1901_cur."from"()
    inc rx1901_pos
    rx1901_cur."!cursor_from"(rx1901_pos)
    ge rx1901_pos, rx1901_eos, rxscan1904_done
  rxscan1904_scan:
    set_addr $I10, rxscan1904_loop
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  rxscan1904_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1905_fail
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  # rx literal  "return"
    add $I11, rx1901_pos, 6
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 6
    ne $S10, "return", rx1901_fail
    add rx1901_pos, 6
    set_addr $I10, rxcap_1905_fail
    ($I12, $I11) = rx1901_cur."!mark_peek"($I10)
    rx1901_cur."!cursor_pos"($I11)
    ($P10) = rx1901_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1901_pos, "")
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1905_done
  rxcap_1905_fail:
    goto rx1901_fail
  rxcap_1905_done:
  # rx charclass s
    ge rx1901_pos, rx1901_eos, rx1901_fail
    sub $I10, rx1901_pos, rx1901_off
    is_cclass $I11, 32, rx1901_tgt, $I10
    unless $I11, rx1901_fail
    inc rx1901_pos
  # rx subrule "O" subtype=capture negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1901_fail
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1901_pos = $P10."pos"()
    rx1901_cur."!cursor_pos"(rx1901_pos)
    find_lex $P1906, unicode:"$\x{a2}"
    $P1907 = $P1906."MATCH"()
    store_lex "$/", $P1907
    .const 'Sub' $P1909 = "375_1304277427.017" 
    capture_lex $P1909
    $P1911 = $P1909()
  # rx pass
    rx1901_cur."!cursor_pass"(rx1901_pos, "prefix:sym<return>")
    if_null rx1901_debug, debug_1395
    rx1901_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1901_pos)
  debug_1395:
    .return (rx1901_cur)
  rx1901_restart:
.annotate 'line', 10
    if_null rx1901_debug, debug_1396
    rx1901_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1396:
  rx1901_fail:
    (rx1901_rep, rx1901_pos, $I10, $P10) = rx1901_cur."!mark_fail"(0)
    lt rx1901_pos, -1, rx1901_done
    eq rx1901_pos, -1, rx1901_fail
    jump $I10
  rx1901_done:
    rx1901_cur."!cursor_fail"()
    if_null rx1901_debug, debug_1397
    rx1901_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1397:
    .return (rx1901_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("374_1304277427.017") :method
.annotate 'line', 10
    new $P1903, "ResizablePMCArray"
    push $P1903, "return"
    .return ($P1903)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1908"  :anon :subid("375_1304277427.017") :outer("373_1304277427.017")
.annotate 'line', 719
    new $P1910, "Integer"
    assign $P1910, 1
    store_dynamic_lex "$*RETURN_USED", $P1910
    .return ($P1910)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("376_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1913_tgt
    .local int rx1913_pos
    .local int rx1913_off
    .local int rx1913_eos
    .local int rx1913_rep
    .local pmc rx1913_cur
    .local pmc rx1913_debug
    (rx1913_cur, rx1913_pos, rx1913_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1913_cur
    .local pmc match
    .lex "$/", match
    length rx1913_eos, rx1913_tgt
    gt rx1913_pos, rx1913_eos, rx1913_done
    set rx1913_off, 0
    lt rx1913_pos, 2, rx1913_start
    sub rx1913_off, rx1913_pos, 1
    substr rx1913_tgt, rx1913_tgt, rx1913_off
  rx1913_start:
    eq $I10, 1, rx1913_restart
    if_null rx1913_debug, debug_1398
    rx1913_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1398:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1916_done
    goto rxscan1916_scan
  rxscan1916_loop:
    (rx1913_pos) = rx1913_cur."from"()
    inc rx1913_pos
    rx1913_cur."!cursor_from"(rx1913_pos)
    ge rx1913_pos, rx1913_eos, rxscan1916_done
  rxscan1916_scan:
    set_addr $I10, rxscan1916_loop
    rx1913_cur."!mark_push"(0, rx1913_pos, $I10)
  rxscan1916_done:
.annotate 'line', 720
  # rx subcapture "sym"
    set_addr $I10, rxcap_1917_fail
    rx1913_cur."!mark_push"(0, rx1913_pos, $I10)
  # rx literal  "make"
    add $I11, rx1913_pos, 4
    gt $I11, rx1913_eos, rx1913_fail
    sub $I11, rx1913_pos, rx1913_off
    substr $S10, rx1913_tgt, $I11, 4
    ne $S10, "make", rx1913_fail
    add rx1913_pos, 4
    set_addr $I10, rxcap_1917_fail
    ($I12, $I11) = rx1913_cur."!mark_peek"($I10)
    rx1913_cur."!cursor_pos"($I11)
    ($P10) = rx1913_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1913_pos, "")
    rx1913_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1917_done
  rxcap_1917_fail:
    goto rx1913_fail
  rxcap_1917_done:
  # rx charclass s
    ge rx1913_pos, rx1913_eos, rx1913_fail
    sub $I10, rx1913_pos, rx1913_off
    is_cclass $I11, 32, rx1913_tgt, $I10
    unless $I11, rx1913_fail
    inc rx1913_pos
  # rx subrule "O" subtype=capture negate=
    rx1913_cur."!cursor_pos"(rx1913_pos)
    $P10 = rx1913_cur."O"("%list_prefix")
    unless $P10, rx1913_fail
    rx1913_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1913_pos = $P10."pos"()
  # rx pass
    rx1913_cur."!cursor_pass"(rx1913_pos, "prefix:sym<make>")
    if_null rx1913_debug, debug_1399
    rx1913_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1913_pos)
  debug_1399:
    .return (rx1913_cur)
  rx1913_restart:
.annotate 'line', 10
    if_null rx1913_debug, debug_1400
    rx1913_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1400:
  rx1913_fail:
    (rx1913_rep, rx1913_pos, $I10, $P10) = rx1913_cur."!mark_fail"(0)
    lt rx1913_pos, -1, rx1913_done
    eq rx1913_pos, -1, rx1913_fail
    jump $I10
  rx1913_done:
    rx1913_cur."!cursor_fail"()
    if_null rx1913_debug, debug_1401
    rx1913_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1401:
    .return (rx1913_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("377_1304277427.017") :method
.annotate 'line', 10
    new $P1915, "ResizablePMCArray"
    push $P1915, "make"
    .return ($P1915)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("378_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1919_tgt
    .local int rx1919_pos
    .local int rx1919_off
    .local int rx1919_eos
    .local int rx1919_rep
    .local pmc rx1919_cur
    .local pmc rx1919_debug
    (rx1919_cur, rx1919_pos, rx1919_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1919_cur
    .local pmc match
    .lex "$/", match
    length rx1919_eos, rx1919_tgt
    gt rx1919_pos, rx1919_eos, rx1919_done
    set rx1919_off, 0
    lt rx1919_pos, 2, rx1919_start
    sub rx1919_off, rx1919_pos, 1
    substr rx1919_tgt, rx1919_tgt, rx1919_off
  rx1919_start:
    eq $I10, 1, rx1919_restart
    if_null rx1919_debug, debug_1402
    rx1919_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1402:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1922_done
    goto rxscan1922_scan
  rxscan1922_loop:
    (rx1919_pos) = rx1919_cur."from"()
    inc rx1919_pos
    rx1919_cur."!cursor_from"(rx1919_pos)
    ge rx1919_pos, rx1919_eos, rxscan1922_done
  rxscan1922_scan:
    set_addr $I10, rxscan1922_loop
    rx1919_cur."!mark_push"(0, rx1919_pos, $I10)
  rxscan1922_done:
.annotate 'line', 721
  # rx subcapture "sym"
    set_addr $I10, rxcap_1923_fail
    rx1919_cur."!mark_push"(0, rx1919_pos, $I10)
  # rx literal  "last"
    add $I11, rx1919_pos, 4
    gt $I11, rx1919_eos, rx1919_fail
    sub $I11, rx1919_pos, rx1919_off
    substr $S10, rx1919_tgt, $I11, 4
    ne $S10, "last", rx1919_fail
    add rx1919_pos, 4
    set_addr $I10, rxcap_1923_fail
    ($I12, $I11) = rx1919_cur."!mark_peek"($I10)
    rx1919_cur."!cursor_pos"($I11)
    ($P10) = rx1919_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1919_pos, "")
    rx1919_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1923_done
  rxcap_1923_fail:
    goto rx1919_fail
  rxcap_1923_done:
  # rx pass
    rx1919_cur."!cursor_pass"(rx1919_pos, "term:sym<last>")
    if_null rx1919_debug, debug_1403
    rx1919_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1919_pos)
  debug_1403:
    .return (rx1919_cur)
  rx1919_restart:
.annotate 'line', 10
    if_null rx1919_debug, debug_1404
    rx1919_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1404:
  rx1919_fail:
    (rx1919_rep, rx1919_pos, $I10, $P10) = rx1919_cur."!mark_fail"(0)
    lt rx1919_pos, -1, rx1919_done
    eq rx1919_pos, -1, rx1919_fail
    jump $I10
  rx1919_done:
    rx1919_cur."!cursor_fail"()
    if_null rx1919_debug, debug_1405
    rx1919_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1405:
    .return (rx1919_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("379_1304277427.017") :method
.annotate 'line', 10
    new $P1921, "ResizablePMCArray"
    push $P1921, "last"
    .return ($P1921)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("380_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1925_tgt
    .local int rx1925_pos
    .local int rx1925_off
    .local int rx1925_eos
    .local int rx1925_rep
    .local pmc rx1925_cur
    .local pmc rx1925_debug
    (rx1925_cur, rx1925_pos, rx1925_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1925_cur
    .local pmc match
    .lex "$/", match
    length rx1925_eos, rx1925_tgt
    gt rx1925_pos, rx1925_eos, rx1925_done
    set rx1925_off, 0
    lt rx1925_pos, 2, rx1925_start
    sub rx1925_off, rx1925_pos, 1
    substr rx1925_tgt, rx1925_tgt, rx1925_off
  rx1925_start:
    eq $I10, 1, rx1925_restart
    if_null rx1925_debug, debug_1406
    rx1925_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1406:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1928_done
    goto rxscan1928_scan
  rxscan1928_loop:
    (rx1925_pos) = rx1925_cur."from"()
    inc rx1925_pos
    rx1925_cur."!cursor_from"(rx1925_pos)
    ge rx1925_pos, rx1925_eos, rxscan1928_done
  rxscan1928_scan:
    set_addr $I10, rxscan1928_loop
    rx1925_cur."!mark_push"(0, rx1925_pos, $I10)
  rxscan1928_done:
.annotate 'line', 722
  # rx subcapture "sym"
    set_addr $I10, rxcap_1929_fail
    rx1925_cur."!mark_push"(0, rx1925_pos, $I10)
  # rx literal  "next"
    add $I11, rx1925_pos, 4
    gt $I11, rx1925_eos, rx1925_fail
    sub $I11, rx1925_pos, rx1925_off
    substr $S10, rx1925_tgt, $I11, 4
    ne $S10, "next", rx1925_fail
    add rx1925_pos, 4
    set_addr $I10, rxcap_1929_fail
    ($I12, $I11) = rx1925_cur."!mark_peek"($I10)
    rx1925_cur."!cursor_pos"($I11)
    ($P10) = rx1925_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1925_pos, "")
    rx1925_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1929_done
  rxcap_1929_fail:
    goto rx1925_fail
  rxcap_1929_done:
  # rx pass
    rx1925_cur."!cursor_pass"(rx1925_pos, "term:sym<next>")
    if_null rx1925_debug, debug_1407
    rx1925_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1925_pos)
  debug_1407:
    .return (rx1925_cur)
  rx1925_restart:
.annotate 'line', 10
    if_null rx1925_debug, debug_1408
    rx1925_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1408:
  rx1925_fail:
    (rx1925_rep, rx1925_pos, $I10, $P10) = rx1925_cur."!mark_fail"(0)
    lt rx1925_pos, -1, rx1925_done
    eq rx1925_pos, -1, rx1925_fail
    jump $I10
  rx1925_done:
    rx1925_cur."!cursor_fail"()
    if_null rx1925_debug, debug_1409
    rx1925_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1409:
    .return (rx1925_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("381_1304277427.017") :method
.annotate 'line', 10
    new $P1927, "ResizablePMCArray"
    push $P1927, "next"
    .return ($P1927)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("382_1304277427.017") :method :outer("12_1304277427.017")
.annotate 'line', 10
    .local string rx1931_tgt
    .local int rx1931_pos
    .local int rx1931_off
    .local int rx1931_eos
    .local int rx1931_rep
    .local pmc rx1931_cur
    .local pmc rx1931_debug
    (rx1931_cur, rx1931_pos, rx1931_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1931_cur
    .local pmc match
    .lex "$/", match
    length rx1931_eos, rx1931_tgt
    gt rx1931_pos, rx1931_eos, rx1931_done
    set rx1931_off, 0
    lt rx1931_pos, 2, rx1931_start
    sub rx1931_off, rx1931_pos, 1
    substr rx1931_tgt, rx1931_tgt, rx1931_off
  rx1931_start:
    eq $I10, 1, rx1931_restart
    if_null rx1931_debug, debug_1410
    rx1931_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1410:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1934_done
    goto rxscan1934_scan
  rxscan1934_loop:
    (rx1931_pos) = rx1931_cur."from"()
    inc rx1931_pos
    rx1931_cur."!cursor_from"(rx1931_pos)
    ge rx1931_pos, rx1931_eos, rxscan1934_done
  rxscan1934_scan:
    set_addr $I10, rxscan1934_loop
    rx1931_cur."!mark_push"(0, rx1931_pos, $I10)
  rxscan1934_done:
.annotate 'line', 723
  # rx subcapture "sym"
    set_addr $I10, rxcap_1935_fail
    rx1931_cur."!mark_push"(0, rx1931_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1931_pos, 4
    gt $I11, rx1931_eos, rx1931_fail
    sub $I11, rx1931_pos, rx1931_off
    substr $S10, rx1931_tgt, $I11, 4
    ne $S10, "redo", rx1931_fail
    add rx1931_pos, 4
    set_addr $I10, rxcap_1935_fail
    ($I12, $I11) = rx1931_cur."!mark_peek"($I10)
    rx1931_cur."!cursor_pos"($I11)
    ($P10) = rx1931_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1931_pos, "")
    rx1931_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1935_done
  rxcap_1935_fail:
    goto rx1931_fail
  rxcap_1935_done:
  # rx pass
    rx1931_cur."!cursor_pass"(rx1931_pos, "term:sym<redo>")
    if_null rx1931_debug, debug_1411
    rx1931_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1931_pos)
  debug_1411:
    .return (rx1931_cur)
  rx1931_restart:
.annotate 'line', 10
    if_null rx1931_debug, debug_1412
    rx1931_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1412:
  rx1931_fail:
    (rx1931_rep, rx1931_pos, $I10, $P10) = rx1931_cur."!mark_fail"(0)
    lt rx1931_pos, -1, rx1931_done
    eq rx1931_pos, -1, rx1931_fail
    jump $I10
  rx1931_done:
    rx1931_cur."!cursor_fail"()
    if_null rx1931_debug, debug_1413
    rx1931_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1413:
    .return (rx1931_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("383_1304277427.017") :method
.annotate 'line', 10
    new $P1933, "ResizablePMCArray"
    push $P1933, "redo"
    .return ($P1933)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("384_1304277427.017") :outer("12_1304277427.017")
    .param pmc param_1937
    .param pmc param_1938
.annotate 'line', 725
    .lex "self", param_1937
    .lex "$/", param_1938
.annotate 'line', 727
    new $P1939, "Undef"
    .lex "$t", $P1939
    find_lex $P1940, "$/"
    unless_null $P1940, vivify_1414
    $P1940 = root_new ['parrot';'ResizablePMCArray']
  vivify_1414:
    set $P1941, $P1940[0]
    unless_null $P1941, vivify_1415
    new $P1941, "Undef"
  vivify_1415:
    store_lex "$t", $P1941
    find_lex $P1942, "$/"
    unless_null $P1942, vivify_1416
    $P1942 = root_new ['parrot';'ResizablePMCArray']
  vivify_1416:
    set $P1943, $P1942[1]
    unless_null $P1943, vivify_1417
    new $P1943, "Undef"
  vivify_1417:
    find_lex $P1944, "$/"
    unless_null $P1944, vivify_1418
    $P1944 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1944
  vivify_1418:
    set $P1944[0], $P1943
    find_lex $P1945, "$t"
    unless_null $P1945, vivify_1419
    new $P1945, "Undef"
  vivify_1419:
    find_lex $P1946, "$/"
    unless_null $P1946, vivify_1420
    $P1946 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1946
  vivify_1420:
    set $P1946[1], $P1945
.annotate 'line', 725
    .return ($P1945)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2285"  :subid("386_1304277427.017") :outer("10_1304277427.017")
.annotate 'line', 731
    .const 'Sub' $P2351 = "407_1304277427.017" 
    capture_lex $P2351
    .const 'Sub' $P2344 = "405_1304277427.017" 
    capture_lex $P2344
    .const 'Sub' $P2339 = "403_1304277427.017" 
    capture_lex $P2339
    .const 'Sub' $P2327 = "400_1304277427.017" 
    capture_lex $P2327
    .const 'Sub' $P2317 = "397_1304277427.017" 
    capture_lex $P2317
    .const 'Sub' $P2312 = "395_1304277427.017" 
    capture_lex $P2312
    .const 'Sub' $P2303 = "392_1304277427.017" 
    capture_lex $P2303
    .const 'Sub' $P2298 = "390_1304277427.017" 
    capture_lex $P2298
    .const 'Sub' $P2289 = "387_1304277427.017" 
    capture_lex $P2289
    .lex "$?PACKAGE", $P2287
    .lex "$?CLASS", $P2288
    .const 'Sub' $P2344 = "405_1304277427.017" 
    capture_lex $P2344
    .return ($P2344)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1421") :outer("386_1304277427.017")
.annotate 'line', 731
    .const 'Sub' $P2286 = "386_1304277427.017" 
    .local pmc block
    set block, $P2286
    .const 'Sub' $P2351 = "407_1304277427.017" 
    capture_lex $P2351
    $P2351()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2350"  :anon :subid("407_1304277427.017") :outer("386_1304277427.017")
.annotate 'line', 731
    nqp_get_sc_object $P2352, "1304277414.8", 194
    .local pmc type_obj
    set type_obj, $P2352
    get_how $P2353, type_obj
    get_global $P2354, "!PREFIX__metachar:sym<:my>"
    $P2353."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2354)
    get_how $P2355, type_obj
    get_global $P2356, "!PREFIX__metachar:sym<{ }>"
    $P2355."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2356)
    get_how $P2357, type_obj
    get_global $P2358, "!PREFIX__metachar:sym<nqpvar>"
    $P2357."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2358)
    get_how $P2359, type_obj
    get_global $P2360, "!PREFIX__assertion:sym<{ }>"
    $P2359."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2360)
    get_how $P2361, type_obj
    get_global $P2362, "!PREFIX__assertion:sym<?{ }>"
    $P2361."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2362)
    get_how $P2363, type_obj
    get_global $P2364, "!PREFIX__assertion:sym<name>"
    $P2363."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2364)
    get_how $P2365, type_obj
    get_global $P2366, "!PREFIX__assertion:sym<var>"
    $P2365."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2366)
    get_how $P2367, type_obj
    get_global $P2368, "!PREFIX__codeblock"
    $P2367."add_method"(type_obj, "!PREFIX__codeblock", $P2368)
    get_how $P2369, type_obj
    $P2370 = $P2369."compose"(type_obj)
    .return ($P2370)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("387_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .const 'Sub' $P2295 = "389_1304277427.017" 
    capture_lex $P2295
    .local string rx2290_tgt
    .local int rx2290_pos
    .local int rx2290_off
    .local int rx2290_eos
    .local int rx2290_rep
    .local pmc rx2290_cur
    .local pmc rx2290_debug
    (rx2290_cur, rx2290_pos, rx2290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2290_cur
    .local pmc match
    .lex "$/", match
    length rx2290_eos, rx2290_tgt
    gt rx2290_pos, rx2290_eos, rx2290_done
    set rx2290_off, 0
    lt rx2290_pos, 2, rx2290_start
    sub rx2290_off, rx2290_pos, 1
    substr rx2290_tgt, rx2290_tgt, rx2290_off
  rx2290_start:
    eq $I10, 1, rx2290_restart
    if_null rx2290_debug, debug_1422
    rx2290_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1422:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2293_done
    goto rxscan2293_scan
  rxscan2293_loop:
    (rx2290_pos) = rx2290_cur."from"()
    inc rx2290_pos
    rx2290_cur."!cursor_from"(rx2290_pos)
    ge rx2290_pos, rx2290_eos, rxscan2293_done
  rxscan2293_scan:
    set_addr $I10, rxscan2293_loop
    rx2290_cur."!mark_push"(0, rx2290_pos, $I10)
  rxscan2293_done:
.annotate 'line', 733
  # rx literal  ":"
    add $I11, rx2290_pos, 1
    gt $I11, rx2290_eos, rx2290_fail
    sub $I11, rx2290_pos, rx2290_off
    ord $I11, rx2290_tgt, $I11
    ne $I11, 58, rx2290_fail
    add rx2290_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2290_cur."!cursor_pos"(rx2290_pos)
    .const 'Sub' $P2295 = "389_1304277427.017" 
    capture_lex $P2295
    $P10 = rx2290_cur."before"($P2295)
    unless $P10, rx2290_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2290_cur."!cursor_pos"(rx2290_pos)
    $P10 = rx2290_cur."LANG"("MAIN", "statement")
    unless $P10, rx2290_fail
    rx2290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2290_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2290_cur."!cursor_pos"(rx2290_pos)
    $P10 = rx2290_cur."ws"()
    unless $P10, rx2290_fail
    rx2290_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2290_pos, 1
    gt $I11, rx2290_eos, rx2290_fail
    sub $I11, rx2290_pos, rx2290_off
    ord $I11, rx2290_tgt, $I11
    ne $I11, 59, rx2290_fail
    add rx2290_pos, 1
.annotate 'line', 732
  # rx pass
    rx2290_cur."!cursor_pass"(rx2290_pos, "metachar:sym<:my>")
    if_null rx2290_debug, debug_1427
    rx2290_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2290_pos)
  debug_1427:
    .return (rx2290_cur)
  rx2290_restart:
.annotate 'line', 731
    if_null rx2290_debug, debug_1428
    rx2290_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1428:
  rx2290_fail:
    (rx2290_rep, rx2290_pos, $I10, $P10) = rx2290_cur."!mark_fail"(0)
    lt rx2290_pos, -1, rx2290_done
    eq rx2290_pos, -1, rx2290_fail
    jump $I10
  rx2290_done:
    rx2290_cur."!cursor_fail"()
    if_null rx2290_debug, debug_1429
    rx2290_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1429:
    .return (rx2290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("388_1304277427.017") :method
.annotate 'line', 731
    new $P2292, "ResizablePMCArray"
    push $P2292, ":"
    .return ($P2292)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2294"  :anon :subid("389_1304277427.017") :method :outer("387_1304277427.017")
.annotate 'line', 733
    .local string rx2296_tgt
    .local int rx2296_pos
    .local int rx2296_off
    .local int rx2296_eos
    .local int rx2296_rep
    .local pmc rx2296_cur
    .local pmc rx2296_debug
    (rx2296_cur, rx2296_pos, rx2296_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2296_cur
    .local pmc match
    .lex "$/", match
    length rx2296_eos, rx2296_tgt
    gt rx2296_pos, rx2296_eos, rx2296_done
    set rx2296_off, 0
    lt rx2296_pos, 2, rx2296_start
    sub rx2296_off, rx2296_pos, 1
    substr rx2296_tgt, rx2296_tgt, rx2296_off
  rx2296_start:
    eq $I10, 1, rx2296_restart
    if_null rx2296_debug, debug_1423
    rx2296_cur."!cursor_debug"("START", "")
  debug_1423:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2297_done
    goto rxscan2297_scan
  rxscan2297_loop:
    (rx2296_pos) = rx2296_cur."from"()
    inc rx2296_pos
    rx2296_cur."!cursor_from"(rx2296_pos)
    ge rx2296_pos, rx2296_eos, rxscan2297_done
  rxscan2297_scan:
    set_addr $I10, rxscan2297_loop
    rx2296_cur."!mark_push"(0, rx2296_pos, $I10)
  rxscan2297_done:
  # rx literal  "my"
    add $I11, rx2296_pos, 2
    gt $I11, rx2296_eos, rx2296_fail
    sub $I11, rx2296_pos, rx2296_off
    substr $S10, rx2296_tgt, $I11, 2
    ne $S10, "my", rx2296_fail
    add rx2296_pos, 2
  # rx pass
    rx2296_cur."!cursor_pass"(rx2296_pos, "")
    if_null rx2296_debug, debug_1424
    rx2296_cur."!cursor_debug"("PASS", "", " at pos=", rx2296_pos)
  debug_1424:
    .return (rx2296_cur)
  rx2296_restart:
    if_null rx2296_debug, debug_1425
    rx2296_cur."!cursor_debug"("NEXT", "")
  debug_1425:
  rx2296_fail:
    (rx2296_rep, rx2296_pos, $I10, $P10) = rx2296_cur."!mark_fail"(0)
    lt rx2296_pos, -1, rx2296_done
    eq rx2296_pos, -1, rx2296_fail
    jump $I10
  rx2296_done:
    rx2296_cur."!cursor_fail"()
    if_null rx2296_debug, debug_1426
    rx2296_cur."!cursor_debug"("FAIL", "")
  debug_1426:
    .return (rx2296_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("390_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .local string rx2299_tgt
    .local int rx2299_pos
    .local int rx2299_off
    .local int rx2299_eos
    .local int rx2299_rep
    .local pmc rx2299_cur
    .local pmc rx2299_debug
    (rx2299_cur, rx2299_pos, rx2299_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2299_cur
    .local pmc match
    .lex "$/", match
    length rx2299_eos, rx2299_tgt
    gt rx2299_pos, rx2299_eos, rx2299_done
    set rx2299_off, 0
    lt rx2299_pos, 2, rx2299_start
    sub rx2299_off, rx2299_pos, 1
    substr rx2299_tgt, rx2299_tgt, rx2299_off
  rx2299_start:
    eq $I10, 1, rx2299_restart
    if_null rx2299_debug, debug_1430
    rx2299_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1430:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2302_done
    goto rxscan2302_scan
  rxscan2302_loop:
    (rx2299_pos) = rx2299_cur."from"()
    inc rx2299_pos
    rx2299_cur."!cursor_from"(rx2299_pos)
    ge rx2299_pos, rx2299_eos, rxscan2302_done
  rxscan2302_scan:
    set_addr $I10, rxscan2302_loop
    rx2299_cur."!mark_push"(0, rx2299_pos, $I10)
  rxscan2302_done:
.annotate 'line', 737
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2299_pos, rx2299_off
    substr $S10, rx2299_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2299_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2299_cur."!cursor_pos"(rx2299_pos)
    $P10 = rx2299_cur."codeblock"()
    unless $P10, rx2299_fail
    rx2299_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2299_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx2299_cur."!cursor_pass"(rx2299_pos, "metachar:sym<{ }>")
    if_null rx2299_debug, debug_1431
    rx2299_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2299_pos)
  debug_1431:
    .return (rx2299_cur)
  rx2299_restart:
.annotate 'line', 731
    if_null rx2299_debug, debug_1432
    rx2299_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1432:
  rx2299_fail:
    (rx2299_rep, rx2299_pos, $I10, $P10) = rx2299_cur."!mark_fail"(0)
    lt rx2299_pos, -1, rx2299_done
    eq rx2299_pos, -1, rx2299_fail
    jump $I10
  rx2299_done:
    rx2299_cur."!cursor_fail"()
    if_null rx2299_debug, debug_1433
    rx2299_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1433:
    .return (rx2299_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("391_1304277427.017") :method
.annotate 'line', 731
    new $P2301, "ResizablePMCArray"
    push $P2301, "{"
    .return ($P2301)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("392_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .const 'Sub' $P2309 = "394_1304277427.017" 
    capture_lex $P2309
    .local string rx2304_tgt
    .local int rx2304_pos
    .local int rx2304_off
    .local int rx2304_eos
    .local int rx2304_rep
    .local pmc rx2304_cur
    .local pmc rx2304_debug
    (rx2304_cur, rx2304_pos, rx2304_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2304_cur
    .local pmc match
    .lex "$/", match
    length rx2304_eos, rx2304_tgt
    gt rx2304_pos, rx2304_eos, rx2304_done
    set rx2304_off, 0
    lt rx2304_pos, 2, rx2304_start
    sub rx2304_off, rx2304_pos, 1
    substr rx2304_tgt, rx2304_tgt, rx2304_off
  rx2304_start:
    eq $I10, 1, rx2304_restart
    if_null rx2304_debug, debug_1434
    rx2304_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2307_done
    goto rxscan2307_scan
  rxscan2307_loop:
    (rx2304_pos) = rx2304_cur."from"()
    inc rx2304_pos
    rx2304_cur."!cursor_from"(rx2304_pos)
    ge rx2304_pos, rx2304_eos, rxscan2307_done
  rxscan2307_scan:
    set_addr $I10, rxscan2307_loop
    rx2304_cur."!mark_push"(0, rx2304_pos, $I10)
  rxscan2307_done:
.annotate 'line', 741
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2304_pos, rx2304_off
    substr $S10, rx2304_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2304_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2304_cur."!cursor_pos"(rx2304_pos)
    .const 'Sub' $P2309 = "394_1304277427.017" 
    capture_lex $P2309
    $P10 = rx2304_cur."before"($P2309)
    unless $P10, rx2304_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2304_cur."!cursor_pos"(rx2304_pos)
    $P10 = rx2304_cur."LANG"("MAIN", "variable")
    unless $P10, rx2304_fail
    rx2304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2304_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx2304_cur."!cursor_pass"(rx2304_pos, "metachar:sym<nqpvar>")
    if_null rx2304_debug, debug_1439
    rx2304_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2304_pos)
  debug_1439:
    .return (rx2304_cur)
  rx2304_restart:
.annotate 'line', 731
    if_null rx2304_debug, debug_1440
    rx2304_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1440:
  rx2304_fail:
    (rx2304_rep, rx2304_pos, $I10, $P10) = rx2304_cur."!mark_fail"(0)
    lt rx2304_pos, -1, rx2304_done
    eq rx2304_pos, -1, rx2304_fail
    jump $I10
  rx2304_done:
    rx2304_cur."!cursor_fail"()
    if_null rx2304_debug, debug_1441
    rx2304_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1441:
    .return (rx2304_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("393_1304277427.017") :method
.annotate 'line', 731
    new $P2306, "ResizablePMCArray"
    push $P2306, "$"
    push $P2306, "@"
    .return ($P2306)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2308"  :anon :subid("394_1304277427.017") :method :outer("392_1304277427.017")
.annotate 'line', 741
    .local string rx2310_tgt
    .local int rx2310_pos
    .local int rx2310_off
    .local int rx2310_eos
    .local int rx2310_rep
    .local pmc rx2310_cur
    .local pmc rx2310_debug
    (rx2310_cur, rx2310_pos, rx2310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2310_cur
    .local pmc match
    .lex "$/", match
    length rx2310_eos, rx2310_tgt
    gt rx2310_pos, rx2310_eos, rx2310_done
    set rx2310_off, 0
    lt rx2310_pos, 2, rx2310_start
    sub rx2310_off, rx2310_pos, 1
    substr rx2310_tgt, rx2310_tgt, rx2310_off
  rx2310_start:
    eq $I10, 1, rx2310_restart
    if_null rx2310_debug, debug_1435
    rx2310_cur."!cursor_debug"("START", "")
  debug_1435:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2311_done
    goto rxscan2311_scan
  rxscan2311_loop:
    (rx2310_pos) = rx2310_cur."from"()
    inc rx2310_pos
    rx2310_cur."!cursor_from"(rx2310_pos)
    ge rx2310_pos, rx2310_eos, rxscan2311_done
  rxscan2311_scan:
    set_addr $I10, rxscan2311_loop
    rx2310_cur."!mark_push"(0, rx2310_pos, $I10)
  rxscan2311_done:
  # rx charclass .
    ge rx2310_pos, rx2310_eos, rx2310_fail
    inc rx2310_pos
  # rx charclass w
    ge rx2310_pos, rx2310_eos, rx2310_fail
    sub $I10, rx2310_pos, rx2310_off
    is_cclass $I11, 8192, rx2310_tgt, $I10
    unless $I11, rx2310_fail
    inc rx2310_pos
  # rx pass
    rx2310_cur."!cursor_pass"(rx2310_pos, "")
    if_null rx2310_debug, debug_1436
    rx2310_cur."!cursor_debug"("PASS", "", " at pos=", rx2310_pos)
  debug_1436:
    .return (rx2310_cur)
  rx2310_restart:
    if_null rx2310_debug, debug_1437
    rx2310_cur."!cursor_debug"("NEXT", "")
  debug_1437:
  rx2310_fail:
    (rx2310_rep, rx2310_pos, $I10, $P10) = rx2310_cur."!mark_fail"(0)
    lt rx2310_pos, -1, rx2310_done
    eq rx2310_pos, -1, rx2310_fail
    jump $I10
  rx2310_done:
    rx2310_cur."!cursor_fail"()
    if_null rx2310_debug, debug_1438
    rx2310_cur."!cursor_debug"("FAIL", "")
  debug_1438:
    .return (rx2310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("395_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .local string rx2313_tgt
    .local int rx2313_pos
    .local int rx2313_off
    .local int rx2313_eos
    .local int rx2313_rep
    .local pmc rx2313_cur
    .local pmc rx2313_debug
    (rx2313_cur, rx2313_pos, rx2313_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2313_cur
    .local pmc match
    .lex "$/", match
    length rx2313_eos, rx2313_tgt
    gt rx2313_pos, rx2313_eos, rx2313_done
    set rx2313_off, 0
    lt rx2313_pos, 2, rx2313_start
    sub rx2313_off, rx2313_pos, 1
    substr rx2313_tgt, rx2313_tgt, rx2313_off
  rx2313_start:
    eq $I10, 1, rx2313_restart
    if_null rx2313_debug, debug_1442
    rx2313_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2316_done
    goto rxscan2316_scan
  rxscan2316_loop:
    (rx2313_pos) = rx2313_cur."from"()
    inc rx2313_pos
    rx2313_cur."!cursor_from"(rx2313_pos)
    ge rx2313_pos, rx2313_eos, rxscan2316_done
  rxscan2316_scan:
    set_addr $I10, rxscan2316_loop
    rx2313_cur."!mark_push"(0, rx2313_pos, $I10)
  rxscan2316_done:
.annotate 'line', 745
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2313_pos, rx2313_off
    substr $S10, rx2313_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2313_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2313_cur."!cursor_pos"(rx2313_pos)
    $P10 = rx2313_cur."codeblock"()
    unless $P10, rx2313_fail
    rx2313_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2313_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx2313_cur."!cursor_pass"(rx2313_pos, "assertion:sym<{ }>")
    if_null rx2313_debug, debug_1443
    rx2313_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2313_pos)
  debug_1443:
    .return (rx2313_cur)
  rx2313_restart:
.annotate 'line', 731
    if_null rx2313_debug, debug_1444
    rx2313_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1444:
  rx2313_fail:
    (rx2313_rep, rx2313_pos, $I10, $P10) = rx2313_cur."!mark_fail"(0)
    lt rx2313_pos, -1, rx2313_done
    eq rx2313_pos, -1, rx2313_fail
    jump $I10
  rx2313_done:
    rx2313_cur."!cursor_fail"()
    if_null rx2313_debug, debug_1445
    rx2313_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1445:
    .return (rx2313_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("396_1304277427.017") :method
.annotate 'line', 731
    new $P2315, "ResizablePMCArray"
    push $P2315, "{"
    .return ($P2315)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("397_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .const 'Sub' $P2323 = "399_1304277427.017" 
    capture_lex $P2323
    .local string rx2318_tgt
    .local int rx2318_pos
    .local int rx2318_off
    .local int rx2318_eos
    .local int rx2318_rep
    .local pmc rx2318_cur
    .local pmc rx2318_debug
    (rx2318_cur, rx2318_pos, rx2318_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2318_cur
    .local pmc match
    .lex "$/", match
    length rx2318_eos, rx2318_tgt
    gt rx2318_pos, rx2318_eos, rx2318_done
    set rx2318_off, 0
    lt rx2318_pos, 2, rx2318_start
    sub rx2318_off, rx2318_pos, 1
    substr rx2318_tgt, rx2318_tgt, rx2318_off
  rx2318_start:
    eq $I10, 1, rx2318_restart
    if_null rx2318_debug, debug_1446
    rx2318_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2321_done
    goto rxscan2321_scan
  rxscan2321_loop:
    (rx2318_pos) = rx2318_cur."from"()
    inc rx2318_pos
    rx2318_cur."!cursor_from"(rx2318_pos)
    ge rx2318_pos, rx2318_eos, rxscan2321_done
  rxscan2321_scan:
    set_addr $I10, rxscan2321_loop
    rx2318_cur."!mark_push"(0, rx2318_pos, $I10)
  rxscan2321_done:
.annotate 'line', 749
  # rx subcapture "zw"
    set_addr $I10, rxcap_2326_fail
    rx2318_cur."!mark_push"(0, rx2318_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2318_pos, rx2318_eos, rx2318_fail
    sub $I10, rx2318_pos, rx2318_off
    substr $S10, rx2318_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2318_fail
    inc rx2318_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2318_cur."!cursor_pos"(rx2318_pos)
    .const 'Sub' $P2323 = "399_1304277427.017" 
    capture_lex $P2323
    $P10 = rx2318_cur."before"($P2323)
    unless $P10, rx2318_fail
    set_addr $I10, rxcap_2326_fail
    ($I12, $I11) = rx2318_cur."!mark_peek"($I10)
    rx2318_cur."!cursor_pos"($I11)
    ($P10) = rx2318_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2318_pos, "")
    rx2318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2326_done
  rxcap_2326_fail:
    goto rx2318_fail
  rxcap_2326_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2318_cur."!cursor_pos"(rx2318_pos)
    $P10 = rx2318_cur."codeblock"()
    unless $P10, rx2318_fail
    rx2318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2318_pos = $P10."pos"()
.annotate 'line', 748
  # rx pass
    rx2318_cur."!cursor_pass"(rx2318_pos, "assertion:sym<?{ }>")
    if_null rx2318_debug, debug_1451
    rx2318_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2318_pos)
  debug_1451:
    .return (rx2318_cur)
  rx2318_restart:
.annotate 'line', 731
    if_null rx2318_debug, debug_1452
    rx2318_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1452:
  rx2318_fail:
    (rx2318_rep, rx2318_pos, $I10, $P10) = rx2318_cur."!mark_fail"(0)
    lt rx2318_pos, -1, rx2318_done
    eq rx2318_pos, -1, rx2318_fail
    jump $I10
  rx2318_done:
    rx2318_cur."!cursor_fail"()
    if_null rx2318_debug, debug_1453
    rx2318_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1453:
    .return (rx2318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("398_1304277427.017") :method
.annotate 'line', 731
    new $P2320, "ResizablePMCArray"
    push $P2320, "!"
    push $P2320, "?"
    .return ($P2320)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2322"  :anon :subid("399_1304277427.017") :method :outer("397_1304277427.017")
.annotate 'line', 749
    .local string rx2324_tgt
    .local int rx2324_pos
    .local int rx2324_off
    .local int rx2324_eos
    .local int rx2324_rep
    .local pmc rx2324_cur
    .local pmc rx2324_debug
    (rx2324_cur, rx2324_pos, rx2324_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2324_cur
    .local pmc match
    .lex "$/", match
    length rx2324_eos, rx2324_tgt
    gt rx2324_pos, rx2324_eos, rx2324_done
    set rx2324_off, 0
    lt rx2324_pos, 2, rx2324_start
    sub rx2324_off, rx2324_pos, 1
    substr rx2324_tgt, rx2324_tgt, rx2324_off
  rx2324_start:
    eq $I10, 1, rx2324_restart
    if_null rx2324_debug, debug_1447
    rx2324_cur."!cursor_debug"("START", "")
  debug_1447:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2325_done
    goto rxscan2325_scan
  rxscan2325_loop:
    (rx2324_pos) = rx2324_cur."from"()
    inc rx2324_pos
    rx2324_cur."!cursor_from"(rx2324_pos)
    ge rx2324_pos, rx2324_eos, rxscan2325_done
  rxscan2325_scan:
    set_addr $I10, rxscan2325_loop
    rx2324_cur."!mark_push"(0, rx2324_pos, $I10)
  rxscan2325_done:
  # rx literal  "{"
    add $I11, rx2324_pos, 1
    gt $I11, rx2324_eos, rx2324_fail
    sub $I11, rx2324_pos, rx2324_off
    ord $I11, rx2324_tgt, $I11
    ne $I11, 123, rx2324_fail
    add rx2324_pos, 1
  # rx pass
    rx2324_cur."!cursor_pass"(rx2324_pos, "")
    if_null rx2324_debug, debug_1448
    rx2324_cur."!cursor_debug"("PASS", "", " at pos=", rx2324_pos)
  debug_1448:
    .return (rx2324_cur)
  rx2324_restart:
    if_null rx2324_debug, debug_1449
    rx2324_cur."!cursor_debug"("NEXT", "")
  debug_1449:
  rx2324_fail:
    (rx2324_rep, rx2324_pos, $I10, $P10) = rx2324_cur."!mark_fail"(0)
    lt rx2324_pos, -1, rx2324_done
    eq rx2324_pos, -1, rx2324_fail
    jump $I10
  rx2324_done:
    rx2324_cur."!cursor_fail"()
    if_null rx2324_debug, debug_1450
    rx2324_cur."!cursor_debug"("FAIL", "")
  debug_1450:
    .return (rx2324_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("400_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .const 'Sub' $P2336 = "402_1304277427.017" 
    capture_lex $P2336
    .local string rx2328_tgt
    .local int rx2328_pos
    .local int rx2328_off
    .local int rx2328_eos
    .local int rx2328_rep
    .local pmc rx2328_cur
    .local pmc rx2328_debug
    (rx2328_cur, rx2328_pos, rx2328_tgt, $I10) = self."!cursor_start"()
    rx2328_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2328_cur
    .local pmc match
    .lex "$/", match
    length rx2328_eos, rx2328_tgt
    gt rx2328_pos, rx2328_eos, rx2328_done
    set rx2328_off, 0
    lt rx2328_pos, 2, rx2328_start
    sub rx2328_off, rx2328_pos, 1
    substr rx2328_tgt, rx2328_tgt, rx2328_off
  rx2328_start:
    eq $I10, 1, rx2328_restart
    if_null rx2328_debug, debug_1454
    rx2328_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2332_done
    goto rxscan2332_scan
  rxscan2332_loop:
    (rx2328_pos) = rx2328_cur."from"()
    inc rx2328_pos
    rx2328_cur."!cursor_from"(rx2328_pos)
    ge rx2328_pos, rx2328_eos, rxscan2332_done
  rxscan2332_scan:
    set_addr $I10, rxscan2332_loop
    rx2328_cur."!mark_push"(0, rx2328_pos, $I10)
  rxscan2332_done:
.annotate 'line', 753
  # rx subrule "identifier" subtype=capture negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."identifier"()
    unless $P10, rx2328_fail
    rx2328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2328_pos = $P10."pos"()
.annotate 'line', 760
  # rx rxquantr2333 ** 0..1
    set_addr $I10, rxquantr2333_done
    rx2328_cur."!mark_push"(0, rx2328_pos, $I10)
  rxquantr2333_loop:
  alt2334_0:
.annotate 'line', 754
    set_addr $I10, alt2334_1
    rx2328_cur."!mark_push"(0, rx2328_pos, $I10)
.annotate 'line', 755
  # rx subrule "before" subtype=zerowidth negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    .const 'Sub' $P2336 = "402_1304277427.017" 
    capture_lex $P2336
    $P10 = rx2328_cur."before"($P2336)
    unless $P10, rx2328_fail
    goto alt2334_end
  alt2334_1:
    set_addr $I10, alt2334_2
    rx2328_cur."!mark_push"(0, rx2328_pos, $I10)
.annotate 'line', 756
  # rx literal  "="
    add $I11, rx2328_pos, 1
    gt $I11, rx2328_eos, rx2328_fail
    sub $I11, rx2328_pos, rx2328_off
    ord $I11, rx2328_tgt, $I11
    ne $I11, 61, rx2328_fail
    add rx2328_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."assertion"()
    unless $P10, rx2328_fail
    rx2328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2328_pos = $P10."pos"()
    goto alt2334_end
  alt2334_2:
    set_addr $I10, alt2334_3
    rx2328_cur."!mark_push"(0, rx2328_pos, $I10)
.annotate 'line', 757
  # rx literal  ":"
    add $I11, rx2328_pos, 1
    gt $I11, rx2328_eos, rx2328_fail
    sub $I11, rx2328_pos, rx2328_off
    ord $I11, rx2328_tgt, $I11
    ne $I11, 58, rx2328_fail
    add rx2328_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."arglist"()
    unless $P10, rx2328_fail
    rx2328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2328_pos = $P10."pos"()
    goto alt2334_end
  alt2334_3:
    set_addr $I10, alt2334_4
    rx2328_cur."!mark_push"(0, rx2328_pos, $I10)
.annotate 'line', 758
  # rx literal  "("
    add $I11, rx2328_pos, 1
    gt $I11, rx2328_eos, rx2328_fail
    sub $I11, rx2328_pos, rx2328_off
    ord $I11, rx2328_tgt, $I11
    ne $I11, 40, rx2328_fail
    add rx2328_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2328_fail
    rx2328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2328_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2328_pos, 1
    gt $I11, rx2328_eos, rx2328_fail
    sub $I11, rx2328_pos, rx2328_off
    ord $I11, rx2328_tgt, $I11
    ne $I11, 41, rx2328_fail
    add rx2328_pos, 1
    goto alt2334_end
  alt2334_4:
.annotate 'line', 759
  # rx subrule "normspace" subtype=method negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."normspace"()
    unless $P10, rx2328_fail
    rx2328_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."nibbler"()
    unless $P10, rx2328_fail
    rx2328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2328_pos = $P10."pos"()
  alt2334_end:
.annotate 'line', 760
    set_addr $I10, rxquantr2333_done
    (rx2328_rep) = rx2328_cur."!mark_commit"($I10)
  rxquantr2333_done:
.annotate 'line', 752
  # rx pass
    rx2328_cur."!cursor_pass"(rx2328_pos, "assertion:sym<name>")
    if_null rx2328_debug, debug_1459
    rx2328_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2328_pos)
  debug_1459:
    .return (rx2328_cur)
  rx2328_restart:
.annotate 'line', 731
    if_null rx2328_debug, debug_1460
    rx2328_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1460:
  rx2328_fail:
    (rx2328_rep, rx2328_pos, $I10, $P10) = rx2328_cur."!mark_fail"(0)
    lt rx2328_pos, -1, rx2328_done
    eq rx2328_pos, -1, rx2328_fail
    jump $I10
  rx2328_done:
    rx2328_cur."!cursor_fail"()
    if_null rx2328_debug, debug_1461
    rx2328_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1461:
    .return (rx2328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("401_1304277427.017") :method
.annotate 'line', 731
    $P2330 = self."!PREFIX__!subrule"("identifier", "")
    new $P2331, "ResizablePMCArray"
    push $P2331, $P2330
    .return ($P2331)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2335"  :anon :subid("402_1304277427.017") :method :outer("400_1304277427.017")
.annotate 'line', 755
    .local string rx2337_tgt
    .local int rx2337_pos
    .local int rx2337_off
    .local int rx2337_eos
    .local int rx2337_rep
    .local pmc rx2337_cur
    .local pmc rx2337_debug
    (rx2337_cur, rx2337_pos, rx2337_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2337_cur
    .local pmc match
    .lex "$/", match
    length rx2337_eos, rx2337_tgt
    gt rx2337_pos, rx2337_eos, rx2337_done
    set rx2337_off, 0
    lt rx2337_pos, 2, rx2337_start
    sub rx2337_off, rx2337_pos, 1
    substr rx2337_tgt, rx2337_tgt, rx2337_off
  rx2337_start:
    eq $I10, 1, rx2337_restart
    if_null rx2337_debug, debug_1455
    rx2337_cur."!cursor_debug"("START", "")
  debug_1455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2338_done
    goto rxscan2338_scan
  rxscan2338_loop:
    (rx2337_pos) = rx2337_cur."from"()
    inc rx2337_pos
    rx2337_cur."!cursor_from"(rx2337_pos)
    ge rx2337_pos, rx2337_eos, rxscan2338_done
  rxscan2338_scan:
    set_addr $I10, rxscan2338_loop
    rx2337_cur."!mark_push"(0, rx2337_pos, $I10)
  rxscan2338_done:
  # rx literal  ">"
    add $I11, rx2337_pos, 1
    gt $I11, rx2337_eos, rx2337_fail
    sub $I11, rx2337_pos, rx2337_off
    ord $I11, rx2337_tgt, $I11
    ne $I11, 62, rx2337_fail
    add rx2337_pos, 1
  # rx pass
    rx2337_cur."!cursor_pass"(rx2337_pos, "")
    if_null rx2337_debug, debug_1456
    rx2337_cur."!cursor_debug"("PASS", "", " at pos=", rx2337_pos)
  debug_1456:
    .return (rx2337_cur)
  rx2337_restart:
    if_null rx2337_debug, debug_1457
    rx2337_cur."!cursor_debug"("NEXT", "")
  debug_1457:
  rx2337_fail:
    (rx2337_rep, rx2337_pos, $I10, $P10) = rx2337_cur."!mark_fail"(0)
    lt rx2337_pos, -1, rx2337_done
    eq rx2337_pos, -1, rx2337_fail
    jump $I10
  rx2337_done:
    rx2337_cur."!cursor_fail"()
    if_null rx2337_debug, debug_1458
    rx2337_cur."!cursor_debug"("FAIL", "")
  debug_1458:
    .return (rx2337_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("403_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .local string rx2340_tgt
    .local int rx2340_pos
    .local int rx2340_off
    .local int rx2340_eos
    .local int rx2340_rep
    .local pmc rx2340_cur
    .local pmc rx2340_debug
    (rx2340_cur, rx2340_pos, rx2340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2340_cur
    .local pmc match
    .lex "$/", match
    length rx2340_eos, rx2340_tgt
    gt rx2340_pos, rx2340_eos, rx2340_done
    set rx2340_off, 0
    lt rx2340_pos, 2, rx2340_start
    sub rx2340_off, rx2340_pos, 1
    substr rx2340_tgt, rx2340_tgt, rx2340_off
  rx2340_start:
    eq $I10, 1, rx2340_restart
    if_null rx2340_debug, debug_1462
    rx2340_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2343_done
    goto rxscan2343_scan
  rxscan2343_loop:
    (rx2340_pos) = rx2340_cur."from"()
    inc rx2340_pos
    rx2340_cur."!cursor_from"(rx2340_pos)
    ge rx2340_pos, rx2340_eos, rxscan2343_done
  rxscan2343_scan:
    set_addr $I10, rxscan2343_loop
    rx2340_cur."!mark_push"(0, rx2340_pos, $I10)
  rxscan2343_done:
.annotate 'line', 764
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2340_pos, rx2340_off
    substr $S10, rx2340_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2340_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2340_cur."!cursor_pos"(rx2340_pos)
    $P10 = rx2340_cur."LANG"("MAIN", "variable")
    unless $P10, rx2340_fail
    rx2340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2340_pos = $P10."pos"()
.annotate 'line', 763
  # rx pass
    rx2340_cur."!cursor_pass"(rx2340_pos, "assertion:sym<var>")
    if_null rx2340_debug, debug_1463
    rx2340_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2340_pos)
  debug_1463:
    .return (rx2340_cur)
  rx2340_restart:
.annotate 'line', 731
    if_null rx2340_debug, debug_1464
    rx2340_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1464:
  rx2340_fail:
    (rx2340_rep, rx2340_pos, $I10, $P10) = rx2340_cur."!mark_fail"(0)
    lt rx2340_pos, -1, rx2340_done
    eq rx2340_pos, -1, rx2340_fail
    jump $I10
  rx2340_done:
    rx2340_cur."!cursor_fail"()
    if_null rx2340_debug, debug_1465
    rx2340_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1465:
    .return (rx2340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("404_1304277427.017") :method
.annotate 'line', 731
    new $P2342, "ResizablePMCArray"
    push $P2342, "$"
    push $P2342, "@"
    .return ($P2342)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("405_1304277427.017") :method :outer("386_1304277427.017")
.annotate 'line', 731
    .local string rx2345_tgt
    .local int rx2345_pos
    .local int rx2345_off
    .local int rx2345_eos
    .local int rx2345_rep
    .local pmc rx2345_cur
    .local pmc rx2345_debug
    (rx2345_cur, rx2345_pos, rx2345_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2345_cur
    .local pmc match
    .lex "$/", match
    length rx2345_eos, rx2345_tgt
    gt rx2345_pos, rx2345_eos, rx2345_done
    set rx2345_off, 0
    lt rx2345_pos, 2, rx2345_start
    sub rx2345_off, rx2345_pos, 1
    substr rx2345_tgt, rx2345_tgt, rx2345_off
  rx2345_start:
    eq $I10, 1, rx2345_restart
    if_null rx2345_debug, debug_1466
    rx2345_cur."!cursor_debug"("START", "codeblock")
  debug_1466:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2349_done
    goto rxscan2349_scan
  rxscan2349_loop:
    (rx2345_pos) = rx2345_cur."from"()
    inc rx2345_pos
    rx2345_cur."!cursor_from"(rx2345_pos)
    ge rx2345_pos, rx2345_eos, rxscan2349_done
  rxscan2349_scan:
    set_addr $I10, rxscan2349_loop
    rx2345_cur."!mark_push"(0, rx2345_pos, $I10)
  rxscan2349_done:
.annotate 'line', 768
  # rx subrule "LANG" subtype=capture negate=
    rx2345_cur."!cursor_pos"(rx2345_pos)
    $P10 = rx2345_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2345_fail
    rx2345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2345_pos = $P10."pos"()
.annotate 'line', 767
  # rx pass
    rx2345_cur."!cursor_pass"(rx2345_pos, "codeblock")
    if_null rx2345_debug, debug_1467
    rx2345_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2345_pos)
  debug_1467:
    .return (rx2345_cur)
  rx2345_restart:
.annotate 'line', 731
    if_null rx2345_debug, debug_1468
    rx2345_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1468:
  rx2345_fail:
    (rx2345_rep, rx2345_pos, $I10, $P10) = rx2345_cur."!mark_fail"(0)
    lt rx2345_pos, -1, rx2345_done
    eq rx2345_pos, -1, rx2345_fail
    jump $I10
  rx2345_done:
    rx2345_cur."!cursor_fail"()
    if_null rx2345_debug, debug_1469
    rx2345_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1469:
    .return (rx2345_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("406_1304277427.017") :method
.annotate 'line', 731
    $P2347 = self."!PREFIX__!subrule"("LANG", "")
    new $P2348, "ResizablePMCArray"
    push $P2348, $P2347
    .return ($P2348)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2371"  :subid("408_1304277427.017") :outer("10_1304277427.017")
.annotate 'line', 774
    .const 'Sub' $P6456 = "582_1304277427.017" 
    capture_lex $P6456
    .const 'Sub' $P6435 = "580_1304277427.017" 
    capture_lex $P6435
    .const 'Sub' $P6420 = "579_1304277427.017" 
    capture_lex $P6420
    .const 'Sub' $P6415 = "578_1304277427.017" 
    capture_lex $P6415
    .const 'Sub' $P6410 = "577_1304277427.017" 
    capture_lex $P6410
    .const 'Sub' $P6405 = "576_1304277427.017" 
    capture_lex $P6405
    .const 'Sub' $P6388 = "575_1304277427.017" 
    capture_lex $P6388
    .const 'Sub' $P6377 = "574_1304277427.017" 
    capture_lex $P6377
    .const 'Sub' $P6366 = "573_1304277427.017" 
    capture_lex $P6366
    .const 'Sub' $P6358 = "572_1304277427.017" 
    capture_lex $P6358
    .const 'Sub' $P6353 = "571_1304277427.017" 
    capture_lex $P6353
    .const 'Sub' $P6338 = "570_1304277427.017" 
    capture_lex $P6338
    .const 'Sub' $P6330 = "569_1304277427.017" 
    capture_lex $P6330
    .const 'Sub' $P6272 = "568_1304277427.017" 
    capture_lex $P6272
    .const 'Sub' $P6257 = "567_1304277427.017" 
    capture_lex $P6257
    .const 'Sub' $P6249 = "566_1304277427.017" 
    capture_lex $P6249
    .const 'Sub' $P6241 = "565_1304277427.017" 
    capture_lex $P6241
    .const 'Sub' $P6233 = "564_1304277427.017" 
    capture_lex $P6233
    .const 'Sub' $P6225 = "563_1304277427.017" 
    capture_lex $P6225
    .const 'Sub' $P6217 = "562_1304277427.017" 
    capture_lex $P6217
    .const 'Sub' $P6188 = "561_1304277427.017" 
    capture_lex $P6188
    .const 'Sub' $P6173 = "560_1304277427.017" 
    capture_lex $P6173
    .const 'Sub' $P6165 = "559_1304277427.017" 
    capture_lex $P6165
    .const 'Sub' $P6151 = "558_1304277427.017" 
    capture_lex $P6151
    .const 'Sub' $P6137 = "557_1304277427.017" 
    capture_lex $P6137
    .const 'Sub' $P6123 = "556_1304277427.017" 
    capture_lex $P6123
    .const 'Sub' $P6115 = "555_1304277427.017" 
    capture_lex $P6115
    .const 'Sub' $P6085 = "554_1304277427.017" 
    capture_lex $P6085
    .const 'Sub' $P6047 = "552_1304277427.017" 
    capture_lex $P6047
    .const 'Sub' $P6039 = "551_1304277427.017" 
    capture_lex $P6039
    .const 'Sub' $P6031 = "550_1304277427.017" 
    capture_lex $P6031
    .const 'Sub' $P6000 = "549_1304277427.017" 
    capture_lex $P6000
    .const 'Sub' $P5981 = "548_1304277427.017" 
    capture_lex $P5981
    .const 'Sub' $P5973 = "547_1304277427.017" 
    capture_lex $P5973
    .const 'Sub' $P5965 = "546_1304277427.017" 
    capture_lex $P5965
    .const 'Sub' $P5857 = "543_1304277427.017" 
    capture_lex $P5857
    .const 'Sub' $P5849 = "542_1304277427.017" 
    capture_lex $P5849
    .const 'Sub' $P5839 = "541_1304277427.017" 
    capture_lex $P5839
    .const 'Sub' $P5805 = "540_1304277427.017" 
    capture_lex $P5805
    .const 'Sub' $P5763 = "538_1304277427.017" 
    capture_lex $P5763
    .const 'Sub' $P5749 = "537_1304277427.017" 
    capture_lex $P5749
    .const 'Sub' $P5739 = "536_1304277427.017" 
    capture_lex $P5739
    .const 'Sub' $P5687 = "535_1304277427.017" 
    capture_lex $P5687
    .const 'Sub' $P5468 = "531_1304277427.017" 
    capture_lex $P5468
    .const 'Sub' $P5395 = "528_1304277427.017" 
    capture_lex $P5395
    .const 'Sub' $P5387 = "527_1304277427.017" 
    capture_lex $P5387
    .const 'Sub' $P5343 = "525_1304277427.017" 
    capture_lex $P5343
    .const 'Sub' $P5328 = "524_1304277427.017" 
    capture_lex $P5328
    .const 'Sub' $P5305 = "523_1304277427.017" 
    capture_lex $P5305
    .const 'Sub' $P5202 = "522_1304277427.017" 
    capture_lex $P5202
    .const 'Sub' $P5148 = "519_1304277427.017" 
    capture_lex $P5148
    .const 'Sub' $P5019 = "516_1304277427.017" 
    capture_lex $P5019
    .const 'Sub' $P4692 = "509_1304277427.017" 
    capture_lex $P4692
    .const 'Sub' $P4684 = "508_1304277427.017" 
    capture_lex $P4684
    .const 'Sub' $P4676 = "507_1304277427.017" 
    capture_lex $P4676
    .const 'Sub' $P4551 = "505_1304277427.017" 
    capture_lex $P4551
    .const 'Sub' $P4543 = "504_1304277427.017" 
    capture_lex $P4543
    .const 'Sub' $P4528 = "503_1304277427.017" 
    capture_lex $P4528
    .const 'Sub' $P4513 = "502_1304277427.017" 
    capture_lex $P4513
    .const 'Sub' $P4498 = "501_1304277427.017" 
    capture_lex $P4498
    .const 'Sub' $P4476 = "500_1304277427.017" 
    capture_lex $P4476
    .const 'Sub' $P4468 = "499_1304277427.017" 
    capture_lex $P4468
    .const 'Sub' $P4460 = "498_1304277427.017" 
    capture_lex $P4460
    .const 'Sub' $P4452 = "497_1304277427.017" 
    capture_lex $P4452
    .const 'Sub' $P4144 = "491_1304277427.017" 
    capture_lex $P4144
    .const 'Sub' $P4136 = "490_1304277427.017" 
    capture_lex $P4136
    .const 'Sub' $P4128 = "489_1304277427.017" 
    capture_lex $P4128
    .const 'Sub' $P4120 = "488_1304277427.017" 
    capture_lex $P4120
    .const 'Sub' $P4112 = "487_1304277427.017" 
    capture_lex $P4112
    .const 'Sub' $P4104 = "486_1304277427.017" 
    capture_lex $P4104
    .const 'Sub' $P4096 = "485_1304277427.017" 
    capture_lex $P4096
    .const 'Sub' $P3893 = "479_1304277427.017" 
    capture_lex $P3893
    .const 'Sub' $P3866 = "478_1304277427.017" 
    capture_lex $P3866
    .const 'Sub' $P3852 = "477_1304277427.017" 
    capture_lex $P3852
    .const 'Sub' $P3844 = "476_1304277427.017" 
    capture_lex $P3844
    .const 'Sub' $P3836 = "475_1304277427.017" 
    capture_lex $P3836
    .const 'Sub' $P3828 = "474_1304277427.017" 
    capture_lex $P3828
    .const 'Sub' $P3820 = "473_1304277427.017" 
    capture_lex $P3820
    .const 'Sub' $P3812 = "472_1304277427.017" 
    capture_lex $P3812
    .const 'Sub' $P3804 = "471_1304277427.017" 
    capture_lex $P3804
    .const 'Sub' $P3796 = "470_1304277427.017" 
    capture_lex $P3796
    .const 'Sub' $P3788 = "469_1304277427.017" 
    capture_lex $P3788
    .const 'Sub' $P3780 = "468_1304277427.017" 
    capture_lex $P3780
    .const 'Sub' $P3772 = "467_1304277427.017" 
    capture_lex $P3772
    .const 'Sub' $P3764 = "466_1304277427.017" 
    capture_lex $P3764
    .const 'Sub' $P3756 = "465_1304277427.017" 
    capture_lex $P3756
    .const 'Sub' $P3748 = "464_1304277427.017" 
    capture_lex $P3748
    .const 'Sub' $P3732 = "463_1304277427.017" 
    capture_lex $P3732
    .const 'Sub' $P3678 = "462_1304277427.017" 
    capture_lex $P3678
    .const 'Sub' $P3661 = "461_1304277427.017" 
    capture_lex $P3661
    .const 'Sub' $P3637 = "460_1304277427.017" 
    capture_lex $P3637
    .const 'Sub' $P3614 = "459_1304277427.017" 
    capture_lex $P3614
    .const 'Sub' $P3587 = "458_1304277427.017" 
    capture_lex $P3587
    .const 'Sub' $P3550 = "457_1304277427.017" 
    capture_lex $P3550
    .const 'Sub' $P3535 = "456_1304277427.017" 
    capture_lex $P3535
    .const 'Sub' $P3523 = "455_1304277427.017" 
    capture_lex $P3523
    .const 'Sub' $P3472 = "453_1304277427.017" 
    capture_lex $P3472
    .const 'Sub' $P3447 = "452_1304277427.017" 
    capture_lex $P3447
    .const 'Sub' $P3440 = "451_1304277427.017" 
    capture_lex $P3440
    .const 'Sub' $P3398 = "450_1304277427.017" 
    capture_lex $P3398
    .const 'Sub' $P3348 = "448_1304277427.017" 
    capture_lex $P3348
    .const 'Sub' $P3331 = "447_1304277427.017" 
    capture_lex $P3331
    .const 'Sub' $P3292 = "445_1304277427.017" 
    capture_lex $P3292
    .const 'Sub' $P3284 = "444_1304277427.017" 
    capture_lex $P3284
    .const 'Sub' $P3276 = "443_1304277427.017" 
    capture_lex $P3276
    .const 'Sub' $P3259 = "442_1304277427.017" 
    capture_lex $P3259
    .const 'Sub' $P3163 = "440_1304277427.017" 
    capture_lex $P3163
    .const 'Sub' $P3119 = "438_1304277427.017" 
    capture_lex $P3119
    .const 'Sub' $P3004 = "437_1304277427.017" 
    capture_lex $P3004
    .const 'Sub' $P2973 = "436_1304277427.017" 
    capture_lex $P2973
    .const 'Sub' $P2965 = "435_1304277427.017" 
    capture_lex $P2965
    .const 'Sub' $P2836 = "429_1304277427.017" 
    capture_lex $P2836
    .const 'Sub' $P2801 = "427_1304277427.017" 
    capture_lex $P2801
    .const 'Sub' $P2796 = "426_1304277427.017" 
    capture_lex $P2796
    .const 'Sub' $P2791 = "425_1304277427.017" 
    capture_lex $P2791
    .const 'Sub' $P2678 = "422_1304277427.017" 
    capture_lex $P2678
    .const 'Sub' $P2660 = "421_1304277427.017" 
    capture_lex $P2660
    .const 'Sub' $P2585 = "419_1304277427.017" 
    capture_lex $P2585
    .const 'Sub' $P2570 = "418_1304277427.017" 
    capture_lex $P2570
    .const 'Sub' $P2483 = "417_1304277427.017" 
    capture_lex $P2483
    .const 'Sub' $P2457 = "415_1304277427.017" 
    capture_lex $P2457
    .const 'Sub' $P2441 = "414_1304277427.017" 
    capture_lex $P2441
    .const 'Sub' $P2417 = "413_1304277427.017" 
    capture_lex $P2417
    .const 'Sub' $P2381 = "410_1304277427.017" 
    capture_lex $P2381
    .const 'Sub' $P2373 = "409_1304277427.017" 
    capture_lex $P2373
.annotate 'line', 778
    .const 'Sub' $P2373 = "409_1304277427.017" 
    newclosure $P2380, $P2373
    .lex "xblock_immediate", $P2380
.annotate 'line', 783
    .const 'Sub' $P2381 = "410_1304277427.017" 
    newclosure $P2416, $P2381
    .lex "block_immediate", $P2416
.annotate 'line', 793
    .const 'Sub' $P2417 = "413_1304277427.017" 
    newclosure $P2440, $P2417
    .lex "vivitype", $P2440
.annotate 'line', 812
    .const 'Sub' $P2441 = "414_1304277427.017" 
    newclosure $P2456, $P2441
    .lex "colonpair_str", $P2456
.annotate 'line', 974
    .const 'Sub' $P2457 = "415_1304277427.017" 
    newclosure $P2482, $P2457
    .lex "import_HOW_exports", $P2482
.annotate 'line', 1079
    .const 'Sub' $P2483 = "417_1304277427.017" 
    newclosure $P2569, $P2483
    .lex "push_block_handler", $P2569
.annotate 'line', 1613
    .const 'Sub' $P2570 = "418_1304277427.017" 
    newclosure $P2584, $P2570
    .lex "only_star_block", $P2584
.annotate 'line', 1622
    .const 'Sub' $P2585 = "419_1304277427.017" 
    newclosure $P2659, $P2585
    .lex "attach_multi_signature", $P2659
.annotate 'line', 2074
    .const 'Sub' $P2660 = "421_1304277427.017" 
    newclosure $P2677, $P2660
    .lex "control", $P2677
.annotate 'line', 2093
    .const 'Sub' $P2678 = "422_1304277427.017" 
    newclosure $P2790, $P2678
    .lex "lexical_package_lookup", $P2790
.annotate 'line', 2142
    .const 'Sub' $P2791 = "425_1304277427.017" 
    newclosure $P2795, $P2791
    .lex "is_lexical", $P2795
.annotate 'line', 2148
    .const 'Sub' $P2796 = "426_1304277427.017" 
    newclosure $P2800, $P2796
    .lex "is_package", $P2800
.annotate 'line', 2154
    .const 'Sub' $P2801 = "427_1304277427.017" 
    newclosure $P2835, $P2801
    .lex "is_scope", $P2835
.annotate 'line', 2177
    .const 'Sub' $P2836 = "429_1304277427.017" 
    newclosure $P2956, $P2836
    .lex "find_sym", $P2956
.annotate 'line', 774
    .lex "$?PACKAGE", $P2957
    .lex "$?CLASS", $P2958
.annotate 'line', 776
    new $P2959, "ResizablePMCArray"
    find_lex $P2960, "$?PACKAGE"
    get_who $P2961, $P2960
    set $P2961["@BLOCK"], $P2959
    find_lex $P2962, "xblock_immediate"
    find_lex $P2963, "block_immediate"
    find_lex $P2964, "vivitype"
.annotate 'line', 804
    find_lex $P3003, "colonpair_str"
.annotate 'line', 957
    find_lex $P3397, "import_HOW_exports"
.annotate 'line', 1072
    find_lex $P3660, "push_block_handler"
.annotate 'line', 1560
    find_lex $P5146, "only_star_block"
    find_lex $P5147, "attach_multi_signature"
.annotate 'line', 2065
    find_lex $P6404, "control"
.annotate 'line', 2087
    find_lex $P6431, "lexical_package_lookup"
    find_lex $P6432, "is_lexical"
    find_lex $P6433, "is_package"
    find_lex $P6434, "is_scope"
.annotate 'line', 2165
    find_lex $P6454, "find_sym"
.annotate 'line', 774
    .return ($P6454)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1470") :outer("408_1304277427.017")
.annotate 'line', 774
    .const 'Sub' $P2372 = "408_1304277427.017" 
    .local pmc block
    set block, $P2372
    .const 'Sub' $P6456 = "582_1304277427.017" 
    capture_lex $P6456
    $P6456()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6455"  :anon :subid("582_1304277427.017") :outer("408_1304277427.017")
.annotate 'line', 774
    nqp_get_sc_object $P6457, "1304277414.8", 203
    .local pmc type_obj
    set type_obj, $P6457
    get_how $P6458, type_obj
    $P6459 = $P6458."compose"(type_obj)
    .return ($P6459)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("409_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2374
.annotate 'line', 778
    .lex "$xblock", param_2374
.annotate 'line', 779
    find_lex $P2375, "$xblock"
    unless_null $P2375, vivify_1471
    $P2375 = root_new ['parrot';'ResizablePMCArray']
  vivify_1471:
    set $P2376, $P2375[1]
    unless_null $P2376, vivify_1472
    new $P2376, "Undef"
  vivify_1472:
    $P2377 = "block_immediate"($P2376)
    find_lex $P2378, "$xblock"
    unless_null $P2378, vivify_1473
    $P2378 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2378
  vivify_1473:
    set $P2378[1], $P2377
    find_lex $P2379, "$xblock"
    unless_null $P2379, vivify_1474
    new $P2379, "Undef"
  vivify_1474:
.annotate 'line', 778
    .return ($P2379)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("410_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2382
.annotate 'line', 783
    .const 'Sub' $P2392 = "411_1304277427.017" 
    capture_lex $P2392
    .lex "$block", param_2382
.annotate 'line', 784
    find_lex $P2383, "$block"
    unless_null $P2383, vivify_1475
    new $P2383, "Undef"
  vivify_1475:
    $P2383."blocktype"("immediate")
.annotate 'line', 785
    find_lex $P2387, "$block"
    unless_null $P2387, vivify_1476
    new $P2387, "Undef"
  vivify_1476:
    $P2388 = $P2387."symtable"()
    unless $P2388, unless_2386
    set $P2385, $P2388
    goto unless_2386_end
  unless_2386:
    find_lex $P2389, "$block"
    unless_null $P2389, vivify_1477
    new $P2389, "Undef"
  vivify_1477:
    $P2390 = $P2389."handlers"()
    set $P2385, $P2390
  unless_2386_end:
    if $P2385, unless_2384_end
    .const 'Sub' $P2392 = "411_1304277427.017" 
    capture_lex $P2392
    $P2392()
  unless_2384_end:
    find_lex $P2415, "$block"
    unless_null $P2415, vivify_1484
    new $P2415, "Undef"
  vivify_1484:
.annotate 'line', 783
    .return ($P2415)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2391"  :anon :subid("411_1304277427.017") :outer("410_1304277427.017")
.annotate 'line', 785
    .const 'Sub' $P2406 = "412_1304277427.017" 
    capture_lex $P2406
.annotate 'line', 786
    new $P2393, "Undef"
    .lex "$stmts", $P2393
    get_hll_global $P2394, "GLOBAL"
    nqp_get_package_through_who $P2395, $P2394, "PAST"
    get_who $P2396, $P2395
    set $P2397, $P2396["Stmts"]
    find_lex $P2398, "$block"
    unless_null $P2398, vivify_1478
    new $P2398, "Undef"
  vivify_1478:
    $P2399 = $P2397."new"($P2398 :named("node"))
    store_lex "$stmts", $P2399
.annotate 'line', 787
    find_lex $P2401, "$block"
    unless_null $P2401, vivify_1479
    new $P2401, "Undef"
  vivify_1479:
    $P2402 = $P2401."list"()
    defined $I2403, $P2402
    unless $I2403, for_undef_1480
    iter $P2400, $P2402
    new $P2412, 'ExceptionHandler'
    set_label $P2412, loop2411_handler
    $P2412."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2412
  loop2411_test:
    unless $P2400, loop2411_done
    shift $P2404, $P2400
  loop2411_redo:
    .const 'Sub' $P2406 = "412_1304277427.017" 
    capture_lex $P2406
    $P2406($P2404)
  loop2411_next:
    goto loop2411_test
  loop2411_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2413, exception, 'type'
    eq $P2413, .CONTROL_LOOP_NEXT, loop2411_next
    eq $P2413, .CONTROL_LOOP_REDO, loop2411_redo
  loop2411_done:
    pop_eh 
  for_undef_1480:
.annotate 'line', 788
    find_lex $P2414, "$stmts"
    unless_null $P2414, vivify_1483
    new $P2414, "Undef"
  vivify_1483:
    store_lex "$block", $P2414
.annotate 'line', 785
    .return ($P2414)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2405"  :anon :subid("412_1304277427.017") :outer("411_1304277427.017")
    .param pmc param_2407
.annotate 'line', 787
    .lex "$_", param_2407
    find_lex $P2408, "$stmts"
    unless_null $P2408, vivify_1481
    new $P2408, "Undef"
  vivify_1481:
    find_lex $P2409, "$_"
    unless_null $P2409, vivify_1482
    new $P2409, "Undef"
  vivify_1482:
    $P2410 = $P2408."push"($P2409)
    .return ($P2410)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("413_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2418
.annotate 'line', 793
    .lex "$sigil", param_2418
.annotate 'line', 794
    find_lex $P2421, "$sigil"
    unless_null $P2421, vivify_1485
    new $P2421, "Undef"
  vivify_1485:
    set $S2422, $P2421
    iseq $I2423, $S2422, "%"
    if $I2423, if_2420
.annotate 'line', 796
    find_lex $P2431, "$sigil"
    unless_null $P2431, vivify_1486
    new $P2431, "Undef"
  vivify_1486:
    set $S2432, $P2431
    iseq $I2433, $S2432, "@"
    if $I2433, if_2430
    new $P2439, "String"
    assign $P2439, "Undef"
    set $P2429, $P2439
    goto if_2430_end
  if_2430:
.annotate 'line', 797
    get_hll_global $P2434, "GLOBAL"
    nqp_get_package_through_who $P2435, $P2434, "PAST"
    get_who $P2436, $P2435
    set $P2437, $P2436["Op"]
    $P2438 = $P2437."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2429, $P2438
  if_2430_end:
    set $P2419, $P2429
.annotate 'line', 794
    goto if_2420_end
  if_2420:
.annotate 'line', 795
    get_hll_global $P2424, "GLOBAL"
    nqp_get_package_through_who $P2425, $P2424, "PAST"
    get_who $P2426, $P2425
    set $P2427, $P2426["Op"]
    $P2428 = $P2427."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2419, $P2428
  if_2420_end:
.annotate 'line', 793
    .return ($P2419)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("414_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2442
.annotate 'line', 812
    .lex "$ast", param_2442
.annotate 'line', 813
    get_hll_global $P2445, "GLOBAL"
    nqp_get_package_through_who $P2446, $P2445, "PAST"
    get_who $P2447, $P2446
    set $P2448, $P2447["Op"]
    find_lex $P2449, "$ast"
    unless_null $P2449, vivify_1487
    new $P2449, "Undef"
  vivify_1487:
    $P2450 = $P2448."ACCEPTS"($P2449)
    if $P2450, if_2444
.annotate 'line', 815
    find_lex $P2454, "$ast"
    unless_null $P2454, vivify_1488
    new $P2454, "Undef"
  vivify_1488:
    $P2455 = $P2454."value"()
    set $P2443, $P2455
.annotate 'line', 813
    goto if_2444_end
  if_2444:
.annotate 'line', 814
    find_lex $P2451, "$ast"
    unless_null $P2451, vivify_1489
    new $P2451, "Undef"
  vivify_1489:
    $P2452 = $P2451."list"()
    join $S2453, " ", $P2452
    new $P2443, 'String'
    set $P2443, $S2453
  if_2444_end:
.annotate 'line', 812
    .return ($P2443)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("415_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2458
.annotate 'line', 974
    .const 'Sub' $P2470 = "416_1304277427.017" 
    capture_lex $P2470
    .lex "$UNIT", param_2458
.annotate 'line', 976
    find_lex $P2461, "$UNIT"
    unless_null $P2461, vivify_1490
    new $P2461, "Undef"
  vivify_1490:
    exists $I2462, $P2461["EXPORTHOW"]
    if $I2462, if_2460
    new $P2459, 'Integer'
    set $P2459, $I2462
    goto if_2460_end
  if_2460:
.annotate 'line', 977
    find_lex $P2464, "$UNIT"
    unless_null $P2464, vivify_1491
    $P2464 = root_new ['parrot';'Hash']
  vivify_1491:
    set $P2465, $P2464["EXPORTHOW"]
    unless_null $P2465, vivify_1492
    new $P2465, "Undef"
  vivify_1492:
    get_who $P2466, $P2465
    defined $I2467, $P2466
    unless $I2467, for_undef_1493
    iter $P2463, $P2466
    new $P2480, 'ExceptionHandler'
    set_label $P2480, loop2479_handler
    $P2480."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2480
  loop2479_test:
    unless $P2463, loop2479_done
    shift $P2468, $P2463
  loop2479_redo:
    .const 'Sub' $P2470 = "416_1304277427.017" 
    capture_lex $P2470
    $P2470($P2468)
  loop2479_next:
    goto loop2479_test
  loop2479_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2481, exception, 'type'
    eq $P2481, .CONTROL_LOOP_NEXT, loop2479_next
    eq $P2481, .CONTROL_LOOP_REDO, loop2479_redo
  loop2479_done:
    pop_eh 
  for_undef_1493:
.annotate 'line', 976
    set $P2459, $P2463
  if_2460_end:
.annotate 'line', 974
    .return ($P2459)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2469"  :anon :subid("416_1304277427.017") :outer("415_1304277427.017")
    .param pmc param_2471
.annotate 'line', 977
    .lex "$_", param_2471
.annotate 'line', 978
    find_lex $P2472, "$_"
    unless_null $P2472, vivify_1494
    new $P2472, "Undef"
  vivify_1494:
    $P2473 = $P2472."value"()
    find_lex $P2474, "$_"
    unless_null $P2474, vivify_1495
    new $P2474, "Undef"
  vivify_1495:
    $P2475 = $P2474."key"()
    find_dynamic_lex $P2478, "%*HOW"
    unless_null $P2478, vivify_1496
    get_hll_global $P2476, "GLOBAL"
    get_who $P2477, $P2476
    set $P2478, $P2477["%HOW"]
    unless_null $P2478, vivify_1497
    die "Contextual %*HOW not found"
  vivify_1497:
    store_dynamic_lex "%*HOW", $P2478
  vivify_1496:
    set $P2478[$P2475], $P2473
.annotate 'line', 977
    .return ($P2473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("417_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2484
    .param pmc param_2485
.annotate 'line', 1079
    .lex "$/", param_2484
    .lex "$block", param_2485
.annotate 'line', 1080
    find_lex $P2487, "$?PACKAGE"
    get_who $P2488, $P2487
    set $P2489, $P2488["@BLOCK"]
    unless_null $P2489, vivify_1498
    $P2489 = root_new ['parrot';'ResizablePMCArray']
  vivify_1498:
    set $P2490, $P2489[0]
    unless_null $P2490, vivify_1499
    new $P2490, "Undef"
  vivify_1499:
    $P2491 = $P2490."handlers"()
    if $P2491, unless_2486_end
.annotate 'line', 1081
    find_lex $P2492, "$?PACKAGE"
    get_who $P2493, $P2492
    set $P2494, $P2493["@BLOCK"]
    unless_null $P2494, vivify_1500
    $P2494 = root_new ['parrot';'ResizablePMCArray']
  vivify_1500:
    set $P2495, $P2494[0]
    unless_null $P2495, vivify_1501
    new $P2495, "Undef"
  vivify_1501:
    new $P2496, "ResizablePMCArray"
    $P2495."handlers"($P2496)
  unless_2486_end:
.annotate 'line', 1083
    find_lex $P2498, "$block"
    unless_null $P2498, vivify_1502
    new $P2498, "Undef"
  vivify_1502:
    $P2499 = $P2498."arity"()
    if $P2499, unless_2497_end
.annotate 'line', 1084
    find_lex $P2500, "$block"
    unless_null $P2500, vivify_1503
    new $P2500, "Undef"
  vivify_1503:
.annotate 'line', 1085
    get_hll_global $P2501, "GLOBAL"
    nqp_get_package_through_who $P2502, $P2501, "PAST"
    get_who $P2503, $P2502
    set $P2504, $P2503["Op"]
.annotate 'line', 1086
    get_hll_global $P2505, "GLOBAL"
    nqp_get_package_through_who $P2506, $P2505, "PAST"
    get_who $P2507, $P2506
    set $P2508, $P2507["Var"]
    $P2509 = $P2508."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1087
    get_hll_global $P2510, "GLOBAL"
    nqp_get_package_through_who $P2511, $P2510, "PAST"
    get_who $P2512, $P2511
    set $P2513, $P2512["Var"]
    $P2514 = $P2513."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2515 = $P2504."new"($P2509, $P2514, "bind" :named("pasttype"))
.annotate 'line', 1085
    $P2500."unshift"($P2515)
.annotate 'line', 1090
    find_lex $P2516, "$block"
    unless_null $P2516, vivify_1504
    new $P2516, "Undef"
  vivify_1504:
    get_hll_global $P2517, "GLOBAL"
    nqp_get_package_through_who $P2518, $P2517, "PAST"
    get_who $P2519, $P2518
    set $P2520, $P2519["Var"]
    $P2521 = $P2520."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2516."unshift"($P2521)
.annotate 'line', 1091
    find_lex $P2522, "$block"
    unless_null $P2522, vivify_1505
    new $P2522, "Undef"
  vivify_1505:
    $P2522."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1092
    find_lex $P2523, "$block"
    unless_null $P2523, vivify_1506
    new $P2523, "Undef"
  vivify_1506:
    $P2523."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1093
    find_lex $P2524, "$block"
    unless_null $P2524, vivify_1507
    new $P2524, "Undef"
  vivify_1507:
    $P2524."arity"(1)
  unless_2497_end:
.annotate 'line', 1095
    find_lex $P2525, "$block"
    unless_null $P2525, vivify_1508
    new $P2525, "Undef"
  vivify_1508:
    $P2525."blocktype"("declaration")
.annotate 'line', 1096
    find_lex $P2526, "$?PACKAGE"
    get_who $P2527, $P2526
    set $P2528, $P2527["@BLOCK"]
    unless_null $P2528, vivify_1509
    $P2528 = root_new ['parrot';'ResizablePMCArray']
  vivify_1509:
    set $P2529, $P2528[0]
    unless_null $P2529, vivify_1510
    new $P2529, "Undef"
  vivify_1510:
    $P2530 = $P2529."handlers"()
.annotate 'line', 1097
    get_hll_global $P2531, "GLOBAL"
    nqp_get_package_through_who $P2532, $P2531, "PAST"
    get_who $P2533, $P2532
    set $P2534, $P2533["Control"]
    find_lex $P2535, "$/"
    unless_null $P2535, vivify_1511
    new $P2535, "Undef"
  vivify_1511:
.annotate 'line', 1099
    get_hll_global $P2536, "GLOBAL"
    nqp_get_package_through_who $P2537, $P2536, "PAST"
    get_who $P2538, $P2537
    set $P2539, $P2538["Stmts"]
.annotate 'line', 1100
    get_hll_global $P2540, "GLOBAL"
    nqp_get_package_through_who $P2541, $P2540, "PAST"
    get_who $P2542, $P2541
    set $P2543, $P2542["Op"]
    find_lex $P2544, "$block"
    unless_null $P2544, vivify_1512
    new $P2544, "Undef"
  vivify_1512:
.annotate 'line', 1102
    get_hll_global $P2545, "GLOBAL"
    nqp_get_package_through_who $P2546, $P2545, "PAST"
    get_who $P2547, $P2546
    set $P2548, $P2547["Var"]
    $P2549 = $P2548."new"("register" :named("scope"), "exception" :named("name"))
    $P2550 = $P2543."new"($P2544, $P2549, "call" :named("pasttype"))
.annotate 'line', 1104
    get_hll_global $P2551, "GLOBAL"
    nqp_get_package_through_who $P2552, $P2551, "PAST"
    get_who $P2553, $P2552
    set $P2554, $P2553["Op"]
.annotate 'line', 1105
    get_hll_global $P2555, "GLOBAL"
    nqp_get_package_through_who $P2556, $P2555, "PAST"
    get_who $P2557, $P2556
    set $P2558, $P2557["Var"]
.annotate 'line', 1106
    get_hll_global $P2559, "GLOBAL"
    nqp_get_package_through_who $P2560, $P2559, "PAST"
    get_who $P2561, $P2560
    set $P2562, $P2561["Var"]
    $P2563 = $P2562."new"("register" :named("scope"), "exception" :named("name"))
    $P2564 = $P2558."new"($P2563, "handled", "keyed" :named("scope"))
.annotate 'line', 1105
    $P2565 = $P2554."new"($P2564, 1, "bind" :named("pasttype"))
.annotate 'line', 1104
    $P2566 = $P2539."new"($P2550, $P2565)
.annotate 'line', 1099
    $P2567 = $P2534."new"($P2566, $P2535 :named("node"))
.annotate 'line', 1097
    $P2568 = $P2530."unshift"($P2567)
.annotate 'line', 1079
    .return ($P2568)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("418_1304277427.017") :outer("408_1304277427.017")
.annotate 'line', 1614
    new $P2571, "Undef"
    .lex "$past", $P2571
    find_lex $P2572, "$?PACKAGE"
    get_who $P2573, $P2572
    set $P2574, $P2573["@BLOCK"]
    unless_null $P2574, vivify_1513
    $P2574 = root_new ['parrot';'ResizablePMCArray']
  vivify_1513:
    $P2575 = $P2574."shift"()
    store_lex "$past", $P2575
.annotate 'line', 1615
    find_lex $P2576, "$past"
    unless_null $P2576, vivify_1514
    new $P2576, "Undef"
  vivify_1514:
    $P2576."closure"(1)
.annotate 'line', 1616
    find_lex $P2577, "$past"
    unless_null $P2577, vivify_1515
    new $P2577, "Undef"
  vivify_1515:
    get_hll_global $P2578, "GLOBAL"
    nqp_get_package_through_who $P2579, $P2578, "PAST"
    get_who $P2580, $P2579
    set $P2581, $P2580["Op"]
    $P2582 = $P2581."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2577."push"($P2582)
    find_lex $P2583, "$past"
    unless_null $P2583, vivify_1516
    new $P2583, "Undef"
  vivify_1516:
.annotate 'line', 1613
    .return ($P2583)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("419_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2586
.annotate 'line', 1622
    .const 'Sub' $P2606 = "420_1304277427.017" 
    capture_lex $P2606
    .lex "$routine", param_2586
.annotate 'line', 1626
    new $P2587, "Undef"
    .lex "$types", $P2587
.annotate 'line', 1627
    new $P2588, "Undef"
    .lex "$definednesses", $P2588
.annotate 'line', 1626
    get_hll_global $P2589, "GLOBAL"
    nqp_get_package_through_who $P2590, $P2589, "PAST"
    get_who $P2591, $P2590
    set $P2592, $P2591["Op"]
    $P2593 = $P2592."new"("list" :named("pasttype"))
    store_lex "$types", $P2593
.annotate 'line', 1627
    get_hll_global $P2594, "GLOBAL"
    nqp_get_package_through_who $P2595, $P2594, "PAST"
    get_who $P2596, $P2595
    set $P2597, $P2596["Op"]
    $P2598 = $P2597."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2598
.annotate 'line', 1628
    find_lex $P2600, "$routine"
    unless_null $P2600, vivify_1517
    $P2600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1517:
    set $P2601, $P2600[0]
    unless_null $P2601, vivify_1518
    new $P2601, "Undef"
  vivify_1518:
    $P2602 = $P2601."list"()
    defined $I2603, $P2602
    unless $I2603, for_undef_1519
    iter $P2599, $P2602
    new $P2650, 'ExceptionHandler'
    set_label $P2650, loop2649_handler
    $P2650."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2650
  loop2649_test:
    unless $P2599, loop2649_done
    shift $P2604, $P2599
  loop2649_redo:
    .const 'Sub' $P2606 = "420_1304277427.017" 
    capture_lex $P2606
    $P2606($P2604)
  loop2649_next:
    goto loop2649_test
  loop2649_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2651, exception, 'type'
    eq $P2651, .CONTROL_LOOP_NEXT, loop2649_next
    eq $P2651, .CONTROL_LOOP_REDO, loop2649_redo
  loop2649_done:
    pop_eh 
  for_undef_1519:
.annotate 'line', 1635
    find_dynamic_lex $P2654, "$*SC"
    unless_null $P2654, vivify_1529
    get_hll_global $P2652, "GLOBAL"
    get_who $P2653, $P2652
    set $P2654, $P2653["$SC"]
    unless_null $P2654, vivify_1530
    die "Contextual $*SC not found"
  vivify_1530:
  vivify_1529:
    find_lex $P2655, "$routine"
    unless_null $P2655, vivify_1531
    new $P2655, "Undef"
  vivify_1531:
    find_lex $P2656, "$types"
    unless_null $P2656, vivify_1532
    new $P2656, "Undef"
  vivify_1532:
    find_lex $P2657, "$definednesses"
    unless_null $P2657, vivify_1533
    new $P2657, "Undef"
  vivify_1533:
    $P2658 = $P2654."set_routine_signature"($P2655, $P2656, $P2657)
.annotate 'line', 1622
    .return ($P2658)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2605"  :anon :subid("420_1304277427.017") :outer("419_1304277427.017")
    .param pmc param_2607
.annotate 'line', 1628
    .lex "$_", param_2607
.annotate 'line', 1629
    get_hll_global $P2612, "GLOBAL"
    nqp_get_package_through_who $P2613, $P2612, "PAST"
    get_who $P2614, $P2613
    set $P2615, $P2614["Var"]
    find_lex $P2616, "$_"
    unless_null $P2616, vivify_1520
    new $P2616, "Undef"
  vivify_1520:
    $P2617 = $P2615."ACCEPTS"($P2616)
    if $P2617, if_2611
    set $P2610, $P2617
    goto if_2611_end
  if_2611:
    find_lex $P2618, "$_"
    unless_null $P2618, vivify_1521
    new $P2618, "Undef"
  vivify_1521:
    $S2619 = $P2618."scope"()
    iseq $I2620, $S2619, "parameter"
    new $P2610, 'Integer'
    set $P2610, $I2620
  if_2611_end:
    if $P2610, if_2609
    set $P2608, $P2610
    goto if_2609_end
  if_2609:
.annotate 'line', 1630
    find_lex $P2621, "$types"
    unless_null $P2621, vivify_1522
    new $P2621, "Undef"
  vivify_1522:
    find_lex $P2623, "$_"
    unless_null $P2623, vivify_1523
    new $P2623, "Undef"
  vivify_1523:
    $P2624 = $P2623."multitype"()
    set $P2622, $P2624
    defined $I2626, $P2622
    if $I2626, default_2625
    get_hll_global $P2627, "GLOBAL"
    nqp_get_package_through_who $P2628, $P2627, "PAST"
    get_who $P2629, $P2628
    set $P2630, $P2629["Op"]
    $P2631 = $P2630."new"("null P" :named("pirop"))
    set $P2622, $P2631
  default_2625:
    $P2621."push"($P2622)
.annotate 'line', 1631
    find_lex $P2632, "$definednesses"
    unless_null $P2632, vivify_1524
    new $P2632, "Undef"
  vivify_1524:
    find_lex $P2635, "$_"
    unless_null $P2635, vivify_1525
    $P2635 = root_new ['parrot';'Hash']
  vivify_1525:
    set $P2636, $P2635["definedness"]
    unless_null $P2636, vivify_1526
    new $P2636, "Undef"
  vivify_1526:
    set $S2637, $P2636
    iseq $I2638, $S2637, "D"
    if $I2638, if_2634
.annotate 'line', 1632
    find_lex $P2642, "$_"
    unless_null $P2642, vivify_1527
    $P2642 = root_new ['parrot';'Hash']
  vivify_1527:
    set $P2643, $P2642["definedness"]
    unless_null $P2643, vivify_1528
    new $P2643, "Undef"
  vivify_1528:
    set $S2644, $P2643
    iseq $I2645, $S2644, "U"
    if $I2645, if_2641
    new $P2647, "Integer"
    assign $P2647, 0
    set $P2640, $P2647
    goto if_2641_end
  if_2641:
    new $P2646, "Integer"
    assign $P2646, 2
    set $P2640, $P2646
  if_2641_end:
    set $P2633, $P2640
.annotate 'line', 1631
    goto if_2634_end
  if_2634:
    new $P2639, "Integer"
    assign $P2639, 1
    set $P2633, $P2639
  if_2634_end:
    $P2648 = $P2632."push"($P2633)
.annotate 'line', 1629
    set $P2608, $P2648
  if_2609_end:
.annotate 'line', 1628
    .return ($P2608)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("421_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2661
    .param pmc param_2662
.annotate 'line', 2074
    .lex "$/", param_2661
    .lex "$type", param_2662
.annotate 'line', 2075
    find_lex $P2663, "$/"
    get_hll_global $P2664, "GLOBAL"
    nqp_get_package_through_who $P2665, $P2664, "PAST"
    get_who $P2666, $P2665
    set $P2667, $P2666["Op"]
    find_lex $P2668, "$/"
    unless_null $P2668, vivify_1534
    new $P2668, "Undef"
  vivify_1534:
.annotate 'line', 2079
    get_hll_global $P2669, "GLOBAL"
    nqp_get_package_through_who $P2670, $P2669, "PAST"
    get_who $P2671, $P2670
    set $P2672, $P2671["Val"]
    find_lex $P2673, "$type"
    unless_null $P2673, vivify_1535
    new $P2673, "Undef"
  vivify_1535:
    $P2674 = $P2672."new"($P2673 :named("value"), "!except_types" :named("returns"))
    $P2675 = $P2667."new"(0, $P2674, $P2668 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2075
    $P2676 = $P2663."!make"($P2675)
.annotate 'line', 2074
    .return ($P2676)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("422_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2681
    .param pmc param_2682
.annotate 'line', 2093
    .const 'Sub' $P2735 = "423_1304277427.017" 
    capture_lex $P2735
    new $P2680, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2680, control_2679
    push_eh $P2680
    .lex "@name", param_2681
    .lex "$/", param_2682
.annotate 'line', 2099
    new $P2683, "Undef"
    .lex "$final_name", $P2683
.annotate 'line', 2100
    new $P2684, "Undef"
    .lex "$lookup", $P2684
.annotate 'line', 2095
    find_lex $P2686, "@name"
    unless_null $P2686, vivify_1536
    $P2686 = root_new ['parrot';'ResizablePMCArray']
  vivify_1536:
    set $N2687, $P2686
    iseq $I2688, $N2687, 0.0
    unless $I2688, if_2685_end
    find_lex $P2689, "$/"
    unless_null $P2689, vivify_1537
    new $P2689, "Undef"
  vivify_1537:
    $P2690 = $P2689."CURSOR"()
    $P2690."panic"("Cannot compile empty name")
  if_2685_end:
.annotate 'line', 2099
    find_lex $P2691, "@name"
    unless_null $P2691, vivify_1538
    $P2691 = root_new ['parrot';'ResizablePMCArray']
  vivify_1538:
    $P2692 = $P2691."pop"()
    store_lex "$final_name", $P2692
.annotate 'line', 2100
    get_hll_global $P2693, "GLOBAL"
    nqp_get_package_through_who $P2694, $P2693, "PAST"
    get_who $P2695, $P2694
    set $P2696, $P2695["Var"]
    find_lex $P2697, "$final_name"
    unless_null $P2697, vivify_1539
    new $P2697, "Undef"
  vivify_1539:
    set $S2698, $P2697
    $P2699 = $P2696."new"($S2698, "keyed" :named("scope"))
    store_lex "$lookup", $P2699
.annotate 'line', 2104
    find_lex $P2701, "@name"
    unless_null $P2701, vivify_1540
    $P2701 = root_new ['parrot';'ResizablePMCArray']
  vivify_1540:
    set $N2702, $P2701
    iseq $I2703, $N2702, 0.0
    if $I2703, if_2700
.annotate 'line', 2122
    .const 'Sub' $P2735 = "423_1304277427.017" 
    capture_lex $P2735
    $P2735()
    goto if_2700_end
  if_2700:
.annotate 'line', 2105
    find_lex $P2704, "$lookup"
    unless_null $P2704, vivify_1553
    new $P2704, "Undef"
  vivify_1553:
    get_hll_global $P2705, "GLOBAL"
    nqp_get_package_through_who $P2706, $P2705, "PAST"
    get_who $P2707, $P2706
    set $P2708, $P2707["Op"]
.annotate 'line', 2107
    get_hll_global $P2709, "GLOBAL"
    nqp_get_package_through_who $P2710, $P2709, "PAST"
    get_who $P2711, $P2710
    set $P2712, $P2711["Var"]
    $P2713 = $P2712."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2714 = $P2708."new"($P2713, "get_who PP" :named("pirop"))
.annotate 'line', 2105
    $P2704."unshift"($P2714)
.annotate 'line', 2109
    find_lex $P2715, "$lookup"
    unless_null $P2715, vivify_1554
    new $P2715, "Undef"
  vivify_1554:
    get_hll_global $P2716, "GLOBAL"
    nqp_get_package_through_who $P2717, $P2716, "PAST"
    get_who $P2718, $P2717
    set $P2719, $P2718["Var"]
.annotate 'line', 2111
    get_hll_global $P2720, "GLOBAL"
    nqp_get_package_through_who $P2721, $P2720, "PAST"
    get_who $P2722, $P2721
    set $P2723, $P2722["Op"]
.annotate 'line', 2113
    get_hll_global $P2724, "GLOBAL"
    nqp_get_package_through_who $P2725, $P2724, "PAST"
    get_who $P2726, $P2725
    set $P2727, $P2726["Var"]
    new $P2728, "ResizablePMCArray"
    $P2729 = $P2727."new"("GLOBAL" :named("name"), $P2728 :named("namespace"), "package" :named("scope"))
    $P2730 = $P2723."new"($P2729, "get_who PP" :named("pirop"))
.annotate 'line', 2115
    find_lex $P2731, "$final_name"
    unless_null $P2731, vivify_1555
    new $P2731, "Undef"
  vivify_1555:
    set $S2732, $P2731
    $P2733 = $P2719."new"($P2730, $S2732, "keyed" :named("scope"))
.annotate 'line', 2109
    $P2715."viviself"($P2733)
  if_2700_end:
.annotate 'line', 2137
    new $P2787, "Exception"
    set $P2787['type'], .CONTROL_RETURN
    find_lex $P2788, "$lookup"
    unless_null $P2788, vivify_1556
    new $P2788, "Undef"
  vivify_1556:
    setattribute $P2787, 'payload', $P2788
    throw $P2787
.annotate 'line', 2093
    .return ()
  control_2679:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2789, exception, "payload"
    .return ($P2789)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2734"  :anon :subid("423_1304277427.017") :outer("422_1304277427.017")
.annotate 'line', 2122
    .const 'Sub' $P2766 = "424_1304277427.017" 
    capture_lex $P2766
.annotate 'line', 2123
    new $P2736, "Undef"
    .lex "$path", $P2736
    find_lex $P2739, "@name"
    unless_null $P2739, vivify_1541
    $P2739 = root_new ['parrot';'ResizablePMCArray']
  vivify_1541:
    set $P2740, $P2739[0]
    unless_null $P2740, vivify_1542
    new $P2740, "Undef"
  vivify_1542:
    $P2741 = "is_lexical"($P2740)
    if $P2741, if_2738
.annotate 'line', 2125
    get_hll_global $P2749, "GLOBAL"
    nqp_get_package_through_who $P2750, $P2749, "PAST"
    get_who $P2751, $P2750
    set $P2752, $P2751["Var"]
    new $P2753, "ResizablePMCArray"
    $P2754 = $P2752."new"("GLOBAL" :named("name"), $P2753 :named("namespace"), "package" :named("scope"))
    set $P2737, $P2754
.annotate 'line', 2123
    goto if_2738_end
  if_2738:
.annotate 'line', 2124
    get_hll_global $P2742, "GLOBAL"
    nqp_get_package_through_who $P2743, $P2742, "PAST"
    get_who $P2744, $P2743
    set $P2745, $P2744["Var"]
    find_lex $P2746, "@name"
    unless_null $P2746, vivify_1543
    $P2746 = root_new ['parrot';'ResizablePMCArray']
  vivify_1543:
    $P2747 = $P2746."shift"()
    $P2748 = $P2745."new"($P2747 :named("name"), "lexical" :named("scope"))
    set $P2737, $P2748
  if_2738_end:
.annotate 'line', 2123
    store_lex "$path", $P2737
.annotate 'line', 2126
    find_lex $P2756, "@name"
    unless_null $P2756, vivify_1544
    $P2756 = root_new ['parrot';'ResizablePMCArray']
  vivify_1544:
    set $P2757, $P2756[0]
    unless_null $P2757, vivify_1545
    new $P2757, "Undef"
  vivify_1545:
    set $S2758, $P2757
    iseq $I2759, $S2758, "GLOBAL"
    unless $I2759, if_2755_end
.annotate 'line', 2127
    find_lex $P2760, "@name"
    unless_null $P2760, vivify_1546
    $P2760 = root_new ['parrot';'ResizablePMCArray']
  vivify_1546:
    $P2760."shift"()
  if_2755_end:
.annotate 'line', 2129
    find_lex $P2762, "@name"
    unless_null $P2762, vivify_1547
    $P2762 = root_new ['parrot';'ResizablePMCArray']
  vivify_1547:
    defined $I2763, $P2762
    unless $I2763, for_undef_1548
    iter $P2761, $P2762
    new $P2777, 'ExceptionHandler'
    set_label $P2777, loop2776_handler
    $P2777."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2777
  loop2776_test:
    unless $P2761, loop2776_done
    shift $P2764, $P2761
  loop2776_redo:
    .const 'Sub' $P2766 = "424_1304277427.017" 
    capture_lex $P2766
    $P2766($P2764)
  loop2776_next:
    goto loop2776_test
  loop2776_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2778, exception, 'type'
    eq $P2778, .CONTROL_LOOP_NEXT, loop2776_next
    eq $P2778, .CONTROL_LOOP_REDO, loop2776_redo
  loop2776_done:
    pop_eh 
  for_undef_1548:
.annotate 'line', 2134
    find_lex $P2779, "$lookup"
    unless_null $P2779, vivify_1551
    new $P2779, "Undef"
  vivify_1551:
    get_hll_global $P2780, "GLOBAL"
    nqp_get_package_through_who $P2781, $P2780, "PAST"
    get_who $P2782, $P2781
    set $P2783, $P2782["Op"]
    find_lex $P2784, "$path"
    unless_null $P2784, vivify_1552
    new $P2784, "Undef"
  vivify_1552:
    $P2785 = $P2783."new"($P2784, "get_who PP" :named("pirop"))
    $P2786 = $P2779."unshift"($P2785)
.annotate 'line', 2122
    .return ($P2786)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2765"  :anon :subid("424_1304277427.017") :outer("423_1304277427.017")
    .param pmc param_2767
.annotate 'line', 2129
    .lex "$_", param_2767
.annotate 'line', 2130
    get_hll_global $P2768, "GLOBAL"
    nqp_get_package_through_who $P2769, $P2768, "PAST"
    get_who $P2770, $P2769
    set $P2771, $P2770["Op"]
    find_lex $P2772, "$path"
    unless_null $P2772, vivify_1549
    new $P2772, "Undef"
  vivify_1549:
.annotate 'line', 2132
    find_lex $P2773, "$_"
    unless_null $P2773, vivify_1550
    new $P2773, "Undef"
  vivify_1550:
    set $S2774, $P2773
    $P2775 = $P2771."new"($P2772, $S2774, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2130
    store_lex "$path", $P2775
.annotate 'line', 2129
    .return ($P2775)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("425_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2792
.annotate 'line', 2142
    .lex "$name", param_2792
.annotate 'line', 2143
    find_lex $P2793, "$name"
    unless_null $P2793, vivify_1557
    new $P2793, "Undef"
  vivify_1557:
    $P2794 = "is_scope"($P2793, "lexical")
.annotate 'line', 2142
    .return ($P2794)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("426_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2797
.annotate 'line', 2148
    .lex "$name", param_2797
.annotate 'line', 2149
    find_lex $P2798, "$name"
    unless_null $P2798, vivify_1558
    new $P2798, "Undef"
  vivify_1558:
    $P2799 = "is_scope"($P2798, "package")
.annotate 'line', 2148
    .return ($P2799)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("427_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2804
    .param pmc param_2805
.annotate 'line', 2154
    .const 'Sub' $P2813 = "428_1304277427.017" 
    capture_lex $P2813
    new $P2803, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2803, control_2802
    push_eh $P2803
    .lex "$name", param_2804
    .lex "$wanted_scope", param_2805
.annotate 'line', 2155
    find_lex $P2807, "$?PACKAGE"
    get_who $P2808, $P2807
    set $P2809, $P2808["@BLOCK"]
    unless_null $P2809, vivify_1559
    $P2809 = root_new ['parrot';'ResizablePMCArray']
  vivify_1559:
    defined $I2810, $P2809
    unless $I2810, for_undef_1560
    iter $P2806, $P2809
    new $P2832, 'ExceptionHandler'
    set_label $P2832, loop2831_handler
    $P2832."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2832
  loop2831_test:
    unless $P2806, loop2831_done
    shift $P2811, $P2806
  loop2831_redo:
    .const 'Sub' $P2813 = "428_1304277427.017" 
    capture_lex $P2813
    $P2813($P2811)
  loop2831_next:
    goto loop2831_test
  loop2831_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2833, exception, 'type'
    eq $P2833, .CONTROL_LOOP_NEXT, loop2831_next
    eq $P2833, .CONTROL_LOOP_REDO, loop2831_redo
  loop2831_done:
    pop_eh 
  for_undef_1560:
.annotate 'line', 2154
    .return (0)
  control_2802:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2834, exception, "payload"
    .return ($P2834)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2812"  :anon :subid("428_1304277427.017") :outer("427_1304277427.017")
    .param pmc param_2815
.annotate 'line', 2156
    $P2814 = root_new ['parrot';'Hash']
    .lex "%sym", $P2814
    .lex "$_", param_2815
    find_lex $P2816, "$_"
    unless_null $P2816, vivify_1561
    new $P2816, "Undef"
  vivify_1561:
    find_lex $P2817, "$name"
    unless_null $P2817, vivify_1562
    new $P2817, "Undef"
  vivify_1562:
    $P2818 = $P2816."symbol"($P2817)
    store_lex "%sym", $P2818
.annotate 'line', 2157
    find_lex $P2821, "%sym"
    unless_null $P2821, vivify_1563
    $P2821 = root_new ['parrot';'Hash']
  vivify_1563:
    set $N2822, $P2821
    if $N2822, if_2820
    new $P2819, 'Float'
    set $P2819, $N2822
    goto if_2820_end
  if_2820:
.annotate 'line', 2158
    new $P2823, "Exception"
    set $P2823['type'], .CONTROL_RETURN
    find_lex $P2824, "%sym"
    unless_null $P2824, vivify_1564
    $P2824 = root_new ['parrot';'Hash']
  vivify_1564:
    set $P2825, $P2824["scope"]
    unless_null $P2825, vivify_1565
    new $P2825, "Undef"
  vivify_1565:
    set $S2826, $P2825
    find_lex $P2827, "$wanted_scope"
    unless_null $P2827, vivify_1566
    new $P2827, "Undef"
  vivify_1566:
    set $S2828, $P2827
    iseq $I2829, $S2826, $S2828
    new $P2830, 'Integer'
    set $P2830, $I2829
    setattribute $P2823, 'payload', $P2830
    throw $P2823
  if_2820_end:
.annotate 'line', 2155
    .return ($P2819)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("429_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2839
    .param pmc param_2840
.annotate 'line', 2177
    .const 'Sub' $P2934 = "434_1304277427.017" 
    capture_lex $P2934
    .const 'Sub' $P2894 = "432_1304277427.017" 
    capture_lex $P2894
    .const 'Sub' $P2852 = "430_1304277427.017" 
    capture_lex $P2852
    new $P2838, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2838, control_2837
    push_eh $P2838
    .lex "@name", param_2839
    .lex "$/", param_2840
.annotate 'line', 2201
    new $P2841, "Undef"
    .lex "$result", $P2841
.annotate 'line', 2179
    find_lex $P2843, "@name"
    unless_null $P2843, vivify_1567
    $P2843 = root_new ['parrot';'ResizablePMCArray']
  vivify_1567:
    set $N2844, $P2843
    if $N2844, unless_2842_end
    find_lex $P2845, "$/"
    unless_null $P2845, vivify_1568
    new $P2845, "Undef"
  vivify_1568:
    $P2846 = $P2845."CURSOR"()
    $P2846."panic"("Cannot look up empty name")
  unless_2842_end:
.annotate 'line', 2183
    find_lex $P2848, "@name"
    unless_null $P2848, vivify_1569
    $P2848 = root_new ['parrot';'ResizablePMCArray']
  vivify_1569:
    set $N2849, $P2848
    iseq $I2850, $N2849, 1.0
    unless $I2850, if_2847_end
    .const 'Sub' $P2852 = "430_1304277427.017" 
    capture_lex $P2852
    $P2852()
  if_2847_end:
.annotate 'line', 2201
    find_dynamic_lex $P2888, "$*GLOBALish"
    unless_null $P2888, vivify_1581
    get_hll_global $P2886, "GLOBAL"
    get_who $P2887, $P2886
    set $P2888, $P2887["$GLOBALish"]
    unless_null $P2888, vivify_1582
    die "Contextual $*GLOBALish not found"
  vivify_1582:
  vivify_1581:
    store_lex "$result", $P2888
.annotate 'line', 2202
    find_lex $P2890, "@name"
    unless_null $P2890, vivify_1583
    $P2890 = root_new ['parrot';'ResizablePMCArray']
  vivify_1583:
    set $N2891, $P2890
    isge $I2892, $N2891, 2.0
    unless $I2892, if_2889_end
    .const 'Sub' $P2894 = "432_1304277427.017" 
    capture_lex $P2894
    $P2894()
  if_2889_end:
.annotate 'line', 2220
    find_lex $P2930, "@name"
    unless_null $P2930, vivify_1596
    $P2930 = root_new ['parrot';'ResizablePMCArray']
  vivify_1596:
    defined $I2931, $P2930
    unless $I2931, for_undef_1597
    iter $P2929, $P2930
    new $P2952, 'ExceptionHandler'
    set_label $P2952, loop2951_handler
    $P2952."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2952
  loop2951_test:
    unless $P2929, loop2951_done
    shift $P2932, $P2929
  loop2951_redo:
    .const 'Sub' $P2934 = "434_1304277427.017" 
    capture_lex $P2934
    $P2934($P2932)
  loop2951_next:
    goto loop2951_test
  loop2951_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2953, exception, 'type'
    eq $P2953, .CONTROL_LOOP_NEXT, loop2951_next
    eq $P2953, .CONTROL_LOOP_REDO, loop2951_redo
  loop2951_done:
    pop_eh 
  for_undef_1597:
    find_lex $P2954, "$result"
    unless_null $P2954, vivify_1604
    new $P2954, "Undef"
  vivify_1604:
.annotate 'line', 2177
    .return ($P2954)
  control_2837:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2955, exception, "payload"
    .return ($P2955)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2851"  :anon :subid("430_1304277427.017") :outer("429_1304277427.017")
.annotate 'line', 2183
    .const 'Sub' $P2863 = "431_1304277427.017" 
    capture_lex $P2863
.annotate 'line', 2184
    new $P2853, "Undef"
    .lex "$final_name", $P2853
    find_lex $P2854, "@name"
    unless_null $P2854, vivify_1570
    $P2854 = root_new ['parrot';'ResizablePMCArray']
  vivify_1570:
    set $P2855, $P2854[0]
    unless_null $P2855, vivify_1571
    new $P2855, "Undef"
  vivify_1571:
    store_lex "$final_name", $P2855
.annotate 'line', 2185
    find_lex $P2857, "$?PACKAGE"
    get_who $P2858, $P2857
    set $P2859, $P2858["@BLOCK"]
    unless_null $P2859, vivify_1572
    $P2859 = root_new ['parrot';'ResizablePMCArray']
  vivify_1572:
    defined $I2860, $P2859
    unless $I2860, for_undef_1573
    iter $P2856, $P2859
    new $P2884, 'ExceptionHandler'
    set_label $P2884, loop2883_handler
    $P2884."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2884
  loop2883_test:
    unless $P2856, loop2883_done
    shift $P2861, $P2856
  loop2883_redo:
    .const 'Sub' $P2863 = "431_1304277427.017" 
    capture_lex $P2863
    $P2863($P2861)
  loop2883_next:
    goto loop2883_test
  loop2883_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2885, exception, 'type'
    eq $P2885, .CONTROL_LOOP_NEXT, loop2883_next
    eq $P2885, .CONTROL_LOOP_REDO, loop2883_redo
  loop2883_done:
    pop_eh 
  for_undef_1573:
.annotate 'line', 2183
    .return ($P2856)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2862"  :anon :subid("431_1304277427.017") :outer("430_1304277427.017")
    .param pmc param_2865
.annotate 'line', 2186
    $P2864 = root_new ['parrot';'Hash']
    .lex "%sym", $P2864
    .lex "$_", param_2865
    find_lex $P2866, "$_"
    unless_null $P2866, vivify_1574
    new $P2866, "Undef"
  vivify_1574:
    find_lex $P2867, "$final_name"
    unless_null $P2867, vivify_1575
    new $P2867, "Undef"
  vivify_1575:
    $P2868 = $P2866."symbol"($P2867)
    store_lex "%sym", $P2868
.annotate 'line', 2187
    find_lex $P2871, "%sym"
    unless_null $P2871, vivify_1576
    $P2871 = root_new ['parrot';'Hash']
  vivify_1576:
    set $N2872, $P2871
    if $N2872, if_2870
    new $P2869, 'Float'
    set $P2869, $N2872
    goto if_2870_end
  if_2870:
.annotate 'line', 2188
    find_lex $P2875, "%sym"
    unless_null $P2875, vivify_1577
    $P2875 = root_new ['parrot';'Hash']
  vivify_1577:
    exists $I2876, $P2875["value"]
    if $I2876, if_2874
.annotate 'line', 2192
    new $P2880, 'String'
    set $P2880, "No compile-time value for "
    find_lex $P2881, "$final_name"
    unless_null $P2881, vivify_1578
    new $P2881, "Undef"
  vivify_1578:
    concat $P2882, $P2880, $P2881
    die $P2882
.annotate 'line', 2191
    goto if_2874_end
  if_2874:
.annotate 'line', 2189
    new $P2877, "Exception"
    set $P2877['type'], .CONTROL_RETURN
    find_lex $P2878, "%sym"
    unless_null $P2878, vivify_1579
    $P2878 = root_new ['parrot';'Hash']
  vivify_1579:
    set $P2879, $P2878["value"]
    unless_null $P2879, vivify_1580
    new $P2879, "Undef"
  vivify_1580:
    setattribute $P2877, 'payload', $P2879
    throw $P2877
  if_2874_end:
.annotate 'line', 2187
    set $P2869, $P2873
  if_2870_end:
.annotate 'line', 2185
    .return ($P2869)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2893"  :anon :subid("432_1304277427.017") :outer("429_1304277427.017")
.annotate 'line', 2202
    .const 'Sub' $P2905 = "433_1304277427.017" 
    capture_lex $P2905
.annotate 'line', 2203
    new $P2895, "Undef"
    .lex "$first", $P2895
    find_lex $P2896, "@name"
    unless_null $P2896, vivify_1584
    $P2896 = root_new ['parrot';'ResizablePMCArray']
  vivify_1584:
    set $P2897, $P2896[0]
    unless_null $P2897, vivify_1585
    new $P2897, "Undef"
  vivify_1585:
    store_lex "$first", $P2897
.annotate 'line', 2204
    find_lex $P2899, "$?PACKAGE"
    get_who $P2900, $P2899
    set $P2901, $P2900["@BLOCK"]
    unless_null $P2901, vivify_1586
    $P2901 = root_new ['parrot';'ResizablePMCArray']
  vivify_1586:
    defined $I2902, $P2901
    unless $I2902, for_undef_1587
    iter $P2898, $P2901
    new $P2927, 'ExceptionHandler'
    set_label $P2927, loop2926_handler
    $P2927."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2927
  loop2926_test:
    unless $P2898, loop2926_done
    shift $P2903, $P2898
  loop2926_redo:
    .const 'Sub' $P2905 = "433_1304277427.017" 
    capture_lex $P2905
    $P2905($P2903)
  loop2926_next:
    goto loop2926_test
  loop2926_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2928, exception, 'type'
    eq $P2928, .CONTROL_LOOP_NEXT, loop2926_next
    eq $P2928, .CONTROL_LOOP_REDO, loop2926_redo
  loop2926_done:
    pop_eh 
  for_undef_1587:
.annotate 'line', 2202
    .return ($P2898)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2904"  :anon :subid("433_1304277427.017") :outer("432_1304277427.017")
    .param pmc param_2907
.annotate 'line', 2205
    $P2906 = root_new ['parrot';'Hash']
    .lex "%sym", $P2906
    .lex "$_", param_2907
    find_lex $P2908, "$_"
    unless_null $P2908, vivify_1588
    new $P2908, "Undef"
  vivify_1588:
    find_lex $P2909, "$first"
    unless_null $P2909, vivify_1589
    new $P2909, "Undef"
  vivify_1589:
    $P2910 = $P2908."symbol"($P2909)
    store_lex "%sym", $P2910
.annotate 'line', 2206
    find_lex $P2913, "%sym"
    unless_null $P2913, vivify_1590
    $P2913 = root_new ['parrot';'Hash']
  vivify_1590:
    set $N2914, $P2913
    if $N2914, if_2912
    new $P2911, 'Float'
    set $P2911, $N2914
    goto if_2912_end
  if_2912:
.annotate 'line', 2207
    find_lex $P2917, "%sym"
    unless_null $P2917, vivify_1591
    $P2917 = root_new ['parrot';'Hash']
  vivify_1591:
    exists $I2918, $P2917["value"]
    if $I2918, if_2916
.annotate 'line', 2213
    new $P2923, 'String'
    set $P2923, "No compile-time value for "
    find_lex $P2924, "$first"
    unless_null $P2924, vivify_1592
    new $P2924, "Undef"
  vivify_1592:
    concat $P2925, $P2923, $P2924
    die $P2925
.annotate 'line', 2212
    goto if_2916_end
  if_2916:
.annotate 'line', 2208
    find_lex $P2919, "%sym"
    unless_null $P2919, vivify_1593
    $P2919 = root_new ['parrot';'Hash']
  vivify_1593:
    set $P2920, $P2919["value"]
    unless_null $P2920, vivify_1594
    new $P2920, "Undef"
  vivify_1594:
    store_lex "$result", $P2920
.annotate 'line', 2209
    find_lex $P2921, "@name"
    unless_null $P2921, vivify_1595
    $P2921 = root_new ['parrot';'ResizablePMCArray']
  vivify_1595:
    $P2921."shift"()
.annotate 'line', 2210
    set $I2922, .CONTROL_LOOP_LAST
    die 0, $I2922
  if_2916_end:
.annotate 'line', 2206
    set $P2911, $P2915
  if_2912_end:
.annotate 'line', 2204
    .return ($P2911)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2933"  :anon :subid("434_1304277427.017") :outer("429_1304277427.017")
    .param pmc param_2935
.annotate 'line', 2220
    .lex "$_", param_2935
.annotate 'line', 2221
    find_lex $P2940, "$_"
    unless_null $P2940, vivify_1598
    new $P2940, "Undef"
  vivify_1598:
    set $S2941, $P2940
    find_lex $P2938, "$result"
    unless_null $P2938, vivify_1599
    new $P2938, "Undef"
  vivify_1599:
    get_who $P2939, $P2938
    exists $I2942, $P2939[$S2941]
    if $I2942, if_2937
.annotate 'line', 2225
    new $P2947, "String"
    assign $P2947, "Could not locate compile-time value for symbol "
.annotate 'line', 2226
    find_lex $P2948, "@name"
    unless_null $P2948, vivify_1600
    $P2948 = root_new ['parrot';'ResizablePMCArray']
  vivify_1600:
    join $S2949, "::", $P2948
    concat $P2950, $P2947, $S2949
.annotate 'line', 2225
    die $P2950
.annotate 'line', 2224
    goto if_2937_end
  if_2937:
.annotate 'line', 2222
    find_lex $P2943, "$_"
    unless_null $P2943, vivify_1601
    new $P2943, "Undef"
  vivify_1601:
    find_lex $P2944, "$result"
    unless_null $P2944, vivify_1602
    new $P2944, "Undef"
  vivify_1602:
    get_who $P2945, $P2944
    set $P2946, $P2945[$P2943]
    unless_null $P2946, vivify_1603
    new $P2946, "Undef"
  vivify_1603:
    store_lex "$result", $P2946
.annotate 'line', 2221
    set $P2936, $P2946
  if_2937_end:
.annotate 'line', 2220
    .return ($P2936)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("435_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2966
    .param pmc param_2967
.annotate 'line', 802
    .lex "self", param_2966
    .lex "$/", param_2967
    find_lex $P2968, "$/"
    find_lex $P2969, "$/"
    unless_null $P2969, vivify_1605
    $P2969 = root_new ['parrot';'Hash']
  vivify_1605:
    set $P2970, $P2969["comp_unit"]
    unless_null $P2970, vivify_1606
    new $P2970, "Undef"
  vivify_1606:
    $P2971 = $P2970."ast"()
    $P2972 = $P2968."!make"($P2971)
    .return ($P2972)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("436_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_2974
    .param pmc param_2975
.annotate 'line', 804
    .lex "self", param_2974
    .lex "$/", param_2975
.annotate 'line', 805
    find_lex $P2976, "$/"
.annotate 'line', 806
    find_lex $P2979, "$/"
    unless_null $P2979, vivify_1607
    $P2979 = root_new ['parrot';'Hash']
  vivify_1607:
    set $P2980, $P2979["colonpair"]
    unless_null $P2980, vivify_1608
    new $P2980, "Undef"
  vivify_1608:
    if $P2980, if_2978
.annotate 'line', 808
    find_lex $P3000, "$/"
    unless_null $P3000, vivify_1609
    new $P3000, "Undef"
  vivify_1609:
    set $S3001, $P3000
    new $P2977, 'String'
    set $P2977, $S3001
.annotate 'line', 806
    goto if_2978_end
  if_2978:
    find_lex $P2981, "$/"
    unless_null $P2981, vivify_1610
    $P2981 = root_new ['parrot';'Hash']
  vivify_1610:
    set $P2982, $P2981["identifier"]
    unless_null $P2982, vivify_1611
    new $P2982, "Undef"
  vivify_1611:
    set $S2983, $P2982
    new $P2984, 'String'
    set $P2984, $S2983
    concat $P2985, $P2984, ":"
    find_lex $P2986, "$/"
    unless_null $P2986, vivify_1612
    $P2986 = root_new ['parrot';'Hash']
  vivify_1612:
    set $P2987, $P2986["colonpair"]
    unless_null $P2987, vivify_1613
    $P2987 = root_new ['parrot';'ResizablePMCArray']
  vivify_1613:
    set $P2988, $P2987[0]
    unless_null $P2988, vivify_1614
    new $P2988, "Undef"
  vivify_1614:
    $P2989 = $P2988."ast"()
    $S2990 = $P2989."named"()
    concat $P2991, $P2985, $S2990
    concat $P2992, $P2991, "<"
.annotate 'line', 807
    find_lex $P2993, "$/"
    unless_null $P2993, vivify_1615
    $P2993 = root_new ['parrot';'Hash']
  vivify_1615:
    set $P2994, $P2993["colonpair"]
    unless_null $P2994, vivify_1616
    $P2994 = root_new ['parrot';'ResizablePMCArray']
  vivify_1616:
    set $P2995, $P2994[0]
    unless_null $P2995, vivify_1617
    new $P2995, "Undef"
  vivify_1617:
    $P2996 = $P2995."ast"()
    $S2997 = "colonpair_str"($P2996)
    concat $P2998, $P2992, $S2997
    concat $P2999, $P2998, ">"
    set $P2977, $P2999
  if_2978_end:
.annotate 'line', 806
    $P3002 = $P2976."!make"($P2977)
.annotate 'line', 804
    .return ($P3002)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("437_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3005
    .param pmc param_3006
.annotate 'line', 818
    .lex "self", param_3005
    .lex "$/", param_3006
.annotate 'line', 819
    new $P3007, "Undef"
    .lex "$mainline", $P3007
.annotate 'line', 820
    new $P3008, "Undef"
    .lex "$unit", $P3008
.annotate 'line', 819
    find_lex $P3009, "$/"
    unless_null $P3009, vivify_1618
    $P3009 = root_new ['parrot';'Hash']
  vivify_1618:
    set $P3010, $P3009["statementlist"]
    unless_null $P3010, vivify_1619
    new $P3010, "Undef"
  vivify_1619:
    $P3011 = $P3010."ast"()
    store_lex "$mainline", $P3011
.annotate 'line', 820
    find_lex $P3012, "$?PACKAGE"
    get_who $P3013, $P3012
    set $P3014, $P3013["@BLOCK"]
    unless_null $P3014, vivify_1620
    $P3014 = root_new ['parrot';'ResizablePMCArray']
  vivify_1620:
    $P3015 = $P3014."shift"()
    store_lex "$unit", $P3015
.annotate 'line', 824
    find_lex $P3016, "$unit"
    unless_null $P3016, vivify_1621
    new $P3016, "Undef"
  vivify_1621:
    $P3017 = $P3016."loadinit"()
    find_dynamic_lex $P3020, "$*SC"
    unless_null $P3020, vivify_1622
    get_hll_global $P3018, "GLOBAL"
    get_who $P3019, $P3018
    set $P3020, $P3019["$SC"]
    unless_null $P3020, vivify_1623
    die "Contextual $*SC not found"
  vivify_1623:
  vivify_1622:
    $P3021 = $P3020."to_past"()
    $P3017."push"($P3021)
.annotate 'line', 829
    find_lex $P3022, "$unit"
    unless_null $P3022, vivify_1624
    new $P3022, "Undef"
  vivify_1624:
    $P3023 = $P3022."loadinit"()
    get_hll_global $P3024, "GLOBAL"
    nqp_get_package_through_who $P3025, $P3024, "PAST"
    get_who $P3026, $P3025
    set $P3027, $P3026["Op"]
.annotate 'line', 831
    get_hll_global $P3028, "GLOBAL"
    nqp_get_package_through_who $P3029, $P3028, "PAST"
    get_who $P3030, $P3029
    set $P3031, $P3030["Var"]
    new $P3032, "ResizablePMCArray"
    $P3033 = $P3031."new"("GLOBAL" :named("name"), $P3032 :named("namespace"), "package" :named("scope"))
.annotate 'line', 832
    find_dynamic_lex $P3036, "$*SC"
    unless_null $P3036, vivify_1625
    get_hll_global $P3034, "GLOBAL"
    get_who $P3035, $P3034
    set $P3036, $P3035["$SC"]
    unless_null $P3036, vivify_1626
    die "Contextual $*SC not found"
  vivify_1626:
  vivify_1625:
    find_dynamic_lex $P3039, "$*PACKAGE"
    unless_null $P3039, vivify_1627
    get_hll_global $P3037, "GLOBAL"
    get_who $P3038, $P3037
    set $P3039, $P3038["$PACKAGE"]
    unless_null $P3039, vivify_1628
    die "Contextual $*PACKAGE not found"
  vivify_1628:
  vivify_1627:
    $P3040 = $P3036."get_slot_past_for_object"($P3039)
    $P3041 = $P3027."new"($P3033, $P3040, "bind" :named("pasttype"))
.annotate 'line', 829
    $P3023."push"($P3041)
.annotate 'line', 838
    find_dynamic_lex $P3045, "$*HAS_YOU_ARE_HERE"
    unless_null $P3045, vivify_1629
    get_hll_global $P3043, "GLOBAL"
    get_who $P3044, $P3043
    set $P3045, $P3044["$HAS_YOU_ARE_HERE"]
    unless_null $P3045, vivify_1630
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1630:
  vivify_1629:
    if $P3045, unless_3042_end
.annotate 'line', 839
    find_lex $P3046, "$unit"
    unless_null $P3046, vivify_1631
    new $P3046, "Undef"
  vivify_1631:
    find_lex $P3047, "self"
    $P3048 = $P3047."CTXSAVE"()
    $P3046."push"($P3048)
  unless_3042_end:
.annotate 'line', 843
    find_lex $P3049, "$unit"
    unless_null $P3049, vivify_1632
    new $P3049, "Undef"
  vivify_1632:
    $P3049."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 847
    find_dynamic_lex $P3053, "$*MAIN_SUB"
    unless_null $P3053, vivify_1633
    get_hll_global $P3051, "GLOBAL"
    get_who $P3052, $P3051
    set $P3053, $P3052["$MAIN_SUB"]
    unless_null $P3053, vivify_1634
    die "Contextual $*MAIN_SUB not found"
  vivify_1634:
  vivify_1633:
    unless $P3053, if_3050_end
.annotate 'line', 848
    find_lex $P3054, "$unit"
    unless_null $P3054, vivify_1635
    new $P3054, "Undef"
  vivify_1635:
    get_hll_global $P3055, "GLOBAL"
    nqp_get_package_through_who $P3056, $P3055, "PAST"
    get_who $P3057, $P3056
    set $P3058, $P3057["Var"]
    $P3059 = $P3058."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3054."unshift"($P3059)
.annotate 'line', 849
    find_lex $P3060, "$mainline"
    unless_null $P3060, vivify_1636
    new $P3060, "Undef"
  vivify_1636:
    get_hll_global $P3061, "GLOBAL"
    nqp_get_package_through_who $P3062, $P3061, "PAST"
    get_who $P3063, $P3062
    set $P3064, $P3063["Op"]
.annotate 'line', 851
    get_hll_global $P3065, "GLOBAL"
    nqp_get_package_through_who $P3066, $P3065, "PAST"
    get_who $P3067, $P3066
    set $P3068, $P3067["Var"]
    $P3069 = $P3068."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 852
    get_hll_global $P3070, "GLOBAL"
    nqp_get_package_through_who $P3071, $P3070, "PAST"
    get_who $P3072, $P3071
    set $P3073, $P3072["Op"]
.annotate 'line', 853
    get_hll_global $P3074, "GLOBAL"
    nqp_get_package_through_who $P3075, $P3074, "PAST"
    get_who $P3076, $P3075
    set $P3077, $P3076["Val"]
    find_dynamic_lex $P3080, "$*MAIN_SUB"
    unless_null $P3080, vivify_1637
    get_hll_global $P3078, "GLOBAL"
    get_who $P3079, $P3078
    set $P3080, $P3079["$MAIN_SUB"]
    unless_null $P3080, vivify_1638
    die "Contextual $*MAIN_SUB not found"
  vivify_1638:
  vivify_1637:
    $P3081 = $P3077."new"($P3080 :named("value"))
.annotate 'line', 854
    get_hll_global $P3082, "GLOBAL"
    nqp_get_package_through_who $P3083, $P3082, "PAST"
    get_who $P3084, $P3083
    set $P3085, $P3084["Var"]
    $P3086 = $P3085."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3087 = $P3073."new"($P3081, $P3086, "call" :named("pasttype"))
.annotate 'line', 852
    $P3088 = $P3064."new"($P3069, $P3087, "if" :named("pasttype"))
.annotate 'line', 849
    $P3060."push"($P3088)
  if_3050_end:
.annotate 'line', 862
    find_lex $P3089, "$unit"
    unless_null $P3089, vivify_1639
    new $P3089, "Undef"
  vivify_1639:
.annotate 'line', 863
    get_hll_global $P3090, "GLOBAL"
    nqp_get_package_through_who $P3091, $P3090, "PAST"
    get_who $P3092, $P3091
    set $P3093, $P3092["Op"]
    find_lex $P3094, "$mainline"
    unless_null $P3094, vivify_1640
    new $P3094, "Undef"
  vivify_1640:
    $P3095 = $P3093."new"($P3094, "return" :named("pirop"))
    $P3089."push"($P3095)
.annotate 'line', 868
    find_lex $P3096, "$unit"
    unless_null $P3096, vivify_1641
    new $P3096, "Undef"
  vivify_1641:
.annotate 'line', 869
    get_hll_global $P3097, "GLOBAL"
    nqp_get_package_through_who $P3098, $P3097, "PAST"
    get_who $P3099, $P3098
    set $P3100, $P3099["Block"]
.annotate 'line', 871
    get_hll_global $P3101, "GLOBAL"
    nqp_get_package_through_who $P3102, $P3101, "PAST"
    get_who $P3103, $P3102
    set $P3104, $P3103["Op"]
    get_hll_global $P3105, "GLOBAL"
    nqp_get_package_through_who $P3106, $P3105, "PAST"
    get_who $P3107, $P3106
    set $P3108, $P3107["Val"]
    find_lex $P3109, "$unit"
    unless_null $P3109, vivify_1642
    new $P3109, "Undef"
  vivify_1642:
    $P3110 = $P3108."new"($P3109 :named("value"))
    $P3111 = $P3104."new"($P3110, "call" :named("pasttype"))
    $P3112 = $P3100."new"($P3111, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 869
    $P3096."push"($P3112)
.annotate 'line', 874
    find_lex $P3113, "$unit"
    unless_null $P3113, vivify_1643
    new $P3113, "Undef"
  vivify_1643:
    find_lex $P3114, "$/"
    unless_null $P3114, vivify_1644
    new $P3114, "Undef"
  vivify_1644:
    $P3113."node"($P3114)
.annotate 'line', 877
    find_lex $P3115, "$unit"
    unless_null $P3115, vivify_1645
    new $P3115, "Undef"
  vivify_1645:
    $P3115."hll"("nqp")
.annotate 'line', 879
    find_lex $P3116, "$/"
    find_lex $P3117, "$unit"
    unless_null $P3117, vivify_1646
    new $P3117, "Undef"
  vivify_1646:
    $P3118 = $P3116."!make"($P3117)
.annotate 'line', 818
    .return ($P3118)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("438_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3120
    .param pmc param_3121
.annotate 'line', 882
    .const 'Sub' $P3138 = "439_1304277427.017" 
    capture_lex $P3138
    .lex "self", param_3120
    .lex "$/", param_3121
.annotate 'line', 883
    new $P3122, "Undef"
    .lex "$past", $P3122
    get_hll_global $P3123, "GLOBAL"
    nqp_get_package_through_who $P3124, $P3123, "PAST"
    get_who $P3125, $P3124
    set $P3126, $P3125["Stmts"]
    find_lex $P3127, "$/"
    unless_null $P3127, vivify_1647
    new $P3127, "Undef"
  vivify_1647:
    $P3128 = $P3126."new"($P3127 :named("node"))
    store_lex "$past", $P3128
.annotate 'line', 884
    find_lex $P3130, "$/"
    unless_null $P3130, vivify_1648
    $P3130 = root_new ['parrot';'Hash']
  vivify_1648:
    set $P3131, $P3130["statement"]
    unless_null $P3131, vivify_1649
    new $P3131, "Undef"
  vivify_1649:
    unless $P3131, if_3129_end
.annotate 'line', 885
    find_lex $P3133, "$/"
    unless_null $P3133, vivify_1650
    $P3133 = root_new ['parrot';'Hash']
  vivify_1650:
    set $P3134, $P3133["statement"]
    unless_null $P3134, vivify_1651
    new $P3134, "Undef"
  vivify_1651:
    defined $I3135, $P3134
    unless $I3135, for_undef_1652
    iter $P3132, $P3134
    new $P3158, 'ExceptionHandler'
    set_label $P3158, loop3157_handler
    $P3158."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3158
  loop3157_test:
    unless $P3132, loop3157_done
    shift $P3136, $P3132
  loop3157_redo:
    .const 'Sub' $P3138 = "439_1304277427.017" 
    capture_lex $P3138
    $P3138($P3136)
  loop3157_next:
    goto loop3157_test
  loop3157_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3159, exception, 'type'
    eq $P3159, .CONTROL_LOOP_NEXT, loop3157_next
    eq $P3159, .CONTROL_LOOP_REDO, loop3157_redo
  loop3157_done:
    pop_eh 
  for_undef_1652:
  if_3129_end:
.annotate 'line', 892
    find_lex $P3160, "$/"
    find_lex $P3161, "$past"
    unless_null $P3161, vivify_1663
    new $P3161, "Undef"
  vivify_1663:
    $P3162 = $P3160."!make"($P3161)
.annotate 'line', 882
    .return ($P3162)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3137"  :anon :subid("439_1304277427.017") :outer("438_1304277427.017")
    .param pmc param_3140
.annotate 'line', 886
    new $P3139, "Undef"
    .lex "$ast", $P3139
    .lex "$_", param_3140
    find_lex $P3141, "$_"
    unless_null $P3141, vivify_1653
    new $P3141, "Undef"
  vivify_1653:
    $P3142 = $P3141."ast"()
    store_lex "$ast", $P3142
.annotate 'line', 887
    find_lex $P3144, "$ast"
    unless_null $P3144, vivify_1654
    $P3144 = root_new ['parrot';'Hash']
  vivify_1654:
    set $P3145, $P3144["sink"]
    unless_null $P3145, vivify_1655
    new $P3145, "Undef"
  vivify_1655:
    defined $I3146, $P3145
    unless $I3146, if_3143_end
    find_lex $P3147, "$ast"
    unless_null $P3147, vivify_1656
    $P3147 = root_new ['parrot';'Hash']
  vivify_1656:
    set $P3148, $P3147["sink"]
    unless_null $P3148, vivify_1657
    new $P3148, "Undef"
  vivify_1657:
    store_lex "$ast", $P3148
  if_3143_end:
.annotate 'line', 888
    find_lex $P3150, "$ast"
    unless_null $P3150, vivify_1658
    $P3150 = root_new ['parrot';'Hash']
  vivify_1658:
    set $P3151, $P3150["bareblock"]
    unless_null $P3151, vivify_1659
    new $P3151, "Undef"
  vivify_1659:
    unless $P3151, if_3149_end
    find_lex $P3152, "$ast"
    unless_null $P3152, vivify_1660
    new $P3152, "Undef"
  vivify_1660:
    $P3153 = "block_immediate"($P3152)
    store_lex "$ast", $P3153
  if_3149_end:
.annotate 'line', 889
    find_lex $P3154, "$past"
    unless_null $P3154, vivify_1661
    new $P3154, "Undef"
  vivify_1661:
    find_lex $P3155, "$ast"
    unless_null $P3155, vivify_1662
    new $P3155, "Undef"
  vivify_1662:
    $P3156 = $P3154."push"($P3155)
.annotate 'line', 885
    .return ($P3156)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("440_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3164
    .param pmc param_3165
    .param pmc param_3166 :optional
    .param int has_param_3166 :opt_flag
.annotate 'line', 895
    .const 'Sub' $P3174 = "441_1304277427.017" 
    capture_lex $P3174
    .lex "self", param_3164
    .lex "$/", param_3165
    if has_param_3166, optparam_1664
    new $P3167, "Undef"
    set param_3166, $P3167
  optparam_1664:
    .lex "$key", param_3166
.annotate 'line', 896
    new $P3168, "Undef"
    .lex "$past", $P3168
.annotate 'line', 895
    find_lex $P3169, "$past"
    unless_null $P3169, vivify_1665
    new $P3169, "Undef"
  vivify_1665:
.annotate 'line', 897
    find_lex $P3171, "$/"
    unless_null $P3171, vivify_1666
    $P3171 = root_new ['parrot';'Hash']
  vivify_1666:
    set $P3172, $P3171["EXPR"]
    unless_null $P3172, vivify_1667
    new $P3172, "Undef"
  vivify_1667:
    if $P3172, if_3170
.annotate 'line', 918
    find_lex $P3250, "$/"
    unless_null $P3250, vivify_1668
    $P3250 = root_new ['parrot';'Hash']
  vivify_1668:
    set $P3251, $P3250["statement_control"]
    unless_null $P3251, vivify_1669
    new $P3251, "Undef"
  vivify_1669:
    if $P3251, if_3249
.annotate 'line', 919
    new $P3255, "Integer"
    assign $P3255, 0
    store_lex "$past", $P3255
    goto if_3249_end
  if_3249:
.annotate 'line', 918
    find_lex $P3252, "$/"
    unless_null $P3252, vivify_1670
    $P3252 = root_new ['parrot';'Hash']
  vivify_1670:
    set $P3253, $P3252["statement_control"]
    unless_null $P3253, vivify_1671
    new $P3253, "Undef"
  vivify_1671:
    $P3254 = $P3253."ast"()
    store_lex "$past", $P3254
  if_3249_end:
    goto if_3170_end
  if_3170:
.annotate 'line', 897
    .const 'Sub' $P3174 = "441_1304277427.017" 
    capture_lex $P3174
    $P3174()
  if_3170_end:
.annotate 'line', 920
    find_lex $P3256, "$/"
    find_lex $P3257, "$past"
    unless_null $P3257, vivify_1705
    new $P3257, "Undef"
  vivify_1705:
    $P3258 = $P3256."!make"($P3257)
.annotate 'line', 895
    .return ($P3258)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3173"  :anon :subid("441_1304277427.017") :outer("440_1304277427.017")
.annotate 'line', 898
    new $P3175, "Undef"
    .lex "$mc", $P3175
.annotate 'line', 899
    new $P3176, "Undef"
    .lex "$ml", $P3176
.annotate 'line', 898
    find_lex $P3177, "$/"
    unless_null $P3177, vivify_1672
    $P3177 = root_new ['parrot';'Hash']
  vivify_1672:
    set $P3178, $P3177["statement_mod_cond"]
    unless_null $P3178, vivify_1673
    $P3178 = root_new ['parrot';'ResizablePMCArray']
  vivify_1673:
    set $P3179, $P3178[0]
    unless_null $P3179, vivify_1674
    new $P3179, "Undef"
  vivify_1674:
    store_lex "$mc", $P3179
.annotate 'line', 899
    find_lex $P3180, "$/"
    unless_null $P3180, vivify_1675
    $P3180 = root_new ['parrot';'Hash']
  vivify_1675:
    set $P3181, $P3180["statement_mod_loop"]
    unless_null $P3181, vivify_1676
    $P3181 = root_new ['parrot';'ResizablePMCArray']
  vivify_1676:
    set $P3182, $P3181[0]
    unless_null $P3182, vivify_1677
    new $P3182, "Undef"
  vivify_1677:
    store_lex "$ml", $P3182
.annotate 'line', 900
    find_lex $P3183, "$/"
    unless_null $P3183, vivify_1678
    $P3183 = root_new ['parrot';'Hash']
  vivify_1678:
    set $P3184, $P3183["EXPR"]
    unless_null $P3184, vivify_1679
    new $P3184, "Undef"
  vivify_1679:
    $P3185 = $P3184."ast"()
    store_lex "$past", $P3185
.annotate 'line', 901
    find_lex $P3187, "$mc"
    unless_null $P3187, vivify_1680
    new $P3187, "Undef"
  vivify_1680:
    unless $P3187, if_3186_end
.annotate 'line', 902
    get_hll_global $P3188, "GLOBAL"
    nqp_get_package_through_who $P3189, $P3188, "PAST"
    get_who $P3190, $P3189
    set $P3191, $P3190["Op"]
    find_lex $P3192, "$mc"
    unless_null $P3192, vivify_1681
    $P3192 = root_new ['parrot';'Hash']
  vivify_1681:
    set $P3193, $P3192["cond"]
    unless_null $P3193, vivify_1682
    new $P3193, "Undef"
  vivify_1682:
    $P3194 = $P3193."ast"()
    find_lex $P3195, "$past"
    unless_null $P3195, vivify_1683
    new $P3195, "Undef"
  vivify_1683:
    find_lex $P3196, "$mc"
    unless_null $P3196, vivify_1684
    $P3196 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P3197, $P3196["sym"]
    unless_null $P3197, vivify_1685
    new $P3197, "Undef"
  vivify_1685:
    set $S3198, $P3197
    find_lex $P3199, "$/"
    unless_null $P3199, vivify_1686
    new $P3199, "Undef"
  vivify_1686:
    $P3200 = $P3191."new"($P3194, $P3195, $S3198 :named("pasttype"), $P3199 :named("node"))
    store_lex "$past", $P3200
  if_3186_end:
.annotate 'line', 904
    find_lex $P3203, "$ml"
    unless_null $P3203, vivify_1687
    new $P3203, "Undef"
  vivify_1687:
    if $P3203, if_3202
    set $P3201, $P3203
    goto if_3202_end
  if_3202:
.annotate 'line', 905
    find_lex $P3206, "$ml"
    unless_null $P3206, vivify_1688
    $P3206 = root_new ['parrot';'Hash']
  vivify_1688:
    set $P3207, $P3206["sym"]
    unless_null $P3207, vivify_1689
    new $P3207, "Undef"
  vivify_1689:
    set $S3208, $P3207
    iseq $I3209, $S3208, "for"
    if $I3209, if_3205
.annotate 'line', 914
    get_hll_global $P3236, "GLOBAL"
    nqp_get_package_through_who $P3237, $P3236, "PAST"
    get_who $P3238, $P3237
    set $P3239, $P3238["Op"]
    find_lex $P3240, "$ml"
    unless_null $P3240, vivify_1690
    $P3240 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P3241, $P3240["cond"]
    unless_null $P3241, vivify_1691
    new $P3241, "Undef"
  vivify_1691:
    $P3242 = $P3241."ast"()
    find_lex $P3243, "$past"
    unless_null $P3243, vivify_1692
    new $P3243, "Undef"
  vivify_1692:
    find_lex $P3244, "$ml"
    unless_null $P3244, vivify_1693
    $P3244 = root_new ['parrot';'Hash']
  vivify_1693:
    set $P3245, $P3244["sym"]
    unless_null $P3245, vivify_1694
    new $P3245, "Undef"
  vivify_1694:
    set $S3246, $P3245
    find_lex $P3247, "$/"
    unless_null $P3247, vivify_1695
    new $P3247, "Undef"
  vivify_1695:
    $P3248 = $P3239."new"($P3242, $P3243, $S3246 :named("pasttype"), $P3247 :named("node"))
    store_lex "$past", $P3248
.annotate 'line', 913
    set $P3204, $P3248
.annotate 'line', 905
    goto if_3205_end
  if_3205:
.annotate 'line', 906
    get_hll_global $P3210, "GLOBAL"
    nqp_get_package_through_who $P3211, $P3210, "PAST"
    get_who $P3212, $P3211
    set $P3213, $P3212["Block"]
.annotate 'line', 907
    get_hll_global $P3214, "GLOBAL"
    nqp_get_package_through_who $P3215, $P3214, "PAST"
    get_who $P3216, $P3215
    set $P3217, $P3216["Var"]
    $P3218 = $P3217."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3219, "$past"
    unless_null $P3219, vivify_1696
    new $P3219, "Undef"
  vivify_1696:
    $P3220 = $P3213."new"($P3218, $P3219, "immediate" :named("blocktype"))
.annotate 'line', 906
    store_lex "$past", $P3220
.annotate 'line', 909
    find_lex $P3221, "$past"
    unless_null $P3221, vivify_1697
    new $P3221, "Undef"
  vivify_1697:
    $P3221."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 910
    find_lex $P3222, "$past"
    unless_null $P3222, vivify_1698
    new $P3222, "Undef"
  vivify_1698:
    $P3222."arity"(1)
.annotate 'line', 911
    get_hll_global $P3223, "GLOBAL"
    nqp_get_package_through_who $P3224, $P3223, "PAST"
    get_who $P3225, $P3224
    set $P3226, $P3225["Op"]
    find_lex $P3227, "$ml"
    unless_null $P3227, vivify_1699
    $P3227 = root_new ['parrot';'Hash']
  vivify_1699:
    set $P3228, $P3227["cond"]
    unless_null $P3228, vivify_1700
    new $P3228, "Undef"
  vivify_1700:
    $P3229 = $P3228."ast"()
    find_lex $P3230, "$past"
    unless_null $P3230, vivify_1701
    new $P3230, "Undef"
  vivify_1701:
    find_lex $P3231, "$ml"
    unless_null $P3231, vivify_1702
    $P3231 = root_new ['parrot';'Hash']
  vivify_1702:
    set $P3232, $P3231["sym"]
    unless_null $P3232, vivify_1703
    new $P3232, "Undef"
  vivify_1703:
    set $S3233, $P3232
    find_lex $P3234, "$/"
    unless_null $P3234, vivify_1704
    new $P3234, "Undef"
  vivify_1704:
    $P3235 = $P3226."new"($P3229, $P3230, $S3233 :named("pasttype"), $P3234 :named("node"))
    store_lex "$past", $P3235
.annotate 'line', 905
    set $P3204, $P3235
  if_3205_end:
.annotate 'line', 904
    set $P3201, $P3204
  if_3202_end:
.annotate 'line', 897
    .return ($P3201)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("442_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3260
    .param pmc param_3261
.annotate 'line', 923
    .lex "self", param_3260
    .lex "$/", param_3261
.annotate 'line', 924
    find_lex $P3262, "$/"
    get_hll_global $P3263, "GLOBAL"
    nqp_get_package_through_who $P3264, $P3263, "PAST"
    get_who $P3265, $P3264
    set $P3266, $P3265["Op"]
    find_lex $P3267, "$/"
    unless_null $P3267, vivify_1706
    $P3267 = root_new ['parrot';'Hash']
  vivify_1706:
    set $P3268, $P3267["EXPR"]
    unless_null $P3268, vivify_1707
    new $P3268, "Undef"
  vivify_1707:
    $P3269 = $P3268."ast"()
    find_lex $P3270, "$/"
    unless_null $P3270, vivify_1708
    $P3270 = root_new ['parrot';'Hash']
  vivify_1708:
    set $P3271, $P3270["pblock"]
    unless_null $P3271, vivify_1709
    new $P3271, "Undef"
  vivify_1709:
    $P3272 = $P3271."ast"()
    find_lex $P3273, "$/"
    unless_null $P3273, vivify_1710
    new $P3273, "Undef"
  vivify_1710:
    $P3274 = $P3266."new"($P3269, $P3272, "if" :named("pasttype"), $P3273 :named("node"))
    $P3275 = $P3262."!make"($P3274)
.annotate 'line', 923
    .return ($P3275)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("443_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3277
    .param pmc param_3278
.annotate 'line', 927
    .lex "self", param_3277
    .lex "$/", param_3278
.annotate 'line', 928
    find_lex $P3279, "$/"
    find_lex $P3280, "$/"
    unless_null $P3280, vivify_1711
    $P3280 = root_new ['parrot';'Hash']
  vivify_1711:
    set $P3281, $P3280["blockoid"]
    unless_null $P3281, vivify_1712
    new $P3281, "Undef"
  vivify_1712:
    $P3282 = $P3281."ast"()
    $P3283 = $P3279."!make"($P3282)
.annotate 'line', 927
    .return ($P3283)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("444_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3285
    .param pmc param_3286
.annotate 'line', 931
    .lex "self", param_3285
    .lex "$/", param_3286
.annotate 'line', 932
    find_lex $P3287, "$/"
    find_lex $P3288, "$/"
    unless_null $P3288, vivify_1713
    $P3288 = root_new ['parrot';'Hash']
  vivify_1713:
    set $P3289, $P3288["blockoid"]
    unless_null $P3289, vivify_1714
    new $P3289, "Undef"
  vivify_1714:
    $P3290 = $P3289."ast"()
    $P3291 = $P3287."!make"($P3290)
.annotate 'line', 931
    .return ($P3291)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("445_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3293
    .param pmc param_3294
.annotate 'line', 935
    .const 'Sub' $P3305 = "446_1304277427.017" 
    capture_lex $P3305
    .lex "self", param_3293
    .lex "$/", param_3294
.annotate 'line', 936
    new $P3295, "Undef"
    .lex "$BLOCK", $P3295
    find_lex $P3296, "$?PACKAGE"
    get_who $P3297, $P3296
    set $P3298, $P3297["@BLOCK"]
    unless_null $P3298, vivify_1715
    $P3298 = root_new ['parrot';'ResizablePMCArray']
  vivify_1715:
    $P3299 = $P3298."shift"()
    store_lex "$BLOCK", $P3299
.annotate 'line', 937
    find_lex $P3302, "$/"
    unless_null $P3302, vivify_1716
    $P3302 = root_new ['parrot';'Hash']
  vivify_1716:
    set $P3303, $P3302["statementlist"]
    unless_null $P3303, vivify_1717
    new $P3303, "Undef"
  vivify_1717:
    if $P3303, if_3301
.annotate 'line', 945
    find_dynamic_lex $P3322, "$*HAS_YOU_ARE_HERE"
    unless_null $P3322, vivify_1718
    get_hll_global $P3320, "GLOBAL"
    get_who $P3321, $P3320
    set $P3322, $P3321["$HAS_YOU_ARE_HERE"]
    unless_null $P3322, vivify_1719
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1719:
  vivify_1718:
    unless $P3322, if_3319_end
.annotate 'line', 946
    find_lex $P3323, "$/"
    unless_null $P3323, vivify_1720
    new $P3323, "Undef"
  vivify_1720:
    $P3324 = $P3323."CURSOR"()
    $P3324."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3319_end:
.annotate 'line', 948
    new $P3325, "Integer"
    assign $P3325, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3325
.annotate 'line', 949
    find_lex $P3326, "$/"
    find_lex $P3327, "$/"
    unless_null $P3327, vivify_1721
    $P3327 = root_new ['parrot';'Hash']
  vivify_1721:
    set $P3328, $P3327["you_are_here"]
    unless_null $P3328, vivify_1722
    new $P3328, "Undef"
  vivify_1722:
    $P3329 = $P3328."ast"()
    $P3330 = $P3326."!make"($P3329)
.annotate 'line', 944
    set $P3300, $P3330
.annotate 'line', 937
    goto if_3301_end
  if_3301:
    .const 'Sub' $P3305 = "446_1304277427.017" 
    capture_lex $P3305
    $P3318 = $P3305()
    set $P3300, $P3318
  if_3301_end:
.annotate 'line', 935
    .return ($P3300)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3304"  :anon :subid("446_1304277427.017") :outer("445_1304277427.017")
.annotate 'line', 938
    new $P3306, "Undef"
    .lex "$past", $P3306
    find_lex $P3307, "$/"
    unless_null $P3307, vivify_1723
    $P3307 = root_new ['parrot';'Hash']
  vivify_1723:
    set $P3308, $P3307["statementlist"]
    unless_null $P3308, vivify_1724
    new $P3308, "Undef"
  vivify_1724:
    $P3309 = $P3308."ast"()
    store_lex "$past", $P3309
.annotate 'line', 939
    find_lex $P3310, "$BLOCK"
    unless_null $P3310, vivify_1725
    new $P3310, "Undef"
  vivify_1725:
    find_lex $P3311, "$past"
    unless_null $P3311, vivify_1726
    new $P3311, "Undef"
  vivify_1726:
    $P3310."push"($P3311)
.annotate 'line', 940
    find_lex $P3312, "$BLOCK"
    unless_null $P3312, vivify_1727
    new $P3312, "Undef"
  vivify_1727:
    find_lex $P3313, "$/"
    unless_null $P3313, vivify_1728
    new $P3313, "Undef"
  vivify_1728:
    $P3312."node"($P3313)
.annotate 'line', 941
    find_lex $P3314, "$BLOCK"
    unless_null $P3314, vivify_1729
    new $P3314, "Undef"
  vivify_1729:
    $P3314."closure"(1)
.annotate 'line', 942
    find_dynamic_lex $P3315, "$/"
    find_lex $P3316, "$BLOCK"
    unless_null $P3316, vivify_1730
    new $P3316, "Undef"
  vivify_1730:
    $P3317 = $P3315."!make"($P3316)
.annotate 'line', 937
    .return ($P3317)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("447_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3332
    .param pmc param_3333
.annotate 'line', 953
    .lex "self", param_3332
    .lex "$/", param_3333
.annotate 'line', 954
    find_lex $P3334, "$?PACKAGE"
    get_who $P3335, $P3334
    set $P3336, $P3335["@BLOCK"]
    unless_null $P3336, vivify_1731
    $P3336 = root_new ['parrot';'ResizablePMCArray']
  vivify_1731:
    get_hll_global $P3337, "GLOBAL"
    nqp_get_package_through_who $P3338, $P3337, "PAST"
    get_who $P3339, $P3338
    set $P3340, $P3339["Block"]
    get_hll_global $P3341, "GLOBAL"
    nqp_get_package_through_who $P3342, $P3341, "PAST"
    get_who $P3343, $P3342
    set $P3344, $P3343["Stmts"]
    $P3345 = $P3344."new"()
    $P3346 = $P3340."new"($P3345)
    $P3347 = $P3336."unshift"($P3346)
.annotate 'line', 953
    .return ($P3347)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("448_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3349
    .param pmc param_3350
.annotate 'line', 957
    .const 'Sub' $P3359 = "449_1304277427.017" 
    capture_lex $P3359
    .lex "self", param_3349
    .lex "$/", param_3350
.annotate 'line', 958
    find_dynamic_lex $P3354, "%*COMPILING"
    unless_null $P3354, vivify_1732
    get_hll_global $P3352, "GLOBAL"
    get_who $P3353, $P3352
    set $P3354, $P3353["%COMPILING"]
    unless_null $P3354, vivify_1733
    die "Contextual %*COMPILING not found"
  vivify_1733:
  vivify_1732:
    set $P3355, $P3354["%?OPTIONS"]
    unless_null $P3355, vivify_1734
    $P3355 = root_new ['parrot';'Hash']
  vivify_1734:
    set $P3356, $P3355["outer_ctx"]
    unless_null $P3356, vivify_1735
    new $P3356, "Undef"
  vivify_1735:
    defined $I3357, $P3356
    if $I3357, unless_3351_end
    .const 'Sub' $P3359 = "449_1304277427.017" 
    capture_lex $P3359
    $P3359()
  unless_3351_end:
.annotate 'line', 971
    find_lex $P3391, "self"
    find_lex $P3392, "$?PACKAGE"
    get_who $P3393, $P3392
    set $P3394, $P3393["@BLOCK"]
    unless_null $P3394, vivify_1751
    $P3394 = root_new ['parrot';'ResizablePMCArray']
  vivify_1751:
    set $P3395, $P3394[0]
    unless_null $P3395, vivify_1752
    new $P3395, "Undef"
  vivify_1752:
    $P3396 = $P3391."SET_BLOCK_OUTER_CTX"($P3395)
.annotate 'line', 957
    .return ($P3396)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3358"  :anon :subid("449_1304277427.017") :outer("448_1304277427.017")
.annotate 'line', 961
    new $P3360, "Undef"
    .lex "$SETTING", $P3360
    find_dynamic_lex $P3363, "$*SC"
    unless_null $P3363, vivify_1736
    get_hll_global $P3361, "GLOBAL"
    get_who $P3362, $P3361
    set $P3363, $P3362["$SC"]
    unless_null $P3363, vivify_1737
    die "Contextual $*SC not found"
  vivify_1737:
  vivify_1736:
    find_dynamic_lex $P3367, "%*COMPILING"
    unless_null $P3367, vivify_1738
    get_hll_global $P3365, "GLOBAL"
    get_who $P3366, $P3365
    set $P3367, $P3366["%COMPILING"]
    unless_null $P3367, vivify_1739
    die "Contextual %*COMPILING not found"
  vivify_1739:
  vivify_1738:
    set $P3368, $P3367["%?OPTIONS"]
    unless_null $P3368, vivify_1740
    $P3368 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3369, $P3368["setting"]
    unless_null $P3369, vivify_1741
    new $P3369, "Undef"
  vivify_1741:
    set $P3364, $P3369
    defined $I3371, $P3364
    if $I3371, default_3370
    new $P3372, "String"
    assign $P3372, "NQPCORE"
    set $P3364, $P3372
  default_3370:
    $P3373 = $P3363."load_setting"($P3364)
    store_lex "$SETTING", $P3373
.annotate 'line', 966
    find_dynamic_lex $P3378, "%*COMPILING"
    unless_null $P3378, vivify_1742
    get_hll_global $P3376, "GLOBAL"
    get_who $P3377, $P3376
    set $P3378, $P3377["%COMPILING"]
    unless_null $P3378, vivify_1743
    die "Contextual %*COMPILING not found"
  vivify_1743:
  vivify_1742:
    set $P3379, $P3378["%?OPTIONS"]
    unless_null $P3379, vivify_1744
    $P3379 = root_new ['parrot';'Hash']
  vivify_1744:
    set $P3380, $P3379["setting"]
    unless_null $P3380, vivify_1745
    new $P3380, "Undef"
  vivify_1745:
    set $S3381, $P3380
    iseq $I3382, $S3381, "NULL"
    unless $I3382, unless_3375
    new $P3374, 'Integer'
    set $P3374, $I3382
    goto unless_3375_end
  unless_3375:
.annotate 'line', 967
    find_lex $P3383, "$SETTING"
    unless_null $P3383, vivify_1746
    new $P3383, "Undef"
  vivify_1746:
    "import_HOW_exports"($P3383)
.annotate 'line', 968
    find_dynamic_lex $P3386, "$*SC"
    unless_null $P3386, vivify_1747
    get_hll_global $P3384, "GLOBAL"
    get_who $P3385, $P3384
    set $P3386, $P3385["$SC"]
    unless_null $P3386, vivify_1748
    die "Contextual $*SC not found"
  vivify_1748:
  vivify_1747:
    find_dynamic_lex $P3389, "$*GLOBALish"
    unless_null $P3389, vivify_1749
    get_hll_global $P3387, "GLOBAL"
    get_who $P3388, $P3387
    set $P3389, $P3388["$GLOBALish"]
    unless_null $P3389, vivify_1750
    die "Contextual $*GLOBALish not found"
  vivify_1750:
  vivify_1749:
    $P3390 = $P3386."load_module"("Regex", $P3389)
.annotate 'line', 966
    set $P3374, $P3390
  unless_3375_end:
.annotate 'line', 958
    .return ($P3374)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("450_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3399
    .param pmc param_3400
.annotate 'line', 983
    .lex "self", param_3399
    .lex "$/", param_3400
.annotate 'line', 987
    find_dynamic_lex $P3403, "$*SC"
    unless_null $P3403, vivify_1753
    get_hll_global $P3401, "GLOBAL"
    get_who $P3402, $P3401
    set $P3403, $P3402["$SC"]
    unless_null $P3403, vivify_1754
    die "Contextual $*SC not found"
  vivify_1754:
  vivify_1753:
    find_dynamic_lex $P3406, "%*HOW"
    unless_null $P3406, vivify_1755
    get_hll_global $P3404, "GLOBAL"
    get_who $P3405, $P3404
    set $P3406, $P3405["%HOW"]
    unless_null $P3406, vivify_1756
    die "Contextual %*HOW not found"
  vivify_1756:
  vivify_1755:
    set $P3407, $P3406["knowhow"]
    unless_null $P3407, vivify_1757
    new $P3407, "Undef"
  vivify_1757:
    $P3408 = $P3403."pkg_create_mo"($P3407, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3408
.annotate 'line', 988
    find_dynamic_lex $P3411, "$*GLOBALish"
    unless_null $P3411, vivify_1758
    get_hll_global $P3409, "GLOBAL"
    get_who $P3410, $P3409
    set $P3411, $P3410["$GLOBALish"]
    unless_null $P3411, vivify_1759
    die "Contextual $*GLOBALish not found"
  vivify_1759:
  vivify_1758:
    get_how $P3412, $P3411
    find_dynamic_lex $P3415, "$*GLOBALish"
    unless_null $P3415, vivify_1760
    get_hll_global $P3413, "GLOBAL"
    get_who $P3414, $P3413
    set $P3415, $P3414["$GLOBALish"]
    unless_null $P3415, vivify_1761
    die "Contextual $*GLOBALish not found"
  vivify_1761:
  vivify_1760:
    $P3412."compose"($P3415)
.annotate 'line', 989
    find_dynamic_lex $P3418, "$*SC"
    unless_null $P3418, vivify_1762
    get_hll_global $P3416, "GLOBAL"
    get_who $P3417, $P3416
    set $P3418, $P3417["$SC"]
    unless_null $P3418, vivify_1763
    die "Contextual $*SC not found"
  vivify_1763:
  vivify_1762:
    find_lex $P3419, "$?PACKAGE"
    get_who $P3420, $P3419
    set $P3421, $P3420["@BLOCK"]
    unless_null $P3421, vivify_1764
    $P3421 = root_new ['parrot';'ResizablePMCArray']
  vivify_1764:
    set $P3422, $P3421[0]
    unless_null $P3422, vivify_1765
    new $P3422, "Undef"
  vivify_1765:
    find_dynamic_lex $P3425, "$*GLOBALish"
    unless_null $P3425, vivify_1766
    get_hll_global $P3423, "GLOBAL"
    get_who $P3424, $P3423
    set $P3425, $P3424["$GLOBALish"]
    unless_null $P3425, vivify_1767
    die "Contextual $*GLOBALish not found"
  vivify_1767:
  vivify_1766:
    $P3418."install_lexical_symbol"($P3422, "GLOBALish", $P3425)
.annotate 'line', 992
    find_dynamic_lex $P3428, "$*GLOBALish"
    unless_null $P3428, vivify_1768
    get_hll_global $P3426, "GLOBAL"
    get_who $P3427, $P3426
    set $P3428, $P3427["$GLOBALish"]
    unless_null $P3428, vivify_1769
    die "Contextual $*GLOBALish not found"
  vivify_1769:
  vivify_1768:
    store_dynamic_lex "$*PACKAGE", $P3428
.annotate 'line', 993
    find_dynamic_lex $P3431, "$*SC"
    unless_null $P3431, vivify_1770
    get_hll_global $P3429, "GLOBAL"
    get_who $P3430, $P3429
    set $P3431, $P3430["$SC"]
    unless_null $P3431, vivify_1771
    die "Contextual $*SC not found"
  vivify_1771:
  vivify_1770:
    find_lex $P3432, "$?PACKAGE"
    get_who $P3433, $P3432
    set $P3434, $P3433["@BLOCK"]
    unless_null $P3434, vivify_1772
    $P3434 = root_new ['parrot';'ResizablePMCArray']
  vivify_1772:
    set $P3435, $P3434[0]
    unless_null $P3435, vivify_1773
    new $P3435, "Undef"
  vivify_1773:
    find_dynamic_lex $P3438, "$*PACKAGE"
    unless_null $P3438, vivify_1774
    get_hll_global $P3436, "GLOBAL"
    get_who $P3437, $P3436
    set $P3438, $P3437["$PACKAGE"]
    unless_null $P3438, vivify_1775
    die "Contextual $*PACKAGE not found"
  vivify_1775:
  vivify_1774:
    $P3439 = $P3431."install_lexical_symbol"($P3435, "$?PACKAGE", $P3438)
.annotate 'line', 983
    .return ($P3439)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("451_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3441
    .param pmc param_3442
.annotate 'line', 996
    .lex "self", param_3441
    .lex "$/", param_3442
.annotate 'line', 997
    find_lex $P3443, "$/"
    find_lex $P3444, "self"
    $P3445 = $P3444."CTXSAVE"()
    $P3446 = $P3443."!make"($P3445)
.annotate 'line', 996
    .return ($P3446)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("452_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3448
    .param pmc param_3449
.annotate 'line', 1002
    .lex "self", param_3448
    .lex "$/", param_3449
.annotate 'line', 1003
    new $P3450, "Undef"
    .lex "$module", $P3450
    find_dynamic_lex $P3453, "$*SC"
    unless_null $P3453, vivify_1776
    get_hll_global $P3451, "GLOBAL"
    get_who $P3452, $P3451
    set $P3453, $P3452["$SC"]
    unless_null $P3453, vivify_1777
    die "Contextual $*SC not found"
  vivify_1777:
  vivify_1776:
    find_lex $P3454, "$/"
    unless_null $P3454, vivify_1778
    $P3454 = root_new ['parrot';'Hash']
  vivify_1778:
    set $P3455, $P3454["name"]
    unless_null $P3455, vivify_1779
    new $P3455, "Undef"
  vivify_1779:
    set $S3456, $P3455
    find_dynamic_lex $P3459, "$*GLOBALish"
    unless_null $P3459, vivify_1780
    get_hll_global $P3457, "GLOBAL"
    get_who $P3458, $P3457
    set $P3459, $P3458["$GLOBALish"]
    unless_null $P3459, vivify_1781
    die "Contextual $*GLOBALish not found"
  vivify_1781:
  vivify_1780:
    $P3460 = $P3453."load_module"($S3456, $P3459)
    store_lex "$module", $P3460
.annotate 'line', 1004
    find_lex $P3462, "$module"
    unless_null $P3462, vivify_1782
    new $P3462, "Undef"
  vivify_1782:
    defined $I3463, $P3462
    unless $I3463, if_3461_end
.annotate 'line', 1005
    find_lex $P3464, "$module"
    unless_null $P3464, vivify_1783
    new $P3464, "Undef"
  vivify_1783:
    "import_HOW_exports"($P3464)
  if_3461_end:
.annotate 'line', 1007
    find_lex $P3465, "$/"
    get_hll_global $P3466, "GLOBAL"
    nqp_get_package_through_who $P3467, $P3466, "PAST"
    get_who $P3468, $P3467
    set $P3469, $P3468["Stmts"]
    $P3470 = $P3469."new"()
    $P3471 = $P3465."!make"($P3470)
.annotate 'line', 1002
    .return ($P3471)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("453_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3473
    .param pmc param_3474
.annotate 'line', 1010
    .const 'Sub' $P3502 = "454_1304277427.017" 
    capture_lex $P3502
    .lex "self", param_3473
    .lex "$/", param_3474
.annotate 'line', 1011
    new $P3475, "Undef"
    .lex "$count", $P3475
.annotate 'line', 1012
    new $P3476, "Undef"
    .lex "$past", $P3476
.annotate 'line', 1011
    find_lex $P3477, "$/"
    unless_null $P3477, vivify_1784
    $P3477 = root_new ['parrot';'Hash']
  vivify_1784:
    set $P3478, $P3477["xblock"]
    unless_null $P3478, vivify_1785
    new $P3478, "Undef"
  vivify_1785:
    set $N3479, $P3478
    new $P3480, 'Float'
    set $P3480, $N3479
    sub $P3481, $P3480, 1
    store_lex "$count", $P3481
.annotate 'line', 1012
    find_lex $P3482, "$count"
    unless_null $P3482, vivify_1786
    new $P3482, "Undef"
  vivify_1786:
    set $I3483, $P3482
    find_lex $P3484, "$/"
    unless_null $P3484, vivify_1787
    $P3484 = root_new ['parrot';'Hash']
  vivify_1787:
    set $P3485, $P3484["xblock"]
    unless_null $P3485, vivify_1788
    $P3485 = root_new ['parrot';'ResizablePMCArray']
  vivify_1788:
    set $P3486, $P3485[$I3483]
    unless_null $P3486, vivify_1789
    new $P3486, "Undef"
  vivify_1789:
    $P3487 = $P3486."ast"()
    $P3488 = "xblock_immediate"($P3487)
    store_lex "$past", $P3488
.annotate 'line', 1013
    find_lex $P3490, "$/"
    unless_null $P3490, vivify_1790
    $P3490 = root_new ['parrot';'Hash']
  vivify_1790:
    set $P3491, $P3490["else"]
    unless_null $P3491, vivify_1791
    new $P3491, "Undef"
  vivify_1791:
    unless $P3491, if_3489_end
.annotate 'line', 1014
    find_lex $P3492, "$past"
    unless_null $P3492, vivify_1792
    new $P3492, "Undef"
  vivify_1792:
    find_lex $P3493, "$/"
    unless_null $P3493, vivify_1793
    $P3493 = root_new ['parrot';'Hash']
  vivify_1793:
    set $P3494, $P3493["else"]
    unless_null $P3494, vivify_1794
    $P3494 = root_new ['parrot';'ResizablePMCArray']
  vivify_1794:
    set $P3495, $P3494[0]
    unless_null $P3495, vivify_1795
    new $P3495, "Undef"
  vivify_1795:
    $P3496 = $P3495."ast"()
    $P3497 = "block_immediate"($P3496)
    $P3492."push"($P3497)
  if_3489_end:
.annotate 'line', 1017
    new $P3518, 'ExceptionHandler'
    set_label $P3518, loop3517_handler
    $P3518."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3518
  loop3517_test:
    find_lex $P3498, "$count"
    unless_null $P3498, vivify_1796
    new $P3498, "Undef"
  vivify_1796:
    set $N3499, $P3498
    isgt $I3500, $N3499, 0.0
    unless $I3500, loop3517_done
  loop3517_redo:
    .const 'Sub' $P3502 = "454_1304277427.017" 
    capture_lex $P3502
    $P3502()
  loop3517_next:
    goto loop3517_test
  loop3517_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3519, exception, 'type'
    eq $P3519, .CONTROL_LOOP_NEXT, loop3517_next
    eq $P3519, .CONTROL_LOOP_REDO, loop3517_redo
  loop3517_done:
    pop_eh 
.annotate 'line', 1023
    find_lex $P3520, "$/"
    find_lex $P3521, "$past"
    unless_null $P3521, vivify_1805
    new $P3521, "Undef"
  vivify_1805:
    $P3522 = $P3520."!make"($P3521)
.annotate 'line', 1010
    .return ($P3522)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3501"  :anon :subid("454_1304277427.017") :outer("453_1304277427.017")
.annotate 'line', 1019
    new $P3503, "Undef"
    .lex "$else", $P3503
.annotate 'line', 1017
    find_lex $P3504, "$count"
    unless_null $P3504, vivify_1797
    new $P3504, "Undef"
  vivify_1797:
    clone $P3505, $P3504
    dec $P3504
.annotate 'line', 1019
    find_lex $P3506, "$past"
    unless_null $P3506, vivify_1798
    new $P3506, "Undef"
  vivify_1798:
    store_lex "$else", $P3506
.annotate 'line', 1020
    find_lex $P3507, "$count"
    unless_null $P3507, vivify_1799
    new $P3507, "Undef"
  vivify_1799:
    set $I3508, $P3507
    find_lex $P3509, "$/"
    unless_null $P3509, vivify_1800
    $P3509 = root_new ['parrot';'Hash']
  vivify_1800:
    set $P3510, $P3509["xblock"]
    unless_null $P3510, vivify_1801
    $P3510 = root_new ['parrot';'ResizablePMCArray']
  vivify_1801:
    set $P3511, $P3510[$I3508]
    unless_null $P3511, vivify_1802
    new $P3511, "Undef"
  vivify_1802:
    $P3512 = $P3511."ast"()
    $P3513 = "xblock_immediate"($P3512)
    store_lex "$past", $P3513
.annotate 'line', 1021
    find_lex $P3514, "$past"
    unless_null $P3514, vivify_1803
    new $P3514, "Undef"
  vivify_1803:
    find_lex $P3515, "$else"
    unless_null $P3515, vivify_1804
    new $P3515, "Undef"
  vivify_1804:
    $P3516 = $P3514."push"($P3515)
.annotate 'line', 1017
    .return ($P3516)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("455_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3524
    .param pmc param_3525
.annotate 'line', 1026
    .lex "self", param_3524
    .lex "$/", param_3525
.annotate 'line', 1027
    new $P3526, "Undef"
    .lex "$past", $P3526
    find_lex $P3527, "$/"
    unless_null $P3527, vivify_1806
    $P3527 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3528, $P3527["xblock"]
    unless_null $P3528, vivify_1807
    new $P3528, "Undef"
  vivify_1807:
    $P3529 = $P3528."ast"()
    $P3530 = "xblock_immediate"($P3529)
    store_lex "$past", $P3530
.annotate 'line', 1028
    find_lex $P3531, "$past"
    unless_null $P3531, vivify_1808
    new $P3531, "Undef"
  vivify_1808:
    $P3531."pasttype"("unless")
.annotate 'line', 1029
    find_lex $P3532, "$/"
    find_lex $P3533, "$past"
    unless_null $P3533, vivify_1809
    new $P3533, "Undef"
  vivify_1809:
    $P3534 = $P3532."!make"($P3533)
.annotate 'line', 1026
    .return ($P3534)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("456_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3536
    .param pmc param_3537
.annotate 'line', 1032
    .lex "self", param_3536
    .lex "$/", param_3537
.annotate 'line', 1033
    new $P3538, "Undef"
    .lex "$past", $P3538
    find_lex $P3539, "$/"
    unless_null $P3539, vivify_1810
    $P3539 = root_new ['parrot';'Hash']
  vivify_1810:
    set $P3540, $P3539["xblock"]
    unless_null $P3540, vivify_1811
    new $P3540, "Undef"
  vivify_1811:
    $P3541 = $P3540."ast"()
    $P3542 = "xblock_immediate"($P3541)
    store_lex "$past", $P3542
.annotate 'line', 1034
    find_lex $P3543, "$past"
    unless_null $P3543, vivify_1812
    new $P3543, "Undef"
  vivify_1812:
    find_lex $P3544, "$/"
    unless_null $P3544, vivify_1813
    $P3544 = root_new ['parrot';'Hash']
  vivify_1813:
    set $P3545, $P3544["sym"]
    unless_null $P3545, vivify_1814
    new $P3545, "Undef"
  vivify_1814:
    set $S3546, $P3545
    $P3543."pasttype"($S3546)
.annotate 'line', 1035
    find_lex $P3547, "$/"
    find_lex $P3548, "$past"
    unless_null $P3548, vivify_1815
    new $P3548, "Undef"
  vivify_1815:
    $P3549 = $P3547."!make"($P3548)
.annotate 'line', 1032
    .return ($P3549)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("457_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3551
    .param pmc param_3552
.annotate 'line', 1038
    .lex "self", param_3551
    .lex "$/", param_3552
.annotate 'line', 1039
    new $P3553, "Undef"
    .lex "$pasttype", $P3553
.annotate 'line', 1040
    new $P3554, "Undef"
    .lex "$past", $P3554
.annotate 'line', 1039
    new $P3555, "String"
    assign $P3555, "repeat_"
    find_lex $P3556, "$/"
    unless_null $P3556, vivify_1816
    $P3556 = root_new ['parrot';'Hash']
  vivify_1816:
    set $P3557, $P3556["wu"]
    unless_null $P3557, vivify_1817
    new $P3557, "Undef"
  vivify_1817:
    set $S3558, $P3557
    concat $P3559, $P3555, $S3558
    store_lex "$pasttype", $P3559
    find_lex $P3560, "$past"
    unless_null $P3560, vivify_1818
    new $P3560, "Undef"
  vivify_1818:
.annotate 'line', 1041
    find_lex $P3562, "$/"
    unless_null $P3562, vivify_1819
    $P3562 = root_new ['parrot';'Hash']
  vivify_1819:
    set $P3563, $P3562["xblock"]
    unless_null $P3563, vivify_1820
    new $P3563, "Undef"
  vivify_1820:
    if $P3563, if_3561
.annotate 'line', 1046
    get_hll_global $P3570, "GLOBAL"
    nqp_get_package_through_who $P3571, $P3570, "PAST"
    get_who $P3572, $P3571
    set $P3573, $P3572["Op"]
    find_lex $P3574, "$/"
    unless_null $P3574, vivify_1821
    $P3574 = root_new ['parrot';'Hash']
  vivify_1821:
    set $P3575, $P3574["EXPR"]
    unless_null $P3575, vivify_1822
    new $P3575, "Undef"
  vivify_1822:
    $P3576 = $P3575."ast"()
    find_lex $P3577, "$/"
    unless_null $P3577, vivify_1823
    $P3577 = root_new ['parrot';'Hash']
  vivify_1823:
    set $P3578, $P3577["pblock"]
    unless_null $P3578, vivify_1824
    new $P3578, "Undef"
  vivify_1824:
    $P3579 = $P3578."ast"()
    $P3580 = "block_immediate"($P3579)
    find_lex $P3581, "$pasttype"
    unless_null $P3581, vivify_1825
    new $P3581, "Undef"
  vivify_1825:
    find_lex $P3582, "$/"
    unless_null $P3582, vivify_1826
    new $P3582, "Undef"
  vivify_1826:
    $P3583 = $P3573."new"($P3576, $P3580, $P3581 :named("pasttype"), $P3582 :named("node"))
    store_lex "$past", $P3583
.annotate 'line', 1045
    goto if_3561_end
  if_3561:
.annotate 'line', 1042
    find_lex $P3564, "$/"
    unless_null $P3564, vivify_1827
    $P3564 = root_new ['parrot';'Hash']
  vivify_1827:
    set $P3565, $P3564["xblock"]
    unless_null $P3565, vivify_1828
    new $P3565, "Undef"
  vivify_1828:
    $P3566 = $P3565."ast"()
    $P3567 = "xblock_immediate"($P3566)
    store_lex "$past", $P3567
.annotate 'line', 1043
    find_lex $P3568, "$past"
    unless_null $P3568, vivify_1829
    new $P3568, "Undef"
  vivify_1829:
    find_lex $P3569, "$pasttype"
    unless_null $P3569, vivify_1830
    new $P3569, "Undef"
  vivify_1830:
    $P3568."pasttype"($P3569)
  if_3561_end:
.annotate 'line', 1049
    find_lex $P3584, "$/"
    find_lex $P3585, "$past"
    unless_null $P3585, vivify_1831
    new $P3585, "Undef"
  vivify_1831:
    $P3586 = $P3584."!make"($P3585)
.annotate 'line', 1038
    .return ($P3586)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("458_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3588
    .param pmc param_3589
.annotate 'line', 1052
    .lex "self", param_3588
    .lex "$/", param_3589
.annotate 'line', 1053
    new $P3590, "Undef"
    .lex "$past", $P3590
.annotate 'line', 1055
    new $P3591, "Undef"
    .lex "$block", $P3591
.annotate 'line', 1053
    find_lex $P3592, "$/"
    unless_null $P3592, vivify_1832
    $P3592 = root_new ['parrot';'Hash']
  vivify_1832:
    set $P3593, $P3592["xblock"]
    unless_null $P3593, vivify_1833
    new $P3593, "Undef"
  vivify_1833:
    $P3594 = $P3593."ast"()
    store_lex "$past", $P3594
.annotate 'line', 1054
    find_lex $P3595, "$past"
    unless_null $P3595, vivify_1834
    new $P3595, "Undef"
  vivify_1834:
    $P3595."pasttype"("for")
.annotate 'line', 1055
    find_lex $P3596, "$past"
    unless_null $P3596, vivify_1835
    $P3596 = root_new ['parrot';'ResizablePMCArray']
  vivify_1835:
    set $P3597, $P3596[1]
    unless_null $P3597, vivify_1836
    new $P3597, "Undef"
  vivify_1836:
    store_lex "$block", $P3597
.annotate 'line', 1056
    find_lex $P3599, "$block"
    unless_null $P3599, vivify_1837
    new $P3599, "Undef"
  vivify_1837:
    $P3600 = $P3599."arity"()
    if $P3600, unless_3598_end
.annotate 'line', 1057
    find_lex $P3601, "$block"
    unless_null $P3601, vivify_1838
    $P3601 = root_new ['parrot';'ResizablePMCArray']
  vivify_1838:
    set $P3602, $P3601[0]
    unless_null $P3602, vivify_1839
    new $P3602, "Undef"
  vivify_1839:
    get_hll_global $P3603, "GLOBAL"
    nqp_get_package_through_who $P3604, $P3603, "PAST"
    get_who $P3605, $P3604
    set $P3606, $P3605["Var"]
    $P3607 = $P3606."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3602."push"($P3607)
.annotate 'line', 1058
    find_lex $P3608, "$block"
    unless_null $P3608, vivify_1840
    new $P3608, "Undef"
  vivify_1840:
    $P3608."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1059
    find_lex $P3609, "$block"
    unless_null $P3609, vivify_1841
    new $P3609, "Undef"
  vivify_1841:
    $P3609."arity"(1)
  unless_3598_end:
.annotate 'line', 1061
    find_lex $P3610, "$block"
    unless_null $P3610, vivify_1842
    new $P3610, "Undef"
  vivify_1842:
    $P3610."blocktype"("immediate")
.annotate 'line', 1062
    find_lex $P3611, "$/"
    find_lex $P3612, "$past"
    unless_null $P3612, vivify_1843
    new $P3612, "Undef"
  vivify_1843:
    $P3613 = $P3611."!make"($P3612)
.annotate 'line', 1052
    .return ($P3613)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("459_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3615
    .param pmc param_3616
.annotate 'line', 1065
    .lex "self", param_3615
    .lex "$/", param_3616
.annotate 'line', 1066
    new $P3617, "Undef"
    .lex "$block", $P3617
    find_lex $P3618, "$/"
    unless_null $P3618, vivify_1844
    $P3618 = root_new ['parrot';'Hash']
  vivify_1844:
    set $P3619, $P3618["block"]
    unless_null $P3619, vivify_1845
    new $P3619, "Undef"
  vivify_1845:
    $P3620 = $P3619."ast"()
    store_lex "$block", $P3620
.annotate 'line', 1067
    find_lex $P3621, "$/"
    unless_null $P3621, vivify_1846
    new $P3621, "Undef"
  vivify_1846:
    find_lex $P3622, "$block"
    unless_null $P3622, vivify_1847
    new $P3622, "Undef"
  vivify_1847:
    "push_block_handler"($P3621, $P3622)
.annotate 'line', 1068
    find_lex $P3623, "$?PACKAGE"
    get_who $P3624, $P3623
    set $P3625, $P3624["@BLOCK"]
    unless_null $P3625, vivify_1848
    $P3625 = root_new ['parrot';'ResizablePMCArray']
  vivify_1848:
    set $P3626, $P3625[0]
    unless_null $P3626, vivify_1849
    new $P3626, "Undef"
  vivify_1849:
    $P3627 = $P3626."handlers"()
    set $P3628, $P3627[0]
    unless_null $P3628, vivify_1850
    new $P3628, "Undef"
  vivify_1850:
    $P3628."handle_types_except"("CONTROL")
.annotate 'line', 1069
    find_lex $P3629, "$/"
    get_hll_global $P3630, "GLOBAL"
    nqp_get_package_through_who $P3631, $P3630, "PAST"
    get_who $P3632, $P3631
    set $P3633, $P3632["Stmts"]
    find_lex $P3634, "$/"
    unless_null $P3634, vivify_1851
    new $P3634, "Undef"
  vivify_1851:
    $P3635 = $P3633."new"($P3634 :named("node"))
    $P3636 = $P3629."!make"($P3635)
.annotate 'line', 1065
    .return ($P3636)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("460_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3638
    .param pmc param_3639
.annotate 'line', 1072
    .lex "self", param_3638
    .lex "$/", param_3639
.annotate 'line', 1073
    new $P3640, "Undef"
    .lex "$block", $P3640
    find_lex $P3641, "$/"
    unless_null $P3641, vivify_1852
    $P3641 = root_new ['parrot';'Hash']
  vivify_1852:
    set $P3642, $P3641["block"]
    unless_null $P3642, vivify_1853
    new $P3642, "Undef"
  vivify_1853:
    $P3643 = $P3642."ast"()
    store_lex "$block", $P3643
.annotate 'line', 1074
    find_lex $P3644, "$/"
    unless_null $P3644, vivify_1854
    new $P3644, "Undef"
  vivify_1854:
    find_lex $P3645, "$block"
    unless_null $P3645, vivify_1855
    new $P3645, "Undef"
  vivify_1855:
    "push_block_handler"($P3644, $P3645)
.annotate 'line', 1075
    find_lex $P3646, "$?PACKAGE"
    get_who $P3647, $P3646
    set $P3648, $P3647["@BLOCK"]
    unless_null $P3648, vivify_1856
    $P3648 = root_new ['parrot';'ResizablePMCArray']
  vivify_1856:
    set $P3649, $P3648[0]
    unless_null $P3649, vivify_1857
    new $P3649, "Undef"
  vivify_1857:
    $P3650 = $P3649."handlers"()
    set $P3651, $P3650[0]
    unless_null $P3651, vivify_1858
    new $P3651, "Undef"
  vivify_1858:
    $P3651."handle_types"("CONTROL")
.annotate 'line', 1076
    find_lex $P3652, "$/"
    get_hll_global $P3653, "GLOBAL"
    nqp_get_package_through_who $P3654, $P3653, "PAST"
    get_who $P3655, $P3654
    set $P3656, $P3655["Stmts"]
    find_lex $P3657, "$/"
    unless_null $P3657, vivify_1859
    new $P3657, "Undef"
  vivify_1859:
    $P3658 = $P3656."new"($P3657 :named("node"))
    $P3659 = $P3652."!make"($P3658)
.annotate 'line', 1072
    .return ($P3659)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("461_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3662
    .param pmc param_3663
.annotate 'line', 1116
    .lex "self", param_3662
    .lex "$/", param_3663
.annotate 'line', 1117
    find_lex $P3664, "$?PACKAGE"
    get_who $P3665, $P3664
    set $P3666, $P3665["@BLOCK"]
    unless_null $P3666, vivify_1860
    $P3666 = root_new ['parrot';'ResizablePMCArray']
  vivify_1860:
    set $P3667, $P3666[0]
    unless_null $P3667, vivify_1861
    new $P3667, "Undef"
  vivify_1861:
    find_lex $P3668, "$/"
    unless_null $P3668, vivify_1862
    $P3668 = root_new ['parrot';'Hash']
  vivify_1862:
    set $P3669, $P3668["blorst"]
    unless_null $P3669, vivify_1863
    new $P3669, "Undef"
  vivify_1863:
    $P3670 = $P3669."ast"()
    $P3667."push"($P3670)
.annotate 'line', 1118
    find_lex $P3671, "$/"
    get_hll_global $P3672, "GLOBAL"
    nqp_get_package_through_who $P3673, $P3672, "PAST"
    get_who $P3674, $P3673
    set $P3675, $P3674["Stmts"]
    $P3676 = $P3675."new"()
    $P3677 = $P3671."!make"($P3676)
.annotate 'line', 1116
    .return ($P3677)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("462_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3679
    .param pmc param_3680
.annotate 'line', 1121
    .lex "self", param_3679
    .lex "$/", param_3680
.annotate 'line', 1122
    new $P3681, "Undef"
    .lex "$past", $P3681
    find_lex $P3682, "$/"
    unless_null $P3682, vivify_1864
    $P3682 = root_new ['parrot';'Hash']
  vivify_1864:
    set $P3683, $P3682["blorst"]
    unless_null $P3683, vivify_1865
    new $P3683, "Undef"
  vivify_1865:
    $P3684 = $P3683."ast"()
    store_lex "$past", $P3684
.annotate 'line', 1123
    get_hll_global $P3686, "GLOBAL"
    nqp_get_package_through_who $P3687, $P3686, "PAST"
    get_who $P3688, $P3687
    set $P3689, $P3688["Block"]
    find_lex $P3690, "$past"
    unless_null $P3690, vivify_1866
    new $P3690, "Undef"
  vivify_1866:
    $P3691 = $P3689."ACCEPTS"($P3690)
    if $P3691, unless_3685_end
.annotate 'line', 1124
    get_hll_global $P3692, "GLOBAL"
    nqp_get_package_through_who $P3693, $P3692, "PAST"
    get_who $P3694, $P3693
    set $P3695, $P3694["Block"]
    find_lex $P3696, "$past"
    unless_null $P3696, vivify_1867
    new $P3696, "Undef"
  vivify_1867:
    find_lex $P3697, "$/"
    unless_null $P3697, vivify_1868
    new $P3697, "Undef"
  vivify_1868:
    $P3698 = $P3695."new"($P3696, "immediate" :named("blocktype"), $P3697 :named("node"))
    store_lex "$past", $P3698
  unless_3685_end:
.annotate 'line', 1126
    find_lex $P3700, "$past"
    unless_null $P3700, vivify_1869
    new $P3700, "Undef"
  vivify_1869:
    $P3701 = $P3700."handlers"()
    if $P3701, unless_3699_end
.annotate 'line', 1127
    find_lex $P3702, "$past"
    unless_null $P3702, vivify_1870
    new $P3702, "Undef"
  vivify_1870:
    get_hll_global $P3703, "GLOBAL"
    nqp_get_package_through_who $P3704, $P3703, "PAST"
    get_who $P3705, $P3704
    set $P3706, $P3705["Control"]
.annotate 'line', 1129
    get_hll_global $P3707, "GLOBAL"
    nqp_get_package_through_who $P3708, $P3707, "PAST"
    get_who $P3709, $P3708
    set $P3710, $P3709["Stmts"]
.annotate 'line', 1130
    get_hll_global $P3711, "GLOBAL"
    nqp_get_package_through_who $P3712, $P3711, "PAST"
    get_who $P3713, $P3712
    set $P3714, $P3713["Op"]
.annotate 'line', 1131
    get_hll_global $P3715, "GLOBAL"
    nqp_get_package_through_who $P3716, $P3715, "PAST"
    get_who $P3717, $P3716
    set $P3718, $P3717["Var"]
.annotate 'line', 1132
    get_hll_global $P3719, "GLOBAL"
    nqp_get_package_through_who $P3720, $P3719, "PAST"
    get_who $P3721, $P3720
    set $P3722, $P3721["Var"]
    $P3723 = $P3722."new"("register" :named("scope"), "exception" :named("name"))
    $P3724 = $P3718."new"($P3723, "handled", "keyed" :named("scope"))
.annotate 'line', 1131
    $P3725 = $P3714."new"($P3724, 1, "bind" :named("pasttype"))
.annotate 'line', 1130
    $P3726 = $P3710."new"($P3725)
.annotate 'line', 1129
    $P3727 = $P3706."new"($P3726, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1127
    new $P3728, "ResizablePMCArray"
    push $P3728, $P3727
    $P3702."handlers"($P3728)
  unless_3699_end:
.annotate 'line', 1141
    find_lex $P3729, "$/"
    find_lex $P3730, "$past"
    unless_null $P3730, vivify_1871
    new $P3730, "Undef"
  vivify_1871:
    $P3731 = $P3729."!make"($P3730)
.annotate 'line', 1121
    .return ($P3731)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("463_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3733
    .param pmc param_3734
.annotate 'line', 1144
    .lex "self", param_3733
    .lex "$/", param_3734
.annotate 'line', 1145
    find_lex $P3735, "$/"
.annotate 'line', 1146
    find_lex $P3738, "$/"
    unless_null $P3738, vivify_1872
    $P3738 = root_new ['parrot';'Hash']
  vivify_1872:
    set $P3739, $P3738["block"]
    unless_null $P3739, vivify_1873
    new $P3739, "Undef"
  vivify_1873:
    if $P3739, if_3737
.annotate 'line', 1147
    find_lex $P3744, "$/"
    unless_null $P3744, vivify_1874
    $P3744 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P3745, $P3744["statement"]
    unless_null $P3745, vivify_1875
    new $P3745, "Undef"
  vivify_1875:
    $P3746 = $P3745."ast"()
    set $P3736, $P3746
.annotate 'line', 1146
    goto if_3737_end
  if_3737:
    find_lex $P3740, "$/"
    unless_null $P3740, vivify_1876
    $P3740 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P3741, $P3740["block"]
    unless_null $P3741, vivify_1877
    new $P3741, "Undef"
  vivify_1877:
    $P3742 = $P3741."ast"()
    $P3743 = "block_immediate"($P3742)
    set $P3736, $P3743
  if_3737_end:
    $P3747 = $P3735."!make"($P3736)
.annotate 'line', 1144
    .return ($P3747)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("464_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3749
    .param pmc param_3750
.annotate 'line', 1152
    .lex "self", param_3749
    .lex "$/", param_3750
    find_lex $P3751, "$/"
    find_lex $P3752, "$/"
    unless_null $P3752, vivify_1878
    $P3752 = root_new ['parrot';'Hash']
  vivify_1878:
    set $P3753, $P3752["cond"]
    unless_null $P3753, vivify_1879
    new $P3753, "Undef"
  vivify_1879:
    $P3754 = $P3753."ast"()
    $P3755 = $P3751."!make"($P3754)
    .return ($P3755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("465_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3757
    .param pmc param_3758
.annotate 'line', 1153
    .lex "self", param_3757
    .lex "$/", param_3758
    find_lex $P3759, "$/"
    find_lex $P3760, "$/"
    unless_null $P3760, vivify_1880
    $P3760 = root_new ['parrot';'Hash']
  vivify_1880:
    set $P3761, $P3760["cond"]
    unless_null $P3761, vivify_1881
    new $P3761, "Undef"
  vivify_1881:
    $P3762 = $P3761."ast"()
    $P3763 = $P3759."!make"($P3762)
    .return ($P3763)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("466_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3765
    .param pmc param_3766
.annotate 'line', 1155
    .lex "self", param_3765
    .lex "$/", param_3766
    find_lex $P3767, "$/"
    find_lex $P3768, "$/"
    unless_null $P3768, vivify_1882
    $P3768 = root_new ['parrot';'Hash']
  vivify_1882:
    set $P3769, $P3768["cond"]
    unless_null $P3769, vivify_1883
    new $P3769, "Undef"
  vivify_1883:
    $P3770 = $P3769."ast"()
    $P3771 = $P3767."!make"($P3770)
    .return ($P3771)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("467_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3773
    .param pmc param_3774
.annotate 'line', 1156
    .lex "self", param_3773
    .lex "$/", param_3774
    find_lex $P3775, "$/"
    find_lex $P3776, "$/"
    unless_null $P3776, vivify_1884
    $P3776 = root_new ['parrot';'Hash']
  vivify_1884:
    set $P3777, $P3776["cond"]
    unless_null $P3777, vivify_1885
    new $P3777, "Undef"
  vivify_1885:
    $P3778 = $P3777."ast"()
    $P3779 = $P3775."!make"($P3778)
    .return ($P3779)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("468_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3781
    .param pmc param_3782
.annotate 'line', 1160
    .lex "self", param_3781
    .lex "$/", param_3782
    find_lex $P3783, "$/"
    find_lex $P3784, "$/"
    unless_null $P3784, vivify_1886
    $P3784 = root_new ['parrot';'Hash']
  vivify_1886:
    set $P3785, $P3784["fatarrow"]
    unless_null $P3785, vivify_1887
    new $P3785, "Undef"
  vivify_1887:
    $P3786 = $P3785."ast"()
    $P3787 = $P3783."!make"($P3786)
    .return ($P3787)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("469_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3789
    .param pmc param_3790
.annotate 'line', 1161
    .lex "self", param_3789
    .lex "$/", param_3790
    find_lex $P3791, "$/"
    find_lex $P3792, "$/"
    unless_null $P3792, vivify_1888
    $P3792 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P3793, $P3792["colonpair"]
    unless_null $P3793, vivify_1889
    new $P3793, "Undef"
  vivify_1889:
    $P3794 = $P3793."ast"()
    $P3795 = $P3791."!make"($P3794)
    .return ($P3795)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("470_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3797
    .param pmc param_3798
.annotate 'line', 1162
    .lex "self", param_3797
    .lex "$/", param_3798
    find_lex $P3799, "$/"
    find_lex $P3800, "$/"
    unless_null $P3800, vivify_1890
    $P3800 = root_new ['parrot';'Hash']
  vivify_1890:
    set $P3801, $P3800["variable"]
    unless_null $P3801, vivify_1891
    new $P3801, "Undef"
  vivify_1891:
    $P3802 = $P3801."ast"()
    $P3803 = $P3799."!make"($P3802)
    .return ($P3803)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("471_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3805
    .param pmc param_3806
.annotate 'line', 1163
    .lex "self", param_3805
    .lex "$/", param_3806
    find_lex $P3807, "$/"
    find_lex $P3808, "$/"
    unless_null $P3808, vivify_1892
    $P3808 = root_new ['parrot';'Hash']
  vivify_1892:
    set $P3809, $P3808["package_declarator"]
    unless_null $P3809, vivify_1893
    new $P3809, "Undef"
  vivify_1893:
    $P3810 = $P3809."ast"()
    $P3811 = $P3807."!make"($P3810)
    .return ($P3811)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("472_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3813
    .param pmc param_3814
.annotate 'line', 1164
    .lex "self", param_3813
    .lex "$/", param_3814
    find_lex $P3815, "$/"
    find_lex $P3816, "$/"
    unless_null $P3816, vivify_1894
    $P3816 = root_new ['parrot';'Hash']
  vivify_1894:
    set $P3817, $P3816["scope_declarator"]
    unless_null $P3817, vivify_1895
    new $P3817, "Undef"
  vivify_1895:
    $P3818 = $P3817."ast"()
    $P3819 = $P3815."!make"($P3818)
    .return ($P3819)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("473_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3821
    .param pmc param_3822
.annotate 'line', 1165
    .lex "self", param_3821
    .lex "$/", param_3822
    find_lex $P3823, "$/"
    find_lex $P3824, "$/"
    unless_null $P3824, vivify_1896
    $P3824 = root_new ['parrot';'Hash']
  vivify_1896:
    set $P3825, $P3824["routine_declarator"]
    unless_null $P3825, vivify_1897
    new $P3825, "Undef"
  vivify_1897:
    $P3826 = $P3825."ast"()
    $P3827 = $P3823."!make"($P3826)
    .return ($P3827)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("474_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3829
    .param pmc param_3830
.annotate 'line', 1166
    .lex "self", param_3829
    .lex "$/", param_3830
    find_lex $P3831, "$/"
    find_lex $P3832, "$/"
    unless_null $P3832, vivify_1898
    $P3832 = root_new ['parrot';'Hash']
  vivify_1898:
    set $P3833, $P3832["regex_declarator"]
    unless_null $P3833, vivify_1899
    new $P3833, "Undef"
  vivify_1899:
    $P3834 = $P3833."ast"()
    $P3835 = $P3831."!make"($P3834)
    .return ($P3835)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("475_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3837
    .param pmc param_3838
.annotate 'line', 1167
    .lex "self", param_3837
    .lex "$/", param_3838
    find_lex $P3839, "$/"
    find_lex $P3840, "$/"
    unless_null $P3840, vivify_1900
    $P3840 = root_new ['parrot';'Hash']
  vivify_1900:
    set $P3841, $P3840["statement_prefix"]
    unless_null $P3841, vivify_1901
    new $P3841, "Undef"
  vivify_1901:
    $P3842 = $P3841."ast"()
    $P3843 = $P3839."!make"($P3842)
    .return ($P3843)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("476_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3845
    .param pmc param_3846
.annotate 'line', 1168
    .lex "self", param_3845
    .lex "$/", param_3846
    find_lex $P3847, "$/"
    find_lex $P3848, "$/"
    unless_null $P3848, vivify_1902
    $P3848 = root_new ['parrot';'Hash']
  vivify_1902:
    set $P3849, $P3848["pblock"]
    unless_null $P3849, vivify_1903
    new $P3849, "Undef"
  vivify_1903:
    $P3850 = $P3849."ast"()
    $P3851 = $P3847."!make"($P3850)
    .return ($P3851)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("477_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3853
    .param pmc param_3854
.annotate 'line', 1170
    .lex "self", param_3853
    .lex "$/", param_3854
.annotate 'line', 1171
    new $P3855, "Undef"
    .lex "$past", $P3855
    find_lex $P3856, "$/"
    unless_null $P3856, vivify_1904
    $P3856 = root_new ['parrot';'Hash']
  vivify_1904:
    set $P3857, $P3856["val"]
    unless_null $P3857, vivify_1905
    new $P3857, "Undef"
  vivify_1905:
    $P3858 = $P3857."ast"()
    store_lex "$past", $P3858
.annotate 'line', 1172
    find_lex $P3859, "$past"
    unless_null $P3859, vivify_1906
    new $P3859, "Undef"
  vivify_1906:
    find_lex $P3860, "$/"
    unless_null $P3860, vivify_1907
    $P3860 = root_new ['parrot';'Hash']
  vivify_1907:
    set $P3861, $P3860["key"]
    unless_null $P3861, vivify_1908
    new $P3861, "Undef"
  vivify_1908:
    $P3862 = $P3861."Str"()
    $P3859."named"($P3862)
.annotate 'line', 1173
    find_lex $P3863, "$/"
    find_lex $P3864, "$past"
    unless_null $P3864, vivify_1909
    new $P3864, "Undef"
  vivify_1909:
    $P3865 = $P3863."!make"($P3864)
.annotate 'line', 1170
    .return ($P3865)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("478_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3867
    .param pmc param_3868
.annotate 'line', 1176
    .lex "self", param_3867
    .lex "$/", param_3868
.annotate 'line', 1177
    new $P3869, "Undef"
    .lex "$past", $P3869
.annotate 'line', 1178
    find_lex $P3872, "$/"
    unless_null $P3872, vivify_1910
    $P3872 = root_new ['parrot';'Hash']
  vivify_1910:
    set $P3873, $P3872["circumfix"]
    unless_null $P3873, vivify_1911
    new $P3873, "Undef"
  vivify_1911:
    if $P3873, if_3871
.annotate 'line', 1179
    get_hll_global $P3878, "GLOBAL"
    nqp_get_package_through_who $P3879, $P3878, "PAST"
    get_who $P3880, $P3879
    set $P3881, $P3880["Val"]
    find_lex $P3882, "$/"
    unless_null $P3882, vivify_1912
    $P3882 = root_new ['parrot';'Hash']
  vivify_1912:
    set $P3883, $P3882["not"]
    unless_null $P3883, vivify_1913
    new $P3883, "Undef"
  vivify_1913:
    isfalse $I3884, $P3883
    $P3885 = $P3881."new"($I3884 :named("value"))
    set $P3870, $P3885
.annotate 'line', 1178
    goto if_3871_end
  if_3871:
    find_lex $P3874, "$/"
    unless_null $P3874, vivify_1914
    $P3874 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P3875, $P3874["circumfix"]
    unless_null $P3875, vivify_1915
    $P3875 = root_new ['parrot';'ResizablePMCArray']
  vivify_1915:
    set $P3876, $P3875[0]
    unless_null $P3876, vivify_1916
    new $P3876, "Undef"
  vivify_1916:
    $P3877 = $P3876."ast"()
    set $P3870, $P3877
  if_3871_end:
    store_lex "$past", $P3870
.annotate 'line', 1180
    find_lex $P3886, "$past"
    unless_null $P3886, vivify_1917
    new $P3886, "Undef"
  vivify_1917:
    find_lex $P3887, "$/"
    unless_null $P3887, vivify_1918
    $P3887 = root_new ['parrot';'Hash']
  vivify_1918:
    set $P3888, $P3887["identifier"]
    unless_null $P3888, vivify_1919
    new $P3888, "Undef"
  vivify_1919:
    set $S3889, $P3888
    $P3886."named"($S3889)
.annotate 'line', 1181
    find_lex $P3890, "$/"
    find_lex $P3891, "$past"
    unless_null $P3891, vivify_1920
    new $P3891, "Undef"
  vivify_1920:
    $P3892 = $P3890."!make"($P3891)
.annotate 'line', 1176
    .return ($P3892)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("479_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_3894
    .param pmc param_3895
.annotate 'line', 1184
    .const 'Sub' $P3911 = "480_1304277427.017" 
    capture_lex $P3911
    .lex "self", param_3894
    .lex "$/", param_3895
.annotate 'line', 1185
    new $P3896, "Undef"
    .lex "$past", $P3896
.annotate 'line', 1184
    find_lex $P3897, "$past"
    unless_null $P3897, vivify_1921
    new $P3897, "Undef"
  vivify_1921:
.annotate 'line', 1186
    find_lex $P3899, "$/"
    unless_null $P3899, vivify_1922
    $P3899 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P3900, $P3899["postcircumfix"]
    unless_null $P3900, vivify_1923
    new $P3900, "Undef"
  vivify_1923:
    if $P3900, if_3898
.annotate 'line', 1190
    .const 'Sub' $P3911 = "480_1304277427.017" 
    capture_lex $P3911
    $P3911()
    goto if_3898_end
  if_3898:
.annotate 'line', 1187
    find_lex $P3901, "$/"
    unless_null $P3901, vivify_1980
    $P3901 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P3902, $P3901["postcircumfix"]
    unless_null $P3902, vivify_1981
    new $P3902, "Undef"
  vivify_1981:
    $P3903 = $P3902."ast"()
    store_lex "$past", $P3903
.annotate 'line', 1188
    find_lex $P3904, "$past"
    unless_null $P3904, vivify_1982
    new $P3904, "Undef"
  vivify_1982:
    get_hll_global $P3905, "GLOBAL"
    nqp_get_package_through_who $P3906, $P3905, "PAST"
    get_who $P3907, $P3906
    set $P3908, $P3907["Var"]
    $P3909 = $P3908."new"("$/" :named("name"))
    $P3904."unshift"($P3909)
  if_3898_end:
.annotate 'line', 1249
    find_lex $P4093, "$/"
    find_lex $P4094, "$past"
    unless_null $P4094, vivify_1983
    new $P4094, "Undef"
  vivify_1983:
    $P4095 = $P4093."!make"($P4094)
.annotate 'line', 1184
    .return ($P4095)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3910"  :anon :subid("480_1304277427.017") :outer("479_1304277427.017")
.annotate 'line', 1190
    .const 'Sub' $P3987 = "482_1304277427.017" 
    capture_lex $P3987
    .const 'Sub' $P3946 = "481_1304277427.017" 
    capture_lex $P3946
.annotate 'line', 1191
    $P3912 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3912
    get_hll_global $P3913, "GLOBAL"
    nqp_get_package_through_who $P3914, $P3913, "NQP"
    get_who $P3915, $P3914
    set $P3916, $P3915["Compiler"]
    find_lex $P3917, "$/"
    unless_null $P3917, vivify_1924
    new $P3917, "Undef"
  vivify_1924:
    set $S3918, $P3917
    $P3919 = $P3916."parse_name"($S3918)
    store_lex "@name", $P3919
.annotate 'line', 1192
    find_lex $P3922, "@name"
    unless_null $P3922, vivify_1925
    $P3922 = root_new ['parrot';'ResizablePMCArray']
  vivify_1925:
    set $N3923, $P3922
    isgt $I3924, $N3923, 1.0
    if $I3924, if_3921
.annotate 'line', 1199
    find_lex $P3940, "$/"
    unless_null $P3940, vivify_1926
    $P3940 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P3941, $P3940["twigil"]
    unless_null $P3941, vivify_1927
    $P3941 = root_new ['parrot';'ResizablePMCArray']
  vivify_1927:
    set $P3942, $P3941[0]
    unless_null $P3942, vivify_1928
    new $P3942, "Undef"
  vivify_1928:
    set $S3943, $P3942
    iseq $I3944, $S3943, "*"
    if $I3944, if_3939
.annotate 'line', 1210
    find_lex $P3981, "$/"
    unless_null $P3981, vivify_1929
    $P3981 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P3982, $P3981["twigil"]
    unless_null $P3982, vivify_1930
    $P3982 = root_new ['parrot';'ResizablePMCArray']
  vivify_1930:
    set $P3983, $P3982[0]
    unless_null $P3983, vivify_1931
    new $P3983, "Undef"
  vivify_1931:
    set $S3984, $P3983
    iseq $I3985, $S3984, "!"
    if $I3985, if_3980
.annotate 'line', 1239
    find_lex $P4070, "@name"
    unless_null $P4070, vivify_1932
    $P4070 = root_new ['parrot';'ResizablePMCArray']
  vivify_1932:
    set $P4071, $P4070[0]
    unless_null $P4071, vivify_1933
    new $P4071, "Undef"
  vivify_1933:
    set $S4072, $P4071
    $P4073 = "is_package"($S4072)
    if $P4073, if_4069
.annotate 'line', 1244
    get_hll_global $P4082, "GLOBAL"
    nqp_get_package_through_who $P4083, $P4082, "PAST"
    get_who $P4084, $P4083
    set $P4085, $P4084["Var"]
.annotate 'line', 1245
    find_lex $P4086, "@name"
    unless_null $P4086, vivify_1934
    $P4086 = root_new ['parrot';'ResizablePMCArray']
  vivify_1934:
    $P4087 = $P4086."pop"()
    set $S4088, $P4087
    find_lex $P4089, "$/"
    unless_null $P4089, vivify_1935
    $P4089 = root_new ['parrot';'Hash']
  vivify_1935:
    set $P4090, $P4089["sigil"]
    unless_null $P4090, vivify_1936
    new $P4090, "Undef"
  vivify_1936:
    $P4091 = "vivitype"($P4090)
    $P4092 = $P4085."new"($S4088 :named("name"), $P4091 :named("viviself"))
.annotate 'line', 1244
    store_lex "$past", $P4092
.annotate 'line', 1243
    set $P4068, $P4092
.annotate 'line', 1239
    goto if_4069_end
  if_4069:
.annotate 'line', 1240
    find_lex $P4074, "@name"
    unless_null $P4074, vivify_1937
    $P4074 = root_new ['parrot';'ResizablePMCArray']
  vivify_1937:
    find_lex $P4075, "$/"
    unless_null $P4075, vivify_1938
    new $P4075, "Undef"
  vivify_1938:
    $P4076 = "lexical_package_lookup"($P4074, $P4075)
    store_lex "$past", $P4076
.annotate 'line', 1241
    find_lex $P4077, "$past"
    unless_null $P4077, vivify_1939
    new $P4077, "Undef"
  vivify_1939:
    find_lex $P4078, "$/"
    unless_null $P4078, vivify_1940
    $P4078 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P4079, $P4078["sigil"]
    unless_null $P4079, vivify_1941
    new $P4079, "Undef"
  vivify_1941:
    $P4080 = "vivitype"($P4079)
    $P4081 = $P4077."viviself"($P4080)
.annotate 'line', 1239
    set $P4068, $P4081
  if_4069_end:
    set $P3979, $P4068
.annotate 'line', 1210
    goto if_3980_end
  if_3980:
    .const 'Sub' $P3987 = "482_1304277427.017" 
    capture_lex $P3987
    $P4067 = $P3987()
    set $P3979, $P4067
  if_3980_end:
    set $P3938, $P3979
.annotate 'line', 1199
    goto if_3939_end
  if_3939:
    .const 'Sub' $P3946 = "481_1304277427.017" 
    capture_lex $P3946
    $P3978 = $P3946()
    set $P3938, $P3978
  if_3939_end:
    set $P3920, $P3938
.annotate 'line', 1192
    goto if_3921_end
  if_3921:
.annotate 'line', 1193
    find_lex $P3926, "$/"
    unless_null $P3926, vivify_1972
    $P3926 = root_new ['parrot';'Hash']
  vivify_1972:
    set $P3927, $P3926["twigil"]
    unless_null $P3927, vivify_1973
    new $P3927, "Undef"
  vivify_1973:
    unless $P3927, if_3925_end
.annotate 'line', 1194
    find_lex $P3928, "$/"
    unless_null $P3928, vivify_1974
    new $P3928, "Undef"
  vivify_1974:
    $P3929 = $P3928."CURSOR"()
    $P3929."panic"("Twigil not allowed on multi-part name")
  if_3925_end:
.annotate 'line', 1196
    find_lex $P3930, "@name"
    unless_null $P3930, vivify_1975
    $P3930 = root_new ['parrot';'ResizablePMCArray']
  vivify_1975:
    find_lex $P3931, "$/"
    unless_null $P3931, vivify_1976
    new $P3931, "Undef"
  vivify_1976:
    $P3932 = "lexical_package_lookup"($P3930, $P3931)
    store_lex "$past", $P3932
.annotate 'line', 1197
    find_lex $P3933, "$past"
    unless_null $P3933, vivify_1977
    new $P3933, "Undef"
  vivify_1977:
    find_lex $P3934, "$/"
    unless_null $P3934, vivify_1978
    $P3934 = root_new ['parrot';'Hash']
  vivify_1978:
    set $P3935, $P3934["sigil"]
    unless_null $P3935, vivify_1979
    new $P3935, "Undef"
  vivify_1979:
    $P3936 = "vivitype"($P3935)
    $P3937 = $P3933."viviself"($P3936)
.annotate 'line', 1192
    set $P3920, $P3937
  if_3921_end:
.annotate 'line', 1190
    .return ($P3920)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3986"  :anon :subid("482_1304277427.017") :outer("480_1304277427.017")
.annotate 'line', 1210
    .const 'Sub' $P4018 = "483_1304277427.017" 
    capture_lex $P4018
.annotate 'line', 1212
    new $P3988, "Undef"
    .lex "$name", $P3988
    find_lex $P3989, "@name"
    unless_null $P3989, vivify_1942
    $P3989 = root_new ['parrot';'ResizablePMCArray']
  vivify_1942:
    $P3990 = $P3989."pop"()
    set $S3991, $P3990
    new $P3992, 'String'
    set $P3992, $S3991
    store_lex "$name", $P3992
.annotate 'line', 1213
    get_hll_global $P3993, "GLOBAL"
    nqp_get_package_through_who $P3994, $P3993, "PAST"
    get_who $P3995, $P3994
    set $P3996, $P3995["Var"]
    find_lex $P3997, "$name"
    unless_null $P3997, vivify_1943
    new $P3997, "Undef"
  vivify_1943:
.annotate 'line', 1215
    find_lex $P3998, "$/"
    unless_null $P3998, vivify_1944
    $P3998 = root_new ['parrot';'Hash']
  vivify_1944:
    set $P3999, $P3998["sigil"]
    unless_null $P3999, vivify_1945
    new $P3999, "Undef"
  vivify_1945:
    $P4000 = "vivitype"($P3999)
.annotate 'line', 1216
    get_hll_global $P4001, "GLOBAL"
    nqp_get_package_through_who $P4002, $P4001, "PAST"
    get_who $P4003, $P4002
    set $P4004, $P4003["Var"]
    $P4005 = $P4004."new"("self" :named("name"))
.annotate 'line', 1217
    get_hll_global $P4006, "GLOBAL"
    nqp_get_package_through_who $P4007, $P4006, "PAST"
    get_who $P4008, $P4007
    set $P4009, $P4008["Var"]
    $P4010 = $P4009."new"("$?CLASS" :named("name"))
    $P4011 = $P3996."new"($P4005, $P4010, $P3997 :named("name"), "attribute_6model" :named("scope"), $P4000 :named("viviself"))
.annotate 'line', 1213
    store_lex "$past", $P4011
.annotate 'line', 1221
    find_dynamic_lex $P4016, "$*IN_DECL"
    unless_null $P4016, vivify_1946
    get_hll_global $P4014, "GLOBAL"
    get_who $P4015, $P4014
    set $P4016, $P4015["$IN_DECL"]
    unless_null $P4016, vivify_1947
    die "Contextual $*IN_DECL not found"
  vivify_1947:
  vivify_1946:
    unless $P4016, unless_4013
    set $P4012, $P4016
    goto unless_4013_end
  unless_4013:
    .const 'Sub' $P4018 = "483_1304277427.017" 
    capture_lex $P4018
    $P4066 = $P4018()
    set $P4012, $P4066
  unless_4013_end:
.annotate 'line', 1210
    .return ($P4012)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4017"  :anon :subid("483_1304277427.017") :outer("482_1304277427.017")
.annotate 'line', 1221
    .const 'Sub' $P4033 = "484_1304277427.017" 
    capture_lex $P4033
.annotate 'line', 1222
    new $P4019, "Undef"
    .lex "$attr", $P4019
.annotate 'line', 1221
    find_lex $P4020, "$attr"
    unless_null $P4020, vivify_1948
    new $P4020, "Undef"
  vivify_1948:
.annotate 'line', 1223
    find_dynamic_lex $P4024, "$*PACKAGE"
    unless_null $P4024, vivify_1949
    get_hll_global $P4022, "GLOBAL"
    get_who $P4023, $P4022
    set $P4024, $P4023["$PACKAGE"]
    unless_null $P4024, vivify_1950
    die "Contextual $*PACKAGE not found"
  vivify_1950:
  vivify_1949:
    get_how $P4025, $P4024
    find_dynamic_lex $P4028, "$*PACKAGE"
    unless_null $P4028, vivify_1951
    get_hll_global $P4026, "GLOBAL"
    get_who $P4027, $P4026
    set $P4028, $P4027["$PACKAGE"]
    unless_null $P4028, vivify_1952
    die "Contextual $*PACKAGE not found"
  vivify_1952:
  vivify_1951:
    $P4029 = $P4025."attributes"($P4028, 1 :named("local"))
    defined $I4030, $P4029
    unless $I4030, for_undef_1953
    iter $P4021, $P4029
    new $P4045, 'ExceptionHandler'
    set_label $P4045, loop4044_handler
    $P4045."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4045
  loop4044_test:
    unless $P4021, loop4044_done
    shift $P4031, $P4021
  loop4044_redo:
    .const 'Sub' $P4033 = "484_1304277427.017" 
    capture_lex $P4033
    $P4033($P4031)
  loop4044_next:
    goto loop4044_test
  loop4044_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4046, exception, 'type'
    eq $P4046, .CONTROL_LOOP_NEXT, loop4044_next
    eq $P4046, .CONTROL_LOOP_REDO, loop4044_redo
  loop4044_done:
    pop_eh 
  for_undef_1953:
.annotate 'line', 1229
    find_lex $P4049, "$attr"
    unless_null $P4049, vivify_1957
    new $P4049, "Undef"
  vivify_1957:
    defined $I4050, $P4049
    if $I4050, if_4048
.annotate 'line', 1235
    find_lex $P4059, "$/"
    unless_null $P4059, vivify_1958
    new $P4059, "Undef"
  vivify_1958:
    $P4060 = $P4059."CURSOR"()
    new $P4061, 'String'
    set $P4061, "Attribute '"
    find_lex $P4062, "$name"
    unless_null $P4062, vivify_1959
    new $P4062, "Undef"
  vivify_1959:
    concat $P4063, $P4061, $P4062
    concat $P4064, $P4063, "' not declared"
    $P4065 = $P4060."panic"($P4064)
.annotate 'line', 1234
    set $P4047, $P4065
.annotate 'line', 1229
    goto if_4048_end
  if_4048:
.annotate 'line', 1230
    find_lex $P4053, "$attr"
    unless_null $P4053, vivify_1960
    new $P4053, "Undef"
  vivify_1960:
    can $I4054, $P4053, "type"
    if $I4054, if_4052
    new $P4051, 'Integer'
    set $P4051, $I4054
    goto if_4052_end
  if_4052:
.annotate 'line', 1231
    find_lex $P4055, "$past"
    unless_null $P4055, vivify_1961
    new $P4055, "Undef"
  vivify_1961:
    find_lex $P4056, "$attr"
    unless_null $P4056, vivify_1962
    new $P4056, "Undef"
  vivify_1962:
    $P4057 = $P4056."type"()
    $P4058 = $P4055."type"($P4057)
.annotate 'line', 1230
    set $P4051, $P4058
  if_4052_end:
.annotate 'line', 1229
    set $P4047, $P4051
  if_4048_end:
.annotate 'line', 1221
    .return ($P4047)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4032"  :anon :subid("484_1304277427.017") :outer("483_1304277427.017")
    .param pmc param_4034
.annotate 'line', 1223
    .lex "$_", param_4034
.annotate 'line', 1224
    find_lex $P4037, "$_"
    unless_null $P4037, vivify_1954
    new $P4037, "Undef"
  vivify_1954:
    $S4038 = $P4037."name"()
    find_lex $P4039, "$name"
    unless_null $P4039, vivify_1955
    new $P4039, "Undef"
  vivify_1955:
    set $S4040, $P4039
    iseq $I4041, $S4038, $S4040
    if $I4041, if_4036
    new $P4035, 'Integer'
    set $P4035, $I4041
    goto if_4036_end
  if_4036:
.annotate 'line', 1225
    find_lex $P4042, "$_"
    unless_null $P4042, vivify_1956
    new $P4042, "Undef"
  vivify_1956:
    store_lex "$attr", $P4042
.annotate 'line', 1226
    set $I4043, .CONTROL_LOOP_LAST
    die 0, $I4043
  if_4036_end:
.annotate 'line', 1223
    .return ($P4035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3945"  :anon :subid("481_1304277427.017") :outer("480_1304277427.017")
.annotate 'line', 1200
    new $P3947, "Undef"
    .lex "$global_fallback", $P3947
    find_lex $P3948, "$/"
    unless_null $P3948, vivify_1963
    $P3948 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P3949, $P3948["sigil"]
    unless_null $P3949, vivify_1964
    new $P3949, "Undef"
  vivify_1964:
    set $S3950, $P3949
    new $P3951, 'String'
    set $P3951, $S3950
    find_lex $P3952, "$/"
    unless_null $P3952, vivify_1965
    $P3952 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P3953, $P3952["desigilname"]
    unless_null $P3953, vivify_1966
    new $P3953, "Undef"
  vivify_1966:
    concat $P3954, $P3951, $P3953
    new $P3955, "ResizablePMCArray"
    push $P3955, "GLOBAL"
    push $P3955, $P3954
    find_lex $P3956, "$/"
    unless_null $P3956, vivify_1967
    new $P3956, "Undef"
  vivify_1967:
    $P3957 = "lexical_package_lookup"($P3955, $P3956)
    store_lex "$global_fallback", $P3957
.annotate 'line', 1201
    find_lex $P3958, "$global_fallback"
    unless_null $P3958, vivify_1968
    new $P3958, "Undef"
  vivify_1968:
    get_hll_global $P3959, "GLOBAL"
    nqp_get_package_through_who $P3960, $P3959, "PAST"
    get_who $P3961, $P3960
    set $P3962, $P3961["Op"]
.annotate 'line', 1202
    new $P3963, "String"
    assign $P3963, "Contextual "
    find_lex $P3964, "$/"
    unless_null $P3964, vivify_1969
    new $P3964, "Undef"
  vivify_1969:
    set $S3965, $P3964
    concat $P3966, $P3963, $S3965
    concat $P3967, $P3966, " not found"
    $P3968 = $P3962."new"($P3967, "die" :named("pirop"))
.annotate 'line', 1201
    $P3958."viviself"($P3968)
.annotate 'line', 1205
    get_hll_global $P3969, "GLOBAL"
    nqp_get_package_through_who $P3970, $P3969, "PAST"
    get_who $P3971, $P3970
    set $P3972, $P3971["Var"]
.annotate 'line', 1206
    find_lex $P3973, "@name"
    unless_null $P3973, vivify_1970
    $P3973 = root_new ['parrot';'ResizablePMCArray']
  vivify_1970:
    $P3974 = $P3973."pop"()
    set $S3975, $P3974
    find_lex $P3976, "$global_fallback"
    unless_null $P3976, vivify_1971
    new $P3976, "Undef"
  vivify_1971:
    $P3977 = $P3972."new"($S3975 :named("name"), "contextual" :named("scope"), $P3976 :named("viviself"))
.annotate 'line', 1205
    store_lex "$past", $P3977
.annotate 'line', 1199
    .return ($P3977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("485_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4097
    .param pmc param_4098
.annotate 'line', 1252
    .lex "self", param_4097
    .lex "$/", param_4098
    find_lex $P4099, "$/"
    find_lex $P4100, "$/"
    unless_null $P4100, vivify_1984
    $P4100 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P4101, $P4100["package_def"]
    unless_null $P4101, vivify_1985
    new $P4101, "Undef"
  vivify_1985:
    $P4102 = $P4101."ast"()
    $P4103 = $P4099."!make"($P4102)
    .return ($P4103)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("486_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4105
    .param pmc param_4106
.annotate 'line', 1253
    .lex "self", param_4105
    .lex "$/", param_4106
    find_lex $P4107, "$/"
    find_lex $P4108, "$/"
    unless_null $P4108, vivify_1986
    $P4108 = root_new ['parrot';'Hash']
  vivify_1986:
    set $P4109, $P4108["package_def"]
    unless_null $P4109, vivify_1987
    new $P4109, "Undef"
  vivify_1987:
    $P4110 = $P4109."ast"()
    $P4111 = $P4107."!make"($P4110)
    .return ($P4111)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("487_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4113
    .param pmc param_4114
.annotate 'line', 1254
    .lex "self", param_4113
    .lex "$/", param_4114
    find_lex $P4115, "$/"
    find_lex $P4116, "$/"
    unless_null $P4116, vivify_1988
    $P4116 = root_new ['parrot';'Hash']
  vivify_1988:
    set $P4117, $P4116["package_def"]
    unless_null $P4117, vivify_1989
    new $P4117, "Undef"
  vivify_1989:
    $P4118 = $P4117."ast"()
    $P4119 = $P4115."!make"($P4118)
    .return ($P4119)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("488_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4121
    .param pmc param_4122
.annotate 'line', 1255
    .lex "self", param_4121
    .lex "$/", param_4122
    find_lex $P4123, "$/"
    find_lex $P4124, "$/"
    unless_null $P4124, vivify_1990
    $P4124 = root_new ['parrot';'Hash']
  vivify_1990:
    set $P4125, $P4124["package_def"]
    unless_null $P4125, vivify_1991
    new $P4125, "Undef"
  vivify_1991:
    $P4126 = $P4125."ast"()
    $P4127 = $P4123."!make"($P4126)
    .return ($P4127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("489_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4129
    .param pmc param_4130
.annotate 'line', 1256
    .lex "self", param_4129
    .lex "$/", param_4130
    find_lex $P4131, "$/"
    find_lex $P4132, "$/"
    unless_null $P4132, vivify_1992
    $P4132 = root_new ['parrot';'Hash']
  vivify_1992:
    set $P4133, $P4132["package_def"]
    unless_null $P4133, vivify_1993
    new $P4133, "Undef"
  vivify_1993:
    $P4134 = $P4133."ast"()
    $P4135 = $P4131."!make"($P4134)
    .return ($P4135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("490_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4137
    .param pmc param_4138
.annotate 'line', 1257
    .lex "self", param_4137
    .lex "$/", param_4138
    find_lex $P4139, "$/"
    find_lex $P4140, "$/"
    unless_null $P4140, vivify_1994
    $P4140 = root_new ['parrot';'Hash']
  vivify_1994:
    set $P4141, $P4140["package_def"]
    unless_null $P4141, vivify_1995
    new $P4141, "Undef"
  vivify_1995:
    $P4142 = $P4141."ast"()
    $P4143 = $P4139."!make"($P4142)
    .return ($P4143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("491_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4145
    .param pmc param_4146
.annotate 'line', 1259
    .const 'Sub' $P4373 = "495_1304277427.017" 
    capture_lex $P4373
    .const 'Sub' $P4343 = "494_1304277427.017" 
    capture_lex $P4343
    .const 'Sub' $P4296 = "492_1304277427.017" 
    capture_lex $P4296
    .lex "self", param_4145
    .lex "$/", param_4146
.annotate 'line', 1261
    $P4147 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4147
.annotate 'line', 1262
    new $P4148, "Undef"
    .lex "$name", $P4148
.annotate 'line', 1263
    new $P4149, "Undef"
    .lex "$how", $P4149
.annotate 'line', 1266
    new $P4150, "Undef"
    .lex "$past", $P4150
.annotate 'line', 1261
    find_lex $P4151, "$/"
    unless_null $P4151, vivify_1996
    $P4151 = root_new ['parrot';'Hash']
  vivify_1996:
    set $P4152, $P4151["name"]
    unless_null $P4152, vivify_1997
    $P4152 = root_new ['parrot';'Hash']
  vivify_1997:
    set $P4153, $P4152["identifier"]
    unless_null $P4153, vivify_1998
    new $P4153, "Undef"
  vivify_1998:
    clone $P4154, $P4153
    store_lex "@ns", $P4154
.annotate 'line', 1262
    find_lex $P4155, "@ns"
    unless_null $P4155, vivify_1999
    $P4155 = root_new ['parrot';'ResizablePMCArray']
  vivify_1999:
    $P4156 = $P4155."pop"()
    set $S4157, $P4156
    new $P4158, 'String'
    set $P4158, $S4157
    store_lex "$name", $P4158
.annotate 'line', 1263
    find_dynamic_lex $P4161, "$*PKGDECL"
    unless_null $P4161, vivify_2000
    get_hll_global $P4159, "GLOBAL"
    get_who $P4160, $P4159
    set $P4161, $P4160["$PKGDECL"]
    unless_null $P4161, vivify_2001
    die "Contextual $*PKGDECL not found"
  vivify_2001:
  vivify_2000:
    find_dynamic_lex $P4164, "%*HOW"
    unless_null $P4164, vivify_2002
    get_hll_global $P4162, "GLOBAL"
    get_who $P4163, $P4162
    set $P4164, $P4163["%HOW"]
    unless_null $P4164, vivify_2003
    die "Contextual %*HOW not found"
  vivify_2003:
  vivify_2002:
    set $P4165, $P4164[$P4161]
    unless_null $P4165, vivify_2004
    new $P4165, "Undef"
  vivify_2004:
    store_lex "$how", $P4165
.annotate 'line', 1266
    find_lex $P4168, "$/"
    unless_null $P4168, vivify_2005
    $P4168 = root_new ['parrot';'Hash']
  vivify_2005:
    set $P4169, $P4168["block"]
    unless_null $P4169, vivify_2006
    new $P4169, "Undef"
  vivify_2006:
    if $P4169, if_4167
    find_lex $P4173, "$/"
    unless_null $P4173, vivify_2007
    $P4173 = root_new ['parrot';'Hash']
  vivify_2007:
    set $P4174, $P4173["comp_unit"]
    unless_null $P4174, vivify_2008
    new $P4174, "Undef"
  vivify_2008:
    $P4175 = $P4174."ast"()
    set $P4166, $P4175
    goto if_4167_end
  if_4167:
    find_lex $P4170, "$/"
    unless_null $P4170, vivify_2009
    $P4170 = root_new ['parrot';'Hash']
  vivify_2009:
    set $P4171, $P4170["block"]
    unless_null $P4171, vivify_2010
    new $P4171, "Undef"
  vivify_2010:
    $P4172 = $P4171."ast"()
    set $P4166, $P4172
  if_4167_end:
    store_lex "$past", $P4166
.annotate 'line', 1267
    find_dynamic_lex $P4181, "$*SCOPE"
    unless_null $P4181, vivify_2011
    get_hll_global $P4179, "GLOBAL"
    get_who $P4180, $P4179
    set $P4181, $P4180["$SCOPE"]
    unless_null $P4181, vivify_2012
    die "Contextual $*SCOPE not found"
  vivify_2012:
  vivify_2011:
    set $S4182, $P4181
    iseq $I4183, $S4182, "our"
    unless $I4183, unless_4178
    new $P4177, 'Integer'
    set $P4177, $I4183
    goto unless_4178_end
  unless_4178:
    find_dynamic_lex $P4186, "$*SCOPE"
    unless_null $P4186, vivify_2013
    get_hll_global $P4184, "GLOBAL"
    get_who $P4185, $P4184
    set $P4186, $P4185["$SCOPE"]
    unless_null $P4186, vivify_2014
    die "Contextual $*SCOPE not found"
  vivify_2014:
  vivify_2013:
    set $S4187, $P4186
    iseq $I4188, $S4187, ""
    new $P4177, 'Integer'
    set $P4177, $I4188
  unless_4178_end:
    unless $P4177, if_4176_end
.annotate 'line', 1268
    find_lex $P4189, "$past"
    unless_null $P4189, vivify_2015
    new $P4189, "Undef"
  vivify_2015:
    find_lex $P4190, "$/"
    unless_null $P4190, vivify_2016
    $P4190 = root_new ['parrot';'Hash']
  vivify_2016:
    set $P4191, $P4190["name"]
    unless_null $P4191, vivify_2017
    $P4191 = root_new ['parrot';'Hash']
  vivify_2017:
    set $P4192, $P4191["identifier"]
    unless_null $P4192, vivify_2018
    new $P4192, "Undef"
  vivify_2018:
    $P4189."namespace"($P4192)
  if_4176_end:
.annotate 'line', 1272
    find_dynamic_lex $P4195, "$*PACKAGE-SETUP"
    unless_null $P4195, vivify_2019
    get_hll_global $P4193, "GLOBAL"
    get_who $P4194, $P4193
    set $P4195, $P4194["$PACKAGE-SETUP"]
    unless_null $P4195, vivify_2020
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2020:
  vivify_2019:
    get_hll_global $P4196, "GLOBAL"
    nqp_get_package_through_who $P4197, $P4196, "PAST"
    get_who $P4198, $P4197
    set $P4199, $P4198["Stmts"]
.annotate 'line', 1273
    get_hll_global $P4200, "GLOBAL"
    nqp_get_package_through_who $P4201, $P4200, "PAST"
    get_who $P4202, $P4201
    set $P4203, $P4202["Op"]
.annotate 'line', 1274
    get_hll_global $P4204, "GLOBAL"
    nqp_get_package_through_who $P4205, $P4204, "PAST"
    get_who $P4206, $P4205
    set $P4207, $P4206["Var"]
    $P4208 = $P4207."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1275
    find_dynamic_lex $P4211, "$*SC"
    unless_null $P4211, vivify_2021
    get_hll_global $P4209, "GLOBAL"
    get_who $P4210, $P4209
    set $P4211, $P4210["$SC"]
    unless_null $P4211, vivify_2022
    die "Contextual $*SC not found"
  vivify_2022:
  vivify_2021:
    find_dynamic_lex $P4214, "$*PACKAGE"
    unless_null $P4214, vivify_2023
    get_hll_global $P4212, "GLOBAL"
    get_who $P4213, $P4212
    set $P4214, $P4213["$PACKAGE"]
    unless_null $P4214, vivify_2024
    die "Contextual $*PACKAGE not found"
  vivify_2024:
  vivify_2023:
    $P4215 = $P4211."get_slot_past_for_object"($P4214)
    $P4216 = $P4203."new"($P4208, $P4215, "bind" :named("pasttype"))
.annotate 'line', 1273
    $P4217 = $P4199."new"($P4216)
.annotate 'line', 1272
    $P4195."unshift"($P4217)
.annotate 'line', 1283
    find_lex $P4221, "$how"
    unless_null $P4221, vivify_2025
    new $P4221, "Undef"
  vivify_2025:
    can $I4222, $P4221, "parametric"
    if $I4222, if_4220
    new $P4219, 'Integer'
    set $P4219, $I4222
    goto if_4220_end
  if_4220:
    find_lex $P4223, "$how"
    unless_null $P4223, vivify_2026
    new $P4223, "Undef"
  vivify_2026:
    find_lex $P4224, "$how"
    unless_null $P4224, vivify_2027
    new $P4224, "Undef"
  vivify_2027:
    $P4225 = $P4223."parametric"($P4224)
    set $P4219, $P4225
  if_4220_end:
    if $P4219, if_4218
.annotate 'line', 1301
    find_lex $P4277, "$past"
    unless_null $P4277, vivify_2028
    new $P4277, "Undef"
  vivify_2028:
    $P4277."blocktype"("immediate")
.annotate 'line', 1302
    find_dynamic_lex $P4280, "$*SC"
    unless_null $P4280, vivify_2029
    get_hll_global $P4278, "GLOBAL"
    get_who $P4279, $P4278
    set $P4280, $P4279["$SC"]
    unless_null $P4280, vivify_2030
    die "Contextual $*SC not found"
  vivify_2030:
  vivify_2029:
    find_lex $P4281, "$past"
    unless_null $P4281, vivify_2031
    new $P4281, "Undef"
  vivify_2031:
    find_dynamic_lex $P4284, "$*PACKAGE"
    unless_null $P4284, vivify_2032
    get_hll_global $P4282, "GLOBAL"
    get_who $P4283, $P4282
    set $P4284, $P4283["$PACKAGE"]
    unless_null $P4284, vivify_2033
    die "Contextual $*PACKAGE not found"
  vivify_2033:
  vivify_2032:
    $P4280."install_lexical_symbol"($P4281, "$?PACKAGE", $P4284)
.annotate 'line', 1303
    find_dynamic_lex $P4287, "$*SC"
    unless_null $P4287, vivify_2034
    get_hll_global $P4285, "GLOBAL"
    get_who $P4286, $P4285
    set $P4287, $P4286["$SC"]
    unless_null $P4287, vivify_2035
    die "Contextual $*SC not found"
  vivify_2035:
  vivify_2034:
    find_lex $P4288, "$past"
    unless_null $P4288, vivify_2036
    new $P4288, "Undef"
  vivify_2036:
    find_dynamic_lex $P4291, "$*PACKAGE"
    unless_null $P4291, vivify_2037
    get_hll_global $P4289, "GLOBAL"
    get_who $P4290, $P4289
    set $P4291, $P4290["$PACKAGE"]
    unless_null $P4291, vivify_2038
    die "Contextual $*PACKAGE not found"
  vivify_2038:
  vivify_2037:
    $P4287."install_lexical_symbol"($P4288, "$?CLASS", $P4291)
.annotate 'line', 1300
    goto if_4218_end
  if_4218:
.annotate 'line', 1284
    find_lex $P4226, "$past"
    unless_null $P4226, vivify_2039
    new $P4226, "Undef"
  vivify_2039:
    $P4226."blocktype"("declaration")
.annotate 'line', 1285
    find_lex $P4227, "$past"
    unless_null $P4227, vivify_2040
    new $P4227, "Undef"
  vivify_2040:
    get_hll_global $P4228, "GLOBAL"
    nqp_get_package_through_who $P4229, $P4228, "PAST"
    get_who $P4230, $P4229
    set $P4231, $P4230["Var"]
    $P4232 = $P4231."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4227."unshift"($P4232)
.annotate 'line', 1286
    find_lex $P4233, "$past"
    unless_null $P4233, vivify_2041
    new $P4233, "Undef"
  vivify_2041:
    $P4233."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1287
    find_dynamic_lex $P4236, "$*PACKAGE-SETUP"
    unless_null $P4236, vivify_2042
    get_hll_global $P4234, "GLOBAL"
    get_who $P4235, $P4234
    set $P4236, $P4235["$PACKAGE-SETUP"]
    unless_null $P4236, vivify_2043
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2043:
  vivify_2042:
    get_hll_global $P4237, "GLOBAL"
    nqp_get_package_through_who $P4238, $P4237, "PAST"
    get_who $P4239, $P4238
    set $P4240, $P4239["Op"]
.annotate 'line', 1289
    get_hll_global $P4241, "GLOBAL"
    nqp_get_package_through_who $P4242, $P4241, "PAST"
    get_who $P4243, $P4242
    set $P4244, $P4243["Op"]
.annotate 'line', 1292
    get_hll_global $P4245, "GLOBAL"
    nqp_get_package_through_who $P4246, $P4245, "PAST"
    get_who $P4247, $P4246
    set $P4248, $P4247["Var"]
    $P4249 = $P4248."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4250 = $P4244."new"($P4249, "get_how PP" :named("pirop"))
.annotate 'line', 1294
    get_hll_global $P4251, "GLOBAL"
    nqp_get_package_through_who $P4252, $P4251, "PAST"
    get_who $P4253, $P4252
    set $P4254, $P4253["Var"]
    $P4255 = $P4254."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1295
    get_hll_global $P4256, "GLOBAL"
    nqp_get_package_through_who $P4257, $P4256, "PAST"
    get_who $P4258, $P4257
    set $P4259, $P4258["Val"]
    find_lex $P4260, "$past"
    unless_null $P4260, vivify_2044
    new $P4260, "Undef"
  vivify_2044:
    $P4261 = $P4259."new"($P4260 :named("value"))
    $P4262 = $P4240."new"($P4250, $P4255, $P4261, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1287
    $P4236."push"($P4262)
.annotate 'line', 1297
    find_dynamic_lex $P4265, "$*SC"
    unless_null $P4265, vivify_2045
    get_hll_global $P4263, "GLOBAL"
    get_who $P4264, $P4263
    set $P4265, $P4264["$SC"]
    unless_null $P4265, vivify_2046
    die "Contextual $*SC not found"
  vivify_2046:
  vivify_2045:
    find_lex $P4266, "$past"
    unless_null $P4266, vivify_2047
    new $P4266, "Undef"
  vivify_2047:
    find_dynamic_lex $P4269, "$*PACKAGE"
    unless_null $P4269, vivify_2048
    get_hll_global $P4267, "GLOBAL"
    get_who $P4268, $P4267
    set $P4269, $P4268["$PACKAGE"]
    unless_null $P4269, vivify_2049
    die "Contextual $*PACKAGE not found"
  vivify_2049:
  vivify_2048:
    $P4265."install_lexical_symbol"($P4266, "$?PACKAGE", $P4269)
.annotate 'line', 1298
    find_dynamic_lex $P4272, "$*SC"
    unless_null $P4272, vivify_2050
    get_hll_global $P4270, "GLOBAL"
    get_who $P4271, $P4270
    set $P4272, $P4271["$SC"]
    unless_null $P4272, vivify_2051
    die "Contextual $*SC not found"
  vivify_2051:
  vivify_2050:
    find_lex $P4273, "$past"
    unless_null $P4273, vivify_2052
    new $P4273, "Undef"
  vivify_2052:
    find_dynamic_lex $P4276, "$*PACKAGE"
    unless_null $P4276, vivify_2053
    get_hll_global $P4274, "GLOBAL"
    get_who $P4275, $P4274
    set $P4276, $P4275["$PACKAGE"]
    unless_null $P4276, vivify_2054
    die "Contextual $*PACKAGE not found"
  vivify_2054:
  vivify_2053:
    $P4272."install_lexical_symbol"($P4273, "$?ROLE", $P4276)
  if_4218_end:
.annotate 'line', 1307
    find_lex $P4293, "$/"
    unless_null $P4293, vivify_2055
    $P4293 = root_new ['parrot';'Hash']
  vivify_2055:
    set $P4294, $P4293["parent"]
    unless_null $P4294, vivify_2056
    new $P4294, "Undef"
  vivify_2056:
    if $P4294, if_4292
.annotate 'line', 1321
    find_lex $P4340, "$how"
    unless_null $P4340, vivify_2057
    new $P4340, "Undef"
  vivify_2057:
    can $I4341, $P4340, "set_default_parent"
    unless $I4341, if_4339_end
    .const 'Sub' $P4343 = "494_1304277427.017" 
    capture_lex $P4343
    $P4343()
  if_4339_end:
    goto if_4292_end
  if_4292:
.annotate 'line', 1307
    .const 'Sub' $P4296 = "492_1304277427.017" 
    capture_lex $P4296
    $P4296()
  if_4292_end:
.annotate 'line', 1328
    find_lex $P4365, "$/"
    unless_null $P4365, vivify_2083
    $P4365 = root_new ['parrot';'Hash']
  vivify_2083:
    set $P4366, $P4365["role"]
    unless_null $P4366, vivify_2084
    new $P4366, "Undef"
  vivify_2084:
    unless $P4366, if_4364_end
.annotate 'line', 1329
    find_lex $P4368, "$/"
    unless_null $P4368, vivify_2085
    $P4368 = root_new ['parrot';'Hash']
  vivify_2085:
    set $P4369, $P4368["role"]
    unless_null $P4369, vivify_2086
    new $P4369, "Undef"
  vivify_2086:
    defined $I4370, $P4369
    unless $I4370, for_undef_2087
    iter $P4367, $P4369
    new $P4414, 'ExceptionHandler'
    set_label $P4414, loop4413_handler
    $P4414."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4414
  loop4413_test:
    unless $P4367, loop4413_done
    shift $P4371, $P4367
  loop4413_redo:
    .const 'Sub' $P4373 = "495_1304277427.017" 
    capture_lex $P4373
    $P4373($P4371)
  loop4413_next:
    goto loop4413_test
  loop4413_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4415, exception, 'type'
    eq $P4415, .CONTROL_LOOP_NEXT, loop4413_next
    eq $P4415, .CONTROL_LOOP_REDO, loop4413_redo
  loop4413_done:
    pop_eh 
  for_undef_2087:
  if_4364_end:
.annotate 'line', 1346
    find_dynamic_lex $P4418, "$*PACKAGE-SETUP"
    unless_null $P4418, vivify_2101
    get_hll_global $P4416, "GLOBAL"
    get_who $P4417, $P4416
    set $P4418, $P4417["$PACKAGE-SETUP"]
    unless_null $P4418, vivify_2102
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2102:
  vivify_2101:
    get_hll_global $P4419, "GLOBAL"
    nqp_get_package_through_who $P4420, $P4419, "PAST"
    get_who $P4421, $P4420
    set $P4422, $P4421["Op"]
.annotate 'line', 1348
    get_hll_global $P4423, "GLOBAL"
    nqp_get_package_through_who $P4424, $P4423, "PAST"
    get_who $P4425, $P4424
    set $P4426, $P4425["Op"]
.annotate 'line', 1351
    get_hll_global $P4427, "GLOBAL"
    nqp_get_package_through_who $P4428, $P4427, "PAST"
    get_who $P4429, $P4428
    set $P4430, $P4429["Var"]
    $P4431 = $P4430."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4432 = $P4426."new"($P4431, "get_how PP" :named("pirop"))
.annotate 'line', 1353
    get_hll_global $P4433, "GLOBAL"
    nqp_get_package_through_who $P4434, $P4433, "PAST"
    get_who $P4435, $P4434
    set $P4436, $P4435["Var"]
    $P4437 = $P4436."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4438 = $P4422."new"($P4432, $P4437, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1346
    $P4418."push"($P4438)
.annotate 'line', 1357
    find_lex $P4439, "$past"
    unless_null $P4439, vivify_2103
    new $P4439, "Undef"
  vivify_2103:
    $P4440 = $P4439."loadinit"()
    get_hll_global $P4441, "GLOBAL"
    nqp_get_package_through_who $P4442, $P4441, "PAST"
    get_who $P4443, $P4442
    set $P4444, $P4443["Block"]
    find_dynamic_lex $P4447, "$*PACKAGE-SETUP"
    unless_null $P4447, vivify_2104
    get_hll_global $P4445, "GLOBAL"
    get_who $P4446, $P4445
    set $P4447, $P4446["$PACKAGE-SETUP"]
    unless_null $P4447, vivify_2105
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2105:
  vivify_2104:
    $P4448 = $P4444."new"($P4447, "immediate" :named("blocktype"))
    $P4440."push"($P4448)
.annotate 'line', 1359
    find_lex $P4449, "$/"
    find_lex $P4450, "$past"
    unless_null $P4450, vivify_2106
    new $P4450, "Undef"
  vivify_2106:
    $P4451 = $P4449."!make"($P4450)
.annotate 'line', 1259
    .return ($P4451)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4342"  :anon :subid("494_1304277427.017") :outer("491_1304277427.017")
.annotate 'line', 1322
    new $P4344, "Undef"
    .lex "$default", $P4344
    find_dynamic_lex $P4349, "$*PKGDECL"
    unless_null $P4349, vivify_2058
    get_hll_global $P4347, "GLOBAL"
    get_who $P4348, $P4347
    set $P4349, $P4348["$PKGDECL"]
    unless_null $P4349, vivify_2059
    die "Contextual $*PKGDECL not found"
  vivify_2059:
  vivify_2058:
    set $S4350, $P4349
    iseq $I4351, $S4350, "grammar"
    if $I4351, if_4346
    new $P4353, "ResizablePMCArray"
    push $P4353, "NQPMu"
    set $P4345, $P4353
    goto if_4346_end
  if_4346:
    new $P4352, "ResizablePMCArray"
    push $P4352, "Regex"
    push $P4352, "Cursor"
    set $P4345, $P4352
  if_4346_end:
    store_lex "$default", $P4345
.annotate 'line', 1323
    find_dynamic_lex $P4356, "$*SC"
    unless_null $P4356, vivify_2060
    get_hll_global $P4354, "GLOBAL"
    get_who $P4355, $P4354
    set $P4356, $P4355["$SC"]
    unless_null $P4356, vivify_2061
    die "Contextual $*SC not found"
  vivify_2061:
  vivify_2060:
    find_dynamic_lex $P4359, "$*PACKAGE"
    unless_null $P4359, vivify_2062
    get_hll_global $P4357, "GLOBAL"
    get_who $P4358, $P4357
    set $P4359, $P4358["$PACKAGE"]
    unless_null $P4359, vivify_2063
    die "Contextual $*PACKAGE not found"
  vivify_2063:
  vivify_2062:
.annotate 'line', 1324
    find_lex $P4360, "$default"
    unless_null $P4360, vivify_2064
    new $P4360, "Undef"
  vivify_2064:
    find_lex $P4361, "$/"
    unless_null $P4361, vivify_2065
    new $P4361, "Undef"
  vivify_2065:
    $P4362 = "find_sym"($P4360, $P4361)
    $P4363 = $P4356."pkg_add_parent_or_role"($P4359, "set_default_parent", $P4362)
.annotate 'line', 1321
    .return ($P4363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4295"  :anon :subid("492_1304277427.017") :outer("491_1304277427.017")
.annotate 'line', 1307
    .const 'Sub' $P4302 = "493_1304277427.017" 
    capture_lex $P4302
.annotate 'line', 1308
    new $P4297, "Undef"
    .lex "$parent", $P4297
.annotate 'line', 1309
    new $P4298, "Undef"
    .lex "$parent_found", $P4298
.annotate 'line', 1307
    find_lex $P4299, "$parent"
    unless_null $P4299, vivify_2066
    new $P4299, "Undef"
  vivify_2066:
    find_lex $P4300, "$parent_found"
    unless_null $P4300, vivify_2067
    new $P4300, "Undef"
  vivify_2067:
.annotate 'line', 1310
    .const 'Sub' $P4302 = "493_1304277427.017" 
    capture_lex $P4302
    $P4302()
.annotate 'line', 1314
    find_lex $P4320, "$parent_found"
    unless_null $P4320, vivify_2073
    new $P4320, "Undef"
  vivify_2073:
    if $P4320, if_4319
.annotate 'line', 1318
    find_lex $P4329, "$/"
    unless_null $P4329, vivify_2074
    new $P4329, "Undef"
  vivify_2074:
    $P4330 = $P4329."CURSOR"()
    new $P4331, "String"
    assign $P4331, "Could not find parent class '"
    find_lex $P4332, "$/"
    unless_null $P4332, vivify_2075
    $P4332 = root_new ['parrot';'Hash']
  vivify_2075:
    set $P4333, $P4332["parent"]
    unless_null $P4333, vivify_2076
    $P4333 = root_new ['parrot';'ResizablePMCArray']
  vivify_2076:
    set $P4334, $P4333[0]
    unless_null $P4334, vivify_2077
    new $P4334, "Undef"
  vivify_2077:
    set $S4335, $P4334
    concat $P4336, $P4331, $S4335
    concat $P4337, $P4336, "'"
    $P4338 = $P4330."panic"($P4337)
.annotate 'line', 1317
    set $P4318, $P4338
.annotate 'line', 1314
    goto if_4319_end
  if_4319:
.annotate 'line', 1315
    find_dynamic_lex $P4323, "$*SC"
    unless_null $P4323, vivify_2078
    get_hll_global $P4321, "GLOBAL"
    get_who $P4322, $P4321
    set $P4323, $P4322["$SC"]
    unless_null $P4323, vivify_2079
    die "Contextual $*SC not found"
  vivify_2079:
  vivify_2078:
    find_dynamic_lex $P4326, "$*PACKAGE"
    unless_null $P4326, vivify_2080
    get_hll_global $P4324, "GLOBAL"
    get_who $P4325, $P4324
    set $P4326, $P4325["$PACKAGE"]
    unless_null $P4326, vivify_2081
    die "Contextual $*PACKAGE not found"
  vivify_2081:
  vivify_2080:
    find_lex $P4327, "$parent"
    unless_null $P4327, vivify_2082
    new $P4327, "Undef"
  vivify_2082:
    $P4328 = $P4323."pkg_add_parent_or_role"($P4326, "add_parent", $P4327)
.annotate 'line', 1314
    set $P4318, $P4328
  if_4319_end:
.annotate 'line', 1307
    .return ($P4318)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4301"  :anon :subid("493_1304277427.017") :outer("492_1304277427.017")
.annotate 'line', 1310
    new $P4313, 'ExceptionHandler'
    set_label $P4313, control_4312
    $P4313."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4313
.annotate 'line', 1311
    find_lex $P4303, "$/"
    unless_null $P4303, vivify_2068
    $P4303 = root_new ['parrot';'Hash']
  vivify_2068:
    set $P4304, $P4303["parent"]
    unless_null $P4304, vivify_2069
    $P4304 = root_new ['parrot';'ResizablePMCArray']
  vivify_2069:
    set $P4305, $P4304[0]
    unless_null $P4305, vivify_2070
    $P4305 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P4306, $P4305["identifier"]
    unless_null $P4306, vivify_2071
    new $P4306, "Undef"
  vivify_2071:
    clone $P4307, $P4306
    find_lex $P4308, "$/"
    unless_null $P4308, vivify_2072
    new $P4308, "Undef"
  vivify_2072:
    $P4309 = "find_sym"($P4307, $P4308)
    store_lex "$parent", $P4309
.annotate 'line', 1312
    new $P4310, "Integer"
    assign $P4310, 1
    store_lex "$parent_found", $P4310
.annotate 'line', 1310
    pop_eh 
    goto skip_handler_4311
  control_4312:
    .local pmc exception 
    .get_results (exception) 
    new $P4316, 'Integer'
    set $P4316, 1
    set exception["handled"], $P4316
    set $I4317, exception["handled"]
    ne $I4317, 1, nothandled_4315
  handled_4314:
    .return (exception)
  nothandled_4315:
    rethrow exception
  skip_handler_4311:
    .return ($P4310)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4372"  :anon :subid("495_1304277427.017") :outer("491_1304277427.017")
    .param pmc param_4376
.annotate 'line', 1329
    .const 'Sub' $P4380 = "496_1304277427.017" 
    capture_lex $P4380
.annotate 'line', 1330
    new $P4374, "Undef"
    .lex "$role", $P4374
.annotate 'line', 1331
    new $P4375, "Undef"
    .lex "$role_found", $P4375
    .lex "$_", param_4376
.annotate 'line', 1329
    find_lex $P4377, "$role"
    unless_null $P4377, vivify_2088
    new $P4377, "Undef"
  vivify_2088:
    find_lex $P4378, "$role_found"
    unless_null $P4378, vivify_2089
    new $P4378, "Undef"
  vivify_2089:
.annotate 'line', 1332
    .const 'Sub' $P4380 = "496_1304277427.017" 
    capture_lex $P4380
    $P4380()
.annotate 'line', 1336
    find_lex $P4396, "$role_found"
    unless_null $P4396, vivify_2093
    new $P4396, "Undef"
  vivify_2093:
    if $P4396, if_4395
.annotate 'line', 1340
    find_lex $P4405, "$/"
    unless_null $P4405, vivify_2094
    new $P4405, "Undef"
  vivify_2094:
    $P4406 = $P4405."CURSOR"()
    new $P4407, "String"
    assign $P4407, "Could not find role '"
    find_lex $P4408, "$_"
    unless_null $P4408, vivify_2095
    new $P4408, "Undef"
  vivify_2095:
    set $S4409, $P4408
    concat $P4410, $P4407, $S4409
    concat $P4411, $P4410, "'"
    $P4412 = $P4406."panic"($P4411)
.annotate 'line', 1339
    set $P4394, $P4412
.annotate 'line', 1336
    goto if_4395_end
  if_4395:
.annotate 'line', 1337
    find_dynamic_lex $P4399, "$*SC"
    unless_null $P4399, vivify_2096
    get_hll_global $P4397, "GLOBAL"
    get_who $P4398, $P4397
    set $P4399, $P4398["$SC"]
    unless_null $P4399, vivify_2097
    die "Contextual $*SC not found"
  vivify_2097:
  vivify_2096:
    find_dynamic_lex $P4402, "$*PACKAGE"
    unless_null $P4402, vivify_2098
    get_hll_global $P4400, "GLOBAL"
    get_who $P4401, $P4400
    set $P4402, $P4401["$PACKAGE"]
    unless_null $P4402, vivify_2099
    die "Contextual $*PACKAGE not found"
  vivify_2099:
  vivify_2098:
    find_lex $P4403, "$role"
    unless_null $P4403, vivify_2100
    new $P4403, "Undef"
  vivify_2100:
    $P4404 = $P4399."pkg_add_parent_or_role"($P4402, "add_role", $P4403)
.annotate 'line', 1336
    set $P4394, $P4404
  if_4395_end:
.annotate 'line', 1329
    .return ($P4394)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4379"  :anon :subid("496_1304277427.017") :outer("495_1304277427.017")
.annotate 'line', 1332
    new $P4389, 'ExceptionHandler'
    set_label $P4389, control_4388
    $P4389."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4389
.annotate 'line', 1333
    find_lex $P4381, "$_"
    unless_null $P4381, vivify_2090
    $P4381 = root_new ['parrot';'Hash']
  vivify_2090:
    set $P4382, $P4381["identifier"]
    unless_null $P4382, vivify_2091
    new $P4382, "Undef"
  vivify_2091:
    clone $P4383, $P4382
    find_lex $P4384, "$/"
    unless_null $P4384, vivify_2092
    new $P4384, "Undef"
  vivify_2092:
    $P4385 = "find_sym"($P4383, $P4384)
    store_lex "$role", $P4385
.annotate 'line', 1334
    new $P4386, "Integer"
    assign $P4386, 1
    store_lex "$role_found", $P4386
.annotate 'line', 1332
    pop_eh 
    goto skip_handler_4387
  control_4388:
    .local pmc exception 
    .get_results (exception) 
    new $P4392, 'Integer'
    set $P4392, 1
    set exception["handled"], $P4392
    set $I4393, exception["handled"]
    ne $I4393, 1, nothandled_4391
  handled_4390:
    .return (exception)
  nothandled_4391:
    rethrow exception
  skip_handler_4387:
    .return ($P4386)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("497_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4453
    .param pmc param_4454
.annotate 'line', 1362
    .lex "self", param_4453
    .lex "$/", param_4454
    find_lex $P4455, "$/"
    find_lex $P4456, "$/"
    unless_null $P4456, vivify_2107
    $P4456 = root_new ['parrot';'Hash']
  vivify_2107:
    set $P4457, $P4456["scoped"]
    unless_null $P4457, vivify_2108
    new $P4457, "Undef"
  vivify_2108:
    $P4458 = $P4457."ast"()
    $P4459 = $P4455."!make"($P4458)
    .return ($P4459)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("498_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4461
    .param pmc param_4462
.annotate 'line', 1363
    .lex "self", param_4461
    .lex "$/", param_4462
    find_lex $P4463, "$/"
    find_lex $P4464, "$/"
    unless_null $P4464, vivify_2109
    $P4464 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4465, $P4464["scoped"]
    unless_null $P4465, vivify_2110
    new $P4465, "Undef"
  vivify_2110:
    $P4466 = $P4465."ast"()
    $P4467 = $P4463."!make"($P4466)
    .return ($P4467)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("499_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4469
    .param pmc param_4470
.annotate 'line', 1364
    .lex "self", param_4469
    .lex "$/", param_4470
    find_lex $P4471, "$/"
    find_lex $P4472, "$/"
    unless_null $P4472, vivify_2111
    $P4472 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P4473, $P4472["scoped"]
    unless_null $P4473, vivify_2112
    new $P4473, "Undef"
  vivify_2112:
    $P4474 = $P4473."ast"()
    $P4475 = $P4471."!make"($P4474)
    .return ($P4475)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("500_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4477
    .param pmc param_4478
.annotate 'line', 1366
    .lex "self", param_4477
    .lex "$/", param_4478
.annotate 'line', 1367
    find_lex $P4479, "$/"
    find_lex $P4482, "$/"
    unless_null $P4482, vivify_2113
    $P4482 = root_new ['parrot';'Hash']
  vivify_2113:
    set $P4483, $P4482["declarator"]
    unless_null $P4483, vivify_2114
    new $P4483, "Undef"
  vivify_2114:
    if $P4483, if_4481
.annotate 'line', 1368
    find_lex $P4489, "$/"
    unless_null $P4489, vivify_2115
    $P4489 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P4490, $P4489["multi_declarator"]
    unless_null $P4490, vivify_2116
    new $P4490, "Undef"
  vivify_2116:
    if $P4490, if_4488
.annotate 'line', 1369
    find_lex $P4494, "$/"
    unless_null $P4494, vivify_2117
    $P4494 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P4495, $P4494["package_declarator"]
    unless_null $P4495, vivify_2118
    new $P4495, "Undef"
  vivify_2118:
    $P4496 = $P4495."ast"()
    set $P4487, $P4496
.annotate 'line', 1368
    goto if_4488_end
  if_4488:
    find_lex $P4491, "$/"
    unless_null $P4491, vivify_2119
    $P4491 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4492, $P4491["multi_declarator"]
    unless_null $P4492, vivify_2120
    new $P4492, "Undef"
  vivify_2120:
    $P4493 = $P4492."ast"()
    set $P4487, $P4493
  if_4488_end:
    set $P4480, $P4487
.annotate 'line', 1367
    goto if_4481_end
  if_4481:
    find_lex $P4484, "$/"
    unless_null $P4484, vivify_2121
    $P4484 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P4485, $P4484["declarator"]
    unless_null $P4485, vivify_2122
    new $P4485, "Undef"
  vivify_2122:
    $P4486 = $P4485."ast"()
    set $P4480, $P4486
  if_4481_end:
    $P4497 = $P4479."!make"($P4480)
.annotate 'line', 1366
    .return ($P4497)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("501_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4499
    .param pmc param_4500
.annotate 'line', 1372
    .lex "self", param_4499
    .lex "$/", param_4500
.annotate 'line', 1373
    find_lex $P4501, "$/"
.annotate 'line', 1374
    find_lex $P4504, "$/"
    unless_null $P4504, vivify_2123
    $P4504 = root_new ['parrot';'Hash']
  vivify_2123:
    set $P4505, $P4504["routine_declarator"]
    unless_null $P4505, vivify_2124
    new $P4505, "Undef"
  vivify_2124:
    if $P4505, if_4503
.annotate 'line', 1375
    find_lex $P4509, "$/"
    unless_null $P4509, vivify_2125
    $P4509 = root_new ['parrot';'Hash']
  vivify_2125:
    set $P4510, $P4509["variable_declarator"]
    unless_null $P4510, vivify_2126
    new $P4510, "Undef"
  vivify_2126:
    $P4511 = $P4510."ast"()
    set $P4502, $P4511
.annotate 'line', 1374
    goto if_4503_end
  if_4503:
    find_lex $P4506, "$/"
    unless_null $P4506, vivify_2127
    $P4506 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P4507, $P4506["routine_declarator"]
    unless_null $P4507, vivify_2128
    new $P4507, "Undef"
  vivify_2128:
    $P4508 = $P4507."ast"()
    set $P4502, $P4508
  if_4503_end:
    $P4512 = $P4501."!make"($P4502)
.annotate 'line', 1372
    .return ($P4512)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("502_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4514
    .param pmc param_4515
.annotate 'line', 1378
    .lex "self", param_4514
    .lex "$/", param_4515
    find_lex $P4516, "$/"
    find_lex $P4519, "$/"
    unless_null $P4519, vivify_2129
    $P4519 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P4520, $P4519["declarator"]
    unless_null $P4520, vivify_2130
    new $P4520, "Undef"
  vivify_2130:
    if $P4520, if_4518
    find_lex $P4524, "$/"
    unless_null $P4524, vivify_2131
    $P4524 = root_new ['parrot';'Hash']
  vivify_2131:
    set $P4525, $P4524["routine_def"]
    unless_null $P4525, vivify_2132
    new $P4525, "Undef"
  vivify_2132:
    $P4526 = $P4525."ast"()
    set $P4517, $P4526
    goto if_4518_end
  if_4518:
    find_lex $P4521, "$/"
    unless_null $P4521, vivify_2133
    $P4521 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P4522, $P4521["declarator"]
    unless_null $P4522, vivify_2134
    new $P4522, "Undef"
  vivify_2134:
    $P4523 = $P4522."ast"()
    set $P4517, $P4523
  if_4518_end:
    $P4527 = $P4516."!make"($P4517)
    .return ($P4527)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("503_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4529
    .param pmc param_4530
.annotate 'line', 1379
    .lex "self", param_4529
    .lex "$/", param_4530
    find_lex $P4531, "$/"
    find_lex $P4534, "$/"
    unless_null $P4534, vivify_2135
    $P4534 = root_new ['parrot';'Hash']
  vivify_2135:
    set $P4535, $P4534["declarator"]
    unless_null $P4535, vivify_2136
    new $P4535, "Undef"
  vivify_2136:
    if $P4535, if_4533
    find_lex $P4539, "$/"
    unless_null $P4539, vivify_2137
    $P4539 = root_new ['parrot';'Hash']
  vivify_2137:
    set $P4540, $P4539["routine_def"]
    unless_null $P4540, vivify_2138
    new $P4540, "Undef"
  vivify_2138:
    $P4541 = $P4540."ast"()
    set $P4532, $P4541
    goto if_4533_end
  if_4533:
    find_lex $P4536, "$/"
    unless_null $P4536, vivify_2139
    $P4536 = root_new ['parrot';'Hash']
  vivify_2139:
    set $P4537, $P4536["declarator"]
    unless_null $P4537, vivify_2140
    new $P4537, "Undef"
  vivify_2140:
    $P4538 = $P4537."ast"()
    set $P4532, $P4538
  if_4533_end:
    $P4542 = $P4531."!make"($P4532)
    .return ($P4542)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("504_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4544
    .param pmc param_4545
.annotate 'line', 1380
    .lex "self", param_4544
    .lex "$/", param_4545
    find_lex $P4546, "$/"
    find_lex $P4547, "$/"
    unless_null $P4547, vivify_2141
    $P4547 = root_new ['parrot';'Hash']
  vivify_2141:
    set $P4548, $P4547["declarator"]
    unless_null $P4548, vivify_2142
    new $P4548, "Undef"
  vivify_2142:
    $P4549 = $P4548."ast"()
    $P4550 = $P4546."!make"($P4549)
    .return ($P4550)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("505_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4552
    .param pmc param_4553
.annotate 'line', 1383
    .const 'Sub' $P4587 = "506_1304277427.017" 
    capture_lex $P4587
    .lex "self", param_4552
    .lex "$/", param_4553
.annotate 'line', 1384
    new $P4554, "Undef"
    .lex "$past", $P4554
.annotate 'line', 1385
    new $P4555, "Undef"
    .lex "$sigil", $P4555
.annotate 'line', 1386
    new $P4556, "Undef"
    .lex "$name", $P4556
.annotate 'line', 1387
    new $P4557, "Undef"
    .lex "$BLOCK", $P4557
.annotate 'line', 1384
    find_lex $P4558, "$/"
    unless_null $P4558, vivify_2143
    $P4558 = root_new ['parrot';'Hash']
  vivify_2143:
    set $P4559, $P4558["variable"]
    unless_null $P4559, vivify_2144
    new $P4559, "Undef"
  vivify_2144:
    $P4560 = $P4559."ast"()
    store_lex "$past", $P4560
.annotate 'line', 1385
    find_lex $P4561, "$/"
    unless_null $P4561, vivify_2145
    $P4561 = root_new ['parrot';'Hash']
  vivify_2145:
    set $P4562, $P4561["variable"]
    unless_null $P4562, vivify_2146
    $P4562 = root_new ['parrot';'Hash']
  vivify_2146:
    set $P4563, $P4562["sigil"]
    unless_null $P4563, vivify_2147
    new $P4563, "Undef"
  vivify_2147:
    store_lex "$sigil", $P4563
.annotate 'line', 1386
    find_lex $P4564, "$past"
    unless_null $P4564, vivify_2148
    new $P4564, "Undef"
  vivify_2148:
    $P4565 = $P4564."name"()
    store_lex "$name", $P4565
.annotate 'line', 1387
    find_lex $P4566, "$?PACKAGE"
    get_who $P4567, $P4566
    set $P4568, $P4567["@BLOCK"]
    unless_null $P4568, vivify_2149
    $P4568 = root_new ['parrot';'ResizablePMCArray']
  vivify_2149:
    set $P4569, $P4568[0]
    unless_null $P4569, vivify_2150
    new $P4569, "Undef"
  vivify_2150:
    store_lex "$BLOCK", $P4569
.annotate 'line', 1388
    find_lex $P4573, "$name"
    unless_null $P4573, vivify_2151
    new $P4573, "Undef"
  vivify_2151:
    if $P4573, if_4572
    set $P4571, $P4573
    goto if_4572_end
  if_4572:
    find_lex $P4574, "$BLOCK"
    unless_null $P4574, vivify_2152
    new $P4574, "Undef"
  vivify_2152:
    find_lex $P4575, "$name"
    unless_null $P4575, vivify_2153
    new $P4575, "Undef"
  vivify_2153:
    $P4576 = $P4574."symbol"($P4575)
    set $P4571, $P4576
  if_4572_end:
    unless $P4571, if_4570_end
.annotate 'line', 1389
    find_lex $P4577, "$/"
    unless_null $P4577, vivify_2154
    new $P4577, "Undef"
  vivify_2154:
    $P4578 = $P4577."CURSOR"()
    find_lex $P4579, "$name"
    unless_null $P4579, vivify_2155
    new $P4579, "Undef"
  vivify_2155:
    $P4578."panic"("Redeclaration of symbol ", $P4579)
  if_4570_end:
.annotate 'line', 1391
    find_dynamic_lex $P4583, "$*SCOPE"
    unless_null $P4583, vivify_2156
    get_hll_global $P4581, "GLOBAL"
    get_who $P4582, $P4581
    set $P4583, $P4582["$SCOPE"]
    unless_null $P4583, vivify_2157
    die "Contextual $*SCOPE not found"
  vivify_2157:
  vivify_2156:
    set $S4584, $P4583
    iseq $I4585, $S4584, "has"
    if $I4585, if_4580
.annotate 'line', 1411
    find_dynamic_lex $P4644, "$*SCOPE"
    unless_null $P4644, vivify_2158
    get_hll_global $P4642, "GLOBAL"
    get_who $P4643, $P4642
    set $P4644, $P4643["$SCOPE"]
    unless_null $P4644, vivify_2159
    die "Contextual $*SCOPE not found"
  vivify_2159:
  vivify_2158:
    set $S4645, $P4644
    iseq $I4646, $S4645, "our"
    if $I4646, if_4641
.annotate 'line', 1421
    find_lex $P4660, "$BLOCK"
    unless_null $P4660, vivify_2160
    $P4660 = root_new ['parrot';'ResizablePMCArray']
  vivify_2160:
    set $P4661, $P4660[0]
    unless_null $P4661, vivify_2161
    new $P4661, "Undef"
  vivify_2161:
    get_hll_global $P4662, "GLOBAL"
    nqp_get_package_through_who $P4663, $P4662, "PAST"
    get_who $P4664, $P4663
    set $P4665, $P4664["Var"]
    find_lex $P4666, "$name"
    unless_null $P4666, vivify_2162
    new $P4666, "Undef"
  vivify_2162:
.annotate 'line', 1423
    find_lex $P4667, "$sigil"
    unless_null $P4667, vivify_2163
    new $P4667, "Undef"
  vivify_2163:
    $P4668 = "vivitype"($P4667)
    find_lex $P4669, "$/"
    unless_null $P4669, vivify_2164
    new $P4669, "Undef"
  vivify_2164:
    $P4670 = $P4665."new"($P4666 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4668 :named("viviself"), $P4669 :named("node"))
.annotate 'line', 1421
    $P4661."push"($P4670)
.annotate 'line', 1426
    find_lex $P4671, "$BLOCK"
    unless_null $P4671, vivify_2165
    new $P4671, "Undef"
  vivify_2165:
    find_lex $P4672, "$name"
    unless_null $P4672, vivify_2166
    new $P4672, "Undef"
  vivify_2166:
    $P4671."symbol"($P4672, "lexical" :named("scope"))
.annotate 'line', 1420
    goto if_4641_end
  if_4641:
.annotate 'line', 1415
    find_lex $P4647, "$/"
    unless_null $P4647, vivify_2167
    $P4647 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P4648, $P4647["variable"]
    unless_null $P4648, vivify_2168
    new $P4648, "Undef"
  vivify_2168:
    set $S4649, $P4648
    new $P4650, 'String'
    set $P4650, $S4649
    store_lex "$name", $P4650
.annotate 'line', 1416
    find_lex $P4651, "$name"
    unless_null $P4651, vivify_2169
    new $P4651, "Undef"
  vivify_2169:
    new $P4652, "ResizablePMCArray"
    push $P4652, $P4651
    find_lex $P4653, "$/"
    unless_null $P4653, vivify_2170
    new $P4653, "Undef"
  vivify_2170:
    $P4654 = "lexical_package_lookup"($P4652, $P4653)
    store_lex "$past", $P4654
.annotate 'line', 1417
    find_lex $P4655, "$past"
    unless_null $P4655, vivify_2171
    new $P4655, "Undef"
  vivify_2171:
    find_lex $P4656, "$sigil"
    unless_null $P4656, vivify_2172
    new $P4656, "Undef"
  vivify_2172:
    $P4657 = "vivitype"($P4656)
    $P4655."viviself"($P4657)
.annotate 'line', 1418
    find_lex $P4658, "$BLOCK"
    unless_null $P4658, vivify_2173
    new $P4658, "Undef"
  vivify_2173:
    find_lex $P4659, "$name"
    unless_null $P4659, vivify_2174
    new $P4659, "Undef"
  vivify_2174:
    $P4658."symbol"($P4659, "package" :named("scope"))
  if_4641_end:
.annotate 'line', 1411
    goto if_4580_end
  if_4580:
.annotate 'line', 1391
    .const 'Sub' $P4587 = "506_1304277427.017" 
    capture_lex $P4587
    $P4587()
  if_4580_end:
.annotate 'line', 1428
    find_lex $P4673, "$/"
    find_lex $P4674, "$past"
    unless_null $P4674, vivify_2204
    new $P4674, "Undef"
  vivify_2204:
    $P4675 = $P4673."!make"($P4674)
.annotate 'line', 1383
    .return ($P4675)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4586"  :anon :subid("506_1304277427.017") :outer("505_1304277427.017")
.annotate 'line', 1398
    $P4588 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P4588
.annotate 'line', 1399
    $P4589 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P4589
.annotate 'line', 1393
    find_dynamic_lex $P4596, "$*PKGDECL"
    unless_null $P4596, vivify_2175
    get_hll_global $P4594, "GLOBAL"
    get_who $P4595, $P4594
    set $P4596, $P4595["$PKGDECL"]
    unless_null $P4596, vivify_2176
    die "Contextual $*PKGDECL not found"
  vivify_2176:
  vivify_2175:
    concat $P4597, $P4596, "-attr"
    find_dynamic_lex $P4593, "%*HOW"
    unless_null $P4593, vivify_2177
    get_hll_global $P4591, "GLOBAL"
    get_who $P4592, $P4591
    set $P4593, $P4592["%HOW"]
    unless_null $P4593, vivify_2178
    die "Contextual %*HOW not found"
  vivify_2178:
  vivify_2177:
    exists $I4598, $P4593[$P4597]
    if $I4598, unless_4590_end
.annotate 'line', 1394
    find_lex $P4599, "$/"
    unless_null $P4599, vivify_2179
    new $P4599, "Undef"
  vivify_2179:
    $P4600 = $P4599."CURSOR"()
    find_dynamic_lex $P4603, "$*PKGDECL"
    unless_null $P4603, vivify_2180
    get_hll_global $P4601, "GLOBAL"
    get_who $P4602, $P4601
    set $P4603, $P4602["$PKGDECL"]
    unless_null $P4603, vivify_2181
    die "Contextual $*PKGDECL not found"
  vivify_2181:
  vivify_2180:
    concat $P4604, $P4603, " packages do not support attributes"
    $P4600."panic"($P4604)
  unless_4590_end:
.annotate 'line', 1393
    find_lex $P4605, "%lit_args"
    unless_null $P4605, vivify_2182
    $P4605 = root_new ['parrot';'Hash']
  vivify_2182:
    find_lex $P4606, "%obj_args"
    unless_null $P4606, vivify_2183
    $P4606 = root_new ['parrot';'Hash']
  vivify_2183:
.annotate 'line', 1400
    find_lex $P4607, "$name"
    unless_null $P4607, vivify_2184
    new $P4607, "Undef"
  vivify_2184:
    find_lex $P4608, "%lit_args"
    unless_null $P4608, vivify_2185
    $P4608 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P4608
  vivify_2185:
    set $P4608["name"], $P4607
.annotate 'line', 1401
    find_lex $P4610, "$/"
    unless_null $P4610, vivify_2186
    $P4610 = root_new ['parrot';'Hash']
  vivify_2186:
    set $P4611, $P4610["typename"]
    unless_null $P4611, vivify_2187
    new $P4611, "Undef"
  vivify_2187:
    unless $P4611, if_4609_end
.annotate 'line', 1402
    find_lex $P4612, "$/"
    unless_null $P4612, vivify_2188
    $P4612 = root_new ['parrot';'Hash']
  vivify_2188:
    set $P4613, $P4612["typename"]
    unless_null $P4613, vivify_2189
    $P4613 = root_new ['parrot';'ResizablePMCArray']
  vivify_2189:
    set $P4614, $P4613[0]
    unless_null $P4614, vivify_2190
    new $P4614, "Undef"
  vivify_2190:
    set $S4615, $P4614
    new $P4616, "ResizablePMCArray"
    push $P4616, $S4615
    find_lex $P4617, "$/"
    unless_null $P4617, vivify_2191
    new $P4617, "Undef"
  vivify_2191:
    $P4618 = "find_sym"($P4616, $P4617)
    find_lex $P4619, "%obj_args"
    unless_null $P4619, vivify_2192
    $P4619 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P4619
  vivify_2192:
    set $P4619["type"], $P4618
  if_4609_end:
.annotate 'line', 1406
    find_dynamic_lex $P4622, "$*SC"
    unless_null $P4622, vivify_2193
    get_hll_global $P4620, "GLOBAL"
    get_who $P4621, $P4620
    set $P4622, $P4621["$SC"]
    unless_null $P4622, vivify_2194
    die "Contextual $*SC not found"
  vivify_2194:
  vivify_2193:
    find_dynamic_lex $P4625, "$*PACKAGE"
    unless_null $P4625, vivify_2195
    get_hll_global $P4623, "GLOBAL"
    get_who $P4624, $P4623
    set $P4625, $P4624["$PACKAGE"]
    unless_null $P4625, vivify_2196
    die "Contextual $*PACKAGE not found"
  vivify_2196:
  vivify_2195:
    find_dynamic_lex $P4628, "$*PKGDECL"
    unless_null $P4628, vivify_2197
    get_hll_global $P4626, "GLOBAL"
    get_who $P4627, $P4626
    set $P4628, $P4627["$PKGDECL"]
    unless_null $P4628, vivify_2198
    die "Contextual $*PKGDECL not found"
  vivify_2198:
  vivify_2197:
    concat $P4629, $P4628, "-attr"
    find_dynamic_lex $P4632, "%*HOW"
    unless_null $P4632, vivify_2199
    get_hll_global $P4630, "GLOBAL"
    get_who $P4631, $P4630
    set $P4632, $P4631["%HOW"]
    unless_null $P4632, vivify_2200
    die "Contextual %*HOW not found"
  vivify_2200:
  vivify_2199:
    set $P4633, $P4632[$P4629]
    unless_null $P4633, vivify_2201
    new $P4633, "Undef"
  vivify_2201:
    find_lex $P4634, "%lit_args"
    unless_null $P4634, vivify_2202
    $P4634 = root_new ['parrot';'Hash']
  vivify_2202:
    find_lex $P4635, "%obj_args"
    unless_null $P4635, vivify_2203
    $P4635 = root_new ['parrot';'Hash']
  vivify_2203:
    $P4622."pkg_add_attribute"($P4625, $P4633, $P4634, $P4635)
.annotate 'line', 1409
    get_hll_global $P4636, "GLOBAL"
    nqp_get_package_through_who $P4637, $P4636, "PAST"
    get_who $P4638, $P4637
    set $P4639, $P4638["Stmts"]
    $P4640 = $P4639."new"()
    store_lex "$past", $P4640
.annotate 'line', 1391
    .return ($P4640)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("507_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4677
    .param pmc param_4678
.annotate 'line', 1431
    .lex "self", param_4677
    .lex "$/", param_4678
    find_lex $P4679, "$/"
    find_lex $P4680, "$/"
    unless_null $P4680, vivify_2205
    $P4680 = root_new ['parrot';'Hash']
  vivify_2205:
    set $P4681, $P4680["routine_def"]
    unless_null $P4681, vivify_2206
    new $P4681, "Undef"
  vivify_2206:
    $P4682 = $P4681."ast"()
    $P4683 = $P4679."!make"($P4682)
    .return ($P4683)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("508_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4685
    .param pmc param_4686
.annotate 'line', 1432
    .lex "self", param_4685
    .lex "$/", param_4686
    find_lex $P4687, "$/"
    find_lex $P4688, "$/"
    unless_null $P4688, vivify_2207
    $P4688 = root_new ['parrot';'Hash']
  vivify_2207:
    set $P4689, $P4688["method_def"]
    unless_null $P4689, vivify_2208
    new $P4689, "Undef"
  vivify_2208:
    $P4690 = $P4689."ast"()
    $P4691 = $P4687."!make"($P4690)
    .return ($P4691)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("509_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_4693
    .param pmc param_4694
.annotate 'line', 1434
    .const 'Sub' $P5007 = "515_1304277427.017" 
    capture_lex $P5007
    .const 'Sub' $P4716 = "510_1304277427.017" 
    capture_lex $P4716
    .lex "self", param_4693
    .lex "$/", param_4694
.annotate 'line', 1437
    new $P4695, "Undef"
    .lex "$past", $P4695
.annotate 'line', 1448
    new $P4696, "Undef"
    .lex "$block", $P4696
.annotate 'line', 1434
    find_lex $P4697, "$past"
    unless_null $P4697, vivify_2209
    new $P4697, "Undef"
  vivify_2209:
.annotate 'line', 1438
    find_lex $P4699, "$/"
    unless_null $P4699, vivify_2210
    $P4699 = root_new ['parrot';'Hash']
  vivify_2210:
    set $P4700, $P4699["onlystar"]
    unless_null $P4700, vivify_2211
    new $P4700, "Undef"
  vivify_2211:
    if $P4700, if_4698
.annotate 'line', 1442
    find_lex $P4702, "$/"
    unless_null $P4702, vivify_2212
    $P4702 = root_new ['parrot';'Hash']
  vivify_2212:
    set $P4703, $P4702["blockoid"]
    unless_null $P4703, vivify_2213
    new $P4703, "Undef"
  vivify_2213:
    $P4704 = $P4703."ast"()
    store_lex "$past", $P4704
.annotate 'line', 1443
    find_lex $P4705, "$past"
    unless_null $P4705, vivify_2214
    new $P4705, "Undef"
  vivify_2214:
    $P4705."blocktype"("declaration")
.annotate 'line', 1444
    find_dynamic_lex $P4709, "$*RETURN_USED"
    unless_null $P4709, vivify_2215
    get_hll_global $P4707, "GLOBAL"
    get_who $P4708, $P4707
    set $P4709, $P4708["$RETURN_USED"]
    unless_null $P4709, vivify_2216
    die "Contextual $*RETURN_USED not found"
  vivify_2216:
  vivify_2215:
    unless $P4709, if_4706_end
.annotate 'line', 1445
    find_lex $P4710, "$past"
    unless_null $P4710, vivify_2217
    new $P4710, "Undef"
  vivify_2217:
    $P4710."control"("return_pir")
  if_4706_end:
.annotate 'line', 1441
    goto if_4698_end
  if_4698:
.annotate 'line', 1439
    $P4701 = "only_star_block"()
    store_lex "$past", $P4701
  if_4698_end:
.annotate 'line', 1448
    find_lex $P4711, "$past"
    unless_null $P4711, vivify_2218
    new $P4711, "Undef"
  vivify_2218:
    store_lex "$block", $P4711
.annotate 'line', 1450
    find_lex $P4713, "$/"
    unless_null $P4713, vivify_2219
    $P4713 = root_new ['parrot';'Hash']
  vivify_2219:
    set $P4714, $P4713["deflongname"]
    unless_null $P4714, vivify_2220
    new $P4714, "Undef"
  vivify_2220:
    unless $P4714, if_4712_end
    .const 'Sub' $P4716 = "510_1304277427.017" 
    capture_lex $P4716
    $P4716()
  if_4712_end:
.annotate 'line', 1551
    find_lex $P4996, "$block"
    unless_null $P4996, vivify_2326
    new $P4996, "Undef"
  vivify_2326:
    find_lex $P4997, "$past"
    unless_null $P4997, vivify_2327
    $P4997 = root_new ['parrot';'Hash']
    store_lex "$past", $P4997
  vivify_2327:
    set $P4997["block_past"], $P4996
.annotate 'line', 1552
    find_lex $P4999, "$/"
    unless_null $P4999, vivify_2328
    $P4999 = root_new ['parrot';'Hash']
  vivify_2328:
    set $P5000, $P4999["trait"]
    unless_null $P5000, vivify_2329
    new $P5000, "Undef"
  vivify_2329:
    unless $P5000, if_4998_end
.annotate 'line', 1553
    find_lex $P5002, "$/"
    unless_null $P5002, vivify_2330
    $P5002 = root_new ['parrot';'Hash']
  vivify_2330:
    set $P5003, $P5002["trait"]
    unless_null $P5003, vivify_2331
    new $P5003, "Undef"
  vivify_2331:
    defined $I5004, $P5003
    unless $I5004, for_undef_2332
    iter $P5001, $P5003
    new $P5014, 'ExceptionHandler'
    set_label $P5014, loop5013_handler
    $P5014."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5014
  loop5013_test:
    unless $P5001, loop5013_done
    shift $P5005, $P5001
  loop5013_redo:
    .const 'Sub' $P5007 = "515_1304277427.017" 
    capture_lex $P5007
    $P5007($P5005)
  loop5013_next:
    goto loop5013_test
  loop5013_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5015, exception, 'type'
    eq $P5015, .CONTROL_LOOP_NEXT, loop5013_next
    eq $P5015, .CONTROL_LOOP_REDO, loop5013_redo
  loop5013_done:
    pop_eh 
  for_undef_2332:
  if_4998_end:
.annotate 'line', 1556
    find_lex $P5016, "$/"
    find_lex $P5017, "$past"
    unless_null $P5017, vivify_2335
    new $P5017, "Undef"
  vivify_2335:
    $P5018 = $P5016."!make"($P5017)
.annotate 'line', 1434
    .return ($P5018)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4715"  :anon :subid("510_1304277427.017") :outer("509_1304277427.017")
.annotate 'line', 1450
    .const 'Sub' $P4870 = "514_1304277427.017" 
    capture_lex $P4870
    .const 'Sub' $P4757 = "511_1304277427.017" 
    capture_lex $P4757
.annotate 'line', 1451
    new $P4717, "Undef"
    .lex "$name", $P4717
    find_lex $P4718, "$/"
    unless_null $P4718, vivify_2221
    $P4718 = root_new ['parrot';'Hash']
  vivify_2221:
    set $P4719, $P4718["sigil"]
    unless_null $P4719, vivify_2222
    $P4719 = root_new ['parrot';'ResizablePMCArray']
  vivify_2222:
    set $P4720, $P4719[0]
    unless_null $P4720, vivify_2223
    new $P4720, "Undef"
  vivify_2223:
    set $S4721, $P4720
    new $P4722, 'String'
    set $P4722, $S4721
    find_lex $P4723, "$/"
    unless_null $P4723, vivify_2224
    $P4723 = root_new ['parrot';'Hash']
  vivify_2224:
    set $P4724, $P4723["deflongname"]
    unless_null $P4724, vivify_2225
    $P4724 = root_new ['parrot';'ResizablePMCArray']
  vivify_2225:
    set $P4725, $P4724[0]
    unless_null $P4725, vivify_2226
    new $P4725, "Undef"
  vivify_2226:
    $S4726 = $P4725."ast"()
    concat $P4727, $P4722, $S4726
    store_lex "$name", $P4727
.annotate 'line', 1452
    find_lex $P4728, "$past"
    unless_null $P4728, vivify_2227
    new $P4728, "Undef"
  vivify_2227:
    find_lex $P4729, "$name"
    unless_null $P4729, vivify_2228
    new $P4729, "Undef"
  vivify_2228:
    $P4728."name"($P4729)
.annotate 'line', 1453
    find_dynamic_lex $P4737, "$*SCOPE"
    unless_null $P4737, vivify_2229
    get_hll_global $P4735, "GLOBAL"
    get_who $P4736, $P4735
    set $P4737, $P4736["$SCOPE"]
    unless_null $P4737, vivify_2230
    die "Contextual $*SCOPE not found"
  vivify_2230:
  vivify_2229:
    set $S4738, $P4737
    iseq $I4739, $S4738, ""
    unless $I4739, unless_4734
    new $P4733, 'Integer'
    set $P4733, $I4739
    goto unless_4734_end
  unless_4734:
    find_dynamic_lex $P4742, "$*SCOPE"
    unless_null $P4742, vivify_2231
    get_hll_global $P4740, "GLOBAL"
    get_who $P4741, $P4740
    set $P4742, $P4741["$SCOPE"]
    unless_null $P4742, vivify_2232
    die "Contextual $*SCOPE not found"
  vivify_2232:
  vivify_2231:
    set $S4743, $P4742
    iseq $I4744, $S4743, "my"
    new $P4733, 'Integer'
    set $P4733, $I4744
  unless_4734_end:
    unless $P4733, unless_4732
    set $P4731, $P4733
    goto unless_4732_end
  unless_4732:
    find_dynamic_lex $P4747, "$*SCOPE"
    unless_null $P4747, vivify_2233
    get_hll_global $P4745, "GLOBAL"
    get_who $P4746, $P4745
    set $P4747, $P4746["$SCOPE"]
    unless_null $P4747, vivify_2234
    die "Contextual $*SCOPE not found"
  vivify_2234:
  vivify_2233:
    set $S4748, $P4747
    iseq $I4749, $S4748, "our"
    new $P4731, 'Integer'
    set $P4731, $I4749
  unless_4732_end:
    if $P4731, if_4730
.annotate 'line', 1541
    find_lex $P4977, "$/"
    unless_null $P4977, vivify_2235
    new $P4977, "Undef"
  vivify_2235:
    $P4978 = $P4977."CURSOR"()
    find_dynamic_lex $P4981, "$*SCOPE"
    unless_null $P4981, vivify_2236
    get_hll_global $P4979, "GLOBAL"
    get_who $P4980, $P4979
    set $P4981, $P4980["$SCOPE"]
    unless_null $P4981, vivify_2237
    die "Contextual $*SCOPE not found"
  vivify_2237:
  vivify_2236:
    concat $P4982, $P4981, " scoped routines are not supported yet"
    $P4978."panic"($P4982)
.annotate 'line', 1540
    goto if_4730_end
  if_4730:
.annotate 'line', 1454
    find_dynamic_lex $P4753, "$*MULTINESS"
    unless_null $P4753, vivify_2238
    get_hll_global $P4751, "GLOBAL"
    get_who $P4752, $P4751
    set $P4753, $P4752["$MULTINESS"]
    unless_null $P4753, vivify_2239
    die "Contextual $*MULTINESS not found"
  vivify_2239:
  vivify_2238:
    set $S4754, $P4753
    iseq $I4755, $S4754, "multi"
    if $I4755, if_4750
.annotate 'line', 1505
    find_dynamic_lex $P4866, "$*MULTINESS"
    unless_null $P4866, vivify_2240
    get_hll_global $P4864, "GLOBAL"
    get_who $P4865, $P4864
    set $P4866, $P4865["$MULTINESS"]
    unless_null $P4866, vivify_2241
    die "Contextual $*MULTINESS not found"
  vivify_2241:
  vivify_2240:
    set $S4867, $P4866
    iseq $I4868, $S4867, "proto"
    if $I4868, if_4863
.annotate 'line', 1524
    find_lex $P4920, "$?PACKAGE"
    get_who $P4921, $P4920
    set $P4922, $P4921["@BLOCK"]
    unless_null $P4922, vivify_2242
    $P4922 = root_new ['parrot';'ResizablePMCArray']
  vivify_2242:
    set $P4923, $P4922[0]
    unless_null $P4923, vivify_2243
    $P4923 = root_new ['parrot';'ResizablePMCArray']
  vivify_2243:
    set $P4924, $P4923[0]
    unless_null $P4924, vivify_2244
    new $P4924, "Undef"
  vivify_2244:
    get_hll_global $P4925, "GLOBAL"
    nqp_get_package_through_who $P4926, $P4925, "PAST"
    get_who $P4927, $P4926
    set $P4928, $P4927["Var"]
    find_lex $P4929, "$name"
    unless_null $P4929, vivify_2245
    new $P4929, "Undef"
  vivify_2245:
    find_lex $P4930, "$past"
    unless_null $P4930, vivify_2246
    new $P4930, "Undef"
  vivify_2246:
    $P4931 = $P4928."new"($P4929 :named("name"), 1 :named("isdecl"), $P4930 :named("viviself"), "lexical" :named("scope"))
    $P4924."push"($P4931)
.annotate 'line', 1526
    find_lex $P4932, "$?PACKAGE"
    get_who $P4933, $P4932
    set $P4934, $P4933["@BLOCK"]
    unless_null $P4934, vivify_2247
    $P4934 = root_new ['parrot';'ResizablePMCArray']
  vivify_2247:
    set $P4935, $P4934[0]
    unless_null $P4935, vivify_2248
    new $P4935, "Undef"
  vivify_2248:
    find_lex $P4936, "$name"
    unless_null $P4936, vivify_2249
    new $P4936, "Undef"
  vivify_2249:
    $P4935."symbol"($P4936, "lexical" :named("scope"))
.annotate 'line', 1527
    find_dynamic_lex $P4940, "$*SCOPE"
    unless_null $P4940, vivify_2250
    get_hll_global $P4938, "GLOBAL"
    get_who $P4939, $P4938
    set $P4940, $P4939["$SCOPE"]
    unless_null $P4940, vivify_2251
    die "Contextual $*SCOPE not found"
  vivify_2251:
  vivify_2250:
    set $S4941, $P4940
    iseq $I4942, $S4941, "our"
    unless $I4942, if_4937_end
.annotate 'line', 1530
    find_dynamic_lex $P4945, "$*SC"
    unless_null $P4945, vivify_2252
    get_hll_global $P4943, "GLOBAL"
    get_who $P4944, $P4943
    set $P4945, $P4944["$SC"]
    unless_null $P4945, vivify_2253
    die "Contextual $*SC not found"
  vivify_2253:
  vivify_2252:
    find_dynamic_lex $P4948, "$*PACKAGE"
    unless_null $P4948, vivify_2254
    get_hll_global $P4946, "GLOBAL"
    get_who $P4947, $P4946
    set $P4948, $P4947["$PACKAGE"]
    unless_null $P4948, vivify_2255
    die "Contextual $*PACKAGE not found"
  vivify_2255:
  vivify_2254:
    find_lex $P4949, "$name"
    unless_null $P4949, vivify_2256
    new $P4949, "Undef"
  vivify_2256:
    find_lex $P4950, "$past"
    unless_null $P4950, vivify_2257
    new $P4950, "Undef"
  vivify_2257:
    $P4945."install_package_routine"($P4948, $P4949, $P4950)
.annotate 'line', 1531
    find_lex $P4951, "$?PACKAGE"
    get_who $P4952, $P4951
    set $P4953, $P4952["@BLOCK"]
    unless_null $P4953, vivify_2258
    $P4953 = root_new ['parrot';'ResizablePMCArray']
  vivify_2258:
    set $P4954, $P4953[0]
    unless_null $P4954, vivify_2259
    $P4954 = root_new ['parrot';'ResizablePMCArray']
  vivify_2259:
    set $P4955, $P4954[0]
    unless_null $P4955, vivify_2260
    new $P4955, "Undef"
  vivify_2260:
    get_hll_global $P4956, "GLOBAL"
    nqp_get_package_through_who $P4957, $P4956, "PAST"
    get_who $P4958, $P4957
    set $P4959, $P4958["Op"]
.annotate 'line', 1533
    find_lex $P4960, "$name"
    unless_null $P4960, vivify_2261
    new $P4960, "Undef"
  vivify_2261:
    new $P4961, "ResizablePMCArray"
    push $P4961, $P4960
    find_lex $P4962, "$/"
    unless_null $P4962, vivify_2262
    new $P4962, "Undef"
  vivify_2262:
    $P4963 = "lexical_package_lookup"($P4961, $P4962)
.annotate 'line', 1534
    get_hll_global $P4964, "GLOBAL"
    nqp_get_package_through_who $P4965, $P4964, "PAST"
    get_who $P4966, $P4965
    set $P4967, $P4966["Var"]
    find_lex $P4968, "$name"
    unless_null $P4968, vivify_2263
    new $P4968, "Undef"
  vivify_2263:
    $P4969 = $P4967."new"($P4968 :named("name"), "lexical" :named("scope"))
    $P4970 = $P4959."new"($P4963, $P4969, "bind" :named("pasttype"))
.annotate 'line', 1531
    $P4955."push"($P4970)
  if_4937_end:
.annotate 'line', 1523
    goto if_4863_end
  if_4863:
.annotate 'line', 1505
    .const 'Sub' $P4870 = "514_1304277427.017" 
    capture_lex $P4870
    $P4870()
  if_4863_end:
    goto if_4750_end
  if_4750:
.annotate 'line', 1454
    .const 'Sub' $P4757 = "511_1304277427.017" 
    capture_lex $P4757
    $P4757()
  if_4750_end:
.annotate 'line', 1538
    get_hll_global $P4971, "GLOBAL"
    nqp_get_package_through_who $P4972, $P4971, "PAST"
    get_who $P4973, $P4972
    set $P4974, $P4973["Var"]
    find_lex $P4975, "$name"
    unless_null $P4975, vivify_2321
    new $P4975, "Undef"
  vivify_2321:
    $P4976 = $P4974."new"($P4975 :named("name"))
    store_lex "$past", $P4976
  if_4730_end:
.annotate 'line', 1545
    find_lex $P4987, "$name"
    unless_null $P4987, vivify_2322
    new $P4987, "Undef"
  vivify_2322:
    set $S4988, $P4987
    iseq $I4989, $S4988, "MAIN"
    if $I4989, if_4986
    new $P4985, 'Integer'
    set $P4985, $I4989
    goto if_4986_end
  if_4986:
    find_dynamic_lex $P4992, "$*MULTINESS"
    unless_null $P4992, vivify_2323
    get_hll_global $P4990, "GLOBAL"
    get_who $P4991, $P4990
    set $P4992, $P4991["$MULTINESS"]
    unless_null $P4992, vivify_2324
    die "Contextual $*MULTINESS not found"
  vivify_2324:
  vivify_2323:
    set $S4993, $P4992
    isne $I4994, $S4993, "multi"
    new $P4985, 'Integer'
    set $P4985, $I4994
  if_4986_end:
    if $P4985, if_4984
    set $P4983, $P4985
    goto if_4984_end
  if_4984:
.annotate 'line', 1546
    find_lex $P4995, "$block"
    unless_null $P4995, vivify_2325
    new $P4995, "Undef"
  vivify_2325:
    store_dynamic_lex "$*MAIN_SUB", $P4995
.annotate 'line', 1545
    set $P4983, $P4995
  if_4984_end:
.annotate 'line', 1450
    .return ($P4983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4869"  :anon :subid("514_1304277427.017") :outer("510_1304277427.017")
.annotate 'line', 1510
    new $P4871, "Undef"
    .lex "$cholder", $P4871
.annotate 'line', 1509
    find_dynamic_lex $P4875, "$*SCOPE"
    unless_null $P4875, vivify_2264
    get_hll_global $P4873, "GLOBAL"
    get_who $P4874, $P4873
    set $P4875, $P4874["$SCOPE"]
    unless_null $P4875, vivify_2265
    die "Contextual $*SCOPE not found"
  vivify_2265:
  vivify_2264:
    set $S4876, $P4875
    iseq $I4877, $S4876, "our"
    unless $I4877, if_4872_end
    die "our-scoped protos not yet implemented"
  if_4872_end:
.annotate 'line', 1510
    get_hll_global $P4878, "GLOBAL"
    nqp_get_package_through_who $P4879, $P4878, "PAST"
    get_who $P4880, $P4879
    set $P4881, $P4880["Op"]
    $P4882 = $P4881."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4882
.annotate 'line', 1511
    find_lex $P4883, "$?PACKAGE"
    get_who $P4884, $P4883
    set $P4885, $P4884["@BLOCK"]
    unless_null $P4885, vivify_2266
    $P4885 = root_new ['parrot';'ResizablePMCArray']
  vivify_2266:
    set $P4886, $P4885[0]
    unless_null $P4886, vivify_2267
    $P4886 = root_new ['parrot';'ResizablePMCArray']
  vivify_2267:
    set $P4887, $P4886[0]
    unless_null $P4887, vivify_2268
    new $P4887, "Undef"
  vivify_2268:
    get_hll_global $P4888, "GLOBAL"
    nqp_get_package_through_who $P4889, $P4888, "PAST"
    get_who $P4890, $P4889
    set $P4891, $P4890["Var"]
    find_lex $P4892, "$name"
    unless_null $P4892, vivify_2269
    new $P4892, "Undef"
  vivify_2269:
    find_lex $P4893, "$past"
    unless_null $P4893, vivify_2270
    new $P4893, "Undef"
  vivify_2270:
    $P4894 = $P4891."new"($P4892 :named("name"), 1 :named("isdecl"), $P4893 :named("viviself"), "lexical" :named("scope"))
    $P4887."push"($P4894)
.annotate 'line', 1513
    find_lex $P4895, "$?PACKAGE"
    get_who $P4896, $P4895
    set $P4897, $P4896["@BLOCK"]
    unless_null $P4897, vivify_2271
    $P4897 = root_new ['parrot';'ResizablePMCArray']
  vivify_2271:
    set $P4898, $P4897[0]
    unless_null $P4898, vivify_2272
    $P4898 = root_new ['parrot';'ResizablePMCArray']
  vivify_2272:
    set $P4899, $P4898[0]
    unless_null $P4899, vivify_2273
    new $P4899, "Undef"
  vivify_2273:
    get_hll_global $P4900, "GLOBAL"
    nqp_get_package_through_who $P4901, $P4900, "PAST"
    get_who $P4902, $P4901
    set $P4903, $P4902["Op"]
.annotate 'line', 1515
    get_hll_global $P4904, "GLOBAL"
    nqp_get_package_through_who $P4905, $P4904, "PAST"
    get_who $P4906, $P4905
    set $P4907, $P4906["Var"]
    find_lex $P4908, "$name"
    unless_null $P4908, vivify_2274
    new $P4908, "Undef"
  vivify_2274:
    $P4909 = $P4907."new"($P4908 :named("name"))
    find_lex $P4910, "$cholder"
    unless_null $P4910, vivify_2275
    new $P4910, "Undef"
  vivify_2275:
    $P4911 = $P4903."new"($P4909, $P4910, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1513
    $P4899."push"($P4911)
.annotate 'line', 1518
    find_lex $P4912, "$?PACKAGE"
    get_who $P4913, $P4912
    set $P4914, $P4913["@BLOCK"]
    unless_null $P4914, vivify_2276
    $P4914 = root_new ['parrot';'ResizablePMCArray']
  vivify_2276:
    set $P4915, $P4914[0]
    unless_null $P4915, vivify_2277
    new $P4915, "Undef"
  vivify_2277:
    find_lex $P4916, "$name"
    unless_null $P4916, vivify_2278
    new $P4916, "Undef"
  vivify_2278:
    find_lex $P4917, "$cholder"
    unless_null $P4917, vivify_2279
    new $P4917, "Undef"
  vivify_2279:
    $P4915."symbol"($P4916, "lexical" :named("scope"), 1 :named("proto"), $P4917 :named("cholder"))
.annotate 'line', 1521
    find_lex $P4918, "$past"
    unless_null $P4918, vivify_2280
    new $P4918, "Undef"
  vivify_2280:
    $P4919 = $P4918."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1505
    .return ($P4919)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4756"  :anon :subid("511_1304277427.017") :outer("510_1304277427.017")
.annotate 'line', 1454
    .const 'Sub' $P4779 = "512_1304277427.017" 
    capture_lex $P4779
.annotate 'line', 1457
    new $P4758, "Undef"
    .lex "$cholder", $P4758
.annotate 'line', 1458
    $P4759 = root_new ['parrot';'Hash']
    .lex "%sym", $P4759
.annotate 'line', 1456
    find_dynamic_lex $P4763, "$*SCOPE"
    unless_null $P4763, vivify_2281
    get_hll_global $P4761, "GLOBAL"
    get_who $P4762, $P4761
    set $P4763, $P4762["$SCOPE"]
    unless_null $P4763, vivify_2282
    die "Contextual $*SCOPE not found"
  vivify_2282:
  vivify_2281:
    set $S4764, $P4763
    iseq $I4765, $S4764, "our"
    unless $I4765, if_4760_end
    die "our-scoped multis not yet implemented"
  if_4760_end:
    find_lex $P4766, "$cholder"
    unless_null $P4766, vivify_2283
    new $P4766, "Undef"
  vivify_2283:
.annotate 'line', 1458
    find_lex $P4767, "$?PACKAGE"
    get_who $P4768, $P4767
    set $P4769, $P4768["@BLOCK"]
    unless_null $P4769, vivify_2284
    $P4769 = root_new ['parrot';'ResizablePMCArray']
  vivify_2284:
    set $P4770, $P4769[0]
    unless_null $P4770, vivify_2285
    new $P4770, "Undef"
  vivify_2285:
    find_lex $P4771, "$name"
    unless_null $P4771, vivify_2286
    new $P4771, "Undef"
  vivify_2286:
    $P4772 = $P4770."symbol"($P4771)
    store_lex "%sym", $P4772
.annotate 'line', 1459
    find_lex $P4774, "%sym"
    unless_null $P4774, vivify_2287
    $P4774 = root_new ['parrot';'Hash']
  vivify_2287:
    set $P4775, $P4774["cholder"]
    unless_null $P4775, vivify_2288
    new $P4775, "Undef"
  vivify_2288:
    if $P4775, if_4773
.annotate 'line', 1464
    .const 'Sub' $P4779 = "512_1304277427.017" 
    capture_lex $P4779
    $P4779()
    goto if_4773_end
  if_4773:
.annotate 'line', 1460
    find_lex $P4776, "%sym"
    unless_null $P4776, vivify_2316
    $P4776 = root_new ['parrot';'Hash']
  vivify_2316:
    set $P4777, $P4776["cholder"]
    unless_null $P4777, vivify_2317
    new $P4777, "Undef"
  vivify_2317:
    store_lex "$cholder", $P4777
  if_4773_end:
.annotate 'line', 1500
    find_lex $P4859, "$cholder"
    unless_null $P4859, vivify_2318
    new $P4859, "Undef"
  vivify_2318:
    find_lex $P4860, "$past"
    unless_null $P4860, vivify_2319
    new $P4860, "Undef"
  vivify_2319:
    $P4859."push"($P4860)
.annotate 'line', 1503
    find_lex $P4861, "$past"
    unless_null $P4861, vivify_2320
    new $P4861, "Undef"
  vivify_2320:
    $P4862 = "attach_multi_signature"($P4861)
.annotate 'line', 1454
    .return ($P4862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4778"  :anon :subid("512_1304277427.017") :outer("511_1304277427.017")
.annotate 'line', 1464
    .const 'Sub' $P4795 = "513_1304277427.017" 
    capture_lex $P4795
.annotate 'line', 1471
    new $P4780, "Undef"
    .lex "$found_proto", $P4780
.annotate 'line', 1489
    new $P4781, "Undef"
    .lex "$dispatch_setup", $P4781
.annotate 'line', 1466
    find_lex $P4783, "%sym"
    unless_null $P4783, vivify_2289
    $P4783 = root_new ['parrot';'Hash']
  vivify_2289:
    set $P4784, $P4783["proto"]
    unless_null $P4784, vivify_2290
    new $P4784, "Undef"
  vivify_2290:
    unless $P4784, if_4782_end
.annotate 'line', 1469
    find_lex $P4785, "$/"
    unless_null $P4785, vivify_2291
    new $P4785, "Undef"
  vivify_2291:
    $P4786 = $P4785."CURSOR"()
    $P4786."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4782_end:
.annotate 'line', 1466
    find_lex $P4787, "$found_proto"
    unless_null $P4787, vivify_2292
    new $P4787, "Undef"
  vivify_2292:
.annotate 'line', 1472
    find_lex $P4789, "$?PACKAGE"
    get_who $P4790, $P4789
    set $P4791, $P4790["@BLOCK"]
    unless_null $P4791, vivify_2293
    $P4791 = root_new ['parrot';'ResizablePMCArray']
  vivify_2293:
    defined $I4792, $P4791
    unless $I4792, for_undef_2294
    iter $P4788, $P4791
    new $P4817, 'ExceptionHandler'
    set_label $P4817, loop4816_handler
    $P4817."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4817
  loop4816_test:
    unless $P4788, loop4816_done
    shift $P4793, $P4788
  loop4816_redo:
    .const 'Sub' $P4795 = "513_1304277427.017" 
    capture_lex $P4795
    $P4795($P4793)
  loop4816_next:
    goto loop4816_test
  loop4816_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4818, exception, 'type'
    eq $P4818, .CONTROL_LOOP_NEXT, loop4816_next
    eq $P4818, .CONTROL_LOOP_REDO, loop4816_redo
  loop4816_done:
    pop_eh 
  for_undef_2294:
.annotate 'line', 1483
    find_lex $P4820, "$found_proto"
    unless_null $P4820, vivify_2303
    new $P4820, "Undef"
  vivify_2303:
    if $P4820, unless_4819_end
.annotate 'line', 1484
    find_lex $P4821, "$/"
    unless_null $P4821, vivify_2304
    new $P4821, "Undef"
  vivify_2304:
    $P4822 = $P4821."CURSOR"()
    $P4822."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4819_end:
.annotate 'line', 1488
    get_hll_global $P4823, "GLOBAL"
    nqp_get_package_through_who $P4824, $P4823, "PAST"
    get_who $P4825, $P4824
    set $P4826, $P4825["Op"]
    $P4827 = $P4826."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4827
.annotate 'line', 1489
    get_hll_global $P4828, "GLOBAL"
    nqp_get_package_through_who $P4829, $P4828, "PAST"
    get_who $P4830, $P4829
    set $P4831, $P4830["Op"]
.annotate 'line', 1491
    get_hll_global $P4832, "GLOBAL"
    nqp_get_package_through_who $P4833, $P4832, "PAST"
    get_who $P4834, $P4833
    set $P4835, $P4834["Var"]
    find_lex $P4836, "$name"
    unless_null $P4836, vivify_2305
    new $P4836, "Undef"
  vivify_2305:
    $P4837 = $P4835."new"($P4836 :named("name"), "outer" :named("scope"))
    find_lex $P4838, "$cholder"
    unless_null $P4838, vivify_2306
    new $P4838, "Undef"
  vivify_2306:
    $P4839 = $P4831."new"($P4837, $P4838, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1489
    store_lex "$dispatch_setup", $P4839
.annotate 'line', 1494
    find_lex $P4840, "$?PACKAGE"
    get_who $P4841, $P4840
    set $P4842, $P4841["@BLOCK"]
    unless_null $P4842, vivify_2307
    $P4842 = root_new ['parrot';'ResizablePMCArray']
  vivify_2307:
    set $P4843, $P4842[0]
    unless_null $P4843, vivify_2308
    $P4843 = root_new ['parrot';'ResizablePMCArray']
  vivify_2308:
    set $P4844, $P4843[0]
    unless_null $P4844, vivify_2309
    new $P4844, "Undef"
  vivify_2309:
    get_hll_global $P4845, "GLOBAL"
    nqp_get_package_through_who $P4846, $P4845, "PAST"
    get_who $P4847, $P4846
    set $P4848, $P4847["Var"]
    find_lex $P4849, "$name"
    unless_null $P4849, vivify_2310
    new $P4849, "Undef"
  vivify_2310:
    find_lex $P4850, "$dispatch_setup"
    unless_null $P4850, vivify_2311
    new $P4850, "Undef"
  vivify_2311:
    $P4851 = $P4848."new"($P4849 :named("name"), 1 :named("isdecl"), $P4850 :named("viviself"), "lexical" :named("scope"))
    $P4844."push"($P4851)
.annotate 'line', 1496
    find_lex $P4852, "$?PACKAGE"
    get_who $P4853, $P4852
    set $P4854, $P4853["@BLOCK"]
    unless_null $P4854, vivify_2312
    $P4854 = root_new ['parrot';'ResizablePMCArray']
  vivify_2312:
    set $P4855, $P4854[0]
    unless_null $P4855, vivify_2313
    new $P4855, "Undef"
  vivify_2313:
    find_lex $P4856, "$name"
    unless_null $P4856, vivify_2314
    new $P4856, "Undef"
  vivify_2314:
    find_lex $P4857, "$cholder"
    unless_null $P4857, vivify_2315
    new $P4857, "Undef"
  vivify_2315:
    $P4858 = $P4855."symbol"($P4856, "lexical" :named("scope"), $P4857 :named("cholder"))
.annotate 'line', 1464
    .return ($P4858)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4794"  :anon :subid("513_1304277427.017") :outer("512_1304277427.017")
    .param pmc param_4797
.annotate 'line', 1473
    $P4796 = root_new ['parrot';'Hash']
    .lex "%sym", $P4796
    .lex "$_", param_4797
    find_lex $P4798, "$_"
    unless_null $P4798, vivify_2295
    new $P4798, "Undef"
  vivify_2295:
    find_lex $P4799, "$name"
    unless_null $P4799, vivify_2296
    new $P4799, "Undef"
  vivify_2296:
    $P4800 = $P4798."symbol"($P4799)
    store_lex "%sym", $P4800
.annotate 'line', 1474
    find_lex $P4805, "%sym"
    unless_null $P4805, vivify_2297
    $P4805 = root_new ['parrot';'Hash']
  vivify_2297:
    set $P4806, $P4805["proto"]
    unless_null $P4806, vivify_2298
    new $P4806, "Undef"
  vivify_2298:
    unless $P4806, unless_4804
    set $P4803, $P4806
    goto unless_4804_end
  unless_4804:
    find_lex $P4807, "%sym"
    unless_null $P4807, vivify_2299
    $P4807 = root_new ['parrot';'Hash']
  vivify_2299:
    set $P4808, $P4807["cholder"]
    unless_null $P4808, vivify_2300
    new $P4808, "Undef"
  vivify_2300:
    set $P4803, $P4808
  unless_4804_end:
    if $P4803, if_4802
.annotate 'line', 1477
    find_lex $P4812, "%sym"
    unless_null $P4812, vivify_2301
    $P4812 = root_new ['parrot';'Hash']
  vivify_2301:
    if $P4812, if_4811
    set $P4810, $P4812
    goto if_4811_end
  if_4811:
.annotate 'line', 1478
    find_lex $P4813, "$/"
    unless_null $P4813, vivify_2302
    new $P4813, "Undef"
  vivify_2302:
    $P4814 = $P4813."CURSOR"()
    $P4815 = $P4814."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1477
    set $P4810, $P4815
  if_4811_end:
    set $P4801, $P4810
.annotate 'line', 1474
    goto if_4802_end
  if_4802:
.annotate 'line', 1475
    new $P4809, "Integer"
    assign $P4809, 1
    store_lex "$found_proto", $P4809
.annotate 'line', 1474
    set $P4801, $P4809
  if_4802_end:
.annotate 'line', 1472
    .return ($P4801)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5006"  :anon :subid("515_1304277427.017") :outer("509_1304277427.017")
    .param pmc param_5008
.annotate 'line', 1553
    .lex "$_", param_5008
    find_lex $P5009, "$_"
    unless_null $P5009, vivify_2333
    new $P5009, "Undef"
  vivify_2333:
    $P5010 = $P5009."ast"()
    find_lex $P5011, "$/"
    unless_null $P5011, vivify_2334
    new $P5011, "Undef"
  vivify_2334:
    $P5012 = $P5010($P5011)
    .return ($P5012)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("516_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5020
    .param pmc param_5021
.annotate 'line', 1560
    .const 'Sub' $P5137 = "518_1304277427.017" 
    capture_lex $P5137
    .const 'Sub' $P5059 = "517_1304277427.017" 
    capture_lex $P5059
    .lex "self", param_5020
    .lex "$/", param_5021
.annotate 'line', 1563
    new $P5022, "Undef"
    .lex "$past", $P5022
.annotate 'line', 1560
    find_lex $P5023, "$past"
    unless_null $P5023, vivify_2336
    new $P5023, "Undef"
  vivify_2336:
.annotate 'line', 1564
    find_lex $P5025, "$/"
    unless_null $P5025, vivify_2337
    $P5025 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P5026, $P5025["onlystar"]
    unless_null $P5026, vivify_2338
    new $P5026, "Undef"
  vivify_2338:
    if $P5026, if_5024
.annotate 'line', 1568
    find_lex $P5028, "$/"
    unless_null $P5028, vivify_2339
    $P5028 = root_new ['parrot';'Hash']
  vivify_2339:
    set $P5029, $P5028["blockoid"]
    unless_null $P5029, vivify_2340
    new $P5029, "Undef"
  vivify_2340:
    $P5030 = $P5029."ast"()
    store_lex "$past", $P5030
.annotate 'line', 1569
    find_lex $P5031, "$past"
    unless_null $P5031, vivify_2341
    new $P5031, "Undef"
  vivify_2341:
    $P5031."blocktype"("declaration")
.annotate 'line', 1570
    find_dynamic_lex $P5035, "$*RETURN_USED"
    unless_null $P5035, vivify_2342
    get_hll_global $P5033, "GLOBAL"
    get_who $P5034, $P5033
    set $P5035, $P5034["$RETURN_USED"]
    unless_null $P5035, vivify_2343
    die "Contextual $*RETURN_USED not found"
  vivify_2343:
  vivify_2342:
    unless $P5035, if_5032_end
.annotate 'line', 1571
    find_lex $P5036, "$past"
    unless_null $P5036, vivify_2344
    new $P5036, "Undef"
  vivify_2344:
    $P5036."control"("return_pir")
  if_5032_end:
.annotate 'line', 1567
    goto if_5024_end
  if_5024:
.annotate 'line', 1565
    $P5027 = "only_star_block"()
    store_lex "$past", $P5027
  if_5024_end:
.annotate 'line', 1576
    find_lex $P5038, "$past"
    unless_null $P5038, vivify_2345
    $P5038 = root_new ['parrot';'Hash']
  vivify_2345:
    set $P5039, $P5038["signature_has_invocant"]
    unless_null $P5039, vivify_2346
    new $P5039, "Undef"
  vivify_2346:
    if $P5039, unless_5037_end
.annotate 'line', 1577
    find_lex $P5040, "$past"
    unless_null $P5040, vivify_2347
    $P5040 = root_new ['parrot';'ResizablePMCArray']
  vivify_2347:
    set $P5041, $P5040[0]
    unless_null $P5041, vivify_2348
    new $P5041, "Undef"
  vivify_2348:
    get_hll_global $P5042, "GLOBAL"
    nqp_get_package_through_who $P5043, $P5042, "PAST"
    get_who $P5044, $P5043
    set $P5045, $P5044["Var"]
.annotate 'line', 1579
    find_dynamic_lex $P5048, "$*SC"
    unless_null $P5048, vivify_2349
    get_hll_global $P5046, "GLOBAL"
    get_who $P5047, $P5046
    set $P5048, $P5047["$SC"]
    unless_null $P5048, vivify_2350
    die "Contextual $*SC not found"
  vivify_2350:
  vivify_2349:
    find_dynamic_lex $P5051, "$*PACKAGE"
    unless_null $P5051, vivify_2351
    get_hll_global $P5049, "GLOBAL"
    get_who $P5050, $P5049
    set $P5051, $P5050["$PACKAGE"]
    unless_null $P5051, vivify_2352
    die "Contextual $*PACKAGE not found"
  vivify_2352:
  vivify_2351:
    $P5052 = $P5048."get_object_sc_ref_past"($P5051)
    $P5053 = $P5045."new"("self" :named("name"), "parameter" :named("scope"), $P5052 :named("multitype"))
.annotate 'line', 1577
    $P5041."unshift"($P5053)
  unless_5037_end:
.annotate 'line', 1582
    find_lex $P5054, "$past"
    unless_null $P5054, vivify_2353
    new $P5054, "Undef"
  vivify_2353:
    $P5054."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1585
    find_lex $P5056, "$/"
    unless_null $P5056, vivify_2354
    $P5056 = root_new ['parrot';'Hash']
  vivify_2354:
    set $P5057, $P5056["deflongname"]
    unless_null $P5057, vivify_2355
    new $P5057, "Undef"
  vivify_2355:
    unless $P5057, if_5055_end
    .const 'Sub' $P5059 = "517_1304277427.017" 
    capture_lex $P5059
    $P5059()
  if_5055_end:
.annotate 'line', 1606
    find_lex $P5123, "$/"
    find_lex $P5124, "$past"
    unless_null $P5124, vivify_2386
    new $P5124, "Undef"
  vivify_2386:
    $P5123."!make"($P5124)
.annotate 'line', 1607
    find_lex $P5125, "$past"
    unless_null $P5125, vivify_2387
    new $P5125, "Undef"
  vivify_2387:
    find_lex $P5126, "$past"
    unless_null $P5126, vivify_2388
    $P5126 = root_new ['parrot';'Hash']
    store_lex "$past", $P5126
  vivify_2388:
    set $P5126["block_past"], $P5125
.annotate 'line', 1608
    find_lex $P5129, "$/"
    unless_null $P5129, vivify_2389
    $P5129 = root_new ['parrot';'Hash']
  vivify_2389:
    set $P5130, $P5129["trait"]
    unless_null $P5130, vivify_2390
    new $P5130, "Undef"
  vivify_2390:
    if $P5130, if_5128
    set $P5127, $P5130
    goto if_5128_end
  if_5128:
.annotate 'line', 1609
    find_lex $P5132, "$/"
    unless_null $P5132, vivify_2391
    $P5132 = root_new ['parrot';'Hash']
  vivify_2391:
    set $P5133, $P5132["trait"]
    unless_null $P5133, vivify_2392
    new $P5133, "Undef"
  vivify_2392:
    defined $I5134, $P5133
    unless $I5134, for_undef_2393
    iter $P5131, $P5133
    new $P5144, 'ExceptionHandler'
    set_label $P5144, loop5143_handler
    $P5144."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5144
  loop5143_test:
    unless $P5131, loop5143_done
    shift $P5135, $P5131
  loop5143_redo:
    .const 'Sub' $P5137 = "518_1304277427.017" 
    capture_lex $P5137
    $P5137($P5135)
  loop5143_next:
    goto loop5143_test
  loop5143_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5145, exception, 'type'
    eq $P5145, .CONTROL_LOOP_NEXT, loop5143_next
    eq $P5145, .CONTROL_LOOP_REDO, loop5143_redo
  loop5143_done:
    pop_eh 
  for_undef_2393:
.annotate 'line', 1608
    set $P5127, $P5131
  if_5128_end:
.annotate 'line', 1560
    .return ($P5127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5058"  :anon :subid("517_1304277427.017") :outer("516_1304277427.017")
.annotate 'line', 1587
    new $P5060, "Undef"
    .lex "$name", $P5060
.annotate 'line', 1595
    new $P5061, "Undef"
    .lex "$meta_meth", $P5061
.annotate 'line', 1596
    new $P5062, "Undef"
    .lex "$is_dispatcher", $P5062
.annotate 'line', 1587
    find_lex $P5063, "$/"
    unless_null $P5063, vivify_2356
    $P5063 = root_new ['parrot';'Hash']
  vivify_2356:
    set $P5064, $P5063["private"]
    unless_null $P5064, vivify_2357
    new $P5064, "Undef"
  vivify_2357:
    set $S5065, $P5064
    new $P5066, 'String'
    set $P5066, $S5065
    find_lex $P5067, "$/"
    unless_null $P5067, vivify_2358
    $P5067 = root_new ['parrot';'Hash']
  vivify_2358:
    set $P5068, $P5067["deflongname"]
    unless_null $P5068, vivify_2359
    $P5068 = root_new ['parrot';'ResizablePMCArray']
  vivify_2359:
    set $P5069, $P5068[0]
    unless_null $P5069, vivify_2360
    new $P5069, "Undef"
  vivify_2360:
    $P5070 = $P5069."ast"()
    set $S5071, $P5070
    concat $P5072, $P5066, $S5071
    store_lex "$name", $P5072
.annotate 'line', 1588
    find_lex $P5073, "$past"
    unless_null $P5073, vivify_2361
    new $P5073, "Undef"
  vivify_2361:
    find_lex $P5074, "$name"
    unless_null $P5074, vivify_2362
    new $P5074, "Undef"
  vivify_2362:
    $P5073."name"($P5074)
.annotate 'line', 1592
    find_dynamic_lex $P5078, "$*MULTINESS"
    unless_null $P5078, vivify_2363
    get_hll_global $P5076, "GLOBAL"
    get_who $P5077, $P5076
    set $P5078, $P5077["$MULTINESS"]
    unless_null $P5078, vivify_2364
    die "Contextual $*MULTINESS not found"
  vivify_2364:
  vivify_2363:
    set $S5079, $P5078
    iseq $I5080, $S5079, "multi"
    unless $I5080, if_5075_end
    find_lex $P5081, "$past"
    unless_null $P5081, vivify_2365
    new $P5081, "Undef"
  vivify_2365:
    "attach_multi_signature"($P5081)
  if_5075_end:
.annotate 'line', 1595
    find_dynamic_lex $P5086, "$*MULTINESS"
    unless_null $P5086, vivify_2366
    get_hll_global $P5084, "GLOBAL"
    get_who $P5085, $P5084
    set $P5086, $P5085["$MULTINESS"]
    unless_null $P5086, vivify_2367
    die "Contextual $*MULTINESS not found"
  vivify_2367:
  vivify_2366:
    set $S5087, $P5086
    iseq $I5088, $S5087, "multi"
    if $I5088, if_5083
    new $P5090, "String"
    assign $P5090, "add_method"
    set $P5082, $P5090
    goto if_5083_end
  if_5083:
    new $P5089, "String"
    assign $P5089, "add_multi_method"
    set $P5082, $P5089
  if_5083_end:
    store_lex "$meta_meth", $P5082
.annotate 'line', 1596
    find_dynamic_lex $P5093, "$*MULTINESS"
    unless_null $P5093, vivify_2368
    get_hll_global $P5091, "GLOBAL"
    get_who $P5092, $P5091
    set $P5093, $P5092["$MULTINESS"]
    unless_null $P5093, vivify_2369
    die "Contextual $*MULTINESS not found"
  vivify_2369:
  vivify_2368:
    set $S5094, $P5093
    iseq $I5095, $S5094, "proto"
    new $P5096, 'Integer'
    set $P5096, $I5095
    store_lex "$is_dispatcher", $P5096
.annotate 'line', 1597
    find_dynamic_lex $P5099, "$*SC"
    unless_null $P5099, vivify_2370
    get_hll_global $P5097, "GLOBAL"
    get_who $P5098, $P5097
    set $P5099, $P5098["$SC"]
    unless_null $P5099, vivify_2371
    die "Contextual $*SC not found"
  vivify_2371:
  vivify_2370:
    find_dynamic_lex $P5102, "$*PACKAGE"
    unless_null $P5102, vivify_2372
    get_hll_global $P5100, "GLOBAL"
    get_who $P5101, $P5100
    set $P5102, $P5101["$PACKAGE"]
    unless_null $P5102, vivify_2373
    die "Contextual $*PACKAGE not found"
  vivify_2373:
  vivify_2372:
    find_lex $P5103, "$meta_meth"
    unless_null $P5103, vivify_2374
    new $P5103, "Undef"
  vivify_2374:
    find_lex $P5104, "$name"
    unless_null $P5104, vivify_2375
    new $P5104, "Undef"
  vivify_2375:
    find_lex $P5105, "$past"
    unless_null $P5105, vivify_2376
    new $P5105, "Undef"
  vivify_2376:
    find_lex $P5106, "$is_dispatcher"
    unless_null $P5106, vivify_2377
    new $P5106, "Undef"
  vivify_2377:
    $P5099."pkg_add_method"($P5102, $P5103, $P5104, $P5105, $P5106)
.annotate 'line', 1600
    find_dynamic_lex $P5111, "$*SCOPE"
    unless_null $P5111, vivify_2378
    get_hll_global $P5109, "GLOBAL"
    get_who $P5110, $P5109
    set $P5111, $P5110["$SCOPE"]
    unless_null $P5111, vivify_2379
    die "Contextual $*SCOPE not found"
  vivify_2379:
  vivify_2378:
    set $S5112, $P5111
    iseq $I5113, $S5112, "our"
    if $I5113, if_5108
    new $P5107, 'Integer'
    set $P5107, $I5113
    goto if_5108_end
  if_5108:
.annotate 'line', 1601
    find_dynamic_lex $P5116, "$*SC"
    unless_null $P5116, vivify_2380
    get_hll_global $P5114, "GLOBAL"
    get_who $P5115, $P5114
    set $P5116, $P5115["$SC"]
    unless_null $P5116, vivify_2381
    die "Contextual $*SC not found"
  vivify_2381:
  vivify_2380:
    find_dynamic_lex $P5119, "$*PACKAGE"
    unless_null $P5119, vivify_2382
    get_hll_global $P5117, "GLOBAL"
    get_who $P5118, $P5117
    set $P5119, $P5118["$PACKAGE"]
    unless_null $P5119, vivify_2383
    die "Contextual $*PACKAGE not found"
  vivify_2383:
  vivify_2382:
    find_lex $P5120, "$name"
    unless_null $P5120, vivify_2384
    new $P5120, "Undef"
  vivify_2384:
    find_lex $P5121, "$past"
    unless_null $P5121, vivify_2385
    new $P5121, "Undef"
  vivify_2385:
    $P5122 = $P5116."install_package_routine"($P5119, $P5120, $P5121)
.annotate 'line', 1600
    set $P5107, $P5122
  if_5108_end:
.annotate 'line', 1585
    .return ($P5107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5136"  :anon :subid("518_1304277427.017") :outer("516_1304277427.017")
    .param pmc param_5138
.annotate 'line', 1609
    .lex "$_", param_5138
    find_lex $P5139, "$_"
    unless_null $P5139, vivify_2394
    new $P5139, "Undef"
  vivify_2394:
    $P5140 = $P5139."ast"()
    find_lex $P5141, "$/"
    unless_null $P5141, vivify_2395
    new $P5141, "Undef"
  vivify_2395:
    $P5142 = $P5140($P5141)
    .return ($P5142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("519_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5149
    .param pmc param_5150
.annotate 'line', 1638
    .const 'Sub' $P5193 = "521_1304277427.017" 
    capture_lex $P5193
    .const 'Sub' $P5161 = "520_1304277427.017" 
    capture_lex $P5161
    .lex "self", param_5149
    .lex "$/", param_5150
.annotate 'line', 1639
    new $P5151, "Undef"
    .lex "$BLOCKINIT", $P5151
    find_lex $P5152, "$?PACKAGE"
    get_who $P5153, $P5152
    set $P5154, $P5153["@BLOCK"]
    unless_null $P5154, vivify_2396
    $P5154 = root_new ['parrot';'ResizablePMCArray']
  vivify_2396:
    set $P5155, $P5154[0]
    unless_null $P5155, vivify_2397
    $P5155 = root_new ['parrot';'ResizablePMCArray']
  vivify_2397:
    set $P5156, $P5155[0]
    unless_null $P5156, vivify_2398
    new $P5156, "Undef"
  vivify_2398:
    store_lex "$BLOCKINIT", $P5156
.annotate 'line', 1640
    find_lex $P5158, "$/"
    unless_null $P5158, vivify_2399
    $P5158 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P5159, $P5158["invocant"]
    unless_null $P5159, vivify_2400
    new $P5159, "Undef"
  vivify_2400:
    unless $P5159, if_5157_end
    .const 'Sub' $P5161 = "520_1304277427.017" 
    capture_lex $P5161
    $P5161()
  if_5157_end:
.annotate 'line', 1649
    find_lex $P5188, "$/"
    unless_null $P5188, vivify_2410
    $P5188 = root_new ['parrot';'Hash']
  vivify_2410:
    set $P5189, $P5188["parameter"]
    unless_null $P5189, vivify_2411
    new $P5189, "Undef"
  vivify_2411:
    defined $I5190, $P5189
    unless $I5190, for_undef_2412
    iter $P5187, $P5189
    new $P5200, 'ExceptionHandler'
    set_label $P5200, loop5199_handler
    $P5200."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5200
  loop5199_test:
    unless $P5187, loop5199_done
    shift $P5191, $P5187
  loop5199_redo:
    .const 'Sub' $P5193 = "521_1304277427.017" 
    capture_lex $P5193
    $P5193($P5191)
  loop5199_next:
    goto loop5199_test
  loop5199_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5201, exception, 'type'
    eq $P5201, .CONTROL_LOOP_NEXT, loop5199_next
    eq $P5201, .CONTROL_LOOP_REDO, loop5199_redo
  loop5199_done:
    pop_eh 
  for_undef_2412:
.annotate 'line', 1638
    .return ($P5187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5160"  :anon :subid("520_1304277427.017") :outer("519_1304277427.017")
.annotate 'line', 1641
    new $P5162, "Undef"
    .lex "$inv", $P5162
    find_lex $P5163, "$/"
    unless_null $P5163, vivify_2401
    $P5163 = root_new ['parrot';'Hash']
  vivify_2401:
    set $P5164, $P5163["invocant"]
    unless_null $P5164, vivify_2402
    $P5164 = root_new ['parrot';'ResizablePMCArray']
  vivify_2402:
    set $P5165, $P5164[0]
    unless_null $P5165, vivify_2403
    new $P5165, "Undef"
  vivify_2403:
    $P5166 = $P5165."ast"()
    store_lex "$inv", $P5166
.annotate 'line', 1642
    find_lex $P5167, "$BLOCKINIT"
    unless_null $P5167, vivify_2404
    new $P5167, "Undef"
  vivify_2404:
    find_lex $P5168, "$inv"
    unless_null $P5168, vivify_2405
    new $P5168, "Undef"
  vivify_2405:
    $P5167."push"($P5168)
.annotate 'line', 1643
    find_lex $P5169, "$BLOCKINIT"
    unless_null $P5169, vivify_2406
    new $P5169, "Undef"
  vivify_2406:
    get_hll_global $P5170, "GLOBAL"
    nqp_get_package_through_who $P5171, $P5170, "PAST"
    get_who $P5172, $P5171
    set $P5173, $P5172["Var"]
.annotate 'line', 1645
    get_hll_global $P5174, "GLOBAL"
    nqp_get_package_through_who $P5175, $P5174, "PAST"
    get_who $P5176, $P5175
    set $P5177, $P5176["Var"]
    find_lex $P5178, "$inv"
    unless_null $P5178, vivify_2407
    new $P5178, "Undef"
  vivify_2407:
    $P5179 = $P5178."name"()
    $P5180 = $P5177."new"("lexical" :named("scope"), $P5179 :named("name"))
    $P5181 = $P5173."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5180 :named("viviself"))
.annotate 'line', 1643
    $P5169."push"($P5181)
.annotate 'line', 1647
    new $P5182, "Integer"
    assign $P5182, 1
    find_lex $P5183, "$?PACKAGE"
    get_who $P5184, $P5183
    set $P5185, $P5184["@BLOCK"]
    unless_null $P5185, vivify_2408
    $P5185 = root_new ['parrot';'ResizablePMCArray']
    set $P5184["@BLOCK"], $P5185
  vivify_2408:
    set $P5186, $P5185[0]
    unless_null $P5186, vivify_2409
    $P5186 = root_new ['parrot';'Hash']
    set $P5185[0], $P5186
  vivify_2409:
    set $P5186["signature_has_invocant"], $P5182
.annotate 'line', 1640
    .return ($P5182)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5192"  :anon :subid("521_1304277427.017") :outer("519_1304277427.017")
    .param pmc param_5194
.annotate 'line', 1649
    .lex "$_", param_5194
    find_lex $P5195, "$BLOCKINIT"
    unless_null $P5195, vivify_2413
    new $P5195, "Undef"
  vivify_2413:
    find_lex $P5196, "$_"
    unless_null $P5196, vivify_2414
    new $P5196, "Undef"
  vivify_2414:
    $P5197 = $P5196."ast"()
    $P5198 = $P5195."push"($P5197)
    .return ($P5198)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("522_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5203
    .param pmc param_5204
.annotate 'line', 1652
    .lex "self", param_5203
    .lex "$/", param_5204
.annotate 'line', 1653
    new $P5205, "Undef"
    .lex "$quant", $P5205
.annotate 'line', 1654
    new $P5206, "Undef"
    .lex "$past", $P5206
.annotate 'line', 1653
    find_lex $P5207, "$/"
    unless_null $P5207, vivify_2415
    $P5207 = root_new ['parrot';'Hash']
  vivify_2415:
    set $P5208, $P5207["quant"]
    unless_null $P5208, vivify_2416
    new $P5208, "Undef"
  vivify_2416:
    store_lex "$quant", $P5208
    find_lex $P5209, "$past"
    unless_null $P5209, vivify_2417
    new $P5209, "Undef"
  vivify_2417:
.annotate 'line', 1655
    find_lex $P5211, "$/"
    unless_null $P5211, vivify_2418
    $P5211 = root_new ['parrot';'Hash']
  vivify_2418:
    set $P5212, $P5211["named_param"]
    unless_null $P5212, vivify_2419
    new $P5212, "Undef"
  vivify_2419:
    if $P5212, if_5210
.annotate 'line', 1662
    find_lex $P5226, "$/"
    unless_null $P5226, vivify_2420
    $P5226 = root_new ['parrot';'Hash']
  vivify_2420:
    set $P5227, $P5226["param_var"]
    unless_null $P5227, vivify_2421
    new $P5227, "Undef"
  vivify_2421:
    $P5228 = $P5227."ast"()
    store_lex "$past", $P5228
.annotate 'line', 1663
    find_lex $P5230, "$quant"
    unless_null $P5230, vivify_2422
    new $P5230, "Undef"
  vivify_2422:
    set $S5231, $P5230
    iseq $I5232, $S5231, "*"
    if $I5232, if_5229
.annotate 'line', 1667
    find_lex $P5241, "$quant"
    unless_null $P5241, vivify_2423
    new $P5241, "Undef"
  vivify_2423:
    set $S5242, $P5241
    iseq $I5243, $S5242, "?"
    unless $I5243, if_5240_end
.annotate 'line', 1668
    find_lex $P5244, "$past"
    unless_null $P5244, vivify_2424
    new $P5244, "Undef"
  vivify_2424:
    find_lex $P5245, "$/"
    unless_null $P5245, vivify_2425
    $P5245 = root_new ['parrot';'Hash']
  vivify_2425:
    set $P5246, $P5245["param_var"]
    unless_null $P5246, vivify_2426
    $P5246 = root_new ['parrot';'Hash']
  vivify_2426:
    set $P5247, $P5246["sigil"]
    unless_null $P5247, vivify_2427
    new $P5247, "Undef"
  vivify_2427:
    $P5248 = "vivitype"($P5247)
    $P5244."viviself"($P5248)
  if_5240_end:
.annotate 'line', 1667
    goto if_5229_end
  if_5229:
.annotate 'line', 1664
    find_lex $P5233, "$past"
    unless_null $P5233, vivify_2428
    new $P5233, "Undef"
  vivify_2428:
    $P5233."slurpy"(1)
.annotate 'line', 1665
    find_lex $P5234, "$past"
    unless_null $P5234, vivify_2429
    new $P5234, "Undef"
  vivify_2429:
    find_lex $P5235, "$/"
    unless_null $P5235, vivify_2430
    $P5235 = root_new ['parrot';'Hash']
  vivify_2430:
    set $P5236, $P5235["param_var"]
    unless_null $P5236, vivify_2431
    $P5236 = root_new ['parrot';'Hash']
  vivify_2431:
    set $P5237, $P5236["sigil"]
    unless_null $P5237, vivify_2432
    new $P5237, "Undef"
  vivify_2432:
    set $S5238, $P5237
    iseq $I5239, $S5238, "%"
    $P5234."named"($I5239)
  if_5229_end:
.annotate 'line', 1661
    goto if_5210_end
  if_5210:
.annotate 'line', 1656
    find_lex $P5213, "$/"
    unless_null $P5213, vivify_2433
    $P5213 = root_new ['parrot';'Hash']
  vivify_2433:
    set $P5214, $P5213["named_param"]
    unless_null $P5214, vivify_2434
    new $P5214, "Undef"
  vivify_2434:
    $P5215 = $P5214."ast"()
    store_lex "$past", $P5215
.annotate 'line', 1657
    find_lex $P5217, "$quant"
    unless_null $P5217, vivify_2435
    new $P5217, "Undef"
  vivify_2435:
    set $S5218, $P5217
    isne $I5219, $S5218, "!"
    unless $I5219, if_5216_end
.annotate 'line', 1658
    find_lex $P5220, "$past"
    unless_null $P5220, vivify_2436
    new $P5220, "Undef"
  vivify_2436:
    find_lex $P5221, "$/"
    unless_null $P5221, vivify_2437
    $P5221 = root_new ['parrot';'Hash']
  vivify_2437:
    set $P5222, $P5221["named_param"]
    unless_null $P5222, vivify_2438
    $P5222 = root_new ['parrot';'Hash']
  vivify_2438:
    set $P5223, $P5222["param_var"]
    unless_null $P5223, vivify_2439
    $P5223 = root_new ['parrot';'Hash']
  vivify_2439:
    set $P5224, $P5223["sigil"]
    unless_null $P5224, vivify_2440
    new $P5224, "Undef"
  vivify_2440:
    $P5225 = "vivitype"($P5224)
    $P5220."viviself"($P5225)
  if_5216_end:
  if_5210_end:
.annotate 'line', 1671
    find_lex $P5250, "$/"
    unless_null $P5250, vivify_2441
    $P5250 = root_new ['parrot';'Hash']
  vivify_2441:
    set $P5251, $P5250["default_value"]
    unless_null $P5251, vivify_2442
    new $P5251, "Undef"
  vivify_2442:
    unless $P5251, if_5249_end
.annotate 'line', 1672
    find_lex $P5253, "$quant"
    unless_null $P5253, vivify_2443
    new $P5253, "Undef"
  vivify_2443:
    set $S5254, $P5253
    iseq $I5255, $S5254, "*"
    unless $I5255, if_5252_end
.annotate 'line', 1673
    find_lex $P5256, "$/"
    unless_null $P5256, vivify_2444
    new $P5256, "Undef"
  vivify_2444:
    $P5257 = $P5256."CURSOR"()
    $P5257."panic"("Can't put default on slurpy parameter")
  if_5252_end:
.annotate 'line', 1675
    find_lex $P5259, "$quant"
    unless_null $P5259, vivify_2445
    new $P5259, "Undef"
  vivify_2445:
    set $S5260, $P5259
    iseq $I5261, $S5260, "!"
    unless $I5261, if_5258_end
.annotate 'line', 1676
    find_lex $P5262, "$/"
    unless_null $P5262, vivify_2446
    new $P5262, "Undef"
  vivify_2446:
    $P5263 = $P5262."CURSOR"()
    $P5263."panic"("Can't put default on required parameter")
  if_5258_end:
.annotate 'line', 1678
    find_lex $P5264, "$past"
    unless_null $P5264, vivify_2447
    new $P5264, "Undef"
  vivify_2447:
    find_lex $P5265, "$/"
    unless_null $P5265, vivify_2448
    $P5265 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P5266, $P5265["default_value"]
    unless_null $P5266, vivify_2449
    $P5266 = root_new ['parrot';'ResizablePMCArray']
  vivify_2449:
    set $P5267, $P5266[0]
    unless_null $P5267, vivify_2450
    $P5267 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P5268, $P5267["EXPR"]
    unless_null $P5268, vivify_2451
    new $P5268, "Undef"
  vivify_2451:
    $P5269 = $P5268."ast"()
    $P5264."viviself"($P5269)
  if_5249_end:
.annotate 'line', 1680
    find_lex $P5271, "$past"
    unless_null $P5271, vivify_2452
    new $P5271, "Undef"
  vivify_2452:
    $P5272 = $P5271."viviself"()
    if $P5272, unless_5270_end
    find_lex $P5273, "$?PACKAGE"
    get_who $P5274, $P5273
    set $P5275, $P5274["@BLOCK"]
    unless_null $P5275, vivify_2453
    $P5275 = root_new ['parrot';'ResizablePMCArray']
  vivify_2453:
    set $P5276, $P5275[0]
    unless_null $P5276, vivify_2454
    new $P5276, "Undef"
  vivify_2454:
    find_lex $P5277, "$?PACKAGE"
    get_who $P5278, $P5277
    set $P5279, $P5278["@BLOCK"]
    unless_null $P5279, vivify_2455
    $P5279 = root_new ['parrot';'ResizablePMCArray']
  vivify_2455:
    set $P5280, $P5279[0]
    unless_null $P5280, vivify_2456
    new $P5280, "Undef"
  vivify_2456:
    $P5281 = $P5280."arity"()
    set $N5282, $P5281
    new $P5283, 'Float'
    set $P5283, $N5282
    add $P5284, $P5283, 1
    $P5276."arity"($P5284)
  unless_5270_end:
.annotate 'line', 1684
    find_lex $P5286, "$/"
    unless_null $P5286, vivify_2457
    $P5286 = root_new ['parrot';'Hash']
  vivify_2457:
    set $P5287, $P5286["typename"]
    unless_null $P5287, vivify_2458
    new $P5287, "Undef"
  vivify_2458:
    unless $P5287, if_5285_end
.annotate 'line', 1685
    find_lex $P5288, "$past"
    unless_null $P5288, vivify_2459
    new $P5288, "Undef"
  vivify_2459:
    find_lex $P5289, "$/"
    unless_null $P5289, vivify_2460
    $P5289 = root_new ['parrot';'Hash']
  vivify_2460:
    set $P5290, $P5289["typename"]
    unless_null $P5290, vivify_2461
    $P5290 = root_new ['parrot';'ResizablePMCArray']
  vivify_2461:
    set $P5291, $P5290[0]
    unless_null $P5291, vivify_2462
    new $P5291, "Undef"
  vivify_2462:
    $P5292 = $P5291."ast"()
    $P5288."multitype"($P5292)
  if_5285_end:
.annotate 'line', 1689
    find_lex $P5294, "$/"
    unless_null $P5294, vivify_2463
    $P5294 = root_new ['parrot';'Hash']
  vivify_2463:
    set $P5295, $P5294["definedness"]
    unless_null $P5295, vivify_2464
    new $P5295, "Undef"
  vivify_2464:
    unless $P5295, if_5293_end
.annotate 'line', 1690
    find_lex $P5296, "$/"
    unless_null $P5296, vivify_2465
    $P5296 = root_new ['parrot';'Hash']
  vivify_2465:
    set $P5297, $P5296["definedness"]
    unless_null $P5297, vivify_2466
    $P5297 = root_new ['parrot';'ResizablePMCArray']
  vivify_2466:
    set $P5298, $P5297[0]
    unless_null $P5298, vivify_2467
    new $P5298, "Undef"
  vivify_2467:
    set $S5299, $P5298
    new $P5300, 'String'
    set $P5300, $S5299
    find_lex $P5301, "$past"
    unless_null $P5301, vivify_2468
    $P5301 = root_new ['parrot';'Hash']
    store_lex "$past", $P5301
  vivify_2468:
    set $P5301["definedness"], $P5300
  if_5293_end:
.annotate 'line', 1693
    find_lex $P5302, "$/"
    find_lex $P5303, "$past"
    unless_null $P5303, vivify_2469
    new $P5303, "Undef"
  vivify_2469:
    $P5304 = $P5302."!make"($P5303)
.annotate 'line', 1652
    .return ($P5304)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("523_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5306
    .param pmc param_5307
.annotate 'line', 1696
    .lex "self", param_5306
    .lex "$/", param_5307
.annotate 'line', 1697
    new $P5308, "Undef"
    .lex "$name", $P5308
.annotate 'line', 1698
    new $P5309, "Undef"
    .lex "$past", $P5309
.annotate 'line', 1697
    find_lex $P5310, "$/"
    unless_null $P5310, vivify_2470
    new $P5310, "Undef"
  vivify_2470:
    set $S5311, $P5310
    new $P5312, 'String'
    set $P5312, $S5311
    store_lex "$name", $P5312
.annotate 'line', 1698
    get_hll_global $P5313, "GLOBAL"
    nqp_get_package_through_who $P5314, $P5313, "PAST"
    get_who $P5315, $P5314
    set $P5316, $P5315["Var"]
    find_lex $P5317, "$name"
    unless_null $P5317, vivify_2471
    new $P5317, "Undef"
  vivify_2471:
    find_lex $P5318, "$/"
    unless_null $P5318, vivify_2472
    new $P5318, "Undef"
  vivify_2472:
    $P5319 = $P5316."new"($P5317 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5318 :named("node"))
    store_lex "$past", $P5319
.annotate 'line', 1700
    find_lex $P5320, "$?PACKAGE"
    get_who $P5321, $P5320
    set $P5322, $P5321["@BLOCK"]
    unless_null $P5322, vivify_2473
    $P5322 = root_new ['parrot';'ResizablePMCArray']
  vivify_2473:
    set $P5323, $P5322[0]
    unless_null $P5323, vivify_2474
    new $P5323, "Undef"
  vivify_2474:
    find_lex $P5324, "$name"
    unless_null $P5324, vivify_2475
    new $P5324, "Undef"
  vivify_2475:
    $P5323."symbol"($P5324, "lexical" :named("scope"))
.annotate 'line', 1701
    find_lex $P5325, "$/"
    find_lex $P5326, "$past"
    unless_null $P5326, vivify_2476
    new $P5326, "Undef"
  vivify_2476:
    $P5327 = $P5325."!make"($P5326)
.annotate 'line', 1696
    .return ($P5327)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("524_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5329
    .param pmc param_5330
.annotate 'line', 1704
    .lex "self", param_5329
    .lex "$/", param_5330
.annotate 'line', 1705
    new $P5331, "Undef"
    .lex "$past", $P5331
    find_lex $P5332, "$/"
    unless_null $P5332, vivify_2477
    $P5332 = root_new ['parrot';'Hash']
  vivify_2477:
    set $P5333, $P5332["param_var"]
    unless_null $P5333, vivify_2478
    new $P5333, "Undef"
  vivify_2478:
    $P5334 = $P5333."ast"()
    store_lex "$past", $P5334
.annotate 'line', 1706
    find_lex $P5335, "$past"
    unless_null $P5335, vivify_2479
    new $P5335, "Undef"
  vivify_2479:
    find_lex $P5336, "$/"
    unless_null $P5336, vivify_2480
    $P5336 = root_new ['parrot';'Hash']
  vivify_2480:
    set $P5337, $P5336["param_var"]
    unless_null $P5337, vivify_2481
    $P5337 = root_new ['parrot';'Hash']
  vivify_2481:
    set $P5338, $P5337["name"]
    unless_null $P5338, vivify_2482
    new $P5338, "Undef"
  vivify_2482:
    set $S5339, $P5338
    $P5335."named"($S5339)
.annotate 'line', 1707
    find_lex $P5340, "$/"
    find_lex $P5341, "$past"
    unless_null $P5341, vivify_2483
    new $P5341, "Undef"
  vivify_2483:
    $P5342 = $P5340."!make"($P5341)
.annotate 'line', 1704
    .return ($P5342)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("525_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5344
    .param pmc param_5345
.annotate 'line', 1710
    .const 'Sub' $P5357 = "526_1304277427.017" 
    capture_lex $P5357
    .lex "self", param_5344
    .lex "$/", param_5345
.annotate 'line', 1714
    $P5346 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5346
.annotate 'line', 1715
    new $P5347, "Undef"
    .lex "$found", $P5347
.annotate 'line', 1714
    get_hll_global $P5348, "GLOBAL"
    nqp_get_package_through_who $P5349, $P5348, "HLL"
    get_who $P5350, $P5349
    set $P5351, $P5350["Compiler"]
    find_lex $P5352, "$/"
    unless_null $P5352, vivify_2484
    new $P5352, "Undef"
  vivify_2484:
    set $S5353, $P5352
    $P5354 = $P5351."parse_name"($S5353)
    store_lex "@name", $P5354
.annotate 'line', 1715
    new $P5355, "Integer"
    assign $P5355, 0
    store_lex "$found", $P5355
.annotate 'line', 1716
    .const 'Sub' $P5357 = "526_1304277427.017" 
    capture_lex $P5357
    $P5357()
.annotate 'line', 1721
    find_lex $P5378, "$found"
    unless_null $P5378, vivify_2490
    new $P5378, "Undef"
  vivify_2490:
    unless $P5378, unless_5377
    set $P5376, $P5378
    goto unless_5377_end
  unless_5377:
.annotate 'line', 1722
    find_lex $P5379, "$/"
    unless_null $P5379, vivify_2491
    new $P5379, "Undef"
  vivify_2491:
    $P5380 = $P5379."CURSOR"()
    new $P5381, "String"
    assign $P5381, "Use of undeclared type '"
    find_lex $P5382, "$/"
    unless_null $P5382, vivify_2492
    new $P5382, "Undef"
  vivify_2492:
    set $S5383, $P5382
    concat $P5384, $P5381, $S5383
    concat $P5385, $P5384, "'"
    $P5386 = $P5380."panic"($P5385)
.annotate 'line', 1721
    set $P5376, $P5386
  unless_5377_end:
.annotate 'line', 1710
    .return ($P5376)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5356"  :anon :subid("526_1304277427.017") :outer("525_1304277427.017")
.annotate 'line', 1716
    new $P5371, 'ExceptionHandler'
    set_label $P5371, control_5370
    $P5371."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P5371
.annotate 'line', 1717
    new $P5358, "Undef"
    .lex "$sym", $P5358
    find_lex $P5359, "@name"
    unless_null $P5359, vivify_2485
    $P5359 = root_new ['parrot';'ResizablePMCArray']
  vivify_2485:
    find_lex $P5360, "$/"
    unless_null $P5360, vivify_2486
    new $P5360, "Undef"
  vivify_2486:
    $P5361 = "find_sym"($P5359, $P5360)
    store_lex "$sym", $P5361
.annotate 'line', 1718
    find_dynamic_lex $P5362, "$/"
    find_dynamic_lex $P5365, "$*SC"
    unless_null $P5365, vivify_2487
    get_hll_global $P5363, "GLOBAL"
    get_who $P5364, $P5363
    set $P5365, $P5364["$SC"]
    unless_null $P5365, vivify_2488
    die "Contextual $*SC not found"
  vivify_2488:
  vivify_2487:
    find_lex $P5366, "$sym"
    unless_null $P5366, vivify_2489
    new $P5366, "Undef"
  vivify_2489:
    $P5367 = $P5365."get_object_sc_ref_past"($P5366)
    $P5362."!make"($P5367)
.annotate 'line', 1719
    new $P5368, "Integer"
    assign $P5368, 1
    store_lex "$found", $P5368
.annotate 'line', 1716
    pop_eh 
    goto skip_handler_5369
  control_5370:
    .local pmc exception 
    .get_results (exception) 
    new $P5374, 'Integer'
    set $P5374, 1
    set exception["handled"], $P5374
    set $I5375, exception["handled"]
    ne $I5375, 1, nothandled_5373
  handled_5372:
    .return (exception)
  nothandled_5373:
    rethrow exception
  skip_handler_5369:
    .return ($P5368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("527_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5388
    .param pmc param_5389
.annotate 'line', 1726
    .lex "self", param_5388
    .lex "$/", param_5389
.annotate 'line', 1727
    find_lex $P5390, "$/"
    find_lex $P5391, "$/"
    unless_null $P5391, vivify_2493
    $P5391 = root_new ['parrot';'Hash']
  vivify_2493:
    set $P5392, $P5391["trait_mod"]
    unless_null $P5392, vivify_2494
    new $P5392, "Undef"
  vivify_2494:
    $P5393 = $P5392."ast"()
    $P5394 = $P5390."!make"($P5393)
.annotate 'line', 1726
    .return ($P5394)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("528_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5396
    .param pmc param_5397
.annotate 'line', 1730
    .const 'Sub' $P5405 = "529_1304277427.017" 
    capture_lex $P5405
    .lex "self", param_5396
    .lex "$/", param_5397
.annotate 'line', 1731
    find_lex $P5400, "$/"
    unless_null $P5400, vivify_2495
    $P5400 = root_new ['parrot';'Hash']
  vivify_2495:
    set $P5401, $P5400["longname"]
    unless_null $P5401, vivify_2496
    new $P5401, "Undef"
  vivify_2496:
    set $S5402, $P5401
    iseq $I5403, $S5402, "parrot_vtable"
    if $I5403, if_5399
.annotate 'line', 1744
    find_lex $P5453, "$/"
    unless_null $P5453, vivify_2497
    $P5453 = root_new ['parrot';'Hash']
  vivify_2497:
    set $P5454, $P5453["longname"]
    unless_null $P5454, vivify_2498
    new $P5454, "Undef"
  vivify_2498:
    set $S5455, $P5454
    iseq $I5456, $S5455, "pirflags"
    if $I5456, if_5452
.annotate 'line', 1748
    find_lex $P5460, "$/"
    unless_null $P5460, vivify_2499
    new $P5460, "Undef"
  vivify_2499:
    $P5461 = $P5460."CURSOR"()
    new $P5462, 'String'
    set $P5462, "Trait '"
    find_lex $P5463, "$/"
    unless_null $P5463, vivify_2500
    $P5463 = root_new ['parrot';'Hash']
  vivify_2500:
    set $P5464, $P5463["longname"]
    unless_null $P5464, vivify_2501
    new $P5464, "Undef"
  vivify_2501:
    concat $P5465, $P5462, $P5464
    concat $P5466, $P5465, "' not implemented"
    $P5467 = $P5461."panic"($P5466)
.annotate 'line', 1747
    set $P5451, $P5467
.annotate 'line', 1744
    goto if_5452_end
  if_5452:
.annotate 'line', 1745
    find_lex $P5457, "$/"
    unless_null $P5457, vivify_2502
    new $P5457, "Undef"
  vivify_2502:
    $P5458 = $P5457."CURSOR"()
    $P5459 = $P5458."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1744
    set $P5451, $P5459
  if_5452_end:
    set $P5398, $P5451
.annotate 'line', 1731
    goto if_5399_end
  if_5399:
    .const 'Sub' $P5405 = "529_1304277427.017" 
    capture_lex $P5405
    $P5450 = $P5405()
    set $P5398, $P5450
  if_5399_end:
.annotate 'line', 1730
    .return ($P5398)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5404"  :anon :subid("529_1304277427.017") :outer("528_1304277427.017")
.annotate 'line', 1731
    .const 'Sub' $P5436 = "530_1304277427.017" 
    capture_lex $P5436
.annotate 'line', 1733
    new $P5406, "Undef"
    .lex "$cpast", $P5406
.annotate 'line', 1736
    new $P5407, "Undef"
    .lex "$name", $P5407
.annotate 'line', 1737
    new $P5408, "Undef"
    .lex "$package", $P5408
.annotate 'line', 1738
    new $P5409, "Undef"
    .lex "$is_dispatcher", $P5409
.annotate 'line', 1733
    find_lex $P5410, "$/"
    unless_null $P5410, vivify_2503
    $P5410 = root_new ['parrot';'Hash']
  vivify_2503:
    set $P5411, $P5410["circumfix"]
    unless_null $P5411, vivify_2504
    $P5411 = root_new ['parrot';'ResizablePMCArray']
  vivify_2504:
    set $P5412, $P5411[0]
    unless_null $P5412, vivify_2505
    new $P5412, "Undef"
  vivify_2505:
    $P5413 = $P5412."ast"()
    store_lex "$cpast", $P5413
.annotate 'line', 1735
    get_hll_global $P5415, "GLOBAL"
    nqp_get_package_through_who $P5416, $P5415, "PAST"
    get_who $P5417, $P5416
    set $P5418, $P5417["Val"]
    find_lex $P5419, "$cpast"
    unless_null $P5419, vivify_2506
    new $P5419, "Undef"
  vivify_2506:
    $P5420 = $P5418."ACCEPTS"($P5419)
    if $P5420, unless_5414_end
.annotate 'line', 1734
    find_lex $P5421, "$/"
    unless_null $P5421, vivify_2507
    new $P5421, "Undef"
  vivify_2507:
    $P5422 = $P5421."CURSOR"()
    $P5422."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5414_end:
.annotate 'line', 1736
    find_lex $P5423, "$cpast"
    unless_null $P5423, vivify_2508
    new $P5423, "Undef"
  vivify_2508:
    $P5424 = $P5423."value"()
    store_lex "$name", $P5424
.annotate 'line', 1737
    find_dynamic_lex $P5427, "$*PACKAGE"
    unless_null $P5427, vivify_2509
    get_hll_global $P5425, "GLOBAL"
    get_who $P5426, $P5425
    set $P5427, $P5426["$PACKAGE"]
    unless_null $P5427, vivify_2510
    die "Contextual $*PACKAGE not found"
  vivify_2510:
  vivify_2509:
    store_lex "$package", $P5427
.annotate 'line', 1738
    find_dynamic_lex $P5430, "$*SCOPE"
    unless_null $P5430, vivify_2511
    get_hll_global $P5428, "GLOBAL"
    get_who $P5429, $P5428
    set $P5430, $P5429["$SCOPE"]
    unless_null $P5430, vivify_2512
    die "Contextual $*SCOPE not found"
  vivify_2512:
  vivify_2511:
    set $S5431, $P5430
    iseq $I5432, $S5431, "proto"
    new $P5433, 'Integer'
    set $P5433, $I5432
    store_lex "$is_dispatcher", $P5433
.annotate 'line', 1739
    find_dynamic_lex $P5434, "$/"
    .const 'Sub' $P5436 = "530_1304277427.017" 
    newclosure $P5448, $P5436
    $P5449 = $P5434."!make"($P5448)
.annotate 'line', 1731
    .return ($P5449)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5435"  :anon :subid("530_1304277427.017") :outer("529_1304277427.017")
    .param pmc param_5437
.annotate 'line', 1739
    .lex "$match", param_5437
.annotate 'line', 1740
    find_dynamic_lex $P5440, "$*SC"
    unless_null $P5440, vivify_2513
    get_hll_global $P5438, "GLOBAL"
    get_who $P5439, $P5438
    set $P5440, $P5439["$SC"]
    unless_null $P5440, vivify_2514
    die "Contextual $*SC not found"
  vivify_2514:
  vivify_2513:
    find_lex $P5441, "$package"
    unless_null $P5441, vivify_2515
    new $P5441, "Undef"
  vivify_2515:
    find_lex $P5442, "$name"
    unless_null $P5442, vivify_2516
    new $P5442, "Undef"
  vivify_2516:
.annotate 'line', 1741
    find_lex $P5443, "$match"
    unless_null $P5443, vivify_2517
    new $P5443, "Undef"
  vivify_2517:
    $P5444 = $P5443."ast"()
    set $P5445, $P5444["block_past"]
    unless_null $P5445, vivify_2518
    new $P5445, "Undef"
  vivify_2518:
.annotate 'line', 1740
    find_lex $P5446, "$is_dispatcher"
    unless_null $P5446, vivify_2519
    new $P5446, "Undef"
  vivify_2519:
    $P5447 = $P5440."pkg_add_method"($P5441, "add_parrot_vtable_mapping", $P5442, $P5445, $P5446)
.annotate 'line', 1739
    .return ($P5447)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("531_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5471
    .param pmc param_5472
    .param pmc param_5473 :optional
    .param int has_param_5473 :opt_flag
.annotate 'line', 1752
    .const 'Sub' $P5600 = "534_1304277427.017" 
    capture_lex $P5600
    .const 'Sub' $P5562 = "533_1304277427.017" 
    capture_lex $P5562
    .const 'Sub' $P5542 = "532_1304277427.017" 
    capture_lex $P5542
    new $P5470, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5470, control_5469
    push_eh $P5470
    .lex "self", param_5471
    .lex "$/", param_5472
    if has_param_5473, optparam_2520
    new $P5474, "Undef"
    set param_5473, $P5474
  optparam_2520:
    .lex "$key", param_5473
.annotate 'line', 1753
    $P5475 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5475
.annotate 'line', 1754
    new $P5476, "Undef"
    .lex "$name", $P5476
.annotate 'line', 1755
    new $P5477, "Undef"
    .lex "$past", $P5477
.annotate 'line', 1753
    get_hll_global $P5478, "GLOBAL"
    nqp_get_package_through_who $P5479, $P5478, "Regex"
    nqp_get_package_through_who $P5480, $P5479, "P6Regex"
    nqp_get_package_through_who $P5481, $P5480, "Actions"
    get_who $P5482, $P5481
    set $P5483, $P5482["@MODIFIERS"]
    unless_null $P5483, vivify_2521
    $P5483 = root_new ['parrot';'ResizablePMCArray']
  vivify_2521:
    store_lex "@MODIFIERS", $P5483
.annotate 'line', 1754
    find_lex $P5484, "$/"
    unless_null $P5484, vivify_2522
    $P5484 = root_new ['parrot';'Hash']
  vivify_2522:
    set $P5485, $P5484["deflongname"]
    unless_null $P5485, vivify_2523
    new $P5485, "Undef"
  vivify_2523:
    $P5486 = $P5485."ast"()
    set $S5487, $P5486
    new $P5488, 'String'
    set $P5488, $S5487
    store_lex "$name", $P5488
    find_lex $P5489, "$past"
    unless_null $P5489, vivify_2524
    new $P5489, "Undef"
  vivify_2524:
.annotate 'line', 1756
    find_lex $P5491, "$/"
    unless_null $P5491, vivify_2525
    $P5491 = root_new ['parrot';'Hash']
  vivify_2525:
    set $P5492, $P5491["proto"]
    unless_null $P5492, vivify_2526
    new $P5492, "Undef"
  vivify_2526:
    if $P5492, if_5490
.annotate 'line', 1786
    find_lex $P5558, "$key"
    unless_null $P5558, vivify_2527
    new $P5558, "Undef"
  vivify_2527:
    set $S5559, $P5558
    iseq $I5560, $S5559, "open"
    if $I5560, if_5557
.annotate 'line', 1796
    .const 'Sub' $P5600 = "534_1304277427.017" 
    capture_lex $P5600
    $P5600()
    goto if_5557_end
  if_5557:
.annotate 'line', 1786
    .const 'Sub' $P5562 = "533_1304277427.017" 
    capture_lex $P5562
    $P5562()
  if_5557_end:
    goto if_5490_end
  if_5490:
.annotate 'line', 1758
    get_hll_global $P5493, "GLOBAL"
    nqp_get_package_through_who $P5494, $P5493, "PAST"
    get_who $P5495, $P5494
    set $P5496, $P5495["Stmts"]
.annotate 'line', 1759
    get_hll_global $P5497, "GLOBAL"
    nqp_get_package_through_who $P5498, $P5497, "PAST"
    get_who $P5499, $P5498
    set $P5500, $P5499["Block"]
    find_lex $P5501, "$name"
    unless_null $P5501, vivify_2565
    new $P5501, "Undef"
  vivify_2565:
.annotate 'line', 1760
    get_hll_global $P5502, "GLOBAL"
    nqp_get_package_through_who $P5503, $P5502, "PAST"
    get_who $P5504, $P5503
    set $P5505, $P5504["Op"]
.annotate 'line', 1761
    get_hll_global $P5506, "GLOBAL"
    nqp_get_package_through_who $P5507, $P5506, "PAST"
    get_who $P5508, $P5507
    set $P5509, $P5508["Var"]
    $P5510 = $P5509."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5511, "$name"
    unless_null $P5511, vivify_2566
    new $P5511, "Undef"
  vivify_2566:
    $P5512 = $P5505."new"($P5510, $P5511, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1760
    find_lex $P5513, "$/"
    unless_null $P5513, vivify_2567
    new $P5513, "Undef"
  vivify_2567:
    $P5514 = $P5500."new"($P5512, $P5501 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5513 :named("node"))
.annotate 'line', 1770
    get_hll_global $P5515, "GLOBAL"
    nqp_get_package_through_who $P5516, $P5515, "PAST"
    get_who $P5517, $P5516
    set $P5518, $P5517["Block"]
    new $P5519, "String"
    assign $P5519, "!PREFIX__"
    find_lex $P5520, "$name"
    unless_null $P5520, vivify_2568
    new $P5520, "Undef"
  vivify_2568:
    concat $P5521, $P5519, $P5520
.annotate 'line', 1771
    get_hll_global $P5522, "GLOBAL"
    nqp_get_package_through_who $P5523, $P5522, "PAST"
    get_who $P5524, $P5523
    set $P5525, $P5524["Op"]
.annotate 'line', 1772
    get_hll_global $P5526, "GLOBAL"
    nqp_get_package_through_who $P5527, $P5526, "PAST"
    get_who $P5528, $P5527
    set $P5529, $P5528["Var"]
    $P5530 = $P5529."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5531, "$name"
    unless_null $P5531, vivify_2569
    new $P5531, "Undef"
  vivify_2569:
    $P5532 = $P5525."new"($P5530, $P5531, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1771
    find_lex $P5533, "$/"
    unless_null $P5533, vivify_2570
    new $P5533, "Undef"
  vivify_2570:
    $P5534 = $P5518."new"($P5532, $P5521 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5533 :named("node"))
.annotate 'line', 1770
    $P5535 = $P5496."new"($P5514, $P5534)
.annotate 'line', 1758
    store_lex "$past", $P5535
.annotate 'line', 1782
    find_lex $P5537, "$past"
    unless_null $P5537, vivify_2571
    new $P5537, "Undef"
  vivify_2571:
    $P5538 = $P5537."list"()
    defined $I5539, $P5538
    unless $I5539, for_undef_2572
    iter $P5536, $P5538
    new $P5555, 'ExceptionHandler'
    set_label $P5555, loop5554_handler
    $P5555."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5555
  loop5554_test:
    unless $P5536, loop5554_done
    shift $P5540, $P5536
  loop5554_redo:
    .const 'Sub' $P5542 = "532_1304277427.017" 
    capture_lex $P5542
    $P5542($P5540)
  loop5554_next:
    goto loop5554_test
  loop5554_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5556, exception, 'type'
    eq $P5556, .CONTROL_LOOP_NEXT, loop5554_next
    eq $P5556, .CONTROL_LOOP_REDO, loop5554_redo
  loop5554_done:
    pop_eh 
  for_undef_2572:
  if_5490_end:
.annotate 'line', 1827
    find_lex $P5683, "$/"
    find_lex $P5684, "$past"
    unless_null $P5684, vivify_2579
    new $P5684, "Undef"
  vivify_2579:
    $P5685 = $P5683."!make"($P5684)
.annotate 'line', 1752
    .return ($P5685)
  control_5469:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5686, exception, "payload"
    .return ($P5686)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5599"  :anon :subid("534_1304277427.017") :outer("531_1304277427.017")
.annotate 'line', 1797
    new $P5601, "Undef"
    .lex "$regex", $P5601
.annotate 'line', 1798
    get_hll_global $P5602, "GLOBAL"
    nqp_get_package_through_who $P5603, $P5602, "Regex"
    nqp_get_package_through_who $P5604, $P5603, "P6Regex"
    nqp_get_package_through_who $P5605, $P5604, "Actions"
    get_who $P5606, $P5605
    set $P5607, $P5606["buildsub"]
    find_lex $P5608, "$/"
    unless_null $P5608, vivify_2528
    $P5608 = root_new ['parrot';'Hash']
  vivify_2528:
    set $P5609, $P5608["p6regex"]
    unless_null $P5609, vivify_2529
    new $P5609, "Undef"
  vivify_2529:
    $P5610 = $P5609."ast"()
    find_lex $P5611, "$?PACKAGE"
    get_who $P5612, $P5611
    set $P5613, $P5612["@BLOCK"]
    unless_null $P5613, vivify_2530
    $P5613 = root_new ['parrot';'ResizablePMCArray']
  vivify_2530:
    $P5614 = $P5613."shift"()
    $P5615 = $P5607($P5610, $P5614)
    store_lex "$regex", $P5615
.annotate 'line', 1799
    find_lex $P5616, "$regex"
    unless_null $P5616, vivify_2531
    new $P5616, "Undef"
  vivify_2531:
    find_lex $P5617, "$name"
    unless_null $P5617, vivify_2532
    new $P5617, "Undef"
  vivify_2532:
    $P5616."name"($P5617)
.annotate 'line', 1801
    get_hll_global $P5618, "GLOBAL"
    nqp_get_package_through_who $P5619, $P5618, "PAST"
    get_who $P5620, $P5619
    set $P5621, $P5620["Op"]
.annotate 'line', 1803
    new $P5622, "ResizablePMCArray"
    push $P5622, "Regex"
    push $P5622, "Method"
    find_lex $P5623, "$/"
    unless_null $P5623, vivify_2533
    new $P5623, "Undef"
  vivify_2533:
    $P5624 = "lexical_package_lookup"($P5622, $P5623)
    find_lex $P5625, "$regex"
    unless_null $P5625, vivify_2534
    new $P5625, "Undef"
  vivify_2534:
    $P5626 = $P5621."new"($P5624, $P5625, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1801
    store_lex "$past", $P5626
.annotate 'line', 1806
    find_dynamic_lex $P5630, "$*PACKAGE-SETUP"
    unless_null $P5630, vivify_2535
    get_hll_global $P5628, "GLOBAL"
    get_who $P5629, $P5628
    set $P5630, $P5629["$PACKAGE-SETUP"]
    unless_null $P5630, vivify_2536
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2536:
  vivify_2535:
    defined $I5631, $P5630
    unless $I5631, if_5627_end
.annotate 'line', 1807
    find_dynamic_lex $P5634, "$*SC"
    unless_null $P5634, vivify_2537
    get_hll_global $P5632, "GLOBAL"
    get_who $P5633, $P5632
    set $P5634, $P5633["$SC"]
    unless_null $P5634, vivify_2538
    die "Contextual $*SC not found"
  vivify_2538:
  vivify_2537:
    find_dynamic_lex $P5637, "$*PACKAGE"
    unless_null $P5637, vivify_2539
    get_hll_global $P5635, "GLOBAL"
    get_who $P5636, $P5635
    set $P5637, $P5636["$PACKAGE"]
    unless_null $P5637, vivify_2540
    die "Contextual $*PACKAGE not found"
  vivify_2540:
  vivify_2539:
    find_lex $P5638, "$name"
    unless_null $P5638, vivify_2541
    new $P5638, "Undef"
  vivify_2541:
    find_lex $P5639, "$regex"
    unless_null $P5639, vivify_2542
    new $P5639, "Undef"
  vivify_2542:
    $P5634."pkg_add_method"($P5637, "add_method", $P5638, $P5639, 0)
.annotate 'line', 1812
    find_dynamic_lex $P5642, "$*PACKAGE-SETUP"
    unless_null $P5642, vivify_2543
    get_hll_global $P5640, "GLOBAL"
    get_who $P5641, $P5640
    set $P5642, $P5641["$PACKAGE-SETUP"]
    unless_null $P5642, vivify_2544
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2544:
  vivify_2543:
    get_hll_global $P5643, "GLOBAL"
    nqp_get_package_through_who $P5644, $P5643, "PAST"
    get_who $P5645, $P5644
    set $P5646, $P5645["Op"]
.annotate 'line', 1814
    get_hll_global $P5647, "GLOBAL"
    nqp_get_package_through_who $P5648, $P5647, "PAST"
    get_who $P5649, $P5648
    set $P5650, $P5649["Op"]
.annotate 'line', 1816
    get_hll_global $P5651, "GLOBAL"
    nqp_get_package_through_who $P5652, $P5651, "PAST"
    get_who $P5653, $P5652
    set $P5654, $P5653["Var"]
    $P5655 = $P5654."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5656 = $P5650."new"($P5655, "get_how PP" :named("pirop"))
.annotate 'line', 1818
    get_hll_global $P5657, "GLOBAL"
    nqp_get_package_through_who $P5658, $P5657, "PAST"
    get_who $P5659, $P5658
    set $P5660, $P5659["Var"]
    $P5661 = $P5660."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1819
    get_hll_global $P5662, "GLOBAL"
    nqp_get_package_through_who $P5663, $P5662, "PAST"
    get_who $P5664, $P5663
    set $P5665, $P5664["Val"]
    new $P5666, "String"
    assign $P5666, "!PREFIX__"
    find_lex $P5667, "$name"
    unless_null $P5667, vivify_2545
    new $P5667, "Undef"
  vivify_2545:
    concat $P5668, $P5666, $P5667
    $P5669 = $P5665."new"($P5668 :named("value"))
.annotate 'line', 1820
    get_hll_global $P5670, "GLOBAL"
    nqp_get_package_through_who $P5671, $P5670, "PAST"
    get_who $P5672, $P5671
    set $P5673, $P5672["Var"]
    new $P5674, "String"
    assign $P5674, "!PREFIX__"
    find_lex $P5675, "$name"
    unless_null $P5675, vivify_2546
    new $P5675, "Undef"
  vivify_2546:
    concat $P5676, $P5674, $P5675
    $P5677 = $P5673."new"($P5676 :named("name"), "package" :named("scope"))
    $P5678 = $P5646."new"($P5656, $P5661, $P5669, $P5677, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1812
    $P5642."push"($P5678)
  if_5627_end:
.annotate 'line', 1824
    find_lex $P5679, "$regex"
    unless_null $P5679, vivify_2547
    new $P5679, "Undef"
  vivify_2547:
    find_lex $P5680, "$past"
    unless_null $P5680, vivify_2548
    $P5680 = root_new ['parrot';'Hash']
    store_lex "$past", $P5680
  vivify_2548:
    set $P5680["sink"], $P5679
.annotate 'line', 1825
    find_lex $P5681, "@MODIFIERS"
    unless_null $P5681, vivify_2549
    $P5681 = root_new ['parrot';'ResizablePMCArray']
  vivify_2549:
    $P5682 = $P5681."shift"()
.annotate 'line', 1796
    .return ($P5682)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5561"  :anon :subid("533_1304277427.017") :outer("531_1304277427.017")
.annotate 'line', 1787
    $P5563 = root_new ['parrot';'Hash']
    .lex "%h", $P5563
.annotate 'line', 1786
    find_lex $P5564, "%h"
    unless_null $P5564, vivify_2550
    $P5564 = root_new ['parrot';'Hash']
  vivify_2550:
.annotate 'line', 1788
    find_lex $P5566, "$/"
    unless_null $P5566, vivify_2551
    $P5566 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P5567, $P5566["sym"]
    unless_null $P5567, vivify_2552
    new $P5567, "Undef"
  vivify_2552:
    set $S5568, $P5567
    iseq $I5569, $S5568, "token"
    unless $I5569, if_5565_end
    new $P5570, "Integer"
    assign $P5570, 1
    find_lex $P5571, "%h"
    unless_null $P5571, vivify_2553
    $P5571 = root_new ['parrot';'Hash']
    store_lex "%h", $P5571
  vivify_2553:
    set $P5571["r"], $P5570
  if_5565_end:
.annotate 'line', 1789
    find_lex $P5573, "$/"
    unless_null $P5573, vivify_2554
    $P5573 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P5574, $P5573["sym"]
    unless_null $P5574, vivify_2555
    new $P5574, "Undef"
  vivify_2555:
    set $S5575, $P5574
    iseq $I5576, $S5575, "rule"
    unless $I5576, if_5572_end
    new $P5577, "Integer"
    assign $P5577, 1
    find_lex $P5578, "%h"
    unless_null $P5578, vivify_2556
    $P5578 = root_new ['parrot';'Hash']
    store_lex "%h", $P5578
  vivify_2556:
    set $P5578["r"], $P5577
    new $P5579, "Integer"
    assign $P5579, 1
    find_lex $P5580, "%h"
    unless_null $P5580, vivify_2557
    $P5580 = root_new ['parrot';'Hash']
    store_lex "%h", $P5580
  vivify_2557:
    set $P5580["s"], $P5579
  if_5572_end:
.annotate 'line', 1790
    find_lex $P5581, "@MODIFIERS"
    unless_null $P5581, vivify_2558
    $P5581 = root_new ['parrot';'ResizablePMCArray']
  vivify_2558:
    find_lex $P5582, "%h"
    unless_null $P5582, vivify_2559
    $P5582 = root_new ['parrot';'Hash']
  vivify_2559:
    $P5581."unshift"($P5582)
.annotate 'line', 1791
    find_lex $P5583, "$name"
    unless_null $P5583, vivify_2560
    new $P5583, "Undef"
  vivify_2560:
    get_hll_global $P5584, "GLOBAL"
    nqp_get_package_through_who $P5585, $P5584, "Regex"
    nqp_get_package_through_who $P5586, $P5585, "P6Regex"
    nqp_get_package_through_who $P5587, $P5586, "Actions"
    get_who $P5588, $P5587
    set $P5588["$REGEXNAME"], $P5583
.annotate 'line', 1792
    find_lex $P5589, "$?PACKAGE"
    get_who $P5590, $P5589
    set $P5591, $P5590["@BLOCK"]
    unless_null $P5591, vivify_2561
    $P5591 = root_new ['parrot';'ResizablePMCArray']
  vivify_2561:
    set $P5592, $P5591[0]
    unless_null $P5592, vivify_2562
    new $P5592, "Undef"
  vivify_2562:
    $P5592."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1793
    find_lex $P5593, "$?PACKAGE"
    get_who $P5594, $P5593
    set $P5595, $P5594["@BLOCK"]
    unless_null $P5595, vivify_2563
    $P5595 = root_new ['parrot';'ResizablePMCArray']
  vivify_2563:
    set $P5596, $P5595[0]
    unless_null $P5596, vivify_2564
    new $P5596, "Undef"
  vivify_2564:
    $P5596."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1794
    new $P5597, "Exception"
    set $P5597['type'], .CONTROL_RETURN
    new $P5598, "Integer"
    assign $P5598, 0
    setattribute $P5597, 'payload', $P5598
    throw $P5597
.annotate 'line', 1786
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5541"  :anon :subid("532_1304277427.017") :outer("531_1304277427.017")
    .param pmc param_5543
.annotate 'line', 1782
    .lex "$_", param_5543
.annotate 'line', 1783
    find_dynamic_lex $P5546, "$*SC"
    unless_null $P5546, vivify_2573
    get_hll_global $P5544, "GLOBAL"
    get_who $P5545, $P5544
    set $P5546, $P5545["$SC"]
    unless_null $P5546, vivify_2574
    die "Contextual $*SC not found"
  vivify_2574:
  vivify_2573:
    find_dynamic_lex $P5549, "$*PACKAGE"
    unless_null $P5549, vivify_2575
    get_hll_global $P5547, "GLOBAL"
    get_who $P5548, $P5547
    set $P5549, $P5548["$PACKAGE"]
    unless_null $P5549, vivify_2576
    die "Contextual $*PACKAGE not found"
  vivify_2576:
  vivify_2575:
    find_lex $P5550, "$_"
    unless_null $P5550, vivify_2577
    new $P5550, "Undef"
  vivify_2577:
    $P5551 = $P5550."name"()
    find_lex $P5552, "$_"
    unless_null $P5552, vivify_2578
    new $P5552, "Undef"
  vivify_2578:
    $P5553 = $P5546."pkg_add_method"($P5549, "add_method", $P5551, $P5552, 0)
.annotate 'line', 1782
    .return ($P5553)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("535_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5688
    .param pmc param_5689
.annotate 'line', 1831
    .lex "self", param_5688
    .lex "$/", param_5689
.annotate 'line', 1832
    new $P5690, "Undef"
    .lex "$past", $P5690
    find_lex $P5693, "$/"
    unless_null $P5693, vivify_2580
    $P5693 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P5694, $P5693["args"]
    unless_null $P5694, vivify_2581
    new $P5694, "Undef"
  vivify_2581:
    if $P5694, if_5692
    get_hll_global $P5699, "GLOBAL"
    nqp_get_package_through_who $P5700, $P5699, "PAST"
    get_who $P5701, $P5700
    set $P5702, $P5701["Op"]
    find_lex $P5703, "$/"
    unless_null $P5703, vivify_2582
    new $P5703, "Undef"
  vivify_2582:
    $P5704 = $P5702."new"($P5703 :named("node"))
    set $P5691, $P5704
    goto if_5692_end
  if_5692:
    find_lex $P5695, "$/"
    unless_null $P5695, vivify_2583
    $P5695 = root_new ['parrot';'Hash']
  vivify_2583:
    set $P5696, $P5695["args"]
    unless_null $P5696, vivify_2584
    $P5696 = root_new ['parrot';'ResizablePMCArray']
  vivify_2584:
    set $P5697, $P5696[0]
    unless_null $P5697, vivify_2585
    new $P5697, "Undef"
  vivify_2585:
    $P5698 = $P5697."ast"()
    set $P5691, $P5698
  if_5692_end:
    store_lex "$past", $P5691
.annotate 'line', 1833
    find_lex $P5706, "$/"
    unless_null $P5706, vivify_2586
    $P5706 = root_new ['parrot';'Hash']
  vivify_2586:
    set $P5707, $P5706["quote"]
    unless_null $P5707, vivify_2587
    new $P5707, "Undef"
  vivify_2587:
    if $P5707, if_5705
.annotate 'line', 1837
    find_lex $P5714, "$/"
    unless_null $P5714, vivify_2588
    $P5714 = root_new ['parrot';'Hash']
  vivify_2588:
    set $P5715, $P5714["longname"]
    unless_null $P5715, vivify_2589
    new $P5715, "Undef"
  vivify_2589:
    set $S5716, $P5715
    iseq $I5717, $S5716, "HOW"
    if $I5717, if_5713
.annotate 'line', 1840
    find_lex $P5720, "$/"
    unless_null $P5720, vivify_2590
    $P5720 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5721, $P5720["longname"]
    unless_null $P5721, vivify_2591
    new $P5721, "Undef"
  vivify_2591:
    set $S5722, $P5721
    iseq $I5723, $S5722, "WHAT"
    if $I5723, if_5719
.annotate 'line', 1843
    find_lex $P5726, "$/"
    unless_null $P5726, vivify_2592
    $P5726 = root_new ['parrot';'Hash']
  vivify_2592:
    set $P5727, $P5726["longname"]
    unless_null $P5727, vivify_2593
    new $P5727, "Undef"
  vivify_2593:
    set $S5728, $P5727
    iseq $I5729, $S5728, "WHO"
    if $I5729, if_5725
.annotate 'line', 1847
    find_lex $P5731, "$past"
    unless_null $P5731, vivify_2594
    new $P5731, "Undef"
  vivify_2594:
    find_lex $P5732, "$/"
    unless_null $P5732, vivify_2595
    $P5732 = root_new ['parrot';'Hash']
  vivify_2595:
    set $P5733, $P5732["longname"]
    unless_null $P5733, vivify_2596
    new $P5733, "Undef"
  vivify_2596:
    set $S5734, $P5733
    $P5731."name"($S5734)
.annotate 'line', 1848
    find_lex $P5735, "$past"
    unless_null $P5735, vivify_2597
    new $P5735, "Undef"
  vivify_2597:
    $P5735."pasttype"("callmethod")
.annotate 'line', 1846
    goto if_5725_end
  if_5725:
.annotate 'line', 1844
    find_lex $P5730, "$past"
    unless_null $P5730, vivify_2598
    new $P5730, "Undef"
  vivify_2598:
    $P5730."pirop"("get_who PP")
  if_5725_end:
.annotate 'line', 1843
    goto if_5719_end
  if_5719:
.annotate 'line', 1841
    find_lex $P5724, "$past"
    unless_null $P5724, vivify_2599
    new $P5724, "Undef"
  vivify_2599:
    $P5724."pirop"("get_what PP")
  if_5719_end:
.annotate 'line', 1840
    goto if_5713_end
  if_5713:
.annotate 'line', 1838
    find_lex $P5718, "$past"
    unless_null $P5718, vivify_2600
    new $P5718, "Undef"
  vivify_2600:
    $P5718."pirop"("get_how PP")
  if_5713_end:
.annotate 'line', 1837
    goto if_5705_end
  if_5705:
.annotate 'line', 1834
    find_lex $P5708, "$past"
    unless_null $P5708, vivify_2601
    new $P5708, "Undef"
  vivify_2601:
    find_lex $P5709, "$/"
    unless_null $P5709, vivify_2602
    $P5709 = root_new ['parrot';'Hash']
  vivify_2602:
    set $P5710, $P5709["quote"]
    unless_null $P5710, vivify_2603
    new $P5710, "Undef"
  vivify_2603:
    $P5711 = $P5710."ast"()
    $P5708."name"($P5711)
.annotate 'line', 1835
    find_lex $P5712, "$past"
    unless_null $P5712, vivify_2604
    new $P5712, "Undef"
  vivify_2604:
    $P5712."pasttype"("callmethod")
  if_5705_end:
.annotate 'line', 1850
    find_lex $P5736, "$/"
    find_lex $P5737, "$past"
    unless_null $P5737, vivify_2605
    new $P5737, "Undef"
  vivify_2605:
    $P5738 = $P5736."!make"($P5737)
.annotate 'line', 1831
    .return ($P5738)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("536_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5740
    .param pmc param_5741
.annotate 'line', 1855
    .lex "self", param_5740
    .lex "$/", param_5741
.annotate 'line', 1856
    find_lex $P5742, "$/"
    get_hll_global $P5743, "GLOBAL"
    nqp_get_package_through_who $P5744, $P5743, "PAST"
    get_who $P5745, $P5744
    set $P5746, $P5745["Var"]
    $P5747 = $P5746."new"("self" :named("name"))
    $P5748 = $P5742."!make"($P5747)
.annotate 'line', 1855
    .return ($P5748)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("537_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5750
    .param pmc param_5751
.annotate 'line', 1859
    .lex "self", param_5750
    .lex "$/", param_5751
.annotate 'line', 1860
    new $P5752, "Undef"
    .lex "$past", $P5752
    find_lex $P5753, "$/"
    unless_null $P5753, vivify_2606
    $P5753 = root_new ['parrot';'Hash']
  vivify_2606:
    set $P5754, $P5753["args"]
    unless_null $P5754, vivify_2607
    new $P5754, "Undef"
  vivify_2607:
    $P5755 = $P5754."ast"()
    store_lex "$past", $P5755
.annotate 'line', 1861
    find_lex $P5756, "$past"
    unless_null $P5756, vivify_2608
    new $P5756, "Undef"
  vivify_2608:
    find_lex $P5757, "$/"
    unless_null $P5757, vivify_2609
    $P5757 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5758, $P5757["deflongname"]
    unless_null $P5758, vivify_2610
    new $P5758, "Undef"
  vivify_2610:
    set $S5759, $P5758
    $P5756."name"($S5759)
.annotate 'line', 1862
    find_lex $P5760, "$/"
    find_lex $P5761, "$past"
    unless_null $P5761, vivify_2611
    new $P5761, "Undef"
  vivify_2611:
    $P5762 = $P5760."!make"($P5761)
.annotate 'line', 1859
    .return ($P5762)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("538_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5764
    .param pmc param_5765
.annotate 'line', 1865
    .const 'Sub' $P5783 = "539_1304277427.017" 
    capture_lex $P5783
    .lex "self", param_5764
    .lex "$/", param_5765
.annotate 'line', 1867
    new $P5766, "Undef"
    .lex "$var", $P5766
.annotate 'line', 1877
    new $P5767, "Undef"
    .lex "$past", $P5767
.annotate 'line', 1865
    find_lex $P5768, "$var"
    unless_null $P5768, vivify_2612
    new $P5768, "Undef"
  vivify_2612:
.annotate 'line', 1868
    find_lex $P5770, "$/"
    unless_null $P5770, vivify_2613
    $P5770 = root_new ['parrot';'Hash']
  vivify_2613:
    set $P5771, $P5770["name"]
    unless_null $P5771, vivify_2614
    new $P5771, "Undef"
  vivify_2614:
    set $S5772, $P5771
    $P5773 = "is_lexical"($S5772)
    if $P5773, if_5769
.annotate 'line', 1871
    .const 'Sub' $P5783 = "539_1304277427.017" 
    capture_lex $P5783
    $P5783()
    goto if_5769_end
  if_5769:
.annotate 'line', 1869
    get_hll_global $P5774, "GLOBAL"
    nqp_get_package_through_who $P5775, $P5774, "PAST"
    get_who $P5776, $P5775
    set $P5777, $P5776["Var"]
    find_lex $P5778, "$/"
    unless_null $P5778, vivify_2620
    $P5778 = root_new ['parrot';'Hash']
  vivify_2620:
    set $P5779, $P5778["name"]
    unless_null $P5779, vivify_2621
    new $P5779, "Undef"
  vivify_2621:
    set $S5780, $P5779
    $P5781 = $P5777."new"($S5780 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5781
  if_5769_end:
.annotate 'line', 1877
    find_lex $P5792, "$var"
    unless_null $P5792, vivify_2622
    new $P5792, "Undef"
  vivify_2622:
    store_lex "$past", $P5792
.annotate 'line', 1878
    find_lex $P5794, "$/"
    unless_null $P5794, vivify_2623
    $P5794 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P5795, $P5794["args"]
    unless_null $P5795, vivify_2624
    new $P5795, "Undef"
  vivify_2624:
    unless $P5795, if_5793_end
.annotate 'line', 1879
    find_lex $P5796, "$/"
    unless_null $P5796, vivify_2625
    $P5796 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P5797, $P5796["args"]
    unless_null $P5797, vivify_2626
    $P5797 = root_new ['parrot';'ResizablePMCArray']
  vivify_2626:
    set $P5798, $P5797[0]
    unless_null $P5798, vivify_2627
    new $P5798, "Undef"
  vivify_2627:
    $P5799 = $P5798."ast"()
    store_lex "$past", $P5799
.annotate 'line', 1880
    find_lex $P5800, "$past"
    unless_null $P5800, vivify_2628
    new $P5800, "Undef"
  vivify_2628:
    find_lex $P5801, "$var"
    unless_null $P5801, vivify_2629
    new $P5801, "Undef"
  vivify_2629:
    $P5800."unshift"($P5801)
  if_5793_end:
.annotate 'line', 1882
    find_lex $P5802, "$/"
    find_lex $P5803, "$past"
    unless_null $P5803, vivify_2630
    new $P5803, "Undef"
  vivify_2630:
    $P5804 = $P5802."!make"($P5803)
.annotate 'line', 1865
    .return ($P5804)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5782"  :anon :subid("539_1304277427.017") :outer("538_1304277427.017")
.annotate 'line', 1872
    $P5784 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5784
    find_lex $P5785, "$/"
    unless_null $P5785, vivify_2615
    $P5785 = root_new ['parrot';'Hash']
  vivify_2615:
    set $P5786, $P5785["name"]
    unless_null $P5786, vivify_2616
    $P5786 = root_new ['parrot';'Hash']
  vivify_2616:
    set $P5787, $P5786["identifier"]
    unless_null $P5787, vivify_2617
    new $P5787, "Undef"
  vivify_2617:
    clone $P5788, $P5787
    store_lex "@ns", $P5788
.annotate 'line', 1873
    find_lex $P5789, "@ns"
    unless_null $P5789, vivify_2618
    $P5789 = root_new ['parrot';'ResizablePMCArray']
  vivify_2618:
    find_lex $P5790, "$/"
    unless_null $P5790, vivify_2619
    new $P5790, "Undef"
  vivify_2619:
    $P5791 = "lexical_package_lookup"($P5789, $P5790)
    store_lex "$var", $P5791
.annotate 'line', 1871
    .return ($P5791)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("540_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5806
    .param pmc param_5807
.annotate 'line', 1885
    .lex "self", param_5806
    .lex "$/", param_5807
.annotate 'line', 1886
    new $P5808, "Undef"
    .lex "$past", $P5808
.annotate 'line', 1887
    new $P5809, "Undef"
    .lex "$pirop", $P5809
.annotate 'line', 1886
    find_lex $P5812, "$/"
    unless_null $P5812, vivify_2631
    $P5812 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P5813, $P5812["args"]
    unless_null $P5813, vivify_2632
    new $P5813, "Undef"
  vivify_2632:
    if $P5813, if_5811
    get_hll_global $P5818, "GLOBAL"
    nqp_get_package_through_who $P5819, $P5818, "PAST"
    get_who $P5820, $P5819
    set $P5821, $P5820["Op"]
    find_lex $P5822, "$/"
    unless_null $P5822, vivify_2633
    new $P5822, "Undef"
  vivify_2633:
    $P5823 = $P5821."new"($P5822 :named("node"))
    set $P5810, $P5823
    goto if_5811_end
  if_5811:
    find_lex $P5814, "$/"
    unless_null $P5814, vivify_2634
    $P5814 = root_new ['parrot';'Hash']
  vivify_2634:
    set $P5815, $P5814["args"]
    unless_null $P5815, vivify_2635
    $P5815 = root_new ['parrot';'ResizablePMCArray']
  vivify_2635:
    set $P5816, $P5815[0]
    unless_null $P5816, vivify_2636
    new $P5816, "Undef"
  vivify_2636:
    $P5817 = $P5816."ast"()
    set $P5810, $P5817
  if_5811_end:
    store_lex "$past", $P5810
.annotate 'line', 1887
    find_lex $P5824, "$/"
    unless_null $P5824, vivify_2637
    $P5824 = root_new ['parrot';'Hash']
  vivify_2637:
    set $P5825, $P5824["op"]
    unless_null $P5825, vivify_2638
    new $P5825, "Undef"
  vivify_2638:
    set $S5826, $P5825
    new $P5827, 'String'
    set $P5827, $S5826
    store_lex "$pirop", $P5827
.annotate 'line', 1888
    find_lex $P5828, "$pirop"
    unless_null $P5828, vivify_2639
    new $P5828, "Undef"
  vivify_2639:
    set $S5829, $P5828
    split $P5830, "__", $S5829
    join $S5831, " ", $P5830
    new $P5832, 'String'
    set $P5832, $S5831
    store_lex "$pirop", $P5832
.annotate 'line', 1889
    find_lex $P5833, "$past"
    unless_null $P5833, vivify_2640
    new $P5833, "Undef"
  vivify_2640:
    find_lex $P5834, "$pirop"
    unless_null $P5834, vivify_2641
    new $P5834, "Undef"
  vivify_2641:
    $P5833."pirop"($P5834)
.annotate 'line', 1890
    find_lex $P5835, "$past"
    unless_null $P5835, vivify_2642
    new $P5835, "Undef"
  vivify_2642:
    $P5835."pasttype"("pirop")
.annotate 'line', 1891
    find_lex $P5836, "$/"
    find_lex $P5837, "$past"
    unless_null $P5837, vivify_2643
    new $P5837, "Undef"
  vivify_2643:
    $P5838 = $P5836."!make"($P5837)
.annotate 'line', 1885
    .return ($P5838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("541_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5840
    .param pmc param_5841
.annotate 'line', 1894
    .lex "self", param_5840
    .lex "$/", param_5841
.annotate 'line', 1895
    find_lex $P5842, "$/"
    get_hll_global $P5843, "GLOBAL"
    nqp_get_package_through_who $P5844, $P5843, "PAST"
    get_who $P5845, $P5844
    set $P5846, $P5845["Op"]
    $P5847 = $P5846."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5848 = $P5842."!make"($P5847)
.annotate 'line', 1894
    .return ($P5848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("542_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5850
    .param pmc param_5851
.annotate 'line', 1900
    .lex "self", param_5850
    .lex "$/", param_5851
    find_lex $P5852, "$/"
    find_lex $P5853, "$/"
    unless_null $P5853, vivify_2644
    $P5853 = root_new ['parrot';'Hash']
  vivify_2644:
    set $P5854, $P5853["arglist"]
    unless_null $P5854, vivify_2645
    new $P5854, "Undef"
  vivify_2645:
    $P5855 = $P5854."ast"()
    $P5856 = $P5852."!make"($P5855)
    .return ($P5856)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("543_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5858
    .param pmc param_5859
.annotate 'line', 1902
    .const 'Sub' $P5873 = "544_1304277427.017" 
    capture_lex $P5873
    .lex "self", param_5858
    .lex "$/", param_5859
.annotate 'line', 1903
    new $P5860, "Undef"
    .lex "$past", $P5860
.annotate 'line', 1911
    new $P5861, "Undef"
    .lex "$i", $P5861
.annotate 'line', 1912
    new $P5862, "Undef"
    .lex "$n", $P5862
.annotate 'line', 1903
    get_hll_global $P5863, "GLOBAL"
    nqp_get_package_through_who $P5864, $P5863, "PAST"
    get_who $P5865, $P5864
    set $P5866, $P5865["Op"]
    find_lex $P5867, "$/"
    unless_null $P5867, vivify_2646
    new $P5867, "Undef"
  vivify_2646:
    $P5868 = $P5866."new"("call" :named("pasttype"), $P5867 :named("node"))
    store_lex "$past", $P5868
.annotate 'line', 1904
    find_lex $P5870, "$/"
    unless_null $P5870, vivify_2647
    $P5870 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P5871, $P5870["EXPR"]
    unless_null $P5871, vivify_2648
    new $P5871, "Undef"
  vivify_2648:
    unless $P5871, if_5869_end
    .const 'Sub' $P5873 = "544_1304277427.017" 
    capture_lex $P5873
    $P5873()
  if_5869_end:
.annotate 'line', 1911
    new $P5905, "Integer"
    assign $P5905, 0
    store_lex "$i", $P5905
.annotate 'line', 1912
    find_lex $P5906, "$past"
    unless_null $P5906, vivify_2659
    new $P5906, "Undef"
  vivify_2659:
    $P5907 = $P5906."list"()
    set $N5908, $P5907
    new $P5909, 'Float'
    set $P5909, $N5908
    store_lex "$n", $P5909
.annotate 'line', 1913
    new $P5960, 'ExceptionHandler'
    set_label $P5960, loop5959_handler
    $P5960."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5960
  loop5959_test:
    find_lex $P5910, "$i"
    unless_null $P5910, vivify_2660
    new $P5910, "Undef"
  vivify_2660:
    set $N5911, $P5910
    find_lex $P5912, "$n"
    unless_null $P5912, vivify_2661
    new $P5912, "Undef"
  vivify_2661:
    set $N5913, $P5912
    islt $I5914, $N5911, $N5913
    unless $I5914, loop5959_done
  loop5959_redo:
.annotate 'line', 1914
    find_lex $P5916, "$i"
    unless_null $P5916, vivify_2662
    new $P5916, "Undef"
  vivify_2662:
    set $I5917, $P5916
    find_lex $P5918, "$past"
    unless_null $P5918, vivify_2663
    $P5918 = root_new ['parrot';'ResizablePMCArray']
  vivify_2663:
    set $P5919, $P5918[$I5917]
    unless_null $P5919, vivify_2664
    new $P5919, "Undef"
  vivify_2664:
    $S5920 = $P5919."name"()
    iseq $I5921, $S5920, "&prefix:<|>"
    unless $I5921, if_5915_end
.annotate 'line', 1915
    find_lex $P5922, "$i"
    unless_null $P5922, vivify_2665
    new $P5922, "Undef"
  vivify_2665:
    set $I5923, $P5922
    find_lex $P5924, "$past"
    unless_null $P5924, vivify_2666
    $P5924 = root_new ['parrot';'ResizablePMCArray']
  vivify_2666:
    set $P5925, $P5924[$I5923]
    unless_null $P5925, vivify_2667
    $P5925 = root_new ['parrot';'ResizablePMCArray']
  vivify_2667:
    set $P5926, $P5925[0]
    unless_null $P5926, vivify_2668
    new $P5926, "Undef"
  vivify_2668:
    find_lex $P5927, "$i"
    unless_null $P5927, vivify_2669
    new $P5927, "Undef"
  vivify_2669:
    set $I5928, $P5927
    find_lex $P5929, "$past"
    unless_null $P5929, vivify_2670
    $P5929 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5929
  vivify_2670:
    set $P5929[$I5928], $P5926
.annotate 'line', 1916
    find_lex $P5930, "$i"
    unless_null $P5930, vivify_2671
    new $P5930, "Undef"
  vivify_2671:
    set $I5931, $P5930
    find_lex $P5932, "$past"
    unless_null $P5932, vivify_2672
    $P5932 = root_new ['parrot';'ResizablePMCArray']
  vivify_2672:
    set $P5933, $P5932[$I5931]
    unless_null $P5933, vivify_2673
    new $P5933, "Undef"
  vivify_2673:
    $P5933."flat"(1)
.annotate 'line', 1917
    find_lex $P5937, "$i"
    unless_null $P5937, vivify_2674
    new $P5937, "Undef"
  vivify_2674:
    set $I5938, $P5937
    find_lex $P5939, "$past"
    unless_null $P5939, vivify_2675
    $P5939 = root_new ['parrot';'ResizablePMCArray']
  vivify_2675:
    set $P5940, $P5939[$I5938]
    unless_null $P5940, vivify_2676
    new $P5940, "Undef"
  vivify_2676:
    get_hll_global $P5941, "GLOBAL"
    nqp_get_package_through_who $P5942, $P5941, "PAST"
    get_who $P5943, $P5942
    set $P5944, $P5943["Val"]
    $P5945 = $P5940."isa"($P5944)
    if $P5945, if_5936
    set $P5935, $P5945
    goto if_5936_end
  if_5936:
.annotate 'line', 1918
    find_lex $P5946, "$i"
    unless_null $P5946, vivify_2677
    new $P5946, "Undef"
  vivify_2677:
    set $I5947, $P5946
    find_lex $P5948, "$past"
    unless_null $P5948, vivify_2678
    $P5948 = root_new ['parrot';'ResizablePMCArray']
  vivify_2678:
    set $P5949, $P5948[$I5947]
    unless_null $P5949, vivify_2679
    new $P5949, "Undef"
  vivify_2679:
    $S5950 = $P5949."name"()
    substr $S5951, $S5950, 0, 1
    iseq $I5952, $S5951, "%"
    new $P5935, 'Integer'
    set $P5935, $I5952
  if_5936_end:
    unless $P5935, if_5934_end
.annotate 'line', 1919
    find_lex $P5953, "$i"
    unless_null $P5953, vivify_2680
    new $P5953, "Undef"
  vivify_2680:
    set $I5954, $P5953
    find_lex $P5955, "$past"
    unless_null $P5955, vivify_2681
    $P5955 = root_new ['parrot';'ResizablePMCArray']
  vivify_2681:
    set $P5956, $P5955[$I5954]
    unless_null $P5956, vivify_2682
    new $P5956, "Undef"
  vivify_2682:
    $P5956."named"(1)
  if_5934_end:
  if_5915_end:
.annotate 'line', 1914
    find_lex $P5957, "$i"
    unless_null $P5957, vivify_2683
    new $P5957, "Undef"
  vivify_2683:
    clone $P5958, $P5957
    inc $P5957
  loop5959_next:
.annotate 'line', 1913
    goto loop5959_test
  loop5959_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5961, exception, 'type'
    eq $P5961, .CONTROL_LOOP_NEXT, loop5959_next
    eq $P5961, .CONTROL_LOOP_REDO, loop5959_redo
  loop5959_done:
    pop_eh 
.annotate 'line', 1924
    find_lex $P5962, "$/"
    find_lex $P5963, "$past"
    unless_null $P5963, vivify_2684
    new $P5963, "Undef"
  vivify_2684:
    $P5964 = $P5962."!make"($P5963)
.annotate 'line', 1902
    .return ($P5964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5872"  :anon :subid("544_1304277427.017") :outer("543_1304277427.017")
.annotate 'line', 1904
    .const 'Sub' $P5894 = "545_1304277427.017" 
    capture_lex $P5894
.annotate 'line', 1905
    new $P5874, "Undef"
    .lex "$expr", $P5874
    find_lex $P5875, "$/"
    unless_null $P5875, vivify_2649
    $P5875 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P5876, $P5875["EXPR"]
    unless_null $P5876, vivify_2650
    new $P5876, "Undef"
  vivify_2650:
    $P5877 = $P5876."ast"()
    store_lex "$expr", $P5877
.annotate 'line', 1906
    find_lex $P5882, "$expr"
    unless_null $P5882, vivify_2651
    new $P5882, "Undef"
  vivify_2651:
    $S5883 = $P5882."name"()
    iseq $I5884, $S5883, "&infix:<,>"
    if $I5884, if_5881
    new $P5880, 'Integer'
    set $P5880, $I5884
    goto if_5881_end
  if_5881:
    find_lex $P5885, "$expr"
    unless_null $P5885, vivify_2652
    new $P5885, "Undef"
  vivify_2652:
    $P5886 = $P5885."named"()
    isfalse $I5887, $P5886
    new $P5880, 'Integer'
    set $P5880, $I5887
  if_5881_end:
    if $P5880, if_5879
.annotate 'line', 1909
    find_lex $P5902, "$past"
    unless_null $P5902, vivify_2653
    new $P5902, "Undef"
  vivify_2653:
    find_lex $P5903, "$expr"
    unless_null $P5903, vivify_2654
    new $P5903, "Undef"
  vivify_2654:
    $P5904 = $P5902."push"($P5903)
    set $P5878, $P5904
.annotate 'line', 1906
    goto if_5879_end
  if_5879:
.annotate 'line', 1907
    find_lex $P5889, "$expr"
    unless_null $P5889, vivify_2655
    new $P5889, "Undef"
  vivify_2655:
    $P5890 = $P5889."list"()
    defined $I5891, $P5890
    unless $I5891, for_undef_2656
    iter $P5888, $P5890
    new $P5900, 'ExceptionHandler'
    set_label $P5900, loop5899_handler
    $P5900."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5900
  loop5899_test:
    unless $P5888, loop5899_done
    shift $P5892, $P5888
  loop5899_redo:
    .const 'Sub' $P5894 = "545_1304277427.017" 
    capture_lex $P5894
    $P5894($P5892)
  loop5899_next:
    goto loop5899_test
  loop5899_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5901, exception, 'type'
    eq $P5901, .CONTROL_LOOP_NEXT, loop5899_next
    eq $P5901, .CONTROL_LOOP_REDO, loop5899_redo
  loop5899_done:
    pop_eh 
  for_undef_2656:
.annotate 'line', 1906
    set $P5878, $P5888
  if_5879_end:
.annotate 'line', 1904
    .return ($P5878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5893"  :anon :subid("545_1304277427.017") :outer("544_1304277427.017")
    .param pmc param_5895
.annotate 'line', 1907
    .lex "$_", param_5895
    find_lex $P5896, "$past"
    unless_null $P5896, vivify_2657
    new $P5896, "Undef"
  vivify_2657:
    find_lex $P5897, "$_"
    unless_null $P5897, vivify_2658
    new $P5897, "Undef"
  vivify_2658:
    $P5898 = $P5896."push"($P5897)
    .return ($P5898)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("546_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5966
    .param pmc param_5967
.annotate 'line', 1927
    .lex "self", param_5966
    .lex "$/", param_5967
    find_lex $P5968, "$/"
    find_lex $P5969, "$/"
    unless_null $P5969, vivify_2685
    $P5969 = root_new ['parrot';'Hash']
  vivify_2685:
    set $P5970, $P5969["multi_declarator"]
    unless_null $P5970, vivify_2686
    new $P5970, "Undef"
  vivify_2686:
    $P5971 = $P5970."ast"()
    $P5972 = $P5968."!make"($P5971)
    .return ($P5972)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("547_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5974
    .param pmc param_5975
.annotate 'line', 1929
    .lex "self", param_5974
    .lex "$/", param_5975
    find_lex $P5976, "$/"
    find_lex $P5977, "$/"
    unless_null $P5977, vivify_2687
    $P5977 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P5978, $P5977["value"]
    unless_null $P5978, vivify_2688
    new $P5978, "Undef"
  vivify_2688:
    $P5979 = $P5978."ast"()
    $P5980 = $P5976."!make"($P5979)
    .return ($P5980)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("548_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_5982
    .param pmc param_5983
.annotate 'line', 1931
    .lex "self", param_5982
    .lex "$/", param_5983
.annotate 'line', 1932
    find_lex $P5984, "$/"
.annotate 'line', 1933
    find_lex $P5987, "$/"
    unless_null $P5987, vivify_2689
    $P5987 = root_new ['parrot';'Hash']
  vivify_2689:
    set $P5988, $P5987["EXPR"]
    unless_null $P5988, vivify_2690
    new $P5988, "Undef"
  vivify_2690:
    if $P5988, if_5986
.annotate 'line', 1934
    get_hll_global $P5993, "GLOBAL"
    nqp_get_package_through_who $P5994, $P5993, "PAST"
    get_who $P5995, $P5994
    set $P5996, $P5995["Op"]
    find_lex $P5997, "$/"
    unless_null $P5997, vivify_2691
    new $P5997, "Undef"
  vivify_2691:
    $P5998 = $P5996."new"("list" :named("pasttype"), $P5997 :named("node"))
    set $P5985, $P5998
.annotate 'line', 1933
    goto if_5986_end
  if_5986:
    find_lex $P5989, "$/"
    unless_null $P5989, vivify_2692
    $P5989 = root_new ['parrot';'Hash']
  vivify_2692:
    set $P5990, $P5989["EXPR"]
    unless_null $P5990, vivify_2693
    $P5990 = root_new ['parrot';'ResizablePMCArray']
  vivify_2693:
    set $P5991, $P5990[0]
    unless_null $P5991, vivify_2694
    new $P5991, "Undef"
  vivify_2694:
    $P5992 = $P5991."ast"()
    set $P5985, $P5992
  if_5986_end:
    $P5999 = $P5984."!make"($P5985)
.annotate 'line', 1931
    .return ($P5999)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("549_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6001
    .param pmc param_6002
.annotate 'line', 1937
    .lex "self", param_6001
    .lex "$/", param_6002
.annotate 'line', 1938
    new $P6003, "Undef"
    .lex "$past", $P6003
.annotate 'line', 1937
    find_lex $P6004, "$past"
    unless_null $P6004, vivify_2695
    new $P6004, "Undef"
  vivify_2695:
.annotate 'line', 1939
    find_lex $P6006, "$/"
    unless_null $P6006, vivify_2696
    $P6006 = root_new ['parrot';'Hash']
  vivify_2696:
    set $P6007, $P6006["EXPR"]
    unless_null $P6007, vivify_2697
    new $P6007, "Undef"
  vivify_2697:
    if $P6007, if_6005
.annotate 'line', 1946
    get_hll_global $P6022, "GLOBAL"
    nqp_get_package_through_who $P6023, $P6022, "PAST"
    get_who $P6024, $P6023
    set $P6025, $P6024["Op"]
    $P6026 = $P6025."new"("list" :named("pasttype"))
    store_lex "$past", $P6026
.annotate 'line', 1945
    goto if_6005_end
  if_6005:
.annotate 'line', 1940
    find_lex $P6008, "$/"
    unless_null $P6008, vivify_2698
    $P6008 = root_new ['parrot';'Hash']
  vivify_2698:
    set $P6009, $P6008["EXPR"]
    unless_null $P6009, vivify_2699
    $P6009 = root_new ['parrot';'ResizablePMCArray']
  vivify_2699:
    set $P6010, $P6009[0]
    unless_null $P6010, vivify_2700
    new $P6010, "Undef"
  vivify_2700:
    $P6011 = $P6010."ast"()
    store_lex "$past", $P6011
.annotate 'line', 1941
    find_lex $P6013, "$past"
    unless_null $P6013, vivify_2701
    new $P6013, "Undef"
  vivify_2701:
    $S6014 = $P6013."name"()
    isne $I6015, $S6014, "&infix:<,>"
    unless $I6015, if_6012_end
.annotate 'line', 1942
    get_hll_global $P6016, "GLOBAL"
    nqp_get_package_through_who $P6017, $P6016, "PAST"
    get_who $P6018, $P6017
    set $P6019, $P6018["Op"]
    find_lex $P6020, "$past"
    unless_null $P6020, vivify_2702
    new $P6020, "Undef"
  vivify_2702:
    $P6021 = $P6019."new"($P6020, "list" :named("pasttype"))
    store_lex "$past", $P6021
  if_6012_end:
  if_6005_end:
.annotate 'line', 1948
    find_lex $P6027, "$past"
    unless_null $P6027, vivify_2703
    new $P6027, "Undef"
  vivify_2703:
    $P6027."name"("&circumfix:<[ ]>")
.annotate 'line', 1949
    find_lex $P6028, "$/"
    find_lex $P6029, "$past"
    unless_null $P6029, vivify_2704
    new $P6029, "Undef"
  vivify_2704:
    $P6030 = $P6028."!make"($P6029)
.annotate 'line', 1937
    .return ($P6030)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("550_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6032
    .param pmc param_6033
.annotate 'line', 1952
    .lex "self", param_6032
    .lex "$/", param_6033
    find_lex $P6034, "$/"
    find_lex $P6035, "$/"
    unless_null $P6035, vivify_2705
    $P6035 = root_new ['parrot';'Hash']
  vivify_2705:
    set $P6036, $P6035["quote_EXPR"]
    unless_null $P6036, vivify_2706
    new $P6036, "Undef"
  vivify_2706:
    $P6037 = $P6036."ast"()
    $P6038 = $P6034."!make"($P6037)
    .return ($P6038)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("551_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6040
    .param pmc param_6041
.annotate 'line', 1953
    .lex "self", param_6040
    .lex "$/", param_6041
    find_lex $P6042, "$/"
    find_lex $P6043, "$/"
    unless_null $P6043, vivify_2707
    $P6043 = root_new ['parrot';'Hash']
  vivify_2707:
    set $P6044, $P6043["quote_EXPR"]
    unless_null $P6044, vivify_2708
    new $P6044, "Undef"
  vivify_2708:
    $P6045 = $P6044."ast"()
    $P6046 = $P6042."!make"($P6045)
    .return ($P6046)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("552_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6048
    .param pmc param_6049
.annotate 'line', 1955
    .const 'Sub' $P6060 = "553_1304277427.017" 
    capture_lex $P6060
    .lex "self", param_6048
    .lex "$/", param_6049
.annotate 'line', 1956
    find_lex $P6052, "$/"
    unless_null $P6052, vivify_2709
    $P6052 = root_new ['parrot';'Hash']
  vivify_2709:
    set $P6053, $P6052["pblock"]
    unless_null $P6053, vivify_2710
    $P6053 = root_new ['parrot';'Hash']
  vivify_2710:
    set $P6054, $P6053["blockoid"]
    unless_null $P6054, vivify_2711
    $P6054 = root_new ['parrot';'Hash']
  vivify_2711:
    set $P6055, $P6054["statementlist"]
    unless_null $P6055, vivify_2712
    $P6055 = root_new ['parrot';'Hash']
  vivify_2712:
    set $P6056, $P6055["statement"]
    unless_null $P6056, vivify_2713
    new $P6056, "Undef"
  vivify_2713:
    set $N6057, $P6056
    isgt $I6058, $N6057, 0.0
    if $I6058, if_6051
.annotate 'line', 1961
    find_lex $P6073, "$/"
    unless_null $P6073, vivify_2714
    $P6073 = root_new ['parrot';'Hash']
  vivify_2714:
    set $P6074, $P6073["pblock"]
    unless_null $P6074, vivify_2715
    $P6074 = root_new ['parrot';'Hash']
  vivify_2715:
    set $P6075, $P6074["blockoid"]
    unless_null $P6075, vivify_2716
    $P6075 = root_new ['parrot';'Hash']
  vivify_2716:
    set $P6076, $P6075["you_are_here"]
    unless_null $P6076, vivify_2717
    new $P6076, "Undef"
  vivify_2717:
    if $P6076, if_6072
.annotate 'line', 1965
    find_lex $P6082, "$/"
    $P6083 = "vivitype"("%")
    $P6084 = $P6082."!make"($P6083)
.annotate 'line', 1964
    set $P6071, $P6084
.annotate 'line', 1961
    goto if_6072_end
  if_6072:
.annotate 'line', 1962
    find_lex $P6077, "$/"
    find_lex $P6078, "$/"
    unless_null $P6078, vivify_2718
    $P6078 = root_new ['parrot';'Hash']
  vivify_2718:
    set $P6079, $P6078["pblock"]
    unless_null $P6079, vivify_2719
    new $P6079, "Undef"
  vivify_2719:
    $P6080 = $P6079."ast"()
    $P6081 = $P6077."!make"($P6080)
.annotate 'line', 1961
    set $P6071, $P6081
  if_6072_end:
    set $P6050, $P6071
.annotate 'line', 1956
    goto if_6051_end
  if_6051:
    .const 'Sub' $P6060 = "553_1304277427.017" 
    capture_lex $P6060
    $P6070 = $P6060()
    set $P6050, $P6070
  if_6051_end:
.annotate 'line', 1955
    .return ($P6050)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6059"  :anon :subid("553_1304277427.017") :outer("552_1304277427.017")
.annotate 'line', 1957
    new $P6061, "Undef"
    .lex "$past", $P6061
    find_lex $P6062, "$/"
    unless_null $P6062, vivify_2720
    $P6062 = root_new ['parrot';'Hash']
  vivify_2720:
    set $P6063, $P6062["pblock"]
    unless_null $P6063, vivify_2721
    new $P6063, "Undef"
  vivify_2721:
    $P6064 = $P6063."ast"()
    store_lex "$past", $P6064
.annotate 'line', 1958
    new $P6065, "Integer"
    assign $P6065, 1
    find_lex $P6066, "$past"
    unless_null $P6066, vivify_2722
    $P6066 = root_new ['parrot';'Hash']
    store_lex "$past", $P6066
  vivify_2722:
    set $P6066["bareblock"], $P6065
.annotate 'line', 1959
    find_dynamic_lex $P6067, "$/"
    find_lex $P6068, "$past"
    unless_null $P6068, vivify_2723
    new $P6068, "Undef"
  vivify_2723:
    $P6069 = $P6067."!make"($P6068)
.annotate 'line', 1956
    .return ($P6069)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("554_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6086
    .param pmc param_6087
.annotate 'line', 1969
    .lex "self", param_6086
    .lex "$/", param_6087
.annotate 'line', 1970
    new $P6088, "Undef"
    .lex "$name", $P6088
    find_lex $P6091, "$/"
    unless_null $P6091, vivify_2724
    $P6091 = root_new ['parrot';'Hash']
  vivify_2724:
    set $P6092, $P6091["sigil"]
    unless_null $P6092, vivify_2725
    new $P6092, "Undef"
  vivify_2725:
    set $S6093, $P6092
    iseq $I6094, $S6093, "@"
    if $I6094, if_6090
.annotate 'line', 1971
    find_lex $P6098, "$/"
    unless_null $P6098, vivify_2726
    $P6098 = root_new ['parrot';'Hash']
  vivify_2726:
    set $P6099, $P6098["sigil"]
    unless_null $P6099, vivify_2727
    new $P6099, "Undef"
  vivify_2727:
    set $S6100, $P6099
    iseq $I6101, $S6100, "%"
    if $I6101, if_6097
    new $P6103, "String"
    assign $P6103, "item"
    set $P6096, $P6103
    goto if_6097_end
  if_6097:
    new $P6102, "String"
    assign $P6102, "hash"
    set $P6096, $P6102
  if_6097_end:
    set $P6089, $P6096
.annotate 'line', 1970
    goto if_6090_end
  if_6090:
    new $P6095, "String"
    assign $P6095, "list"
    set $P6089, $P6095
  if_6090_end:
    store_lex "$name", $P6089
.annotate 'line', 1973
    find_lex $P6104, "$/"
    get_hll_global $P6105, "GLOBAL"
    nqp_get_package_through_who $P6106, $P6105, "PAST"
    get_who $P6107, $P6106
    set $P6108, $P6107["Op"]
    find_lex $P6109, "$name"
    unless_null $P6109, vivify_2728
    new $P6109, "Undef"
  vivify_2728:
    find_lex $P6110, "$/"
    unless_null $P6110, vivify_2729
    $P6110 = root_new ['parrot';'Hash']
  vivify_2729:
    set $P6111, $P6110["semilist"]
    unless_null $P6111, vivify_2730
    new $P6111, "Undef"
  vivify_2730:
    $P6112 = $P6111."ast"()
    $P6113 = $P6108."new"($P6112, "callmethod" :named("pasttype"), $P6109 :named("name"))
    $P6114 = $P6104."!make"($P6113)
.annotate 'line', 1969
    .return ($P6114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("555_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6116
    .param pmc param_6117
.annotate 'line', 1976
    .lex "self", param_6116
    .lex "$/", param_6117
    find_lex $P6118, "$/"
    find_lex $P6119, "$/"
    unless_null $P6119, vivify_2731
    $P6119 = root_new ['parrot';'Hash']
  vivify_2731:
    set $P6120, $P6119["statement"]
    unless_null $P6120, vivify_2732
    new $P6120, "Undef"
  vivify_2732:
    $P6121 = $P6120."ast"()
    $P6122 = $P6118."!make"($P6121)
    .return ($P6122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("556_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6124
    .param pmc param_6125
.annotate 'line', 1978
    .lex "self", param_6124
    .lex "$/", param_6125
.annotate 'line', 1979
    find_lex $P6126, "$/"
    get_hll_global $P6127, "GLOBAL"
    nqp_get_package_through_who $P6128, $P6127, "PAST"
    get_who $P6129, $P6128
    set $P6130, $P6129["Var"]
    find_lex $P6131, "$/"
    unless_null $P6131, vivify_2733
    $P6131 = root_new ['parrot';'Hash']
  vivify_2733:
    set $P6132, $P6131["EXPR"]
    unless_null $P6132, vivify_2734
    new $P6132, "Undef"
  vivify_2734:
    $P6133 = $P6132."ast"()
.annotate 'line', 1981
    $P6134 = "vivitype"("@")
    $P6135 = $P6130."new"($P6133, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6134 :named("vivibase"))
.annotate 'line', 1979
    $P6136 = $P6126."!make"($P6135)
.annotate 'line', 1978
    .return ($P6136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("557_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6138
    .param pmc param_6139
.annotate 'line', 1984
    .lex "self", param_6138
    .lex "$/", param_6139
.annotate 'line', 1985
    find_lex $P6140, "$/"
    get_hll_global $P6141, "GLOBAL"
    nqp_get_package_through_who $P6142, $P6141, "PAST"
    get_who $P6143, $P6142
    set $P6144, $P6143["Var"]
    find_lex $P6145, "$/"
    unless_null $P6145, vivify_2735
    $P6145 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P6146, $P6145["EXPR"]
    unless_null $P6146, vivify_2736
    new $P6146, "Undef"
  vivify_2736:
    $P6147 = $P6146."ast"()
.annotate 'line', 1987
    $P6148 = "vivitype"("%")
    $P6149 = $P6144."new"($P6147, "keyed" :named("scope"), "Undef" :named("viviself"), $P6148 :named("vivibase"))
.annotate 'line', 1985
    $P6150 = $P6140."!make"($P6149)
.annotate 'line', 1984
    .return ($P6150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("558_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6152
    .param pmc param_6153
.annotate 'line', 1990
    .lex "self", param_6152
    .lex "$/", param_6153
.annotate 'line', 1991
    find_lex $P6154, "$/"
    get_hll_global $P6155, "GLOBAL"
    nqp_get_package_through_who $P6156, $P6155, "PAST"
    get_who $P6157, $P6156
    set $P6158, $P6157["Var"]
    find_lex $P6159, "$/"
    unless_null $P6159, vivify_2737
    $P6159 = root_new ['parrot';'Hash']
  vivify_2737:
    set $P6160, $P6159["quote_EXPR"]
    unless_null $P6160, vivify_2738
    new $P6160, "Undef"
  vivify_2738:
    $P6161 = $P6160."ast"()
.annotate 'line', 1993
    $P6162 = "vivitype"("%")
    $P6163 = $P6158."new"($P6161, "keyed" :named("scope"), "Undef" :named("viviself"), $P6162 :named("vivibase"))
.annotate 'line', 1991
    $P6164 = $P6154."!make"($P6163)
.annotate 'line', 1990
    .return ($P6164)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("559_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6166
    .param pmc param_6167
.annotate 'line', 1996
    .lex "self", param_6166
    .lex "$/", param_6167
.annotate 'line', 1997
    find_lex $P6168, "$/"
    find_lex $P6169, "$/"
    unless_null $P6169, vivify_2739
    $P6169 = root_new ['parrot';'Hash']
  vivify_2739:
    set $P6170, $P6169["arglist"]
    unless_null $P6170, vivify_2740
    new $P6170, "Undef"
  vivify_2740:
    $P6171 = $P6170."ast"()
    $P6172 = $P6168."!make"($P6171)
.annotate 'line', 1996
    .return ($P6172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("560_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6174
    .param pmc param_6175
.annotate 'line', 2000
    .lex "self", param_6174
    .lex "$/", param_6175
.annotate 'line', 2001
    find_lex $P6176, "$/"
    find_lex $P6179, "$/"
    unless_null $P6179, vivify_2741
    $P6179 = root_new ['parrot';'Hash']
  vivify_2741:
    set $P6180, $P6179["quote"]
    unless_null $P6180, vivify_2742
    new $P6180, "Undef"
  vivify_2742:
    if $P6180, if_6178
    find_lex $P6184, "$/"
    unless_null $P6184, vivify_2743
    $P6184 = root_new ['parrot';'Hash']
  vivify_2743:
    set $P6185, $P6184["number"]
    unless_null $P6185, vivify_2744
    new $P6185, "Undef"
  vivify_2744:
    $P6186 = $P6185."ast"()
    set $P6177, $P6186
    goto if_6178_end
  if_6178:
    find_lex $P6181, "$/"
    unless_null $P6181, vivify_2745
    $P6181 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P6182, $P6181["quote"]
    unless_null $P6182, vivify_2746
    new $P6182, "Undef"
  vivify_2746:
    $P6183 = $P6182."ast"()
    set $P6177, $P6183
  if_6178_end:
    $P6187 = $P6176."!make"($P6177)
.annotate 'line', 2000
    .return ($P6187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("561_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6189
    .param pmc param_6190
.annotate 'line', 2004
    .lex "self", param_6189
    .lex "$/", param_6190
.annotate 'line', 2005
    new $P6191, "Undef"
    .lex "$value", $P6191
    find_lex $P6194, "$/"
    unless_null $P6194, vivify_2747
    $P6194 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P6195, $P6194["dec_number"]
    unless_null $P6195, vivify_2748
    new $P6195, "Undef"
  vivify_2748:
    if $P6195, if_6193
    find_lex $P6199, "$/"
    unless_null $P6199, vivify_2749
    $P6199 = root_new ['parrot';'Hash']
  vivify_2749:
    set $P6200, $P6199["integer"]
    unless_null $P6200, vivify_2750
    new $P6200, "Undef"
  vivify_2750:
    $P6201 = $P6200."ast"()
    set $P6192, $P6201
    goto if_6193_end
  if_6193:
    find_lex $P6196, "$/"
    unless_null $P6196, vivify_2751
    $P6196 = root_new ['parrot';'Hash']
  vivify_2751:
    set $P6197, $P6196["dec_number"]
    unless_null $P6197, vivify_2752
    new $P6197, "Undef"
  vivify_2752:
    $P6198 = $P6197."ast"()
    set $P6192, $P6198
  if_6193_end:
    store_lex "$value", $P6192
.annotate 'line', 2006
    find_lex $P6203, "$/"
    unless_null $P6203, vivify_2753
    $P6203 = root_new ['parrot';'Hash']
  vivify_2753:
    set $P6204, $P6203["sign"]
    unless_null $P6204, vivify_2754
    new $P6204, "Undef"
  vivify_2754:
    set $S6205, $P6204
    iseq $I6206, $S6205, "-"
    unless $I6206, if_6202_end
    find_lex $P6207, "$value"
    unless_null $P6207, vivify_2755
    new $P6207, "Undef"
  vivify_2755:
    neg $P6208, $P6207
    store_lex "$value", $P6208
  if_6202_end:
.annotate 'line', 2007
    find_lex $P6209, "$/"
    get_hll_global $P6210, "GLOBAL"
    nqp_get_package_through_who $P6211, $P6210, "PAST"
    get_who $P6212, $P6211
    set $P6213, $P6212["Val"]
    find_lex $P6214, "$value"
    unless_null $P6214, vivify_2756
    new $P6214, "Undef"
  vivify_2756:
    $P6215 = $P6213."new"($P6214 :named("value"))
    $P6216 = $P6209."!make"($P6215)
.annotate 'line', 2004
    .return ($P6216)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("562_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6218
    .param pmc param_6219
.annotate 'line', 2010
    .lex "self", param_6218
    .lex "$/", param_6219
    find_lex $P6220, "$/"
    find_lex $P6221, "$/"
    unless_null $P6221, vivify_2757
    $P6221 = root_new ['parrot';'Hash']
  vivify_2757:
    set $P6222, $P6221["quote_EXPR"]
    unless_null $P6222, vivify_2758
    new $P6222, "Undef"
  vivify_2758:
    $P6223 = $P6222."ast"()
    $P6224 = $P6220."!make"($P6223)
    .return ($P6224)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("563_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6226
    .param pmc param_6227
.annotate 'line', 2011
    .lex "self", param_6226
    .lex "$/", param_6227
    find_lex $P6228, "$/"
    find_lex $P6229, "$/"
    unless_null $P6229, vivify_2759
    $P6229 = root_new ['parrot';'Hash']
  vivify_2759:
    set $P6230, $P6229["quote_EXPR"]
    unless_null $P6230, vivify_2760
    new $P6230, "Undef"
  vivify_2760:
    $P6231 = $P6230."ast"()
    $P6232 = $P6228."!make"($P6231)
    .return ($P6232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("564_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6234
    .param pmc param_6235
.annotate 'line', 2012
    .lex "self", param_6234
    .lex "$/", param_6235
    find_lex $P6236, "$/"
    find_lex $P6237, "$/"
    unless_null $P6237, vivify_2761
    $P6237 = root_new ['parrot';'Hash']
  vivify_2761:
    set $P6238, $P6237["quote_EXPR"]
    unless_null $P6238, vivify_2762
    new $P6238, "Undef"
  vivify_2762:
    $P6239 = $P6238."ast"()
    $P6240 = $P6236."!make"($P6239)
    .return ($P6240)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("565_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6242
    .param pmc param_6243
.annotate 'line', 2013
    .lex "self", param_6242
    .lex "$/", param_6243
    find_lex $P6244, "$/"
    find_lex $P6245, "$/"
    unless_null $P6245, vivify_2763
    $P6245 = root_new ['parrot';'Hash']
  vivify_2763:
    set $P6246, $P6245["quote_EXPR"]
    unless_null $P6246, vivify_2764
    new $P6246, "Undef"
  vivify_2764:
    $P6247 = $P6246."ast"()
    $P6248 = $P6244."!make"($P6247)
    .return ($P6248)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("566_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6250
    .param pmc param_6251
.annotate 'line', 2014
    .lex "self", param_6250
    .lex "$/", param_6251
    find_lex $P6252, "$/"
    find_lex $P6253, "$/"
    unless_null $P6253, vivify_2765
    $P6253 = root_new ['parrot';'Hash']
  vivify_2765:
    set $P6254, $P6253["quote_EXPR"]
    unless_null $P6254, vivify_2766
    new $P6254, "Undef"
  vivify_2766:
    $P6255 = $P6254."ast"()
    $P6256 = $P6252."!make"($P6255)
    .return ($P6256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("567_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6258
    .param pmc param_6259
.annotate 'line', 2015
    .lex "self", param_6258
    .lex "$/", param_6259
.annotate 'line', 2016
    find_lex $P6260, "$/"
    get_hll_global $P6261, "GLOBAL"
    nqp_get_package_through_who $P6262, $P6261, "PAST"
    get_who $P6263, $P6262
    set $P6264, $P6263["Op"]
    find_lex $P6265, "$/"
    unless_null $P6265, vivify_2767
    $P6265 = root_new ['parrot';'Hash']
  vivify_2767:
    set $P6266, $P6265["quote_EXPR"]
    unless_null $P6266, vivify_2768
    new $P6266, "Undef"
  vivify_2768:
    $P6267 = $P6266."ast"()
    $P6268 = $P6267."value"()
    find_lex $P6269, "$/"
    unless_null $P6269, vivify_2769
    new $P6269, "Undef"
  vivify_2769:
    $P6270 = $P6264."new"($P6268 :named("inline"), "inline" :named("pasttype"), $P6269 :named("node"))
    $P6271 = $P6260."!make"($P6270)
.annotate 'line', 2015
    .return ($P6271)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("568_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6275
    .param pmc param_6276
    .param pmc param_6277 :optional
    .param int has_param_6277 :opt_flag
.annotate 'line', 2021
    new $P6274, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6274, control_6273
    push_eh $P6274
    .lex "self", param_6275
    .lex "$/", param_6276
    if has_param_6277, optparam_2770
    new $P6278, "Undef"
    set param_6277, $P6278
  optparam_2770:
    .lex "$key", param_6277
.annotate 'line', 2028
    new $P6279, "Undef"
    .lex "$regex", $P6279
.annotate 'line', 2030
    new $P6280, "Undef"
    .lex "$past", $P6280
.annotate 'line', 2022
    find_lex $P6282, "$key"
    unless_null $P6282, vivify_2771
    new $P6282, "Undef"
  vivify_2771:
    set $S6283, $P6282
    iseq $I6284, $S6283, "open"
    unless $I6284, if_6281_end
.annotate 'line', 2023
    null $P6285
    get_hll_global $P6286, "GLOBAL"
    nqp_get_package_through_who $P6287, $P6286, "Regex"
    nqp_get_package_through_who $P6288, $P6287, "P6Regex"
    nqp_get_package_through_who $P6289, $P6288, "Actions"
    get_who $P6290, $P6289
    set $P6290["$REGEXNAME"], $P6285
.annotate 'line', 2024
    find_lex $P6291, "$?PACKAGE"
    get_who $P6292, $P6291
    set $P6293, $P6292["@BLOCK"]
    unless_null $P6293, vivify_2772
    $P6293 = root_new ['parrot';'ResizablePMCArray']
  vivify_2772:
    set $P6294, $P6293[0]
    unless_null $P6294, vivify_2773
    new $P6294, "Undef"
  vivify_2773:
    $P6294."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2025
    find_lex $P6295, "$?PACKAGE"
    get_who $P6296, $P6295
    set $P6297, $P6296["@BLOCK"]
    unless_null $P6297, vivify_2774
    $P6297 = root_new ['parrot';'ResizablePMCArray']
  vivify_2774:
    set $P6298, $P6297[0]
    unless_null $P6298, vivify_2775
    new $P6298, "Undef"
  vivify_2775:
    $P6298."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2026
    new $P6299, "Exception"
    set $P6299['type'], .CONTROL_RETURN
    new $P6300, "Integer"
    assign $P6300, 0
    setattribute $P6299, 'payload', $P6300
    throw $P6299
  if_6281_end:
.annotate 'line', 2029
    get_hll_global $P6301, "GLOBAL"
    nqp_get_package_through_who $P6302, $P6301, "Regex"
    nqp_get_package_through_who $P6303, $P6302, "P6Regex"
    nqp_get_package_through_who $P6304, $P6303, "Actions"
    get_who $P6305, $P6304
    set $P6306, $P6305["buildsub"]
    find_lex $P6307, "$/"
    unless_null $P6307, vivify_2776
    $P6307 = root_new ['parrot';'Hash']
  vivify_2776:
    set $P6308, $P6307["p6regex"]
    unless_null $P6308, vivify_2777
    new $P6308, "Undef"
  vivify_2777:
    $P6309 = $P6308."ast"()
    find_lex $P6310, "$?PACKAGE"
    get_who $P6311, $P6310
    set $P6312, $P6311["@BLOCK"]
    unless_null $P6312, vivify_2778
    $P6312 = root_new ['parrot';'ResizablePMCArray']
  vivify_2778:
    $P6313 = $P6312."shift"()
    $P6314 = $P6306($P6309, $P6313)
    store_lex "$regex", $P6314
.annotate 'line', 2031
    get_hll_global $P6315, "GLOBAL"
    nqp_get_package_through_who $P6316, $P6315, "PAST"
    get_who $P6317, $P6316
    set $P6318, $P6317["Op"]
.annotate 'line', 2033
    new $P6319, "ResizablePMCArray"
    push $P6319, "Regex"
    push $P6319, "Regex"
    find_lex $P6320, "$/"
    unless_null $P6320, vivify_2779
    new $P6320, "Undef"
  vivify_2779:
    $P6321 = "lexical_package_lookup"($P6319, $P6320)
    find_lex $P6322, "$regex"
    unless_null $P6322, vivify_2780
    new $P6322, "Undef"
  vivify_2780:
    $P6323 = $P6318."new"($P6321, $P6322, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2031
    store_lex "$past", $P6323
.annotate 'line', 2037
    find_lex $P6324, "$regex"
    unless_null $P6324, vivify_2781
    new $P6324, "Undef"
  vivify_2781:
    find_lex $P6325, "$past"
    unless_null $P6325, vivify_2782
    $P6325 = root_new ['parrot';'Hash']
    store_lex "$past", $P6325
  vivify_2782:
    set $P6325["sink"], $P6324
.annotate 'line', 2038
    find_lex $P6326, "$/"
    find_lex $P6327, "$past"
    unless_null $P6327, vivify_2783
    new $P6327, "Undef"
  vivify_2783:
    $P6328 = $P6326."!make"($P6327)
.annotate 'line', 2021
    .return ($P6328)
  control_6273:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6329, exception, "payload"
    .return ($P6329)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("569_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6331
    .param pmc param_6332
.annotate 'line', 2041
    .lex "self", param_6331
    .lex "$/", param_6332
    find_lex $P6333, "$/"
    find_lex $P6334, "$/"
    unless_null $P6334, vivify_2784
    $P6334 = root_new ['parrot';'Hash']
  vivify_2784:
    set $P6335, $P6334["variable"]
    unless_null $P6335, vivify_2785
    new $P6335, "Undef"
  vivify_2785:
    $P6336 = $P6335."ast"()
    $P6337 = $P6333."!make"($P6336)
    .return ($P6337)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("570_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6339
    .param pmc param_6340
.annotate 'line', 2042
    .lex "self", param_6339
    .lex "$/", param_6340
.annotate 'line', 2043
    find_lex $P6341, "$/"
    get_hll_global $P6342, "GLOBAL"
    nqp_get_package_through_who $P6343, $P6342, "PAST"
    get_who $P6344, $P6343
    set $P6345, $P6344["Op"]
.annotate 'line', 2044
    find_lex $P6346, "$/"
    unless_null $P6346, vivify_2786
    $P6346 = root_new ['parrot';'Hash']
  vivify_2786:
    set $P6347, $P6346["block"]
    unless_null $P6347, vivify_2787
    new $P6347, "Undef"
  vivify_2787:
    $P6348 = $P6347."ast"()
    $P6349 = "block_immediate"($P6348)
    find_lex $P6350, "$/"
    unless_null $P6350, vivify_2788
    new $P6350, "Undef"
  vivify_2788:
    $P6351 = $P6345."new"($P6349, "set S*" :named("pirop"), $P6350 :named("node"))
.annotate 'line', 2043
    $P6352 = $P6341."!make"($P6351)
.annotate 'line', 2042
    .return ($P6352)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("571_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6354
    .param pmc param_6355
.annotate 'line', 2047
    .lex "self", param_6354
    .lex "$/", param_6355
    find_lex $P6356, "$/"
    $P6357 = $P6356."!make"("\e")
    .return ($P6357)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("572_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6359
    .param pmc param_6360
.annotate 'line', 2051
    .lex "self", param_6359
    .lex "$/", param_6360
    find_lex $P6361, "$/"
    find_lex $P6362, "$/"
    unless_null $P6362, vivify_2789
    $P6362 = root_new ['parrot';'Hash']
  vivify_2789:
    set $P6363, $P6362["dotty"]
    unless_null $P6363, vivify_2790
    new $P6363, "Undef"
  vivify_2790:
    $P6364 = $P6363."ast"()
    $P6365 = $P6361."!make"($P6364)
    .return ($P6365)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("573_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6367
    .param pmc param_6368
.annotate 'line', 2053
    .lex "self", param_6367
    .lex "$/", param_6368
.annotate 'line', 2054
    find_lex $P6369, "$/"
    get_hll_global $P6370, "GLOBAL"
    nqp_get_package_through_who $P6371, $P6370, "PAST"
    get_who $P6372, $P6371
    set $P6373, $P6372["Op"]
.annotate 'line', 2055
    new $P6374, "ResizablePMCArray"
    push $P6374, "    clone %r, %0"
    push $P6374, "    inc %0"
    $P6375 = $P6373."new"("postfix:<++>" :named("name"), $P6374 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2054
    $P6376 = $P6369."!make"($P6375)
.annotate 'line', 2053
    .return ($P6376)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("574_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6378
    .param pmc param_6379
.annotate 'line', 2059
    .lex "self", param_6378
    .lex "$/", param_6379
.annotate 'line', 2060
    find_lex $P6380, "$/"
    get_hll_global $P6381, "GLOBAL"
    nqp_get_package_through_who $P6382, $P6381, "PAST"
    get_who $P6383, $P6382
    set $P6384, $P6383["Op"]
.annotate 'line', 2061
    new $P6385, "ResizablePMCArray"
    push $P6385, "    clone %r, %0"
    push $P6385, "    dec %0"
    $P6386 = $P6384."new"("postfix:<-->" :named("name"), $P6385 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2060
    $P6387 = $P6380."!make"($P6386)
.annotate 'line', 2059
    .return ($P6387)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("575_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6389
    .param pmc param_6390
.annotate 'line', 2065
    .lex "self", param_6389
    .lex "$/", param_6390
.annotate 'line', 2066
    find_lex $P6391, "$/"
    get_hll_global $P6392, "GLOBAL"
    nqp_get_package_through_who $P6393, $P6392, "PAST"
    get_who $P6394, $P6393
    set $P6395, $P6394["Op"]
.annotate 'line', 2067
    get_hll_global $P6396, "GLOBAL"
    nqp_get_package_through_who $P6397, $P6396, "PAST"
    get_who $P6398, $P6397
    set $P6399, $P6398["Var"]
    $P6400 = $P6399."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P6401, "$/"
    unless_null $P6401, vivify_2791
    new $P6401, "Undef"
  vivify_2791:
    $P6402 = $P6395."new"($P6400, "callmethod" :named("pasttype"), "!make" :named("name"), $P6401 :named("node"))
.annotate 'line', 2066
    $P6403 = $P6391."!make"($P6402)
.annotate 'line', 2065
    .return ($P6403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("576_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6406
    .param pmc param_6407
.annotate 'line', 2083
    .lex "self", param_6406
    .lex "$/", param_6407
    find_lex $P6408, "$/"
    unless_null $P6408, vivify_2792
    new $P6408, "Undef"
  vivify_2792:
    $P6409 = "control"($P6408, "CONTROL_LOOP_NEXT")
    .return ($P6409)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("577_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6411
    .param pmc param_6412
.annotate 'line', 2084
    .lex "self", param_6411
    .lex "$/", param_6412
    find_lex $P6413, "$/"
    unless_null $P6413, vivify_2793
    new $P6413, "Undef"
  vivify_2793:
    $P6414 = "control"($P6413, "CONTROL_LOOP_LAST")
    .return ($P6414)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("578_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6416
    .param pmc param_6417
.annotate 'line', 2085
    .lex "self", param_6416
    .lex "$/", param_6417
    find_lex $P6418, "$/"
    unless_null $P6418, vivify_2794
    new $P6418, "Undef"
  vivify_2794:
    $P6419 = "control"($P6418, "CONTROL_LOOP_REDO")
    .return ($P6419)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("579_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6421
    .param pmc param_6422
.annotate 'line', 2087
    .lex "self", param_6421
    .lex "$/", param_6422
.annotate 'line', 2088
    find_lex $P6423, "$/"
    get_hll_global $P6424, "GLOBAL"
    nqp_get_package_through_who $P6425, $P6424, "PAST"
    get_who $P6426, $P6425
    set $P6427, $P6426["Op"]
    find_lex $P6428, "$/"
    unless_null $P6428, vivify_2795
    new $P6428, "Undef"
  vivify_2795:
    $P6429 = $P6427."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6428 :named("node"))
    $P6430 = $P6423."!make"($P6429)
.annotate 'line', 2087
    .return ($P6430)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym"  :subid("580_1304277427.017") :outer("408_1304277427.017")
    .param pmc param_6436
    .param pmc param_6437
    .param pmc param_6438
.annotate 'line', 2165
    .const 'Sub' $P6442 = "581_1304277427.017" 
    capture_lex $P6442
    .lex "self", param_6436
    .lex "$/", param_6437
    .lex "@name", param_6438
.annotate 'line', 2166
    new $P6439, "Undef"
    .lex "$known", $P6439
    new $P6440, "Integer"
    assign $P6440, 0
    store_lex "$known", $P6440
.annotate 'line', 2167
    .const 'Sub' $P6442 = "581_1304277427.017" 
    capture_lex $P6442
    $P6442()
    find_lex $P6453, "$known"
    unless_null $P6453, vivify_2798
    new $P6453, "Undef"
  vivify_2798:
.annotate 'line', 2165
    .return ($P6453)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6441"  :anon :subid("581_1304277427.017") :outer("580_1304277427.017")
.annotate 'line', 2167
    new $P6448, 'ExceptionHandler'
    set_label $P6448, control_6447
    $P6448."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P6448
.annotate 'line', 2168
    find_lex $P6443, "@name"
    unless_null $P6443, vivify_2796
    $P6443 = root_new ['parrot';'ResizablePMCArray']
  vivify_2796:
    find_lex $P6444, "$/"
    unless_null $P6444, vivify_2797
    new $P6444, "Undef"
  vivify_2797:
    "find_sym"($P6443, $P6444)
.annotate 'line', 2169
    new $P6445, "Integer"
    assign $P6445, 1
    store_lex "$known", $P6445
.annotate 'line', 2167
    pop_eh 
    goto skip_handler_6446
  control_6447:
    .local pmc exception 
    .get_results (exception) 
    new $P6451, 'Integer'
    set $P6451, 1
    set exception["handled"], $P6451
    set $I6452, exception["handled"]
    ne $I6452, 1, nothandled_6450
  handled_6449:
    .return (exception)
  nothandled_6450:
    rethrow exception
  skip_handler_6446:
    .return ($P6445)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6460"  :subid("583_1304277427.017") :outer("10_1304277427.017")
.annotate 'line', 2234
    .const 'Sub' $P6594 = "591_1304277427.017" 
    capture_lex $P6594
    .const 'Sub' $P6554 = "590_1304277427.017" 
    capture_lex $P6554
    .const 'Sub' $P6540 = "589_1304277427.017" 
    capture_lex $P6540
    .const 'Sub' $P6522 = "588_1304277427.017" 
    capture_lex $P6522
    .const 'Sub' $P6508 = "587_1304277427.017" 
    capture_lex $P6508
    .const 'Sub' $P6494 = "586_1304277427.017" 
    capture_lex $P6494
    .const 'Sub' $P6480 = "585_1304277427.017" 
    capture_lex $P6480
    .const 'Sub' $P6464 = "584_1304277427.017" 
    capture_lex $P6464
    .lex "$?PACKAGE", $P6462
    .lex "$?CLASS", $P6463
.annotate 'line', 2268
    .const 'Sub' $P6554 = "590_1304277427.017" 
    newclosure $P6592, $P6554
.annotate 'line', 2234
    .return ($P6592)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2799") :outer("583_1304277427.017")
.annotate 'line', 2234
    .const 'Sub' $P6461 = "583_1304277427.017" 
    .local pmc block
    set block, $P6461
    .const 'Sub' $P6594 = "591_1304277427.017" 
    capture_lex $P6594
    $P6594()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6593"  :anon :subid("591_1304277427.017") :outer("583_1304277427.017")
.annotate 'line', 2234
    nqp_get_sc_object $P6595, "1304277414.8", 314
    .local pmc type_obj
    set type_obj, $P6595
    get_how $P6596, type_obj
    $P6597 = $P6596."compose"(type_obj)
    .return ($P6597)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("584_1304277427.017") :outer("583_1304277427.017")
    .param pmc param_6465
    .param pmc param_6466
.annotate 'line', 2236
    .lex "self", param_6465
    .lex "$/", param_6466
.annotate 'line', 2237
    new $P6467, "Undef"
    .lex "$past", $P6467
    find_lex $P6468, "$/"
    unless_null $P6468, vivify_2800
    $P6468 = root_new ['parrot';'Hash']
  vivify_2800:
    set $P6469, $P6468["statement"]
    unless_null $P6469, vivify_2801
    new $P6469, "Undef"
  vivify_2801:
    $P6470 = $P6469."ast"()
    store_lex "$past", $P6470
.annotate 'line', 2238
    find_lex $P6471, "$/"
    get_hll_global $P6472, "GLOBAL"
    nqp_get_package_through_who $P6473, $P6472, "PAST"
    get_who $P6474, $P6473
    set $P6475, $P6474["Regex"]
    find_lex $P6476, "$past"
    unless_null $P6476, vivify_2802
    new $P6476, "Undef"
  vivify_2802:
    find_lex $P6477, "$/"
    unless_null $P6477, vivify_2803
    new $P6477, "Undef"
  vivify_2803:
    $P6478 = $P6475."new"($P6476, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6477 :named("node"))
    $P6479 = $P6471."!make"($P6478)
.annotate 'line', 2236
    .return ($P6479)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("585_1304277427.017") :outer("583_1304277427.017")
    .param pmc param_6481
    .param pmc param_6482
.annotate 'line', 2242
    .lex "self", param_6481
    .lex "$/", param_6482
.annotate 'line', 2243
    find_lex $P6483, "$/"
    get_hll_global $P6484, "GLOBAL"
    nqp_get_package_through_who $P6485, $P6484, "PAST"
    get_who $P6486, $P6485
    set $P6487, $P6486["Regex"]
    find_lex $P6488, "$/"
    unless_null $P6488, vivify_2804
    $P6488 = root_new ['parrot';'Hash']
  vivify_2804:
    set $P6489, $P6488["codeblock"]
    unless_null $P6489, vivify_2805
    new $P6489, "Undef"
  vivify_2805:
    $P6490 = $P6489."ast"()
    find_lex $P6491, "$/"
    unless_null $P6491, vivify_2806
    new $P6491, "Undef"
  vivify_2806:
    $P6492 = $P6487."new"($P6490, "pastnode" :named("pasttype"), $P6491 :named("node"))
    $P6493 = $P6483."!make"($P6492)
.annotate 'line', 2242
    .return ($P6493)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("586_1304277427.017") :outer("583_1304277427.017")
    .param pmc param_6495
    .param pmc param_6496
.annotate 'line', 2247
    .lex "self", param_6495
    .lex "$/", param_6496
.annotate 'line', 2248
    find_lex $P6497, "$/"
    get_hll_global $P6498, "GLOBAL"
    nqp_get_package_through_who $P6499, $P6498, "PAST"
    get_who $P6500, $P6499
    set $P6501, $P6500["Regex"]
    find_lex $P6502, "$/"
    unless_null $P6502, vivify_2807
    $P6502 = root_new ['parrot';'Hash']
  vivify_2807:
    set $P6503, $P6502["var"]
    unless_null $P6503, vivify_2808
    new $P6503, "Undef"
  vivify_2808:
    $P6504 = $P6503."ast"()
    find_lex $P6505, "$/"
    unless_null $P6505, vivify_2809
    new $P6505, "Undef"
  vivify_2809:
    $P6506 = $P6501."new"("!INTERPOLATE", $P6504, "subrule" :named("pasttype"), "method" :named("subtype"), $P6505 :named("node"))
    $P6507 = $P6497."!make"($P6506)
.annotate 'line', 2247
    .return ($P6507)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("587_1304277427.017") :outer("583_1304277427.017")
    .param pmc param_6509
    .param pmc param_6510
.annotate 'line', 2252
    .lex "self", param_6509
    .lex "$/", param_6510
.annotate 'line', 2253
    find_lex $P6511, "$/"
    get_hll_global $P6512, "GLOBAL"
    nqp_get_package_through_who $P6513, $P6512, "PAST"
    get_who $P6514, $P6513
    set $P6515, $P6514["Regex"]
    find_lex $P6516, "$/"
    unless_null $P6516, vivify_2810
    $P6516 = root_new ['parrot';'Hash']
  vivify_2810:
    set $P6517, $P6516["codeblock"]
    unless_null $P6517, vivify_2811
    new $P6517, "Undef"
  vivify_2811:
    $P6518 = $P6517."ast"()
    find_lex $P6519, "$/"
    unless_null $P6519, vivify_2812
    new $P6519, "Undef"
  vivify_2812:
    $P6520 = $P6515."new"("!INTERPOLATE_REGEX", $P6518, "subrule" :named("pasttype"), "method" :named("subtype"), $P6519 :named("node"))
    $P6521 = $P6511."!make"($P6520)
.annotate 'line', 2252
    .return ($P6521)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("588_1304277427.017") :outer("583_1304277427.017")
    .param pmc param_6523
    .param pmc param_6524
.annotate 'line', 2257
    .lex "self", param_6523
    .lex "$/", param_6524
.annotate 'line', 2258
    find_lex $P6525, "$/"
    get_hll_global $P6526, "GLOBAL"
    nqp_get_package_through_who $P6527, $P6526, "PAST"
    get_who $P6528, $P6527
    set $P6529, $P6528["Regex"]
    find_lex $P6530, "$/"
    unless_null $P6530, vivify_2813
    $P6530 = root_new ['parrot';'Hash']
  vivify_2813:
    set $P6531, $P6530["codeblock"]
    unless_null $P6531, vivify_2814
    new $P6531, "Undef"
  vivify_2814:
    $P6532 = $P6531."ast"()
.annotate 'line', 2259
    find_lex $P6533, "$/"
    unless_null $P6533, vivify_2815
    $P6533 = root_new ['parrot';'Hash']
  vivify_2815:
    set $P6534, $P6533["zw"]
    unless_null $P6534, vivify_2816
    new $P6534, "Undef"
  vivify_2816:
    set $S6535, $P6534
    iseq $I6536, $S6535, "!"
    find_lex $P6537, "$/"
    unless_null $P6537, vivify_2817
    new $P6537, "Undef"
  vivify_2817:
    $P6538 = $P6529."new"($P6532, "zerowidth" :named("subtype"), $I6536 :named("negate"), "pastnode" :named("pasttype"), $P6537 :named("node"))
.annotate 'line', 2258
    $P6539 = $P6525."!make"($P6538)
.annotate 'line', 2257
    .return ($P6539)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("589_1304277427.017") :outer("583_1304277427.017")
    .param pmc param_6541
    .param pmc param_6542
.annotate 'line', 2263
    .lex "self", param_6541
    .lex "$/", param_6542
.annotate 'line', 2264
    find_lex $P6543, "$/"
    get_hll_global $P6544, "GLOBAL"
    nqp_get_package_through_who $P6545, $P6544, "PAST"
    get_who $P6546, $P6545
    set $P6547, $P6546["Regex"]
    find_lex $P6548, "$/"
    unless_null $P6548, vivify_2818
    $P6548 = root_new ['parrot';'Hash']
  vivify_2818:
    set $P6549, $P6548["var"]
    unless_null $P6549, vivify_2819
    new $P6549, "Undef"
  vivify_2819:
    $P6550 = $P6549."ast"()
    find_lex $P6551, "$/"
    unless_null $P6551, vivify_2820
    new $P6551, "Undef"
  vivify_2820:
    $P6552 = $P6547."new"("!INTERPOLATE_REGEX", $P6550, "subrule" :named("pasttype"), "method" :named("subtype"), $P6551 :named("node"))
    $P6553 = $P6543."!make"($P6552)
.annotate 'line', 2263
    .return ($P6553)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("590_1304277427.017") :outer("583_1304277427.017")
    .param pmc param_6555
    .param pmc param_6556
.annotate 'line', 2268
    .lex "self", param_6555
    .lex "$/", param_6556
.annotate 'line', 2269
    new $P6557, "Undef"
    .lex "$block", $P6557
.annotate 'line', 2271
    new $P6558, "Undef"
    .lex "$past", $P6558
.annotate 'line', 2269
    find_lex $P6559, "$/"
    unless_null $P6559, vivify_2821
    $P6559 = root_new ['parrot';'Hash']
  vivify_2821:
    set $P6560, $P6559["block"]
    unless_null $P6560, vivify_2822
    new $P6560, "Undef"
  vivify_2822:
    $P6561 = $P6560."ast"()
    store_lex "$block", $P6561
.annotate 'line', 2270
    find_lex $P6562, "$block"
    unless_null $P6562, vivify_2823
    new $P6562, "Undef"
  vivify_2823:
    $P6562."blocktype"("immediate")
.annotate 'line', 2272
    get_hll_global $P6563, "GLOBAL"
    nqp_get_package_through_who $P6564, $P6563, "PAST"
    get_who $P6565, $P6564
    set $P6566, $P6565["Stmts"]
.annotate 'line', 2273
    get_hll_global $P6567, "GLOBAL"
    nqp_get_package_through_who $P6568, $P6567, "PAST"
    get_who $P6569, $P6568
    set $P6570, $P6569["Op"]
.annotate 'line', 2274
    get_hll_global $P6571, "GLOBAL"
    nqp_get_package_through_who $P6572, $P6571, "PAST"
    get_who $P6573, $P6572
    set $P6574, $P6573["Var"]
    $P6575 = $P6574."new"("$/" :named("name"))
.annotate 'line', 2275
    get_hll_global $P6576, "GLOBAL"
    nqp_get_package_through_who $P6577, $P6576, "PAST"
    get_who $P6578, $P6577
    set $P6579, $P6578["Op"]
.annotate 'line', 2276
    get_hll_global $P6580, "GLOBAL"
    nqp_get_package_through_who $P6581, $P6580, "PAST"
    get_who $P6582, $P6581
    set $P6583, $P6582["Var"]
    $P6584 = $P6583."new"(unicode:"$\x{a2}" :named("name"))
    $P6585 = $P6579."new"($P6584, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2275
    $P6586 = $P6570."new"($P6575, $P6585, "bind" :named("pasttype"))
.annotate 'line', 2273
    find_lex $P6587, "$block"
    unless_null $P6587, vivify_2824
    new $P6587, "Undef"
  vivify_2824:
    $P6588 = $P6566."new"($P6586, $P6587)
.annotate 'line', 2272
    store_lex "$past", $P6588
.annotate 'line', 2284
    find_lex $P6589, "$/"
    find_lex $P6590, "$past"
    unless_null $P6590, vivify_2825
    new $P6590, "Undef"
  vivify_2825:
    $P6591 = $P6589."!make"($P6590)
.annotate 'line', 2268
    .return ($P6591)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6598"  :subid("592_1304277427.017") :outer("10_1304277427.017")
.annotate 'line', 2289
    .const 'Sub' $P6603 = "593_1304277427.017" 
    capture_lex $P6603
    .lex "$?PACKAGE", $P6600
    .lex "$?CLASS", $P6601
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2826") :outer("592_1304277427.017")
.annotate 'line', 2289
    .const 'Sub' $P6599 = "592_1304277427.017" 
    .local pmc block
    set block, $P6599
    .const 'Sub' $P6603 = "593_1304277427.017" 
    capture_lex $P6603
    $P6603()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6602"  :anon :subid("593_1304277427.017") :outer("592_1304277427.017")
.annotate 'line', 2289
    nqp_get_sc_object $P6604, "1304277414.8", 322
    .local pmc type_obj
    set type_obj, $P6604
    get_how $P6605, type_obj
    $P6606 = $P6605."compose"(type_obj)
    .return ($P6606)
.end


.HLL "nqp"

.namespace []
.sub "_block6614" :load :anon :subid("594_1304277427.017")
.annotate 'line', 1
    .const 'Sub' $P6616 = "10_1304277427.017" 
    $P6617 = $P6616()
    .return ($P6617)
.end

