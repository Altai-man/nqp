# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

.HLL 'nqp'

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup

    .local pmc interp, lexpad, nqplexpad
    interp = getinterp
    lexpad = get_class 'LexPad'
    nqplexpad = get_class 'NQPLexPad'
    interp.'hll_map'(lexpad, nqplexpad)
    
    load_bytecode 'SettingManager.pbc'
    load_bytecode 'nqpmo.pbc'
.end

.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
    
    ## Bring in PAST and PCT
    .local pmc hllns, parrotns, imports
    hllns = get_hll_namespace
    parrotns = get_root_namespace ['parrot']
    imports = split ' ', 'PAST PCT'
    parrotns.'export_to'(hllns, imports)
.end

### .include 'gen/nqp-grammar.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300051172.188")
.annotate 'line', 0
    get_hll_global $P17, ["NQP";"Grammar"], "_block16" 
    capture_lex $P17
.annotate 'line', 1
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P17, ["NQP";"Grammar"], "_block16" 
    capture_lex $P17
    $P2501 = $P17()
.annotate 'line', 1
    .return ($P2501)
    .const 'Sub' $P2503 = "405_1300051172.188" 
    .return ($P2503)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post406") :outer("10_1300051172.188")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300051172.188" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P2507, "1300051166.695"
    isnull $I2508, $P2507
    if $I2508, if_2506
    nqp_get_sc_object $P2518, "1300051166.695", 1
    set_hll_global ["NQP"], "Regex", $P2518
    nqp_get_sc_object $P2519, "1300051166.695", 0
    set_hll_global ["NQP"], "Grammar", $P2519
    goto if_2506_end
  if_2506:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P2509, "1300051166.695"
    .local pmc cur_sc
    set cur_sc, $P2509
    load_bytecode "SettingManager.pbc"
    get_hll_global $P2510, ["HLL"], "SettingManager"
    $P2511 = $P2510."load_setting"("NQPCORE")
    block."set_outer_ctx"($P2511)
    get_hll_global $P2512, "NQPClassHOW"
    $P2513 = $P2512."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P2513, cur_sc
    nqp_set_sc_object "1300051166.695", 0, $P2513
    get_hll_global $P2514, "NQPClassHOW"
    $P2515 = $P2514."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P2515, cur_sc
    nqp_set_sc_object "1300051166.695", 1, $P2515
    nqp_get_sc_object $P2516, "1300051166.695", 1
    set_hll_global ["NQP"], "Regex", $P2516
    nqp_get_sc_object $P2517, "1300051166.695", 0
    set_hll_global ["NQP"], "Grammar", $P2517
  if_2506_end:
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block16"  :subid("11_1300051172.188") :outer("10_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P1783 = "404_1300051172.188" 
    capture_lex $P1783
    get_hll_global $P1663, ["NQP";"Regex"], "_block1662" 
    capture_lex $P1663
    .const 'Sub' $P1651 = "380_1300051172.188" 
    capture_lex $P1651
    .const 'Sub' $P1645 = "378_1300051172.188" 
    capture_lex $P1645
    .const 'Sub' $P1639 = "376_1300051172.188" 
    capture_lex $P1639
    .const 'Sub' $P1633 = "374_1300051172.188" 
    capture_lex $P1633
    .const 'Sub' $P1627 = "372_1300051172.188" 
    capture_lex $P1627
    .const 'Sub' $P1615 = "369_1300051172.188" 
    capture_lex $P1615
    .const 'Sub' $P1608 = "367_1300051172.188" 
    capture_lex $P1608
    .const 'Sub' $P1601 = "365_1300051172.188" 
    capture_lex $P1601
    .const 'Sub' $P1594 = "363_1300051172.188" 
    capture_lex $P1594
    .const 'Sub' $P1587 = "361_1300051172.188" 
    capture_lex $P1587
    .const 'Sub' $P1581 = "359_1300051172.188" 
    capture_lex $P1581
    .const 'Sub' $P1574 = "357_1300051172.188" 
    capture_lex $P1574
    .const 'Sub' $P1567 = "355_1300051172.188" 
    capture_lex $P1567
    .const 'Sub' $P1560 = "353_1300051172.188" 
    capture_lex $P1560
    .const 'Sub' $P1553 = "351_1300051172.188" 
    capture_lex $P1553
    .const 'Sub' $P1546 = "349_1300051172.188" 
    capture_lex $P1546
    .const 'Sub' $P1539 = "347_1300051172.188" 
    capture_lex $P1539
    .const 'Sub' $P1532 = "345_1300051172.188" 
    capture_lex $P1532
    .const 'Sub' $P1525 = "343_1300051172.188" 
    capture_lex $P1525
    .const 'Sub' $P1518 = "341_1300051172.188" 
    capture_lex $P1518
    .const 'Sub' $P1511 = "339_1300051172.188" 
    capture_lex $P1511
    .const 'Sub' $P1504 = "337_1300051172.188" 
    capture_lex $P1504
    .const 'Sub' $P1497 = "335_1300051172.188" 
    capture_lex $P1497
    .const 'Sub' $P1490 = "333_1300051172.188" 
    capture_lex $P1490
    .const 'Sub' $P1483 = "331_1300051172.188" 
    capture_lex $P1483
    .const 'Sub' $P1476 = "329_1300051172.188" 
    capture_lex $P1476
    .const 'Sub' $P1469 = "327_1300051172.188" 
    capture_lex $P1469
    .const 'Sub' $P1462 = "325_1300051172.188" 
    capture_lex $P1462
    .const 'Sub' $P1455 = "323_1300051172.188" 
    capture_lex $P1455
    .const 'Sub' $P1448 = "321_1300051172.188" 
    capture_lex $P1448
    .const 'Sub' $P1441 = "319_1300051172.188" 
    capture_lex $P1441
    .const 'Sub' $P1434 = "317_1300051172.188" 
    capture_lex $P1434
    .const 'Sub' $P1427 = "315_1300051172.188" 
    capture_lex $P1427
    .const 'Sub' $P1420 = "313_1300051172.188" 
    capture_lex $P1420
    .const 'Sub' $P1413 = "311_1300051172.188" 
    capture_lex $P1413
    .const 'Sub' $P1406 = "309_1300051172.188" 
    capture_lex $P1406
    .const 'Sub' $P1399 = "307_1300051172.188" 
    capture_lex $P1399
    .const 'Sub' $P1392 = "305_1300051172.188" 
    capture_lex $P1392
    .const 'Sub' $P1385 = "303_1300051172.188" 
    capture_lex $P1385
    .const 'Sub' $P1378 = "301_1300051172.188" 
    capture_lex $P1378
    .const 'Sub' $P1372 = "299_1300051172.188" 
    capture_lex $P1372
    .const 'Sub' $P1365 = "297_1300051172.188" 
    capture_lex $P1365
    .const 'Sub' $P1358 = "295_1300051172.188" 
    capture_lex $P1358
    .const 'Sub' $P1351 = "293_1300051172.188" 
    capture_lex $P1351
    .const 'Sub' $P1344 = "291_1300051172.188" 
    capture_lex $P1344
    .const 'Sub' $P1337 = "289_1300051172.188" 
    capture_lex $P1337
    .const 'Sub' $P1330 = "287_1300051172.188" 
    capture_lex $P1330
    .const 'Sub' $P1323 = "285_1300051172.188" 
    capture_lex $P1323
    .const 'Sub' $P1317 = "283_1300051172.188" 
    capture_lex $P1317
    .const 'Sub' $P1311 = "281_1300051172.188" 
    capture_lex $P1311
    .const 'Sub' $P1306 = "279_1300051172.188" 
    capture_lex $P1306
    .const 'Sub' $P1300 = "277_1300051172.188" 
    capture_lex $P1300
    .const 'Sub' $P1294 = "275_1300051172.188" 
    capture_lex $P1294
    .const 'Sub' $P1289 = "273_1300051172.188" 
    capture_lex $P1289
    .const 'Sub' $P1284 = "271_1300051172.188" 
    capture_lex $P1284
    .const 'Sub' $P1268 = "270_1300051172.188" 
    capture_lex $P1268
    .const 'Sub' $P1259 = "268_1300051172.188" 
    capture_lex $P1259
    .const 'Sub' $P1250 = "266_1300051172.188" 
    capture_lex $P1250
    .const 'Sub' $P1245 = "264_1300051172.188" 
    capture_lex $P1245
    .const 'Sub' $P1240 = "262_1300051172.188" 
    capture_lex $P1240
    .const 'Sub' $P1235 = "260_1300051172.188" 
    capture_lex $P1235
    .const 'Sub' $P1227 = "258_1300051172.188" 
    capture_lex $P1227
    .const 'Sub' $P1219 = "256_1300051172.188" 
    capture_lex $P1219
    .const 'Sub' $P1214 = "254_1300051172.188" 
    capture_lex $P1214
    .const 'Sub' $P1209 = "252_1300051172.188" 
    capture_lex $P1209
    .const 'Sub' $P1204 = "250_1300051172.188" 
    capture_lex $P1204
    .const 'Sub' $P1198 = "248_1300051172.188" 
    capture_lex $P1198
    .const 'Sub' $P1192 = "246_1300051172.188" 
    capture_lex $P1192
    .const 'Sub' $P1186 = "244_1300051172.188" 
    capture_lex $P1186
    .const 'Sub' $P1180 = "242_1300051172.188" 
    capture_lex $P1180
    .const 'Sub' $P1174 = "240_1300051172.188" 
    capture_lex $P1174
    .const 'Sub' $P1169 = "238_1300051172.188" 
    capture_lex $P1169
    .const 'Sub' $P1164 = "236_1300051172.188" 
    capture_lex $P1164
    .const 'Sub' $P1150 = "232_1300051172.188" 
    capture_lex $P1150
    .const 'Sub' $P1142 = "230_1300051172.188" 
    capture_lex $P1142
    .const 'Sub' $P1136 = "228_1300051172.188" 
    capture_lex $P1136
    .const 'Sub' $P1129 = "226_1300051172.188" 
    capture_lex $P1129
    .const 'Sub' $P1123 = "224_1300051172.188" 
    capture_lex $P1123
    .const 'Sub' $P1109 = "221_1300051172.188" 
    capture_lex $P1109
    .const 'Sub' $P1101 = "219_1300051172.188" 
    capture_lex $P1101
    .const 'Sub' $P1093 = "217_1300051172.188" 
    capture_lex $P1093
    .const 'Sub' $P1087 = "215_1300051172.188" 
    capture_lex $P1087
    .const 'Sub' $P1081 = "213_1300051172.188" 
    capture_lex $P1081
    .const 'Sub' $P1065 = "209_1300051172.188" 
    capture_lex $P1065
    .const 'Sub' $P1024 = "207_1300051172.188" 
    capture_lex $P1024
    .const 'Sub' $P1013 = "205_1300051172.188" 
    capture_lex $P1013
    .const 'Sub' $P999 = "201_1300051172.188" 
    capture_lex $P999
    .const 'Sub' $P990 = "199_1300051172.188" 
    capture_lex $P990
    .const 'Sub' $P984 = "197_1300051172.188" 
    capture_lex $P984
    .const 'Sub' $P974 = "195_1300051172.188" 
    capture_lex $P974
    .const 'Sub' $P959 = "193_1300051172.188" 
    capture_lex $P959
    .const 'Sub' $P945 = "190_1300051172.188" 
    capture_lex $P945
    .const 'Sub' $P937 = "188_1300051172.188" 
    capture_lex $P937
    .const 'Sub' $P927 = "186_1300051172.188" 
    capture_lex $P927
    .const 'Sub' $P917 = "184_1300051172.188" 
    capture_lex $P917
    .const 'Sub' $P898 = "179_1300051172.188" 
    capture_lex $P898
    .const 'Sub' $P854 = "176_1300051172.188" 
    capture_lex $P854
    .const 'Sub' $P820 = "174_1300051172.188" 
    capture_lex $P820
    .const 'Sub' $P813 = "172_1300051172.188" 
    capture_lex $P813
    .const 'Sub' $P806 = "170_1300051172.188" 
    capture_lex $P806
    .const 'Sub' $P789 = "166_1300051172.188" 
    capture_lex $P789
    .const 'Sub' $P781 = "164_1300051172.188" 
    capture_lex $P781
    .const 'Sub' $P775 = "162_1300051172.188" 
    capture_lex $P775
    .const 'Sub' $P759 = "160_1300051172.188" 
    capture_lex $P759
    .const 'Sub' $P752 = "158_1300051172.188" 
    capture_lex $P752
    .const 'Sub' $P745 = "156_1300051172.188" 
    capture_lex $P745
    .const 'Sub' $P738 = "154_1300051172.188" 
    capture_lex $P738
    .const 'Sub' $P660 = "149_1300051172.188" 
    capture_lex $P660
    .const 'Sub' $P648 = "147_1300051172.188" 
    capture_lex $P648
    .const 'Sub' $P636 = "145_1300051172.188" 
    capture_lex $P636
    .const 'Sub' $P624 = "143_1300051172.188" 
    capture_lex $P624
    .const 'Sub' $P612 = "141_1300051172.188" 
    capture_lex $P612
    .const 'Sub' $P600 = "139_1300051172.188" 
    capture_lex $P600
    .const 'Sub' $P588 = "137_1300051172.188" 
    capture_lex $P588
    .const 'Sub' $P577 = "133_1300051172.188" 
    capture_lex $P577
    .const 'Sub' $P572 = "131_1300051172.188" 
    capture_lex $P572
    .const 'Sub' $P560 = "129_1300051172.188" 
    capture_lex $P560
    .const 'Sub' $P548 = "127_1300051172.188" 
    capture_lex $P548
    .const 'Sub' $P541 = "125_1300051172.188" 
    capture_lex $P541
    .const 'Sub' $P536 = "123_1300051172.188" 
    capture_lex $P536
    .const 'Sub' $P530 = "121_1300051172.188" 
    capture_lex $P530
    .const 'Sub' $P524 = "119_1300051172.188" 
    capture_lex $P524
    .const 'Sub' $P509 = "115_1300051172.188" 
    capture_lex $P509
    .const 'Sub' $P503 = "113_1300051172.188" 
    capture_lex $P503
    .const 'Sub' $P497 = "111_1300051172.188" 
    capture_lex $P497
    .const 'Sub' $P491 = "109_1300051172.188" 
    capture_lex $P491
    .const 'Sub' $P485 = "107_1300051172.188" 
    capture_lex $P485
    .const 'Sub' $P479 = "105_1300051172.188" 
    capture_lex $P479
    .const 'Sub' $P473 = "103_1300051172.188" 
    capture_lex $P473
    .const 'Sub' $P464 = "101_1300051172.188" 
    capture_lex $P464
    .const 'Sub' $P455 = "99_1300051172.188" 
    capture_lex $P455
    .const 'Sub' $P446 = "97_1300051172.188" 
    capture_lex $P446
    .const 'Sub' $P431 = "93_1300051172.188" 
    capture_lex $P431
    .const 'Sub' $P422 = "91_1300051172.188" 
    capture_lex $P422
    .const 'Sub' $P410 = "87_1300051172.188" 
    capture_lex $P410
    .const 'Sub' $P403 = "85_1300051172.188" 
    capture_lex $P403
    .const 'Sub' $P396 = "83_1300051172.188" 
    capture_lex $P396
    .const 'Sub' $P382 = "79_1300051172.188" 
    capture_lex $P382
    .const 'Sub' $P374 = "77_1300051172.188" 
    capture_lex $P374
    .const 'Sub' $P366 = "75_1300051172.188" 
    capture_lex $P366
    .const 'Sub' $P346 = "73_1300051172.188" 
    capture_lex $P346
    .const 'Sub' $P337 = "71_1300051172.188" 
    capture_lex $P337
    .const 'Sub' $P319 = "68_1300051172.188" 
    capture_lex $P319
    .const 'Sub' $P301 = "66_1300051172.188" 
    capture_lex $P301
    .const 'Sub' $P293 = "64_1300051172.188" 
    capture_lex $P293
    .const 'Sub' $P282 = "60_1300051172.188" 
    capture_lex $P282
    .const 'Sub' $P277 = "58_1300051172.188" 
    capture_lex $P277
    .const 'Sub' $P266 = "54_1300051172.188" 
    capture_lex $P266
    .const 'Sub' $P261 = "52_1300051172.188" 
    capture_lex $P261
    .const 'Sub' $P256 = "50_1300051172.188" 
    capture_lex $P256
    .const 'Sub' $P251 = "48_1300051172.188" 
    capture_lex $P251
    .const 'Sub' $P241 = "46_1300051172.188" 
    capture_lex $P241
    .const 'Sub' $P234 = "44_1300051172.188" 
    capture_lex $P234
    .const 'Sub' $P228 = "42_1300051172.188" 
    capture_lex $P228
    .const 'Sub' $P220 = "40_1300051172.188" 
    capture_lex $P220
    .const 'Sub' $P214 = "38_1300051172.188" 
    capture_lex $P214
    .const 'Sub' $P208 = "36_1300051172.188" 
    capture_lex $P208
    .const 'Sub' $P193 = "33_1300051172.188" 
    capture_lex $P193
    .const 'Sub' $P179 = "31_1300051172.188" 
    capture_lex $P179
    .const 'Sub' $P170 = "29_1300051172.188" 
    capture_lex $P170
    .const 'Sub' $P131 = "26_1300051172.188" 
    capture_lex $P131
    .const 'Sub' $P116 = "23_1300051172.188" 
    capture_lex $P116
    .const 'Sub' $P105 = "21_1300051172.188" 
    capture_lex $P105
    .const 'Sub' $P93 = "19_1300051172.188" 
    capture_lex $P93
    .const 'Sub' $P85 = "17_1300051172.188" 
    capture_lex $P85
    .const 'Sub' $P78 = "15_1300051172.188" 
    capture_lex $P78
    .const 'Sub' $P71 = "13_1300051172.188" 
    capture_lex $P71
    .const 'Sub' $P22 = "12_1300051172.188" 
    capture_lex $P22
    get_global $P18, "$?CLASS"
    getinterp $P19
    get_class $P20, "LexPad"
    get_class $P21, "NQPLexPad"
    $P19."hll_map"($P20, $P21)
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1268 = "270_1300051172.188" 
    capture_lex $P1268
    $P1268()
.annotate 'line', 691
    get_hll_global $P1663, ["NQP";"Regex"], "_block1662" 
    capture_lex $P1663
    $P1765 = $P1663()
.annotate 'line', 4
    .return ($P1765)
    .const 'Sub' $P1767 = "403_1300051172.188" 
    .return ($P1767)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post407") :outer("11_1300051172.188")
.annotate 'line', 4
    get_hll_global $P17, ["NQP";"Grammar"], "_block16" 
    .local pmc block
    set block, $P17
    nqp_get_sc $P1771, "1300051166.695"
    isnull $I1772, $P1771
    if $I1772, if_1770
    nqp_get_sc_object $P1781, "1300051166.695", 1
    set_hll_global ["NQP"], "Regex", $P1781
    goto if_1770_end
  if_1770:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P1773, "1300051166.695"
    .local pmc cur_sc
    set cur_sc, $P1773
    load_bytecode "SettingManager.pbc"
    get_hll_global $P1774, ["HLL"], "SettingManager"
    $P1775 = $P1774."load_setting"("NQPCORE")
    block."set_outer_ctx"($P1775)
    get_hll_global $P1776, "NQPClassHOW"
    $P1777 = $P1776."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P1777, cur_sc
    nqp_set_sc_object "1300051166.695", 0, $P1777
    get_hll_global $P1778, "NQPClassHOW"
    $P1779 = $P1778."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P1779, cur_sc
    nqp_set_sc_object "1300051166.695", 1, $P1779
    nqp_get_sc_object $P1780, "1300051166.695", 1
    set_hll_global ["NQP"], "Regex", $P1780
  if_1770_end:
    .const 'Sub' $P1783 = "404_1300051172.188" 
    capture_lex $P1783
    $P1783()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1782"  :anon :subid("404_1300051172.188") :outer("11_1300051172.188")
.annotate 'line', 4
    nqp_get_sc_object $P1784, "1300051166.695", 0
    .local pmc type_obj
    set type_obj, $P1784
    set_global "$?CLASS", type_obj
    get_how $P1785, type_obj
    .const 'Sub' $P1786 = "12_1300051172.188" 
    $P1785."add_method"(type_obj, "TOP", $P1786)
    get_how $P1787, type_obj
    .const 'Sub' $P1788 = "13_1300051172.188" 
    $P1787."add_method"(type_obj, "identifier", $P1788)
    get_how $P1789, type_obj
    get_global $P1790, "!PREFIX__identifier"
    $P1789."add_method"(type_obj, "!PREFIX__identifier", $P1790)
    get_how $P1791, type_obj
    .const 'Sub' $P1792 = "15_1300051172.188" 
    $P1791."add_method"(type_obj, "name", $P1792)
    get_how $P1793, type_obj
    get_global $P1794, "!PREFIX__name"
    $P1793."add_method"(type_obj, "!PREFIX__name", $P1794)
    get_how $P1795, type_obj
    .const 'Sub' $P1796 = "17_1300051172.188" 
    $P1795."add_method"(type_obj, "deflongname", $P1796)
    get_how $P1797, type_obj
    get_global $P1798, "!PREFIX__deflongname"
    $P1797."add_method"(type_obj, "!PREFIX__deflongname", $P1798)
    get_how $P1799, type_obj
    .const 'Sub' $P1800 = "19_1300051172.188" 
    $P1799."add_method"(type_obj, "ENDSTMT", $P1800)
    get_how $P1801, type_obj
    get_global $P1802, "!PREFIX__ENDSTMT"
    $P1801."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1802)
    get_how $P1803, type_obj
    .const 'Sub' $P1804 = "21_1300051172.188" 
    $P1803."add_method"(type_obj, "ws", $P1804)
    get_how $P1805, type_obj
    get_global $P1806, "!PREFIX__ws"
    $P1805."add_method"(type_obj, "!PREFIX__ws", $P1806)
    get_how $P1807, type_obj
    .const 'Sub' $P1808 = "23_1300051172.188" 
    $P1807."add_method"(type_obj, "unv", $P1808)
    get_how $P1809, type_obj
    get_global $P1810, "!PREFIX__unv"
    $P1809."add_method"(type_obj, "!PREFIX__unv", $P1810)
    get_how $P1811, type_obj
    .const 'Sub' $P1812 = "26_1300051172.188" 
    $P1811."add_method"(type_obj, "pod_comment", $P1812)
    get_how $P1813, type_obj
    get_global $P1814, "!PREFIX__pod_comment"
    $P1813."add_method"(type_obj, "!PREFIX__pod_comment", $P1814)
    get_how $P1815, type_obj
    .const 'Sub' $P1816 = "29_1300051172.188" 
    $P1815."add_method"(type_obj, "comp_unit", $P1816)
    get_how $P1817, type_obj
    get_global $P1818, "!PREFIX__comp_unit"
    $P1817."add_method"(type_obj, "!PREFIX__comp_unit", $P1818)
    get_how $P1819, type_obj
    .const 'Sub' $P1820 = "31_1300051172.188" 
    $P1819."add_method"(type_obj, "statementlist", $P1820)
    get_how $P1821, type_obj
    get_global $P1822, "!PREFIX__statementlist"
    $P1821."add_method"(type_obj, "!PREFIX__statementlist", $P1822)
    get_how $P1823, type_obj
    .const 'Sub' $P1824 = "33_1300051172.188" 
    $P1823."add_method"(type_obj, "statement", $P1824)
    get_how $P1825, type_obj
    get_global $P1826, "!PREFIX__statement"
    $P1825."add_method"(type_obj, "!PREFIX__statement", $P1826)
    get_how $P1827, type_obj
    .const 'Sub' $P1828 = "36_1300051172.188" 
    $P1827."add_method"(type_obj, "eat_terminator", $P1828)
    get_how $P1829, type_obj
    get_global $P1830, "!PREFIX__eat_terminator"
    $P1829."add_method"(type_obj, "!PREFIX__eat_terminator", $P1830)
    get_how $P1831, type_obj
    .const 'Sub' $P1832 = "38_1300051172.188" 
    $P1831."add_method"(type_obj, "xblock", $P1832)
    get_how $P1833, type_obj
    get_global $P1834, "!PREFIX__xblock"
    $P1833."add_method"(type_obj, "!PREFIX__xblock", $P1834)
    get_how $P1835, type_obj
    .const 'Sub' $P1836 = "40_1300051172.188" 
    $P1835."add_method"(type_obj, "pblock", $P1836)
    get_how $P1837, type_obj
    get_global $P1838, "!PREFIX__pblock"
    $P1837."add_method"(type_obj, "!PREFIX__pblock", $P1838)
    get_how $P1839, type_obj
    .const 'Sub' $P1840 = "42_1300051172.188" 
    $P1839."add_method"(type_obj, "lambda", $P1840)
    get_how $P1841, type_obj
    get_global $P1842, "!PREFIX__lambda"
    $P1841."add_method"(type_obj, "!PREFIX__lambda", $P1842)
    get_how $P1843, type_obj
    .const 'Sub' $P1844 = "44_1300051172.188" 
    $P1843."add_method"(type_obj, "block", $P1844)
    get_how $P1845, type_obj
    get_global $P1846, "!PREFIX__block"
    $P1845."add_method"(type_obj, "!PREFIX__block", $P1846)
    get_how $P1847, type_obj
    .const 'Sub' $P1848 = "46_1300051172.188" 
    $P1847."add_method"(type_obj, "blockoid", $P1848)
    get_how $P1849, type_obj
    get_global $P1850, "!PREFIX__blockoid"
    $P1849."add_method"(type_obj, "!PREFIX__blockoid", $P1850)
    get_how $P1851, type_obj
    .const 'Sub' $P1852 = "48_1300051172.188" 
    $P1851."add_method"(type_obj, "newpad", $P1852)
    get_how $P1853, type_obj
    get_global $P1854, "!PREFIX__newpad"
    $P1853."add_method"(type_obj, "!PREFIX__newpad", $P1854)
    get_how $P1855, type_obj
    .const 'Sub' $P1856 = "50_1300051172.188" 
    $P1855."add_method"(type_obj, "outerctx", $P1856)
    get_how $P1857, type_obj
    get_global $P1858, "!PREFIX__outerctx"
    $P1857."add_method"(type_obj, "!PREFIX__outerctx", $P1858)
    get_how $P1859, type_obj
    .const 'Sub' $P1860 = "52_1300051172.188" 
    $P1859."add_method"(type_obj, "finishpad", $P1860)
    get_how $P1861, type_obj
    get_global $P1862, "!PREFIX__finishpad"
    $P1861."add_method"(type_obj, "!PREFIX__finishpad", $P1862)
    get_how $P1863, type_obj
    .const 'Sub' $P1864 = "54_1300051172.188" 
    $P1863."add_method"(type_obj, "you_are_here", $P1864)
    get_how $P1865, type_obj
    get_global $P1866, "!PREFIX__you_are_here"
    $P1865."add_method"(type_obj, "!PREFIX__you_are_here", $P1866)
    get_how $P1867, type_obj
    .const 'Sub' $P1868 = "56_1300051172.188" 
    $P1867."add_method"(type_obj, "terminator", $P1868)
    get_how $P1869, type_obj
    .const 'Sub' $P1870 = "57_1300051172.188" 
    $P1869."add_method"(type_obj, "!PREFIX__terminator", $P1870)
    get_how $P1871, type_obj
    .const 'Sub' $P1872 = "58_1300051172.188" 
    $P1871."add_method"(type_obj, "terminator:sym<;>", $P1872)
    get_how $P1873, type_obj
    get_global $P1874, "!PREFIX__terminator:sym<;>"
    $P1873."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1874)
    get_how $P1875, type_obj
    .const 'Sub' $P1876 = "60_1300051172.188" 
    $P1875."add_method"(type_obj, "terminator:sym<}>", $P1876)
    get_how $P1877, type_obj
    get_global $P1878, "!PREFIX__terminator:sym<}>"
    $P1877."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1878)
    get_how $P1879, type_obj
    .const 'Sub' $P1880 = "62_1300051172.188" 
    $P1879."add_method"(type_obj, "statement_control", $P1880)
    get_how $P1881, type_obj
    .const 'Sub' $P1882 = "63_1300051172.188" 
    $P1881."add_method"(type_obj, "!PREFIX__statement_control", $P1882)
    get_how $P1883, type_obj
    .const 'Sub' $P1884 = "64_1300051172.188" 
    $P1883."add_method"(type_obj, "statement_control:sym<use>", $P1884)
    get_how $P1885, type_obj
    get_global $P1886, "!PREFIX__statement_control:sym<use>"
    $P1885."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1886)
    get_how $P1887, type_obj
    .const 'Sub' $P1888 = "66_1300051172.188" 
    $P1887."add_method"(type_obj, "statement_control:sym<if>", $P1888)
    get_how $P1889, type_obj
    get_global $P1890, "!PREFIX__statement_control:sym<if>"
    $P1889."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1890)
    get_how $P1891, type_obj
    .const 'Sub' $P1892 = "68_1300051172.188" 
    $P1891."add_method"(type_obj, "statement_control:sym<unless>", $P1892)
    get_how $P1893, type_obj
    get_global $P1894, "!PREFIX__statement_control:sym<unless>"
    $P1893."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1894)
    get_how $P1895, type_obj
    .const 'Sub' $P1896 = "71_1300051172.188" 
    $P1895."add_method"(type_obj, "statement_control:sym<while>", $P1896)
    get_how $P1897, type_obj
    get_global $P1898, "!PREFIX__statement_control:sym<while>"
    $P1897."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1898)
    get_how $P1899, type_obj
    .const 'Sub' $P1900 = "73_1300051172.188" 
    $P1899."add_method"(type_obj, "statement_control:sym<repeat>", $P1900)
    get_how $P1901, type_obj
    get_global $P1902, "!PREFIX__statement_control:sym<repeat>"
    $P1901."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1902)
    get_how $P1903, type_obj
    .const 'Sub' $P1904 = "75_1300051172.188" 
    $P1903."add_method"(type_obj, "statement_control:sym<for>", $P1904)
    get_how $P1905, type_obj
    get_global $P1906, "!PREFIX__statement_control:sym<for>"
    $P1905."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1906)
    get_how $P1907, type_obj
    .const 'Sub' $P1908 = "77_1300051172.188" 
    $P1907."add_method"(type_obj, "statement_control:sym<CATCH>", $P1908)
    get_how $P1909, type_obj
    get_global $P1910, "!PREFIX__statement_control:sym<CATCH>"
    $P1909."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1910)
    get_how $P1911, type_obj
    .const 'Sub' $P1912 = "79_1300051172.188" 
    $P1911."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1912)
    get_how $P1913, type_obj
    get_global $P1914, "!PREFIX__statement_control:sym<CONTROL>"
    $P1913."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1914)
    get_how $P1915, type_obj
    .const 'Sub' $P1916 = "81_1300051172.188" 
    $P1915."add_method"(type_obj, "statement_prefix", $P1916)
    get_how $P1917, type_obj
    .const 'Sub' $P1918 = "82_1300051172.188" 
    $P1917."add_method"(type_obj, "!PREFIX__statement_prefix", $P1918)
    get_how $P1919, type_obj
    .const 'Sub' $P1920 = "83_1300051172.188" 
    $P1919."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1920)
    get_how $P1921, type_obj
    get_global $P1922, "!PREFIX__statement_prefix:sym<INIT>"
    $P1921."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1922)
    get_how $P1923, type_obj
    .const 'Sub' $P1924 = "85_1300051172.188" 
    $P1923."add_method"(type_obj, "statement_prefix:sym<try>", $P1924)
    get_how $P1925, type_obj
    get_global $P1926, "!PREFIX__statement_prefix:sym<try>"
    $P1925."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1926)
    get_how $P1927, type_obj
    .const 'Sub' $P1928 = "87_1300051172.188" 
    $P1927."add_method"(type_obj, "blorst", $P1928)
    get_how $P1929, type_obj
    get_global $P1930, "!PREFIX__blorst"
    $P1929."add_method"(type_obj, "!PREFIX__blorst", $P1930)
    get_how $P1931, type_obj
    .const 'Sub' $P1932 = "89_1300051172.188" 
    $P1931."add_method"(type_obj, "statement_mod_cond", $P1932)
    get_how $P1933, type_obj
    .const 'Sub' $P1934 = "90_1300051172.188" 
    $P1933."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1934)
    get_how $P1935, type_obj
    .const 'Sub' $P1936 = "91_1300051172.188" 
    $P1935."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1936)
    get_how $P1937, type_obj
    get_global $P1938, "!PREFIX__statement_mod_cond:sym<if>"
    $P1937."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1938)
    get_how $P1939, type_obj
    .const 'Sub' $P1940 = "93_1300051172.188" 
    $P1939."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1940)
    get_how $P1941, type_obj
    get_global $P1942, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1941."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1942)
    get_how $P1943, type_obj
    .const 'Sub' $P1944 = "95_1300051172.188" 
    $P1943."add_method"(type_obj, "statement_mod_loop", $P1944)
    get_how $P1945, type_obj
    .const 'Sub' $P1946 = "96_1300051172.188" 
    $P1945."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1946)
    get_how $P1947, type_obj
    .const 'Sub' $P1948 = "97_1300051172.188" 
    $P1947."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1948)
    get_how $P1949, type_obj
    get_global $P1950, "!PREFIX__statement_mod_loop:sym<while>"
    $P1949."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1950)
    get_how $P1951, type_obj
    .const 'Sub' $P1952 = "99_1300051172.188" 
    $P1951."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1952)
    get_how $P1953, type_obj
    get_global $P1954, "!PREFIX__statement_mod_loop:sym<until>"
    $P1953."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1954)
    get_how $P1955, type_obj
    .const 'Sub' $P1956 = "101_1300051172.188" 
    $P1955."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1956)
    get_how $P1957, type_obj
    get_global $P1958, "!PREFIX__statement_mod_loop:sym<for>"
    $P1957."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1958)
    get_how $P1959, type_obj
    .const 'Sub' $P1960 = "103_1300051172.188" 
    $P1959."add_method"(type_obj, "term:sym<fatarrow>", $P1960)
    get_how $P1961, type_obj
    get_global $P1962, "!PREFIX__term:sym<fatarrow>"
    $P1961."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1962)
    get_how $P1963, type_obj
    .const 'Sub' $P1964 = "105_1300051172.188" 
    $P1963."add_method"(type_obj, "term:sym<colonpair>", $P1964)
    get_how $P1965, type_obj
    get_global $P1966, "!PREFIX__term:sym<colonpair>"
    $P1965."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1966)
    get_how $P1967, type_obj
    .const 'Sub' $P1968 = "107_1300051172.188" 
    $P1967."add_method"(type_obj, "term:sym<variable>", $P1968)
    get_how $P1969, type_obj
    get_global $P1970, "!PREFIX__term:sym<variable>"
    $P1969."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1970)
    get_how $P1971, type_obj
    .const 'Sub' $P1972 = "109_1300051172.188" 
    $P1971."add_method"(type_obj, "term:sym<package_declarator>", $P1972)
    get_how $P1973, type_obj
    get_global $P1974, "!PREFIX__term:sym<package_declarator>"
    $P1973."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1974)
    get_how $P1975, type_obj
    .const 'Sub' $P1976 = "111_1300051172.188" 
    $P1975."add_method"(type_obj, "term:sym<scope_declarator>", $P1976)
    get_how $P1977, type_obj
    get_global $P1978, "!PREFIX__term:sym<scope_declarator>"
    $P1977."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1978)
    get_how $P1979, type_obj
    .const 'Sub' $P1980 = "113_1300051172.188" 
    $P1979."add_method"(type_obj, "term:sym<routine_declarator>", $P1980)
    get_how $P1981, type_obj
    get_global $P1982, "!PREFIX__term:sym<routine_declarator>"
    $P1981."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1982)
    get_how $P1983, type_obj
    .const 'Sub' $P1984 = "115_1300051172.188" 
    $P1983."add_method"(type_obj, "term:sym<multi_declarator>", $P1984)
    get_how $P1985, type_obj
    get_global $P1986, "!PREFIX__term:sym<multi_declarator>"
    $P1985."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1986)
    get_how $P1987, type_obj
    .const 'Sub' $P1988 = "119_1300051172.188" 
    $P1987."add_method"(type_obj, "term:sym<regex_declarator>", $P1988)
    get_how $P1989, type_obj
    get_global $P1990, "!PREFIX__term:sym<regex_declarator>"
    $P1989."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1990)
    get_how $P1991, type_obj
    .const 'Sub' $P1992 = "121_1300051172.188" 
    $P1991."add_method"(type_obj, "term:sym<statement_prefix>", $P1992)
    get_how $P1993, type_obj
    get_global $P1994, "!PREFIX__term:sym<statement_prefix>"
    $P1993."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1994)
    get_how $P1995, type_obj
    .const 'Sub' $P1996 = "123_1300051172.188" 
    $P1995."add_method"(type_obj, "term:sym<lambda>", $P1996)
    get_how $P1997, type_obj
    get_global $P1998, "!PREFIX__term:sym<lambda>"
    $P1997."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1998)
    get_how $P1999, type_obj
    .const 'Sub' $P2000 = "125_1300051172.188" 
    $P1999."add_method"(type_obj, "fatarrow", $P2000)
    get_how $P2001, type_obj
    get_global $P2002, "!PREFIX__fatarrow"
    $P2001."add_method"(type_obj, "!PREFIX__fatarrow", $P2002)
    get_how $P2003, type_obj
    .const 'Sub' $P2004 = "127_1300051172.188" 
    $P2003."add_method"(type_obj, "colonpair", $P2004)
    get_how $P2005, type_obj
    get_global $P2006, "!PREFIX__colonpair"
    $P2005."add_method"(type_obj, "!PREFIX__colonpair", $P2006)
    get_how $P2007, type_obj
    .const 'Sub' $P2008 = "129_1300051172.188" 
    $P2007."add_method"(type_obj, "variable", $P2008)
    get_how $P2009, type_obj
    get_global $P2010, "!PREFIX__variable"
    $P2009."add_method"(type_obj, "!PREFIX__variable", $P2010)
    get_how $P2011, type_obj
    .const 'Sub' $P2012 = "131_1300051172.188" 
    $P2011."add_method"(type_obj, "sigil", $P2012)
    get_how $P2013, type_obj
    get_global $P2014, "!PREFIX__sigil"
    $P2013."add_method"(type_obj, "!PREFIX__sigil", $P2014)
    get_how $P2015, type_obj
    .const 'Sub' $P2016 = "133_1300051172.188" 
    $P2015."add_method"(type_obj, "twigil", $P2016)
    get_how $P2017, type_obj
    get_global $P2018, "!PREFIX__twigil"
    $P2017."add_method"(type_obj, "!PREFIX__twigil", $P2018)
    get_how $P2019, type_obj
    .const 'Sub' $P2020 = "135_1300051172.188" 
    $P2019."add_method"(type_obj, "package_declarator", $P2020)
    get_how $P2021, type_obj
    .const 'Sub' $P2022 = "136_1300051172.188" 
    $P2021."add_method"(type_obj, "!PREFIX__package_declarator", $P2022)
    get_how $P2023, type_obj
    .const 'Sub' $P2024 = "137_1300051172.188" 
    $P2023."add_method"(type_obj, "package_declarator:sym<module>", $P2024)
    get_how $P2025, type_obj
    get_global $P2026, "!PREFIX__package_declarator:sym<module>"
    $P2025."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2026)
    get_how $P2027, type_obj
    .const 'Sub' $P2028 = "139_1300051172.188" 
    $P2027."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2028)
    get_how $P2029, type_obj
    get_global $P2030, "!PREFIX__package_declarator:sym<knowhow>"
    $P2029."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2030)
    get_how $P2031, type_obj
    .const 'Sub' $P2032 = "141_1300051172.188" 
    $P2031."add_method"(type_obj, "package_declarator:sym<class>", $P2032)
    get_how $P2033, type_obj
    get_global $P2034, "!PREFIX__package_declarator:sym<class>"
    $P2033."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2034)
    get_how $P2035, type_obj
    .const 'Sub' $P2036 = "143_1300051172.188" 
    $P2035."add_method"(type_obj, "package_declarator:sym<grammar>", $P2036)
    get_how $P2037, type_obj
    get_global $P2038, "!PREFIX__package_declarator:sym<grammar>"
    $P2037."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2038)
    get_how $P2039, type_obj
    .const 'Sub' $P2040 = "145_1300051172.188" 
    $P2039."add_method"(type_obj, "package_declarator:sym<role>", $P2040)
    get_how $P2041, type_obj
    get_global $P2042, "!PREFIX__package_declarator:sym<role>"
    $P2041."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2042)
    get_how $P2043, type_obj
    .const 'Sub' $P2044 = "147_1300051172.188" 
    $P2043."add_method"(type_obj, "package_declarator:sym<native>", $P2044)
    get_how $P2045, type_obj
    get_global $P2046, "!PREFIX__package_declarator:sym<native>"
    $P2045."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2046)
    get_how $P2047, type_obj
    .const 'Sub' $P2048 = "149_1300051172.188" 
    $P2047."add_method"(type_obj, "package_def", $P2048)
    get_how $P2049, type_obj
    get_global $P2050, "!PREFIX__package_def"
    $P2049."add_method"(type_obj, "!PREFIX__package_def", $P2050)
    get_how $P2051, type_obj
    .const 'Sub' $P2052 = "152_1300051172.188" 
    $P2051."add_method"(type_obj, "scope_declarator", $P2052)
    get_how $P2053, type_obj
    .const 'Sub' $P2054 = "153_1300051172.188" 
    $P2053."add_method"(type_obj, "!PREFIX__scope_declarator", $P2054)
    get_how $P2055, type_obj
    .const 'Sub' $P2056 = "154_1300051172.188" 
    $P2055."add_method"(type_obj, "scope_declarator:sym<my>", $P2056)
    get_how $P2057, type_obj
    get_global $P2058, "!PREFIX__scope_declarator:sym<my>"
    $P2057."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2058)
    get_how $P2059, type_obj
    .const 'Sub' $P2060 = "156_1300051172.188" 
    $P2059."add_method"(type_obj, "scope_declarator:sym<our>", $P2060)
    get_how $P2061, type_obj
    get_global $P2062, "!PREFIX__scope_declarator:sym<our>"
    $P2061."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2062)
    get_how $P2063, type_obj
    .const 'Sub' $P2064 = "158_1300051172.188" 
    $P2063."add_method"(type_obj, "scope_declarator:sym<has>", $P2064)
    get_how $P2065, type_obj
    get_global $P2066, "!PREFIX__scope_declarator:sym<has>"
    $P2065."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2066)
    get_how $P2067, type_obj
    .const 'Sub' $P2068 = "160_1300051172.188" 
    $P2067."add_method"(type_obj, "scoped", $P2068)
    get_how $P2069, type_obj
    get_global $P2070, "!PREFIX__scoped"
    $P2069."add_method"(type_obj, "!PREFIX__scoped", $P2070)
    get_how $P2071, type_obj
    .const 'Sub' $P2072 = "162_1300051172.188" 
    $P2071."add_method"(type_obj, "typename", $P2072)
    get_how $P2073, type_obj
    get_global $P2074, "!PREFIX__typename"
    $P2073."add_method"(type_obj, "!PREFIX__typename", $P2074)
    get_how $P2075, type_obj
    .const 'Sub' $P2076 = "164_1300051172.188" 
    $P2075."add_method"(type_obj, "declarator", $P2076)
    get_how $P2077, type_obj
    get_global $P2078, "!PREFIX__declarator"
    $P2077."add_method"(type_obj, "!PREFIX__declarator", $P2078)
    get_how $P2079, type_obj
    .const 'Sub' $P2080 = "166_1300051172.188" 
    $P2079."add_method"(type_obj, "variable_declarator", $P2080)
    get_how $P2081, type_obj
    get_global $P2082, "!PREFIX__variable_declarator"
    $P2081."add_method"(type_obj, "!PREFIX__variable_declarator", $P2082)
    get_how $P2083, type_obj
    .const 'Sub' $P2084 = "168_1300051172.188" 
    $P2083."add_method"(type_obj, "routine_declarator", $P2084)
    get_how $P2085, type_obj
    .const 'Sub' $P2086 = "169_1300051172.188" 
    $P2085."add_method"(type_obj, "!PREFIX__routine_declarator", $P2086)
    get_how $P2087, type_obj
    .const 'Sub' $P2088 = "170_1300051172.188" 
    $P2087."add_method"(type_obj, "routine_declarator:sym<sub>", $P2088)
    get_how $P2089, type_obj
    get_global $P2090, "!PREFIX__routine_declarator:sym<sub>"
    $P2089."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2090)
    get_how $P2091, type_obj
    .const 'Sub' $P2092 = "172_1300051172.188" 
    $P2091."add_method"(type_obj, "routine_declarator:sym<method>", $P2092)
    get_how $P2093, type_obj
    get_global $P2094, "!PREFIX__routine_declarator:sym<method>"
    $P2093."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2094)
    get_how $P2095, type_obj
    .const 'Sub' $P2096 = "174_1300051172.188" 
    $P2095."add_method"(type_obj, "routine_def", $P2096)
    get_how $P2097, type_obj
    get_global $P2098, "!PREFIX__routine_def"
    $P2097."add_method"(type_obj, "!PREFIX__routine_def", $P2098)
    get_how $P2099, type_obj
    .const 'Sub' $P2100 = "176_1300051172.188" 
    $P2099."add_method"(type_obj, "method_def", $P2100)
    get_how $P2101, type_obj
    get_global $P2102, "!PREFIX__method_def"
    $P2101."add_method"(type_obj, "!PREFIX__method_def", $P2102)
    get_how $P2103, type_obj
    .const 'Sub' $P2104 = "179_1300051172.188" 
    $P2103."add_method"(type_obj, "onlystar", $P2104)
    get_how $P2105, type_obj
    get_global $P2106, "!PREFIX__onlystar"
    $P2105."add_method"(type_obj, "!PREFIX__onlystar", $P2106)
    get_how $P2107, type_obj
    .const 'Sub' $P2108 = "182_1300051172.188" 
    $P2107."add_method"(type_obj, "multi_declarator", $P2108)
    get_how $P2109, type_obj
    .const 'Sub' $P2110 = "183_1300051172.188" 
    $P2109."add_method"(type_obj, "!PREFIX__multi_declarator", $P2110)
    get_how $P2111, type_obj
    .const 'Sub' $P2112 = "184_1300051172.188" 
    $P2111."add_method"(type_obj, "multi_declarator:sym<multi>", $P2112)
    get_how $P2113, type_obj
    get_global $P2114, "!PREFIX__multi_declarator:sym<multi>"
    $P2113."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2114)
    get_how $P2115, type_obj
    .const 'Sub' $P2116 = "186_1300051172.188" 
    $P2115."add_method"(type_obj, "multi_declarator:sym<proto>", $P2116)
    get_how $P2117, type_obj
    get_global $P2118, "!PREFIX__multi_declarator:sym<proto>"
    $P2117."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2118)
    get_how $P2119, type_obj
    .const 'Sub' $P2120 = "188_1300051172.188" 
    $P2119."add_method"(type_obj, "multi_declarator:sym<null>", $P2120)
    get_how $P2121, type_obj
    get_global $P2122, "!PREFIX__multi_declarator:sym<null>"
    $P2121."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2122)
    get_how $P2123, type_obj
    .const 'Sub' $P2124 = "190_1300051172.188" 
    $P2123."add_method"(type_obj, "signature", $P2124)
    get_how $P2125, type_obj
    get_global $P2126, "!PREFIX__signature"
    $P2125."add_method"(type_obj, "!PREFIX__signature", $P2126)
    get_how $P2127, type_obj
    .const 'Sub' $P2128 = "193_1300051172.188" 
    $P2127."add_method"(type_obj, "parameter", $P2128)
    get_how $P2129, type_obj
    get_global $P2130, "!PREFIX__parameter"
    $P2129."add_method"(type_obj, "!PREFIX__parameter", $P2130)
    get_how $P2131, type_obj
    .const 'Sub' $P2132 = "195_1300051172.188" 
    $P2131."add_method"(type_obj, "param_var", $P2132)
    get_how $P2133, type_obj
    get_global $P2134, "!PREFIX__param_var"
    $P2133."add_method"(type_obj, "!PREFIX__param_var", $P2134)
    get_how $P2135, type_obj
    .const 'Sub' $P2136 = "197_1300051172.188" 
    $P2135."add_method"(type_obj, "named_param", $P2136)
    get_how $P2137, type_obj
    get_global $P2138, "!PREFIX__named_param"
    $P2137."add_method"(type_obj, "!PREFIX__named_param", $P2138)
    get_how $P2139, type_obj
    .const 'Sub' $P2140 = "199_1300051172.188" 
    $P2139."add_method"(type_obj, "default_value", $P2140)
    get_how $P2141, type_obj
    get_global $P2142, "!PREFIX__default_value"
    $P2141."add_method"(type_obj, "!PREFIX__default_value", $P2142)
    get_how $P2143, type_obj
    .const 'Sub' $P2144 = "201_1300051172.188" 
    $P2143."add_method"(type_obj, "trait", $P2144)
    get_how $P2145, type_obj
    get_global $P2146, "!PREFIX__trait"
    $P2145."add_method"(type_obj, "!PREFIX__trait", $P2146)
    get_how $P2147, type_obj
    .const 'Sub' $P2148 = "203_1300051172.188" 
    $P2147."add_method"(type_obj, "trait_mod", $P2148)
    get_how $P2149, type_obj
    .const 'Sub' $P2150 = "204_1300051172.188" 
    $P2149."add_method"(type_obj, "!PREFIX__trait_mod", $P2150)
    get_how $P2151, type_obj
    .const 'Sub' $P2152 = "205_1300051172.188" 
    $P2151."add_method"(type_obj, "trait_mod:sym<is>", $P2152)
    get_how $P2153, type_obj
    get_global $P2154, "!PREFIX__trait_mod:sym<is>"
    $P2153."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2154)
    get_how $P2155, type_obj
    .const 'Sub' $P2156 = "207_1300051172.188" 
    $P2155."add_method"(type_obj, "regex_declarator", $P2156)
    get_how $P2157, type_obj
    get_global $P2158, "!PREFIX__regex_declarator"
    $P2157."add_method"(type_obj, "!PREFIX__regex_declarator", $P2158)
    get_how $P2159, type_obj
    .const 'Sub' $P2160 = "209_1300051172.188" 
    $P2159."add_method"(type_obj, "dotty", $P2160)
    get_how $P2161, type_obj
    get_global $P2162, "!PREFIX__dotty"
    $P2161."add_method"(type_obj, "!PREFIX__dotty", $P2162)
    get_how $P2163, type_obj
    .const 'Sub' $P2164 = "211_1300051172.188" 
    $P2163."add_method"(type_obj, "term", $P2164)
    get_how $P2165, type_obj
    .const 'Sub' $P2166 = "212_1300051172.188" 
    $P2165."add_method"(type_obj, "!PREFIX__term", $P2166)
    get_how $P2167, type_obj
    .const 'Sub' $P2168 = "213_1300051172.188" 
    $P2167."add_method"(type_obj, "term:sym<self>", $P2168)
    get_how $P2169, type_obj
    get_global $P2170, "!PREFIX__term:sym<self>"
    $P2169."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2170)
    get_how $P2171, type_obj
    .const 'Sub' $P2172 = "215_1300051172.188" 
    $P2171."add_method"(type_obj, "term:sym<identifier>", $P2172)
    get_how $P2173, type_obj
    get_global $P2174, "!PREFIX__term:sym<identifier>"
    $P2173."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2174)
    get_how $P2175, type_obj
    .const 'Sub' $P2176 = "217_1300051172.188" 
    $P2175."add_method"(type_obj, "term:sym<name>", $P2176)
    get_how $P2177, type_obj
    get_global $P2178, "!PREFIX__term:sym<name>"
    $P2177."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2178)
    get_how $P2179, type_obj
    .const 'Sub' $P2180 = "219_1300051172.188" 
    $P2179."add_method"(type_obj, "term:sym<pir::op>", $P2180)
    get_how $P2181, type_obj
    get_global $P2182, "!PREFIX__term:sym<pir::op>"
    $P2181."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2182)
    get_how $P2183, type_obj
    .const 'Sub' $P2184 = "221_1300051172.188" 
    $P2183."add_method"(type_obj, "term:sym<onlystar>", $P2184)
    get_how $P2185, type_obj
    get_global $P2186, "!PREFIX__term:sym<onlystar>"
    $P2185."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2186)
    get_how $P2187, type_obj
    .const 'Sub' $P2188 = "224_1300051172.188" 
    $P2187."add_method"(type_obj, "args", $P2188)
    get_how $P2189, type_obj
    get_global $P2190, "!PREFIX__args"
    $P2189."add_method"(type_obj, "!PREFIX__args", $P2190)
    get_how $P2191, type_obj
    .const 'Sub' $P2192 = "226_1300051172.188" 
    $P2191."add_method"(type_obj, "arglist", $P2192)
    get_how $P2193, type_obj
    get_global $P2194, "!PREFIX__arglist"
    $P2193."add_method"(type_obj, "!PREFIX__arglist", $P2194)
    get_how $P2195, type_obj
    .const 'Sub' $P2196 = "228_1300051172.188" 
    $P2195."add_method"(type_obj, "term:sym<value>", $P2196)
    get_how $P2197, type_obj
    get_global $P2198, "!PREFIX__term:sym<value>"
    $P2197."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2198)
    get_how $P2199, type_obj
    .const 'Sub' $P2200 = "230_1300051172.188" 
    $P2199."add_method"(type_obj, "value", $P2200)
    get_how $P2201, type_obj
    get_global $P2202, "!PREFIX__value"
    $P2201."add_method"(type_obj, "!PREFIX__value", $P2202)
    get_how $P2203, type_obj
    .const 'Sub' $P2204 = "232_1300051172.188" 
    $P2203."add_method"(type_obj, "number", $P2204)
    get_how $P2205, type_obj
    get_global $P2206, "!PREFIX__number"
    $P2205."add_method"(type_obj, "!PREFIX__number", $P2206)
    get_how $P2207, type_obj
    .const 'Sub' $P2208 = "234_1300051172.188" 
    $P2207."add_method"(type_obj, "quote", $P2208)
    get_how $P2209, type_obj
    .const 'Sub' $P2210 = "235_1300051172.188" 
    $P2209."add_method"(type_obj, "!PREFIX__quote", $P2210)
    get_how $P2211, type_obj
    .const 'Sub' $P2212 = "236_1300051172.188" 
    $P2211."add_method"(type_obj, "quote:sym<apos>", $P2212)
    get_how $P2213, type_obj
    get_global $P2214, "!PREFIX__quote:sym<apos>"
    $P2213."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2214)
    get_how $P2215, type_obj
    .const 'Sub' $P2216 = "238_1300051172.188" 
    $P2215."add_method"(type_obj, "quote:sym<dblq>", $P2216)
    get_how $P2217, type_obj
    get_global $P2218, "!PREFIX__quote:sym<dblq>"
    $P2217."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2218)
    get_how $P2219, type_obj
    .const 'Sub' $P2220 = "240_1300051172.188" 
    $P2219."add_method"(type_obj, "quote:sym<q>", $P2220)
    get_how $P2221, type_obj
    get_global $P2222, "!PREFIX__quote:sym<q>"
    $P2221."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2222)
    get_how $P2223, type_obj
    .const 'Sub' $P2224 = "242_1300051172.188" 
    $P2223."add_method"(type_obj, "quote:sym<qq>", $P2224)
    get_how $P2225, type_obj
    get_global $P2226, "!PREFIX__quote:sym<qq>"
    $P2225."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2226)
    get_how $P2227, type_obj
    .const 'Sub' $P2228 = "244_1300051172.188" 
    $P2227."add_method"(type_obj, "quote:sym<Q>", $P2228)
    get_how $P2229, type_obj
    get_global $P2230, "!PREFIX__quote:sym<Q>"
    $P2229."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2230)
    get_how $P2231, type_obj
    .const 'Sub' $P2232 = "246_1300051172.188" 
    $P2231."add_method"(type_obj, "quote:sym<Q:PIR>", $P2232)
    get_how $P2233, type_obj
    get_global $P2234, "!PREFIX__quote:sym<Q:PIR>"
    $P2233."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2234)
    get_how $P2235, type_obj
    .const 'Sub' $P2236 = "248_1300051172.188" 
    $P2235."add_method"(type_obj, "quote:sym</ />", $P2236)
    get_how $P2237, type_obj
    get_global $P2238, "!PREFIX__quote:sym</ />"
    $P2237."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2238)
    get_how $P2239, type_obj
    .const 'Sub' $P2240 = "250_1300051172.188" 
    $P2239."add_method"(type_obj, "quote_escape:sym<$>", $P2240)
    get_how $P2241, type_obj
    get_global $P2242, "!PREFIX__quote_escape:sym<$>"
    $P2241."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2242)
    get_how $P2243, type_obj
    .const 'Sub' $P2244 = "252_1300051172.188" 
    $P2243."add_method"(type_obj, "quote_escape:sym<{ }>", $P2244)
    get_how $P2245, type_obj
    get_global $P2246, "!PREFIX__quote_escape:sym<{ }>"
    $P2245."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2246)
    get_how $P2247, type_obj
    .const 'Sub' $P2248 = "254_1300051172.188" 
    $P2247."add_method"(type_obj, "quote_escape:sym<esc>", $P2248)
    get_how $P2249, type_obj
    get_global $P2250, "!PREFIX__quote_escape:sym<esc>"
    $P2249."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2250)
    get_how $P2251, type_obj
    .const 'Sub' $P2252 = "256_1300051172.188" 
    $P2251."add_method"(type_obj, "circumfix:sym<( )>", $P2252)
    get_how $P2253, type_obj
    get_global $P2254, "!PREFIX__circumfix:sym<( )>"
    $P2253."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2254)
    get_how $P2255, type_obj
    .const 'Sub' $P2256 = "258_1300051172.188" 
    $P2255."add_method"(type_obj, "circumfix:sym<[ ]>", $P2256)
    get_how $P2257, type_obj
    get_global $P2258, "!PREFIX__circumfix:sym<[ ]>"
    $P2257."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2258)
    get_how $P2259, type_obj
    .const 'Sub' $P2260 = "260_1300051172.188" 
    $P2259."add_method"(type_obj, "circumfix:sym<ang>", $P2260)
    get_how $P2261, type_obj
    get_global $P2262, "!PREFIX__circumfix:sym<ang>"
    $P2261."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2262)
    get_how $P2263, type_obj
    .const 'Sub' $P2264 = "262_1300051172.188" 
    $P2263."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2264)
    get_how $P2265, type_obj
    get_global $P2266, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2265."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2266)
    get_how $P2267, type_obj
    .const 'Sub' $P2268 = "264_1300051172.188" 
    $P2267."add_method"(type_obj, "circumfix:sym<{ }>", $P2268)
    get_how $P2269, type_obj
    get_global $P2270, "!PREFIX__circumfix:sym<{ }>"
    $P2269."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2270)
    get_how $P2271, type_obj
    .const 'Sub' $P2272 = "266_1300051172.188" 
    $P2271."add_method"(type_obj, "circumfix:sym<sigil>", $P2272)
    get_how $P2273, type_obj
    get_global $P2274, "!PREFIX__circumfix:sym<sigil>"
    $P2273."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2274)
    get_how $P2275, type_obj
    .const 'Sub' $P2276 = "268_1300051172.188" 
    $P2275."add_method"(type_obj, "semilist", $P2276)
    get_how $P2277, type_obj
    get_global $P2278, "!PREFIX__semilist"
    $P2277."add_method"(type_obj, "!PREFIX__semilist", $P2278)
    get_how $P2279, type_obj
    .const 'Sub' $P2280 = "271_1300051172.188" 
    $P2279."add_method"(type_obj, "infixish", $P2280)
    get_how $P2281, type_obj
    get_global $P2282, "!PREFIX__infixish"
    $P2281."add_method"(type_obj, "!PREFIX__infixish", $P2282)
    get_how $P2283, type_obj
    .const 'Sub' $P2284 = "273_1300051172.188" 
    $P2283."add_method"(type_obj, "infixstopper", $P2284)
    get_how $P2285, type_obj
    get_global $P2286, "!PREFIX__infixstopper"
    $P2285."add_method"(type_obj, "!PREFIX__infixstopper", $P2286)
    get_how $P2287, type_obj
    .const 'Sub' $P2288 = "275_1300051172.188" 
    $P2287."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2288)
    get_how $P2289, type_obj
    get_global $P2290, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2289."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2290)
    get_how $P2291, type_obj
    .const 'Sub' $P2292 = "277_1300051172.188" 
    $P2291."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2292)
    get_how $P2293, type_obj
    get_global $P2294, "!PREFIX__postcircumfix:sym<{ }>"
    $P2293."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2294)
    get_how $P2295, type_obj
    .const 'Sub' $P2296 = "279_1300051172.188" 
    $P2295."add_method"(type_obj, "postcircumfix:sym<ang>", $P2296)
    get_how $P2297, type_obj
    get_global $P2298, "!PREFIX__postcircumfix:sym<ang>"
    $P2297."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2298)
    get_how $P2299, type_obj
    .const 'Sub' $P2300 = "281_1300051172.188" 
    $P2299."add_method"(type_obj, "postcircumfix:sym<( )>", $P2300)
    get_how $P2301, type_obj
    get_global $P2302, "!PREFIX__postcircumfix:sym<( )>"
    $P2301."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2302)
    get_how $P2303, type_obj
    .const 'Sub' $P2304 = "283_1300051172.188" 
    $P2303."add_method"(type_obj, "postfix:sym<.>", $P2304)
    get_how $P2305, type_obj
    get_global $P2306, "!PREFIX__postfix:sym<.>"
    $P2305."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2306)
    get_how $P2307, type_obj
    .const 'Sub' $P2308 = "285_1300051172.188" 
    $P2307."add_method"(type_obj, "prefix:sym<++>", $P2308)
    get_how $P2309, type_obj
    get_global $P2310, "!PREFIX__prefix:sym<++>"
    $P2309."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2310)
    get_how $P2311, type_obj
    .const 'Sub' $P2312 = "287_1300051172.188" 
    $P2311."add_method"(type_obj, "prefix:sym<-->", $P2312)
    get_how $P2313, type_obj
    get_global $P2314, "!PREFIX__prefix:sym<-->"
    $P2313."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2314)
    get_how $P2315, type_obj
    .const 'Sub' $P2316 = "289_1300051172.188" 
    $P2315."add_method"(type_obj, "postfix:sym<++>", $P2316)
    get_how $P2317, type_obj
    get_global $P2318, "!PREFIX__postfix:sym<++>"
    $P2317."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2318)
    get_how $P2319, type_obj
    .const 'Sub' $P2320 = "291_1300051172.188" 
    $P2319."add_method"(type_obj, "postfix:sym<-->", $P2320)
    get_how $P2321, type_obj
    get_global $P2322, "!PREFIX__postfix:sym<-->"
    $P2321."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2322)
    get_how $P2323, type_obj
    .const 'Sub' $P2324 = "293_1300051172.188" 
    $P2323."add_method"(type_obj, "infix:sym<**>", $P2324)
    get_how $P2325, type_obj
    get_global $P2326, "!PREFIX__infix:sym<**>"
    $P2325."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2326)
    get_how $P2327, type_obj
    .const 'Sub' $P2328 = "295_1300051172.188" 
    $P2327."add_method"(type_obj, "prefix:sym<+>", $P2328)
    get_how $P2329, type_obj
    get_global $P2330, "!PREFIX__prefix:sym<+>"
    $P2329."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2330)
    get_how $P2331, type_obj
    .const 'Sub' $P2332 = "297_1300051172.188" 
    $P2331."add_method"(type_obj, "prefix:sym<~>", $P2332)
    get_how $P2333, type_obj
    get_global $P2334, "!PREFIX__prefix:sym<~>"
    $P2333."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2334)
    get_how $P2335, type_obj
    .const 'Sub' $P2336 = "299_1300051172.188" 
    $P2335."add_method"(type_obj, "prefix:sym<->", $P2336)
    get_how $P2337, type_obj
    get_global $P2338, "!PREFIX__prefix:sym<->"
    $P2337."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2338)
    get_how $P2339, type_obj
    .const 'Sub' $P2340 = "301_1300051172.188" 
    $P2339."add_method"(type_obj, "prefix:sym<?>", $P2340)
    get_how $P2341, type_obj
    get_global $P2342, "!PREFIX__prefix:sym<?>"
    $P2341."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2342)
    get_how $P2343, type_obj
    .const 'Sub' $P2344 = "303_1300051172.188" 
    $P2343."add_method"(type_obj, "prefix:sym<!>", $P2344)
    get_how $P2345, type_obj
    get_global $P2346, "!PREFIX__prefix:sym<!>"
    $P2345."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2346)
    get_how $P2347, type_obj
    .const 'Sub' $P2348 = "305_1300051172.188" 
    $P2347."add_method"(type_obj, "prefix:sym<|>", $P2348)
    get_how $P2349, type_obj
    get_global $P2350, "!PREFIX__prefix:sym<|>"
    $P2349."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2350)
    get_how $P2351, type_obj
    .const 'Sub' $P2352 = "307_1300051172.188" 
    $P2351."add_method"(type_obj, "infix:sym<*>", $P2352)
    get_how $P2353, type_obj
    get_global $P2354, "!PREFIX__infix:sym<*>"
    $P2353."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2354)
    get_how $P2355, type_obj
    .const 'Sub' $P2356 = "309_1300051172.188" 
    $P2355."add_method"(type_obj, "infix:sym</>", $P2356)
    get_how $P2357, type_obj
    get_global $P2358, "!PREFIX__infix:sym</>"
    $P2357."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2358)
    get_how $P2359, type_obj
    .const 'Sub' $P2360 = "311_1300051172.188" 
    $P2359."add_method"(type_obj, "infix:sym<%>", $P2360)
    get_how $P2361, type_obj
    get_global $P2362, "!PREFIX__infix:sym<%>"
    $P2361."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2362)
    get_how $P2363, type_obj
    .const 'Sub' $P2364 = "313_1300051172.188" 
    $P2363."add_method"(type_obj, "infix:sym<+&>", $P2364)
    get_how $P2365, type_obj
    get_global $P2366, "!PREFIX__infix:sym<+&>"
    $P2365."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2366)
    get_how $P2367, type_obj
    .const 'Sub' $P2368 = "315_1300051172.188" 
    $P2367."add_method"(type_obj, "infix:sym<+>", $P2368)
    get_how $P2369, type_obj
    get_global $P2370, "!PREFIX__infix:sym<+>"
    $P2369."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2370)
    get_how $P2371, type_obj
    .const 'Sub' $P2372 = "317_1300051172.188" 
    $P2371."add_method"(type_obj, "infix:sym<->", $P2372)
    get_how $P2373, type_obj
    get_global $P2374, "!PREFIX__infix:sym<->"
    $P2373."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2374)
    get_how $P2375, type_obj
    .const 'Sub' $P2376 = "319_1300051172.188" 
    $P2375."add_method"(type_obj, "infix:sym<+|>", $P2376)
    get_how $P2377, type_obj
    get_global $P2378, "!PREFIX__infix:sym<+|>"
    $P2377."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2378)
    get_how $P2379, type_obj
    .const 'Sub' $P2380 = "321_1300051172.188" 
    $P2379."add_method"(type_obj, "infix:sym<+^>", $P2380)
    get_how $P2381, type_obj
    get_global $P2382, "!PREFIX__infix:sym<+^>"
    $P2381."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2382)
    get_how $P2383, type_obj
    .const 'Sub' $P2384 = "323_1300051172.188" 
    $P2383."add_method"(type_obj, "infix:sym<~>", $P2384)
    get_how $P2385, type_obj
    get_global $P2386, "!PREFIX__infix:sym<~>"
    $P2385."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2386)
    get_how $P2387, type_obj
    .const 'Sub' $P2388 = "325_1300051172.188" 
    $P2387."add_method"(type_obj, "infix:sym<==>", $P2388)
    get_how $P2389, type_obj
    get_global $P2390, "!PREFIX__infix:sym<==>"
    $P2389."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2390)
    get_how $P2391, type_obj
    .const 'Sub' $P2392 = "327_1300051172.188" 
    $P2391."add_method"(type_obj, "infix:sym<!=>", $P2392)
    get_how $P2393, type_obj
    get_global $P2394, "!PREFIX__infix:sym<!=>"
    $P2393."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2394)
    get_how $P2395, type_obj
    .const 'Sub' $P2396 = "329_1300051172.188" 
    $P2395."add_method"(type_obj, "infix:sym<<=>", $P2396)
    get_how $P2397, type_obj
    get_global $P2398, "!PREFIX__infix:sym<<=>"
    $P2397."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2398)
    get_how $P2399, type_obj
    .const 'Sub' $P2400 = "331_1300051172.188" 
    $P2399."add_method"(type_obj, "infix:sym<>=>", $P2400)
    get_how $P2401, type_obj
    get_global $P2402, "!PREFIX__infix:sym<>=>"
    $P2401."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2402)
    get_how $P2403, type_obj
    .const 'Sub' $P2404 = "333_1300051172.188" 
    $P2403."add_method"(type_obj, "infix:sym<<>", $P2404)
    get_how $P2405, type_obj
    get_global $P2406, "!PREFIX__infix:sym<<>"
    $P2405."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2406)
    get_how $P2407, type_obj
    .const 'Sub' $P2408 = "335_1300051172.188" 
    $P2407."add_method"(type_obj, "infix:sym<>>", $P2408)
    get_how $P2409, type_obj
    get_global $P2410, "!PREFIX__infix:sym<>>"
    $P2409."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2410)
    get_how $P2411, type_obj
    .const 'Sub' $P2412 = "337_1300051172.188" 
    $P2411."add_method"(type_obj, "infix:sym<eq>", $P2412)
    get_how $P2413, type_obj
    get_global $P2414, "!PREFIX__infix:sym<eq>"
    $P2413."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2414)
    get_how $P2415, type_obj
    .const 'Sub' $P2416 = "339_1300051172.188" 
    $P2415."add_method"(type_obj, "infix:sym<ne>", $P2416)
    get_how $P2417, type_obj
    get_global $P2418, "!PREFIX__infix:sym<ne>"
    $P2417."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2418)
    get_how $P2419, type_obj
    .const 'Sub' $P2420 = "341_1300051172.188" 
    $P2419."add_method"(type_obj, "infix:sym<le>", $P2420)
    get_how $P2421, type_obj
    get_global $P2422, "!PREFIX__infix:sym<le>"
    $P2421."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2422)
    get_how $P2423, type_obj
    .const 'Sub' $P2424 = "343_1300051172.188" 
    $P2423."add_method"(type_obj, "infix:sym<ge>", $P2424)
    get_how $P2425, type_obj
    get_global $P2426, "!PREFIX__infix:sym<ge>"
    $P2425."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2426)
    get_how $P2427, type_obj
    .const 'Sub' $P2428 = "345_1300051172.188" 
    $P2427."add_method"(type_obj, "infix:sym<lt>", $P2428)
    get_how $P2429, type_obj
    get_global $P2430, "!PREFIX__infix:sym<lt>"
    $P2429."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2430)
    get_how $P2431, type_obj
    .const 'Sub' $P2432 = "347_1300051172.188" 
    $P2431."add_method"(type_obj, "infix:sym<gt>", $P2432)
    get_how $P2433, type_obj
    get_global $P2434, "!PREFIX__infix:sym<gt>"
    $P2433."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2434)
    get_how $P2435, type_obj
    .const 'Sub' $P2436 = "349_1300051172.188" 
    $P2435."add_method"(type_obj, "infix:sym<=:=>", $P2436)
    get_how $P2437, type_obj
    get_global $P2438, "!PREFIX__infix:sym<=:=>"
    $P2437."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2438)
    get_how $P2439, type_obj
    .const 'Sub' $P2440 = "351_1300051172.188" 
    $P2439."add_method"(type_obj, "infix:sym<~~>", $P2440)
    get_how $P2441, type_obj
    get_global $P2442, "!PREFIX__infix:sym<~~>"
    $P2441."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2442)
    get_how $P2443, type_obj
    .const 'Sub' $P2444 = "353_1300051172.188" 
    $P2443."add_method"(type_obj, "infix:sym<&&>", $P2444)
    get_how $P2445, type_obj
    get_global $P2446, "!PREFIX__infix:sym<&&>"
    $P2445."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2446)
    get_how $P2447, type_obj
    .const 'Sub' $P2448 = "355_1300051172.188" 
    $P2447."add_method"(type_obj, "infix:sym<||>", $P2448)
    get_how $P2449, type_obj
    get_global $P2450, "!PREFIX__infix:sym<||>"
    $P2449."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2450)
    get_how $P2451, type_obj
    .const 'Sub' $P2452 = "357_1300051172.188" 
    $P2451."add_method"(type_obj, "infix:sym<//>", $P2452)
    get_how $P2453, type_obj
    get_global $P2454, "!PREFIX__infix:sym<//>"
    $P2453."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2454)
    get_how $P2455, type_obj
    .const 'Sub' $P2456 = "359_1300051172.188" 
    $P2455."add_method"(type_obj, "infix:sym<?? !!>", $P2456)
    get_how $P2457, type_obj
    get_global $P2458, "!PREFIX__infix:sym<?? !!>"
    $P2457."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2458)
    get_how $P2459, type_obj
    .const 'Sub' $P2460 = "361_1300051172.188" 
    $P2459."add_method"(type_obj, "infix:sym<=>", $P2460)
    get_how $P2461, type_obj
    get_global $P2462, "!PREFIX__infix:sym<=>"
    $P2461."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2462)
    get_how $P2463, type_obj
    .const 'Sub' $P2464 = "363_1300051172.188" 
    $P2463."add_method"(type_obj, "infix:sym<:=>", $P2464)
    get_how $P2465, type_obj
    get_global $P2466, "!PREFIX__infix:sym<:=>"
    $P2465."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2466)
    get_how $P2467, type_obj
    .const 'Sub' $P2468 = "365_1300051172.188" 
    $P2467."add_method"(type_obj, "infix:sym<::=>", $P2468)
    get_how $P2469, type_obj
    get_global $P2470, "!PREFIX__infix:sym<::=>"
    $P2469."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2470)
    get_how $P2471, type_obj
    .const 'Sub' $P2472 = "367_1300051172.188" 
    $P2471."add_method"(type_obj, "infix:sym<,>", $P2472)
    get_how $P2473, type_obj
    get_global $P2474, "!PREFIX__infix:sym<,>"
    $P2473."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2474)
    get_how $P2475, type_obj
    .const 'Sub' $P2476 = "369_1300051172.188" 
    $P2475."add_method"(type_obj, "prefix:sym<return>", $P2476)
    get_how $P2477, type_obj
    get_global $P2478, "!PREFIX__prefix:sym<return>"
    $P2477."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2478)
    get_how $P2479, type_obj
    .const 'Sub' $P2480 = "372_1300051172.188" 
    $P2479."add_method"(type_obj, "prefix:sym<make>", $P2480)
    get_how $P2481, type_obj
    get_global $P2482, "!PREFIX__prefix:sym<make>"
    $P2481."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2482)
    get_how $P2483, type_obj
    .const 'Sub' $P2484 = "374_1300051172.188" 
    $P2483."add_method"(type_obj, "term:sym<last>", $P2484)
    get_how $P2485, type_obj
    get_global $P2486, "!PREFIX__term:sym<last>"
    $P2485."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2486)
    get_how $P2487, type_obj
    .const 'Sub' $P2488 = "376_1300051172.188" 
    $P2487."add_method"(type_obj, "term:sym<next>", $P2488)
    get_how $P2489, type_obj
    get_global $P2490, "!PREFIX__term:sym<next>"
    $P2489."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2490)
    get_how $P2491, type_obj
    .const 'Sub' $P2492 = "378_1300051172.188" 
    $P2491."add_method"(type_obj, "term:sym<redo>", $P2492)
    get_how $P2493, type_obj
    get_global $P2494, "!PREFIX__term:sym<redo>"
    $P2493."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2494)
    get_how $P2495, type_obj
    .const 'Sub' $P2496 = "380_1300051172.188" 
    $P2495."add_method"(type_obj, "smartmatch", $P2496)
    get_how $P2497, type_obj
    get_hll_global $P2498, ["HLL"], "Grammar"
    $P2497."add_parent"(type_obj, $P2498)
    get_how $P2499, type_obj
    $P2500 = $P2499."compose"(type_obj)
    .return ($P2500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1300051172.188") :outer("11_1300051172.188")
    .param pmc param_23
.annotate 'line', 4
    .lex "self", param_23
.annotate 'line', 6
    $P24 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P24
.annotate 'line', 13
    $P25 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P25
.annotate 'line', 22
    new $P26, "Undef"
    .lex "$*DEFAULT-METAATTR", $P26
.annotate 'line', 23
    $P27 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P27
.annotate 'line', 29
    new $P28, "Undef"
    .lex "$*SC", $P28
.annotate 'line', 33
    new $P29, "Undef"
    .lex "$*SCOPE", $P29
.annotate 'line', 34
    new $P30, "Undef"
    .lex "$*MULTINESS", $P30
.annotate 'line', 35
    new $P31, "Undef"
    .lex "$*INVOCANT_OK", $P31
.annotate 'line', 36
    new $P32, "Undef"
    .lex "$*RETURN_USED", $P32
.annotate 'line', 37
    new $P33, "Undef"
    .lex "$*PACKAGE-SETUP", $P33
.annotate 'line', 4
    find_lex $P34, "%*LANG"
    unless_null $P34, vivify_408
    get_hll_global $P34, "%LANG"
    unless_null $P34, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
  vivify_408:
.annotate 'line', 7
    get_hll_global $P35, ["NQP"], "Regex"
    find_lex $P36, "%*LANG"
    unless_null $P36, vivify_410
    get_hll_global $P36, "%LANG"
    unless_null $P36, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P36
  vivify_410:
    set $P36["Regex"], $P35
.annotate 'line', 8
    get_hll_global $P37, ["NQP"], "RegexActions"
    find_lex $P38, "%*LANG"
    unless_null $P38, vivify_412
    get_hll_global $P38, "%LANG"
    unless_null $P38, vivify_413
    die "Contextual %*LANG not found"
  vivify_413:
    store_lex "%*LANG", $P38
  vivify_412:
    set $P38["Regex-actions"], $P37
.annotate 'line', 9
    get_hll_global $P39, ["NQP"], "Grammar"
    find_lex $P40, "%*LANG"
    unless_null $P40, vivify_414
    get_hll_global $P40, "%LANG"
    unless_null $P40, vivify_415
    die "Contextual %*LANG not found"
  vivify_415:
    store_lex "%*LANG", $P40
  vivify_414:
    set $P40["MAIN"], $P39
.annotate 'line', 10
    get_hll_global $P41, ["NQP"], "Actions"
    find_lex $P42, "%*LANG"
    unless_null $P42, vivify_416
    get_hll_global $P42, "%LANG"
    unless_null $P42, vivify_417
    die "Contextual %*LANG not found"
  vivify_417:
    store_lex "%*LANG", $P42
  vivify_416:
    set $P42["MAIN-actions"], $P41
    find_lex $P43, "%*HOW"
    unless_null $P43, vivify_418
    get_hll_global $P43, "%HOW"
    unless_null $P43, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
  vivify_418:
.annotate 'line', 14
    get_hll_global $P44, "KnowHOW"
    find_lex $P45, "%*HOW"
    unless_null $P45, vivify_420
    get_hll_global $P45, "%HOW"
    unless_null $P45, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P45
  vivify_420:
    set $P45["knowhow"], $P44
.annotate 'line', 15
    get_hll_global $P46, "NQPModuleHOW"
    find_lex $P47, "%*HOW"
    unless_null $P47, vivify_422
    get_hll_global $P47, "%HOW"
    unless_null $P47, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P47
  vivify_422:
    set $P47["module"], $P46
.annotate 'line', 16
    get_hll_global $P48, "NQPClassHOW"
    find_lex $P49, "%*HOW"
    unless_null $P49, vivify_424
    get_hll_global $P49, "%HOW"
    unless_null $P49, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P49
  vivify_424:
    set $P49["class"], $P48
.annotate 'line', 17
    get_hll_global $P50, "NQPClassHOW"
    find_lex $P51, "%*HOW"
    unless_null $P51, vivify_426
    get_hll_global $P51, "%HOW"
    unless_null $P51, vivify_427
    die "Contextual %*HOW not found"
  vivify_427:
    store_lex "%*HOW", $P51
  vivify_426:
    set $P51["grammar"], $P50
.annotate 'line', 18
    get_hll_global $P52, "NQPParametricRoleHOW"
    find_lex $P53, "%*HOW"
    unless_null $P53, vivify_428
    get_hll_global $P53, "%HOW"
    unless_null $P53, vivify_429
    die "Contextual %*HOW not found"
  vivify_429:
    store_lex "%*HOW", $P53
  vivify_428:
    set $P53["role"], $P52
.annotate 'line', 19
    get_hll_global $P54, "NQPNativeHOW"
    find_lex $P55, "%*HOW"
    unless_null $P55, vivify_430
    get_hll_global $P55, "%HOW"
    unless_null $P55, vivify_431
    die "Contextual %*HOW not found"
  vivify_431:
    store_lex "%*HOW", $P55
  vivify_430:
    set $P55["native"], $P54
.annotate 'line', 22
    new $P56, "String"
    assign $P56, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P56
    find_lex $P57, "%*HOW-METAATTR"
    unless_null $P57, vivify_432
    get_hll_global $P57, "%HOW-METAATTR"
    unless_null $P57, vivify_433
    die "Contextual %*HOW-METAATTR not found"
  vivify_433:
  vivify_432:
.annotate 'line', 24
    new $P58, "String"
    assign $P58, "KnowHOWAttribute"
    find_lex $P59, "%*HOW-METAATTR"
    unless_null $P59, vivify_434
    get_hll_global $P59, "%HOW-METAATTR"
    unless_null $P59, vivify_435
    die "Contextual %*HOW-METAATTR not found"
  vivify_435:
    store_lex "%*HOW-METAATTR", $P59
  vivify_434:
    set $P59["knowhow"], $P58
.annotate 'line', 29
    get_hll_global $P60, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 31
    time $N61
    set $S62, $N61
    $P63 = $P60."new"($S62 :named("handle"))
.annotate 'line', 29
    store_lex "$*SC", $P63
.annotate 'line', 33
    new $P64, "String"
    assign $P64, ""
    store_lex "$*SCOPE", $P64
.annotate 'line', 34
    new $P65, "String"
    assign $P65, ""
    store_lex "$*MULTINESS", $P65
.annotate 'line', 35
    new $P66, "Integer"
    assign $P66, 0
    store_lex "$*INVOCANT_OK", $P66
.annotate 'line', 36
    new $P67, "Integer"
    assign $P67, 0
    store_lex "$*RETURN_USED", $P67
    find_lex $P68, "$*PACKAGE-SETUP"
    unless_null $P68, vivify_436
    get_hll_global $P68, "$PACKAGE-SETUP"
    unless_null $P68, vivify_437
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_437:
  vivify_436:
.annotate 'line', 38
    find_lex $P69, "self"
    $P70 = $P69."comp_unit"()
.annotate 'line', 4
    .return ($P70)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx72_tgt
    .local int rx72_pos
    .local int rx72_off
    .local int rx72_eos
    .local int rx72_rep
    .local pmc rx72_cur
    .local pmc rx72_debug
    (rx72_cur, rx72_pos, rx72_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx72_cur
    .local pmc match
    .lex "$/", match
    length rx72_eos, rx72_tgt
    gt rx72_pos, rx72_eos, rx72_done
    set rx72_off, 0
    lt rx72_pos, 2, rx72_start
    sub rx72_off, rx72_pos, 1
    substr rx72_tgt, rx72_tgt, rx72_off
  rx72_start:
    eq $I10, 1, rx72_restart
    if_null rx72_debug, debug_438
    rx72_cur."!cursor_debug"("START", "identifier")
  debug_438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan76_done
    goto rxscan76_scan
  rxscan76_loop:
    (rx72_pos) = rx72_cur."from"()
    inc rx72_pos
    rx72_cur."!cursor_from"(rx72_pos)
    ge rx72_pos, rx72_eos, rxscan76_done
  rxscan76_scan:
    set_addr $I10, rxscan76_loop
    rx72_cur."!mark_push"(0, rx72_pos, $I10)
  rxscan76_done:
.annotate 'line', 43
  # rx subrule "ident" subtype=method negate=
    rx72_cur."!cursor_pos"(rx72_pos)
    $P10 = rx72_cur."ident"()
    unless $P10, rx72_fail
    rx72_pos = $P10."pos"()
  # rx rxquantr77 ** 0..*
    set_addr $I10, rxquantr77_done
    rx72_cur."!mark_push"(0, rx72_pos, $I10)
  rxquantr77_loop:
  # rx enumcharlist negate=0 
    ge rx72_pos, rx72_eos, rx72_fail
    sub $I10, rx72_pos, rx72_off
    substr $S10, rx72_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx72_fail
    inc rx72_pos
  # rx subrule "ident" subtype=method negate=
    rx72_cur."!cursor_pos"(rx72_pos)
    $P10 = rx72_cur."ident"()
    unless $P10, rx72_fail
    rx72_pos = $P10."pos"()
    set_addr $I10, rxquantr77_done
    (rx72_rep) = rx72_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr77_done
    rx72_cur."!mark_push"(rx72_rep, rx72_pos, $I10)
    goto rxquantr77_loop
  rxquantr77_done:
  # rx pass
    rx72_cur."!cursor_pass"(rx72_pos, "identifier")
    if_null rx72_debug, debug_439
    rx72_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx72_pos)
  debug_439:
    .return (rx72_cur)
  rx72_restart:
.annotate 'line', 4
    if_null rx72_debug, debug_440
    rx72_cur."!cursor_debug"("NEXT", "identifier")
  debug_440:
  rx72_fail:
    (rx72_rep, rx72_pos, $I10, $P10) = rx72_cur."!mark_fail"(0)
    lt rx72_pos, -1, rx72_done
    eq rx72_pos, -1, rx72_fail
    jump $I10
  rx72_done:
    rx72_cur."!cursor_fail"()
    if_null rx72_debug, debug_441
    rx72_cur."!cursor_debug"("FAIL", "identifier")
  debug_441:
    .return (rx72_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1300051172.188") :method
.annotate 'line', 4
    $P74 = self."!PREFIX__!subrule"("ident", "")
    new $P75, "ResizablePMCArray"
    push $P75, $P74
    .return ($P75)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx79_tgt
    .local int rx79_pos
    .local int rx79_off
    .local int rx79_eos
    .local int rx79_rep
    .local pmc rx79_cur
    .local pmc rx79_debug
    (rx79_cur, rx79_pos, rx79_tgt, $I10) = self."!cursor_start"()
    rx79_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx79_cur
    .local pmc match
    .lex "$/", match
    length rx79_eos, rx79_tgt
    gt rx79_pos, rx79_eos, rx79_done
    set rx79_off, 0
    lt rx79_pos, 2, rx79_start
    sub rx79_off, rx79_pos, 1
    substr rx79_tgt, rx79_tgt, rx79_off
  rx79_start:
    eq $I10, 1, rx79_restart
    if_null rx79_debug, debug_442
    rx79_cur."!cursor_debug"("START", "name")
  debug_442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan82_done
    goto rxscan82_scan
  rxscan82_loop:
    (rx79_pos) = rx79_cur."from"()
    inc rx79_pos
    rx79_cur."!cursor_from"(rx79_pos)
    ge rx79_pos, rx79_eos, rxscan82_done
  rxscan82_scan:
    set_addr $I10, rxscan82_loop
    rx79_cur."!mark_push"(0, rx79_pos, $I10)
  rxscan82_done:
.annotate 'line', 45
  # rx rxquantr83 ** 1..*
    set_addr $I10, rxquantr83_done
    rx79_cur."!mark_push"(0, -1, $I10)
  rxquantr83_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx79_cur."!cursor_pos"(rx79_pos)
    $P10 = rx79_cur."identifier"()
    unless $P10, rx79_fail
    goto rxsubrule84_pass
  rxsubrule84_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx79_fail
  rxsubrule84_pass:
    set_addr $I10, rxsubrule84_back
    rx79_cur."!mark_push"(0, rx79_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx79_pos = $P10."pos"()
    set_addr $I10, rxquantr83_done
    (rx79_rep) = rx79_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr83_done
    rx79_cur."!mark_push"(rx79_rep, rx79_pos, $I10)
  # rx literal  "::"
    add $I11, rx79_pos, 2
    gt $I11, rx79_eos, rx79_fail
    sub $I11, rx79_pos, rx79_off
    substr $S10, rx79_tgt, $I11, 2
    ne $S10, "::", rx79_fail
    add rx79_pos, 2
    goto rxquantr83_loop
  rxquantr83_done:
  # rx pass
    rx79_cur."!cursor_pass"(rx79_pos, "name")
    if_null rx79_debug, debug_443
    rx79_cur."!cursor_debug"("PASS", "name", " at pos=", rx79_pos)
  debug_443:
    .return (rx79_cur)
  rx79_restart:
.annotate 'line', 4
    if_null rx79_debug, debug_444
    rx79_cur."!cursor_debug"("NEXT", "name")
  debug_444:
  rx79_fail:
    (rx79_rep, rx79_pos, $I10, $P10) = rx79_cur."!mark_fail"(0)
    lt rx79_pos, -1, rx79_done
    eq rx79_pos, -1, rx79_fail
    jump $I10
  rx79_done:
    rx79_cur."!cursor_fail"()
    if_null rx79_debug, debug_445
    rx79_cur."!cursor_debug"("FAIL", "name")
  debug_445:
    .return (rx79_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1300051172.188") :method
.annotate 'line', 4
    new $P81, "ResizablePMCArray"
    push $P81, ""
    .return ($P81)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx86_tgt
    .local int rx86_pos
    .local int rx86_off
    .local int rx86_eos
    .local int rx86_rep
    .local pmc rx86_cur
    .local pmc rx86_debug
    (rx86_cur, rx86_pos, rx86_tgt, $I10) = self."!cursor_start"()
    rx86_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx86_cur
    .local pmc match
    .lex "$/", match
    length rx86_eos, rx86_tgt
    gt rx86_pos, rx86_eos, rx86_done
    set rx86_off, 0
    lt rx86_pos, 2, rx86_start
    sub rx86_off, rx86_pos, 1
    substr rx86_tgt, rx86_tgt, rx86_off
  rx86_start:
    eq $I10, 1, rx86_restart
    if_null rx86_debug, debug_446
    rx86_cur."!cursor_debug"("START", "deflongname")
  debug_446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan90_done
    goto rxscan90_scan
  rxscan90_loop:
    (rx86_pos) = rx86_cur."from"()
    inc rx86_pos
    rx86_cur."!cursor_from"(rx86_pos)
    ge rx86_pos, rx86_eos, rxscan90_done
  rxscan90_scan:
    set_addr $I10, rxscan90_loop
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxscan90_done:
.annotate 'line', 48
  # rx subrule "identifier" subtype=capture negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."identifier"()
    unless $P10, rx86_fail
    rx86_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx86_pos = $P10."pos"()
  # rx rxquantr91 ** 0..1
    set_addr $I10, rxquantr91_done
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxquantr91_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."colonpair"()
    unless $P10, rx86_fail
    goto rxsubrule92_pass
  rxsubrule92_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx86_fail
  rxsubrule92_pass:
    set_addr $I10, rxsubrule92_back
    rx86_cur."!mark_push"(0, rx86_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx86_pos = $P10."pos"()
    set_addr $I10, rxquantr91_done
    (rx86_rep) = rx86_cur."!mark_commit"($I10)
  rxquantr91_done:
.annotate 'line', 47
  # rx pass
    rx86_cur."!cursor_pass"(rx86_pos, "deflongname")
    if_null rx86_debug, debug_447
    rx86_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx86_pos)
  debug_447:
    .return (rx86_cur)
  rx86_restart:
.annotate 'line', 4
    if_null rx86_debug, debug_448
    rx86_cur."!cursor_debug"("NEXT", "deflongname")
  debug_448:
  rx86_fail:
    (rx86_rep, rx86_pos, $I10, $P10) = rx86_cur."!mark_fail"(0)
    lt rx86_pos, -1, rx86_done
    eq rx86_pos, -1, rx86_fail
    jump $I10
  rx86_done:
    rx86_cur."!cursor_fail"()
    if_null rx86_debug, debug_449
    rx86_cur."!cursor_debug"("FAIL", "deflongname")
  debug_449:
    .return (rx86_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1300051172.188") :method
.annotate 'line', 4
    $P88 = self."!PREFIX__!subrule"("identifier", "")
    new $P89, "ResizablePMCArray"
    push $P89, $P88
    .return ($P89)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx94_tgt
    .local int rx94_pos
    .local int rx94_off
    .local int rx94_eos
    .local int rx94_rep
    .local pmc rx94_cur
    .local pmc rx94_debug
    (rx94_cur, rx94_pos, rx94_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx94_cur
    .local pmc match
    .lex "$/", match
    length rx94_eos, rx94_tgt
    gt rx94_pos, rx94_eos, rx94_done
    set rx94_off, 0
    lt rx94_pos, 2, rx94_start
    sub rx94_off, rx94_pos, 1
    substr rx94_tgt, rx94_tgt, rx94_off
  rx94_start:
    eq $I10, 1, rx94_restart
    if_null rx94_debug, debug_450
    rx94_cur."!cursor_debug"("START", "ENDSTMT")
  debug_450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan97_done
    goto rxscan97_scan
  rxscan97_loop:
    (rx94_pos) = rx94_cur."from"()
    inc rx94_pos
    rx94_cur."!cursor_from"(rx94_pos)
    ge rx94_pos, rx94_eos, rxscan97_done
  rxscan97_scan:
    set_addr $I10, rxscan97_loop
    rx94_cur."!mark_push"(0, rx94_pos, $I10)
  rxscan97_done:
.annotate 'line', 55
  # rx rxquantr98 ** 0..1
    set_addr $I10, rxquantr98_done
    rx94_cur."!mark_push"(0, rx94_pos, $I10)
  rxquantr98_loop:
  alt99_0:
.annotate 'line', 52
    set_addr $I10, alt99_1
    rx94_cur."!mark_push"(0, rx94_pos, $I10)
.annotate 'line', 53
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx94_pos, rx94_off
    set rx94_rep, 0
    sub $I12, rx94_eos, rx94_pos
  rxenumcharlistq100_loop:
    le $I12, 0, rxenumcharlistq100_done
    substr $S10, rx94_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq100_done
    inc rx94_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq100_loop
  rxenumcharlistq100_done:
    add rx94_pos, rx94_pos, rx94_rep
  # rxanchor eol
    sub $I10, rx94_pos, rx94_off
    is_cclass $I11, 4096, rx94_tgt, $I10
    if $I11, rxanchor101_done
    ne rx94_pos, rx94_eos, rx94_fail
    eq rx94_pos, 0, rxanchor101_done
    dec $I10
    is_cclass $I11, 4096, rx94_tgt, $I10
    if $I11, rx94_fail
  rxanchor101_done:
  # rx subrule "ws" subtype=method negate=
    rx94_cur."!cursor_pos"(rx94_pos)
    $P10 = rx94_cur."ws"()
    unless $P10, rx94_fail
    rx94_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx94_cur."!cursor_pos"(rx94_pos)
    $P10 = rx94_cur."MARKER"("endstmt")
    unless $P10, rx94_fail
    goto alt99_end
  alt99_1:
.annotate 'line', 54
  # rx rxquantr102 ** 0..1
    set_addr $I10, rxquantr102_done
    rx94_cur."!mark_push"(0, rx94_pos, $I10)
  rxquantr102_loop:
  # rx subrule "unv" subtype=method negate=
    rx94_cur."!cursor_pos"(rx94_pos)
    $P10 = rx94_cur."unv"()
    unless $P10, rx94_fail
    goto rxsubrule103_pass
  rxsubrule103_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx94_fail
  rxsubrule103_pass:
    set_addr $I10, rxsubrule103_back
    rx94_cur."!mark_push"(0, rx94_pos, $I10, $P10)
    rx94_pos = $P10."pos"()
    set_addr $I10, rxquantr102_done
    (rx94_rep) = rx94_cur."!mark_commit"($I10)
  rxquantr102_done:
  # rxanchor eol
    sub $I10, rx94_pos, rx94_off
    is_cclass $I11, 4096, rx94_tgt, $I10
    if $I11, rxanchor104_done
    ne rx94_pos, rx94_eos, rx94_fail
    eq rx94_pos, 0, rxanchor104_done
    dec $I10
    is_cclass $I11, 4096, rx94_tgt, $I10
    if $I11, rx94_fail
  rxanchor104_done:
  # rx subrule "ws" subtype=method negate=
    rx94_cur."!cursor_pos"(rx94_pos)
    $P10 = rx94_cur."ws"()
    unless $P10, rx94_fail
    rx94_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx94_cur."!cursor_pos"(rx94_pos)
    $P10 = rx94_cur."MARKER"("endstmt")
    unless $P10, rx94_fail
  alt99_end:
.annotate 'line', 55
    set_addr $I10, rxquantr98_done
    (rx94_rep) = rx94_cur."!mark_commit"($I10)
  rxquantr98_done:
.annotate 'line', 51
  # rx pass
    rx94_cur."!cursor_pass"(rx94_pos, "ENDSTMT")
    if_null rx94_debug, debug_451
    rx94_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx94_pos)
  debug_451:
    .return (rx94_cur)
  rx94_restart:
.annotate 'line', 4
    if_null rx94_debug, debug_452
    rx94_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_452:
  rx94_fail:
    (rx94_rep, rx94_pos, $I10, $P10) = rx94_cur."!mark_fail"(0)
    lt rx94_pos, -1, rx94_done
    eq rx94_pos, -1, rx94_fail
    jump $I10
  rx94_done:
    rx94_cur."!cursor_fail"()
    if_null rx94_debug, debug_453
    rx94_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_453:
    .return (rx94_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1300051172.188") :method
.annotate 'line', 4
    new $P96, "ResizablePMCArray"
    push $P96, ""
    .return ($P96)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx106_tgt
    .local int rx106_pos
    .local int rx106_off
    .local int rx106_eos
    .local int rx106_rep
    .local pmc rx106_cur
    .local pmc rx106_debug
    (rx106_cur, rx106_pos, rx106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx106_cur
    .local pmc match
    .lex "$/", match
    length rx106_eos, rx106_tgt
    gt rx106_pos, rx106_eos, rx106_done
    set rx106_off, 0
    lt rx106_pos, 2, rx106_start
    sub rx106_off, rx106_pos, 1
    substr rx106_tgt, rx106_tgt, rx106_off
  rx106_start:
    eq $I10, 1, rx106_restart
    if_null rx106_debug, debug_454
    rx106_cur."!cursor_debug"("START", "ws")
  debug_454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan109_done
    goto rxscan109_scan
  rxscan109_loop:
    (rx106_pos) = rx106_cur."from"()
    inc rx106_pos
    rx106_cur."!cursor_from"(rx106_pos)
    ge rx106_pos, rx106_eos, rxscan109_done
  rxscan109_scan:
    set_addr $I10, rxscan109_loop
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
  rxscan109_done:
  alt110_0:
.annotate 'line', 58
    set_addr $I10, alt110_1
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
.annotate 'line', 59
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx106_cur."!cursor_pos"(rx106_pos)
    $P10 = rx106_cur."MARKED"("ws")
    unless $P10, rx106_fail
    goto alt110_end
  alt110_1:
.annotate 'line', 60
  # rx subrule "ww" subtype=zerowidth negate=1
    rx106_cur."!cursor_pos"(rx106_pos)
    $P10 = rx106_cur."ww"()
    if $P10, rx106_fail
.annotate 'line', 65
  # rx rxquantr111 ** 0..*
    set_addr $I10, rxquantr111_done
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
  rxquantr111_loop:
  alt112_0:
.annotate 'line', 61
    set_addr $I10, alt112_1
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx106_pos, rx106_off
    set rx106_rep, 0
    sub $I12, rx106_eos, rx106_pos
  rxenumcharlistq113_loop:
    le $I12, 0, rxenumcharlistq113_done
    substr $S10, rx106_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq113_done
    inc rx106_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq113_loop
  rxenumcharlistq113_done:
    lt rx106_rep, 1, rx106_fail
    add rx106_pos, rx106_pos, rx106_rep
    goto alt112_end
  alt112_1:
    set_addr $I10, alt112_2
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
.annotate 'line', 62
  # rx literal  "#"
    add $I11, rx106_pos, 1
    gt $I11, rx106_eos, rx106_fail
    sub $I11, rx106_pos, rx106_off
    ord $I11, rx106_tgt, $I11
    ne $I11, 35, rx106_fail
    add rx106_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx106_pos, rx106_off
    find_cclass $I11, 4096, rx106_tgt, $I10, rx106_eos
    add rx106_pos, rx106_off, $I11
    goto alt112_end
  alt112_2:
    set_addr $I10, alt112_3
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
.annotate 'line', 63
  # rxanchor bol
    eq rx106_pos, 0, rxanchor114_done
    ge rx106_pos, rx106_eos, rx106_fail
    sub $I10, rx106_pos, rx106_off
    dec $I10
    is_cclass $I11, 4096, rx106_tgt, $I10
    unless $I11, rx106_fail
  rxanchor114_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx106_cur."!cursor_pos"(rx106_pos)
    $P10 = rx106_cur."pod_comment"()
    unless $P10, rx106_fail
    rx106_pos = $P10."pos"()
    goto alt112_end
  alt112_3:
.annotate 'line', 64
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx106_pos, rx106_off
    set rx106_rep, 0
    sub $I12, rx106_eos, rx106_pos
  rxenumcharlistq115_loop:
    le $I12, 0, rxenumcharlistq115_done
    substr $S10, rx106_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq115_done
    inc rx106_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq115_loop
  rxenumcharlistq115_done:
    lt rx106_rep, 1, rx106_fail
    add rx106_pos, rx106_pos, rx106_rep
  alt112_end:
.annotate 'line', 65
    set_addr $I10, rxquantr111_done
    (rx106_rep) = rx106_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr111_done
    rx106_cur."!mark_push"(rx106_rep, rx106_pos, $I10)
    goto rxquantr111_loop
  rxquantr111_done:
.annotate 'line', 66
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx106_cur."!cursor_pos"(rx106_pos)
    $P10 = rx106_cur."MARKER"("ws")
    unless $P10, rx106_fail
  alt110_end:
.annotate 'line', 58
  # rx pass
    rx106_cur."!cursor_pass"(rx106_pos, "ws")
    if_null rx106_debug, debug_455
    rx106_cur."!cursor_debug"("PASS", "ws", " at pos=", rx106_pos)
  debug_455:
    .return (rx106_cur)
  rx106_restart:
.annotate 'line', 4
    if_null rx106_debug, debug_456
    rx106_cur."!cursor_debug"("NEXT", "ws")
  debug_456:
  rx106_fail:
    (rx106_rep, rx106_pos, $I10, $P10) = rx106_cur."!mark_fail"(0)
    lt rx106_pos, -1, rx106_done
    eq rx106_pos, -1, rx106_fail
    jump $I10
  rx106_done:
    rx106_cur."!cursor_fail"()
    if_null rx106_debug, debug_457
    rx106_cur."!cursor_debug"("FAIL", "ws")
  debug_457:
    .return (rx106_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1300051172.188") :method
.annotate 'line', 4
    new $P108, "ResizablePMCArray"
    push $P108, ""
    push $P108, ""
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P124 = "25_1300051172.188" 
    capture_lex $P124
    .local string rx117_tgt
    .local int rx117_pos
    .local int rx117_off
    .local int rx117_eos
    .local int rx117_rep
    .local pmc rx117_cur
    .local pmc rx117_debug
    (rx117_cur, rx117_pos, rx117_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx117_cur
    .local pmc match
    .lex "$/", match
    length rx117_eos, rx117_tgt
    gt rx117_pos, rx117_eos, rx117_done
    set rx117_off, 0
    lt rx117_pos, 2, rx117_start
    sub rx117_off, rx117_pos, 1
    substr rx117_tgt, rx117_tgt, rx117_off
  rx117_start:
    eq $I10, 1, rx117_restart
    if_null rx117_debug, debug_458
    rx117_cur."!cursor_debug"("START", "unv")
  debug_458:
    $I10 = self.'from'()
    ne $I10, -1, rxscan120_done
    goto rxscan120_scan
  rxscan120_loop:
    (rx117_pos) = rx117_cur."from"()
    inc rx117_pos
    rx117_cur."!cursor_from"(rx117_pos)
    ge rx117_pos, rx117_eos, rxscan120_done
  rxscan120_scan:
    set_addr $I10, rxscan120_loop
    rx117_cur."!mark_push"(0, rx117_pos, $I10)
  rxscan120_done:
  alt121_0:
.annotate 'line', 71
    set_addr $I10, alt121_1
    rx117_cur."!mark_push"(0, rx117_pos, $I10)
.annotate 'line', 72
  # rxanchor bol
    eq rx117_pos, 0, rxanchor122_done
    ge rx117_pos, rx117_eos, rx117_fail
    sub $I10, rx117_pos, rx117_off
    dec $I10
    is_cclass $I11, 4096, rx117_tgt, $I10
    unless $I11, rx117_fail
  rxanchor122_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx117_cur."!cursor_pos"(rx117_pos)
    .const 'Sub' $P124 = "25_1300051172.188" 
    capture_lex $P124
    $P10 = rx117_cur."before"($P124)
    unless $P10, rx117_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx117_cur."!cursor_pos"(rx117_pos)
    $P10 = rx117_cur."pod_comment"()
    unless $P10, rx117_fail
    rx117_pos = $P10."pos"()
    goto alt121_end
  alt121_1:
    set_addr $I10, alt121_2
    rx117_cur."!mark_push"(0, rx117_pos, $I10)
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx117_pos, rx117_off
    set rx117_rep, 0
    sub $I12, rx117_eos, rx117_pos
  rxenumcharlistq129_loop:
    le $I12, 0, rxenumcharlistq129_done
    substr $S10, rx117_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq129_done
    inc rx117_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq129_loop
  rxenumcharlistq129_done:
    add rx117_pos, rx117_pos, rx117_rep
  # rx literal  "#"
    add $I11, rx117_pos, 1
    gt $I11, rx117_eos, rx117_fail
    sub $I11, rx117_pos, rx117_off
    ord $I11, rx117_tgt, $I11
    ne $I11, 35, rx117_fail
    add rx117_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx117_pos, rx117_off
    find_cclass $I11, 4096, rx117_tgt, $I10, rx117_eos
    add rx117_pos, rx117_off, $I11
    goto alt121_end
  alt121_2:
.annotate 'line', 74
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx117_pos, rx117_off
    set rx117_rep, 0
    sub $I12, rx117_eos, rx117_pos
  rxenumcharlistq130_loop:
    le $I12, 0, rxenumcharlistq130_done
    substr $S10, rx117_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq130_done
    inc rx117_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq130_loop
  rxenumcharlistq130_done:
    lt rx117_rep, 1, rx117_fail
    add rx117_pos, rx117_pos, rx117_rep
  alt121_end:
.annotate 'line', 69
  # rx pass
    rx117_cur."!cursor_pass"(rx117_pos, "unv")
    if_null rx117_debug, debug_463
    rx117_cur."!cursor_debug"("PASS", "unv", " at pos=", rx117_pos)
  debug_463:
    .return (rx117_cur)
  rx117_restart:
.annotate 'line', 4
    if_null rx117_debug, debug_464
    rx117_cur."!cursor_debug"("NEXT", "unv")
  debug_464:
  rx117_fail:
    (rx117_rep, rx117_pos, $I10, $P10) = rx117_cur."!mark_fail"(0)
    lt rx117_pos, -1, rx117_done
    eq rx117_pos, -1, rx117_fail
    jump $I10
  rx117_done:
    rx117_cur."!cursor_fail"()
    if_null rx117_debug, debug_465
    rx117_cur."!cursor_debug"("FAIL", "unv")
  debug_465:
    .return (rx117_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1300051172.188") :method
.annotate 'line', 4
    new $P119, "ResizablePMCArray"
    push $P119, ""
    push $P119, ""
    push $P119, ""
    .return ($P119)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block123"  :anon :subid("25_1300051172.188") :method :outer("23_1300051172.188")
.annotate 'line', 72
    .local string rx125_tgt
    .local int rx125_pos
    .local int rx125_off
    .local int rx125_eos
    .local int rx125_rep
    .local pmc rx125_cur
    .local pmc rx125_debug
    (rx125_cur, rx125_pos, rx125_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx125_cur
    .local pmc match
    .lex "$/", match
    length rx125_eos, rx125_tgt
    gt rx125_pos, rx125_eos, rx125_done
    set rx125_off, 0
    lt rx125_pos, 2, rx125_start
    sub rx125_off, rx125_pos, 1
    substr rx125_tgt, rx125_tgt, rx125_off
  rx125_start:
    eq $I10, 1, rx125_restart
    if_null rx125_debug, debug_459
    rx125_cur."!cursor_debug"("START", "")
  debug_459:
    $I10 = self.'from'()
    ne $I10, -1, rxscan126_done
    goto rxscan126_scan
  rxscan126_loop:
    (rx125_pos) = rx125_cur."from"()
    inc rx125_pos
    rx125_cur."!cursor_from"(rx125_pos)
    ge rx125_pos, rx125_eos, rxscan126_done
  rxscan126_scan:
    set_addr $I10, rxscan126_loop
    rx125_cur."!mark_push"(0, rx125_pos, $I10)
  rxscan126_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx125_pos, rx125_off
    set rx125_rep, 0
    sub $I12, rx125_eos, rx125_pos
  rxenumcharlistq127_loop:
    le $I12, 0, rxenumcharlistq127_done
    substr $S10, rx125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq127_done
    inc rx125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq127_loop
  rxenumcharlistq127_done:
    add rx125_pos, rx125_pos, rx125_rep
  # rx literal  "="
    add $I11, rx125_pos, 1
    gt $I11, rx125_eos, rx125_fail
    sub $I11, rx125_pos, rx125_off
    ord $I11, rx125_tgt, $I11
    ne $I11, 61, rx125_fail
    add rx125_pos, 1
  alt128_0:
    set_addr $I10, alt128_1
    rx125_cur."!mark_push"(0, rx125_pos, $I10)
  # rx charclass w
    ge rx125_pos, rx125_eos, rx125_fail
    sub $I10, rx125_pos, rx125_off
    is_cclass $I11, 8192, rx125_tgt, $I10
    unless $I11, rx125_fail
    inc rx125_pos
    goto alt128_end
  alt128_1:
  # rx literal  "\\"
    add $I11, rx125_pos, 1
    gt $I11, rx125_eos, rx125_fail
    sub $I11, rx125_pos, rx125_off
    ord $I11, rx125_tgt, $I11
    ne $I11, 92, rx125_fail
    add rx125_pos, 1
  alt128_end:
  # rx pass
    rx125_cur."!cursor_pass"(rx125_pos, "")
    if_null rx125_debug, debug_460
    rx125_cur."!cursor_debug"("PASS", "", " at pos=", rx125_pos)
  debug_460:
    .return (rx125_cur)
  rx125_restart:
    if_null rx125_debug, debug_461
    rx125_cur."!cursor_debug"("NEXT", "")
  debug_461:
  rx125_fail:
    (rx125_rep, rx125_pos, $I10, $P10) = rx125_cur."!mark_fail"(0)
    lt rx125_pos, -1, rx125_done
    eq rx125_pos, -1, rx125_fail
    jump $I10
  rx125_done:
    rx125_cur."!cursor_fail"()
    if_null rx125_debug, debug_462
    rx125_cur."!cursor_debug"("FAIL", "")
  debug_462:
    .return (rx125_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P163 = "28_1300051172.188" 
    capture_lex $P163
    .local string rx132_tgt
    .local int rx132_pos
    .local int rx132_off
    .local int rx132_eos
    .local int rx132_rep
    .local pmc rx132_cur
    .local pmc rx132_debug
    (rx132_cur, rx132_pos, rx132_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx132_cur
    .local pmc match
    .lex "$/", match
    length rx132_eos, rx132_tgt
    gt rx132_pos, rx132_eos, rx132_done
    set rx132_off, 0
    lt rx132_pos, 2, rx132_start
    sub rx132_off, rx132_pos, 1
    substr rx132_tgt, rx132_tgt, rx132_off
  rx132_start:
    eq $I10, 1, rx132_restart
    if_null rx132_debug, debug_466
    rx132_cur."!cursor_debug"("START", "pod_comment")
  debug_466:
    $I10 = self.'from'()
    ne $I10, -1, rxscan135_done
    goto rxscan135_scan
  rxscan135_loop:
    (rx132_pos) = rx132_cur."from"()
    inc rx132_pos
    rx132_cur."!cursor_from"(rx132_pos)
    ge rx132_pos, rx132_eos, rxscan135_done
  rxscan135_scan:
    set_addr $I10, rxscan135_loop
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
  rxscan135_done:
.annotate 'line', 79
  # rxanchor bol
    eq rx132_pos, 0, rxanchor136_done
    ge rx132_pos, rx132_eos, rx132_fail
    sub $I10, rx132_pos, rx132_off
    dec $I10
    is_cclass $I11, 4096, rx132_tgt, $I10
    unless $I11, rx132_fail
  rxanchor136_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq137_loop:
    le $I12, 0, rxenumcharlistq137_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq137_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq137_loop
  rxenumcharlistq137_done:
    add rx132_pos, rx132_pos, rx132_rep
  # rx literal  "="
    add $I11, rx132_pos, 1
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    ord $I11, rx132_tgt, $I11
    ne $I11, 61, rx132_fail
    add rx132_pos, 1
  alt138_0:
.annotate 'line', 80
    set_addr $I10, alt138_1
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
.annotate 'line', 81
  # rx literal  "begin"
    add $I11, rx132_pos, 5
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 5
    ne $S10, "begin", rx132_fail
    add rx132_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq139_loop:
    le $I12, 0, rxenumcharlistq139_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq139_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq139_loop
  rxenumcharlistq139_done:
    lt rx132_rep, 1, rx132_fail
    add rx132_pos, rx132_pos, rx132_rep
  # rx literal  "END"
    add $I11, rx132_pos, 3
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 3
    ne $S10, "END", rx132_fail
    add rx132_pos, 3
  # rxanchor rwb
    le rx132_pos, 0, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 8192, rx132_tgt, $I10
    if $I11, rx132_fail
    dec $I10
    is_cclass $I11, 8192, rx132_tgt, $I10
    unless $I11, rx132_fail
  alt140_0:
.annotate 'line', 82
    set_addr $I10, alt140_1
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
  # rx rxquantf141 ** 0..*
    set_addr $I10, rxquantf141_loop
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
    goto rxquantf141_done
  rxquantf141_loop:
  # rx charclass .
    ge rx132_pos, rx132_eos, rx132_fail
    inc rx132_pos
    set_addr $I10, rxquantf141_loop
    rx132_cur."!mark_push"(rx132_rep, rx132_pos, $I10)
  rxquantf141_done:
  # rx charclass nl
    ge rx132_pos, rx132_eos, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 4096, rx132_tgt, $I10
    unless $I11, rx132_fail
    substr $S10, rx132_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx132_pos, $I11
    inc rx132_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx132_pos, rx132_pos, rx132_rep
  # rx literal  "=end"
    add $I11, rx132_pos, 4
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 4
    ne $S10, "=end", rx132_fail
    add rx132_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq144_loop:
    le $I12, 0, rxenumcharlistq144_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq144_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq144_loop
  rxenumcharlistq144_done:
    lt rx132_rep, 1, rx132_fail
    add rx132_pos, rx132_pos, rx132_rep
  # rx literal  "END"
    add $I11, rx132_pos, 3
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 3
    ne $S10, "END", rx132_fail
    add rx132_pos, 3
  # rxanchor rwb
    le rx132_pos, 0, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 8192, rx132_tgt, $I10
    if $I11, rx132_fail
    dec $I10
    is_cclass $I11, 8192, rx132_tgt, $I10
    unless $I11, rx132_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx132_pos, rx132_off
    find_cclass $I11, 4096, rx132_tgt, $I10, rx132_eos
    add rx132_pos, rx132_off, $I11
    goto alt140_end
  alt140_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx132_pos, rx132_off
    find_not_cclass $I11, 65535, rx132_tgt, $I10, rx132_eos
    add rx132_pos, rx132_off, $I11
  alt140_end:
.annotate 'line', 81
    goto alt138_end
  alt138_1:
    set_addr $I10, alt138_2
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
.annotate 'line', 83
  # rx literal  "begin"
    add $I11, rx132_pos, 5
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 5
    ne $S10, "begin", rx132_fail
    add rx132_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq145_loop:
    le $I12, 0, rxenumcharlistq145_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq145_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq145_loop
  rxenumcharlistq145_done:
    lt rx132_rep, 1, rx132_fail
    add rx132_pos, rx132_pos, rx132_rep
  # rx subrule "identifier" subtype=capture negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    $P10 = rx132_cur."identifier"()
    unless $P10, rx132_fail
    rx132_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx132_pos = $P10."pos"()
  alt146_0:
.annotate 'line', 84
    set_addr $I10, alt146_1
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
.annotate 'line', 85
  # rx rxquantf147 ** 0..*
    set_addr $I10, rxquantf147_loop
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
    goto rxquantf147_done
  rxquantf147_loop:
  # rx charclass .
    ge rx132_pos, rx132_eos, rx132_fail
    inc rx132_pos
    set_addr $I10, rxquantf147_loop
    rx132_cur."!mark_push"(rx132_rep, rx132_pos, $I10)
  rxquantf147_done:
  # rx charclass nl
    ge rx132_pos, rx132_eos, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 4096, rx132_tgt, $I10
    unless $I11, rx132_fail
    substr $S10, rx132_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx132_pos, $I11
    inc rx132_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    add rx132_pos, rx132_pos, rx132_rep
  # rx literal  "=end"
    add $I11, rx132_pos, 4
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 4
    ne $S10, "=end", rx132_fail
    add rx132_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq150_loop:
    le $I12, 0, rxenumcharlistq150_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq150_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq150_loop
  rxenumcharlistq150_done:
    lt rx132_rep, 1, rx132_fail
    add rx132_pos, rx132_pos, rx132_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    $P10 = rx132_cur."!BACKREF"("identifier")
    unless $P10, rx132_fail
    rx132_pos = $P10."pos"()
  # rxanchor rwb
    le rx132_pos, 0, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 8192, rx132_tgt, $I10
    if $I11, rx132_fail
    dec $I10
    is_cclass $I11, 8192, rx132_tgt, $I10
    unless $I11, rx132_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx132_pos, rx132_off
    find_cclass $I11, 4096, rx132_tgt, $I10, rx132_eos
    add rx132_pos, rx132_off, $I11
    goto alt146_end
  alt146_1:
.annotate 'line', 86
  # rx subrule "panic" subtype=method negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    $P10 = rx132_cur."panic"("=begin without matching =end")
    unless $P10, rx132_fail
    rx132_pos = $P10."pos"()
  alt146_end:
.annotate 'line', 83
    goto alt138_end
  alt138_2:
    set_addr $I10, alt138_3
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
.annotate 'line', 88
  # rx literal  "begin"
    add $I11, rx132_pos, 5
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 5
    ne $S10, "begin", rx132_fail
    add rx132_pos, 5
  # rxanchor rwb
    le rx132_pos, 0, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 8192, rx132_tgt, $I10
    if $I11, rx132_fail
    dec $I10
    is_cclass $I11, 8192, rx132_tgt, $I10
    unless $I11, rx132_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq152_loop:
    le $I12, 0, rxenumcharlistq152_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq152_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq152_loop
  rxenumcharlistq152_done:
    add rx132_pos, rx132_pos, rx132_rep
  alt153_0:
.annotate 'line', 89
    set_addr $I10, alt153_1
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
  # rxanchor eol
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 4096, rx132_tgt, $I10
    if $I11, rxanchor154_done
    ne rx132_pos, rx132_eos, rx132_fail
    eq rx132_pos, 0, rxanchor154_done
    dec $I10
    is_cclass $I11, 4096, rx132_tgt, $I10
    if $I11, rx132_fail
  rxanchor154_done:
    goto alt153_end
  alt153_1:
    set_addr $I10, alt153_2
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
  # rx literal  "#"
    add $I11, rx132_pos, 1
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    ord $I11, rx132_tgt, $I11
    ne $I11, 35, rx132_fail
    add rx132_pos, 1
    goto alt153_end
  alt153_2:
  # rx subrule "panic" subtype=method negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    $P10 = rx132_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx132_fail
    rx132_pos = $P10."pos"()
  alt153_end:
  alt155_0:
.annotate 'line', 90
    set_addr $I10, alt155_1
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
.annotate 'line', 91
  # rx rxquantf156 ** 0..*
    set_addr $I10, rxquantf156_loop
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
    goto rxquantf156_done
  rxquantf156_loop:
  # rx charclass .
    ge rx132_pos, rx132_eos, rx132_fail
    inc rx132_pos
    set_addr $I10, rxquantf156_loop
    rx132_cur."!mark_push"(rx132_rep, rx132_pos, $I10)
  rxquantf156_done:
  # rx charclass nl
    ge rx132_pos, rx132_eos, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 4096, rx132_tgt, $I10
    unless $I11, rx132_fail
    substr $S10, rx132_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx132_pos, $I11
    inc rx132_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx132_pos, rx132_off
    set rx132_rep, 0
    sub $I12, rx132_eos, rx132_pos
  rxenumcharlistq158_loop:
    le $I12, 0, rxenumcharlistq158_done
    substr $S10, rx132_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq158_done
    inc rx132_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq158_loop
  rxenumcharlistq158_done:
    add rx132_pos, rx132_pos, rx132_rep
  # rx literal  "=end"
    add $I11, rx132_pos, 4
    gt $I11, rx132_eos, rx132_fail
    sub $I11, rx132_pos, rx132_off
    substr $S10, rx132_tgt, $I11, 4
    ne $S10, "=end", rx132_fail
    add rx132_pos, 4
  # rxanchor rwb
    le rx132_pos, 0, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 8192, rx132_tgt, $I10
    if $I11, rx132_fail
    dec $I10
    is_cclass $I11, 8192, rx132_tgt, $I10
    unless $I11, rx132_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx132_pos, rx132_off
    find_cclass $I11, 4096, rx132_tgt, $I10, rx132_eos
    add rx132_pos, rx132_off, $I11
    goto alt155_end
  alt155_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    $P10 = rx132_cur."panic"("=begin without matching =end")
    unless $P10, rx132_fail
    rx132_pos = $P10."pos"()
  alt155_end:
.annotate 'line', 88
    goto alt138_end
  alt138_3:
    set_addr $I10, alt138_4
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
.annotate 'line', 94
  # rx subrule "identifier" subtype=capture negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    $P10 = rx132_cur."identifier"()
    unless $P10, rx132_fail
    rx132_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx132_pos = $P10."pos"()
.annotate 'line', 95
  # rx rxquantf159 ** 0..*
    set_addr $I10, rxquantf159_loop
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
    goto rxquantf159_done
  rxquantf159_loop:
  # rx charclass .
    ge rx132_pos, rx132_eos, rx132_fail
    inc rx132_pos
    set_addr $I10, rxquantf159_loop
    rx132_cur."!mark_push"(rx132_rep, rx132_pos, $I10)
  rxquantf159_done:
  # rxanchor bol
    eq rx132_pos, 0, rxanchor161_done
    ge rx132_pos, rx132_eos, rx132_fail
    sub $I10, rx132_pos, rx132_off
    dec $I10
    is_cclass $I11, 4096, rx132_tgt, $I10
    unless $I11, rx132_fail
  rxanchor161_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    .const 'Sub' $P163 = "28_1300051172.188" 
    capture_lex $P163
    $P10 = rx132_cur."before"($P163)
    unless $P10, rx132_fail
.annotate 'line', 94
    goto alt138_end
  alt138_4:
  alt169_0:
.annotate 'line', 101
    set_addr $I10, alt169_1
    rx132_cur."!mark_push"(0, rx132_pos, $I10)
  # rx charclass s
    ge rx132_pos, rx132_eos, rx132_fail
    sub $I10, rx132_pos, rx132_off
    is_cclass $I11, 32, rx132_tgt, $I10
    unless $I11, rx132_fail
    inc rx132_pos
    goto alt169_end
  alt169_1:
  # rx subrule "panic" subtype=method negate=
    rx132_cur."!cursor_pos"(rx132_pos)
    $P10 = rx132_cur."panic"("Illegal pod directive")
    unless $P10, rx132_fail
    rx132_pos = $P10."pos"()
  alt169_end:
.annotate 'line', 102
  # rx charclass_q N r 0..-1
    sub $I10, rx132_pos, rx132_off
    find_cclass $I11, 4096, rx132_tgt, $I10, rx132_eos
    add rx132_pos, rx132_off, $I11
  alt138_end:
.annotate 'line', 78
  # rx pass
    rx132_cur."!cursor_pass"(rx132_pos, "pod_comment")
    if_null rx132_debug, debug_471
    rx132_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx132_pos)
  debug_471:
    .return (rx132_cur)
  rx132_restart:
.annotate 'line', 4
    if_null rx132_debug, debug_472
    rx132_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_472:
  rx132_fail:
    (rx132_rep, rx132_pos, $I10, $P10) = rx132_cur."!mark_fail"(0)
    lt rx132_pos, -1, rx132_done
    eq rx132_pos, -1, rx132_fail
    jump $I10
  rx132_done:
    rx132_cur."!cursor_fail"()
    if_null rx132_debug, debug_473
    rx132_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_473:
    .return (rx132_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1300051172.188") :method
.annotate 'line', 4
    new $P134, "ResizablePMCArray"
    push $P134, ""
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block162"  :anon :subid("28_1300051172.188") :method :outer("26_1300051172.188")
.annotate 'line', 95
    .local string rx164_tgt
    .local int rx164_pos
    .local int rx164_off
    .local int rx164_eos
    .local int rx164_rep
    .local pmc rx164_cur
    .local pmc rx164_debug
    (rx164_cur, rx164_pos, rx164_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx164_cur
    .local pmc match
    .lex "$/", match
    length rx164_eos, rx164_tgt
    gt rx164_pos, rx164_eos, rx164_done
    set rx164_off, 0
    lt rx164_pos, 2, rx164_start
    sub rx164_off, rx164_pos, 1
    substr rx164_tgt, rx164_tgt, rx164_off
  rx164_start:
    eq $I10, 1, rx164_restart
    if_null rx164_debug, debug_467
    rx164_cur."!cursor_debug"("START", "")
  debug_467:
    $I10 = self.'from'()
    ne $I10, -1, rxscan165_done
    goto rxscan165_scan
  rxscan165_loop:
    (rx164_pos) = rx164_cur."from"()
    inc rx164_pos
    rx164_cur."!cursor_from"(rx164_pos)
    ge rx164_pos, rx164_eos, rxscan165_done
  rxscan165_scan:
    set_addr $I10, rxscan165_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  rxscan165_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq166_loop:
    le $I12, 0, rxenumcharlistq166_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq166_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq166_loop
  rxenumcharlistq166_done:
    add rx164_pos, rx164_pos, rx164_rep
  alt167_0:
    set_addr $I10, alt167_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 96
  # rx literal  "="
    add $I11, rx164_pos, 1
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    ord $I11, rx164_tgt, $I11
    ne $I11, 61, rx164_fail
    add rx164_pos, 1
.annotate 'line', 98
  # rx rxquantr168 ** 0..1
    set_addr $I10, rxquantr168_done
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  rxquantr168_loop:
.annotate 'line', 97
  # rx literal  "cut"
    add $I11, rx164_pos, 3
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 3
    ne $S10, "cut", rx164_fail
    add rx164_pos, 3
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
    set_addr $I10, rxquantr168_done
    (rx164_rep) = rx164_cur."!mark_commit"($I10)
  rxquantr168_done:
.annotate 'line', 95
    goto alt167_end
  alt167_1:
.annotate 'line', 99
  # rx charclass nl
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
    substr $S10, rx164_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx164_pos, $I11
    inc rx164_pos
  alt167_end:
.annotate 'line', 95
  # rx pass
    rx164_cur."!cursor_pass"(rx164_pos, "")
    if_null rx164_debug, debug_468
    rx164_cur."!cursor_debug"("PASS", "", " at pos=", rx164_pos)
  debug_468:
    .return (rx164_cur)
  rx164_restart:
    if_null rx164_debug, debug_469
    rx164_cur."!cursor_debug"("NEXT", "")
  debug_469:
  rx164_fail:
    (rx164_rep, rx164_pos, $I10, $P10) = rx164_cur."!mark_fail"(0)
    lt rx164_pos, -1, rx164_done
    eq rx164_pos, -1, rx164_fail
    jump $I10
  rx164_done:
    rx164_cur."!cursor_fail"()
    if_null rx164_debug, debug_470
    rx164_cur."!cursor_debug"("FAIL", "")
  debug_470:
    .return (rx164_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 110
    new $P171, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P171
.annotate 'line', 4
    .local string rx172_tgt
    .local int rx172_pos
    .local int rx172_off
    .local int rx172_eos
    .local int rx172_rep
    .local pmc rx172_cur
    .local pmc rx172_debug
    (rx172_cur, rx172_pos, rx172_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx172_cur
    .local pmc match
    .lex "$/", match
    length rx172_eos, rx172_tgt
    gt rx172_pos, rx172_eos, rx172_done
    set rx172_off, 0
    lt rx172_pos, 2, rx172_start
    sub rx172_off, rx172_pos, 1
    substr rx172_tgt, rx172_tgt, rx172_off
  rx172_start:
    eq $I10, 1, rx172_restart
    if_null rx172_debug, debug_474
    rx172_cur."!cursor_debug"("START", "comp_unit")
  debug_474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan176_done
    goto rxscan176_scan
  rxscan176_loop:
    (rx172_pos) = rx172_cur."from"()
    inc rx172_pos
    rx172_cur."!cursor_from"(rx172_pos)
    ge rx172_pos, rx172_eos, rxscan176_done
  rxscan176_scan:
    set_addr $I10, rxscan176_loop
    rx172_cur."!mark_push"(0, rx172_pos, $I10)
  rxscan176_done:
.annotate 'line', 110
    rx172_cur."!cursor_pos"(rx172_pos)
    new $P177, "Integer"
    assign $P177, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P177
.annotate 'line', 111
  # rx subrule "newpad" subtype=method negate=
    rx172_cur."!cursor_pos"(rx172_pos)
    $P10 = rx172_cur."newpad"()
    unless $P10, rx172_fail
    rx172_pos = $P10."pos"()
.annotate 'line', 112
  # rx subrule "outerctx" subtype=method negate=
    rx172_cur."!cursor_pos"(rx172_pos)
    $P10 = rx172_cur."outerctx"()
    unless $P10, rx172_fail
    rx172_pos = $P10."pos"()
.annotate 'line', 113
  # rx subrule "statementlist" subtype=capture negate=
    rx172_cur."!cursor_pos"(rx172_pos)
    $P10 = rx172_cur."statementlist"()
    unless $P10, rx172_fail
    rx172_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx172_pos = $P10."pos"()
  alt178_0:
.annotate 'line', 114
    set_addr $I10, alt178_1
    rx172_cur."!mark_push"(0, rx172_pos, $I10)
  # rxanchor eos
    ne rx172_pos, rx172_eos, rx172_fail
    goto alt178_end
  alt178_1:
  # rx subrule "panic" subtype=method negate=
    rx172_cur."!cursor_pos"(rx172_pos)
    $P10 = rx172_cur."panic"("Confused")
    unless $P10, rx172_fail
    rx172_pos = $P10."pos"()
  alt178_end:
.annotate 'line', 109
  # rx pass
    rx172_cur."!cursor_pass"(rx172_pos, "comp_unit")
    if_null rx172_debug, debug_475
    rx172_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx172_pos)
  debug_475:
    .return (rx172_cur)
  rx172_restart:
.annotate 'line', 4
    if_null rx172_debug, debug_476
    rx172_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_476:
  rx172_fail:
    (rx172_rep, rx172_pos, $I10, $P10) = rx172_cur."!mark_fail"(0)
    lt rx172_pos, -1, rx172_done
    eq rx172_pos, -1, rx172_fail
    jump $I10
  rx172_done:
    rx172_cur."!cursor_fail"()
    if_null rx172_debug, debug_477
    rx172_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_477:
    .return (rx172_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1300051172.188") :method
.annotate 'line', 4
    $P174 = self."!PREFIX__!subrule"("newpad", "")
    new $P175, "ResizablePMCArray"
    push $P175, $P174
    .return ($P175)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx180_tgt
    .local int rx180_pos
    .local int rx180_off
    .local int rx180_eos
    .local int rx180_rep
    .local pmc rx180_cur
    .local pmc rx180_debug
    (rx180_cur, rx180_pos, rx180_tgt, $I10) = self."!cursor_start"()
    rx180_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx180_cur
    .local pmc match
    .lex "$/", match
    length rx180_eos, rx180_tgt
    gt rx180_pos, rx180_eos, rx180_done
    set rx180_off, 0
    lt rx180_pos, 2, rx180_start
    sub rx180_off, rx180_pos, 1
    substr rx180_tgt, rx180_tgt, rx180_off
  rx180_start:
    eq $I10, 1, rx180_restart
    if_null rx180_debug, debug_478
    rx180_cur."!cursor_debug"("START", "statementlist")
  debug_478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan185_done
    goto rxscan185_scan
  rxscan185_loop:
    (rx180_pos) = rx180_cur."from"()
    inc rx180_pos
    rx180_cur."!cursor_from"(rx180_pos)
    ge rx180_pos, rx180_eos, rxscan185_done
  rxscan185_scan:
    set_addr $I10, rxscan185_loop
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxscan185_done:
  alt186_0:
.annotate 'line', 117
    set_addr $I10, alt186_1
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
.annotate 'line', 118
  # rx subrule "ws" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ws"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
  # rxanchor eos
    ne rx180_pos, rx180_eos, rx180_fail
  # rx subrule "ws" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ws"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
    goto alt186_end
  alt186_1:
.annotate 'line', 119
  # rx subrule "ws" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ws"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
  # rx rxquantr190 ** 0..*
    set_addr $I10, rxquantr190_done
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxquantr190_loop:
  # rx subrule "statement" subtype=capture negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."statement"()
    unless $P10, rx180_fail
    rx180_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx180_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."eat_terminator"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ws"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
    set_addr $I10, rxquantr190_done
    (rx180_rep) = rx180_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr190_done
    rx180_cur."!mark_push"(rx180_rep, rx180_pos, $I10)
    goto rxquantr190_loop
  rxquantr190_done:
  # rx subrule "ws" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ws"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
  alt186_end:
.annotate 'line', 117
  # rx pass
    rx180_cur."!cursor_pass"(rx180_pos, "statementlist")
    if_null rx180_debug, debug_479
    rx180_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx180_pos)
  debug_479:
    .return (rx180_cur)
  rx180_restart:
.annotate 'line', 4
    if_null rx180_debug, debug_480
    rx180_cur."!cursor_debug"("NEXT", "statementlist")
  debug_480:
  rx180_fail:
    (rx180_rep, rx180_pos, $I10, $P10) = rx180_cur."!mark_fail"(0)
    lt rx180_pos, -1, rx180_done
    eq rx180_pos, -1, rx180_fail
    jump $I10
  rx180_done:
    rx180_cur."!cursor_fail"()
    if_null rx180_debug, debug_481
    rx180_cur."!cursor_debug"("FAIL", "statementlist")
  debug_481:
    .return (rx180_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1300051172.188") :method
.annotate 'line', 4
    $P182 = self."!PREFIX__!subrule"("ws", "")
    $P183 = self."!PREFIX__!subrule"("ws", "")
    new $P184, "ResizablePMCArray"
    push $P184, $P182
    push $P184, $P183
    .return ($P184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P199 = "35_1300051172.188" 
    capture_lex $P199
    .local string rx194_tgt
    .local int rx194_pos
    .local int rx194_off
    .local int rx194_eos
    .local int rx194_rep
    .local pmc rx194_cur
    .local pmc rx194_debug
    (rx194_cur, rx194_pos, rx194_tgt, $I10) = self."!cursor_start"()
    rx194_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx194_cur
    .local pmc match
    .lex "$/", match
    length rx194_eos, rx194_tgt
    gt rx194_pos, rx194_eos, rx194_done
    set rx194_off, 0
    lt rx194_pos, 2, rx194_start
    sub rx194_off, rx194_pos, 1
    substr rx194_tgt, rx194_tgt, rx194_off
  rx194_start:
    eq $I10, 1, rx194_restart
    if_null rx194_debug, debug_482
    rx194_cur."!cursor_debug"("START", "statement")
  debug_482:
    $I10 = self.'from'()
    ne $I10, -1, rxscan197_done
    goto rxscan197_scan
  rxscan197_loop:
    (rx194_pos) = rx194_cur."from"()
    inc rx194_pos
    rx194_cur."!cursor_from"(rx194_pos)
    ge rx194_pos, rx194_eos, rxscan197_done
  rxscan197_scan:
    set_addr $I10, rxscan197_loop
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxscan197_done:
.annotate 'line', 123
  # rx subrule "before" subtype=zerowidth negate=1
    rx194_cur."!cursor_pos"(rx194_pos)
    .const 'Sub' $P199 = "35_1300051172.188" 
    capture_lex $P199
    $P10 = rx194_cur."before"($P199)
    if $P10, rx194_fail
  alt203_0:
.annotate 'line', 124
    set_addr $I10, alt203_1
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
.annotate 'line', 125
  # rx subrule "statement_control" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."statement_control"()
    unless $P10, rx194_fail
    rx194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx194_pos = $P10."pos"()
    goto alt203_end
  alt203_1:
.annotate 'line', 126
  # rx subrule "EXPR" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."EXPR"()
    unless $P10, rx194_fail
    rx194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx194_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."ws"()
    unless $P10, rx194_fail
    rx194_pos = $P10."pos"()
.annotate 'line', 131
  # rx rxquantr204 ** 0..1
    set_addr $I10, rxquantr204_done
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxquantr204_loop:
  alt205_0:
.annotate 'line', 127
    set_addr $I10, alt205_1
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
.annotate 'line', 128
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."MARKED"("endstmt")
    unless $P10, rx194_fail
    goto alt205_end
  alt205_1:
    set_addr $I10, alt205_2
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
.annotate 'line', 129
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."statement_mod_cond"()
    unless $P10, rx194_fail
    rx194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx194_pos = $P10."pos"()
  # rx rxquantr206 ** 0..1
    set_addr $I10, rxquantr206_done
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxquantr206_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."statement_mod_loop"()
    unless $P10, rx194_fail
    goto rxsubrule207_pass
  rxsubrule207_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx194_fail
  rxsubrule207_pass:
    set_addr $I10, rxsubrule207_back
    rx194_cur."!mark_push"(0, rx194_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx194_pos = $P10."pos"()
    set_addr $I10, rxquantr206_done
    (rx194_rep) = rx194_cur."!mark_commit"($I10)
  rxquantr206_done:
    goto alt205_end
  alt205_2:
.annotate 'line', 130
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."statement_mod_loop"()
    unless $P10, rx194_fail
    rx194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx194_pos = $P10."pos"()
  alt205_end:
.annotate 'line', 131
    set_addr $I10, rxquantr204_done
    (rx194_rep) = rx194_cur."!mark_commit"($I10)
  rxquantr204_done:
  alt203_end:
.annotate 'line', 122
  # rx pass
    rx194_cur."!cursor_pass"(rx194_pos, "statement")
    if_null rx194_debug, debug_487
    rx194_cur."!cursor_debug"("PASS", "statement", " at pos=", rx194_pos)
  debug_487:
    .return (rx194_cur)
  rx194_restart:
.annotate 'line', 4
    if_null rx194_debug, debug_488
    rx194_cur."!cursor_debug"("NEXT", "statement")
  debug_488:
  rx194_fail:
    (rx194_rep, rx194_pos, $I10, $P10) = rx194_cur."!mark_fail"(0)
    lt rx194_pos, -1, rx194_done
    eq rx194_pos, -1, rx194_fail
    jump $I10
  rx194_done:
    rx194_cur."!cursor_fail"()
    if_null rx194_debug, debug_489
    rx194_cur."!cursor_debug"("FAIL", "statement")
  debug_489:
    .return (rx194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1300051172.188") :method
.annotate 'line', 4
    new $P196, "ResizablePMCArray"
    push $P196, ""
    .return ($P196)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block198"  :anon :subid("35_1300051172.188") :method :outer("33_1300051172.188")
.annotate 'line', 123
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_483
    rx200_cur."!cursor_debug"("START", "")
  debug_483:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan201_done:
  alt202_0:
    set_addr $I10, alt202_1
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx200_pos, rx200_eos, rx200_fail
    sub $I10, rx200_pos, rx200_off
    substr $S10, rx200_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx200_fail
    inc rx200_pos
    goto alt202_end
  alt202_1:
  # rxanchor eos
    ne rx200_pos, rx200_eos, rx200_fail
  alt202_end:
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "")
    if_null rx200_debug, debug_484
    rx200_cur."!cursor_debug"("PASS", "", " at pos=", rx200_pos)
  debug_484:
    .return (rx200_cur)
  rx200_restart:
    if_null rx200_debug, debug_485
    rx200_cur."!cursor_debug"("NEXT", "")
  debug_485:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_486
    rx200_cur."!cursor_debug"("FAIL", "")
  debug_486:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx209_tgt
    .local int rx209_pos
    .local int rx209_off
    .local int rx209_eos
    .local int rx209_rep
    .local pmc rx209_cur
    .local pmc rx209_debug
    (rx209_cur, rx209_pos, rx209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx209_cur
    .local pmc match
    .lex "$/", match
    length rx209_eos, rx209_tgt
    gt rx209_pos, rx209_eos, rx209_done
    set rx209_off, 0
    lt rx209_pos, 2, rx209_start
    sub rx209_off, rx209_pos, 1
    substr rx209_tgt, rx209_tgt, rx209_off
  rx209_start:
    eq $I10, 1, rx209_restart
    if_null rx209_debug, debug_490
    rx209_cur."!cursor_debug"("START", "eat_terminator")
  debug_490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan212_done
    goto rxscan212_scan
  rxscan212_loop:
    (rx209_pos) = rx209_cur."from"()
    inc rx209_pos
    rx209_cur."!cursor_from"(rx209_pos)
    ge rx209_pos, rx209_eos, rxscan212_done
  rxscan212_scan:
    set_addr $I10, rxscan212_loop
    rx209_cur."!mark_push"(0, rx209_pos, $I10)
  rxscan212_done:
  alt213_0:
.annotate 'line', 135
    set_addr $I10, alt213_1
    rx209_cur."!mark_push"(0, rx209_pos, $I10)
.annotate 'line', 136
  # rx literal  ";"
    add $I11, rx209_pos, 1
    gt $I11, rx209_eos, rx209_fail
    sub $I11, rx209_pos, rx209_off
    ord $I11, rx209_tgt, $I11
    ne $I11, 59, rx209_fail
    add rx209_pos, 1
    goto alt213_end
  alt213_1:
    set_addr $I10, alt213_2
    rx209_cur."!mark_push"(0, rx209_pos, $I10)
.annotate 'line', 137
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx209_cur."!cursor_pos"(rx209_pos)
    $P10 = rx209_cur."MARKED"("endstmt")
    unless $P10, rx209_fail
    goto alt213_end
  alt213_2:
    set_addr $I10, alt213_3
    rx209_cur."!mark_push"(0, rx209_pos, $I10)
.annotate 'line', 138
  # rx subrule "terminator" subtype=zerowidth negate=
    rx209_cur."!cursor_pos"(rx209_pos)
    $P10 = rx209_cur."terminator"()
    unless $P10, rx209_fail
    goto alt213_end
  alt213_3:
.annotate 'line', 139
  # rxanchor eos
    ne rx209_pos, rx209_eos, rx209_fail
  alt213_end:
.annotate 'line', 135
  # rx pass
    rx209_cur."!cursor_pass"(rx209_pos, "eat_terminator")
    if_null rx209_debug, debug_491
    rx209_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx209_pos)
  debug_491:
    .return (rx209_cur)
  rx209_restart:
.annotate 'line', 4
    if_null rx209_debug, debug_492
    rx209_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_492:
  rx209_fail:
    (rx209_rep, rx209_pos, $I10, $P10) = rx209_cur."!mark_fail"(0)
    lt rx209_pos, -1, rx209_done
    eq rx209_pos, -1, rx209_fail
    jump $I10
  rx209_done:
    rx209_cur."!cursor_fail"()
    if_null rx209_debug, debug_493
    rx209_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_493:
    .return (rx209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1300051172.188") :method
.annotate 'line', 4
    new $P211, "ResizablePMCArray"
    push $P211, ""
    push $P211, ""
    push $P211, ""
    push $P211, ";"
    .return ($P211)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx215_tgt
    .local int rx215_pos
    .local int rx215_off
    .local int rx215_eos
    .local int rx215_rep
    .local pmc rx215_cur
    .local pmc rx215_debug
    (rx215_cur, rx215_pos, rx215_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx215_cur
    .local pmc match
    .lex "$/", match
    length rx215_eos, rx215_tgt
    gt rx215_pos, rx215_eos, rx215_done
    set rx215_off, 0
    lt rx215_pos, 2, rx215_start
    sub rx215_off, rx215_pos, 1
    substr rx215_tgt, rx215_tgt, rx215_off
  rx215_start:
    eq $I10, 1, rx215_restart
    if_null rx215_debug, debug_494
    rx215_cur."!cursor_debug"("START", "xblock")
  debug_494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan219_done
    goto rxscan219_scan
  rxscan219_loop:
    (rx215_pos) = rx215_cur."from"()
    inc rx215_pos
    rx215_cur."!cursor_from"(rx215_pos)
    ge rx215_pos, rx215_eos, rxscan219_done
  rxscan219_scan:
    set_addr $I10, rxscan219_loop
    rx215_cur."!mark_push"(0, rx215_pos, $I10)
  rxscan219_done:
.annotate 'line', 143
  # rx subrule "EXPR" subtype=capture negate=
    rx215_cur."!cursor_pos"(rx215_pos)
    $P10 = rx215_cur."EXPR"()
    unless $P10, rx215_fail
    rx215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx215_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx215_cur."!cursor_pos"(rx215_pos)
    $P10 = rx215_cur."ws"()
    unless $P10, rx215_fail
    rx215_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx215_cur."!cursor_pos"(rx215_pos)
    $P10 = rx215_cur."pblock"()
    unless $P10, rx215_fail
    rx215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx215_pos = $P10."pos"()
.annotate 'line', 142
  # rx pass
    rx215_cur."!cursor_pass"(rx215_pos, "xblock")
    if_null rx215_debug, debug_495
    rx215_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx215_pos)
  debug_495:
    .return (rx215_cur)
  rx215_restart:
.annotate 'line', 4
    if_null rx215_debug, debug_496
    rx215_cur."!cursor_debug"("NEXT", "xblock")
  debug_496:
  rx215_fail:
    (rx215_rep, rx215_pos, $I10, $P10) = rx215_cur."!mark_fail"(0)
    lt rx215_pos, -1, rx215_done
    eq rx215_pos, -1, rx215_fail
    jump $I10
  rx215_done:
    rx215_cur."!cursor_fail"()
    if_null rx215_debug, debug_497
    rx215_cur."!cursor_debug"("FAIL", "xblock")
  debug_497:
    .return (rx215_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1300051172.188") :method
.annotate 'line', 4
    $P217 = self."!PREFIX__!subrule"("EXPR", "")
    new $P218, "ResizablePMCArray"
    push $P218, $P217
    .return ($P218)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx221_tgt
    .local int rx221_pos
    .local int rx221_off
    .local int rx221_eos
    .local int rx221_rep
    .local pmc rx221_cur
    .local pmc rx221_debug
    (rx221_cur, rx221_pos, rx221_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx221_cur
    .local pmc match
    .lex "$/", match
    length rx221_eos, rx221_tgt
    gt rx221_pos, rx221_eos, rx221_done
    set rx221_off, 0
    lt rx221_pos, 2, rx221_start
    sub rx221_off, rx221_pos, 1
    substr rx221_tgt, rx221_tgt, rx221_off
  rx221_start:
    eq $I10, 1, rx221_restart
    if_null rx221_debug, debug_498
    rx221_cur."!cursor_debug"("START", "pblock")
  debug_498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan226_done
    goto rxscan226_scan
  rxscan226_loop:
    (rx221_pos) = rx221_cur."from"()
    inc rx221_pos
    rx221_cur."!cursor_from"(rx221_pos)
    ge rx221_pos, rx221_eos, rxscan226_done
  rxscan226_scan:
    set_addr $I10, rxscan226_loop
    rx221_cur."!mark_push"(0, rx221_pos, $I10)
  rxscan226_done:
  alt227_0:
.annotate 'line', 146
    set_addr $I10, alt227_1
    rx221_cur."!mark_push"(0, rx221_pos, $I10)
.annotate 'line', 147
  # rx subrule "lambda" subtype=method negate=
    rx221_cur."!cursor_pos"(rx221_pos)
    $P10 = rx221_cur."lambda"()
    unless $P10, rx221_fail
    rx221_pos = $P10."pos"()
.annotate 'line', 148
  # rx subrule "newpad" subtype=method negate=
    rx221_cur."!cursor_pos"(rx221_pos)
    $P10 = rx221_cur."newpad"()
    unless $P10, rx221_fail
    rx221_pos = $P10."pos"()
.annotate 'line', 149
  # rx subrule "signature" subtype=capture negate=
    rx221_cur."!cursor_pos"(rx221_pos)
    $P10 = rx221_cur."signature"()
    unless $P10, rx221_fail
    rx221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx221_pos = $P10."pos"()
.annotate 'line', 150
  # rx subrule "blockoid" subtype=capture negate=
    rx221_cur."!cursor_pos"(rx221_pos)
    $P10 = rx221_cur."blockoid"()
    unless $P10, rx221_fail
    rx221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx221_pos = $P10."pos"()
.annotate 'line', 147
    goto alt227_end
  alt227_1:
    set_addr $I10, alt227_2
    rx221_cur."!mark_push"(0, rx221_pos, $I10)
.annotate 'line', 151
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx221_pos, rx221_off
    substr $S10, rx221_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx221_fail
.annotate 'line', 152
  # rx subrule "newpad" subtype=method negate=
    rx221_cur."!cursor_pos"(rx221_pos)
    $P10 = rx221_cur."newpad"()
    unless $P10, rx221_fail
    rx221_pos = $P10."pos"()
.annotate 'line', 153
  # rx subrule "blockoid" subtype=capture negate=
    rx221_cur."!cursor_pos"(rx221_pos)
    $P10 = rx221_cur."blockoid"()
    unless $P10, rx221_fail
    rx221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx221_pos = $P10."pos"()
.annotate 'line', 151
    goto alt227_end
  alt227_2:
.annotate 'line', 154
  # rx subrule "panic" subtype=method negate=
    rx221_cur."!cursor_pos"(rx221_pos)
    $P10 = rx221_cur."panic"("Missing block")
    unless $P10, rx221_fail
    rx221_pos = $P10."pos"()
  alt227_end:
.annotate 'line', 146
  # rx pass
    rx221_cur."!cursor_pass"(rx221_pos, "pblock")
    if_null rx221_debug, debug_499
    rx221_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx221_pos)
  debug_499:
    .return (rx221_cur)
  rx221_restart:
.annotate 'line', 4
    if_null rx221_debug, debug_500
    rx221_cur."!cursor_debug"("NEXT", "pblock")
  debug_500:
  rx221_fail:
    (rx221_rep, rx221_pos, $I10, $P10) = rx221_cur."!mark_fail"(0)
    lt rx221_pos, -1, rx221_done
    eq rx221_pos, -1, rx221_fail
    jump $I10
  rx221_done:
    rx221_cur."!cursor_fail"()
    if_null rx221_debug, debug_501
    rx221_cur."!cursor_debug"("FAIL", "pblock")
  debug_501:
    .return (rx221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1300051172.188") :method
.annotate 'line', 4
    $P223 = self."!PREFIX__!subrule"("panic", "")
    $P224 = self."!PREFIX__!subrule"("lambda", "")
    new $P225, "ResizablePMCArray"
    push $P225, $P223
    push $P225, "{"
    push $P225, $P224
    .return ($P225)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx229_tgt
    .local int rx229_pos
    .local int rx229_off
    .local int rx229_eos
    .local int rx229_rep
    .local pmc rx229_cur
    .local pmc rx229_debug
    (rx229_cur, rx229_pos, rx229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx229_cur
    .local pmc match
    .lex "$/", match
    length rx229_eos, rx229_tgt
    gt rx229_pos, rx229_eos, rx229_done
    set rx229_off, 0
    lt rx229_pos, 2, rx229_start
    sub rx229_off, rx229_pos, 1
    substr rx229_tgt, rx229_tgt, rx229_off
  rx229_start:
    eq $I10, 1, rx229_restart
    if_null rx229_debug, debug_502
    rx229_cur."!cursor_debug"("START", "lambda")
  debug_502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan232_done
    goto rxscan232_scan
  rxscan232_loop:
    (rx229_pos) = rx229_cur."from"()
    inc rx229_pos
    rx229_cur."!cursor_from"(rx229_pos)
    ge rx229_pos, rx229_eos, rxscan232_done
  rxscan232_scan:
    set_addr $I10, rxscan232_loop
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  rxscan232_done:
  alt233_0:
.annotate 'line', 157
    set_addr $I10, alt233_1
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  # rx literal  "->"
    add $I11, rx229_pos, 2
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    substr $S10, rx229_tgt, $I11, 2
    ne $S10, "->", rx229_fail
    add rx229_pos, 2
    goto alt233_end
  alt233_1:
  # rx literal  "<->"
    add $I11, rx229_pos, 3
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    substr $S10, rx229_tgt, $I11, 3
    ne $S10, "<->", rx229_fail
    add rx229_pos, 3
  alt233_end:
  # rx pass
    rx229_cur."!cursor_pass"(rx229_pos, "lambda")
    if_null rx229_debug, debug_503
    rx229_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx229_pos)
  debug_503:
    .return (rx229_cur)
  rx229_restart:
.annotate 'line', 4
    if_null rx229_debug, debug_504
    rx229_cur."!cursor_debug"("NEXT", "lambda")
  debug_504:
  rx229_fail:
    (rx229_rep, rx229_pos, $I10, $P10) = rx229_cur."!mark_fail"(0)
    lt rx229_pos, -1, rx229_done
    eq rx229_pos, -1, rx229_fail
    jump $I10
  rx229_done:
    rx229_cur."!cursor_fail"()
    if_null rx229_debug, debug_505
    rx229_cur."!cursor_debug"("FAIL", "lambda")
  debug_505:
    .return (rx229_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1300051172.188") :method
.annotate 'line', 4
    new $P231, "ResizablePMCArray"
    push $P231, "<->"
    push $P231, "->"
    .return ($P231)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx235_tgt
    .local int rx235_pos
    .local int rx235_off
    .local int rx235_eos
    .local int rx235_rep
    .local pmc rx235_cur
    .local pmc rx235_debug
    (rx235_cur, rx235_pos, rx235_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx235_cur
    .local pmc match
    .lex "$/", match
    length rx235_eos, rx235_tgt
    gt rx235_pos, rx235_eos, rx235_done
    set rx235_off, 0
    lt rx235_pos, 2, rx235_start
    sub rx235_off, rx235_pos, 1
    substr rx235_tgt, rx235_tgt, rx235_off
  rx235_start:
    eq $I10, 1, rx235_restart
    if_null rx235_debug, debug_506
    rx235_cur."!cursor_debug"("START", "block")
  debug_506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan239_done
    goto rxscan239_scan
  rxscan239_loop:
    (rx235_pos) = rx235_cur."from"()
    inc rx235_pos
    rx235_cur."!cursor_from"(rx235_pos)
    ge rx235_pos, rx235_eos, rxscan239_done
  rxscan239_scan:
    set_addr $I10, rxscan239_loop
    rx235_cur."!mark_push"(0, rx235_pos, $I10)
  rxscan239_done:
  alt240_0:
.annotate 'line', 160
    set_addr $I10, alt240_1
    rx235_cur."!mark_push"(0, rx235_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx235_pos, rx235_off
    substr $S10, rx235_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx235_fail
    goto alt240_end
  alt240_1:
  # rx subrule "panic" subtype=method negate=
    rx235_cur."!cursor_pos"(rx235_pos)
    $P10 = rx235_cur."panic"("Missing block")
    unless $P10, rx235_fail
    rx235_pos = $P10."pos"()
  alt240_end:
.annotate 'line', 161
  # rx subrule "newpad" subtype=method negate=
    rx235_cur."!cursor_pos"(rx235_pos)
    $P10 = rx235_cur."newpad"()
    unless $P10, rx235_fail
    rx235_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx235_cur."!cursor_pos"(rx235_pos)
    $P10 = rx235_cur."blockoid"()
    unless $P10, rx235_fail
    rx235_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx235_pos = $P10."pos"()
.annotate 'line', 159
  # rx pass
    rx235_cur."!cursor_pass"(rx235_pos, "block")
    if_null rx235_debug, debug_507
    rx235_cur."!cursor_debug"("PASS", "block", " at pos=", rx235_pos)
  debug_507:
    .return (rx235_cur)
  rx235_restart:
.annotate 'line', 4
    if_null rx235_debug, debug_508
    rx235_cur."!cursor_debug"("NEXT", "block")
  debug_508:
  rx235_fail:
    (rx235_rep, rx235_pos, $I10, $P10) = rx235_cur."!mark_fail"(0)
    lt rx235_pos, -1, rx235_done
    eq rx235_pos, -1, rx235_fail
    jump $I10
  rx235_done:
    rx235_cur."!cursor_fail"()
    if_null rx235_debug, debug_509
    rx235_cur."!cursor_debug"("FAIL", "block")
  debug_509:
    .return (rx235_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1300051172.188") :method
.annotate 'line', 4
    $P237 = self."!PREFIX__!subrule"("panic", "")
    new $P238, "ResizablePMCArray"
    push $P238, $P237
    push $P238, "{"
    .return ($P238)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx242_tgt
    .local int rx242_pos
    .local int rx242_off
    .local int rx242_eos
    .local int rx242_rep
    .local pmc rx242_cur
    .local pmc rx242_debug
    (rx242_cur, rx242_pos, rx242_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx242_cur
    .local pmc match
    .lex "$/", match
    length rx242_eos, rx242_tgt
    gt rx242_pos, rx242_eos, rx242_done
    set rx242_off, 0
    lt rx242_pos, 2, rx242_start
    sub rx242_off, rx242_pos, 1
    substr rx242_tgt, rx242_tgt, rx242_off
  rx242_start:
    eq $I10, 1, rx242_restart
    if_null rx242_debug, debug_510
    rx242_cur."!cursor_debug"("START", "blockoid")
  debug_510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan246_done
    goto rxscan246_scan
  rxscan246_loop:
    (rx242_pos) = rx242_cur."from"()
    inc rx242_pos
    rx242_cur."!cursor_from"(rx242_pos)
    ge rx242_pos, rx242_eos, rxscan246_done
  rxscan246_scan:
    set_addr $I10, rxscan246_loop
    rx242_cur."!mark_push"(0, rx242_pos, $I10)
  rxscan246_done:
.annotate 'line', 166
  # rx subrule "finishpad" subtype=method negate=
    rx242_cur."!cursor_pos"(rx242_pos)
    $P10 = rx242_cur."finishpad"()
    unless $P10, rx242_fail
    rx242_pos = $P10."pos"()
  alt247_0:
.annotate 'line', 167
    set_addr $I10, alt247_1
    rx242_cur."!mark_push"(0, rx242_pos, $I10)
.annotate 'line', 168
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx242_pos, 14
    gt $I11, rx242_eos, rx242_fail
    sub $I11, rx242_pos, rx242_off
    substr $S10, rx242_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx242_fail
    add rx242_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx242_cur."!cursor_pos"(rx242_pos)
    $P10 = rx242_cur."you_are_here"()
    unless $P10, rx242_fail
    rx242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx242_pos = $P10."pos"()
    goto alt247_end
  alt247_1:
.annotate 'line', 169
  # rx literal  "{"
    add $I11, rx242_pos, 1
    gt $I11, rx242_eos, rx242_fail
    sub $I11, rx242_pos, rx242_off
    ord $I11, rx242_tgt, $I11
    ne $I11, 123, rx242_fail
    add rx242_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx242_cur."!cursor_pos"(rx242_pos)
    $P10 = rx242_cur."statementlist"()
    unless $P10, rx242_fail
    rx242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx242_pos = $P10."pos"()
  alt248_0:
    set_addr $I10, alt248_1
    rx242_cur."!mark_push"(0, rx242_pos, $I10)
  # rx literal  "}"
    add $I11, rx242_pos, 1
    gt $I11, rx242_eos, rx242_fail
    sub $I11, rx242_pos, rx242_off
    ord $I11, rx242_tgt, $I11
    ne $I11, 125, rx242_fail
    add rx242_pos, 1
    goto alt248_end
  alt248_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx242_cur."!cursor_pos"(rx242_pos)
    $P10 = rx242_cur."FAILGOAL"("'}'")
    unless $P10, rx242_fail
    goto rxsubrule250_pass
  rxsubrule250_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx242_fail
  rxsubrule250_pass:
    set_addr $I10, rxsubrule250_back
    rx242_cur."!mark_push"(0, rx242_pos, $I10, $P10)
    rx242_pos = $P10."pos"()
  alt248_end:
  alt247_end:
.annotate 'line', 171
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx242_cur."!cursor_pos"(rx242_pos)
    $P10 = rx242_cur."ENDSTMT"()
    unless $P10, rx242_fail
.annotate 'line', 165
  # rx pass
    rx242_cur."!cursor_pass"(rx242_pos, "blockoid")
    if_null rx242_debug, debug_511
    rx242_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx242_pos)
  debug_511:
    .return (rx242_cur)
  rx242_restart:
.annotate 'line', 4
    if_null rx242_debug, debug_512
    rx242_cur."!cursor_debug"("NEXT", "blockoid")
  debug_512:
  rx242_fail:
    (rx242_rep, rx242_pos, $I10, $P10) = rx242_cur."!mark_fail"(0)
    lt rx242_pos, -1, rx242_done
    eq rx242_pos, -1, rx242_fail
    jump $I10
  rx242_done:
    rx242_cur."!cursor_fail"()
    if_null rx242_debug, debug_513
    rx242_cur."!cursor_debug"("FAIL", "blockoid")
  debug_513:
    .return (rx242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1300051172.188") :method
.annotate 'line', 4
    $P244 = self."!PREFIX__!subrule"("finishpad", "")
    new $P245, "ResizablePMCArray"
    push $P245, $P244
    .return ($P245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx252_tgt
    .local int rx252_pos
    .local int rx252_off
    .local int rx252_eos
    .local int rx252_rep
    .local pmc rx252_cur
    .local pmc rx252_debug
    (rx252_cur, rx252_pos, rx252_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx252_cur
    .local pmc match
    .lex "$/", match
    length rx252_eos, rx252_tgt
    gt rx252_pos, rx252_eos, rx252_done
    set rx252_off, 0
    lt rx252_pos, 2, rx252_start
    sub rx252_off, rx252_pos, 1
    substr rx252_tgt, rx252_tgt, rx252_off
  rx252_start:
    eq $I10, 1, rx252_restart
    if_null rx252_debug, debug_514
    rx252_cur."!cursor_debug"("START", "newpad")
  debug_514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan255_done
    goto rxscan255_scan
  rxscan255_loop:
    (rx252_pos) = rx252_cur."from"()
    inc rx252_pos
    rx252_cur."!cursor_from"(rx252_pos)
    ge rx252_pos, rx252_eos, rxscan255_done
  rxscan255_scan:
    set_addr $I10, rxscan255_loop
    rx252_cur."!mark_push"(0, rx252_pos, $I10)
  rxscan255_done:
.annotate 'line', 174
  # rx pass
    rx252_cur."!cursor_pass"(rx252_pos, "newpad")
    if_null rx252_debug, debug_515
    rx252_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx252_pos)
  debug_515:
    .return (rx252_cur)
  rx252_restart:
.annotate 'line', 4
    if_null rx252_debug, debug_516
    rx252_cur."!cursor_debug"("NEXT", "newpad")
  debug_516:
  rx252_fail:
    (rx252_rep, rx252_pos, $I10, $P10) = rx252_cur."!mark_fail"(0)
    lt rx252_pos, -1, rx252_done
    eq rx252_pos, -1, rx252_fail
    jump $I10
  rx252_done:
    rx252_cur."!cursor_fail"()
    if_null rx252_debug, debug_517
    rx252_cur."!cursor_debug"("FAIL", "newpad")
  debug_517:
    .return (rx252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1300051172.188") :method
.annotate 'line', 4
    new $P254, "ResizablePMCArray"
    push $P254, ""
    .return ($P254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx257_tgt
    .local int rx257_pos
    .local int rx257_off
    .local int rx257_eos
    .local int rx257_rep
    .local pmc rx257_cur
    .local pmc rx257_debug
    (rx257_cur, rx257_pos, rx257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx257_cur
    .local pmc match
    .lex "$/", match
    length rx257_eos, rx257_tgt
    gt rx257_pos, rx257_eos, rx257_done
    set rx257_off, 0
    lt rx257_pos, 2, rx257_start
    sub rx257_off, rx257_pos, 1
    substr rx257_tgt, rx257_tgt, rx257_off
  rx257_start:
    eq $I10, 1, rx257_restart
    if_null rx257_debug, debug_518
    rx257_cur."!cursor_debug"("START", "outerctx")
  debug_518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan260_done
    goto rxscan260_scan
  rxscan260_loop:
    (rx257_pos) = rx257_cur."from"()
    inc rx257_pos
    rx257_cur."!cursor_from"(rx257_pos)
    ge rx257_pos, rx257_eos, rxscan260_done
  rxscan260_scan:
    set_addr $I10, rxscan260_loop
    rx257_cur."!mark_push"(0, rx257_pos, $I10)
  rxscan260_done:
.annotate 'line', 175
  # rx pass
    rx257_cur."!cursor_pass"(rx257_pos, "outerctx")
    if_null rx257_debug, debug_519
    rx257_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx257_pos)
  debug_519:
    .return (rx257_cur)
  rx257_restart:
.annotate 'line', 4
    if_null rx257_debug, debug_520
    rx257_cur."!cursor_debug"("NEXT", "outerctx")
  debug_520:
  rx257_fail:
    (rx257_rep, rx257_pos, $I10, $P10) = rx257_cur."!mark_fail"(0)
    lt rx257_pos, -1, rx257_done
    eq rx257_pos, -1, rx257_fail
    jump $I10
  rx257_done:
    rx257_cur."!cursor_fail"()
    if_null rx257_debug, debug_521
    rx257_cur."!cursor_debug"("FAIL", "outerctx")
  debug_521:
    .return (rx257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1300051172.188") :method
.annotate 'line', 4
    new $P259, "ResizablePMCArray"
    push $P259, ""
    .return ($P259)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx262_tgt
    .local int rx262_pos
    .local int rx262_off
    .local int rx262_eos
    .local int rx262_rep
    .local pmc rx262_cur
    .local pmc rx262_debug
    (rx262_cur, rx262_pos, rx262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx262_cur
    .local pmc match
    .lex "$/", match
    length rx262_eos, rx262_tgt
    gt rx262_pos, rx262_eos, rx262_done
    set rx262_off, 0
    lt rx262_pos, 2, rx262_start
    sub rx262_off, rx262_pos, 1
    substr rx262_tgt, rx262_tgt, rx262_off
  rx262_start:
    eq $I10, 1, rx262_restart
    if_null rx262_debug, debug_522
    rx262_cur."!cursor_debug"("START", "finishpad")
  debug_522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan265_done
    goto rxscan265_scan
  rxscan265_loop:
    (rx262_pos) = rx262_cur."from"()
    inc rx262_pos
    rx262_cur."!cursor_from"(rx262_pos)
    ge rx262_pos, rx262_eos, rxscan265_done
  rxscan265_scan:
    set_addr $I10, rxscan265_loop
    rx262_cur."!mark_push"(0, rx262_pos, $I10)
  rxscan265_done:
.annotate 'line', 176
  # rx pass
    rx262_cur."!cursor_pass"(rx262_pos, "finishpad")
    if_null rx262_debug, debug_523
    rx262_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx262_pos)
  debug_523:
    .return (rx262_cur)
  rx262_restart:
.annotate 'line', 4
    if_null rx262_debug, debug_524
    rx262_cur."!cursor_debug"("NEXT", "finishpad")
  debug_524:
  rx262_fail:
    (rx262_rep, rx262_pos, $I10, $P10) = rx262_cur."!mark_fail"(0)
    lt rx262_pos, -1, rx262_done
    eq rx262_pos, -1, rx262_fail
    jump $I10
  rx262_done:
    rx262_cur."!cursor_fail"()
    if_null rx262_debug, debug_525
    rx262_cur."!cursor_debug"("FAIL", "finishpad")
  debug_525:
    .return (rx262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1300051172.188") :method
.annotate 'line', 4
    new $P264, "ResizablePMCArray"
    push $P264, ""
    .return ($P264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("54_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx267_tgt
    .local int rx267_pos
    .local int rx267_off
    .local int rx267_eos
    .local int rx267_rep
    .local pmc rx267_cur
    .local pmc rx267_debug
    (rx267_cur, rx267_pos, rx267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx267_cur
    .local pmc match
    .lex "$/", match
    length rx267_eos, rx267_tgt
    gt rx267_pos, rx267_eos, rx267_done
    set rx267_off, 0
    lt rx267_pos, 2, rx267_start
    sub rx267_off, rx267_pos, 1
    substr rx267_tgt, rx267_tgt, rx267_off
  rx267_start:
    eq $I10, 1, rx267_restart
    if_null rx267_debug, debug_526
    rx267_cur."!cursor_debug"("START", "you_are_here")
  debug_526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan270_done
    goto rxscan270_scan
  rxscan270_loop:
    (rx267_pos) = rx267_cur."from"()
    inc rx267_pos
    rx267_cur."!cursor_from"(rx267_pos)
    ge rx267_pos, rx267_eos, rxscan270_done
  rxscan270_scan:
    set_addr $I10, rxscan270_loop
    rx267_cur."!mark_push"(0, rx267_pos, $I10)
  rxscan270_done:
.annotate 'line', 177
  # rx pass
    rx267_cur."!cursor_pass"(rx267_pos, "you_are_here")
    if_null rx267_debug, debug_527
    rx267_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx267_pos)
  debug_527:
    .return (rx267_cur)
  rx267_restart:
.annotate 'line', 4
    if_null rx267_debug, debug_528
    rx267_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_528:
  rx267_fail:
    (rx267_rep, rx267_pos, $I10, $P10) = rx267_cur."!mark_fail"(0)
    lt rx267_pos, -1, rx267_done
    eq rx267_pos, -1, rx267_fail
    jump $I10
  rx267_done:
    rx267_cur."!cursor_fail"()
    if_null rx267_debug, debug_529
    rx267_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_529:
    .return (rx267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("55_1300051172.188") :method
.annotate 'line', 4
    new $P269, "ResizablePMCArray"
    push $P269, ""
    .return ($P269)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("56_1300051172.188")
    .param pmc param_272
.annotate 'line', 179
    .lex "self", param_272
    $P273 = param_272."!protoregex"("terminator")
    .return ($P273)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("57_1300051172.188")
    .param pmc param_275
.annotate 'line', 179
    .lex "self", param_275
    $P276 = param_275."!PREFIX__!protoregex"("terminator")
    .return ($P276)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("58_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx278_tgt
    .local int rx278_pos
    .local int rx278_off
    .local int rx278_eos
    .local int rx278_rep
    .local pmc rx278_cur
    .local pmc rx278_debug
    (rx278_cur, rx278_pos, rx278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx278_cur
    .local pmc match
    .lex "$/", match
    length rx278_eos, rx278_tgt
    gt rx278_pos, rx278_eos, rx278_done
    set rx278_off, 0
    lt rx278_pos, 2, rx278_start
    sub rx278_off, rx278_pos, 1
    substr rx278_tgt, rx278_tgt, rx278_off
  rx278_start:
    eq $I10, 1, rx278_restart
    if_null rx278_debug, debug_530
    rx278_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan281_done
    goto rxscan281_scan
  rxscan281_loop:
    (rx278_pos) = rx278_cur."from"()
    inc rx278_pos
    rx278_cur."!cursor_from"(rx278_pos)
    ge rx278_pos, rx278_eos, rxscan281_done
  rxscan281_scan:
    set_addr $I10, rxscan281_loop
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxscan281_done:
.annotate 'line', 181
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx278_pos, rx278_off
    substr $S10, rx278_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx278_fail
  # rx pass
    rx278_cur."!cursor_pass"(rx278_pos, "terminator:sym<;>")
    if_null rx278_debug, debug_531
    rx278_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx278_pos)
  debug_531:
    .return (rx278_cur)
  rx278_restart:
.annotate 'line', 4
    if_null rx278_debug, debug_532
    rx278_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_532:
  rx278_fail:
    (rx278_rep, rx278_pos, $I10, $P10) = rx278_cur."!mark_fail"(0)
    lt rx278_pos, -1, rx278_done
    eq rx278_pos, -1, rx278_fail
    jump $I10
  rx278_done:
    rx278_cur."!cursor_fail"()
    if_null rx278_debug, debug_533
    rx278_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_533:
    .return (rx278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("59_1300051172.188") :method
.annotate 'line', 4
    new $P280, "ResizablePMCArray"
    push $P280, ";"
    .return ($P280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("60_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx283_tgt
    .local int rx283_pos
    .local int rx283_off
    .local int rx283_eos
    .local int rx283_rep
    .local pmc rx283_cur
    .local pmc rx283_debug
    (rx283_cur, rx283_pos, rx283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx283_cur
    .local pmc match
    .lex "$/", match
    length rx283_eos, rx283_tgt
    gt rx283_pos, rx283_eos, rx283_done
    set rx283_off, 0
    lt rx283_pos, 2, rx283_start
    sub rx283_off, rx283_pos, 1
    substr rx283_tgt, rx283_tgt, rx283_off
  rx283_start:
    eq $I10, 1, rx283_restart
    if_null rx283_debug, debug_534
    rx283_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan286_done
    goto rxscan286_scan
  rxscan286_loop:
    (rx283_pos) = rx283_cur."from"()
    inc rx283_pos
    rx283_cur."!cursor_from"(rx283_pos)
    ge rx283_pos, rx283_eos, rxscan286_done
  rxscan286_scan:
    set_addr $I10, rxscan286_loop
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  rxscan286_done:
.annotate 'line', 182
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx283_pos, rx283_off
    substr $S10, rx283_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx283_fail
  # rx pass
    rx283_cur."!cursor_pass"(rx283_pos, "terminator:sym<}>")
    if_null rx283_debug, debug_535
    rx283_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx283_pos)
  debug_535:
    .return (rx283_cur)
  rx283_restart:
.annotate 'line', 4
    if_null rx283_debug, debug_536
    rx283_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_536:
  rx283_fail:
    (rx283_rep, rx283_pos, $I10, $P10) = rx283_cur."!mark_fail"(0)
    lt rx283_pos, -1, rx283_done
    eq rx283_pos, -1, rx283_fail
    jump $I10
  rx283_done:
    rx283_cur."!cursor_fail"()
    if_null rx283_debug, debug_537
    rx283_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_537:
    .return (rx283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("61_1300051172.188") :method
.annotate 'line', 4
    new $P285, "ResizablePMCArray"
    push $P285, "}"
    .return ($P285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("62_1300051172.188")
    .param pmc param_288
.annotate 'line', 186
    .lex "self", param_288
    $P289 = param_288."!protoregex"("statement_control")
    .return ($P289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("63_1300051172.188")
    .param pmc param_291
.annotate 'line', 186
    .lex "self", param_291
    $P292 = param_291."!PREFIX__!protoregex"("statement_control")
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("64_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx294_tgt
    .local int rx294_pos
    .local int rx294_off
    .local int rx294_eos
    .local int rx294_rep
    .local pmc rx294_cur
    .local pmc rx294_debug
    (rx294_cur, rx294_pos, rx294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx294_cur
    .local pmc match
    .lex "$/", match
    length rx294_eos, rx294_tgt
    gt rx294_pos, rx294_eos, rx294_done
    set rx294_off, 0
    lt rx294_pos, 2, rx294_start
    sub rx294_off, rx294_pos, 1
    substr rx294_tgt, rx294_tgt, rx294_off
  rx294_start:
    eq $I10, 1, rx294_restart
    if_null rx294_debug, debug_538
    rx294_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan297_done
    goto rxscan297_scan
  rxscan297_loop:
    (rx294_pos) = rx294_cur."from"()
    inc rx294_pos
    rx294_cur."!cursor_from"(rx294_pos)
    ge rx294_pos, rx294_eos, rxscan297_done
  rxscan297_scan:
    set_addr $I10, rxscan297_loop
    rx294_cur."!mark_push"(0, rx294_pos, $I10)
  rxscan297_done:
.annotate 'line', 189
  # rx subcapture "sym"
    set_addr $I10, rxcap_298_fail
    rx294_cur."!mark_push"(0, rx294_pos, $I10)
  # rx literal  "use"
    add $I11, rx294_pos, 3
    gt $I11, rx294_eos, rx294_fail
    sub $I11, rx294_pos, rx294_off
    substr $S10, rx294_tgt, $I11, 3
    ne $S10, "use", rx294_fail
    add rx294_pos, 3
    set_addr $I10, rxcap_298_fail
    ($I12, $I11) = rx294_cur."!mark_peek"($I10)
    rx294_cur."!cursor_pos"($I11)
    ($P10) = rx294_cur."!cursor_start"()
    $P10."!cursor_pass"(rx294_pos, "")
    rx294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_298_done
  rxcap_298_fail:
    goto rx294_fail
  rxcap_298_done:
  # rx charclass s
    ge rx294_pos, rx294_eos, rx294_fail
    sub $I10, rx294_pos, rx294_off
    is_cclass $I11, 32, rx294_tgt, $I10
    unless $I11, rx294_fail
    inc rx294_pos
  # rx subrule "ws" subtype=method negate=
    rx294_cur."!cursor_pos"(rx294_pos)
    $P10 = rx294_cur."ws"()
    unless $P10, rx294_fail
    rx294_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx294_cur."!cursor_pos"(rx294_pos)
    $P10 = rx294_cur."name"()
    unless $P10, rx294_fail
    rx294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx294_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx294_cur."!cursor_pos"(rx294_pos)
    $P10 = rx294_cur."ws"()
    unless $P10, rx294_fail
    rx294_pos = $P10."pos"()
.annotate 'line', 188
  # rx pass
    rx294_cur."!cursor_pass"(rx294_pos, "statement_control:sym<use>")
    if_null rx294_debug, debug_539
    rx294_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx294_pos)
  debug_539:
    .return (rx294_cur)
  rx294_restart:
.annotate 'line', 4
    if_null rx294_debug, debug_540
    rx294_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_540:
  rx294_fail:
    (rx294_rep, rx294_pos, $I10, $P10) = rx294_cur."!mark_fail"(0)
    lt rx294_pos, -1, rx294_done
    eq rx294_pos, -1, rx294_fail
    jump $I10
  rx294_done:
    rx294_cur."!cursor_fail"()
    if_null rx294_debug, debug_541
    rx294_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_541:
    .return (rx294_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("65_1300051172.188") :method
.annotate 'line', 4
    new $P296, "ResizablePMCArray"
    push $P296, "use"
    .return ($P296)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("66_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx302_tgt
    .local int rx302_pos
    .local int rx302_off
    .local int rx302_eos
    .local int rx302_rep
    .local pmc rx302_cur
    .local pmc rx302_debug
    (rx302_cur, rx302_pos, rx302_tgt, $I10) = self."!cursor_start"()
    rx302_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx302_cur
    .local pmc match
    .lex "$/", match
    length rx302_eos, rx302_tgt
    gt rx302_pos, rx302_eos, rx302_done
    set rx302_off, 0
    lt rx302_pos, 2, rx302_start
    sub rx302_off, rx302_pos, 1
    substr rx302_tgt, rx302_tgt, rx302_off
  rx302_start:
    eq $I10, 1, rx302_restart
    if_null rx302_debug, debug_542
    rx302_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_542:
    $I10 = self.'from'()
    ne $I10, -1, rxscan305_done
    goto rxscan305_scan
  rxscan305_loop:
    (rx302_pos) = rx302_cur."from"()
    inc rx302_pos
    rx302_cur."!cursor_from"(rx302_pos)
    ge rx302_pos, rx302_eos, rxscan305_done
  rxscan305_scan:
    set_addr $I10, rxscan305_loop
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxscan305_done:
.annotate 'line', 193
  # rx subcapture "sym"
    set_addr $I10, rxcap_306_fail
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  # rx literal  "if"
    add $I11, rx302_pos, 2
    gt $I11, rx302_eos, rx302_fail
    sub $I11, rx302_pos, rx302_off
    substr $S10, rx302_tgt, $I11, 2
    ne $S10, "if", rx302_fail
    add rx302_pos, 2
    set_addr $I10, rxcap_306_fail
    ($I12, $I11) = rx302_cur."!mark_peek"($I10)
    rx302_cur."!cursor_pos"($I11)
    ($P10) = rx302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx302_pos, "")
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_306_done
  rxcap_306_fail:
    goto rx302_fail
  rxcap_306_done:
  # rx charclass s
    ge rx302_pos, rx302_eos, rx302_fail
    sub $I10, rx302_pos, rx302_off
    is_cclass $I11, 32, rx302_tgt, $I10
    unless $I11, rx302_fail
    inc rx302_pos
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
.annotate 'line', 194
  # rx subrule "xblock" subtype=capture negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."xblock"()
    unless $P10, rx302_fail
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
.annotate 'line', 195
  # rx rxquantr309 ** 0..*
    set_addr $I10, rxquantr309_done
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxquantr309_loop:
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx302_pos, 5
    gt $I11, rx302_eos, rx302_fail
    sub $I11, rx302_pos, rx302_off
    substr $S10, rx302_tgt, $I11, 5
    ne $S10, "elsif", rx302_fail
    add rx302_pos, 5
  # rx charclass s
    ge rx302_pos, rx302_eos, rx302_fail
    sub $I10, rx302_pos, rx302_off
    is_cclass $I11, 32, rx302_tgt, $I10
    unless $I11, rx302_fail
    inc rx302_pos
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."xblock"()
    unless $P10, rx302_fail
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
    set_addr $I10, rxquantr309_done
    (rx302_rep) = rx302_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr309_done
    rx302_cur."!mark_push"(rx302_rep, rx302_pos, $I10)
    goto rxquantr309_loop
  rxquantr309_done:
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
.annotate 'line', 196
  # rx rxquantr314 ** 0..1
    set_addr $I10, rxquantr314_done
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxquantr314_loop:
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx302_pos, 4
    gt $I11, rx302_eos, rx302_fail
    sub $I11, rx302_pos, rx302_off
    substr $S10, rx302_tgt, $I11, 4
    ne $S10, "else", rx302_fail
    add rx302_pos, 4
  # rx charclass s
    ge rx302_pos, rx302_eos, rx302_fail
    sub $I10, rx302_pos, rx302_off
    is_cclass $I11, 32, rx302_tgt, $I10
    unless $I11, rx302_fail
    inc rx302_pos
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."pblock"()
    unless $P10, rx302_fail
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
    set_addr $I10, rxquantr314_done
    (rx302_rep) = rx302_cur."!mark_commit"($I10)
  rxquantr314_done:
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
.annotate 'line', 192
  # rx pass
    rx302_cur."!cursor_pass"(rx302_pos, "statement_control:sym<if>")
    if_null rx302_debug, debug_543
    rx302_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx302_pos)
  debug_543:
    .return (rx302_cur)
  rx302_restart:
.annotate 'line', 4
    if_null rx302_debug, debug_544
    rx302_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_544:
  rx302_fail:
    (rx302_rep, rx302_pos, $I10, $P10) = rx302_cur."!mark_fail"(0)
    lt rx302_pos, -1, rx302_done
    eq rx302_pos, -1, rx302_fail
    jump $I10
  rx302_done:
    rx302_cur."!cursor_fail"()
    if_null rx302_debug, debug_545
    rx302_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_545:
    .return (rx302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("67_1300051172.188") :method
.annotate 'line', 4
    new $P304, "ResizablePMCArray"
    push $P304, "if"
    .return ($P304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("68_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P330 = "70_1300051172.188" 
    capture_lex $P330
    .local string rx320_tgt
    .local int rx320_pos
    .local int rx320_off
    .local int rx320_eos
    .local int rx320_rep
    .local pmc rx320_cur
    .local pmc rx320_debug
    (rx320_cur, rx320_pos, rx320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx320_cur
    .local pmc match
    .lex "$/", match
    length rx320_eos, rx320_tgt
    gt rx320_pos, rx320_eos, rx320_done
    set rx320_off, 0
    lt rx320_pos, 2, rx320_start
    sub rx320_off, rx320_pos, 1
    substr rx320_tgt, rx320_tgt, rx320_off
  rx320_start:
    eq $I10, 1, rx320_restart
    if_null rx320_debug, debug_546
    rx320_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan323_done
    goto rxscan323_scan
  rxscan323_loop:
    (rx320_pos) = rx320_cur."from"()
    inc rx320_pos
    rx320_cur."!cursor_from"(rx320_pos)
    ge rx320_pos, rx320_eos, rxscan323_done
  rxscan323_scan:
    set_addr $I10, rxscan323_loop
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxscan323_done:
.annotate 'line', 200
  # rx subcapture "sym"
    set_addr $I10, rxcap_324_fail
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  # rx literal  "unless"
    add $I11, rx320_pos, 6
    gt $I11, rx320_eos, rx320_fail
    sub $I11, rx320_pos, rx320_off
    substr $S10, rx320_tgt, $I11, 6
    ne $S10, "unless", rx320_fail
    add rx320_pos, 6
    set_addr $I10, rxcap_324_fail
    ($I12, $I11) = rx320_cur."!mark_peek"($I10)
    rx320_cur."!cursor_pos"($I11)
    ($P10) = rx320_cur."!cursor_start"()
    $P10."!cursor_pass"(rx320_pos, "")
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_324_done
  rxcap_324_fail:
    goto rx320_fail
  rxcap_324_done:
  # rx charclass s
    ge rx320_pos, rx320_eos, rx320_fail
    sub $I10, rx320_pos, rx320_off
    is_cclass $I11, 32, rx320_tgt, $I10
    unless $I11, rx320_fail
    inc rx320_pos
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
.annotate 'line', 201
  # rx subrule "xblock" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."xblock"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  alt327_0:
.annotate 'line', 202
    set_addr $I10, alt327_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx320_cur."!cursor_pos"(rx320_pos)
    .const 'Sub' $P330 = "70_1300051172.188" 
    capture_lex $P330
    $P10 = rx320_cur."before"($P330)
    if $P10, rx320_fail
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
    goto alt327_end
  alt327_1:
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  alt327_end:
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
.annotate 'line', 199
  # rx pass
    rx320_cur."!cursor_pass"(rx320_pos, "statement_control:sym<unless>")
    if_null rx320_debug, debug_551
    rx320_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx320_pos)
  debug_551:
    .return (rx320_cur)
  rx320_restart:
.annotate 'line', 4
    if_null rx320_debug, debug_552
    rx320_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_552:
  rx320_fail:
    (rx320_rep, rx320_pos, $I10, $P10) = rx320_cur."!mark_fail"(0)
    lt rx320_pos, -1, rx320_done
    eq rx320_pos, -1, rx320_fail
    jump $I10
  rx320_done:
    rx320_cur."!cursor_fail"()
    if_null rx320_debug, debug_553
    rx320_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_553:
    .return (rx320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("69_1300051172.188") :method
.annotate 'line', 4
    new $P322, "ResizablePMCArray"
    push $P322, "unless"
    .return ($P322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block329"  :anon :subid("70_1300051172.188") :method :outer("68_1300051172.188")
.annotate 'line', 202
    .local string rx331_tgt
    .local int rx331_pos
    .local int rx331_off
    .local int rx331_eos
    .local int rx331_rep
    .local pmc rx331_cur
    .local pmc rx331_debug
    (rx331_cur, rx331_pos, rx331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx331_cur
    .local pmc match
    .lex "$/", match
    length rx331_eos, rx331_tgt
    gt rx331_pos, rx331_eos, rx331_done
    set rx331_off, 0
    lt rx331_pos, 2, rx331_start
    sub rx331_off, rx331_pos, 1
    substr rx331_tgt, rx331_tgt, rx331_off
  rx331_start:
    eq $I10, 1, rx331_restart
    if_null rx331_debug, debug_547
    rx331_cur."!cursor_debug"("START", "")
  debug_547:
    $I10 = self.'from'()
    ne $I10, -1, rxscan332_done
    goto rxscan332_scan
  rxscan332_loop:
    (rx331_pos) = rx331_cur."from"()
    inc rx331_pos
    rx331_cur."!cursor_from"(rx331_pos)
    ge rx331_pos, rx331_eos, rxscan332_done
  rxscan332_scan:
    set_addr $I10, rxscan332_loop
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
  rxscan332_done:
  # rx literal  "else"
    add $I11, rx331_pos, 4
    gt $I11, rx331_eos, rx331_fail
    sub $I11, rx331_pos, rx331_off
    substr $S10, rx331_tgt, $I11, 4
    ne $S10, "else", rx331_fail
    add rx331_pos, 4
  # rx pass
    rx331_cur."!cursor_pass"(rx331_pos, "")
    if_null rx331_debug, debug_548
    rx331_cur."!cursor_debug"("PASS", "", " at pos=", rx331_pos)
  debug_548:
    .return (rx331_cur)
  rx331_restart:
    if_null rx331_debug, debug_549
    rx331_cur."!cursor_debug"("NEXT", "")
  debug_549:
  rx331_fail:
    (rx331_rep, rx331_pos, $I10, $P10) = rx331_cur."!mark_fail"(0)
    lt rx331_pos, -1, rx331_done
    eq rx331_pos, -1, rx331_fail
    jump $I10
  rx331_done:
    rx331_cur."!cursor_fail"()
    if_null rx331_debug, debug_550
    rx331_cur."!cursor_debug"("FAIL", "")
  debug_550:
    .return (rx331_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("71_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx338_tgt
    .local int rx338_pos
    .local int rx338_off
    .local int rx338_eos
    .local int rx338_rep
    .local pmc rx338_cur
    .local pmc rx338_debug
    (rx338_cur, rx338_pos, rx338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx338_cur
    .local pmc match
    .lex "$/", match
    length rx338_eos, rx338_tgt
    gt rx338_pos, rx338_eos, rx338_done
    set rx338_off, 0
    lt rx338_pos, 2, rx338_start
    sub rx338_off, rx338_pos, 1
    substr rx338_tgt, rx338_tgt, rx338_off
  rx338_start:
    eq $I10, 1, rx338_restart
    if_null rx338_debug, debug_554
    rx338_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan341_done
    goto rxscan341_scan
  rxscan341_loop:
    (rx338_pos) = rx338_cur."from"()
    inc rx338_pos
    rx338_cur."!cursor_from"(rx338_pos)
    ge rx338_pos, rx338_eos, rxscan341_done
  rxscan341_scan:
    set_addr $I10, rxscan341_loop
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  rxscan341_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_343_fail
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  alt342_0:
    set_addr $I10, alt342_1
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  # rx literal  "while"
    add $I11, rx338_pos, 5
    gt $I11, rx338_eos, rx338_fail
    sub $I11, rx338_pos, rx338_off
    substr $S10, rx338_tgt, $I11, 5
    ne $S10, "while", rx338_fail
    add rx338_pos, 5
    goto alt342_end
  alt342_1:
  # rx literal  "until"
    add $I11, rx338_pos, 5
    gt $I11, rx338_eos, rx338_fail
    sub $I11, rx338_pos, rx338_off
    substr $S10, rx338_tgt, $I11, 5
    ne $S10, "until", rx338_fail
    add rx338_pos, 5
  alt342_end:
    set_addr $I10, rxcap_343_fail
    ($I12, $I11) = rx338_cur."!mark_peek"($I10)
    rx338_cur."!cursor_pos"($I11)
    ($P10) = rx338_cur."!cursor_start"()
    $P10."!cursor_pass"(rx338_pos, "")
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_343_done
  rxcap_343_fail:
    goto rx338_fail
  rxcap_343_done:
  # rx charclass s
    ge rx338_pos, rx338_eos, rx338_fail
    sub $I10, rx338_pos, rx338_off
    is_cclass $I11, 32, rx338_tgt, $I10
    unless $I11, rx338_fail
    inc rx338_pos
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "xblock" subtype=capture negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."xblock"()
    unless $P10, rx338_fail
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx338_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx338_cur."!cursor_pass"(rx338_pos, "statement_control:sym<while>")
    if_null rx338_debug, debug_555
    rx338_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx338_pos)
  debug_555:
    .return (rx338_cur)
  rx338_restart:
.annotate 'line', 4
    if_null rx338_debug, debug_556
    rx338_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_556:
  rx338_fail:
    (rx338_rep, rx338_pos, $I10, $P10) = rx338_cur."!mark_fail"(0)
    lt rx338_pos, -1, rx338_done
    eq rx338_pos, -1, rx338_fail
    jump $I10
  rx338_done:
    rx338_cur."!cursor_fail"()
    if_null rx338_debug, debug_557
    rx338_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_557:
    .return (rx338_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("72_1300051172.188") :method
.annotate 'line', 4
    new $P340, "ResizablePMCArray"
    push $P340, "until"
    push $P340, "while"
    .return ($P340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("73_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_558
    rx347_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan350_done
    goto rxscan350_scan
  rxscan350_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan350_done
  rxscan350_scan:
    set_addr $I10, rxscan350_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan350_done:
.annotate 'line', 211
  # rx subcapture "sym"
    set_addr $I10, rxcap_351_fail
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx347_pos, 6
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 6
    ne $S10, "repeat", rx347_fail
    add rx347_pos, 6
    set_addr $I10, rxcap_351_fail
    ($I12, $I11) = rx347_cur."!mark_peek"($I10)
    rx347_cur."!cursor_pos"($I11)
    ($P10) = rx347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx347_pos, "")
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_351_done
  rxcap_351_fail:
    goto rx347_fail
  rxcap_351_done:
  # rx charclass s
    ge rx347_pos, rx347_eos, rx347_fail
    sub $I10, rx347_pos, rx347_off
    is_cclass $I11, 32, rx347_tgt, $I10
    unless $I11, rx347_fail
    inc rx347_pos
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  alt353_0:
.annotate 'line', 212
    set_addr $I10, alt353_1
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
.annotate 'line', 213
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_356_fail
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  alt355_0:
    set_addr $I10, alt355_1
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  # rx literal  "while"
    add $I11, rx347_pos, 5
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 5
    ne $S10, "while", rx347_fail
    add rx347_pos, 5
    goto alt355_end
  alt355_1:
  # rx literal  "until"
    add $I11, rx347_pos, 5
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 5
    ne $S10, "until", rx347_fail
    add rx347_pos, 5
  alt355_end:
    set_addr $I10, rxcap_356_fail
    ($I12, $I11) = rx347_cur."!mark_peek"($I10)
    rx347_cur."!cursor_pos"($I11)
    ($P10) = rx347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx347_pos, "")
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_356_done
  rxcap_356_fail:
    goto rx347_fail
  rxcap_356_done:
  # rx charclass s
    ge rx347_pos, rx347_eos, rx347_fail
    sub $I10, rx347_pos, rx347_off
    is_cclass $I11, 32, rx347_tgt, $I10
    unless $I11, rx347_fail
    inc rx347_pos
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."xblock"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
    goto alt353_end
  alt353_1:
.annotate 'line', 214
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."pblock"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_362_fail
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  alt361_0:
    set_addr $I10, alt361_1
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  # rx literal  "while"
    add $I11, rx347_pos, 5
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 5
    ne $S10, "while", rx347_fail
    add rx347_pos, 5
    goto alt361_end
  alt361_1:
  # rx literal  "until"
    add $I11, rx347_pos, 5
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 5
    ne $S10, "until", rx347_fail
    add rx347_pos, 5
  alt361_end:
    set_addr $I10, rxcap_362_fail
    ($I12, $I11) = rx347_cur."!mark_peek"($I10)
    rx347_cur."!cursor_pos"($I11)
    ($P10) = rx347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx347_pos, "")
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_362_done
  rxcap_362_fail:
    goto rx347_fail
  rxcap_362_done:
  # rx charclass s
    ge rx347_pos, rx347_eos, rx347_fail
    sub $I10, rx347_pos, rx347_off
    is_cclass $I11, 32, rx347_tgt, $I10
    unless $I11, rx347_fail
    inc rx347_pos
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."EXPR"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  alt353_end:
.annotate 'line', 215
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 210
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "statement_control:sym<repeat>")
    if_null rx347_debug, debug_559
    rx347_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx347_pos)
  debug_559:
    .return (rx347_cur)
  rx347_restart:
.annotate 'line', 4
    if_null rx347_debug, debug_560
    rx347_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_560:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_561
    rx347_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_561:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("74_1300051172.188") :method
.annotate 'line', 4
    new $P349, "ResizablePMCArray"
    push $P349, "repeat"
    .return ($P349)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("75_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx367_tgt
    .local int rx367_pos
    .local int rx367_off
    .local int rx367_eos
    .local int rx367_rep
    .local pmc rx367_cur
    .local pmc rx367_debug
    (rx367_cur, rx367_pos, rx367_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx367_cur
    .local pmc match
    .lex "$/", match
    length rx367_eos, rx367_tgt
    gt rx367_pos, rx367_eos, rx367_done
    set rx367_off, 0
    lt rx367_pos, 2, rx367_start
    sub rx367_off, rx367_pos, 1
    substr rx367_tgt, rx367_tgt, rx367_off
  rx367_start:
    eq $I10, 1, rx367_restart
    if_null rx367_debug, debug_562
    rx367_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan370_done
    goto rxscan370_scan
  rxscan370_loop:
    (rx367_pos) = rx367_cur."from"()
    inc rx367_pos
    rx367_cur."!cursor_from"(rx367_pos)
    ge rx367_pos, rx367_eos, rxscan370_done
  rxscan370_scan:
    set_addr $I10, rxscan370_loop
    rx367_cur."!mark_push"(0, rx367_pos, $I10)
  rxscan370_done:
.annotate 'line', 219
  # rx subcapture "sym"
    set_addr $I10, rxcap_371_fail
    rx367_cur."!mark_push"(0, rx367_pos, $I10)
  # rx literal  "for"
    add $I11, rx367_pos, 3
    gt $I11, rx367_eos, rx367_fail
    sub $I11, rx367_pos, rx367_off
    substr $S10, rx367_tgt, $I11, 3
    ne $S10, "for", rx367_fail
    add rx367_pos, 3
    set_addr $I10, rxcap_371_fail
    ($I12, $I11) = rx367_cur."!mark_peek"($I10)
    rx367_cur."!cursor_pos"($I11)
    ($P10) = rx367_cur."!cursor_start"()
    $P10."!cursor_pass"(rx367_pos, "")
    rx367_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_371_done
  rxcap_371_fail:
    goto rx367_fail
  rxcap_371_done:
  # rx charclass s
    ge rx367_pos, rx367_eos, rx367_fail
    sub $I10, rx367_pos, rx367_off
    is_cclass $I11, 32, rx367_tgt, $I10
    unless $I11, rx367_fail
    inc rx367_pos
  # rx subrule "ws" subtype=method negate=
    rx367_cur."!cursor_pos"(rx367_pos)
    $P10 = rx367_cur."ws"()
    unless $P10, rx367_fail
    rx367_pos = $P10."pos"()
.annotate 'line', 220
  # rx subrule "xblock" subtype=capture negate=
    rx367_cur."!cursor_pos"(rx367_pos)
    $P10 = rx367_cur."xblock"()
    unless $P10, rx367_fail
    rx367_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx367_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx367_cur."!cursor_pos"(rx367_pos)
    $P10 = rx367_cur."ws"()
    unless $P10, rx367_fail
    rx367_pos = $P10."pos"()
.annotate 'line', 218
  # rx pass
    rx367_cur."!cursor_pass"(rx367_pos, "statement_control:sym<for>")
    if_null rx367_debug, debug_563
    rx367_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx367_pos)
  debug_563:
    .return (rx367_cur)
  rx367_restart:
.annotate 'line', 4
    if_null rx367_debug, debug_564
    rx367_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_564:
  rx367_fail:
    (rx367_rep, rx367_pos, $I10, $P10) = rx367_cur."!mark_fail"(0)
    lt rx367_pos, -1, rx367_done
    eq rx367_pos, -1, rx367_fail
    jump $I10
  rx367_done:
    rx367_cur."!cursor_fail"()
    if_null rx367_debug, debug_565
    rx367_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_565:
    .return (rx367_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("76_1300051172.188") :method
.annotate 'line', 4
    new $P369, "ResizablePMCArray"
    push $P369, "for"
    .return ($P369)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("77_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx375_tgt
    .local int rx375_pos
    .local int rx375_off
    .local int rx375_eos
    .local int rx375_rep
    .local pmc rx375_cur
    .local pmc rx375_debug
    (rx375_cur, rx375_pos, rx375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx375_cur
    .local pmc match
    .lex "$/", match
    length rx375_eos, rx375_tgt
    gt rx375_pos, rx375_eos, rx375_done
    set rx375_off, 0
    lt rx375_pos, 2, rx375_start
    sub rx375_off, rx375_pos, 1
    substr rx375_tgt, rx375_tgt, rx375_off
  rx375_start:
    eq $I10, 1, rx375_restart
    if_null rx375_debug, debug_566
    rx375_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan378_done
    goto rxscan378_scan
  rxscan378_loop:
    (rx375_pos) = rx375_cur."from"()
    inc rx375_pos
    rx375_cur."!cursor_from"(rx375_pos)
    ge rx375_pos, rx375_eos, rxscan378_done
  rxscan378_scan:
    set_addr $I10, rxscan378_loop
    rx375_cur."!mark_push"(0, rx375_pos, $I10)
  rxscan378_done:
.annotate 'line', 224
  # rx subcapture "sym"
    set_addr $I10, rxcap_379_fail
    rx375_cur."!mark_push"(0, rx375_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx375_pos, 5
    gt $I11, rx375_eos, rx375_fail
    sub $I11, rx375_pos, rx375_off
    substr $S10, rx375_tgt, $I11, 5
    ne $S10, "CATCH", rx375_fail
    add rx375_pos, 5
    set_addr $I10, rxcap_379_fail
    ($I12, $I11) = rx375_cur."!mark_peek"($I10)
    rx375_cur."!cursor_pos"($I11)
    ($P10) = rx375_cur."!cursor_start"()
    $P10."!cursor_pass"(rx375_pos, "")
    rx375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_379_done
  rxcap_379_fail:
    goto rx375_fail
  rxcap_379_done:
  # rx charclass s
    ge rx375_pos, rx375_eos, rx375_fail
    sub $I10, rx375_pos, rx375_off
    is_cclass $I11, 32, rx375_tgt, $I10
    unless $I11, rx375_fail
    inc rx375_pos
  # rx subrule "ws" subtype=method negate=
    rx375_cur."!cursor_pos"(rx375_pos)
    $P10 = rx375_cur."ws"()
    unless $P10, rx375_fail
    rx375_pos = $P10."pos"()
.annotate 'line', 225
  # rx subrule "block" subtype=capture negate=
    rx375_cur."!cursor_pos"(rx375_pos)
    $P10 = rx375_cur."block"()
    unless $P10, rx375_fail
    rx375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx375_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx375_cur."!cursor_pos"(rx375_pos)
    $P10 = rx375_cur."ws"()
    unless $P10, rx375_fail
    rx375_pos = $P10."pos"()
.annotate 'line', 223
  # rx pass
    rx375_cur."!cursor_pass"(rx375_pos, "statement_control:sym<CATCH>")
    if_null rx375_debug, debug_567
    rx375_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx375_pos)
  debug_567:
    .return (rx375_cur)
  rx375_restart:
.annotate 'line', 4
    if_null rx375_debug, debug_568
    rx375_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_568:
  rx375_fail:
    (rx375_rep, rx375_pos, $I10, $P10) = rx375_cur."!mark_fail"(0)
    lt rx375_pos, -1, rx375_done
    eq rx375_pos, -1, rx375_fail
    jump $I10
  rx375_done:
    rx375_cur."!cursor_fail"()
    if_null rx375_debug, debug_569
    rx375_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_569:
    .return (rx375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("78_1300051172.188") :method
.annotate 'line', 4
    new $P377, "ResizablePMCArray"
    push $P377, "CATCH"
    .return ($P377)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("79_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_570
    rx383_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 229
  # rx subcapture "sym"
    set_addr $I10, rxcap_387_fail
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx383_pos, 7
    gt $I11, rx383_eos, rx383_fail
    sub $I11, rx383_pos, rx383_off
    substr $S10, rx383_tgt, $I11, 7
    ne $S10, "CONTROL", rx383_fail
    add rx383_pos, 7
    set_addr $I10, rxcap_387_fail
    ($I12, $I11) = rx383_cur."!mark_peek"($I10)
    rx383_cur."!cursor_pos"($I11)
    ($P10) = rx383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx383_pos, "")
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_387_done
  rxcap_387_fail:
    goto rx383_fail
  rxcap_387_done:
  # rx charclass s
    ge rx383_pos, rx383_eos, rx383_fail
    sub $I10, rx383_pos, rx383_off
    is_cclass $I11, 32, rx383_tgt, $I10
    unless $I11, rx383_fail
    inc rx383_pos
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 230
  # rx subrule "block" subtype=capture negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."block"()
    unless $P10, rx383_fail
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 228
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "statement_control:sym<CONTROL>")
    if_null rx383_debug, debug_571
    rx383_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx383_pos)
  debug_571:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 4
    if_null rx383_debug, debug_572
    rx383_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_572:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_573
    rx383_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_573:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("80_1300051172.188") :method
.annotate 'line', 4
    new $P385, "ResizablePMCArray"
    push $P385, "CONTROL"
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("81_1300051172.188")
    .param pmc param_391
.annotate 'line', 233
    .lex "self", param_391
    $P392 = param_391."!protoregex"("statement_prefix")
    .return ($P392)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("82_1300051172.188")
    .param pmc param_394
.annotate 'line', 233
    .lex "self", param_394
    $P395 = param_394."!PREFIX__!protoregex"("statement_prefix")
    .return ($P395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("83_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx397_tgt
    .local int rx397_pos
    .local int rx397_off
    .local int rx397_eos
    .local int rx397_rep
    .local pmc rx397_cur
    .local pmc rx397_debug
    (rx397_cur, rx397_pos, rx397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx397_cur
    .local pmc match
    .lex "$/", match
    length rx397_eos, rx397_tgt
    gt rx397_pos, rx397_eos, rx397_done
    set rx397_off, 0
    lt rx397_pos, 2, rx397_start
    sub rx397_off, rx397_pos, 1
    substr rx397_tgt, rx397_tgt, rx397_off
  rx397_start:
    eq $I10, 1, rx397_restart
    if_null rx397_debug, debug_574
    rx397_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan401_done
    goto rxscan401_scan
  rxscan401_loop:
    (rx397_pos) = rx397_cur."from"()
    inc rx397_pos
    rx397_cur."!cursor_from"(rx397_pos)
    ge rx397_pos, rx397_eos, rxscan401_done
  rxscan401_scan:
    set_addr $I10, rxscan401_loop
    rx397_cur."!mark_push"(0, rx397_pos, $I10)
  rxscan401_done:
.annotate 'line', 234
  # rx subcapture "sym"
    set_addr $I10, rxcap_402_fail
    rx397_cur."!mark_push"(0, rx397_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx397_pos, 4
    gt $I11, rx397_eos, rx397_fail
    sub $I11, rx397_pos, rx397_off
    substr $S10, rx397_tgt, $I11, 4
    ne $S10, "INIT", rx397_fail
    add rx397_pos, 4
    set_addr $I10, rxcap_402_fail
    ($I12, $I11) = rx397_cur."!mark_peek"($I10)
    rx397_cur."!cursor_pos"($I11)
    ($P10) = rx397_cur."!cursor_start"()
    $P10."!cursor_pass"(rx397_pos, "")
    rx397_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_402_done
  rxcap_402_fail:
    goto rx397_fail
  rxcap_402_done:
  # rx subrule "blorst" subtype=capture negate=
    rx397_cur."!cursor_pos"(rx397_pos)
    $P10 = rx397_cur."blorst"()
    unless $P10, rx397_fail
    rx397_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx397_pos = $P10."pos"()
  # rx pass
    rx397_cur."!cursor_pass"(rx397_pos, "statement_prefix:sym<INIT>")
    if_null rx397_debug, debug_575
    rx397_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx397_pos)
  debug_575:
    .return (rx397_cur)
  rx397_restart:
.annotate 'line', 4
    if_null rx397_debug, debug_576
    rx397_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_576:
  rx397_fail:
    (rx397_rep, rx397_pos, $I10, $P10) = rx397_cur."!mark_fail"(0)
    lt rx397_pos, -1, rx397_done
    eq rx397_pos, -1, rx397_fail
    jump $I10
  rx397_done:
    rx397_cur."!cursor_fail"()
    if_null rx397_debug, debug_577
    rx397_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_577:
    .return (rx397_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("84_1300051172.188") :method
.annotate 'line', 4
    $P399 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P400, "ResizablePMCArray"
    push $P400, $P399
    .return ($P400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("85_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx404_tgt
    .local int rx404_pos
    .local int rx404_off
    .local int rx404_eos
    .local int rx404_rep
    .local pmc rx404_cur
    .local pmc rx404_debug
    (rx404_cur, rx404_pos, rx404_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx404_cur
    .local pmc match
    .lex "$/", match
    length rx404_eos, rx404_tgt
    gt rx404_pos, rx404_eos, rx404_done
    set rx404_off, 0
    lt rx404_pos, 2, rx404_start
    sub rx404_off, rx404_pos, 1
    substr rx404_tgt, rx404_tgt, rx404_off
  rx404_start:
    eq $I10, 1, rx404_restart
    if_null rx404_debug, debug_578
    rx404_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan408_done
    goto rxscan408_scan
  rxscan408_loop:
    (rx404_pos) = rx404_cur."from"()
    inc rx404_pos
    rx404_cur."!cursor_from"(rx404_pos)
    ge rx404_pos, rx404_eos, rxscan408_done
  rxscan408_scan:
    set_addr $I10, rxscan408_loop
    rx404_cur."!mark_push"(0, rx404_pos, $I10)
  rxscan408_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_409_fail
    rx404_cur."!mark_push"(0, rx404_pos, $I10)
  # rx literal  "try"
    add $I11, rx404_pos, 3
    gt $I11, rx404_eos, rx404_fail
    sub $I11, rx404_pos, rx404_off
    substr $S10, rx404_tgt, $I11, 3
    ne $S10, "try", rx404_fail
    add rx404_pos, 3
    set_addr $I10, rxcap_409_fail
    ($I12, $I11) = rx404_cur."!mark_peek"($I10)
    rx404_cur."!cursor_pos"($I11)
    ($P10) = rx404_cur."!cursor_start"()
    $P10."!cursor_pass"(rx404_pos, "")
    rx404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_409_done
  rxcap_409_fail:
    goto rx404_fail
  rxcap_409_done:
.annotate 'line', 238
  # rx subrule "blorst" subtype=capture negate=
    rx404_cur."!cursor_pos"(rx404_pos)
    $P10 = rx404_cur."blorst"()
    unless $P10, rx404_fail
    rx404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx404_pos = $P10."pos"()
.annotate 'line', 236
  # rx pass
    rx404_cur."!cursor_pass"(rx404_pos, "statement_prefix:sym<try>")
    if_null rx404_debug, debug_579
    rx404_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx404_pos)
  debug_579:
    .return (rx404_cur)
  rx404_restart:
.annotate 'line', 4
    if_null rx404_debug, debug_580
    rx404_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_580:
  rx404_fail:
    (rx404_rep, rx404_pos, $I10, $P10) = rx404_cur."!mark_fail"(0)
    lt rx404_pos, -1, rx404_done
    eq rx404_pos, -1, rx404_fail
    jump $I10
  rx404_done:
    rx404_cur."!cursor_fail"()
    if_null rx404_debug, debug_581
    rx404_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_581:
    .return (rx404_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("86_1300051172.188") :method
.annotate 'line', 4
    $P406 = self."!PREFIX__!subrule"("blorst", "try")
    new $P407, "ResizablePMCArray"
    push $P407, $P406
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("87_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx411_tgt
    .local int rx411_pos
    .local int rx411_off
    .local int rx411_eos
    .local int rx411_rep
    .local pmc rx411_cur
    .local pmc rx411_debug
    (rx411_cur, rx411_pos, rx411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx411_cur
    .local pmc match
    .lex "$/", match
    length rx411_eos, rx411_tgt
    gt rx411_pos, rx411_eos, rx411_done
    set rx411_off, 0
    lt rx411_pos, 2, rx411_start
    sub rx411_off, rx411_pos, 1
    substr rx411_tgt, rx411_tgt, rx411_off
  rx411_start:
    eq $I10, 1, rx411_restart
    if_null rx411_debug, debug_582
    rx411_cur."!cursor_debug"("START", "blorst")
  debug_582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan414_done
    goto rxscan414_scan
  rxscan414_loop:
    (rx411_pos) = rx411_cur."from"()
    inc rx411_pos
    rx411_cur."!cursor_from"(rx411_pos)
    ge rx411_pos, rx411_eos, rxscan414_done
  rxscan414_scan:
    set_addr $I10, rxscan414_loop
    rx411_cur."!mark_push"(0, rx411_pos, $I10)
  rxscan414_done:
.annotate 'line', 242
  # rx charclass s
    ge rx411_pos, rx411_eos, rx411_fail
    sub $I10, rx411_pos, rx411_off
    is_cclass $I11, 32, rx411_tgt, $I10
    unless $I11, rx411_fail
    inc rx411_pos
  # rx subrule "ws" subtype=method negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."ws"()
    unless $P10, rx411_fail
    rx411_pos = $P10."pos"()
  alt415_0:
    set_addr $I10, alt415_1
    rx411_cur."!mark_push"(0, rx411_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx411_pos, rx411_off
    substr $S10, rx411_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx411_fail
  # rx subrule "block" subtype=capture negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."block"()
    unless $P10, rx411_fail
    rx411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx411_pos = $P10."pos"()
    goto alt415_end
  alt415_1:
  # rx subrule "statement" subtype=capture negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."statement"()
    unless $P10, rx411_fail
    rx411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx411_pos = $P10."pos"()
  alt415_end:
.annotate 'line', 241
  # rx pass
    rx411_cur."!cursor_pass"(rx411_pos, "blorst")
    if_null rx411_debug, debug_583
    rx411_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx411_pos)
  debug_583:
    .return (rx411_cur)
  rx411_restart:
.annotate 'line', 4
    if_null rx411_debug, debug_584
    rx411_cur."!cursor_debug"("NEXT", "blorst")
  debug_584:
  rx411_fail:
    (rx411_rep, rx411_pos, $I10, $P10) = rx411_cur."!mark_fail"(0)
    lt rx411_pos, -1, rx411_done
    eq rx411_pos, -1, rx411_fail
    jump $I10
  rx411_done:
    rx411_cur."!cursor_fail"()
    if_null rx411_debug, debug_585
    rx411_cur."!cursor_debug"("FAIL", "blorst")
  debug_585:
    .return (rx411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("88_1300051172.188") :method
.annotate 'line', 4
    new $P413, "ResizablePMCArray"
    push $P413, ""
    .return ($P413)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("89_1300051172.188")
    .param pmc param_417
.annotate 'line', 247
    .lex "self", param_417
    $P418 = param_417."!protoregex"("statement_mod_cond")
    .return ($P418)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("90_1300051172.188")
    .param pmc param_420
.annotate 'line', 247
    .lex "self", param_420
    $P421 = param_420."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("91_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx423_tgt
    .local int rx423_pos
    .local int rx423_off
    .local int rx423_eos
    .local int rx423_rep
    .local pmc rx423_cur
    .local pmc rx423_debug
    (rx423_cur, rx423_pos, rx423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx423_cur
    .local pmc match
    .lex "$/", match
    length rx423_eos, rx423_tgt
    gt rx423_pos, rx423_eos, rx423_done
    set rx423_off, 0
    lt rx423_pos, 2, rx423_start
    sub rx423_off, rx423_pos, 1
    substr rx423_tgt, rx423_tgt, rx423_off
  rx423_start:
    eq $I10, 1, rx423_restart
    if_null rx423_debug, debug_586
    rx423_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan427_done
    goto rxscan427_scan
  rxscan427_loop:
    (rx423_pos) = rx423_cur."from"()
    inc rx423_pos
    rx423_cur."!cursor_from"(rx423_pos)
    ge rx423_pos, rx423_eos, rxscan427_done
  rxscan427_scan:
    set_addr $I10, rxscan427_loop
    rx423_cur."!mark_push"(0, rx423_pos, $I10)
  rxscan427_done:
.annotate 'line', 249
  # rx subcapture "sym"
    set_addr $I10, rxcap_428_fail
    rx423_cur."!mark_push"(0, rx423_pos, $I10)
  # rx literal  "if"
    add $I11, rx423_pos, 2
    gt $I11, rx423_eos, rx423_fail
    sub $I11, rx423_pos, rx423_off
    substr $S10, rx423_tgt, $I11, 2
    ne $S10, "if", rx423_fail
    add rx423_pos, 2
    set_addr $I10, rxcap_428_fail
    ($I12, $I11) = rx423_cur."!mark_peek"($I10)
    rx423_cur."!cursor_pos"($I11)
    ($P10) = rx423_cur."!cursor_start"()
    $P10."!cursor_pass"(rx423_pos, "")
    rx423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_428_done
  rxcap_428_fail:
    goto rx423_fail
  rxcap_428_done:
  # rx subrule "ws" subtype=method negate=
    rx423_cur."!cursor_pos"(rx423_pos)
    $P10 = rx423_cur."ws"()
    unless $P10, rx423_fail
    rx423_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx423_cur."!cursor_pos"(rx423_pos)
    $P10 = rx423_cur."EXPR"()
    unless $P10, rx423_fail
    rx423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx423_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx423_cur."!cursor_pos"(rx423_pos)
    $P10 = rx423_cur."ws"()
    unless $P10, rx423_fail
    rx423_pos = $P10."pos"()
  # rx pass
    rx423_cur."!cursor_pass"(rx423_pos, "statement_mod_cond:sym<if>")
    if_null rx423_debug, debug_587
    rx423_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx423_pos)
  debug_587:
    .return (rx423_cur)
  rx423_restart:
.annotate 'line', 4
    if_null rx423_debug, debug_588
    rx423_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_588:
  rx423_fail:
    (rx423_rep, rx423_pos, $I10, $P10) = rx423_cur."!mark_fail"(0)
    lt rx423_pos, -1, rx423_done
    eq rx423_pos, -1, rx423_fail
    jump $I10
  rx423_done:
    rx423_cur."!cursor_fail"()
    if_null rx423_debug, debug_589
    rx423_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_589:
    .return (rx423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("92_1300051172.188") :method
.annotate 'line', 4
    $P425 = self."!PREFIX__!subrule"("ws", "if")
    new $P426, "ResizablePMCArray"
    push $P426, $P425
    .return ($P426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("93_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx432_tgt
    .local int rx432_pos
    .local int rx432_off
    .local int rx432_eos
    .local int rx432_rep
    .local pmc rx432_cur
    .local pmc rx432_debug
    (rx432_cur, rx432_pos, rx432_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx432_cur
    .local pmc match
    .lex "$/", match
    length rx432_eos, rx432_tgt
    gt rx432_pos, rx432_eos, rx432_done
    set rx432_off, 0
    lt rx432_pos, 2, rx432_start
    sub rx432_off, rx432_pos, 1
    substr rx432_tgt, rx432_tgt, rx432_off
  rx432_start:
    eq $I10, 1, rx432_restart
    if_null rx432_debug, debug_590
    rx432_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan436_done
    goto rxscan436_scan
  rxscan436_loop:
    (rx432_pos) = rx432_cur."from"()
    inc rx432_pos
    rx432_cur."!cursor_from"(rx432_pos)
    ge rx432_pos, rx432_eos, rxscan436_done
  rxscan436_scan:
    set_addr $I10, rxscan436_loop
    rx432_cur."!mark_push"(0, rx432_pos, $I10)
  rxscan436_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_437_fail
    rx432_cur."!mark_push"(0, rx432_pos, $I10)
  # rx literal  "unless"
    add $I11, rx432_pos, 6
    gt $I11, rx432_eos, rx432_fail
    sub $I11, rx432_pos, rx432_off
    substr $S10, rx432_tgt, $I11, 6
    ne $S10, "unless", rx432_fail
    add rx432_pos, 6
    set_addr $I10, rxcap_437_fail
    ($I12, $I11) = rx432_cur."!mark_peek"($I10)
    rx432_cur."!cursor_pos"($I11)
    ($P10) = rx432_cur."!cursor_start"()
    $P10."!cursor_pass"(rx432_pos, "")
    rx432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_437_done
  rxcap_437_fail:
    goto rx432_fail
  rxcap_437_done:
  # rx subrule "ws" subtype=method negate=
    rx432_cur."!cursor_pos"(rx432_pos)
    $P10 = rx432_cur."ws"()
    unless $P10, rx432_fail
    rx432_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx432_cur."!cursor_pos"(rx432_pos)
    $P10 = rx432_cur."EXPR"()
    unless $P10, rx432_fail
    rx432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx432_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx432_cur."!cursor_pos"(rx432_pos)
    $P10 = rx432_cur."ws"()
    unless $P10, rx432_fail
    rx432_pos = $P10."pos"()
  # rx pass
    rx432_cur."!cursor_pass"(rx432_pos, "statement_mod_cond:sym<unless>")
    if_null rx432_debug, debug_591
    rx432_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx432_pos)
  debug_591:
    .return (rx432_cur)
  rx432_restart:
.annotate 'line', 4
    if_null rx432_debug, debug_592
    rx432_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_592:
  rx432_fail:
    (rx432_rep, rx432_pos, $I10, $P10) = rx432_cur."!mark_fail"(0)
    lt rx432_pos, -1, rx432_done
    eq rx432_pos, -1, rx432_fail
    jump $I10
  rx432_done:
    rx432_cur."!cursor_fail"()
    if_null rx432_debug, debug_593
    rx432_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_593:
    .return (rx432_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("94_1300051172.188") :method
.annotate 'line', 4
    $P434 = self."!PREFIX__!subrule"("ws", "unless")
    new $P435, "ResizablePMCArray"
    push $P435, $P434
    .return ($P435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("95_1300051172.188")
    .param pmc param_441
.annotate 'line', 252
    .lex "self", param_441
    $P442 = param_441."!protoregex"("statement_mod_loop")
    .return ($P442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("96_1300051172.188")
    .param pmc param_444
.annotate 'line', 252
    .lex "self", param_444
    $P445 = param_444."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("97_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx447_tgt
    .local int rx447_pos
    .local int rx447_off
    .local int rx447_eos
    .local int rx447_rep
    .local pmc rx447_cur
    .local pmc rx447_debug
    (rx447_cur, rx447_pos, rx447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx447_cur
    .local pmc match
    .lex "$/", match
    length rx447_eos, rx447_tgt
    gt rx447_pos, rx447_eos, rx447_done
    set rx447_off, 0
    lt rx447_pos, 2, rx447_start
    sub rx447_off, rx447_pos, 1
    substr rx447_tgt, rx447_tgt, rx447_off
  rx447_start:
    eq $I10, 1, rx447_restart
    if_null rx447_debug, debug_594
    rx447_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan451_done
    goto rxscan451_scan
  rxscan451_loop:
    (rx447_pos) = rx447_cur."from"()
    inc rx447_pos
    rx447_cur."!cursor_from"(rx447_pos)
    ge rx447_pos, rx447_eos, rxscan451_done
  rxscan451_scan:
    set_addr $I10, rxscan451_loop
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  rxscan451_done:
.annotate 'line', 254
  # rx subcapture "sym"
    set_addr $I10, rxcap_452_fail
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  # rx literal  "while"
    add $I11, rx447_pos, 5
    gt $I11, rx447_eos, rx447_fail
    sub $I11, rx447_pos, rx447_off
    substr $S10, rx447_tgt, $I11, 5
    ne $S10, "while", rx447_fail
    add rx447_pos, 5
    set_addr $I10, rxcap_452_fail
    ($I12, $I11) = rx447_cur."!mark_peek"($I10)
    rx447_cur."!cursor_pos"($I11)
    ($P10) = rx447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx447_pos, "")
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_452_done
  rxcap_452_fail:
    goto rx447_fail
  rxcap_452_done:
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."EXPR"()
    unless $P10, rx447_fail
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx447_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx pass
    rx447_cur."!cursor_pass"(rx447_pos, "statement_mod_loop:sym<while>")
    if_null rx447_debug, debug_595
    rx447_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx447_pos)
  debug_595:
    .return (rx447_cur)
  rx447_restart:
.annotate 'line', 4
    if_null rx447_debug, debug_596
    rx447_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_596:
  rx447_fail:
    (rx447_rep, rx447_pos, $I10, $P10) = rx447_cur."!mark_fail"(0)
    lt rx447_pos, -1, rx447_done
    eq rx447_pos, -1, rx447_fail
    jump $I10
  rx447_done:
    rx447_cur."!cursor_fail"()
    if_null rx447_debug, debug_597
    rx447_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_597:
    .return (rx447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("98_1300051172.188") :method
.annotate 'line', 4
    $P449 = self."!PREFIX__!subrule"("ws", "while")
    new $P450, "ResizablePMCArray"
    push $P450, $P449
    .return ($P450)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("99_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx456_tgt
    .local int rx456_pos
    .local int rx456_off
    .local int rx456_eos
    .local int rx456_rep
    .local pmc rx456_cur
    .local pmc rx456_debug
    (rx456_cur, rx456_pos, rx456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx456_cur
    .local pmc match
    .lex "$/", match
    length rx456_eos, rx456_tgt
    gt rx456_pos, rx456_eos, rx456_done
    set rx456_off, 0
    lt rx456_pos, 2, rx456_start
    sub rx456_off, rx456_pos, 1
    substr rx456_tgt, rx456_tgt, rx456_off
  rx456_start:
    eq $I10, 1, rx456_restart
    if_null rx456_debug, debug_598
    rx456_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan460_done
    goto rxscan460_scan
  rxscan460_loop:
    (rx456_pos) = rx456_cur."from"()
    inc rx456_pos
    rx456_cur."!cursor_from"(rx456_pos)
    ge rx456_pos, rx456_eos, rxscan460_done
  rxscan460_scan:
    set_addr $I10, rxscan460_loop
    rx456_cur."!mark_push"(0, rx456_pos, $I10)
  rxscan460_done:
.annotate 'line', 255
  # rx subcapture "sym"
    set_addr $I10, rxcap_461_fail
    rx456_cur."!mark_push"(0, rx456_pos, $I10)
  # rx literal  "until"
    add $I11, rx456_pos, 5
    gt $I11, rx456_eos, rx456_fail
    sub $I11, rx456_pos, rx456_off
    substr $S10, rx456_tgt, $I11, 5
    ne $S10, "until", rx456_fail
    add rx456_pos, 5
    set_addr $I10, rxcap_461_fail
    ($I12, $I11) = rx456_cur."!mark_peek"($I10)
    rx456_cur."!cursor_pos"($I11)
    ($P10) = rx456_cur."!cursor_start"()
    $P10."!cursor_pass"(rx456_pos, "")
    rx456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_461_done
  rxcap_461_fail:
    goto rx456_fail
  rxcap_461_done:
  # rx subrule "ws" subtype=method negate=
    rx456_cur."!cursor_pos"(rx456_pos)
    $P10 = rx456_cur."ws"()
    unless $P10, rx456_fail
    rx456_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx456_cur."!cursor_pos"(rx456_pos)
    $P10 = rx456_cur."EXPR"()
    unless $P10, rx456_fail
    rx456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx456_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx456_cur."!cursor_pos"(rx456_pos)
    $P10 = rx456_cur."ws"()
    unless $P10, rx456_fail
    rx456_pos = $P10."pos"()
  # rx pass
    rx456_cur."!cursor_pass"(rx456_pos, "statement_mod_loop:sym<until>")
    if_null rx456_debug, debug_599
    rx456_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx456_pos)
  debug_599:
    .return (rx456_cur)
  rx456_restart:
.annotate 'line', 4
    if_null rx456_debug, debug_600
    rx456_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_600:
  rx456_fail:
    (rx456_rep, rx456_pos, $I10, $P10) = rx456_cur."!mark_fail"(0)
    lt rx456_pos, -1, rx456_done
    eq rx456_pos, -1, rx456_fail
    jump $I10
  rx456_done:
    rx456_cur."!cursor_fail"()
    if_null rx456_debug, debug_601
    rx456_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_601:
    .return (rx456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("100_1300051172.188") :method
.annotate 'line', 4
    $P458 = self."!PREFIX__!subrule"("ws", "until")
    new $P459, "ResizablePMCArray"
    push $P459, $P458
    .return ($P459)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("101_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx465_tgt
    .local int rx465_pos
    .local int rx465_off
    .local int rx465_eos
    .local int rx465_rep
    .local pmc rx465_cur
    .local pmc rx465_debug
    (rx465_cur, rx465_pos, rx465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx465_cur
    .local pmc match
    .lex "$/", match
    length rx465_eos, rx465_tgt
    gt rx465_pos, rx465_eos, rx465_done
    set rx465_off, 0
    lt rx465_pos, 2, rx465_start
    sub rx465_off, rx465_pos, 1
    substr rx465_tgt, rx465_tgt, rx465_off
  rx465_start:
    eq $I10, 1, rx465_restart
    if_null rx465_debug, debug_602
    rx465_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan469_done
    goto rxscan469_scan
  rxscan469_loop:
    (rx465_pos) = rx465_cur."from"()
    inc rx465_pos
    rx465_cur."!cursor_from"(rx465_pos)
    ge rx465_pos, rx465_eos, rxscan469_done
  rxscan469_scan:
    set_addr $I10, rxscan469_loop
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  rxscan469_done:
.annotate 'line', 256
  # rx subcapture "sym"
    set_addr $I10, rxcap_470_fail
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  # rx literal  "for"
    add $I11, rx465_pos, 3
    gt $I11, rx465_eos, rx465_fail
    sub $I11, rx465_pos, rx465_off
    substr $S10, rx465_tgt, $I11, 3
    ne $S10, "for", rx465_fail
    add rx465_pos, 3
    set_addr $I10, rxcap_470_fail
    ($I12, $I11) = rx465_cur."!mark_peek"($I10)
    rx465_cur."!cursor_pos"($I11)
    ($P10) = rx465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx465_pos, "")
    rx465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_470_done
  rxcap_470_fail:
    goto rx465_fail
  rxcap_470_done:
  # rx subrule "ws" subtype=method negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."ws"()
    unless $P10, rx465_fail
    rx465_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."EXPR"()
    unless $P10, rx465_fail
    rx465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx465_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."ws"()
    unless $P10, rx465_fail
    rx465_pos = $P10."pos"()
  # rx pass
    rx465_cur."!cursor_pass"(rx465_pos, "statement_mod_loop:sym<for>")
    if_null rx465_debug, debug_603
    rx465_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx465_pos)
  debug_603:
    .return (rx465_cur)
  rx465_restart:
.annotate 'line', 4
    if_null rx465_debug, debug_604
    rx465_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_604:
  rx465_fail:
    (rx465_rep, rx465_pos, $I10, $P10) = rx465_cur."!mark_fail"(0)
    lt rx465_pos, -1, rx465_done
    eq rx465_pos, -1, rx465_fail
    jump $I10
  rx465_done:
    rx465_cur."!cursor_fail"()
    if_null rx465_debug, debug_605
    rx465_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_605:
    .return (rx465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("102_1300051172.188") :method
.annotate 'line', 4
    $P467 = self."!PREFIX__!subrule"("ws", "for")
    new $P468, "ResizablePMCArray"
    push $P468, $P467
    .return ($P468)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("103_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx474_tgt
    .local int rx474_pos
    .local int rx474_off
    .local int rx474_eos
    .local int rx474_rep
    .local pmc rx474_cur
    .local pmc rx474_debug
    (rx474_cur, rx474_pos, rx474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx474_cur
    .local pmc match
    .lex "$/", match
    length rx474_eos, rx474_tgt
    gt rx474_pos, rx474_eos, rx474_done
    set rx474_off, 0
    lt rx474_pos, 2, rx474_start
    sub rx474_off, rx474_pos, 1
    substr rx474_tgt, rx474_tgt, rx474_off
  rx474_start:
    eq $I10, 1, rx474_restart
    if_null rx474_debug, debug_606
    rx474_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan478_done
    goto rxscan478_scan
  rxscan478_loop:
    (rx474_pos) = rx474_cur."from"()
    inc rx474_pos
    rx474_cur."!cursor_from"(rx474_pos)
    ge rx474_pos, rx474_eos, rxscan478_done
  rxscan478_scan:
    set_addr $I10, rxscan478_loop
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  rxscan478_done:
.annotate 'line', 260
  # rx subrule "fatarrow" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."fatarrow"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx474_pos = $P10."pos"()
  # rx pass
    rx474_cur."!cursor_pass"(rx474_pos, "term:sym<fatarrow>")
    if_null rx474_debug, debug_607
    rx474_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx474_pos)
  debug_607:
    .return (rx474_cur)
  rx474_restart:
.annotate 'line', 4
    if_null rx474_debug, debug_608
    rx474_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_608:
  rx474_fail:
    (rx474_rep, rx474_pos, $I10, $P10) = rx474_cur."!mark_fail"(0)
    lt rx474_pos, -1, rx474_done
    eq rx474_pos, -1, rx474_fail
    jump $I10
  rx474_done:
    rx474_cur."!cursor_fail"()
    if_null rx474_debug, debug_609
    rx474_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_609:
    .return (rx474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("104_1300051172.188") :method
.annotate 'line', 4
    $P476 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P477, "ResizablePMCArray"
    push $P477, $P476
    .return ($P477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("105_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx480_tgt
    .local int rx480_pos
    .local int rx480_off
    .local int rx480_eos
    .local int rx480_rep
    .local pmc rx480_cur
    .local pmc rx480_debug
    (rx480_cur, rx480_pos, rx480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx480_cur
    .local pmc match
    .lex "$/", match
    length rx480_eos, rx480_tgt
    gt rx480_pos, rx480_eos, rx480_done
    set rx480_off, 0
    lt rx480_pos, 2, rx480_start
    sub rx480_off, rx480_pos, 1
    substr rx480_tgt, rx480_tgt, rx480_off
  rx480_start:
    eq $I10, 1, rx480_restart
    if_null rx480_debug, debug_610
    rx480_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan484_done
    goto rxscan484_scan
  rxscan484_loop:
    (rx480_pos) = rx480_cur."from"()
    inc rx480_pos
    rx480_cur."!cursor_from"(rx480_pos)
    ge rx480_pos, rx480_eos, rxscan484_done
  rxscan484_scan:
    set_addr $I10, rxscan484_loop
    rx480_cur."!mark_push"(0, rx480_pos, $I10)
  rxscan484_done:
.annotate 'line', 261
  # rx subrule "colonpair" subtype=capture negate=
    rx480_cur."!cursor_pos"(rx480_pos)
    $P10 = rx480_cur."colonpair"()
    unless $P10, rx480_fail
    rx480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx480_pos = $P10."pos"()
  # rx pass
    rx480_cur."!cursor_pass"(rx480_pos, "term:sym<colonpair>")
    if_null rx480_debug, debug_611
    rx480_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx480_pos)
  debug_611:
    .return (rx480_cur)
  rx480_restart:
.annotate 'line', 4
    if_null rx480_debug, debug_612
    rx480_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_612:
  rx480_fail:
    (rx480_rep, rx480_pos, $I10, $P10) = rx480_cur."!mark_fail"(0)
    lt rx480_pos, -1, rx480_done
    eq rx480_pos, -1, rx480_fail
    jump $I10
  rx480_done:
    rx480_cur."!cursor_fail"()
    if_null rx480_debug, debug_613
    rx480_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_613:
    .return (rx480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("106_1300051172.188") :method
.annotate 'line', 4
    $P482 = self."!PREFIX__!subrule"("colonpair", "")
    new $P483, "ResizablePMCArray"
    push $P483, $P482
    .return ($P483)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("107_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx486_tgt
    .local int rx486_pos
    .local int rx486_off
    .local int rx486_eos
    .local int rx486_rep
    .local pmc rx486_cur
    .local pmc rx486_debug
    (rx486_cur, rx486_pos, rx486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx486_cur
    .local pmc match
    .lex "$/", match
    length rx486_eos, rx486_tgt
    gt rx486_pos, rx486_eos, rx486_done
    set rx486_off, 0
    lt rx486_pos, 2, rx486_start
    sub rx486_off, rx486_pos, 1
    substr rx486_tgt, rx486_tgt, rx486_off
  rx486_start:
    eq $I10, 1, rx486_restart
    if_null rx486_debug, debug_614
    rx486_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan490_done
    goto rxscan490_scan
  rxscan490_loop:
    (rx486_pos) = rx486_cur."from"()
    inc rx486_pos
    rx486_cur."!cursor_from"(rx486_pos)
    ge rx486_pos, rx486_eos, rxscan490_done
  rxscan490_scan:
    set_addr $I10, rxscan490_loop
    rx486_cur."!mark_push"(0, rx486_pos, $I10)
  rxscan490_done:
.annotate 'line', 262
  # rx subrule "variable" subtype=capture negate=
    rx486_cur."!cursor_pos"(rx486_pos)
    $P10 = rx486_cur."variable"()
    unless $P10, rx486_fail
    rx486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx486_pos = $P10."pos"()
  # rx pass
    rx486_cur."!cursor_pass"(rx486_pos, "term:sym<variable>")
    if_null rx486_debug, debug_615
    rx486_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx486_pos)
  debug_615:
    .return (rx486_cur)
  rx486_restart:
.annotate 'line', 4
    if_null rx486_debug, debug_616
    rx486_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_616:
  rx486_fail:
    (rx486_rep, rx486_pos, $I10, $P10) = rx486_cur."!mark_fail"(0)
    lt rx486_pos, -1, rx486_done
    eq rx486_pos, -1, rx486_fail
    jump $I10
  rx486_done:
    rx486_cur."!cursor_fail"()
    if_null rx486_debug, debug_617
    rx486_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_617:
    .return (rx486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("108_1300051172.188") :method
.annotate 'line', 4
    $P488 = self."!PREFIX__!subrule"("variable", "")
    new $P489, "ResizablePMCArray"
    push $P489, $P488
    .return ($P489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("109_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx492_tgt
    .local int rx492_pos
    .local int rx492_off
    .local int rx492_eos
    .local int rx492_rep
    .local pmc rx492_cur
    .local pmc rx492_debug
    (rx492_cur, rx492_pos, rx492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx492_cur
    .local pmc match
    .lex "$/", match
    length rx492_eos, rx492_tgt
    gt rx492_pos, rx492_eos, rx492_done
    set rx492_off, 0
    lt rx492_pos, 2, rx492_start
    sub rx492_off, rx492_pos, 1
    substr rx492_tgt, rx492_tgt, rx492_off
  rx492_start:
    eq $I10, 1, rx492_restart
    if_null rx492_debug, debug_618
    rx492_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan496_done
    goto rxscan496_scan
  rxscan496_loop:
    (rx492_pos) = rx492_cur."from"()
    inc rx492_pos
    rx492_cur."!cursor_from"(rx492_pos)
    ge rx492_pos, rx492_eos, rxscan496_done
  rxscan496_scan:
    set_addr $I10, rxscan496_loop
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  rxscan496_done:
.annotate 'line', 263
  # rx subrule "package_declarator" subtype=capture negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."package_declarator"()
    unless $P10, rx492_fail
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx492_pos = $P10."pos"()
  # rx pass
    rx492_cur."!cursor_pass"(rx492_pos, "term:sym<package_declarator>")
    if_null rx492_debug, debug_619
    rx492_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx492_pos)
  debug_619:
    .return (rx492_cur)
  rx492_restart:
.annotate 'line', 4
    if_null rx492_debug, debug_620
    rx492_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_620:
  rx492_fail:
    (rx492_rep, rx492_pos, $I10, $P10) = rx492_cur."!mark_fail"(0)
    lt rx492_pos, -1, rx492_done
    eq rx492_pos, -1, rx492_fail
    jump $I10
  rx492_done:
    rx492_cur."!cursor_fail"()
    if_null rx492_debug, debug_621
    rx492_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_621:
    .return (rx492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("110_1300051172.188") :method
.annotate 'line', 4
    $P494 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P495, "ResizablePMCArray"
    push $P495, $P494
    .return ($P495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("111_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx498_tgt
    .local int rx498_pos
    .local int rx498_off
    .local int rx498_eos
    .local int rx498_rep
    .local pmc rx498_cur
    .local pmc rx498_debug
    (rx498_cur, rx498_pos, rx498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx498_cur
    .local pmc match
    .lex "$/", match
    length rx498_eos, rx498_tgt
    gt rx498_pos, rx498_eos, rx498_done
    set rx498_off, 0
    lt rx498_pos, 2, rx498_start
    sub rx498_off, rx498_pos, 1
    substr rx498_tgt, rx498_tgt, rx498_off
  rx498_start:
    eq $I10, 1, rx498_restart
    if_null rx498_debug, debug_622
    rx498_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan502_done
    goto rxscan502_scan
  rxscan502_loop:
    (rx498_pos) = rx498_cur."from"()
    inc rx498_pos
    rx498_cur."!cursor_from"(rx498_pos)
    ge rx498_pos, rx498_eos, rxscan502_done
  rxscan502_scan:
    set_addr $I10, rxscan502_loop
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  rxscan502_done:
.annotate 'line', 264
  # rx subrule "scope_declarator" subtype=capture negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."scope_declarator"()
    unless $P10, rx498_fail
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx498_pos = $P10."pos"()
  # rx pass
    rx498_cur."!cursor_pass"(rx498_pos, "term:sym<scope_declarator>")
    if_null rx498_debug, debug_623
    rx498_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx498_pos)
  debug_623:
    .return (rx498_cur)
  rx498_restart:
.annotate 'line', 4
    if_null rx498_debug, debug_624
    rx498_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_624:
  rx498_fail:
    (rx498_rep, rx498_pos, $I10, $P10) = rx498_cur."!mark_fail"(0)
    lt rx498_pos, -1, rx498_done
    eq rx498_pos, -1, rx498_fail
    jump $I10
  rx498_done:
    rx498_cur."!cursor_fail"()
    if_null rx498_debug, debug_625
    rx498_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_625:
    .return (rx498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("112_1300051172.188") :method
.annotate 'line', 4
    $P500 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P501, "ResizablePMCArray"
    push $P501, $P500
    .return ($P501)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("113_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx504_tgt
    .local int rx504_pos
    .local int rx504_off
    .local int rx504_eos
    .local int rx504_rep
    .local pmc rx504_cur
    .local pmc rx504_debug
    (rx504_cur, rx504_pos, rx504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx504_cur
    .local pmc match
    .lex "$/", match
    length rx504_eos, rx504_tgt
    gt rx504_pos, rx504_eos, rx504_done
    set rx504_off, 0
    lt rx504_pos, 2, rx504_start
    sub rx504_off, rx504_pos, 1
    substr rx504_tgt, rx504_tgt, rx504_off
  rx504_start:
    eq $I10, 1, rx504_restart
    if_null rx504_debug, debug_626
    rx504_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan508_done
    goto rxscan508_scan
  rxscan508_loop:
    (rx504_pos) = rx504_cur."from"()
    inc rx504_pos
    rx504_cur."!cursor_from"(rx504_pos)
    ge rx504_pos, rx504_eos, rxscan508_done
  rxscan508_scan:
    set_addr $I10, rxscan508_loop
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  rxscan508_done:
.annotate 'line', 265
  # rx subrule "routine_declarator" subtype=capture negate=
    rx504_cur."!cursor_pos"(rx504_pos)
    $P10 = rx504_cur."routine_declarator"()
    unless $P10, rx504_fail
    rx504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx504_pos = $P10."pos"()
  # rx pass
    rx504_cur."!cursor_pass"(rx504_pos, "term:sym<routine_declarator>")
    if_null rx504_debug, debug_627
    rx504_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx504_pos)
  debug_627:
    .return (rx504_cur)
  rx504_restart:
.annotate 'line', 4
    if_null rx504_debug, debug_628
    rx504_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_628:
  rx504_fail:
    (rx504_rep, rx504_pos, $I10, $P10) = rx504_cur."!mark_fail"(0)
    lt rx504_pos, -1, rx504_done
    eq rx504_pos, -1, rx504_fail
    jump $I10
  rx504_done:
    rx504_cur."!cursor_fail"()
    if_null rx504_debug, debug_629
    rx504_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_629:
    .return (rx504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("114_1300051172.188") :method
.annotate 'line', 4
    $P506 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P507, "ResizablePMCArray"
    push $P507, $P506
    .return ($P507)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("115_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P520 = "118_1300051172.188" 
    capture_lex $P520
    .const 'Sub' $P515 = "117_1300051172.188" 
    capture_lex $P515
    .local string rx510_tgt
    .local int rx510_pos
    .local int rx510_off
    .local int rx510_eos
    .local int rx510_rep
    .local pmc rx510_cur
    .local pmc rx510_debug
    (rx510_cur, rx510_pos, rx510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx510_cur
    .local pmc match
    .lex "$/", match
    length rx510_eos, rx510_tgt
    gt rx510_pos, rx510_eos, rx510_done
    set rx510_off, 0
    lt rx510_pos, 2, rx510_start
    sub rx510_off, rx510_pos, 1
    substr rx510_tgt, rx510_tgt, rx510_off
  rx510_start:
    eq $I10, 1, rx510_restart
    if_null rx510_debug, debug_630
    rx510_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    (rx510_pos) = rx510_cur."from"()
    inc rx510_pos
    rx510_cur."!cursor_from"(rx510_pos)
    ge rx510_pos, rx510_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  rxscan513_done:
.annotate 'line', 267
  # rx subrule "before" subtype=zerowidth negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    .const 'Sub' $P515 = "117_1300051172.188" 
    capture_lex $P515
    $P10 = rx510_cur."before"($P515)
    unless $P10, rx510_fail
.annotate 'line', 268
  # rx subrule "before" subtype=zerowidth negate=1
    rx510_cur."!cursor_pos"(rx510_pos)
    .const 'Sub' $P520 = "118_1300051172.188" 
    capture_lex $P520
    $P10 = rx510_cur."before"($P520)
    if $P10, rx510_fail
.annotate 'line', 269
  # rx subrule "multi_declarator" subtype=capture negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."multi_declarator"()
    unless $P10, rx510_fail
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx510_pos = $P10."pos"()
.annotate 'line', 266
  # rx pass
    rx510_cur."!cursor_pass"(rx510_pos, "term:sym<multi_declarator>")
    if_null rx510_debug, debug_639
    rx510_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx510_pos)
  debug_639:
    .return (rx510_cur)
  rx510_restart:
.annotate 'line', 4
    if_null rx510_debug, debug_640
    rx510_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_640:
  rx510_fail:
    (rx510_rep, rx510_pos, $I10, $P10) = rx510_cur."!mark_fail"(0)
    lt rx510_pos, -1, rx510_done
    eq rx510_pos, -1, rx510_fail
    jump $I10
  rx510_done:
    rx510_cur."!cursor_fail"()
    if_null rx510_debug, debug_641
    rx510_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_641:
    .return (rx510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("116_1300051172.188") :method
.annotate 'line', 4
    new $P512, "ResizablePMCArray"
    push $P512, ""
    .return ($P512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block514"  :anon :subid("117_1300051172.188") :method :outer("115_1300051172.188")
.annotate 'line', 267
    .local string rx516_tgt
    .local int rx516_pos
    .local int rx516_off
    .local int rx516_eos
    .local int rx516_rep
    .local pmc rx516_cur
    .local pmc rx516_debug
    (rx516_cur, rx516_pos, rx516_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx516_cur
    .local pmc match
    .lex "$/", match
    length rx516_eos, rx516_tgt
    gt rx516_pos, rx516_eos, rx516_done
    set rx516_off, 0
    lt rx516_pos, 2, rx516_start
    sub rx516_off, rx516_pos, 1
    substr rx516_tgt, rx516_tgt, rx516_off
  rx516_start:
    eq $I10, 1, rx516_restart
    if_null rx516_debug, debug_631
    rx516_cur."!cursor_debug"("START", "")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan517_done
    goto rxscan517_scan
  rxscan517_loop:
    (rx516_pos) = rx516_cur."from"()
    inc rx516_pos
    rx516_cur."!cursor_from"(rx516_pos)
    ge rx516_pos, rx516_eos, rxscan517_done
  rxscan517_scan:
    set_addr $I10, rxscan517_loop
    rx516_cur."!mark_push"(0, rx516_pos, $I10)
  rxscan517_done:
  alt518_0:
    set_addr $I10, alt518_1
    rx516_cur."!mark_push"(0, rx516_pos, $I10)
  # rx literal  "multi"
    add $I11, rx516_pos, 5
    gt $I11, rx516_eos, rx516_fail
    sub $I11, rx516_pos, rx516_off
    substr $S10, rx516_tgt, $I11, 5
    ne $S10, "multi", rx516_fail
    add rx516_pos, 5
    goto alt518_end
  alt518_1:
    set_addr $I10, alt518_2
    rx516_cur."!mark_push"(0, rx516_pos, $I10)
  # rx literal  "proto"
    add $I11, rx516_pos, 5
    gt $I11, rx516_eos, rx516_fail
    sub $I11, rx516_pos, rx516_off
    substr $S10, rx516_tgt, $I11, 5
    ne $S10, "proto", rx516_fail
    add rx516_pos, 5
    goto alt518_end
  alt518_2:
  # rx literal  "only"
    add $I11, rx516_pos, 4
    gt $I11, rx516_eos, rx516_fail
    sub $I11, rx516_pos, rx516_off
    substr $S10, rx516_tgt, $I11, 4
    ne $S10, "only", rx516_fail
    add rx516_pos, 4
  alt518_end:
  # rx pass
    rx516_cur."!cursor_pass"(rx516_pos, "")
    if_null rx516_debug, debug_632
    rx516_cur."!cursor_debug"("PASS", "", " at pos=", rx516_pos)
  debug_632:
    .return (rx516_cur)
  rx516_restart:
    if_null rx516_debug, debug_633
    rx516_cur."!cursor_debug"("NEXT", "")
  debug_633:
  rx516_fail:
    (rx516_rep, rx516_pos, $I10, $P10) = rx516_cur."!mark_fail"(0)
    lt rx516_pos, -1, rx516_done
    eq rx516_pos, -1, rx516_fail
    jump $I10
  rx516_done:
    rx516_cur."!cursor_fail"()
    if_null rx516_debug, debug_634
    rx516_cur."!cursor_debug"("FAIL", "")
  debug_634:
    .return (rx516_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block519"  :anon :subid("118_1300051172.188") :method :outer("115_1300051172.188")
.annotate 'line', 268
    .local string rx521_tgt
    .local int rx521_pos
    .local int rx521_off
    .local int rx521_eos
    .local int rx521_rep
    .local pmc rx521_cur
    .local pmc rx521_debug
    (rx521_cur, rx521_pos, rx521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx521_cur
    .local pmc match
    .lex "$/", match
    length rx521_eos, rx521_tgt
    gt rx521_pos, rx521_eos, rx521_done
    set rx521_off, 0
    lt rx521_pos, 2, rx521_start
    sub rx521_off, rx521_pos, 1
    substr rx521_tgt, rx521_tgt, rx521_off
  rx521_start:
    eq $I10, 1, rx521_restart
    if_null rx521_debug, debug_635
    rx521_cur."!cursor_debug"("START", "")
  debug_635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan522_done
    goto rxscan522_scan
  rxscan522_loop:
    (rx521_pos) = rx521_cur."from"()
    inc rx521_pos
    rx521_cur."!cursor_from"(rx521_pos)
    ge rx521_pos, rx521_eos, rxscan522_done
  rxscan522_scan:
    set_addr $I10, rxscan522_loop
    rx521_cur."!mark_push"(0, rx521_pos, $I10)
  rxscan522_done:
  # rx literal  "proto"
    add $I11, rx521_pos, 5
    gt $I11, rx521_eos, rx521_fail
    sub $I11, rx521_pos, rx521_off
    substr $S10, rx521_tgt, $I11, 5
    ne $S10, "proto", rx521_fail
    add rx521_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx521_cur."!cursor_pos"(rx521_pos)
    $P10 = rx521_cur."ws"()
    unless $P10, rx521_fail
    rx521_pos = $P10."pos"()
  alt523_0:
    set_addr $I10, alt523_1
    rx521_cur."!mark_push"(0, rx521_pos, $I10)
  # rx literal  "regex"
    add $I11, rx521_pos, 5
    gt $I11, rx521_eos, rx521_fail
    sub $I11, rx521_pos, rx521_off
    substr $S10, rx521_tgt, $I11, 5
    ne $S10, "regex", rx521_fail
    add rx521_pos, 5
    goto alt523_end
  alt523_1:
    set_addr $I10, alt523_2
    rx521_cur."!mark_push"(0, rx521_pos, $I10)
  # rx literal  "token"
    add $I11, rx521_pos, 5
    gt $I11, rx521_eos, rx521_fail
    sub $I11, rx521_pos, rx521_off
    substr $S10, rx521_tgt, $I11, 5
    ne $S10, "token", rx521_fail
    add rx521_pos, 5
    goto alt523_end
  alt523_2:
  # rx literal  "rule"
    add $I11, rx521_pos, 4
    gt $I11, rx521_eos, rx521_fail
    sub $I11, rx521_pos, rx521_off
    substr $S10, rx521_tgt, $I11, 4
    ne $S10, "rule", rx521_fail
    add rx521_pos, 4
  alt523_end:
  # rx pass
    rx521_cur."!cursor_pass"(rx521_pos, "")
    if_null rx521_debug, debug_636
    rx521_cur."!cursor_debug"("PASS", "", " at pos=", rx521_pos)
  debug_636:
    .return (rx521_cur)
  rx521_restart:
    if_null rx521_debug, debug_637
    rx521_cur."!cursor_debug"("NEXT", "")
  debug_637:
  rx521_fail:
    (rx521_rep, rx521_pos, $I10, $P10) = rx521_cur."!mark_fail"(0)
    lt rx521_pos, -1, rx521_done
    eq rx521_pos, -1, rx521_fail
    jump $I10
  rx521_done:
    rx521_cur."!cursor_fail"()
    if_null rx521_debug, debug_638
    rx521_cur."!cursor_debug"("FAIL", "")
  debug_638:
    .return (rx521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("119_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx525_tgt
    .local int rx525_pos
    .local int rx525_off
    .local int rx525_eos
    .local int rx525_rep
    .local pmc rx525_cur
    .local pmc rx525_debug
    (rx525_cur, rx525_pos, rx525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx525_cur
    .local pmc match
    .lex "$/", match
    length rx525_eos, rx525_tgt
    gt rx525_pos, rx525_eos, rx525_done
    set rx525_off, 0
    lt rx525_pos, 2, rx525_start
    sub rx525_off, rx525_pos, 1
    substr rx525_tgt, rx525_tgt, rx525_off
  rx525_start:
    eq $I10, 1, rx525_restart
    if_null rx525_debug, debug_642
    rx525_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx525_pos) = rx525_cur."from"()
    inc rx525_pos
    rx525_cur."!cursor_from"(rx525_pos)
    ge rx525_pos, rx525_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx525_cur."!mark_push"(0, rx525_pos, $I10)
  rxscan529_done:
.annotate 'line', 271
  # rx subrule "regex_declarator" subtype=capture negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."regex_declarator"()
    unless $P10, rx525_fail
    rx525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx525_pos = $P10."pos"()
  # rx pass
    rx525_cur."!cursor_pass"(rx525_pos, "term:sym<regex_declarator>")
    if_null rx525_debug, debug_643
    rx525_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx525_pos)
  debug_643:
    .return (rx525_cur)
  rx525_restart:
.annotate 'line', 4
    if_null rx525_debug, debug_644
    rx525_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_644:
  rx525_fail:
    (rx525_rep, rx525_pos, $I10, $P10) = rx525_cur."!mark_fail"(0)
    lt rx525_pos, -1, rx525_done
    eq rx525_pos, -1, rx525_fail
    jump $I10
  rx525_done:
    rx525_cur."!cursor_fail"()
    if_null rx525_debug, debug_645
    rx525_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_645:
    .return (rx525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("120_1300051172.188") :method
.annotate 'line', 4
    $P527 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P528, "ResizablePMCArray"
    push $P528, $P527
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("121_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx531_tgt
    .local int rx531_pos
    .local int rx531_off
    .local int rx531_eos
    .local int rx531_rep
    .local pmc rx531_cur
    .local pmc rx531_debug
    (rx531_cur, rx531_pos, rx531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx531_cur
    .local pmc match
    .lex "$/", match
    length rx531_eos, rx531_tgt
    gt rx531_pos, rx531_eos, rx531_done
    set rx531_off, 0
    lt rx531_pos, 2, rx531_start
    sub rx531_off, rx531_pos, 1
    substr rx531_tgt, rx531_tgt, rx531_off
  rx531_start:
    eq $I10, 1, rx531_restart
    if_null rx531_debug, debug_646
    rx531_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan535_done
    goto rxscan535_scan
  rxscan535_loop:
    (rx531_pos) = rx531_cur."from"()
    inc rx531_pos
    rx531_cur."!cursor_from"(rx531_pos)
    ge rx531_pos, rx531_eos, rxscan535_done
  rxscan535_scan:
    set_addr $I10, rxscan535_loop
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  rxscan535_done:
.annotate 'line', 272
  # rx subrule "statement_prefix" subtype=capture negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."statement_prefix"()
    unless $P10, rx531_fail
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx531_pos = $P10."pos"()
  # rx pass
    rx531_cur."!cursor_pass"(rx531_pos, "term:sym<statement_prefix>")
    if_null rx531_debug, debug_647
    rx531_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx531_pos)
  debug_647:
    .return (rx531_cur)
  rx531_restart:
.annotate 'line', 4
    if_null rx531_debug, debug_648
    rx531_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_648:
  rx531_fail:
    (rx531_rep, rx531_pos, $I10, $P10) = rx531_cur."!mark_fail"(0)
    lt rx531_pos, -1, rx531_done
    eq rx531_pos, -1, rx531_fail
    jump $I10
  rx531_done:
    rx531_cur."!cursor_fail"()
    if_null rx531_debug, debug_649
    rx531_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_649:
    .return (rx531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("122_1300051172.188") :method
.annotate 'line', 4
    $P533 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P534, "ResizablePMCArray"
    push $P534, $P533
    .return ($P534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("123_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx537_tgt
    .local int rx537_pos
    .local int rx537_off
    .local int rx537_eos
    .local int rx537_rep
    .local pmc rx537_cur
    .local pmc rx537_debug
    (rx537_cur, rx537_pos, rx537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx537_cur
    .local pmc match
    .lex "$/", match
    length rx537_eos, rx537_tgt
    gt rx537_pos, rx537_eos, rx537_done
    set rx537_off, 0
    lt rx537_pos, 2, rx537_start
    sub rx537_off, rx537_pos, 1
    substr rx537_tgt, rx537_tgt, rx537_off
  rx537_start:
    eq $I10, 1, rx537_restart
    if_null rx537_debug, debug_650
    rx537_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan540_done
    goto rxscan540_scan
  rxscan540_loop:
    (rx537_pos) = rx537_cur."from"()
    inc rx537_pos
    rx537_cur."!cursor_from"(rx537_pos)
    ge rx537_pos, rx537_eos, rxscan540_done
  rxscan540_scan:
    set_addr $I10, rxscan540_loop
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  rxscan540_done:
.annotate 'line', 273
  # rx subrule "lambda" subtype=zerowidth negate=
    rx537_cur."!cursor_pos"(rx537_pos)
    $P10 = rx537_cur."lambda"()
    unless $P10, rx537_fail
  # rx subrule "pblock" subtype=capture negate=
    rx537_cur."!cursor_pos"(rx537_pos)
    $P10 = rx537_cur."pblock"()
    unless $P10, rx537_fail
    rx537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx537_pos = $P10."pos"()
  # rx pass
    rx537_cur."!cursor_pass"(rx537_pos, "term:sym<lambda>")
    if_null rx537_debug, debug_651
    rx537_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx537_pos)
  debug_651:
    .return (rx537_cur)
  rx537_restart:
.annotate 'line', 4
    if_null rx537_debug, debug_652
    rx537_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_652:
  rx537_fail:
    (rx537_rep, rx537_pos, $I10, $P10) = rx537_cur."!mark_fail"(0)
    lt rx537_pos, -1, rx537_done
    eq rx537_pos, -1, rx537_fail
    jump $I10
  rx537_done:
    rx537_cur."!cursor_fail"()
    if_null rx537_debug, debug_653
    rx537_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_653:
    .return (rx537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("124_1300051172.188") :method
.annotate 'line', 4
    new $P539, "ResizablePMCArray"
    push $P539, ""
    .return ($P539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("125_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx542_tgt
    .local int rx542_pos
    .local int rx542_off
    .local int rx542_eos
    .local int rx542_rep
    .local pmc rx542_cur
    .local pmc rx542_debug
    (rx542_cur, rx542_pos, rx542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx542_cur
    .local pmc match
    .lex "$/", match
    length rx542_eos, rx542_tgt
    gt rx542_pos, rx542_eos, rx542_done
    set rx542_off, 0
    lt rx542_pos, 2, rx542_start
    sub rx542_off, rx542_pos, 1
    substr rx542_tgt, rx542_tgt, rx542_off
  rx542_start:
    eq $I10, 1, rx542_restart
    if_null rx542_debug, debug_654
    rx542_cur."!cursor_debug"("START", "fatarrow")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan546_done
    goto rxscan546_scan
  rxscan546_loop:
    (rx542_pos) = rx542_cur."from"()
    inc rx542_pos
    rx542_cur."!cursor_from"(rx542_pos)
    ge rx542_pos, rx542_eos, rxscan546_done
  rxscan546_scan:
    set_addr $I10, rxscan546_loop
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxscan546_done:
.annotate 'line', 276
  # rx subrule "identifier" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."identifier"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx542_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx542_pos, rx542_off
    set rx542_rep, 0
    sub $I12, rx542_eos, rx542_pos
  rxenumcharlistq547_loop:
    le $I12, 0, rxenumcharlistq547_done
    substr $S10, rx542_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq547_done
    inc rx542_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq547_loop
  rxenumcharlistq547_done:
    add rx542_pos, rx542_pos, rx542_rep
  # rx literal  "=>"
    add $I11, rx542_pos, 2
    gt $I11, rx542_eos, rx542_fail
    sub $I11, rx542_pos, rx542_off
    substr $S10, rx542_tgt, $I11, 2
    ne $S10, "=>", rx542_fail
    add rx542_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."ws"()
    unless $P10, rx542_fail
    rx542_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."EXPR"("i=")
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx542_pos = $P10."pos"()
.annotate 'line', 275
  # rx pass
    rx542_cur."!cursor_pass"(rx542_pos, "fatarrow")
    if_null rx542_debug, debug_655
    rx542_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx542_pos)
  debug_655:
    .return (rx542_cur)
  rx542_restart:
.annotate 'line', 4
    if_null rx542_debug, debug_656
    rx542_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_656:
  rx542_fail:
    (rx542_rep, rx542_pos, $I10, $P10) = rx542_cur."!mark_fail"(0)
    lt rx542_pos, -1, rx542_done
    eq rx542_pos, -1, rx542_fail
    jump $I10
  rx542_done:
    rx542_cur."!cursor_fail"()
    if_null rx542_debug, debug_657
    rx542_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_657:
    .return (rx542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("126_1300051172.188") :method
.annotate 'line', 4
    $P544 = self."!PREFIX__!subrule"("identifier", "")
    new $P545, "ResizablePMCArray"
    push $P545, $P544
    .return ($P545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("127_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx549_tgt
    .local int rx549_pos
    .local int rx549_off
    .local int rx549_eos
    .local int rx549_rep
    .local pmc rx549_cur
    .local pmc rx549_debug
    (rx549_cur, rx549_pos, rx549_tgt, $I10) = self."!cursor_start"()
    rx549_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx549_cur
    .local pmc match
    .lex "$/", match
    length rx549_eos, rx549_tgt
    gt rx549_pos, rx549_eos, rx549_done
    set rx549_off, 0
    lt rx549_pos, 2, rx549_start
    sub rx549_off, rx549_pos, 1
    substr rx549_tgt, rx549_tgt, rx549_off
  rx549_start:
    eq $I10, 1, rx549_restart
    if_null rx549_debug, debug_658
    rx549_cur."!cursor_debug"("START", "colonpair")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan555_done
    goto rxscan555_scan
  rxscan555_loop:
    (rx549_pos) = rx549_cur."from"()
    inc rx549_pos
    rx549_cur."!cursor_from"(rx549_pos)
    ge rx549_pos, rx549_eos, rxscan555_done
  rxscan555_scan:
    set_addr $I10, rxscan555_loop
    rx549_cur."!mark_push"(0, rx549_pos, $I10)
  rxscan555_done:
.annotate 'line', 280
  # rx literal  ":"
    add $I11, rx549_pos, 1
    gt $I11, rx549_eos, rx549_fail
    sub $I11, rx549_pos, rx549_off
    ord $I11, rx549_tgt, $I11
    ne $I11, 58, rx549_fail
    add rx549_pos, 1
  alt556_0:
.annotate 'line', 281
    set_addr $I10, alt556_1
    rx549_cur."!mark_push"(0, rx549_pos, $I10)
.annotate 'line', 282
  # rx subcapture "not"
    set_addr $I10, rxcap_557_fail
    rx549_cur."!mark_push"(0, rx549_pos, $I10)
  # rx literal  "!"
    add $I11, rx549_pos, 1
    gt $I11, rx549_eos, rx549_fail
    sub $I11, rx549_pos, rx549_off
    ord $I11, rx549_tgt, $I11
    ne $I11, 33, rx549_fail
    add rx549_pos, 1
    set_addr $I10, rxcap_557_fail
    ($I12, $I11) = rx549_cur."!mark_peek"($I10)
    rx549_cur."!cursor_pos"($I11)
    ($P10) = rx549_cur."!cursor_start"()
    $P10."!cursor_pass"(rx549_pos, "")
    rx549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_557_done
  rxcap_557_fail:
    goto rx549_fail
  rxcap_557_done:
  # rx subrule "identifier" subtype=capture negate=
    rx549_cur."!cursor_pos"(rx549_pos)
    $P10 = rx549_cur."identifier"()
    unless $P10, rx549_fail
    rx549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx549_pos = $P10."pos"()
    goto alt556_end
  alt556_1:
    set_addr $I10, alt556_2
    rx549_cur."!mark_push"(0, rx549_pos, $I10)
.annotate 'line', 283
  # rx subrule "identifier" subtype=capture negate=
    rx549_cur."!cursor_pos"(rx549_pos)
    $P10 = rx549_cur."identifier"()
    unless $P10, rx549_fail
    rx549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx549_pos = $P10."pos"()
  # rx rxquantr558 ** 0..1
    set_addr $I10, rxquantr558_done
    rx549_cur."!mark_push"(0, rx549_pos, $I10)
  rxquantr558_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx549_cur."!cursor_pos"(rx549_pos)
    $P10 = rx549_cur."circumfix"()
    unless $P10, rx549_fail
    goto rxsubrule559_pass
  rxsubrule559_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx549_fail
  rxsubrule559_pass:
    set_addr $I10, rxsubrule559_back
    rx549_cur."!mark_push"(0, rx549_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx549_pos = $P10."pos"()
    set_addr $I10, rxquantr558_done
    (rx549_rep) = rx549_cur."!mark_commit"($I10)
  rxquantr558_done:
    goto alt556_end
  alt556_2:
.annotate 'line', 284
  # rx subrule "circumfix" subtype=capture negate=
    rx549_cur."!cursor_pos"(rx549_pos)
    $P10 = rx549_cur."circumfix"()
    unless $P10, rx549_fail
    rx549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx549_pos = $P10."pos"()
  alt556_end:
.annotate 'line', 279
  # rx pass
    rx549_cur."!cursor_pass"(rx549_pos, "colonpair")
    if_null rx549_debug, debug_659
    rx549_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx549_pos)
  debug_659:
    .return (rx549_cur)
  rx549_restart:
.annotate 'line', 4
    if_null rx549_debug, debug_660
    rx549_cur."!cursor_debug"("NEXT", "colonpair")
  debug_660:
  rx549_fail:
    (rx549_rep, rx549_pos, $I10, $P10) = rx549_cur."!mark_fail"(0)
    lt rx549_pos, -1, rx549_done
    eq rx549_pos, -1, rx549_fail
    jump $I10
  rx549_done:
    rx549_cur."!cursor_fail"()
    if_null rx549_debug, debug_661
    rx549_cur."!cursor_debug"("FAIL", "colonpair")
  debug_661:
    .return (rx549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("128_1300051172.188") :method
.annotate 'line', 4
    $P551 = self."!PREFIX__!subrule"("circumfix", ":")
    $P552 = self."!PREFIX__!subrule"("identifier", ":")
    $P553 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P554, "ResizablePMCArray"
    push $P554, $P551
    push $P554, $P552
    push $P554, $P553
    .return ($P554)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("129_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx561_tgt
    .local int rx561_pos
    .local int rx561_off
    .local int rx561_eos
    .local int rx561_rep
    .local pmc rx561_cur
    .local pmc rx561_debug
    (rx561_cur, rx561_pos, rx561_tgt, $I10) = self."!cursor_start"()
    rx561_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx561_cur
    .local pmc match
    .lex "$/", match
    length rx561_eos, rx561_tgt
    gt rx561_pos, rx561_eos, rx561_done
    set rx561_off, 0
    lt rx561_pos, 2, rx561_start
    sub rx561_off, rx561_pos, 1
    substr rx561_tgt, rx561_tgt, rx561_off
  rx561_start:
    eq $I10, 1, rx561_restart
    if_null rx561_debug, debug_662
    rx561_cur."!cursor_debug"("START", "variable")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan566_done
    goto rxscan566_scan
  rxscan566_loop:
    (rx561_pos) = rx561_cur."from"()
    inc rx561_pos
    rx561_cur."!cursor_from"(rx561_pos)
    ge rx561_pos, rx561_eos, rxscan566_done
  rxscan566_scan:
    set_addr $I10, rxscan566_loop
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  rxscan566_done:
  alt567_0:
.annotate 'line', 288
    set_addr $I10, alt567_1
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
.annotate 'line', 289
  # rx subrule "sigil" subtype=capture negate=
    rx561_cur."!cursor_pos"(rx561_pos)
    $P10 = rx561_cur."sigil"()
    unless $P10, rx561_fail
    rx561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx561_pos = $P10."pos"()
  # rx rxquantr568 ** 0..1
    set_addr $I10, rxquantr568_done
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  rxquantr568_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx561_cur."!cursor_pos"(rx561_pos)
    $P10 = rx561_cur."twigil"()
    unless $P10, rx561_fail
    goto rxsubrule569_pass
  rxsubrule569_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx561_fail
  rxsubrule569_pass:
    set_addr $I10, rxsubrule569_back
    rx561_cur."!mark_push"(0, rx561_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx561_pos = $P10."pos"()
    set_addr $I10, rxquantr568_done
    (rx561_rep) = rx561_cur."!mark_commit"($I10)
  rxquantr568_done:
  # rx subrule "name" subtype=capture negate=
    rx561_cur."!cursor_pos"(rx561_pos)
    $P10 = rx561_cur."name"()
    unless $P10, rx561_fail
    rx561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx561_pos = $P10."pos"()
    goto alt567_end
  alt567_1:
    set_addr $I10, alt567_2
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
.annotate 'line', 290
  # rx subrule "sigil" subtype=capture negate=
    rx561_cur."!cursor_pos"(rx561_pos)
    $P10 = rx561_cur."sigil"()
    unless $P10, rx561_fail
    rx561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx561_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx561_pos, rx561_off
    substr $S10, rx561_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx561_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx561_cur."!cursor_pos"(rx561_pos)
    $P10 = rx561_cur."postcircumfix"()
    unless $P10, rx561_fail
    rx561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx561_pos = $P10."pos"()
    goto alt567_end
  alt567_2:
.annotate 'line', 291
  # rx subcapture "sigil"
    set_addr $I10, rxcap_570_fail
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  # rx literal  "$"
    add $I11, rx561_pos, 1
    gt $I11, rx561_eos, rx561_fail
    sub $I11, rx561_pos, rx561_off
    ord $I11, rx561_tgt, $I11
    ne $I11, 36, rx561_fail
    add rx561_pos, 1
    set_addr $I10, rxcap_570_fail
    ($I12, $I11) = rx561_cur."!mark_peek"($I10)
    rx561_cur."!cursor_pos"($I11)
    ($P10) = rx561_cur."!cursor_start"()
    $P10."!cursor_pass"(rx561_pos, "")
    rx561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_570_done
  rxcap_570_fail:
    goto rx561_fail
  rxcap_570_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_571_fail
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx561_pos, rx561_eos, rx561_fail
    sub $I10, rx561_pos, rx561_off
    substr $S10, rx561_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx561_fail
    inc rx561_pos
    set_addr $I10, rxcap_571_fail
    ($I12, $I11) = rx561_cur."!mark_peek"($I10)
    rx561_cur."!cursor_pos"($I11)
    ($P10) = rx561_cur."!cursor_start"()
    $P10."!cursor_pass"(rx561_pos, "")
    rx561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_571_done
  rxcap_571_fail:
    goto rx561_fail
  rxcap_571_done:
  alt567_end:
.annotate 'line', 288
  # rx pass
    rx561_cur."!cursor_pass"(rx561_pos, "variable")
    if_null rx561_debug, debug_663
    rx561_cur."!cursor_debug"("PASS", "variable", " at pos=", rx561_pos)
  debug_663:
    .return (rx561_cur)
  rx561_restart:
.annotate 'line', 4
    if_null rx561_debug, debug_664
    rx561_cur."!cursor_debug"("NEXT", "variable")
  debug_664:
  rx561_fail:
    (rx561_rep, rx561_pos, $I10, $P10) = rx561_cur."!mark_fail"(0)
    lt rx561_pos, -1, rx561_done
    eq rx561_pos, -1, rx561_fail
    jump $I10
  rx561_done:
    rx561_cur."!cursor_fail"()
    if_null rx561_debug, debug_665
    rx561_cur."!cursor_debug"("FAIL", "variable")
  debug_665:
    .return (rx561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("130_1300051172.188") :method
.annotate 'line', 4
    $P563 = self."!PREFIX__!subrule"("sigil", "")
    $P564 = self."!PREFIX__!subrule"("sigil", "")
    new $P565, "ResizablePMCArray"
    push $P565, "$!"
    push $P565, "$_"
    push $P565, "$/"
    push $P565, $P563
    push $P565, $P564
    .return ($P565)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("131_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx573_tgt
    .local int rx573_pos
    .local int rx573_off
    .local int rx573_eos
    .local int rx573_rep
    .local pmc rx573_cur
    .local pmc rx573_debug
    (rx573_cur, rx573_pos, rx573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx573_cur
    .local pmc match
    .lex "$/", match
    length rx573_eos, rx573_tgt
    gt rx573_pos, rx573_eos, rx573_done
    set rx573_off, 0
    lt rx573_pos, 2, rx573_start
    sub rx573_off, rx573_pos, 1
    substr rx573_tgt, rx573_tgt, rx573_off
  rx573_start:
    eq $I10, 1, rx573_restart
    if_null rx573_debug, debug_666
    rx573_cur."!cursor_debug"("START", "sigil")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan576_done
    goto rxscan576_scan
  rxscan576_loop:
    (rx573_pos) = rx573_cur."from"()
    inc rx573_pos
    rx573_cur."!cursor_from"(rx573_pos)
    ge rx573_pos, rx573_eos, rxscan576_done
  rxscan576_scan:
    set_addr $I10, rxscan576_loop
    rx573_cur."!mark_push"(0, rx573_pos, $I10)
  rxscan576_done:
.annotate 'line', 294
  # rx enumcharlist negate=0 
    ge rx573_pos, rx573_eos, rx573_fail
    sub $I10, rx573_pos, rx573_off
    substr $S10, rx573_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx573_fail
    inc rx573_pos
  # rx pass
    rx573_cur."!cursor_pass"(rx573_pos, "sigil")
    if_null rx573_debug, debug_667
    rx573_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx573_pos)
  debug_667:
    .return (rx573_cur)
  rx573_restart:
.annotate 'line', 4
    if_null rx573_debug, debug_668
    rx573_cur."!cursor_debug"("NEXT", "sigil")
  debug_668:
  rx573_fail:
    (rx573_rep, rx573_pos, $I10, $P10) = rx573_cur."!mark_fail"(0)
    lt rx573_pos, -1, rx573_done
    eq rx573_pos, -1, rx573_fail
    jump $I10
  rx573_done:
    rx573_cur."!cursor_fail"()
    if_null rx573_debug, debug_669
    rx573_cur."!cursor_debug"("FAIL", "sigil")
  debug_669:
    .return (rx573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("132_1300051172.188") :method
.annotate 'line', 4
    new $P575, "ResizablePMCArray"
    push $P575, "&"
    push $P575, "%"
    push $P575, "@"
    push $P575, "$"
    .return ($P575)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("133_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx578_tgt
    .local int rx578_pos
    .local int rx578_off
    .local int rx578_eos
    .local int rx578_rep
    .local pmc rx578_cur
    .local pmc rx578_debug
    (rx578_cur, rx578_pos, rx578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx578_cur
    .local pmc match
    .lex "$/", match
    length rx578_eos, rx578_tgt
    gt rx578_pos, rx578_eos, rx578_done
    set rx578_off, 0
    lt rx578_pos, 2, rx578_start
    sub rx578_off, rx578_pos, 1
    substr rx578_tgt, rx578_tgt, rx578_off
  rx578_start:
    eq $I10, 1, rx578_restart
    if_null rx578_debug, debug_670
    rx578_cur."!cursor_debug"("START", "twigil")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan581_done
    goto rxscan581_scan
  rxscan581_loop:
    (rx578_pos) = rx578_cur."from"()
    inc rx578_pos
    rx578_cur."!cursor_from"(rx578_pos)
    ge rx578_pos, rx578_eos, rxscan581_done
  rxscan581_scan:
    set_addr $I10, rxscan581_loop
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  rxscan581_done:
.annotate 'line', 296
  # rx enumcharlist negate=0 
    ge rx578_pos, rx578_eos, rx578_fail
    sub $I10, rx578_pos, rx578_off
    substr $S10, rx578_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx578_fail
    inc rx578_pos
  # rx pass
    rx578_cur."!cursor_pass"(rx578_pos, "twigil")
    if_null rx578_debug, debug_671
    rx578_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx578_pos)
  debug_671:
    .return (rx578_cur)
  rx578_restart:
.annotate 'line', 4
    if_null rx578_debug, debug_672
    rx578_cur."!cursor_debug"("NEXT", "twigil")
  debug_672:
  rx578_fail:
    (rx578_rep, rx578_pos, $I10, $P10) = rx578_cur."!mark_fail"(0)
    lt rx578_pos, -1, rx578_done
    eq rx578_pos, -1, rx578_fail
    jump $I10
  rx578_done:
    rx578_cur."!cursor_fail"()
    if_null rx578_debug, debug_673
    rx578_cur."!cursor_debug"("FAIL", "twigil")
  debug_673:
    .return (rx578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("134_1300051172.188") :method
.annotate 'line', 4
    new $P580, "ResizablePMCArray"
    push $P580, "?"
    push $P580, "!"
    push $P580, "*"
    .return ($P580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("135_1300051172.188")
    .param pmc param_583
.annotate 'line', 298
    .lex "self", param_583
    $P584 = param_583."!protoregex"("package_declarator")
    .return ($P584)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("136_1300051172.188")
    .param pmc param_586
.annotate 'line', 298
    .lex "self", param_586
    $P587 = param_586."!PREFIX__!protoregex"("package_declarator")
    .return ($P587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("137_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 300
    new $P589, "Undef"
    .lex "$*PACKAGE-SETUP", $P589
.annotate 'line', 301
    new $P590, "Undef"
    .lex "$*PKGDECL", $P590
.annotate 'line', 4
    .local string rx591_tgt
    .local int rx591_pos
    .local int rx591_off
    .local int rx591_eos
    .local int rx591_rep
    .local pmc rx591_cur
    .local pmc rx591_debug
    (rx591_cur, rx591_pos, rx591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx591_cur
    .local pmc match
    .lex "$/", match
    length rx591_eos, rx591_tgt
    gt rx591_pos, rx591_eos, rx591_done
    set rx591_off, 0
    lt rx591_pos, 2, rx591_start
    sub rx591_off, rx591_pos, 1
    substr rx591_tgt, rx591_tgt, rx591_off
  rx591_start:
    eq $I10, 1, rx591_restart
    if_null rx591_debug, debug_674
    rx591_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan595_done
    goto rxscan595_scan
  rxscan595_loop:
    (rx591_pos) = rx591_cur."from"()
    inc rx591_pos
    rx591_cur."!cursor_from"(rx591_pos)
    ge rx591_pos, rx591_eos, rxscan595_done
  rxscan595_scan:
    set_addr $I10, rxscan595_loop
    rx591_cur."!mark_push"(0, rx591_pos, $I10)
  rxscan595_done:
.annotate 'line', 300
    rx591_cur."!cursor_pos"(rx591_pos)
    get_hll_global $P596, ["PAST"], "Stmts"
    $P597 = $P596."new"()
    store_lex "$*PACKAGE-SETUP", $P597
.annotate 'line', 301
    rx591_cur."!cursor_pos"(rx591_pos)
    new $P598, "String"
    assign $P598, "module"
    store_lex "$*PKGDECL", $P598
.annotate 'line', 302
  # rx subcapture "sym"
    set_addr $I10, rxcap_599_fail
    rx591_cur."!mark_push"(0, rx591_pos, $I10)
  # rx literal  "module"
    add $I11, rx591_pos, 6
    gt $I11, rx591_eos, rx591_fail
    sub $I11, rx591_pos, rx591_off
    substr $S10, rx591_tgt, $I11, 6
    ne $S10, "module", rx591_fail
    add rx591_pos, 6
    set_addr $I10, rxcap_599_fail
    ($I12, $I11) = rx591_cur."!mark_peek"($I10)
    rx591_cur."!cursor_pos"($I11)
    ($P10) = rx591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx591_pos, "")
    rx591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_599_done
  rxcap_599_fail:
    goto rx591_fail
  rxcap_599_done:
  # rx subrule "package_def" subtype=capture negate=
    rx591_cur."!cursor_pos"(rx591_pos)
    $P10 = rx591_cur."package_def"()
    unless $P10, rx591_fail
    rx591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx591_pos = $P10."pos"()
.annotate 'line', 299
  # rx pass
    rx591_cur."!cursor_pass"(rx591_pos, "package_declarator:sym<module>")
    if_null rx591_debug, debug_675
    rx591_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx591_pos)
  debug_675:
    .return (rx591_cur)
  rx591_restart:
.annotate 'line', 4
    if_null rx591_debug, debug_676
    rx591_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_676:
  rx591_fail:
    (rx591_rep, rx591_pos, $I10, $P10) = rx591_cur."!mark_fail"(0)
    lt rx591_pos, -1, rx591_done
    eq rx591_pos, -1, rx591_fail
    jump $I10
  rx591_done:
    rx591_cur."!cursor_fail"()
    if_null rx591_debug, debug_677
    rx591_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_677:
    .return (rx591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("138_1300051172.188") :method
.annotate 'line', 4
    $P593 = self."!PREFIX__!subrule"("package_def", "module")
    new $P594, "ResizablePMCArray"
    push $P594, $P593
    .return ($P594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("139_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 305
    new $P601, "Undef"
    .lex "$*PACKAGE-SETUP", $P601
.annotate 'line', 306
    new $P602, "Undef"
    .lex "$*PKGDECL", $P602
.annotate 'line', 4
    .local string rx603_tgt
    .local int rx603_pos
    .local int rx603_off
    .local int rx603_eos
    .local int rx603_rep
    .local pmc rx603_cur
    .local pmc rx603_debug
    (rx603_cur, rx603_pos, rx603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx603_cur
    .local pmc match
    .lex "$/", match
    length rx603_eos, rx603_tgt
    gt rx603_pos, rx603_eos, rx603_done
    set rx603_off, 0
    lt rx603_pos, 2, rx603_start
    sub rx603_off, rx603_pos, 1
    substr rx603_tgt, rx603_tgt, rx603_off
  rx603_start:
    eq $I10, 1, rx603_restart
    if_null rx603_debug, debug_678
    rx603_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan607_done
    goto rxscan607_scan
  rxscan607_loop:
    (rx603_pos) = rx603_cur."from"()
    inc rx603_pos
    rx603_cur."!cursor_from"(rx603_pos)
    ge rx603_pos, rx603_eos, rxscan607_done
  rxscan607_scan:
    set_addr $I10, rxscan607_loop
    rx603_cur."!mark_push"(0, rx603_pos, $I10)
  rxscan607_done:
.annotate 'line', 305
    rx603_cur."!cursor_pos"(rx603_pos)
    get_hll_global $P608, ["PAST"], "Stmts"
    $P609 = $P608."new"()
    store_lex "$*PACKAGE-SETUP", $P609
.annotate 'line', 306
    rx603_cur."!cursor_pos"(rx603_pos)
    new $P610, "String"
    assign $P610, "knowhow"
    store_lex "$*PKGDECL", $P610
.annotate 'line', 307
  # rx subcapture "sym"
    set_addr $I10, rxcap_611_fail
    rx603_cur."!mark_push"(0, rx603_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx603_pos, 7
    gt $I11, rx603_eos, rx603_fail
    sub $I11, rx603_pos, rx603_off
    substr $S10, rx603_tgt, $I11, 7
    ne $S10, "knowhow", rx603_fail
    add rx603_pos, 7
    set_addr $I10, rxcap_611_fail
    ($I12, $I11) = rx603_cur."!mark_peek"($I10)
    rx603_cur."!cursor_pos"($I11)
    ($P10) = rx603_cur."!cursor_start"()
    $P10."!cursor_pass"(rx603_pos, "")
    rx603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_611_done
  rxcap_611_fail:
    goto rx603_fail
  rxcap_611_done:
  # rx subrule "package_def" subtype=capture negate=
    rx603_cur."!cursor_pos"(rx603_pos)
    $P10 = rx603_cur."package_def"()
    unless $P10, rx603_fail
    rx603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx603_pos = $P10."pos"()
.annotate 'line', 304
  # rx pass
    rx603_cur."!cursor_pass"(rx603_pos, "package_declarator:sym<knowhow>")
    if_null rx603_debug, debug_679
    rx603_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx603_pos)
  debug_679:
    .return (rx603_cur)
  rx603_restart:
.annotate 'line', 4
    if_null rx603_debug, debug_680
    rx603_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_680:
  rx603_fail:
    (rx603_rep, rx603_pos, $I10, $P10) = rx603_cur."!mark_fail"(0)
    lt rx603_pos, -1, rx603_done
    eq rx603_pos, -1, rx603_fail
    jump $I10
  rx603_done:
    rx603_cur."!cursor_fail"()
    if_null rx603_debug, debug_681
    rx603_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_681:
    .return (rx603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("140_1300051172.188") :method
.annotate 'line', 4
    $P605 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P606, "ResizablePMCArray"
    push $P606, $P605
    .return ($P606)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("141_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 310
    new $P613, "Undef"
    .lex "$*PACKAGE-SETUP", $P613
.annotate 'line', 311
    new $P614, "Undef"
    .lex "$*PKGDECL", $P614
.annotate 'line', 4
    .local string rx615_tgt
    .local int rx615_pos
    .local int rx615_off
    .local int rx615_eos
    .local int rx615_rep
    .local pmc rx615_cur
    .local pmc rx615_debug
    (rx615_cur, rx615_pos, rx615_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx615_cur
    .local pmc match
    .lex "$/", match
    length rx615_eos, rx615_tgt
    gt rx615_pos, rx615_eos, rx615_done
    set rx615_off, 0
    lt rx615_pos, 2, rx615_start
    sub rx615_off, rx615_pos, 1
    substr rx615_tgt, rx615_tgt, rx615_off
  rx615_start:
    eq $I10, 1, rx615_restart
    if_null rx615_debug, debug_682
    rx615_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan619_done
    goto rxscan619_scan
  rxscan619_loop:
    (rx615_pos) = rx615_cur."from"()
    inc rx615_pos
    rx615_cur."!cursor_from"(rx615_pos)
    ge rx615_pos, rx615_eos, rxscan619_done
  rxscan619_scan:
    set_addr $I10, rxscan619_loop
    rx615_cur."!mark_push"(0, rx615_pos, $I10)
  rxscan619_done:
.annotate 'line', 310
    rx615_cur."!cursor_pos"(rx615_pos)
    get_hll_global $P620, ["PAST"], "Stmts"
    $P621 = $P620."new"()
    store_lex "$*PACKAGE-SETUP", $P621
.annotate 'line', 311
    rx615_cur."!cursor_pos"(rx615_pos)
    new $P622, "String"
    assign $P622, "class"
    store_lex "$*PKGDECL", $P622
.annotate 'line', 312
  # rx subcapture "sym"
    set_addr $I10, rxcap_623_fail
    rx615_cur."!mark_push"(0, rx615_pos, $I10)
  # rx literal  "class"
    add $I11, rx615_pos, 5
    gt $I11, rx615_eos, rx615_fail
    sub $I11, rx615_pos, rx615_off
    substr $S10, rx615_tgt, $I11, 5
    ne $S10, "class", rx615_fail
    add rx615_pos, 5
    set_addr $I10, rxcap_623_fail
    ($I12, $I11) = rx615_cur."!mark_peek"($I10)
    rx615_cur."!cursor_pos"($I11)
    ($P10) = rx615_cur."!cursor_start"()
    $P10."!cursor_pass"(rx615_pos, "")
    rx615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_623_done
  rxcap_623_fail:
    goto rx615_fail
  rxcap_623_done:
  # rx subrule "package_def" subtype=capture negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."package_def"()
    unless $P10, rx615_fail
    rx615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx615_pos = $P10."pos"()
.annotate 'line', 309
  # rx pass
    rx615_cur."!cursor_pass"(rx615_pos, "package_declarator:sym<class>")
    if_null rx615_debug, debug_683
    rx615_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx615_pos)
  debug_683:
    .return (rx615_cur)
  rx615_restart:
.annotate 'line', 4
    if_null rx615_debug, debug_684
    rx615_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_684:
  rx615_fail:
    (rx615_rep, rx615_pos, $I10, $P10) = rx615_cur."!mark_fail"(0)
    lt rx615_pos, -1, rx615_done
    eq rx615_pos, -1, rx615_fail
    jump $I10
  rx615_done:
    rx615_cur."!cursor_fail"()
    if_null rx615_debug, debug_685
    rx615_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_685:
    .return (rx615_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("142_1300051172.188") :method
.annotate 'line', 4
    $P617 = self."!PREFIX__!subrule"("package_def", "class")
    new $P618, "ResizablePMCArray"
    push $P618, $P617
    .return ($P618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("143_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 315
    new $P625, "Undef"
    .lex "$*PACKAGE-SETUP", $P625
.annotate 'line', 316
    new $P626, "Undef"
    .lex "$*PKGDECL", $P626
.annotate 'line', 4
    .local string rx627_tgt
    .local int rx627_pos
    .local int rx627_off
    .local int rx627_eos
    .local int rx627_rep
    .local pmc rx627_cur
    .local pmc rx627_debug
    (rx627_cur, rx627_pos, rx627_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx627_cur
    .local pmc match
    .lex "$/", match
    length rx627_eos, rx627_tgt
    gt rx627_pos, rx627_eos, rx627_done
    set rx627_off, 0
    lt rx627_pos, 2, rx627_start
    sub rx627_off, rx627_pos, 1
    substr rx627_tgt, rx627_tgt, rx627_off
  rx627_start:
    eq $I10, 1, rx627_restart
    if_null rx627_debug, debug_686
    rx627_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan631_done
    goto rxscan631_scan
  rxscan631_loop:
    (rx627_pos) = rx627_cur."from"()
    inc rx627_pos
    rx627_cur."!cursor_from"(rx627_pos)
    ge rx627_pos, rx627_eos, rxscan631_done
  rxscan631_scan:
    set_addr $I10, rxscan631_loop
    rx627_cur."!mark_push"(0, rx627_pos, $I10)
  rxscan631_done:
.annotate 'line', 315
    rx627_cur."!cursor_pos"(rx627_pos)
    get_hll_global $P632, ["PAST"], "Stmts"
    $P633 = $P632."new"()
    store_lex "$*PACKAGE-SETUP", $P633
.annotate 'line', 316
    rx627_cur."!cursor_pos"(rx627_pos)
    new $P634, "String"
    assign $P634, "grammar"
    store_lex "$*PKGDECL", $P634
.annotate 'line', 317
  # rx subcapture "sym"
    set_addr $I10, rxcap_635_fail
    rx627_cur."!mark_push"(0, rx627_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx627_pos, 7
    gt $I11, rx627_eos, rx627_fail
    sub $I11, rx627_pos, rx627_off
    substr $S10, rx627_tgt, $I11, 7
    ne $S10, "grammar", rx627_fail
    add rx627_pos, 7
    set_addr $I10, rxcap_635_fail
    ($I12, $I11) = rx627_cur."!mark_peek"($I10)
    rx627_cur."!cursor_pos"($I11)
    ($P10) = rx627_cur."!cursor_start"()
    $P10."!cursor_pass"(rx627_pos, "")
    rx627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_635_done
  rxcap_635_fail:
    goto rx627_fail
  rxcap_635_done:
  # rx subrule "package_def" subtype=capture negate=
    rx627_cur."!cursor_pos"(rx627_pos)
    $P10 = rx627_cur."package_def"()
    unless $P10, rx627_fail
    rx627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx627_pos = $P10."pos"()
.annotate 'line', 314
  # rx pass
    rx627_cur."!cursor_pass"(rx627_pos, "package_declarator:sym<grammar>")
    if_null rx627_debug, debug_687
    rx627_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx627_pos)
  debug_687:
    .return (rx627_cur)
  rx627_restart:
.annotate 'line', 4
    if_null rx627_debug, debug_688
    rx627_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_688:
  rx627_fail:
    (rx627_rep, rx627_pos, $I10, $P10) = rx627_cur."!mark_fail"(0)
    lt rx627_pos, -1, rx627_done
    eq rx627_pos, -1, rx627_fail
    jump $I10
  rx627_done:
    rx627_cur."!cursor_fail"()
    if_null rx627_debug, debug_689
    rx627_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_689:
    .return (rx627_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("144_1300051172.188") :method
.annotate 'line', 4
    $P629 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P630, "ResizablePMCArray"
    push $P630, $P629
    .return ($P630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("145_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 320
    new $P637, "Undef"
    .lex "$*PACKAGE-SETUP", $P637
.annotate 'line', 321
    new $P638, "Undef"
    .lex "$*PKGDECL", $P638
.annotate 'line', 4
    .local string rx639_tgt
    .local int rx639_pos
    .local int rx639_off
    .local int rx639_eos
    .local int rx639_rep
    .local pmc rx639_cur
    .local pmc rx639_debug
    (rx639_cur, rx639_pos, rx639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx639_cur
    .local pmc match
    .lex "$/", match
    length rx639_eos, rx639_tgt
    gt rx639_pos, rx639_eos, rx639_done
    set rx639_off, 0
    lt rx639_pos, 2, rx639_start
    sub rx639_off, rx639_pos, 1
    substr rx639_tgt, rx639_tgt, rx639_off
  rx639_start:
    eq $I10, 1, rx639_restart
    if_null rx639_debug, debug_690
    rx639_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan643_done
    goto rxscan643_scan
  rxscan643_loop:
    (rx639_pos) = rx639_cur."from"()
    inc rx639_pos
    rx639_cur."!cursor_from"(rx639_pos)
    ge rx639_pos, rx639_eos, rxscan643_done
  rxscan643_scan:
    set_addr $I10, rxscan643_loop
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  rxscan643_done:
.annotate 'line', 320
    rx639_cur."!cursor_pos"(rx639_pos)
    get_hll_global $P644, ["PAST"], "Stmts"
    $P645 = $P644."new"()
    store_lex "$*PACKAGE-SETUP", $P645
.annotate 'line', 321
    rx639_cur."!cursor_pos"(rx639_pos)
    new $P646, "String"
    assign $P646, "role"
    store_lex "$*PKGDECL", $P646
.annotate 'line', 322
  # rx subcapture "sym"
    set_addr $I10, rxcap_647_fail
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  # rx literal  "role"
    add $I11, rx639_pos, 4
    gt $I11, rx639_eos, rx639_fail
    sub $I11, rx639_pos, rx639_off
    substr $S10, rx639_tgt, $I11, 4
    ne $S10, "role", rx639_fail
    add rx639_pos, 4
    set_addr $I10, rxcap_647_fail
    ($I12, $I11) = rx639_cur."!mark_peek"($I10)
    rx639_cur."!cursor_pos"($I11)
    ($P10) = rx639_cur."!cursor_start"()
    $P10."!cursor_pass"(rx639_pos, "")
    rx639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_647_done
  rxcap_647_fail:
    goto rx639_fail
  rxcap_647_done:
  # rx subrule "package_def" subtype=capture negate=
    rx639_cur."!cursor_pos"(rx639_pos)
    $P10 = rx639_cur."package_def"()
    unless $P10, rx639_fail
    rx639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx639_pos = $P10."pos"()
.annotate 'line', 319
  # rx pass
    rx639_cur."!cursor_pass"(rx639_pos, "package_declarator:sym<role>")
    if_null rx639_debug, debug_691
    rx639_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx639_pos)
  debug_691:
    .return (rx639_cur)
  rx639_restart:
.annotate 'line', 4
    if_null rx639_debug, debug_692
    rx639_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_692:
  rx639_fail:
    (rx639_rep, rx639_pos, $I10, $P10) = rx639_cur."!mark_fail"(0)
    lt rx639_pos, -1, rx639_done
    eq rx639_pos, -1, rx639_fail
    jump $I10
  rx639_done:
    rx639_cur."!cursor_fail"()
    if_null rx639_debug, debug_693
    rx639_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_693:
    .return (rx639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("146_1300051172.188") :method
.annotate 'line', 4
    $P641 = self."!PREFIX__!subrule"("package_def", "role")
    new $P642, "ResizablePMCArray"
    push $P642, $P641
    .return ($P642)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("147_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 325
    new $P649, "Undef"
    .lex "$*PACKAGE-SETUP", $P649
.annotate 'line', 326
    new $P650, "Undef"
    .lex "$*PKGDECL", $P650
.annotate 'line', 4
    .local string rx651_tgt
    .local int rx651_pos
    .local int rx651_off
    .local int rx651_eos
    .local int rx651_rep
    .local pmc rx651_cur
    .local pmc rx651_debug
    (rx651_cur, rx651_pos, rx651_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx651_cur
    .local pmc match
    .lex "$/", match
    length rx651_eos, rx651_tgt
    gt rx651_pos, rx651_eos, rx651_done
    set rx651_off, 0
    lt rx651_pos, 2, rx651_start
    sub rx651_off, rx651_pos, 1
    substr rx651_tgt, rx651_tgt, rx651_off
  rx651_start:
    eq $I10, 1, rx651_restart
    if_null rx651_debug, debug_694
    rx651_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan655_done
    goto rxscan655_scan
  rxscan655_loop:
    (rx651_pos) = rx651_cur."from"()
    inc rx651_pos
    rx651_cur."!cursor_from"(rx651_pos)
    ge rx651_pos, rx651_eos, rxscan655_done
  rxscan655_scan:
    set_addr $I10, rxscan655_loop
    rx651_cur."!mark_push"(0, rx651_pos, $I10)
  rxscan655_done:
.annotate 'line', 325
    rx651_cur."!cursor_pos"(rx651_pos)
    get_hll_global $P656, ["PAST"], "Stmts"
    $P657 = $P656."new"()
    store_lex "$*PACKAGE-SETUP", $P657
.annotate 'line', 326
    rx651_cur."!cursor_pos"(rx651_pos)
    new $P658, "String"
    assign $P658, "native"
    store_lex "$*PKGDECL", $P658
.annotate 'line', 327
  # rx subcapture "sym"
    set_addr $I10, rxcap_659_fail
    rx651_cur."!mark_push"(0, rx651_pos, $I10)
  # rx literal  "native"
    add $I11, rx651_pos, 6
    gt $I11, rx651_eos, rx651_fail
    sub $I11, rx651_pos, rx651_off
    substr $S10, rx651_tgt, $I11, 6
    ne $S10, "native", rx651_fail
    add rx651_pos, 6
    set_addr $I10, rxcap_659_fail
    ($I12, $I11) = rx651_cur."!mark_peek"($I10)
    rx651_cur."!cursor_pos"($I11)
    ($P10) = rx651_cur."!cursor_start"()
    $P10."!cursor_pass"(rx651_pos, "")
    rx651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_659_done
  rxcap_659_fail:
    goto rx651_fail
  rxcap_659_done:
  # rx subrule "package_def" subtype=capture negate=
    rx651_cur."!cursor_pos"(rx651_pos)
    $P10 = rx651_cur."package_def"()
    unless $P10, rx651_fail
    rx651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx651_pos = $P10."pos"()
.annotate 'line', 324
  # rx pass
    rx651_cur."!cursor_pass"(rx651_pos, "package_declarator:sym<native>")
    if_null rx651_debug, debug_695
    rx651_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx651_pos)
  debug_695:
    .return (rx651_cur)
  rx651_restart:
.annotate 'line', 4
    if_null rx651_debug, debug_696
    rx651_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_696:
  rx651_fail:
    (rx651_rep, rx651_pos, $I10, $P10) = rx651_cur."!mark_fail"(0)
    lt rx651_pos, -1, rx651_done
    eq rx651_pos, -1, rx651_fail
    jump $I10
  rx651_done:
    rx651_cur."!cursor_fail"()
    if_null rx651_debug, debug_697
    rx651_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_697:
    .return (rx651_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("148_1300051172.188") :method
.annotate 'line', 4
    $P653 = self."!PREFIX__!subrule"("package_def", "native")
    new $P654, "ResizablePMCArray"
    push $P654, $P653
    .return ($P654)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("149_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P684 = "151_1300051172.188" 
    capture_lex $P684
.annotate 'line', 331
    new $P661, "Undef"
    .lex "$*PKGMETA", $P661
.annotate 'line', 332
    $P662 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P662
.annotate 'line', 4
    .local string rx663_tgt
    .local int rx663_pos
    .local int rx663_off
    .local int rx663_eos
    .local int rx663_rep
    .local pmc rx663_cur
    .local pmc rx663_debug
    (rx663_cur, rx663_pos, rx663_tgt, $I10) = self."!cursor_start"()
    rx663_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx663_cur
    .local pmc match
    .lex "$/", match
    length rx663_eos, rx663_tgt
    gt rx663_pos, rx663_eos, rx663_done
    set rx663_off, 0
    lt rx663_pos, 2, rx663_start
    sub rx663_off, rx663_pos, 1
    substr rx663_tgt, rx663_tgt, rx663_off
  rx663_start:
    eq $I10, 1, rx663_restart
    if_null rx663_debug, debug_698
    rx663_cur."!cursor_debug"("START", "package_def")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan667_done
    goto rxscan667_scan
  rxscan667_loop:
    (rx663_pos) = rx663_cur."from"()
    inc rx663_pos
    rx663_cur."!cursor_from"(rx663_pos)
    ge rx663_pos, rx663_eos, rxscan667_done
  rxscan667_scan:
    set_addr $I10, rxscan667_loop
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  rxscan667_done:
.annotate 'line', 330
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 331
    rx663_cur."!cursor_pos"(rx663_pos)
    find_lex $P669, "$*PKGMETA"
    unless_null $P669, vivify_699
    get_hll_global $P669, "$PKGMETA"
    unless_null $P669, vivify_700
    die "Contextual $*PKGMETA not found"
  vivify_700:
  vivify_699:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 332
    rx663_cur."!cursor_pos"(rx663_pos)
    find_lex $P671, "%*ATTR-CHECK"
    unless_null $P671, vivify_701
    get_hll_global $P671, "%ATTR-CHECK"
    unless_null $P671, vivify_702
    die "Contextual %*ATTR-CHECK not found"
  vivify_702:
  vivify_701:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 334
  # rx subrule "name" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."name"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx663_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 335
  # rx rxquantr674 ** 0..1
    set_addr $I10, rxquantr674_done
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  rxquantr674_loop:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx663_pos, 2
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    substr $S10, rx663_tgt, $I11, 2
    ne $S10, "is", rx663_fail
    add rx663_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx663_pos, 5
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    substr $S10, rx663_tgt, $I11, 5
    ne $S10, "repr(", rx663_fail
    add rx663_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."quote_EXPR"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx663_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx663_pos, 1
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    ord $I11, rx663_tgt, $I11
    ne $I11, 41, rx663_fail
    add rx663_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
    set_addr $I10, rxquantr674_done
    (rx663_rep) = rx663_cur."!mark_commit"($I10)
  rxquantr674_done:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 337
    rx663_cur."!cursor_pos"(rx663_pos)
    find_lex $P681, unicode:"$\x{a2}"
    $P682 = $P681."MATCH"()
    store_lex "$/", $P682
    .const 'Sub' $P684 = "151_1300051172.188" 
    capture_lex $P684
    $P710 = $P684()
.annotate 'line', 346
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 348
  # rx rxquantr712 ** 0..1
    set_addr $I10, rxquantr712_done
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  rxquantr712_loop:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx663_pos, 2
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    substr $S10, rx663_tgt, $I11, 2
    ne $S10, "is", rx663_fail
    add rx663_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."name"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx663_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
    set_addr $I10, rxquantr712_done
    (rx663_rep) = rx663_cur."!mark_commit"($I10)
  rxquantr712_done:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 349
  # rx rxquantr717 ** 0..*
    set_addr $I10, rxquantr717_done
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  rxquantr717_loop:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx663_pos, 4
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    substr $S10, rx663_tgt, $I11, 4
    ne $S10, "does", rx663_fail
    add rx663_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."name"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx663_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
    set_addr $I10, rxquantr717_done
    (rx663_rep) = rx663_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr717_done
    rx663_cur."!mark_push"(rx663_rep, rx663_pos, $I10)
    goto rxquantr717_loop
  rxquantr717_done:
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  alt722_0:
.annotate 'line', 350
    set_addr $I10, alt722_1
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
.annotate 'line', 351
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx663_pos, 1
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    ord $I11, rx663_tgt, $I11
    ne $I11, 59, rx663_fail
    add rx663_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."comp_unit"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx663_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
    goto alt722_end
  alt722_1:
    set_addr $I10, alt722_2
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
.annotate 'line', 352
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx663_pos, rx663_off
    substr $S10, rx663_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx663_fail
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."block"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx663_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
    goto alt722_end
  alt722_2:
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."panic"("Malformed package declaration")
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
  alt722_end:
.annotate 'line', 354
  # rx subrule "ws" subtype=method negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."ws"()
    unless $P10, rx663_fail
    rx663_pos = $P10."pos"()
.annotate 'line', 330
  # rx pass
    rx663_cur."!cursor_pass"(rx663_pos, "package_def")
    if_null rx663_debug, debug_722
    rx663_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx663_pos)
  debug_722:
    .return (rx663_cur)
  rx663_restart:
.annotate 'line', 4
    if_null rx663_debug, debug_723
    rx663_cur."!cursor_debug"("NEXT", "package_def")
  debug_723:
  rx663_fail:
    (rx663_rep, rx663_pos, $I10, $P10) = rx663_cur."!mark_fail"(0)
    lt rx663_pos, -1, rx663_done
    eq rx663_pos, -1, rx663_fail
    jump $I10
  rx663_done:
    rx663_cur."!cursor_fail"()
    if_null rx663_debug, debug_724
    rx663_cur."!cursor_debug"("FAIL", "package_def")
  debug_724:
    .return (rx663_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("150_1300051172.188") :method
.annotate 'line', 4
    $P665 = self."!PREFIX__!subrule"("ws", "")
    new $P666, "ResizablePMCArray"
    push $P666, $P665
    .return ($P666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block683"  :anon :subid("151_1300051172.188") :outer("149_1300051172.188")
.annotate 'line', 340
    $P685 = root_new ['parrot';'Hash']
    .lex "%args", $P685
.annotate 'line', 337
    find_lex $P686, "%args"
.annotate 'line', 341
    find_lex $P687, "$/"
    unless_null $P687, vivify_703
    $P687 = root_new ['parrot';'Hash']
  vivify_703:
    set $P688, $P687["name"]
    unless_null $P688, vivify_704
    new $P688, "Undef"
  vivify_704:
    set $S689, $P688
    new $P690, 'String'
    set $P690, $S689
    find_lex $P691, "%args"
    unless_null $P691, vivify_705
    $P691 = root_new ['parrot';'Hash']
    store_lex "%args", $P691
  vivify_705:
    set $P691["name"], $P690
.annotate 'line', 342
    find_lex $P693, "$/"
    unless_null $P693, vivify_706
    $P693 = root_new ['parrot';'Hash']
  vivify_706:
    set $P694, $P693["repr"]
    unless_null $P694, vivify_707
    new $P694, "Undef"
  vivify_707:
    unless $P694, if_692_end
.annotate 'line', 343
    find_lex $P695, "$/"
    unless_null $P695, vivify_708
    $P695 = root_new ['parrot';'Hash']
  vivify_708:
    set $P696, $P695["repr"]
    unless_null $P696, vivify_709
    $P696 = root_new ['parrot';'ResizablePMCArray']
  vivify_709:
    set $P697, $P696[0]
    unless_null $P697, vivify_710
    $P697 = root_new ['parrot';'Hash']
  vivify_710:
    set $P698, $P697["quote_delimited"]
    unless_null $P698, vivify_711
    $P698 = root_new ['parrot';'Hash']
  vivify_711:
    set $P699, $P698["quote_atom"]
    unless_null $P699, vivify_712
    $P699 = root_new ['parrot';'ResizablePMCArray']
  vivify_712:
    set $P700, $P699[0]
    unless_null $P700, vivify_713
    new $P700, "Undef"
  vivify_713:
    set $S701, $P700
    new $P702, 'String'
    set $P702, $S701
    find_lex $P703, "%args"
    unless_null $P703, vivify_714
    $P703 = root_new ['parrot';'Hash']
    store_lex "%args", $P703
  vivify_714:
    set $P703["repr"], $P702
  if_692_end:
.annotate 'line', 345
    find_dynamic_lex $P704, "$*SC"
    unless_null $P704, vivify_715
    get_hll_global $P704, "$SC"
    unless_null $P704, vivify_716
    die "Contextual $*SC not found"
  vivify_716:
  vivify_715:
    find_dynamic_lex $P705, "$*PKGDECL"
    unless_null $P705, vivify_717
    get_hll_global $P705, "$PKGDECL"
    unless_null $P705, vivify_718
    die "Contextual $*PKGDECL not found"
  vivify_718:
  vivify_717:
    find_dynamic_lex $P706, "%*HOW"
    unless_null $P706, vivify_719
    get_hll_global $P706, "%HOW"
    unless_null $P706, vivify_720
    die "Contextual %*HOW not found"
  vivify_720:
  vivify_719:
    set $P707, $P706[$P705]
    unless_null $P707, vivify_721
    new $P707, "Undef"
  vivify_721:
    find_lex $P708, "%args"
    $P709 = $P704."pkg_create_mo"($P707, $P708 :flat)
    store_dynamic_lex "$*PKGMETA", $P709
.annotate 'line', 337
    .return ($P709)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("152_1300051172.188")
    .param pmc param_733
.annotate 'line', 357
    .lex "self", param_733
    $P734 = param_733."!protoregex"("scope_declarator")
    .return ($P734)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("153_1300051172.188")
    .param pmc param_736
.annotate 'line', 357
    .lex "self", param_736
    $P737 = param_736."!PREFIX__!protoregex"("scope_declarator")
    .return ($P737)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("154_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx739_tgt
    .local int rx739_pos
    .local int rx739_off
    .local int rx739_eos
    .local int rx739_rep
    .local pmc rx739_cur
    .local pmc rx739_debug
    (rx739_cur, rx739_pos, rx739_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx739_cur
    .local pmc match
    .lex "$/", match
    length rx739_eos, rx739_tgt
    gt rx739_pos, rx739_eos, rx739_done
    set rx739_off, 0
    lt rx739_pos, 2, rx739_start
    sub rx739_off, rx739_pos, 1
    substr rx739_tgt, rx739_tgt, rx739_off
  rx739_start:
    eq $I10, 1, rx739_restart
    if_null rx739_debug, debug_725
    rx739_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_725:
    $I10 = self.'from'()
    ne $I10, -1, rxscan743_done
    goto rxscan743_scan
  rxscan743_loop:
    (rx739_pos) = rx739_cur."from"()
    inc rx739_pos
    rx739_cur."!cursor_from"(rx739_pos)
    ge rx739_pos, rx739_eos, rxscan743_done
  rxscan743_scan:
    set_addr $I10, rxscan743_loop
    rx739_cur."!mark_push"(0, rx739_pos, $I10)
  rxscan743_done:
.annotate 'line', 358
  # rx subcapture "sym"
    set_addr $I10, rxcap_744_fail
    rx739_cur."!mark_push"(0, rx739_pos, $I10)
  # rx literal  "my"
    add $I11, rx739_pos, 2
    gt $I11, rx739_eos, rx739_fail
    sub $I11, rx739_pos, rx739_off
    substr $S10, rx739_tgt, $I11, 2
    ne $S10, "my", rx739_fail
    add rx739_pos, 2
    set_addr $I10, rxcap_744_fail
    ($I12, $I11) = rx739_cur."!mark_peek"($I10)
    rx739_cur."!cursor_pos"($I11)
    ($P10) = rx739_cur."!cursor_start"()
    $P10."!cursor_pass"(rx739_pos, "")
    rx739_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_744_done
  rxcap_744_fail:
    goto rx739_fail
  rxcap_744_done:
  # rx subrule "scoped" subtype=capture negate=
    rx739_cur."!cursor_pos"(rx739_pos)
    $P10 = rx739_cur."scoped"("my")
    unless $P10, rx739_fail
    rx739_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx739_pos = $P10."pos"()
  # rx pass
    rx739_cur."!cursor_pass"(rx739_pos, "scope_declarator:sym<my>")
    if_null rx739_debug, debug_726
    rx739_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx739_pos)
  debug_726:
    .return (rx739_cur)
  rx739_restart:
.annotate 'line', 4
    if_null rx739_debug, debug_727
    rx739_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_727:
  rx739_fail:
    (rx739_rep, rx739_pos, $I10, $P10) = rx739_cur."!mark_fail"(0)
    lt rx739_pos, -1, rx739_done
    eq rx739_pos, -1, rx739_fail
    jump $I10
  rx739_done:
    rx739_cur."!cursor_fail"()
    if_null rx739_debug, debug_728
    rx739_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_728:
    .return (rx739_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("155_1300051172.188") :method
.annotate 'line', 4
    $P741 = self."!PREFIX__!subrule"("scoped", "my")
    new $P742, "ResizablePMCArray"
    push $P742, $P741
    .return ($P742)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("156_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx746_tgt
    .local int rx746_pos
    .local int rx746_off
    .local int rx746_eos
    .local int rx746_rep
    .local pmc rx746_cur
    .local pmc rx746_debug
    (rx746_cur, rx746_pos, rx746_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx746_cur
    .local pmc match
    .lex "$/", match
    length rx746_eos, rx746_tgt
    gt rx746_pos, rx746_eos, rx746_done
    set rx746_off, 0
    lt rx746_pos, 2, rx746_start
    sub rx746_off, rx746_pos, 1
    substr rx746_tgt, rx746_tgt, rx746_off
  rx746_start:
    eq $I10, 1, rx746_restart
    if_null rx746_debug, debug_729
    rx746_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_729:
    $I10 = self.'from'()
    ne $I10, -1, rxscan750_done
    goto rxscan750_scan
  rxscan750_loop:
    (rx746_pos) = rx746_cur."from"()
    inc rx746_pos
    rx746_cur."!cursor_from"(rx746_pos)
    ge rx746_pos, rx746_eos, rxscan750_done
  rxscan750_scan:
    set_addr $I10, rxscan750_loop
    rx746_cur."!mark_push"(0, rx746_pos, $I10)
  rxscan750_done:
.annotate 'line', 359
  # rx subcapture "sym"
    set_addr $I10, rxcap_751_fail
    rx746_cur."!mark_push"(0, rx746_pos, $I10)
  # rx literal  "our"
    add $I11, rx746_pos, 3
    gt $I11, rx746_eos, rx746_fail
    sub $I11, rx746_pos, rx746_off
    substr $S10, rx746_tgt, $I11, 3
    ne $S10, "our", rx746_fail
    add rx746_pos, 3
    set_addr $I10, rxcap_751_fail
    ($I12, $I11) = rx746_cur."!mark_peek"($I10)
    rx746_cur."!cursor_pos"($I11)
    ($P10) = rx746_cur."!cursor_start"()
    $P10."!cursor_pass"(rx746_pos, "")
    rx746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_751_done
  rxcap_751_fail:
    goto rx746_fail
  rxcap_751_done:
  # rx subrule "scoped" subtype=capture negate=
    rx746_cur."!cursor_pos"(rx746_pos)
    $P10 = rx746_cur."scoped"("our")
    unless $P10, rx746_fail
    rx746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx746_pos = $P10."pos"()
  # rx pass
    rx746_cur."!cursor_pass"(rx746_pos, "scope_declarator:sym<our>")
    if_null rx746_debug, debug_730
    rx746_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx746_pos)
  debug_730:
    .return (rx746_cur)
  rx746_restart:
.annotate 'line', 4
    if_null rx746_debug, debug_731
    rx746_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_731:
  rx746_fail:
    (rx746_rep, rx746_pos, $I10, $P10) = rx746_cur."!mark_fail"(0)
    lt rx746_pos, -1, rx746_done
    eq rx746_pos, -1, rx746_fail
    jump $I10
  rx746_done:
    rx746_cur."!cursor_fail"()
    if_null rx746_debug, debug_732
    rx746_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_732:
    .return (rx746_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("157_1300051172.188") :method
.annotate 'line', 4
    $P748 = self."!PREFIX__!subrule"("scoped", "our")
    new $P749, "ResizablePMCArray"
    push $P749, $P748
    .return ($P749)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("158_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx753_tgt
    .local int rx753_pos
    .local int rx753_off
    .local int rx753_eos
    .local int rx753_rep
    .local pmc rx753_cur
    .local pmc rx753_debug
    (rx753_cur, rx753_pos, rx753_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx753_cur
    .local pmc match
    .lex "$/", match
    length rx753_eos, rx753_tgt
    gt rx753_pos, rx753_eos, rx753_done
    set rx753_off, 0
    lt rx753_pos, 2, rx753_start
    sub rx753_off, rx753_pos, 1
    substr rx753_tgt, rx753_tgt, rx753_off
  rx753_start:
    eq $I10, 1, rx753_restart
    if_null rx753_debug, debug_733
    rx753_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_733:
    $I10 = self.'from'()
    ne $I10, -1, rxscan757_done
    goto rxscan757_scan
  rxscan757_loop:
    (rx753_pos) = rx753_cur."from"()
    inc rx753_pos
    rx753_cur."!cursor_from"(rx753_pos)
    ge rx753_pos, rx753_eos, rxscan757_done
  rxscan757_scan:
    set_addr $I10, rxscan757_loop
    rx753_cur."!mark_push"(0, rx753_pos, $I10)
  rxscan757_done:
.annotate 'line', 360
  # rx subcapture "sym"
    set_addr $I10, rxcap_758_fail
    rx753_cur."!mark_push"(0, rx753_pos, $I10)
  # rx literal  "has"
    add $I11, rx753_pos, 3
    gt $I11, rx753_eos, rx753_fail
    sub $I11, rx753_pos, rx753_off
    substr $S10, rx753_tgt, $I11, 3
    ne $S10, "has", rx753_fail
    add rx753_pos, 3
    set_addr $I10, rxcap_758_fail
    ($I12, $I11) = rx753_cur."!mark_peek"($I10)
    rx753_cur."!cursor_pos"($I11)
    ($P10) = rx753_cur."!cursor_start"()
    $P10."!cursor_pass"(rx753_pos, "")
    rx753_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_758_done
  rxcap_758_fail:
    goto rx753_fail
  rxcap_758_done:
  # rx subrule "scoped" subtype=capture negate=
    rx753_cur."!cursor_pos"(rx753_pos)
    $P10 = rx753_cur."scoped"("has")
    unless $P10, rx753_fail
    rx753_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx753_pos = $P10."pos"()
  # rx pass
    rx753_cur."!cursor_pass"(rx753_pos, "scope_declarator:sym<has>")
    if_null rx753_debug, debug_734
    rx753_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx753_pos)
  debug_734:
    .return (rx753_cur)
  rx753_restart:
.annotate 'line', 4
    if_null rx753_debug, debug_735
    rx753_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_735:
  rx753_fail:
    (rx753_rep, rx753_pos, $I10, $P10) = rx753_cur."!mark_fail"(0)
    lt rx753_pos, -1, rx753_done
    eq rx753_pos, -1, rx753_fail
    jump $I10
  rx753_done:
    rx753_cur."!cursor_fail"()
    if_null rx753_debug, debug_736
    rx753_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_736:
    .return (rx753_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("159_1300051172.188") :method
.annotate 'line', 4
    $P755 = self."!PREFIX__!subrule"("scoped", "has")
    new $P756, "ResizablePMCArray"
    push $P756, $P755
    .return ($P756)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("160_1300051172.188") :method :outer("11_1300051172.188")
    .param pmc param_760
.annotate 'line', 362
    .lex "$*SCOPE", param_760
.annotate 'line', 4
    .local string rx761_tgt
    .local int rx761_pos
    .local int rx761_off
    .local int rx761_eos
    .local int rx761_rep
    .local pmc rx761_cur
    .local pmc rx761_debug
    (rx761_cur, rx761_pos, rx761_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx761_cur
    .local pmc match
    .lex "$/", match
    length rx761_eos, rx761_tgt
    gt rx761_pos, rx761_eos, rx761_done
    set rx761_off, 0
    lt rx761_pos, 2, rx761_start
    sub rx761_off, rx761_pos, 1
    substr rx761_tgt, rx761_tgt, rx761_off
  rx761_start:
    eq $I10, 1, rx761_restart
    if_null rx761_debug, debug_737
    rx761_cur."!cursor_debug"("START", "scoped")
  debug_737:
    $I10 = self.'from'()
    ne $I10, -1, rxscan767_done
    goto rxscan767_scan
  rxscan767_loop:
    (rx761_pos) = rx761_cur."from"()
    inc rx761_pos
    rx761_cur."!cursor_from"(rx761_pos)
    ge rx761_pos, rx761_eos, rxscan767_done
  rxscan767_scan:
    set_addr $I10, rxscan767_loop
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxscan767_done:
  alt768_0:
.annotate 'line', 362
    set_addr $I10, alt768_1
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
.annotate 'line', 363
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."declarator"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
    goto alt768_end
  alt768_1:
    set_addr $I10, alt768_2
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
.annotate 'line', 364
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."multi_declarator"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
    goto alt768_end
  alt768_2:
.annotate 'line', 365
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."package_declarator"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  alt768_end:
.annotate 'line', 362
  # rx pass
    rx761_cur."!cursor_pass"(rx761_pos, "scoped")
    if_null rx761_debug, debug_738
    rx761_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx761_pos)
  debug_738:
    .return (rx761_cur)
  rx761_restart:
.annotate 'line', 4
    if_null rx761_debug, debug_739
    rx761_cur."!cursor_debug"("NEXT", "scoped")
  debug_739:
  rx761_fail:
    (rx761_rep, rx761_pos, $I10, $P10) = rx761_cur."!mark_fail"(0)
    lt rx761_pos, -1, rx761_done
    eq rx761_pos, -1, rx761_fail
    jump $I10
  rx761_done:
    rx761_cur."!cursor_fail"()
    if_null rx761_debug, debug_740
    rx761_cur."!cursor_debug"("FAIL", "scoped")
  debug_740:
    .return (rx761_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("161_1300051172.188") :method
.annotate 'line', 4
    $P763 = self."!PREFIX__!subrule"("ws", "")
    $P764 = self."!PREFIX__!subrule"("ws", "")
    $P765 = self."!PREFIX__!subrule"("ws", "")
    new $P766, "ResizablePMCArray"
    push $P766, $P763
    push $P766, $P764
    push $P766, $P765
    .return ($P766)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("162_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx776_tgt
    .local int rx776_pos
    .local int rx776_off
    .local int rx776_eos
    .local int rx776_rep
    .local pmc rx776_cur
    .local pmc rx776_debug
    (rx776_cur, rx776_pos, rx776_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx776_cur
    .local pmc match
    .lex "$/", match
    length rx776_eos, rx776_tgt
    gt rx776_pos, rx776_eos, rx776_done
    set rx776_off, 0
    lt rx776_pos, 2, rx776_start
    sub rx776_off, rx776_pos, 1
    substr rx776_tgt, rx776_tgt, rx776_off
  rx776_start:
    eq $I10, 1, rx776_restart
    if_null rx776_debug, debug_741
    rx776_cur."!cursor_debug"("START", "typename")
  debug_741:
    $I10 = self.'from'()
    ne $I10, -1, rxscan780_done
    goto rxscan780_scan
  rxscan780_loop:
    (rx776_pos) = rx776_cur."from"()
    inc rx776_pos
    rx776_cur."!cursor_from"(rx776_pos)
    ge rx776_pos, rx776_eos, rxscan780_done
  rxscan780_scan:
    set_addr $I10, rxscan780_loop
    rx776_cur."!mark_push"(0, rx776_pos, $I10)
  rxscan780_done:
.annotate 'line', 368
  # rx subrule "name" subtype=capture negate=
    rx776_cur."!cursor_pos"(rx776_pos)
    $P10 = rx776_cur."name"()
    unless $P10, rx776_fail
    rx776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx776_pos = $P10."pos"()
  # rx pass
    rx776_cur."!cursor_pass"(rx776_pos, "typename")
    if_null rx776_debug, debug_742
    rx776_cur."!cursor_debug"("PASS", "typename", " at pos=", rx776_pos)
  debug_742:
    .return (rx776_cur)
  rx776_restart:
.annotate 'line', 4
    if_null rx776_debug, debug_743
    rx776_cur."!cursor_debug"("NEXT", "typename")
  debug_743:
  rx776_fail:
    (rx776_rep, rx776_pos, $I10, $P10) = rx776_cur."!mark_fail"(0)
    lt rx776_pos, -1, rx776_done
    eq rx776_pos, -1, rx776_fail
    jump $I10
  rx776_done:
    rx776_cur."!cursor_fail"()
    if_null rx776_debug, debug_744
    rx776_cur."!cursor_debug"("FAIL", "typename")
  debug_744:
    .return (rx776_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("163_1300051172.188") :method
.annotate 'line', 4
    $P778 = self."!PREFIX__!subrule"("name", "")
    new $P779, "ResizablePMCArray"
    push $P779, $P778
    .return ($P779)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("164_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx782_tgt
    .local int rx782_pos
    .local int rx782_off
    .local int rx782_eos
    .local int rx782_rep
    .local pmc rx782_cur
    .local pmc rx782_debug
    (rx782_cur, rx782_pos, rx782_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx782_cur
    .local pmc match
    .lex "$/", match
    length rx782_eos, rx782_tgt
    gt rx782_pos, rx782_eos, rx782_done
    set rx782_off, 0
    lt rx782_pos, 2, rx782_start
    sub rx782_off, rx782_pos, 1
    substr rx782_tgt, rx782_tgt, rx782_off
  rx782_start:
    eq $I10, 1, rx782_restart
    if_null rx782_debug, debug_745
    rx782_cur."!cursor_debug"("START", "declarator")
  debug_745:
    $I10 = self.'from'()
    ne $I10, -1, rxscan787_done
    goto rxscan787_scan
  rxscan787_loop:
    (rx782_pos) = rx782_cur."from"()
    inc rx782_pos
    rx782_cur."!cursor_from"(rx782_pos)
    ge rx782_pos, rx782_eos, rxscan787_done
  rxscan787_scan:
    set_addr $I10, rxscan787_loop
    rx782_cur."!mark_push"(0, rx782_pos, $I10)
  rxscan787_done:
  alt788_0:
.annotate 'line', 370
    set_addr $I10, alt788_1
    rx782_cur."!mark_push"(0, rx782_pos, $I10)
.annotate 'line', 371
  # rx subrule "variable_declarator" subtype=capture negate=
    rx782_cur."!cursor_pos"(rx782_pos)
    $P10 = rx782_cur."variable_declarator"()
    unless $P10, rx782_fail
    rx782_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx782_pos = $P10."pos"()
    goto alt788_end
  alt788_1:
.annotate 'line', 372
  # rx subrule "routine_declarator" subtype=capture negate=
    rx782_cur."!cursor_pos"(rx782_pos)
    $P10 = rx782_cur."routine_declarator"()
    unless $P10, rx782_fail
    rx782_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx782_pos = $P10."pos"()
  alt788_end:
.annotate 'line', 370
  # rx pass
    rx782_cur."!cursor_pass"(rx782_pos, "declarator")
    if_null rx782_debug, debug_746
    rx782_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx782_pos)
  debug_746:
    .return (rx782_cur)
  rx782_restart:
.annotate 'line', 4
    if_null rx782_debug, debug_747
    rx782_cur."!cursor_debug"("NEXT", "declarator")
  debug_747:
  rx782_fail:
    (rx782_rep, rx782_pos, $I10, $P10) = rx782_cur."!mark_fail"(0)
    lt rx782_pos, -1, rx782_done
    eq rx782_pos, -1, rx782_fail
    jump $I10
  rx782_done:
    rx782_cur."!cursor_fail"()
    if_null rx782_debug, debug_748
    rx782_cur."!cursor_debug"("FAIL", "declarator")
  debug_748:
    .return (rx782_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("165_1300051172.188") :method
.annotate 'line', 4
    $P784 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P785 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P786, "ResizablePMCArray"
    push $P786, $P784
    push $P786, $P785
    .return ($P786)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("166_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx790_tgt
    .local int rx790_pos
    .local int rx790_off
    .local int rx790_eos
    .local int rx790_rep
    .local pmc rx790_cur
    .local pmc rx790_debug
    (rx790_cur, rx790_pos, rx790_tgt, $I10) = self."!cursor_start"()
    rx790_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx790_cur
    .local pmc match
    .lex "$/", match
    length rx790_eos, rx790_tgt
    gt rx790_pos, rx790_eos, rx790_done
    set rx790_off, 0
    lt rx790_pos, 2, rx790_start
    sub rx790_off, rx790_pos, 1
    substr rx790_tgt, rx790_tgt, rx790_off
  rx790_start:
    eq $I10, 1, rx790_restart
    if_null rx790_debug, debug_749
    rx790_cur."!cursor_debug"("START", "variable_declarator")
  debug_749:
    $I10 = self.'from'()
    ne $I10, -1, rxscan794_done
    goto rxscan794_scan
  rxscan794_loop:
    (rx790_pos) = rx790_cur."from"()
    inc rx790_pos
    rx790_cur."!cursor_from"(rx790_pos)
    ge rx790_pos, rx790_eos, rxscan794_done
  rxscan794_scan:
    set_addr $I10, rxscan794_loop
    rx790_cur."!mark_push"(0, rx790_pos, $I10)
  rxscan794_done:
.annotate 'line', 375
  # rx subrule "ws" subtype=method negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."ws"()
    unless $P10, rx790_fail
    rx790_pos = $P10."pos"()
  # rx rxquantr796 ** 0..1
    set_addr $I10, rxquantr796_done
    rx790_cur."!mark_push"(0, rx790_pos, $I10)
  rxquantr796_loop:
  # rx subrule "typename" subtype=capture negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."typename"()
    unless $P10, rx790_fail
    goto rxsubrule797_pass
  rxsubrule797_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx790_fail
  rxsubrule797_pass:
    set_addr $I10, rxsubrule797_back
    rx790_cur."!mark_push"(0, rx790_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx790_pos = $P10."pos"()
    set_addr $I10, rxquantr796_done
    (rx790_rep) = rx790_cur."!mark_commit"($I10)
  rxquantr796_done:
  # rx subrule "ws" subtype=method negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."ws"()
    unless $P10, rx790_fail
    rx790_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."variable"()
    unless $P10, rx790_fail
    rx790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx790_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."ws"()
    unless $P10, rx790_fail
    rx790_pos = $P10."pos"()
  # rx pass
    rx790_cur."!cursor_pass"(rx790_pos, "variable_declarator")
    if_null rx790_debug, debug_750
    rx790_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx790_pos)
  debug_750:
    .return (rx790_cur)
  rx790_restart:
.annotate 'line', 4
    if_null rx790_debug, debug_751
    rx790_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_751:
  rx790_fail:
    (rx790_rep, rx790_pos, $I10, $P10) = rx790_cur."!mark_fail"(0)
    lt rx790_pos, -1, rx790_done
    eq rx790_pos, -1, rx790_fail
    jump $I10
  rx790_done:
    rx790_cur."!cursor_fail"()
    if_null rx790_debug, debug_752
    rx790_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_752:
    .return (rx790_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("167_1300051172.188") :method
.annotate 'line', 4
    $P792 = self."!PREFIX__!subrule"("ws", "")
    new $P793, "ResizablePMCArray"
    push $P793, $P792
    .return ($P793)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("168_1300051172.188")
    .param pmc param_801
.annotate 'line', 377
    .lex "self", param_801
    $P802 = param_801."!protoregex"("routine_declarator")
    .return ($P802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("169_1300051172.188")
    .param pmc param_804
.annotate 'line', 377
    .lex "self", param_804
    $P805 = param_804."!PREFIX__!protoregex"("routine_declarator")
    .return ($P805)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("170_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx807_tgt
    .local int rx807_pos
    .local int rx807_off
    .local int rx807_eos
    .local int rx807_rep
    .local pmc rx807_cur
    .local pmc rx807_debug
    (rx807_cur, rx807_pos, rx807_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx807_cur
    .local pmc match
    .lex "$/", match
    length rx807_eos, rx807_tgt
    gt rx807_pos, rx807_eos, rx807_done
    set rx807_off, 0
    lt rx807_pos, 2, rx807_start
    sub rx807_off, rx807_pos, 1
    substr rx807_tgt, rx807_tgt, rx807_off
  rx807_start:
    eq $I10, 1, rx807_restart
    if_null rx807_debug, debug_753
    rx807_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_753:
    $I10 = self.'from'()
    ne $I10, -1, rxscan811_done
    goto rxscan811_scan
  rxscan811_loop:
    (rx807_pos) = rx807_cur."from"()
    inc rx807_pos
    rx807_cur."!cursor_from"(rx807_pos)
    ge rx807_pos, rx807_eos, rxscan811_done
  rxscan811_scan:
    set_addr $I10, rxscan811_loop
    rx807_cur."!mark_push"(0, rx807_pos, $I10)
  rxscan811_done:
.annotate 'line', 378
  # rx subcapture "sym"
    set_addr $I10, rxcap_812_fail
    rx807_cur."!mark_push"(0, rx807_pos, $I10)
  # rx literal  "sub"
    add $I11, rx807_pos, 3
    gt $I11, rx807_eos, rx807_fail
    sub $I11, rx807_pos, rx807_off
    substr $S10, rx807_tgt, $I11, 3
    ne $S10, "sub", rx807_fail
    add rx807_pos, 3
    set_addr $I10, rxcap_812_fail
    ($I12, $I11) = rx807_cur."!mark_peek"($I10)
    rx807_cur."!cursor_pos"($I11)
    ($P10) = rx807_cur."!cursor_start"()
    $P10."!cursor_pass"(rx807_pos, "")
    rx807_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_812_done
  rxcap_812_fail:
    goto rx807_fail
  rxcap_812_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx807_cur."!cursor_pos"(rx807_pos)
    $P10 = rx807_cur."routine_def"()
    unless $P10, rx807_fail
    rx807_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx807_pos = $P10."pos"()
  # rx pass
    rx807_cur."!cursor_pass"(rx807_pos, "routine_declarator:sym<sub>")
    if_null rx807_debug, debug_754
    rx807_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx807_pos)
  debug_754:
    .return (rx807_cur)
  rx807_restart:
.annotate 'line', 4
    if_null rx807_debug, debug_755
    rx807_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_755:
  rx807_fail:
    (rx807_rep, rx807_pos, $I10, $P10) = rx807_cur."!mark_fail"(0)
    lt rx807_pos, -1, rx807_done
    eq rx807_pos, -1, rx807_fail
    jump $I10
  rx807_done:
    rx807_cur."!cursor_fail"()
    if_null rx807_debug, debug_756
    rx807_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_756:
    .return (rx807_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("171_1300051172.188") :method
.annotate 'line', 4
    $P809 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P810, "ResizablePMCArray"
    push $P810, $P809
    .return ($P810)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("172_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx814_tgt
    .local int rx814_pos
    .local int rx814_off
    .local int rx814_eos
    .local int rx814_rep
    .local pmc rx814_cur
    .local pmc rx814_debug
    (rx814_cur, rx814_pos, rx814_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx814_cur
    .local pmc match
    .lex "$/", match
    length rx814_eos, rx814_tgt
    gt rx814_pos, rx814_eos, rx814_done
    set rx814_off, 0
    lt rx814_pos, 2, rx814_start
    sub rx814_off, rx814_pos, 1
    substr rx814_tgt, rx814_tgt, rx814_off
  rx814_start:
    eq $I10, 1, rx814_restart
    if_null rx814_debug, debug_757
    rx814_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_757:
    $I10 = self.'from'()
    ne $I10, -1, rxscan818_done
    goto rxscan818_scan
  rxscan818_loop:
    (rx814_pos) = rx814_cur."from"()
    inc rx814_pos
    rx814_cur."!cursor_from"(rx814_pos)
    ge rx814_pos, rx814_eos, rxscan818_done
  rxscan818_scan:
    set_addr $I10, rxscan818_loop
    rx814_cur."!mark_push"(0, rx814_pos, $I10)
  rxscan818_done:
.annotate 'line', 379
  # rx subcapture "sym"
    set_addr $I10, rxcap_819_fail
    rx814_cur."!mark_push"(0, rx814_pos, $I10)
  # rx literal  "method"
    add $I11, rx814_pos, 6
    gt $I11, rx814_eos, rx814_fail
    sub $I11, rx814_pos, rx814_off
    substr $S10, rx814_tgt, $I11, 6
    ne $S10, "method", rx814_fail
    add rx814_pos, 6
    set_addr $I10, rxcap_819_fail
    ($I12, $I11) = rx814_cur."!mark_peek"($I10)
    rx814_cur."!cursor_pos"($I11)
    ($P10) = rx814_cur."!cursor_start"()
    $P10."!cursor_pass"(rx814_pos, "")
    rx814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_819_done
  rxcap_819_fail:
    goto rx814_fail
  rxcap_819_done:
  # rx subrule "method_def" subtype=capture negate=
    rx814_cur."!cursor_pos"(rx814_pos)
    $P10 = rx814_cur."method_def"()
    unless $P10, rx814_fail
    rx814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx814_pos = $P10."pos"()
  # rx pass
    rx814_cur."!cursor_pass"(rx814_pos, "routine_declarator:sym<method>")
    if_null rx814_debug, debug_758
    rx814_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx814_pos)
  debug_758:
    .return (rx814_cur)
  rx814_restart:
.annotate 'line', 4
    if_null rx814_debug, debug_759
    rx814_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_759:
  rx814_fail:
    (rx814_rep, rx814_pos, $I10, $P10) = rx814_cur."!mark_fail"(0)
    lt rx814_pos, -1, rx814_done
    eq rx814_pos, -1, rx814_fail
    jump $I10
  rx814_done:
    rx814_cur."!cursor_fail"()
    if_null rx814_debug, debug_760
    rx814_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_760:
    .return (rx814_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("173_1300051172.188") :method
.annotate 'line', 4
    $P816 = self."!PREFIX__!subrule"("method_def", "method")
    new $P817, "ResizablePMCArray"
    push $P817, $P816
    .return ($P817)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("174_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 382
    new $P821, "Undef"
    .lex "$*RETURN_USED", $P821
.annotate 'line', 4
    .local string rx822_tgt
    .local int rx822_pos
    .local int rx822_off
    .local int rx822_eos
    .local int rx822_rep
    .local pmc rx822_cur
    .local pmc rx822_debug
    (rx822_cur, rx822_pos, rx822_tgt, $I10) = self."!cursor_start"()
    rx822_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx822_cur
    .local pmc match
    .lex "$/", match
    length rx822_eos, rx822_tgt
    gt rx822_pos, rx822_eos, rx822_done
    set rx822_off, 0
    lt rx822_pos, 2, rx822_start
    sub rx822_off, rx822_pos, 1
    substr rx822_tgt, rx822_tgt, rx822_off
  rx822_start:
    eq $I10, 1, rx822_restart
    if_null rx822_debug, debug_761
    rx822_cur."!cursor_debug"("START", "routine_def")
  debug_761:
    $I10 = self.'from'()
    ne $I10, -1, rxscan826_done
    goto rxscan826_scan
  rxscan826_loop:
    (rx822_pos) = rx822_cur."from"()
    inc rx822_pos
    rx822_cur."!cursor_from"(rx822_pos)
    ge rx822_pos, rx822_eos, rxscan826_done
  rxscan826_scan:
    set_addr $I10, rxscan826_loop
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
  rxscan826_done:
.annotate 'line', 381
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
.annotate 'line', 382
    rx822_cur."!cursor_pos"(rx822_pos)
    new $P828, "Integer"
    assign $P828, 0
    store_lex "$*RETURN_USED", $P828
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
.annotate 'line', 383
  # rx rxquantr830 ** 0..1
    set_addr $I10, rxquantr830_done
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
  rxquantr830_loop:
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_833_fail
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
  # rx rxquantr832 ** 0..1
    set_addr $I10, rxquantr832_done
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
  rxquantr832_loop:
  # rx literal  "&"
    add $I11, rx822_pos, 1
    gt $I11, rx822_eos, rx822_fail
    sub $I11, rx822_pos, rx822_off
    ord $I11, rx822_tgt, $I11
    ne $I11, 38, rx822_fail
    add rx822_pos, 1
    set_addr $I10, rxquantr832_done
    (rx822_rep) = rx822_cur."!mark_commit"($I10)
  rxquantr832_done:
    set_addr $I10, rxcap_833_fail
    ($I12, $I11) = rx822_cur."!mark_peek"($I10)
    rx822_cur."!cursor_pos"($I11)
    ($P10) = rx822_cur."!cursor_start"()
    $P10."!cursor_pass"(rx822_pos, "")
    rx822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_833_done
  rxcap_833_fail:
    goto rx822_fail
  rxcap_833_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."deflongname"()
    unless $P10, rx822_fail
    rx822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx822_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
    set_addr $I10, rxquantr830_done
    (rx822_rep) = rx822_cur."!mark_commit"($I10)
  rxquantr830_done:
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
.annotate 'line', 384
  # rx subrule "newpad" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."newpad"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  alt837_0:
.annotate 'line', 385
    set_addr $I10, alt837_1
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx822_pos, 1
    gt $I11, rx822_eos, rx822_fail
    sub $I11, rx822_pos, rx822_off
    ord $I11, rx822_tgt, $I11
    ne $I11, 40, rx822_fail
    add rx822_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."signature"()
    unless $P10, rx822_fail
    rx822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx822_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx822_pos, 1
    gt $I11, rx822_eos, rx822_fail
    sub $I11, rx822_pos, rx822_off
    ord $I11, rx822_tgt, $I11
    ne $I11, 41, rx822_fail
    add rx822_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
    goto alt837_end
  alt837_1:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  alt837_end:
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
.annotate 'line', 387
  # rx rxquantr845 ** 0..*
    set_addr $I10, rxquantr845_done
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
  rxquantr845_loop:
  # rx subrule "trait" subtype=capture negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."trait"()
    unless $P10, rx822_fail
    goto rxsubrule846_pass
  rxsubrule846_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx822_fail
  rxsubrule846_pass:
    set_addr $I10, rxsubrule846_back
    rx822_cur."!mark_push"(0, rx822_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx822_pos = $P10."pos"()
    set_addr $I10, rxquantr845_done
    (rx822_rep) = rx822_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr845_done
    rx822_cur."!mark_push"(rx822_rep, rx822_pos, $I10)
    goto rxquantr845_loop
  rxquantr845_done:
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  alt848_0:
.annotate 'line', 388
    set_addr $I10, alt848_1
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."onlystar"()
    unless $P10, rx822_fail
    rx822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx822_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
    goto alt848_end
  alt848_1:
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."blockoid"()
    unless $P10, rx822_fail
    rx822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx822_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  alt848_end:
.annotate 'line', 391
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
.annotate 'line', 381
  # rx pass
    rx822_cur."!cursor_pass"(rx822_pos, "routine_def")
    if_null rx822_debug, debug_762
    rx822_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx822_pos)
  debug_762:
    .return (rx822_cur)
  rx822_restart:
.annotate 'line', 4
    if_null rx822_debug, debug_763
    rx822_cur."!cursor_debug"("NEXT", "routine_def")
  debug_763:
  rx822_fail:
    (rx822_rep, rx822_pos, $I10, $P10) = rx822_cur."!mark_fail"(0)
    lt rx822_pos, -1, rx822_done
    eq rx822_pos, -1, rx822_fail
    jump $I10
  rx822_done:
    rx822_cur."!cursor_fail"()
    if_null rx822_debug, debug_764
    rx822_cur."!cursor_debug"("FAIL", "routine_def")
  debug_764:
    .return (rx822_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("175_1300051172.188") :method
.annotate 'line', 4
    $P824 = self."!PREFIX__!subrule"("ws", "")
    new $P825, "ResizablePMCArray"
    push $P825, $P824
    .return ($P825)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("176_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P885 = "178_1300051172.188" 
    capture_lex $P885
.annotate 'line', 395
    new $P855, "Undef"
    .lex "$*RETURN_USED", $P855
.annotate 'line', 396
    new $P856, "Undef"
    .lex "$*INVOCANT_OK", $P856
.annotate 'line', 4
    .local string rx857_tgt
    .local int rx857_pos
    .local int rx857_off
    .local int rx857_eos
    .local int rx857_rep
    .local pmc rx857_cur
    .local pmc rx857_debug
    (rx857_cur, rx857_pos, rx857_tgt, $I10) = self."!cursor_start"()
    rx857_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx857_cur
    .local pmc match
    .lex "$/", match
    length rx857_eos, rx857_tgt
    gt rx857_pos, rx857_eos, rx857_done
    set rx857_off, 0
    lt rx857_pos, 2, rx857_start
    sub rx857_off, rx857_pos, 1
    substr rx857_tgt, rx857_tgt, rx857_off
  rx857_start:
    eq $I10, 1, rx857_restart
    if_null rx857_debug, debug_765
    rx857_cur."!cursor_debug"("START", "method_def")
  debug_765:
    $I10 = self.'from'()
    ne $I10, -1, rxscan861_done
    goto rxscan861_scan
  rxscan861_loop:
    (rx857_pos) = rx857_cur."from"()
    inc rx857_pos
    rx857_cur."!cursor_from"(rx857_pos)
    ge rx857_pos, rx857_eos, rxscan861_done
  rxscan861_scan:
    set_addr $I10, rxscan861_loop
    rx857_cur."!mark_push"(0, rx857_pos, $I10)
  rxscan861_done:
.annotate 'line', 394
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 395
    rx857_cur."!cursor_pos"(rx857_pos)
    new $P863, "Integer"
    assign $P863, 0
    store_lex "$*RETURN_USED", $P863
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 396
    rx857_cur."!cursor_pos"(rx857_pos)
    new $P865, "Integer"
    assign $P865, 1
    store_lex "$*INVOCANT_OK", $P865
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 397
  # rx subcapture "private"
    set_addr $I10, rxcap_868_fail
    rx857_cur."!mark_push"(0, rx857_pos, $I10)
  # rx rxquantr867 ** 0..1
    set_addr $I10, rxquantr867_done
    rx857_cur."!mark_push"(0, rx857_pos, $I10)
  rxquantr867_loop:
  # rx literal  "!"
    add $I11, rx857_pos, 1
    gt $I11, rx857_eos, rx857_fail
    sub $I11, rx857_pos, rx857_off
    ord $I11, rx857_tgt, $I11
    ne $I11, 33, rx857_fail
    add rx857_pos, 1
    set_addr $I10, rxquantr867_done
    (rx857_rep) = rx857_cur."!mark_commit"($I10)
  rxquantr867_done:
    set_addr $I10, rxcap_868_fail
    ($I12, $I11) = rx857_cur."!mark_peek"($I10)
    rx857_cur."!cursor_pos"($I11)
    ($P10) = rx857_cur."!cursor_start"()
    $P10."!cursor_pass"(rx857_pos, "")
    rx857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_868_done
  rxcap_868_fail:
    goto rx857_fail
  rxcap_868_done:
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 398
  # rx rxquantr870 ** 0..1
    set_addr $I10, rxquantr870_done
    rx857_cur."!mark_push"(0, rx857_pos, $I10)
  rxquantr870_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."deflongname"()
    unless $P10, rx857_fail
    goto rxsubrule871_pass
  rxsubrule871_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx857_fail
  rxsubrule871_pass:
    set_addr $I10, rxsubrule871_back
    rx857_cur."!mark_push"(0, rx857_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx857_pos = $P10."pos"()
    set_addr $I10, rxquantr870_done
    (rx857_rep) = rx857_cur."!mark_commit"($I10)
  rxquantr870_done:
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 399
  # rx subrule "newpad" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."newpad"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  alt874_0:
.annotate 'line', 400
    set_addr $I10, alt874_1
    rx857_cur."!mark_push"(0, rx857_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx857_pos, 1
    gt $I11, rx857_eos, rx857_fail
    sub $I11, rx857_pos, rx857_off
    ord $I11, rx857_tgt, $I11
    ne $I11, 40, rx857_fail
    add rx857_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."signature"()
    unless $P10, rx857_fail
    rx857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx857_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx857_pos, 1
    gt $I11, rx857_eos, rx857_fail
    sub $I11, rx857_pos, rx857_off
    ord $I11, rx857_tgt, $I11
    ne $I11, 41, rx857_fail
    add rx857_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
    goto alt874_end
  alt874_1:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  alt874_end:
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 402
    rx857_cur."!cursor_pos"(rx857_pos)
    find_lex $P882, unicode:"$\x{a2}"
    $P883 = $P882."MATCH"()
    store_lex "$/", $P883
    .const 'Sub' $P885 = "178_1300051172.188" 
    capture_lex $P885
    $P887 = $P885()
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 403
  # rx rxquantr889 ** 0..*
    set_addr $I10, rxquantr889_done
    rx857_cur."!mark_push"(0, rx857_pos, $I10)
  rxquantr889_loop:
  # rx subrule "trait" subtype=capture negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."trait"()
    unless $P10, rx857_fail
    goto rxsubrule890_pass
  rxsubrule890_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx857_fail
  rxsubrule890_pass:
    set_addr $I10, rxsubrule890_back
    rx857_cur."!mark_push"(0, rx857_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx857_pos = $P10."pos"()
    set_addr $I10, rxquantr889_done
    (rx857_rep) = rx857_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr889_done
    rx857_cur."!mark_push"(rx857_rep, rx857_pos, $I10)
    goto rxquantr889_loop
  rxquantr889_done:
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  alt892_0:
.annotate 'line', 404
    set_addr $I10, alt892_1
    rx857_cur."!mark_push"(0, rx857_pos, $I10)
.annotate 'line', 405
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."onlystar"()
    unless $P10, rx857_fail
    rx857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx857_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
    goto alt892_end
  alt892_1:
.annotate 'line', 406
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."blockoid"()
    unless $P10, rx857_fail
    rx857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx857_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
  alt892_end:
.annotate 'line', 407
  # rx subrule "ws" subtype=method negate=
    rx857_cur."!cursor_pos"(rx857_pos)
    $P10 = rx857_cur."ws"()
    unless $P10, rx857_fail
    rx857_pos = $P10."pos"()
.annotate 'line', 394
  # rx pass
    rx857_cur."!cursor_pass"(rx857_pos, "method_def")
    if_null rx857_debug, debug_766
    rx857_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx857_pos)
  debug_766:
    .return (rx857_cur)
  rx857_restart:
.annotate 'line', 4
    if_null rx857_debug, debug_767
    rx857_cur."!cursor_debug"("NEXT", "method_def")
  debug_767:
  rx857_fail:
    (rx857_rep, rx857_pos, $I10, $P10) = rx857_cur."!mark_fail"(0)
    lt rx857_pos, -1, rx857_done
    eq rx857_pos, -1, rx857_fail
    jump $I10
  rx857_done:
    rx857_cur."!cursor_fail"()
    if_null rx857_debug, debug_768
    rx857_cur."!cursor_debug"("FAIL", "method_def")
  debug_768:
    .return (rx857_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("177_1300051172.188") :method
.annotate 'line', 4
    $P859 = self."!PREFIX__!subrule"("ws", "")
    new $P860, "ResizablePMCArray"
    push $P860, $P859
    .return ($P860)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block884"  :anon :subid("178_1300051172.188") :outer("176_1300051172.188")
.annotate 'line', 402
    new $P886, "Integer"
    assign $P886, 0
    store_dynamic_lex "$*INVOCANT_OK", $P886
    .return ($P886)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("179_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P906 = "181_1300051172.188" 
    capture_lex $P906
    .local string rx899_tgt
    .local int rx899_pos
    .local int rx899_off
    .local int rx899_eos
    .local int rx899_rep
    .local pmc rx899_cur
    .local pmc rx899_debug
    (rx899_cur, rx899_pos, rx899_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx899_cur
    .local pmc match
    .lex "$/", match
    length rx899_eos, rx899_tgt
    gt rx899_pos, rx899_eos, rx899_done
    set rx899_off, 0
    lt rx899_pos, 2, rx899_start
    sub rx899_off, rx899_pos, 1
    substr rx899_tgt, rx899_tgt, rx899_off
  rx899_start:
    eq $I10, 1, rx899_restart
    if_null rx899_debug, debug_769
    rx899_cur."!cursor_debug"("START", "onlystar")
  debug_769:
    $I10 = self.'from'()
    ne $I10, -1, rxscan902_done
    goto rxscan902_scan
  rxscan902_loop:
    (rx899_pos) = rx899_cur."from"()
    inc rx899_pos
    rx899_cur."!cursor_from"(rx899_pos)
    ge rx899_pos, rx899_eos, rxscan902_done
  rxscan902_scan:
    set_addr $I10, rxscan902_loop
    rx899_cur."!mark_push"(0, rx899_pos, $I10)
  rxscan902_done:
.annotate 'line', 411
    rx899_cur."!cursor_pos"(rx899_pos)
    find_lex $P903, unicode:"$\x{a2}"
    $P904 = $P903."MATCH"()
    store_lex "$/", $P904
    .const 'Sub' $P906 = "181_1300051172.188" 
    capture_lex $P906
    $P910 = $P906()
    unless $P910, rx899_fail
.annotate 'line', 412
  # rx literal  "{"
    add $I11, rx899_pos, 1
    gt $I11, rx899_eos, rx899_fail
    sub $I11, rx899_pos, rx899_off
    ord $I11, rx899_tgt, $I11
    ne $I11, 123, rx899_fail
    add rx899_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx899_cur."!cursor_pos"(rx899_pos)
    $P10 = rx899_cur."ws"()
    unless $P10, rx899_fail
    rx899_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx899_pos, 1
    gt $I11, rx899_eos, rx899_fail
    sub $I11, rx899_pos, rx899_off
    ord $I11, rx899_tgt, $I11
    ne $I11, 42, rx899_fail
    add rx899_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx899_cur."!cursor_pos"(rx899_pos)
    $P10 = rx899_cur."ws"()
    unless $P10, rx899_fail
    rx899_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx899_pos, 1
    gt $I11, rx899_eos, rx899_fail
    sub $I11, rx899_pos, rx899_off
    ord $I11, rx899_tgt, $I11
    ne $I11, 125, rx899_fail
    add rx899_pos, 1
.annotate 'line', 413
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx899_cur."!cursor_pos"(rx899_pos)
    $P10 = rx899_cur."ENDSTMT"()
    unless $P10, rx899_fail
.annotate 'line', 414
  # rx subrule "finishpad" subtype=method negate=
    rx899_cur."!cursor_pos"(rx899_pos)
    $P10 = rx899_cur."finishpad"()
    unless $P10, rx899_fail
    rx899_pos = $P10."pos"()
.annotate 'line', 410
  # rx pass
    rx899_cur."!cursor_pass"(rx899_pos, "onlystar")
    if_null rx899_debug, debug_772
    rx899_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx899_pos)
  debug_772:
    .return (rx899_cur)
  rx899_restart:
.annotate 'line', 4
    if_null rx899_debug, debug_773
    rx899_cur."!cursor_debug"("NEXT", "onlystar")
  debug_773:
  rx899_fail:
    (rx899_rep, rx899_pos, $I10, $P10) = rx899_cur."!mark_fail"(0)
    lt rx899_pos, -1, rx899_done
    eq rx899_pos, -1, rx899_fail
    jump $I10
  rx899_done:
    rx899_cur."!cursor_fail"()
    if_null rx899_debug, debug_774
    rx899_cur."!cursor_debug"("FAIL", "onlystar")
  debug_774:
    .return (rx899_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("180_1300051172.188") :method
.annotate 'line', 4
    new $P901, "ResizablePMCArray"
    push $P901, ""
    .return ($P901)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block905"  :anon :subid("181_1300051172.188") :outer("179_1300051172.188")
.annotate 'line', 411
    find_dynamic_lex $P907, "$*MULTINESS"
    unless_null $P907, vivify_770
    get_hll_global $P907, "$MULTINESS"
    unless_null $P907, vivify_771
    die "Contextual $*MULTINESS not found"
  vivify_771:
  vivify_770:
    set $S908, $P907
    iseq $I909, $S908, "proto"
    .return ($I909)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("182_1300051172.188")
    .param pmc param_912
.annotate 'line', 417
    .lex "self", param_912
    $P913 = param_912."!protoregex"("multi_declarator")
    .return ($P913)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("183_1300051172.188")
    .param pmc param_915
.annotate 'line', 417
    .lex "self", param_915
    $P916 = param_915."!PREFIX__!protoregex"("multi_declarator")
    .return ($P916)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("184_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 419
    new $P918, "Undef"
    .lex "$*MULTINESS", $P918
.annotate 'line', 4
    .local string rx919_tgt
    .local int rx919_pos
    .local int rx919_off
    .local int rx919_eos
    .local int rx919_rep
    .local pmc rx919_cur
    .local pmc rx919_debug
    (rx919_cur, rx919_pos, rx919_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx919_cur
    .local pmc match
    .lex "$/", match
    length rx919_eos, rx919_tgt
    gt rx919_pos, rx919_eos, rx919_done
    set rx919_off, 0
    lt rx919_pos, 2, rx919_start
    sub rx919_off, rx919_pos, 1
    substr rx919_tgt, rx919_tgt, rx919_off
  rx919_start:
    eq $I10, 1, rx919_restart
    if_null rx919_debug, debug_775
    rx919_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_775:
    $I10 = self.'from'()
    ne $I10, -1, rxscan923_done
    goto rxscan923_scan
  rxscan923_loop:
    (rx919_pos) = rx919_cur."from"()
    inc rx919_pos
    rx919_cur."!cursor_from"(rx919_pos)
    ge rx919_pos, rx919_eos, rxscan923_done
  rxscan923_scan:
    set_addr $I10, rxscan923_loop
    rx919_cur."!mark_push"(0, rx919_pos, $I10)
  rxscan923_done:
.annotate 'line', 419
    rx919_cur."!cursor_pos"(rx919_pos)
    new $P924, "String"
    assign $P924, "multi"
    store_lex "$*MULTINESS", $P924
.annotate 'line', 420
  # rx subcapture "sym"
    set_addr $I10, rxcap_925_fail
    rx919_cur."!mark_push"(0, rx919_pos, $I10)
  # rx literal  "multi"
    add $I11, rx919_pos, 5
    gt $I11, rx919_eos, rx919_fail
    sub $I11, rx919_pos, rx919_off
    substr $S10, rx919_tgt, $I11, 5
    ne $S10, "multi", rx919_fail
    add rx919_pos, 5
    set_addr $I10, rxcap_925_fail
    ($I12, $I11) = rx919_cur."!mark_peek"($I10)
    rx919_cur."!cursor_pos"($I11)
    ($P10) = rx919_cur."!cursor_start"()
    $P10."!cursor_pass"(rx919_pos, "")
    rx919_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_925_done
  rxcap_925_fail:
    goto rx919_fail
  rxcap_925_done:
.annotate 'line', 421
  # rx subrule "ws" subtype=method negate=
    rx919_cur."!cursor_pos"(rx919_pos)
    $P10 = rx919_cur."ws"()
    unless $P10, rx919_fail
    rx919_pos = $P10."pos"()
  alt926_0:
    set_addr $I10, alt926_1
    rx919_cur."!mark_push"(0, rx919_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx919_cur."!cursor_pos"(rx919_pos)
    $P10 = rx919_cur."declarator"()
    unless $P10, rx919_fail
    rx919_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx919_pos = $P10."pos"()
    goto alt926_end
  alt926_1:
    set_addr $I10, alt926_2
    rx919_cur."!mark_push"(0, rx919_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx919_cur."!cursor_pos"(rx919_pos)
    $P10 = rx919_cur."routine_def"()
    unless $P10, rx919_fail
    rx919_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx919_pos = $P10."pos"()
    goto alt926_end
  alt926_2:
  # rx subrule "panic" subtype=method negate=
    rx919_cur."!cursor_pos"(rx919_pos)
    $P10 = rx919_cur."panic"("Malformed multi")
    unless $P10, rx919_fail
    rx919_pos = $P10."pos"()
  alt926_end:
.annotate 'line', 418
  # rx pass
    rx919_cur."!cursor_pass"(rx919_pos, "multi_declarator:sym<multi>")
    if_null rx919_debug, debug_776
    rx919_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx919_pos)
  debug_776:
    .return (rx919_cur)
  rx919_restart:
.annotate 'line', 4
    if_null rx919_debug, debug_777
    rx919_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_777:
  rx919_fail:
    (rx919_rep, rx919_pos, $I10, $P10) = rx919_cur."!mark_fail"(0)
    lt rx919_pos, -1, rx919_done
    eq rx919_pos, -1, rx919_fail
    jump $I10
  rx919_done:
    rx919_cur."!cursor_fail"()
    if_null rx919_debug, debug_778
    rx919_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_778:
    .return (rx919_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("185_1300051172.188") :method
.annotate 'line', 4
    $P921 = self."!PREFIX__!subrule"("ws", "multi")
    new $P922, "ResizablePMCArray"
    push $P922, $P921
    .return ($P922)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("186_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 424
    new $P928, "Undef"
    .lex "$*MULTINESS", $P928
.annotate 'line', 4
    .local string rx929_tgt
    .local int rx929_pos
    .local int rx929_off
    .local int rx929_eos
    .local int rx929_rep
    .local pmc rx929_cur
    .local pmc rx929_debug
    (rx929_cur, rx929_pos, rx929_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx929_cur
    .local pmc match
    .lex "$/", match
    length rx929_eos, rx929_tgt
    gt rx929_pos, rx929_eos, rx929_done
    set rx929_off, 0
    lt rx929_pos, 2, rx929_start
    sub rx929_off, rx929_pos, 1
    substr rx929_tgt, rx929_tgt, rx929_off
  rx929_start:
    eq $I10, 1, rx929_restart
    if_null rx929_debug, debug_779
    rx929_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_779:
    $I10 = self.'from'()
    ne $I10, -1, rxscan933_done
    goto rxscan933_scan
  rxscan933_loop:
    (rx929_pos) = rx929_cur."from"()
    inc rx929_pos
    rx929_cur."!cursor_from"(rx929_pos)
    ge rx929_pos, rx929_eos, rxscan933_done
  rxscan933_scan:
    set_addr $I10, rxscan933_loop
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  rxscan933_done:
.annotate 'line', 424
    rx929_cur."!cursor_pos"(rx929_pos)
    new $P934, "String"
    assign $P934, "proto"
    store_lex "$*MULTINESS", $P934
.annotate 'line', 425
  # rx subcapture "sym"
    set_addr $I10, rxcap_935_fail
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx literal  "proto"
    add $I11, rx929_pos, 5
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 5
    ne $S10, "proto", rx929_fail
    add rx929_pos, 5
    set_addr $I10, rxcap_935_fail
    ($I12, $I11) = rx929_cur."!mark_peek"($I10)
    rx929_cur."!cursor_pos"($I11)
    ($P10) = rx929_cur."!cursor_start"()
    $P10."!cursor_pass"(rx929_pos, "")
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_935_done
  rxcap_935_fail:
    goto rx929_fail
  rxcap_935_done:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  alt936_0:
    set_addr $I10, alt936_1
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."declarator"()
    unless $P10, rx929_fail
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx929_pos = $P10."pos"()
    goto alt936_end
  alt936_1:
    set_addr $I10, alt936_2
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."routine_def"()
    unless $P10, rx929_fail
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx929_pos = $P10."pos"()
    goto alt936_end
  alt936_2:
  # rx subrule "panic" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."panic"("Malformed proto")
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  alt936_end:
.annotate 'line', 423
  # rx pass
    rx929_cur."!cursor_pass"(rx929_pos, "multi_declarator:sym<proto>")
    if_null rx929_debug, debug_780
    rx929_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx929_pos)
  debug_780:
    .return (rx929_cur)
  rx929_restart:
.annotate 'line', 4
    if_null rx929_debug, debug_781
    rx929_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_781:
  rx929_fail:
    (rx929_rep, rx929_pos, $I10, $P10) = rx929_cur."!mark_fail"(0)
    lt rx929_pos, -1, rx929_done
    eq rx929_pos, -1, rx929_fail
    jump $I10
  rx929_done:
    rx929_cur."!cursor_fail"()
    if_null rx929_debug, debug_782
    rx929_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_782:
    .return (rx929_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("187_1300051172.188") :method
.annotate 'line', 4
    $P931 = self."!PREFIX__!subrule"("ws", "proto")
    new $P932, "ResizablePMCArray"
    push $P932, $P931
    .return ($P932)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("188_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 429
    new $P938, "Undef"
    .lex "$*MULTINESS", $P938
.annotate 'line', 4
    .local string rx939_tgt
    .local int rx939_pos
    .local int rx939_off
    .local int rx939_eos
    .local int rx939_rep
    .local pmc rx939_cur
    .local pmc rx939_debug
    (rx939_cur, rx939_pos, rx939_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx939_cur
    .local pmc match
    .lex "$/", match
    length rx939_eos, rx939_tgt
    gt rx939_pos, rx939_eos, rx939_done
    set rx939_off, 0
    lt rx939_pos, 2, rx939_start
    sub rx939_off, rx939_pos, 1
    substr rx939_tgt, rx939_tgt, rx939_off
  rx939_start:
    eq $I10, 1, rx939_restart
    if_null rx939_debug, debug_783
    rx939_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_783:
    $I10 = self.'from'()
    ne $I10, -1, rxscan943_done
    goto rxscan943_scan
  rxscan943_loop:
    (rx939_pos) = rx939_cur."from"()
    inc rx939_pos
    rx939_cur."!cursor_from"(rx939_pos)
    ge rx939_pos, rx939_eos, rxscan943_done
  rxscan943_scan:
    set_addr $I10, rxscan943_loop
    rx939_cur."!mark_push"(0, rx939_pos, $I10)
  rxscan943_done:
.annotate 'line', 429
    rx939_cur."!cursor_pos"(rx939_pos)
    new $P944, "String"
    assign $P944, ""
    store_lex "$*MULTINESS", $P944
.annotate 'line', 430
  # rx subrule "declarator" subtype=capture negate=
    rx939_cur."!cursor_pos"(rx939_pos)
    $P10 = rx939_cur."declarator"()
    unless $P10, rx939_fail
    rx939_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx939_pos = $P10."pos"()
.annotate 'line', 428
  # rx pass
    rx939_cur."!cursor_pass"(rx939_pos, "multi_declarator:sym<null>")
    if_null rx939_debug, debug_784
    rx939_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx939_pos)
  debug_784:
    .return (rx939_cur)
  rx939_restart:
.annotate 'line', 4
    if_null rx939_debug, debug_785
    rx939_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_785:
  rx939_fail:
    (rx939_rep, rx939_pos, $I10, $P10) = rx939_cur."!mark_fail"(0)
    lt rx939_pos, -1, rx939_done
    eq rx939_pos, -1, rx939_fail
    jump $I10
  rx939_done:
    rx939_cur."!cursor_fail"()
    if_null rx939_debug, debug_786
    rx939_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_786:
    .return (rx939_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("189_1300051172.188") :method
.annotate 'line', 4
    $P941 = self."!PREFIX__!subrule"("declarator", "")
    new $P942, "ResizablePMCArray"
    push $P942, $P941
    .return ($P942)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("190_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P954 = "192_1300051172.188" 
    capture_lex $P954
    .local string rx946_tgt
    .local int rx946_pos
    .local int rx946_off
    .local int rx946_eos
    .local int rx946_rep
    .local pmc rx946_cur
    .local pmc rx946_debug
    (rx946_cur, rx946_pos, rx946_tgt, $I10) = self."!cursor_start"()
    rx946_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx946_cur
    .local pmc match
    .lex "$/", match
    length rx946_eos, rx946_tgt
    gt rx946_pos, rx946_eos, rx946_done
    set rx946_off, 0
    lt rx946_pos, 2, rx946_start
    sub rx946_off, rx946_pos, 1
    substr rx946_tgt, rx946_tgt, rx946_off
  rx946_start:
    eq $I10, 1, rx946_restart
    if_null rx946_debug, debug_787
    rx946_cur."!cursor_debug"("START", "signature")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan949_done
    goto rxscan949_scan
  rxscan949_loop:
    (rx946_pos) = rx946_cur."from"()
    inc rx946_pos
    rx946_cur."!cursor_from"(rx946_pos)
    ge rx946_pos, rx946_eos, rxscan949_done
  rxscan949_scan:
    set_addr $I10, rxscan949_loop
    rx946_cur."!mark_push"(0, rx946_pos, $I10)
  rxscan949_done:
.annotate 'line', 434
  # rx rxquantr950 ** 0..1
    set_addr $I10, rxquantr950_done
    rx946_cur."!mark_push"(0, rx946_pos, $I10)
  rxquantr950_loop:
    rx946_cur."!cursor_pos"(rx946_pos)
    find_lex $P951, unicode:"$\x{a2}"
    $P952 = $P951."MATCH"()
    store_lex "$/", $P952
    .const 'Sub' $P954 = "192_1300051172.188" 
    capture_lex $P954
    $P956 = $P954()
    unless $P956, rx946_fail
  # rx subrule "ws" subtype=method negate=
    rx946_cur."!cursor_pos"(rx946_pos)
    $P10 = rx946_cur."ws"()
    unless $P10, rx946_fail
    rx946_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx946_cur."!cursor_pos"(rx946_pos)
    $P10 = rx946_cur."parameter"()
    unless $P10, rx946_fail
    rx946_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx946_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx946_cur."!cursor_pos"(rx946_pos)
    $P10 = rx946_cur."ws"()
    unless $P10, rx946_fail
    rx946_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx946_pos, 1
    gt $I11, rx946_eos, rx946_fail
    sub $I11, rx946_pos, rx946_off
    ord $I11, rx946_tgt, $I11
    ne $I11, 58, rx946_fail
    add rx946_pos, 1
    set_addr $I10, rxquantr950_done
    (rx946_rep) = rx946_cur."!mark_commit"($I10)
  rxquantr950_done:
.annotate 'line', 435
  # rx rxquantr957 ** 0..1
    set_addr $I10, rxquantr957_done
    rx946_cur."!mark_push"(0, rx946_pos, $I10)
  rxquantr957_loop:
  # rx rxquantr958 ** 1..*
    set_addr $I10, rxquantr958_done
    rx946_cur."!mark_push"(0, -1, $I10)
  rxquantr958_loop:
  # rx subrule "ws" subtype=method negate=
    rx946_cur."!cursor_pos"(rx946_pos)
    $P10 = rx946_cur."ws"()
    unless $P10, rx946_fail
    rx946_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx946_cur."!cursor_pos"(rx946_pos)
    $P10 = rx946_cur."parameter"()
    unless $P10, rx946_fail
    rx946_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx946_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx946_cur."!cursor_pos"(rx946_pos)
    $P10 = rx946_cur."ws"()
    unless $P10, rx946_fail
    rx946_pos = $P10."pos"()
    set_addr $I10, rxquantr958_done
    (rx946_rep) = rx946_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr958_done
    rx946_cur."!mark_push"(rx946_rep, rx946_pos, $I10)
  # rx literal  ","
    add $I11, rx946_pos, 1
    gt $I11, rx946_eos, rx946_fail
    sub $I11, rx946_pos, rx946_off
    ord $I11, rx946_tgt, $I11
    ne $I11, 44, rx946_fail
    add rx946_pos, 1
    goto rxquantr958_loop
  rxquantr958_done:
    set_addr $I10, rxquantr957_done
    (rx946_rep) = rx946_cur."!mark_commit"($I10)
  rxquantr957_done:
.annotate 'line', 433
  # rx pass
    rx946_cur."!cursor_pass"(rx946_pos, "signature")
    if_null rx946_debug, debug_790
    rx946_cur."!cursor_debug"("PASS", "signature", " at pos=", rx946_pos)
  debug_790:
    .return (rx946_cur)
  rx946_restart:
.annotate 'line', 4
    if_null rx946_debug, debug_791
    rx946_cur."!cursor_debug"("NEXT", "signature")
  debug_791:
  rx946_fail:
    (rx946_rep, rx946_pos, $I10, $P10) = rx946_cur."!mark_fail"(0)
    lt rx946_pos, -1, rx946_done
    eq rx946_pos, -1, rx946_fail
    jump $I10
  rx946_done:
    rx946_cur."!cursor_fail"()
    if_null rx946_debug, debug_792
    rx946_cur."!cursor_debug"("FAIL", "signature")
  debug_792:
    .return (rx946_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("191_1300051172.188") :method
.annotate 'line', 4
    new $P948, "ResizablePMCArray"
    push $P948, ""
    .return ($P948)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block953"  :anon :subid("192_1300051172.188") :outer("190_1300051172.188")
.annotate 'line', 434
    find_dynamic_lex $P955, "$*INVOCANT_OK"
    unless_null $P955, vivify_788
    get_hll_global $P955, "$INVOCANT_OK"
    unless_null $P955, vivify_789
    die "Contextual $*INVOCANT_OK not found"
  vivify_789:
  vivify_788:
    .return ($P955)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("193_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx960_tgt
    .local int rx960_pos
    .local int rx960_off
    .local int rx960_eos
    .local int rx960_rep
    .local pmc rx960_cur
    .local pmc rx960_debug
    (rx960_cur, rx960_pos, rx960_tgt, $I10) = self."!cursor_start"()
    rx960_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx960_cur
    .local pmc match
    .lex "$/", match
    length rx960_eos, rx960_tgt
    gt rx960_pos, rx960_eos, rx960_done
    set rx960_off, 0
    lt rx960_pos, 2, rx960_start
    sub rx960_off, rx960_pos, 1
    substr rx960_tgt, rx960_tgt, rx960_off
  rx960_start:
    eq $I10, 1, rx960_restart
    if_null rx960_debug, debug_793
    rx960_cur."!cursor_debug"("START", "parameter")
  debug_793:
    $I10 = self.'from'()
    ne $I10, -1, rxscan963_done
    goto rxscan963_scan
  rxscan963_loop:
    (rx960_pos) = rx960_cur."from"()
    inc rx960_pos
    rx960_cur."!cursor_from"(rx960_pos)
    ge rx960_pos, rx960_eos, rxscan963_done
  rxscan963_scan:
    set_addr $I10, rxscan963_loop
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxscan963_done:
.annotate 'line', 439
  # rx rxquantr964 ** 0..*
    set_addr $I10, rxquantr964_done
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxquantr964_loop:
  # rx subrule "typename" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."typename"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx960_pos = $P10."pos"()
  # rx rxquantr965 ** 0..1
    set_addr $I10, rxquantr965_done
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxquantr965_loop:
  # rx literal  ":"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 58, rx960_fail
    add rx960_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_966_fail
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx960_pos, rx960_eos, rx960_fail
    sub $I10, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx960_fail
    inc rx960_pos
    set_addr $I10, rxcap_966_fail
    ($I12, $I11) = rx960_cur."!mark_peek"($I10)
    rx960_cur."!cursor_pos"($I11)
    ($P10) = rx960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx960_pos, "")
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_966_done
  rxcap_966_fail:
    goto rx960_fail
  rxcap_966_done:
    set_addr $I10, rxquantr965_done
    (rx960_rep) = rx960_cur."!mark_commit"($I10)
  rxquantr965_done:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
    set_addr $I10, rxquantr964_done
    (rx960_rep) = rx960_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr964_done
    rx960_cur."!mark_push"(rx960_rep, rx960_pos, $I10)
    goto rxquantr964_loop
  rxquantr964_done:
  alt967_0:
.annotate 'line', 440
    set_addr $I10, alt967_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
.annotate 'line', 441
  # rx subcapture "quant"
    set_addr $I10, rxcap_968_fail
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "*"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 42, rx960_fail
    add rx960_pos, 1
    set_addr $I10, rxcap_968_fail
    ($I12, $I11) = rx960_cur."!mark_peek"($I10)
    rx960_cur."!cursor_pos"($I11)
    ($P10) = rx960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx960_pos, "")
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_968_done
  rxcap_968_fail:
    goto rx960_fail
  rxcap_968_done:
  # rx subrule "param_var" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."param_var"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx960_pos = $P10."pos"()
    goto alt967_end
  alt967_1:
  alt969_0:
.annotate 'line', 442
    set_addr $I10, alt969_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."param_var"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx960_pos = $P10."pos"()
    goto alt969_end
  alt969_1:
  # rx subrule "named_param" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."named_param"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx960_pos = $P10."pos"()
  alt969_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_971_fail
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  alt970_0:
    set_addr $I10, alt970_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "?"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 63, rx960_fail
    add rx960_pos, 1
    goto alt970_end
  alt970_1:
    set_addr $I10, alt970_2
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "!"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 33, rx960_fail
    add rx960_pos, 1
    goto alt970_end
  alt970_2:
  alt970_end:
    set_addr $I10, rxcap_971_fail
    ($I12, $I11) = rx960_cur."!mark_peek"($I10)
    rx960_cur."!cursor_pos"($I11)
    ($P10) = rx960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx960_pos, "")
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_971_done
  rxcap_971_fail:
    goto rx960_fail
  rxcap_971_done:
  alt967_end:
.annotate 'line', 444
  # rx rxquantr972 ** 0..1
    set_addr $I10, rxquantr972_done
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxquantr972_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."default_value"()
    unless $P10, rx960_fail
    goto rxsubrule973_pass
  rxsubrule973_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx960_fail
  rxsubrule973_pass:
    set_addr $I10, rxsubrule973_back
    rx960_cur."!mark_push"(0, rx960_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx960_pos = $P10."pos"()
    set_addr $I10, rxquantr972_done
    (rx960_rep) = rx960_cur."!mark_commit"($I10)
  rxquantr972_done:
.annotate 'line', 438
  # rx pass
    rx960_cur."!cursor_pass"(rx960_pos, "parameter")
    if_null rx960_debug, debug_794
    rx960_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx960_pos)
  debug_794:
    .return (rx960_cur)
  rx960_restart:
.annotate 'line', 4
    if_null rx960_debug, debug_795
    rx960_cur."!cursor_debug"("NEXT", "parameter")
  debug_795:
  rx960_fail:
    (rx960_rep, rx960_pos, $I10, $P10) = rx960_cur."!mark_fail"(0)
    lt rx960_pos, -1, rx960_done
    eq rx960_pos, -1, rx960_fail
    jump $I10
  rx960_done:
    rx960_cur."!cursor_fail"()
    if_null rx960_debug, debug_796
    rx960_cur."!cursor_debug"("FAIL", "parameter")
  debug_796:
    .return (rx960_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("194_1300051172.188") :method
.annotate 'line', 4
    new $P962, "ResizablePMCArray"
    push $P962, ""
    .return ($P962)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("195_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx975_tgt
    .local int rx975_pos
    .local int rx975_off
    .local int rx975_eos
    .local int rx975_rep
    .local pmc rx975_cur
    .local pmc rx975_debug
    (rx975_cur, rx975_pos, rx975_tgt, $I10) = self."!cursor_start"()
    rx975_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx975_cur
    .local pmc match
    .lex "$/", match
    length rx975_eos, rx975_tgt
    gt rx975_pos, rx975_eos, rx975_done
    set rx975_off, 0
    lt rx975_pos, 2, rx975_start
    sub rx975_off, rx975_pos, 1
    substr rx975_tgt, rx975_tgt, rx975_off
  rx975_start:
    eq $I10, 1, rx975_restart
    if_null rx975_debug, debug_797
    rx975_cur."!cursor_debug"("START", "param_var")
  debug_797:
    $I10 = self.'from'()
    ne $I10, -1, rxscan979_done
    goto rxscan979_scan
  rxscan979_loop:
    (rx975_pos) = rx975_cur."from"()
    inc rx975_pos
    rx975_cur."!cursor_from"(rx975_pos)
    ge rx975_pos, rx975_eos, rxscan979_done
  rxscan979_scan:
    set_addr $I10, rxscan979_loop
    rx975_cur."!mark_push"(0, rx975_pos, $I10)
  rxscan979_done:
.annotate 'line', 448
  # rx subrule "sigil" subtype=capture negate=
    rx975_cur."!cursor_pos"(rx975_pos)
    $P10 = rx975_cur."sigil"()
    unless $P10, rx975_fail
    rx975_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx975_pos = $P10."pos"()
  # rx rxquantr980 ** 0..1
    set_addr $I10, rxquantr980_done
    rx975_cur."!mark_push"(0, rx975_pos, $I10)
  rxquantr980_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx975_cur."!cursor_pos"(rx975_pos)
    $P10 = rx975_cur."twigil"()
    unless $P10, rx975_fail
    goto rxsubrule981_pass
  rxsubrule981_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx975_fail
  rxsubrule981_pass:
    set_addr $I10, rxsubrule981_back
    rx975_cur."!mark_push"(0, rx975_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx975_pos = $P10."pos"()
    set_addr $I10, rxquantr980_done
    (rx975_rep) = rx975_cur."!mark_commit"($I10)
  rxquantr980_done:
  alt982_0:
.annotate 'line', 449
    set_addr $I10, alt982_1
    rx975_cur."!mark_push"(0, rx975_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx975_cur."!cursor_pos"(rx975_pos)
    $P10 = rx975_cur."ident"()
    unless $P10, rx975_fail
    rx975_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx975_pos = $P10."pos"()
    goto alt982_end
  alt982_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_983_fail
    rx975_cur."!mark_push"(0, rx975_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx975_pos, rx975_eos, rx975_fail
    sub $I10, rx975_pos, rx975_off
    substr $S10, rx975_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx975_fail
    inc rx975_pos
    set_addr $I10, rxcap_983_fail
    ($I12, $I11) = rx975_cur."!mark_peek"($I10)
    rx975_cur."!cursor_pos"($I11)
    ($P10) = rx975_cur."!cursor_start"()
    $P10."!cursor_pass"(rx975_pos, "")
    rx975_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_983_done
  rxcap_983_fail:
    goto rx975_fail
  rxcap_983_done:
  alt982_end:
.annotate 'line', 447
  # rx pass
    rx975_cur."!cursor_pass"(rx975_pos, "param_var")
    if_null rx975_debug, debug_798
    rx975_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx975_pos)
  debug_798:
    .return (rx975_cur)
  rx975_restart:
.annotate 'line', 4
    if_null rx975_debug, debug_799
    rx975_cur."!cursor_debug"("NEXT", "param_var")
  debug_799:
  rx975_fail:
    (rx975_rep, rx975_pos, $I10, $P10) = rx975_cur."!mark_fail"(0)
    lt rx975_pos, -1, rx975_done
    eq rx975_pos, -1, rx975_fail
    jump $I10
  rx975_done:
    rx975_cur."!cursor_fail"()
    if_null rx975_debug, debug_800
    rx975_cur."!cursor_debug"("FAIL", "param_var")
  debug_800:
    .return (rx975_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("196_1300051172.188") :method
.annotate 'line', 4
    $P977 = self."!PREFIX__!subrule"("sigil", "")
    new $P978, "ResizablePMCArray"
    push $P978, $P977
    .return ($P978)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("197_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx985_tgt
    .local int rx985_pos
    .local int rx985_off
    .local int rx985_eos
    .local int rx985_rep
    .local pmc rx985_cur
    .local pmc rx985_debug
    (rx985_cur, rx985_pos, rx985_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx985_cur
    .local pmc match
    .lex "$/", match
    length rx985_eos, rx985_tgt
    gt rx985_pos, rx985_eos, rx985_done
    set rx985_off, 0
    lt rx985_pos, 2, rx985_start
    sub rx985_off, rx985_pos, 1
    substr rx985_tgt, rx985_tgt, rx985_off
  rx985_start:
    eq $I10, 1, rx985_restart
    if_null rx985_debug, debug_801
    rx985_cur."!cursor_debug"("START", "named_param")
  debug_801:
    $I10 = self.'from'()
    ne $I10, -1, rxscan989_done
    goto rxscan989_scan
  rxscan989_loop:
    (rx985_pos) = rx985_cur."from"()
    inc rx985_pos
    rx985_cur."!cursor_from"(rx985_pos)
    ge rx985_pos, rx985_eos, rxscan989_done
  rxscan989_scan:
    set_addr $I10, rxscan989_loop
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  rxscan989_done:
.annotate 'line', 453
  # rx literal  ":"
    add $I11, rx985_pos, 1
    gt $I11, rx985_eos, rx985_fail
    sub $I11, rx985_pos, rx985_off
    ord $I11, rx985_tgt, $I11
    ne $I11, 58, rx985_fail
    add rx985_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."param_var"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx985_pos = $P10."pos"()
.annotate 'line', 452
  # rx pass
    rx985_cur."!cursor_pass"(rx985_pos, "named_param")
    if_null rx985_debug, debug_802
    rx985_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx985_pos)
  debug_802:
    .return (rx985_cur)
  rx985_restart:
.annotate 'line', 4
    if_null rx985_debug, debug_803
    rx985_cur."!cursor_debug"("NEXT", "named_param")
  debug_803:
  rx985_fail:
    (rx985_rep, rx985_pos, $I10, $P10) = rx985_cur."!mark_fail"(0)
    lt rx985_pos, -1, rx985_done
    eq rx985_pos, -1, rx985_fail
    jump $I10
  rx985_done:
    rx985_cur."!cursor_fail"()
    if_null rx985_debug, debug_804
    rx985_cur."!cursor_debug"("FAIL", "named_param")
  debug_804:
    .return (rx985_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("198_1300051172.188") :method
.annotate 'line', 4
    $P987 = self."!PREFIX__!subrule"("param_var", ":")
    new $P988, "ResizablePMCArray"
    push $P988, $P987
    .return ($P988)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("199_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx991_tgt
    .local int rx991_pos
    .local int rx991_off
    .local int rx991_eos
    .local int rx991_rep
    .local pmc rx991_cur
    .local pmc rx991_debug
    (rx991_cur, rx991_pos, rx991_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx991_cur
    .local pmc match
    .lex "$/", match
    length rx991_eos, rx991_tgt
    gt rx991_pos, rx991_eos, rx991_done
    set rx991_off, 0
    lt rx991_pos, 2, rx991_start
    sub rx991_off, rx991_pos, 1
    substr rx991_tgt, rx991_tgt, rx991_off
  rx991_start:
    eq $I10, 1, rx991_restart
    if_null rx991_debug, debug_805
    rx991_cur."!cursor_debug"("START", "default_value")
  debug_805:
    $I10 = self.'from'()
    ne $I10, -1, rxscan995_done
    goto rxscan995_scan
  rxscan995_loop:
    (rx991_pos) = rx991_cur."from"()
    inc rx991_pos
    rx991_cur."!cursor_from"(rx991_pos)
    ge rx991_pos, rx991_eos, rxscan995_done
  rxscan995_scan:
    set_addr $I10, rxscan995_loop
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxscan995_done:
.annotate 'line', 456
  # rx subrule "ws" subtype=method negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ws"()
    unless $P10, rx991_fail
    rx991_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx991_pos, 1
    gt $I11, rx991_eos, rx991_fail
    sub $I11, rx991_pos, rx991_off
    ord $I11, rx991_tgt, $I11
    ne $I11, 61, rx991_fail
    add rx991_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ws"()
    unless $P10, rx991_fail
    rx991_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."EXPR"("i=")
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx991_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ws"()
    unless $P10, rx991_fail
    rx991_pos = $P10."pos"()
  # rx pass
    rx991_cur."!cursor_pass"(rx991_pos, "default_value")
    if_null rx991_debug, debug_806
    rx991_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx991_pos)
  debug_806:
    .return (rx991_cur)
  rx991_restart:
.annotate 'line', 4
    if_null rx991_debug, debug_807
    rx991_cur."!cursor_debug"("NEXT", "default_value")
  debug_807:
  rx991_fail:
    (rx991_rep, rx991_pos, $I10, $P10) = rx991_cur."!mark_fail"(0)
    lt rx991_pos, -1, rx991_done
    eq rx991_pos, -1, rx991_fail
    jump $I10
  rx991_done:
    rx991_cur."!cursor_fail"()
    if_null rx991_debug, debug_808
    rx991_cur."!cursor_debug"("FAIL", "default_value")
  debug_808:
    .return (rx991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("200_1300051172.188") :method
.annotate 'line', 4
    $P993 = self."!PREFIX__!subrule"("ws", "")
    new $P994, "ResizablePMCArray"
    push $P994, $P993
    .return ($P994)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("201_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1000_tgt
    .local int rx1000_pos
    .local int rx1000_off
    .local int rx1000_eos
    .local int rx1000_rep
    .local pmc rx1000_cur
    .local pmc rx1000_debug
    (rx1000_cur, rx1000_pos, rx1000_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1000_cur
    .local pmc match
    .lex "$/", match
    length rx1000_eos, rx1000_tgt
    gt rx1000_pos, rx1000_eos, rx1000_done
    set rx1000_off, 0
    lt rx1000_pos, 2, rx1000_start
    sub rx1000_off, rx1000_pos, 1
    substr rx1000_tgt, rx1000_tgt, rx1000_off
  rx1000_start:
    eq $I10, 1, rx1000_restart
    if_null rx1000_debug, debug_809
    rx1000_cur."!cursor_debug"("START", "trait")
  debug_809:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1004_done
    goto rxscan1004_scan
  rxscan1004_loop:
    (rx1000_pos) = rx1000_cur."from"()
    inc rx1000_pos
    rx1000_cur."!cursor_from"(rx1000_pos)
    ge rx1000_pos, rx1000_eos, rxscan1004_done
  rxscan1004_scan:
    set_addr $I10, rxscan1004_loop
    rx1000_cur."!mark_push"(0, rx1000_pos, $I10)
  rxscan1004_done:
.annotate 'line', 458
  # rx subrule "ws" subtype=method negate=
    rx1000_cur."!cursor_pos"(rx1000_pos)
    $P10 = rx1000_cur."ws"()
    unless $P10, rx1000_fail
    rx1000_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1000_cur."!cursor_pos"(rx1000_pos)
    $P10 = rx1000_cur."trait_mod"()
    unless $P10, rx1000_fail
    rx1000_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1000_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1000_cur."!cursor_pos"(rx1000_pos)
    $P10 = rx1000_cur."ws"()
    unless $P10, rx1000_fail
    rx1000_pos = $P10."pos"()
  # rx pass
    rx1000_cur."!cursor_pass"(rx1000_pos, "trait")
    if_null rx1000_debug, debug_810
    rx1000_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1000_pos)
  debug_810:
    .return (rx1000_cur)
  rx1000_restart:
.annotate 'line', 4
    if_null rx1000_debug, debug_811
    rx1000_cur."!cursor_debug"("NEXT", "trait")
  debug_811:
  rx1000_fail:
    (rx1000_rep, rx1000_pos, $I10, $P10) = rx1000_cur."!mark_fail"(0)
    lt rx1000_pos, -1, rx1000_done
    eq rx1000_pos, -1, rx1000_fail
    jump $I10
  rx1000_done:
    rx1000_cur."!cursor_fail"()
    if_null rx1000_debug, debug_812
    rx1000_cur."!cursor_debug"("FAIL", "trait")
  debug_812:
    .return (rx1000_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("202_1300051172.188") :method
.annotate 'line', 4
    $P1002 = self."!PREFIX__!subrule"("ws", "")
    new $P1003, "ResizablePMCArray"
    push $P1003, $P1002
    .return ($P1003)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("203_1300051172.188")
    .param pmc param_1008
.annotate 'line', 460
    .lex "self", param_1008
    $P1009 = param_1008."!protoregex"("trait_mod")
    .return ($P1009)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("204_1300051172.188")
    .param pmc param_1011
.annotate 'line', 460
    .lex "self", param_1011
    $P1012 = param_1011."!PREFIX__!protoregex"("trait_mod")
    .return ($P1012)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("205_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1014_tgt
    .local int rx1014_pos
    .local int rx1014_off
    .local int rx1014_eos
    .local int rx1014_rep
    .local pmc rx1014_cur
    .local pmc rx1014_debug
    (rx1014_cur, rx1014_pos, rx1014_tgt, $I10) = self."!cursor_start"()
    rx1014_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1014_cur
    .local pmc match
    .lex "$/", match
    length rx1014_eos, rx1014_tgt
    gt rx1014_pos, rx1014_eos, rx1014_done
    set rx1014_off, 0
    lt rx1014_pos, 2, rx1014_start
    sub rx1014_off, rx1014_pos, 1
    substr rx1014_tgt, rx1014_tgt, rx1014_off
  rx1014_start:
    eq $I10, 1, rx1014_restart
    if_null rx1014_debug, debug_813
    rx1014_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_813:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1018_done
    goto rxscan1018_scan
  rxscan1018_loop:
    (rx1014_pos) = rx1014_cur."from"()
    inc rx1014_pos
    rx1014_cur."!cursor_from"(rx1014_pos)
    ge rx1014_pos, rx1014_eos, rxscan1018_done
  rxscan1018_scan:
    set_addr $I10, rxscan1018_loop
    rx1014_cur."!mark_push"(0, rx1014_pos, $I10)
  rxscan1018_done:
.annotate 'line', 461
  # rx subcapture "sym"
    set_addr $I10, rxcap_1019_fail
    rx1014_cur."!mark_push"(0, rx1014_pos, $I10)
  # rx literal  "is"
    add $I11, rx1014_pos, 2
    gt $I11, rx1014_eos, rx1014_fail
    sub $I11, rx1014_pos, rx1014_off
    substr $S10, rx1014_tgt, $I11, 2
    ne $S10, "is", rx1014_fail
    add rx1014_pos, 2
    set_addr $I10, rxcap_1019_fail
    ($I12, $I11) = rx1014_cur."!mark_peek"($I10)
    rx1014_cur."!cursor_pos"($I11)
    ($P10) = rx1014_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1014_pos, "")
    rx1014_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1019_done
  rxcap_1019_fail:
    goto rx1014_fail
  rxcap_1019_done:
  # rx subrule "ws" subtype=method negate=
    rx1014_cur."!cursor_pos"(rx1014_pos)
    $P10 = rx1014_cur."ws"()
    unless $P10, rx1014_fail
    rx1014_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1014_cur."!cursor_pos"(rx1014_pos)
    $P10 = rx1014_cur."deflongname"()
    unless $P10, rx1014_fail
    rx1014_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1014_pos = $P10."pos"()
  # rx rxquantr1021 ** 0..1
    set_addr $I10, rxquantr1021_done
    rx1014_cur."!mark_push"(0, rx1014_pos, $I10)
  rxquantr1021_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1014_cur."!cursor_pos"(rx1014_pos)
    $P10 = rx1014_cur."circumfix"()
    unless $P10, rx1014_fail
    goto rxsubrule1022_pass
  rxsubrule1022_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1014_fail
  rxsubrule1022_pass:
    set_addr $I10, rxsubrule1022_back
    rx1014_cur."!mark_push"(0, rx1014_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1014_pos = $P10."pos"()
    set_addr $I10, rxquantr1021_done
    (rx1014_rep) = rx1014_cur."!mark_commit"($I10)
  rxquantr1021_done:
  # rx subrule "ws" subtype=method negate=
    rx1014_cur."!cursor_pos"(rx1014_pos)
    $P10 = rx1014_cur."ws"()
    unless $P10, rx1014_fail
    rx1014_pos = $P10."pos"()
  # rx pass
    rx1014_cur."!cursor_pass"(rx1014_pos, "trait_mod:sym<is>")
    if_null rx1014_debug, debug_814
    rx1014_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1014_pos)
  debug_814:
    .return (rx1014_cur)
  rx1014_restart:
.annotate 'line', 4
    if_null rx1014_debug, debug_815
    rx1014_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_815:
  rx1014_fail:
    (rx1014_rep, rx1014_pos, $I10, $P10) = rx1014_cur."!mark_fail"(0)
    lt rx1014_pos, -1, rx1014_done
    eq rx1014_pos, -1, rx1014_fail
    jump $I10
  rx1014_done:
    rx1014_cur."!cursor_fail"()
    if_null rx1014_debug, debug_816
    rx1014_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_816:
    .return (rx1014_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("206_1300051172.188") :method
.annotate 'line', 4
    $P1016 = self."!PREFIX__!subrule"("ws", "is")
    new $P1017, "ResizablePMCArray"
    push $P1017, $P1016
    .return ($P1017)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("207_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1025_tgt
    .local int rx1025_pos
    .local int rx1025_off
    .local int rx1025_eos
    .local int rx1025_rep
    .local pmc rx1025_cur
    .local pmc rx1025_debug
    (rx1025_cur, rx1025_pos, rx1025_tgt, $I10) = self."!cursor_start"()
    rx1025_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1025_cur
    .local pmc match
    .lex "$/", match
    length rx1025_eos, rx1025_tgt
    gt rx1025_pos, rx1025_eos, rx1025_done
    set rx1025_off, 0
    lt rx1025_pos, 2, rx1025_start
    sub rx1025_off, rx1025_pos, 1
    substr rx1025_tgt, rx1025_tgt, rx1025_off
  rx1025_start:
    eq $I10, 1, rx1025_restart
    if_null rx1025_debug, debug_817
    rx1025_cur."!cursor_debug"("START", "regex_declarator")
  debug_817:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1029_done
    goto rxscan1029_scan
  rxscan1029_loop:
    (rx1025_pos) = rx1025_cur."from"()
    inc rx1025_pos
    rx1025_cur."!cursor_from"(rx1025_pos)
    ge rx1025_pos, rx1025_eos, rxscan1029_done
  rxscan1029_scan:
    set_addr $I10, rxscan1029_loop
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  rxscan1029_done:
.annotate 'line', 463
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  alt1031_0:
.annotate 'line', 464
    set_addr $I10, alt1031_1
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
.annotate 'line', 465
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1033_fail
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1025_pos, 5
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 5
    ne $S10, "proto", rx1025_fail
    add rx1025_pos, 5
    set_addr $I10, rxcap_1033_fail
    ($I12, $I11) = rx1025_cur."!mark_peek"($I10)
    rx1025_cur."!cursor_pos"($I11)
    ($P10) = rx1025_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1025_pos, "")
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1033_done
  rxcap_1033_fail:
    goto rx1025_fail
  rxcap_1033_done:
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  alt1035_0:
    set_addr $I10, alt1035_1
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1025_pos, 5
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 5
    ne $S10, "regex", rx1025_fail
    add rx1025_pos, 5
    goto alt1035_end
  alt1035_1:
    set_addr $I10, alt1035_2
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  # rx literal  "token"
    add $I11, rx1025_pos, 5
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 5
    ne $S10, "token", rx1025_fail
    add rx1025_pos, 5
    goto alt1035_end
  alt1035_2:
  # rx literal  "rule"
    add $I11, rx1025_pos, 4
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 4
    ne $S10, "rule", rx1025_fail
    add rx1025_pos, 4
  alt1035_end:
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 466
  # rx subrule "deflongname" subtype=capture negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."deflongname"()
    unless $P10, rx1025_fail
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  alt1038_0:
.annotate 'line', 467
    set_addr $I10, alt1038_1
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
.annotate 'line', 468
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 123, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1025_pos, 5
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 5
    ne $S10, "<...>", rx1025_fail
    add rx1025_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 125, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ENDSTMT"()
    unless $P10, rx1025_fail
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
    goto alt1038_end
  alt1038_1:
    set_addr $I10, alt1038_2
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
.annotate 'line', 469
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 123, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1025_pos, 3
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 3
    ne $S10, "<*>", rx1025_fail
    add rx1025_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 125, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ENDSTMT"()
    unless $P10, rx1025_fail
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
    goto alt1038_end
  alt1038_2:
.annotate 'line', 470
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  alt1038_end:
.annotate 'line', 471
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 465
    goto alt1031_end
  alt1031_1:
.annotate 'line', 472
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1052_fail
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  alt1051_0:
    set_addr $I10, alt1051_1
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1025_pos, 5
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 5
    ne $S10, "regex", rx1025_fail
    add rx1025_pos, 5
    goto alt1051_end
  alt1051_1:
    set_addr $I10, alt1051_2
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  # rx literal  "token"
    add $I11, rx1025_pos, 5
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 5
    ne $S10, "token", rx1025_fail
    add rx1025_pos, 5
    goto alt1051_end
  alt1051_2:
  # rx literal  "rule"
    add $I11, rx1025_pos, 4
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 4
    ne $S10, "rule", rx1025_fail
    add rx1025_pos, 4
  alt1051_end:
    set_addr $I10, rxcap_1052_fail
    ($I12, $I11) = rx1025_cur."!mark_peek"($I10)
    rx1025_cur."!cursor_pos"($I11)
    ($P10) = rx1025_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1025_pos, "")
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1052_done
  rxcap_1052_fail:
    goto rx1025_fail
  rxcap_1052_done:
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 473
  # rx subrule "deflongname" subtype=capture negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."deflongname"()
    unless $P10, rx1025_fail
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 474
  # rx subrule "newpad" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."newpad"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 475
  # rx rxquantr1056 ** 0..1
    set_addr $I10, rxquantr1056_done
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  rxquantr1056_loop:
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 40, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."signature"()
    unless $P10, rx1025_fail
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 41, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
    set_addr $I10, rxquantr1056_done
    (rx1025_rep) = rx1025_cur."!mark_commit"($I10)
  rxquantr1056_done:
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 476
  # rx reduce name="regex_declarator" key="open"
    rx1025_cur."!cursor_pos"(rx1025_pos)
    rx1025_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 477
  # rx literal  "{"
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 123, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1025_fail
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1025_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1025_pos, 1
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    ord $I11, rx1025_tgt, $I11
    ne $I11, 125, rx1025_fail
    add rx1025_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ENDSTMT"()
    unless $P10, rx1025_fail
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  alt1031_end:
.annotate 'line', 478
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
.annotate 'line', 463
  # rx pass
    rx1025_cur."!cursor_pass"(rx1025_pos, "regex_declarator")
    if_null rx1025_debug, debug_818
    rx1025_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1025_pos)
  debug_818:
    .return (rx1025_cur)
  rx1025_restart:
.annotate 'line', 4
    if_null rx1025_debug, debug_819
    rx1025_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_819:
  rx1025_fail:
    (rx1025_rep, rx1025_pos, $I10, $P10) = rx1025_cur."!mark_fail"(0)
    lt rx1025_pos, -1, rx1025_done
    eq rx1025_pos, -1, rx1025_fail
    jump $I10
  rx1025_done:
    rx1025_cur."!cursor_fail"()
    if_null rx1025_debug, debug_820
    rx1025_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_820:
    .return (rx1025_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("208_1300051172.188") :method
.annotate 'line', 4
    $P1027 = self."!PREFIX__!subrule"("ws", "")
    new $P1028, "ResizablePMCArray"
    push $P1028, $P1027
    .return ($P1028)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("209_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1066_tgt
    .local int rx1066_pos
    .local int rx1066_off
    .local int rx1066_eos
    .local int rx1066_rep
    .local pmc rx1066_cur
    .local pmc rx1066_debug
    (rx1066_cur, rx1066_pos, rx1066_tgt, $I10) = self."!cursor_start"()
    rx1066_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1066_cur
    .local pmc match
    .lex "$/", match
    length rx1066_eos, rx1066_tgt
    gt rx1066_pos, rx1066_eos, rx1066_done
    set rx1066_off, 0
    lt rx1066_pos, 2, rx1066_start
    sub rx1066_off, rx1066_pos, 1
    substr rx1066_tgt, rx1066_tgt, rx1066_off
  rx1066_start:
    eq $I10, 1, rx1066_restart
    if_null rx1066_debug, debug_821
    rx1066_cur."!cursor_debug"("START", "dotty")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1070_done
    goto rxscan1070_scan
  rxscan1070_loop:
    (rx1066_pos) = rx1066_cur."from"()
    inc rx1066_pos
    rx1066_cur."!cursor_from"(rx1066_pos)
    ge rx1066_pos, rx1066_eos, rxscan1070_done
  rxscan1070_scan:
    set_addr $I10, rxscan1070_loop
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxscan1070_done:
.annotate 'line', 482
  # rx literal  "."
    add $I11, rx1066_pos, 1
    gt $I11, rx1066_eos, rx1066_fail
    sub $I11, rx1066_pos, rx1066_off
    ord $I11, rx1066_tgt, $I11
    ne $I11, 46, rx1066_fail
    add rx1066_pos, 1
  alt1071_0:
.annotate 'line', 483
    set_addr $I10, alt1071_1
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."deflongname"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1066_pos = $P10."pos"()
    goto alt1071_end
  alt1071_1:
.annotate 'line', 484
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1066_pos, rx1066_off
    substr $S10, rx1066_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1066_fail
  # rx subrule "quote" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."quote"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1066_pos = $P10."pos"()
  alt1072_0:
.annotate 'line', 485
    set_addr $I10, alt1072_1
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1066_pos, rx1066_off
    substr $S10, rx1066_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1066_fail
    goto alt1072_end
  alt1072_1:
  # rx subrule "panic" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
  alt1072_end:
  alt1071_end:
.annotate 'line', 491
  # rx rxquantr1073 ** 0..1
    set_addr $I10, rxquantr1073_done
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxquantr1073_loop:
  alt1074_0:
.annotate 'line', 488
    set_addr $I10, alt1074_1
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
.annotate 'line', 489
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1066_pos, rx1066_off
    substr $S10, rx1066_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1066_fail
  # rx subrule "args" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."args"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1066_pos = $P10."pos"()
    goto alt1074_end
  alt1074_1:
.annotate 'line', 490
  # rx literal  ":"
    add $I11, rx1066_pos, 1
    gt $I11, rx1066_eos, rx1066_fail
    sub $I11, rx1066_pos, rx1066_off
    ord $I11, rx1066_tgt, $I11
    ne $I11, 58, rx1066_fail
    add rx1066_pos, 1
  # rx charclass s
    ge rx1066_pos, rx1066_eos, rx1066_fail
    sub $I10, rx1066_pos, rx1066_off
    is_cclass $I11, 32, rx1066_tgt, $I10
    unless $I11, rx1066_fail
    inc rx1066_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."arglist"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1066_pos = $P10."pos"()
  alt1074_end:
.annotate 'line', 491
    set_addr $I10, rxquantr1073_done
    (rx1066_rep) = rx1066_cur."!mark_commit"($I10)
  rxquantr1073_done:
.annotate 'line', 481
  # rx pass
    rx1066_cur."!cursor_pass"(rx1066_pos, "dotty")
    if_null rx1066_debug, debug_822
    rx1066_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1066_pos)
  debug_822:
    .return (rx1066_cur)
  rx1066_restart:
.annotate 'line', 4
    if_null rx1066_debug, debug_823
    rx1066_cur."!cursor_debug"("NEXT", "dotty")
  debug_823:
  rx1066_fail:
    (rx1066_rep, rx1066_pos, $I10, $P10) = rx1066_cur."!mark_fail"(0)
    lt rx1066_pos, -1, rx1066_done
    eq rx1066_pos, -1, rx1066_fail
    jump $I10
  rx1066_done:
    rx1066_cur."!cursor_fail"()
    if_null rx1066_debug, debug_824
    rx1066_cur."!cursor_debug"("FAIL", "dotty")
  debug_824:
    .return (rx1066_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("210_1300051172.188") :method
.annotate 'line', 4
    $P1068 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1069, "ResizablePMCArray"
    push $P1069, "'"
    push $P1069, "\""
    push $P1069, $P1068
    .return ($P1069)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("211_1300051172.188")
    .param pmc param_1076
.annotate 'line', 495
    .lex "self", param_1076
    $P1077 = param_1076."!protoregex"("term")
    .return ($P1077)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("212_1300051172.188")
    .param pmc param_1079
.annotate 'line', 495
    .lex "self", param_1079
    $P1080 = param_1079."!PREFIX__!protoregex"("term")
    .return ($P1080)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("213_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1082_tgt
    .local int rx1082_pos
    .local int rx1082_off
    .local int rx1082_eos
    .local int rx1082_rep
    .local pmc rx1082_cur
    .local pmc rx1082_debug
    (rx1082_cur, rx1082_pos, rx1082_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1082_cur
    .local pmc match
    .lex "$/", match
    length rx1082_eos, rx1082_tgt
    gt rx1082_pos, rx1082_eos, rx1082_done
    set rx1082_off, 0
    lt rx1082_pos, 2, rx1082_start
    sub rx1082_off, rx1082_pos, 1
    substr rx1082_tgt, rx1082_tgt, rx1082_off
  rx1082_start:
    eq $I10, 1, rx1082_restart
    if_null rx1082_debug, debug_825
    rx1082_cur."!cursor_debug"("START", "term:sym<self>")
  debug_825:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1085_done
    goto rxscan1085_scan
  rxscan1085_loop:
    (rx1082_pos) = rx1082_cur."from"()
    inc rx1082_pos
    rx1082_cur."!cursor_from"(rx1082_pos)
    ge rx1082_pos, rx1082_eos, rxscan1085_done
  rxscan1085_scan:
    set_addr $I10, rxscan1085_loop
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxscan1085_done:
.annotate 'line', 497
  # rx subcapture "sym"
    set_addr $I10, rxcap_1086_fail
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx literal  "self"
    add $I11, rx1082_pos, 4
    gt $I11, rx1082_eos, rx1082_fail
    sub $I11, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I11, 4
    ne $S10, "self", rx1082_fail
    add rx1082_pos, 4
    set_addr $I10, rxcap_1086_fail
    ($I12, $I11) = rx1082_cur."!mark_peek"($I10)
    rx1082_cur."!cursor_pos"($I11)
    ($P10) = rx1082_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1082_pos, "")
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1086_done
  rxcap_1086_fail:
    goto rx1082_fail
  rxcap_1086_done:
  # rxanchor rwb
    le rx1082_pos, 0, rx1082_fail
    sub $I10, rx1082_pos, rx1082_off
    is_cclass $I11, 8192, rx1082_tgt, $I10
    if $I11, rx1082_fail
    dec $I10
    is_cclass $I11, 8192, rx1082_tgt, $I10
    unless $I11, rx1082_fail
  # rx pass
    rx1082_cur."!cursor_pass"(rx1082_pos, "term:sym<self>")
    if_null rx1082_debug, debug_826
    rx1082_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1082_pos)
  debug_826:
    .return (rx1082_cur)
  rx1082_restart:
.annotate 'line', 4
    if_null rx1082_debug, debug_827
    rx1082_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_827:
  rx1082_fail:
    (rx1082_rep, rx1082_pos, $I10, $P10) = rx1082_cur."!mark_fail"(0)
    lt rx1082_pos, -1, rx1082_done
    eq rx1082_pos, -1, rx1082_fail
    jump $I10
  rx1082_done:
    rx1082_cur."!cursor_fail"()
    if_null rx1082_debug, debug_828
    rx1082_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_828:
    .return (rx1082_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("214_1300051172.188") :method
.annotate 'line', 4
    new $P1084, "ResizablePMCArray"
    push $P1084, "self"
    .return ($P1084)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("215_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1088_tgt
    .local int rx1088_pos
    .local int rx1088_off
    .local int rx1088_eos
    .local int rx1088_rep
    .local pmc rx1088_cur
    .local pmc rx1088_debug
    (rx1088_cur, rx1088_pos, rx1088_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1088_cur
    .local pmc match
    .lex "$/", match
    length rx1088_eos, rx1088_tgt
    gt rx1088_pos, rx1088_eos, rx1088_done
    set rx1088_off, 0
    lt rx1088_pos, 2, rx1088_start
    sub rx1088_off, rx1088_pos, 1
    substr rx1088_tgt, rx1088_tgt, rx1088_off
  rx1088_start:
    eq $I10, 1, rx1088_restart
    if_null rx1088_debug, debug_829
    rx1088_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_829:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1092_done
    goto rxscan1092_scan
  rxscan1092_loop:
    (rx1088_pos) = rx1088_cur."from"()
    inc rx1088_pos
    rx1088_cur."!cursor_from"(rx1088_pos)
    ge rx1088_pos, rx1088_eos, rxscan1092_done
  rxscan1092_scan:
    set_addr $I10, rxscan1092_loop
    rx1088_cur."!mark_push"(0, rx1088_pos, $I10)
  rxscan1092_done:
.annotate 'line', 500
  # rx subrule "deflongname" subtype=capture negate=
    rx1088_cur."!cursor_pos"(rx1088_pos)
    $P10 = rx1088_cur."deflongname"()
    unless $P10, rx1088_fail
    rx1088_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1088_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1088_pos, rx1088_off
    substr $S10, rx1088_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1088_fail
  # rx subrule "args" subtype=capture negate=
    rx1088_cur."!cursor_pos"(rx1088_pos)
    $P10 = rx1088_cur."args"()
    unless $P10, rx1088_fail
    rx1088_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1088_pos = $P10."pos"()
.annotate 'line', 499
  # rx pass
    rx1088_cur."!cursor_pass"(rx1088_pos, "term:sym<identifier>")
    if_null rx1088_debug, debug_830
    rx1088_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1088_pos)
  debug_830:
    .return (rx1088_cur)
  rx1088_restart:
.annotate 'line', 4
    if_null rx1088_debug, debug_831
    rx1088_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_831:
  rx1088_fail:
    (rx1088_rep, rx1088_pos, $I10, $P10) = rx1088_cur."!mark_fail"(0)
    lt rx1088_pos, -1, rx1088_done
    eq rx1088_pos, -1, rx1088_fail
    jump $I10
  rx1088_done:
    rx1088_cur."!cursor_fail"()
    if_null rx1088_debug, debug_832
    rx1088_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_832:
    .return (rx1088_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("216_1300051172.188") :method
.annotate 'line', 4
    $P1090 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1091, "ResizablePMCArray"
    push $P1091, $P1090
    .return ($P1091)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("217_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1094_tgt
    .local int rx1094_pos
    .local int rx1094_off
    .local int rx1094_eos
    .local int rx1094_rep
    .local pmc rx1094_cur
    .local pmc rx1094_debug
    (rx1094_cur, rx1094_pos, rx1094_tgt, $I10) = self."!cursor_start"()
    rx1094_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1094_cur
    .local pmc match
    .lex "$/", match
    length rx1094_eos, rx1094_tgt
    gt rx1094_pos, rx1094_eos, rx1094_done
    set rx1094_off, 0
    lt rx1094_pos, 2, rx1094_start
    sub rx1094_off, rx1094_pos, 1
    substr rx1094_tgt, rx1094_tgt, rx1094_off
  rx1094_start:
    eq $I10, 1, rx1094_restart
    if_null rx1094_debug, debug_833
    rx1094_cur."!cursor_debug"("START", "term:sym<name>")
  debug_833:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1098_done
    goto rxscan1098_scan
  rxscan1098_loop:
    (rx1094_pos) = rx1094_cur."from"()
    inc rx1094_pos
    rx1094_cur."!cursor_from"(rx1094_pos)
    ge rx1094_pos, rx1094_eos, rxscan1098_done
  rxscan1098_scan:
    set_addr $I10, rxscan1098_loop
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  rxscan1098_done:
.annotate 'line', 504
  # rx subrule "name" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."name"()
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1094_pos = $P10."pos"()
  # rx rxquantr1099 ** 0..1
    set_addr $I10, rxquantr1099_done
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  rxquantr1099_loop:
  # rx subrule "args" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."args"()
    unless $P10, rx1094_fail
    goto rxsubrule1100_pass
  rxsubrule1100_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1094_fail
  rxsubrule1100_pass:
    set_addr $I10, rxsubrule1100_back
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1094_pos = $P10."pos"()
    set_addr $I10, rxquantr1099_done
    (rx1094_rep) = rx1094_cur."!mark_commit"($I10)
  rxquantr1099_done:
.annotate 'line', 503
  # rx pass
    rx1094_cur."!cursor_pass"(rx1094_pos, "term:sym<name>")
    if_null rx1094_debug, debug_834
    rx1094_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1094_pos)
  debug_834:
    .return (rx1094_cur)
  rx1094_restart:
.annotate 'line', 4
    if_null rx1094_debug, debug_835
    rx1094_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_835:
  rx1094_fail:
    (rx1094_rep, rx1094_pos, $I10, $P10) = rx1094_cur."!mark_fail"(0)
    lt rx1094_pos, -1, rx1094_done
    eq rx1094_pos, -1, rx1094_fail
    jump $I10
  rx1094_done:
    rx1094_cur."!cursor_fail"()
    if_null rx1094_debug, debug_836
    rx1094_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_836:
    .return (rx1094_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("218_1300051172.188") :method
.annotate 'line', 4
    $P1096 = self."!PREFIX__!subrule"("name", "")
    new $P1097, "ResizablePMCArray"
    push $P1097, $P1096
    .return ($P1097)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("219_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1102_tgt
    .local int rx1102_pos
    .local int rx1102_off
    .local int rx1102_eos
    .local int rx1102_rep
    .local pmc rx1102_cur
    .local pmc rx1102_debug
    (rx1102_cur, rx1102_pos, rx1102_tgt, $I10) = self."!cursor_start"()
    rx1102_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1102_cur
    .local pmc match
    .lex "$/", match
    length rx1102_eos, rx1102_tgt
    gt rx1102_pos, rx1102_eos, rx1102_done
    set rx1102_off, 0
    lt rx1102_pos, 2, rx1102_start
    sub rx1102_off, rx1102_pos, 1
    substr rx1102_tgt, rx1102_tgt, rx1102_off
  rx1102_start:
    eq $I10, 1, rx1102_restart
    if_null rx1102_debug, debug_837
    rx1102_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_837:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1105_done
    goto rxscan1105_scan
  rxscan1105_loop:
    (rx1102_pos) = rx1102_cur."from"()
    inc rx1102_pos
    rx1102_cur."!cursor_from"(rx1102_pos)
    ge rx1102_pos, rx1102_eos, rxscan1105_done
  rxscan1105_scan:
    set_addr $I10, rxscan1105_loop
    rx1102_cur."!mark_push"(0, rx1102_pos, $I10)
  rxscan1105_done:
.annotate 'line', 508
  # rx literal  "pir::"
    add $I11, rx1102_pos, 5
    gt $I11, rx1102_eos, rx1102_fail
    sub $I11, rx1102_pos, rx1102_off
    substr $S10, rx1102_tgt, $I11, 5
    ne $S10, "pir::", rx1102_fail
    add rx1102_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1106_fail
    rx1102_cur."!mark_push"(0, rx1102_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1102_pos, rx1102_off
    find_not_cclass $I11, 8192, rx1102_tgt, $I10, rx1102_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1102_fail
    add rx1102_pos, rx1102_off, $I11
    set_addr $I10, rxcap_1106_fail
    ($I12, $I11) = rx1102_cur."!mark_peek"($I10)
    rx1102_cur."!cursor_pos"($I11)
    ($P10) = rx1102_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1102_pos, "")
    rx1102_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1106_done
  rxcap_1106_fail:
    goto rx1102_fail
  rxcap_1106_done:
  # rx rxquantr1107 ** 0..1
    set_addr $I10, rxquantr1107_done
    rx1102_cur."!mark_push"(0, rx1102_pos, $I10)
  rxquantr1107_loop:
  # rx subrule "args" subtype=capture negate=
    rx1102_cur."!cursor_pos"(rx1102_pos)
    $P10 = rx1102_cur."args"()
    unless $P10, rx1102_fail
    goto rxsubrule1108_pass
  rxsubrule1108_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1102_fail
  rxsubrule1108_pass:
    set_addr $I10, rxsubrule1108_back
    rx1102_cur."!mark_push"(0, rx1102_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1102_pos = $P10."pos"()
    set_addr $I10, rxquantr1107_done
    (rx1102_rep) = rx1102_cur."!mark_commit"($I10)
  rxquantr1107_done:
.annotate 'line', 507
  # rx pass
    rx1102_cur."!cursor_pass"(rx1102_pos, "term:sym<pir::op>")
    if_null rx1102_debug, debug_838
    rx1102_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1102_pos)
  debug_838:
    .return (rx1102_cur)
  rx1102_restart:
.annotate 'line', 4
    if_null rx1102_debug, debug_839
    rx1102_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_839:
  rx1102_fail:
    (rx1102_rep, rx1102_pos, $I10, $P10) = rx1102_cur."!mark_fail"(0)
    lt rx1102_pos, -1, rx1102_done
    eq rx1102_pos, -1, rx1102_fail
    jump $I10
  rx1102_done:
    rx1102_cur."!cursor_fail"()
    if_null rx1102_debug, debug_840
    rx1102_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_840:
    .return (rx1102_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("220_1300051172.188") :method
.annotate 'line', 4
    new $P1104, "ResizablePMCArray"
    push $P1104, "pir::"
    .return ($P1104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("221_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P1118 = "223_1300051172.188" 
    capture_lex $P1118
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_841
    rx1110_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_841:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1113_done
    goto rxscan1113_scan
  rxscan1113_loop:
    (rx1110_pos) = rx1110_cur."from"()
    inc rx1110_pos
    rx1110_cur."!cursor_from"(rx1110_pos)
    ge rx1110_pos, rx1110_eos, rxscan1113_done
  rxscan1113_scan:
    set_addr $I10, rxscan1113_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1113_done:
.annotate 'line', 512
  # rx literal  "{*}"
    add $I11, rx1110_pos, 3
    gt $I11, rx1110_eos, rx1110_fail
    sub $I11, rx1110_pos, rx1110_off
    substr $S10, rx1110_tgt, $I11, 3
    ne $S10, "{*}", rx1110_fail
    add rx1110_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."ENDSTMT"()
    unless $P10, rx1110_fail
  alt1114_0:
.annotate 'line', 513
    set_addr $I10, alt1114_1
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
    rx1110_cur."!cursor_pos"(rx1110_pos)
    find_lex $P1115, unicode:"$\x{a2}"
    $P1116 = $P1115."MATCH"()
    store_lex "$/", $P1116
    .const 'Sub' $P1118 = "223_1300051172.188" 
    capture_lex $P1118
    $P1122 = $P1118()
    unless $P1122, rx1110_fail
    goto alt1114_end
  alt1114_1:
  # rx subrule "panic" subtype=method negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1110_fail
    rx1110_pos = $P10."pos"()
  alt1114_end:
.annotate 'line', 511
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "term:sym<onlystar>")
    if_null rx1110_debug, debug_844
    rx1110_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1110_pos)
  debug_844:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 4
    if_null rx1110_debug, debug_845
    rx1110_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_845:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_846
    rx1110_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_846:
    .return (rx1110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("222_1300051172.188") :method
.annotate 'line', 4
    new $P1112, "ResizablePMCArray"
    push $P1112, "{*}"
    .return ($P1112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1117"  :anon :subid("223_1300051172.188") :outer("221_1300051172.188")
.annotate 'line', 513
    find_dynamic_lex $P1119, "$*MULTINESS"
    unless_null $P1119, vivify_842
    get_hll_global $P1119, "$MULTINESS"
    unless_null $P1119, vivify_843
    die "Contextual $*MULTINESS not found"
  vivify_843:
  vivify_842:
    set $S1120, $P1119
    iseq $I1121, $S1120, "proto"
    .return ($I1121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("224_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1124_tgt
    .local int rx1124_pos
    .local int rx1124_off
    .local int rx1124_eos
    .local int rx1124_rep
    .local pmc rx1124_cur
    .local pmc rx1124_debug
    (rx1124_cur, rx1124_pos, rx1124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1124_cur
    .local pmc match
    .lex "$/", match
    length rx1124_eos, rx1124_tgt
    gt rx1124_pos, rx1124_eos, rx1124_done
    set rx1124_off, 0
    lt rx1124_pos, 2, rx1124_start
    sub rx1124_off, rx1124_pos, 1
    substr rx1124_tgt, rx1124_tgt, rx1124_off
  rx1124_start:
    eq $I10, 1, rx1124_restart
    if_null rx1124_debug, debug_847
    rx1124_cur."!cursor_debug"("START", "args")
  debug_847:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1128_done
    goto rxscan1128_scan
  rxscan1128_loop:
    (rx1124_pos) = rx1124_cur."from"()
    inc rx1124_pos
    rx1124_cur."!cursor_from"(rx1124_pos)
    ge rx1124_pos, rx1124_eos, rxscan1128_done
  rxscan1128_scan:
    set_addr $I10, rxscan1128_loop
    rx1124_cur."!mark_push"(0, rx1124_pos, $I10)
  rxscan1128_done:
.annotate 'line', 517
  # rx literal  "("
    add $I11, rx1124_pos, 1
    gt $I11, rx1124_eos, rx1124_fail
    sub $I11, rx1124_pos, rx1124_off
    ord $I11, rx1124_tgt, $I11
    ne $I11, 40, rx1124_fail
    add rx1124_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."arglist"()
    unless $P10, rx1124_fail
    rx1124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1124_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1124_pos, 1
    gt $I11, rx1124_eos, rx1124_fail
    sub $I11, rx1124_pos, rx1124_off
    ord $I11, rx1124_tgt, $I11
    ne $I11, 41, rx1124_fail
    add rx1124_pos, 1
  # rx pass
    rx1124_cur."!cursor_pass"(rx1124_pos, "args")
    if_null rx1124_debug, debug_848
    rx1124_cur."!cursor_debug"("PASS", "args", " at pos=", rx1124_pos)
  debug_848:
    .return (rx1124_cur)
  rx1124_restart:
.annotate 'line', 4
    if_null rx1124_debug, debug_849
    rx1124_cur."!cursor_debug"("NEXT", "args")
  debug_849:
  rx1124_fail:
    (rx1124_rep, rx1124_pos, $I10, $P10) = rx1124_cur."!mark_fail"(0)
    lt rx1124_pos, -1, rx1124_done
    eq rx1124_pos, -1, rx1124_fail
    jump $I10
  rx1124_done:
    rx1124_cur."!cursor_fail"()
    if_null rx1124_debug, debug_850
    rx1124_cur."!cursor_debug"("FAIL", "args")
  debug_850:
    .return (rx1124_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("225_1300051172.188") :method
.annotate 'line', 4
    $P1126 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1127, "ResizablePMCArray"
    push $P1127, $P1126
    .return ($P1127)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("226_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_851
    rx1130_cur."!cursor_debug"("START", "arglist")
  debug_851:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 521
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1135_0:
.annotate 'line', 522
    set_addr $I10, alt1135_1
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
.annotate 'line', 523
  # rx subrule "EXPR" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."EXPR"("f=")
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1130_pos = $P10."pos"()
    goto alt1135_end
  alt1135_1:
  alt1135_end:
.annotate 'line', 520
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "arglist")
    if_null rx1130_debug, debug_852
    rx1130_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1130_pos)
  debug_852:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 4
    if_null rx1130_debug, debug_853
    rx1130_cur."!cursor_debug"("NEXT", "arglist")
  debug_853:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_854
    rx1130_cur."!cursor_debug"("FAIL", "arglist")
  debug_854:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("227_1300051172.188") :method
.annotate 'line', 4
    $P1132 = self."!PREFIX__!subrule"("ws", "")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("228_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1137_tgt
    .local int rx1137_pos
    .local int rx1137_off
    .local int rx1137_eos
    .local int rx1137_rep
    .local pmc rx1137_cur
    .local pmc rx1137_debug
    (rx1137_cur, rx1137_pos, rx1137_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1137_cur
    .local pmc match
    .lex "$/", match
    length rx1137_eos, rx1137_tgt
    gt rx1137_pos, rx1137_eos, rx1137_done
    set rx1137_off, 0
    lt rx1137_pos, 2, rx1137_start
    sub rx1137_off, rx1137_pos, 1
    substr rx1137_tgt, rx1137_tgt, rx1137_off
  rx1137_start:
    eq $I10, 1, rx1137_restart
    if_null rx1137_debug, debug_855
    rx1137_cur."!cursor_debug"("START", "term:sym<value>")
  debug_855:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1141_done
    goto rxscan1141_scan
  rxscan1141_loop:
    (rx1137_pos) = rx1137_cur."from"()
    inc rx1137_pos
    rx1137_cur."!cursor_from"(rx1137_pos)
    ge rx1137_pos, rx1137_eos, rxscan1141_done
  rxscan1141_scan:
    set_addr $I10, rxscan1141_loop
    rx1137_cur."!mark_push"(0, rx1137_pos, $I10)
  rxscan1141_done:
.annotate 'line', 529
  # rx subrule "value" subtype=capture negate=
    rx1137_cur."!cursor_pos"(rx1137_pos)
    $P10 = rx1137_cur."value"()
    unless $P10, rx1137_fail
    rx1137_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1137_pos = $P10."pos"()
  # rx pass
    rx1137_cur."!cursor_pass"(rx1137_pos, "term:sym<value>")
    if_null rx1137_debug, debug_856
    rx1137_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1137_pos)
  debug_856:
    .return (rx1137_cur)
  rx1137_restart:
.annotate 'line', 4
    if_null rx1137_debug, debug_857
    rx1137_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_857:
  rx1137_fail:
    (rx1137_rep, rx1137_pos, $I10, $P10) = rx1137_cur."!mark_fail"(0)
    lt rx1137_pos, -1, rx1137_done
    eq rx1137_pos, -1, rx1137_fail
    jump $I10
  rx1137_done:
    rx1137_cur."!cursor_fail"()
    if_null rx1137_debug, debug_858
    rx1137_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_858:
    .return (rx1137_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("229_1300051172.188") :method
.annotate 'line', 4
    $P1139 = self."!PREFIX__!subrule"("value", "")
    new $P1140, "ResizablePMCArray"
    push $P1140, $P1139
    .return ($P1140)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("230_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1143_tgt
    .local int rx1143_pos
    .local int rx1143_off
    .local int rx1143_eos
    .local int rx1143_rep
    .local pmc rx1143_cur
    .local pmc rx1143_debug
    (rx1143_cur, rx1143_pos, rx1143_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1143_cur
    .local pmc match
    .lex "$/", match
    length rx1143_eos, rx1143_tgt
    gt rx1143_pos, rx1143_eos, rx1143_done
    set rx1143_off, 0
    lt rx1143_pos, 2, rx1143_start
    sub rx1143_off, rx1143_pos, 1
    substr rx1143_tgt, rx1143_tgt, rx1143_off
  rx1143_start:
    eq $I10, 1, rx1143_restart
    if_null rx1143_debug, debug_859
    rx1143_cur."!cursor_debug"("START", "value")
  debug_859:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1148_done
    goto rxscan1148_scan
  rxscan1148_loop:
    (rx1143_pos) = rx1143_cur."from"()
    inc rx1143_pos
    rx1143_cur."!cursor_from"(rx1143_pos)
    ge rx1143_pos, rx1143_eos, rxscan1148_done
  rxscan1148_scan:
    set_addr $I10, rxscan1148_loop
    rx1143_cur."!mark_push"(0, rx1143_pos, $I10)
  rxscan1148_done:
  alt1149_0:
.annotate 'line', 531
    set_addr $I10, alt1149_1
    rx1143_cur."!mark_push"(0, rx1143_pos, $I10)
.annotate 'line', 532
  # rx subrule "quote" subtype=capture negate=
    rx1143_cur."!cursor_pos"(rx1143_pos)
    $P10 = rx1143_cur."quote"()
    unless $P10, rx1143_fail
    rx1143_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1143_pos = $P10."pos"()
    goto alt1149_end
  alt1149_1:
.annotate 'line', 533
  # rx subrule "number" subtype=capture negate=
    rx1143_cur."!cursor_pos"(rx1143_pos)
    $P10 = rx1143_cur."number"()
    unless $P10, rx1143_fail
    rx1143_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1143_pos = $P10."pos"()
  alt1149_end:
.annotate 'line', 531
  # rx pass
    rx1143_cur."!cursor_pass"(rx1143_pos, "value")
    if_null rx1143_debug, debug_860
    rx1143_cur."!cursor_debug"("PASS", "value", " at pos=", rx1143_pos)
  debug_860:
    .return (rx1143_cur)
  rx1143_restart:
.annotate 'line', 4
    if_null rx1143_debug, debug_861
    rx1143_cur."!cursor_debug"("NEXT", "value")
  debug_861:
  rx1143_fail:
    (rx1143_rep, rx1143_pos, $I10, $P10) = rx1143_cur."!mark_fail"(0)
    lt rx1143_pos, -1, rx1143_done
    eq rx1143_pos, -1, rx1143_fail
    jump $I10
  rx1143_done:
    rx1143_cur."!cursor_fail"()
    if_null rx1143_debug, debug_862
    rx1143_cur."!cursor_debug"("FAIL", "value")
  debug_862:
    .return (rx1143_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("231_1300051172.188") :method
.annotate 'line', 4
    $P1145 = self."!PREFIX__!subrule"("number", "")
    $P1146 = self."!PREFIX__!subrule"("quote", "")
    new $P1147, "ResizablePMCArray"
    push $P1147, $P1145
    push $P1147, $P1146
    .return ($P1147)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("232_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1151_tgt
    .local int rx1151_pos
    .local int rx1151_off
    .local int rx1151_eos
    .local int rx1151_rep
    .local pmc rx1151_cur
    .local pmc rx1151_debug
    (rx1151_cur, rx1151_pos, rx1151_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1151_cur
    .local pmc match
    .lex "$/", match
    length rx1151_eos, rx1151_tgt
    gt rx1151_pos, rx1151_eos, rx1151_done
    set rx1151_off, 0
    lt rx1151_pos, 2, rx1151_start
    sub rx1151_off, rx1151_pos, 1
    substr rx1151_tgt, rx1151_tgt, rx1151_off
  rx1151_start:
    eq $I10, 1, rx1151_restart
    if_null rx1151_debug, debug_863
    rx1151_cur."!cursor_debug"("START", "number")
  debug_863:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1154_done
    goto rxscan1154_scan
  rxscan1154_loop:
    (rx1151_pos) = rx1151_cur."from"()
    inc rx1151_pos
    rx1151_cur."!cursor_from"(rx1151_pos)
    ge rx1151_pos, rx1151_eos, rxscan1154_done
  rxscan1154_scan:
    set_addr $I10, rxscan1154_loop
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  rxscan1154_done:
.annotate 'line', 537
  # rx subcapture "sign"
    set_addr $I10, rxcap_1156_fail
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1151_pos, rx1151_off
    set rx1151_rep, 0
    sub $I12, rx1151_eos, rx1151_pos
    le $I12, 1, rxenumcharlistq1155_loop
    set $I12, 1
  rxenumcharlistq1155_loop:
    le $I12, 0, rxenumcharlistq1155_done
    substr $S10, rx1151_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1155_done
    inc rx1151_rep
  rxenumcharlistq1155_done:
    add rx1151_pos, rx1151_pos, rx1151_rep
    set_addr $I10, rxcap_1156_fail
    ($I12, $I11) = rx1151_cur."!mark_peek"($I10)
    rx1151_cur."!cursor_pos"($I11)
    ($P10) = rx1151_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1151_pos, "")
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1156_done
  rxcap_1156_fail:
    goto rx1151_fail
  rxcap_1156_done:
  alt1157_0:
.annotate 'line', 538
    set_addr $I10, alt1157_1
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."dec_number"()
    unless $P10, rx1151_fail
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1151_pos = $P10."pos"()
    goto alt1157_end
  alt1157_1:
  # rx subrule "integer" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."integer"()
    unless $P10, rx1151_fail
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1151_pos = $P10."pos"()
  alt1157_end:
.annotate 'line', 536
  # rx pass
    rx1151_cur."!cursor_pass"(rx1151_pos, "number")
    if_null rx1151_debug, debug_864
    rx1151_cur."!cursor_debug"("PASS", "number", " at pos=", rx1151_pos)
  debug_864:
    .return (rx1151_cur)
  rx1151_restart:
.annotate 'line', 4
    if_null rx1151_debug, debug_865
    rx1151_cur."!cursor_debug"("NEXT", "number")
  debug_865:
  rx1151_fail:
    (rx1151_rep, rx1151_pos, $I10, $P10) = rx1151_cur."!mark_fail"(0)
    lt rx1151_pos, -1, rx1151_done
    eq rx1151_pos, -1, rx1151_fail
    jump $I10
  rx1151_done:
    rx1151_cur."!cursor_fail"()
    if_null rx1151_debug, debug_866
    rx1151_cur."!cursor_debug"("FAIL", "number")
  debug_866:
    .return (rx1151_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("233_1300051172.188") :method
.annotate 'line', 4
    new $P1153, "ResizablePMCArray"
    push $P1153, ""
    .return ($P1153)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("234_1300051172.188")
    .param pmc param_1159
.annotate 'line', 541
    .lex "self", param_1159
    $P1160 = param_1159."!protoregex"("quote")
    .return ($P1160)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("235_1300051172.188")
    .param pmc param_1162
.annotate 'line', 541
    .lex "self", param_1162
    $P1163 = param_1162."!PREFIX__!protoregex"("quote")
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("236_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1165_tgt
    .local int rx1165_pos
    .local int rx1165_off
    .local int rx1165_eos
    .local int rx1165_rep
    .local pmc rx1165_cur
    .local pmc rx1165_debug
    (rx1165_cur, rx1165_pos, rx1165_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1165_cur
    .local pmc match
    .lex "$/", match
    length rx1165_eos, rx1165_tgt
    gt rx1165_pos, rx1165_eos, rx1165_done
    set rx1165_off, 0
    lt rx1165_pos, 2, rx1165_start
    sub rx1165_off, rx1165_pos, 1
    substr rx1165_tgt, rx1165_tgt, rx1165_off
  rx1165_start:
    eq $I10, 1, rx1165_restart
    if_null rx1165_debug, debug_867
    rx1165_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_867:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1168_done
    goto rxscan1168_scan
  rxscan1168_loop:
    (rx1165_pos) = rx1165_cur."from"()
    inc rx1165_pos
    rx1165_cur."!cursor_from"(rx1165_pos)
    ge rx1165_pos, rx1165_eos, rxscan1168_done
  rxscan1168_scan:
    set_addr $I10, rxscan1168_loop
    rx1165_cur."!mark_push"(0, rx1165_pos, $I10)
  rxscan1168_done:
.annotate 'line', 542
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1165_pos, rx1165_off
    substr $S10, rx1165_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1165_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1165_cur."!cursor_pos"(rx1165_pos)
    $P10 = rx1165_cur."quote_EXPR"(":q")
    unless $P10, rx1165_fail
    rx1165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1165_pos = $P10."pos"()
  # rx pass
    rx1165_cur."!cursor_pass"(rx1165_pos, "quote:sym<apos>")
    if_null rx1165_debug, debug_868
    rx1165_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1165_pos)
  debug_868:
    .return (rx1165_cur)
  rx1165_restart:
.annotate 'line', 4
    if_null rx1165_debug, debug_869
    rx1165_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_869:
  rx1165_fail:
    (rx1165_rep, rx1165_pos, $I10, $P10) = rx1165_cur."!mark_fail"(0)
    lt rx1165_pos, -1, rx1165_done
    eq rx1165_pos, -1, rx1165_fail
    jump $I10
  rx1165_done:
    rx1165_cur."!cursor_fail"()
    if_null rx1165_debug, debug_870
    rx1165_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_870:
    .return (rx1165_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("237_1300051172.188") :method
.annotate 'line', 4
    new $P1167, "ResizablePMCArray"
    push $P1167, "'"
    .return ($P1167)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("238_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1170_tgt
    .local int rx1170_pos
    .local int rx1170_off
    .local int rx1170_eos
    .local int rx1170_rep
    .local pmc rx1170_cur
    .local pmc rx1170_debug
    (rx1170_cur, rx1170_pos, rx1170_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1170_cur
    .local pmc match
    .lex "$/", match
    length rx1170_eos, rx1170_tgt
    gt rx1170_pos, rx1170_eos, rx1170_done
    set rx1170_off, 0
    lt rx1170_pos, 2, rx1170_start
    sub rx1170_off, rx1170_pos, 1
    substr rx1170_tgt, rx1170_tgt, rx1170_off
  rx1170_start:
    eq $I10, 1, rx1170_restart
    if_null rx1170_debug, debug_871
    rx1170_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_871:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1173_done
    goto rxscan1173_scan
  rxscan1173_loop:
    (rx1170_pos) = rx1170_cur."from"()
    inc rx1170_pos
    rx1170_cur."!cursor_from"(rx1170_pos)
    ge rx1170_pos, rx1170_eos, rxscan1173_done
  rxscan1173_scan:
    set_addr $I10, rxscan1173_loop
    rx1170_cur."!mark_push"(0, rx1170_pos, $I10)
  rxscan1173_done:
.annotate 'line', 543
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1170_pos, rx1170_off
    substr $S10, rx1170_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1170_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1170_cur."!cursor_pos"(rx1170_pos)
    $P10 = rx1170_cur."quote_EXPR"(":qq")
    unless $P10, rx1170_fail
    rx1170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1170_pos = $P10."pos"()
  # rx pass
    rx1170_cur."!cursor_pass"(rx1170_pos, "quote:sym<dblq>")
    if_null rx1170_debug, debug_872
    rx1170_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1170_pos)
  debug_872:
    .return (rx1170_cur)
  rx1170_restart:
.annotate 'line', 4
    if_null rx1170_debug, debug_873
    rx1170_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_873:
  rx1170_fail:
    (rx1170_rep, rx1170_pos, $I10, $P10) = rx1170_cur."!mark_fail"(0)
    lt rx1170_pos, -1, rx1170_done
    eq rx1170_pos, -1, rx1170_fail
    jump $I10
  rx1170_done:
    rx1170_cur."!cursor_fail"()
    if_null rx1170_debug, debug_874
    rx1170_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_874:
    .return (rx1170_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("239_1300051172.188") :method
.annotate 'line', 4
    new $P1172, "ResizablePMCArray"
    push $P1172, "\""
    .return ($P1172)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("240_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1175_tgt
    .local int rx1175_pos
    .local int rx1175_off
    .local int rx1175_eos
    .local int rx1175_rep
    .local pmc rx1175_cur
    .local pmc rx1175_debug
    (rx1175_cur, rx1175_pos, rx1175_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1175_cur
    .local pmc match
    .lex "$/", match
    length rx1175_eos, rx1175_tgt
    gt rx1175_pos, rx1175_eos, rx1175_done
    set rx1175_off, 0
    lt rx1175_pos, 2, rx1175_start
    sub rx1175_off, rx1175_pos, 1
    substr rx1175_tgt, rx1175_tgt, rx1175_off
  rx1175_start:
    eq $I10, 1, rx1175_restart
    if_null rx1175_debug, debug_875
    rx1175_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_875:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1179_done
    goto rxscan1179_scan
  rxscan1179_loop:
    (rx1175_pos) = rx1175_cur."from"()
    inc rx1175_pos
    rx1175_cur."!cursor_from"(rx1175_pos)
    ge rx1175_pos, rx1175_eos, rxscan1179_done
  rxscan1179_scan:
    set_addr $I10, rxscan1179_loop
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  rxscan1179_done:
.annotate 'line', 544
  # rx literal  "q"
    add $I11, rx1175_pos, 1
    gt $I11, rx1175_eos, rx1175_fail
    sub $I11, rx1175_pos, rx1175_off
    ord $I11, rx1175_tgt, $I11
    ne $I11, 113, rx1175_fail
    add rx1175_pos, 1
  # rxanchor rwb
    le rx1175_pos, 0, rx1175_fail
    sub $I10, rx1175_pos, rx1175_off
    is_cclass $I11, 8192, rx1175_tgt, $I10
    if $I11, rx1175_fail
    dec $I10
    is_cclass $I11, 8192, rx1175_tgt, $I10
    unless $I11, rx1175_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1175_pos, rx1175_off
    substr $S10, rx1175_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1175_fail
  # rx subrule "ws" subtype=method negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."ws"()
    unless $P10, rx1175_fail
    rx1175_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."quote_EXPR"(":q")
    unless $P10, rx1175_fail
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1175_pos = $P10."pos"()
  # rx pass
    rx1175_cur."!cursor_pass"(rx1175_pos, "quote:sym<q>")
    if_null rx1175_debug, debug_876
    rx1175_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1175_pos)
  debug_876:
    .return (rx1175_cur)
  rx1175_restart:
.annotate 'line', 4
    if_null rx1175_debug, debug_877
    rx1175_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_877:
  rx1175_fail:
    (rx1175_rep, rx1175_pos, $I10, $P10) = rx1175_cur."!mark_fail"(0)
    lt rx1175_pos, -1, rx1175_done
    eq rx1175_pos, -1, rx1175_fail
    jump $I10
  rx1175_done:
    rx1175_cur."!cursor_fail"()
    if_null rx1175_debug, debug_878
    rx1175_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_878:
    .return (rx1175_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("241_1300051172.188") :method
.annotate 'line', 4
    $P1177 = self."!PREFIX__!subrule"("ws", "q")
    new $P1178, "ResizablePMCArray"
    push $P1178, $P1177
    .return ($P1178)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("242_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1181_tgt
    .local int rx1181_pos
    .local int rx1181_off
    .local int rx1181_eos
    .local int rx1181_rep
    .local pmc rx1181_cur
    .local pmc rx1181_debug
    (rx1181_cur, rx1181_pos, rx1181_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1181_cur
    .local pmc match
    .lex "$/", match
    length rx1181_eos, rx1181_tgt
    gt rx1181_pos, rx1181_eos, rx1181_done
    set rx1181_off, 0
    lt rx1181_pos, 2, rx1181_start
    sub rx1181_off, rx1181_pos, 1
    substr rx1181_tgt, rx1181_tgt, rx1181_off
  rx1181_start:
    eq $I10, 1, rx1181_restart
    if_null rx1181_debug, debug_879
    rx1181_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_879:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1185_done
    goto rxscan1185_scan
  rxscan1185_loop:
    (rx1181_pos) = rx1181_cur."from"()
    inc rx1181_pos
    rx1181_cur."!cursor_from"(rx1181_pos)
    ge rx1181_pos, rx1181_eos, rxscan1185_done
  rxscan1185_scan:
    set_addr $I10, rxscan1185_loop
    rx1181_cur."!mark_push"(0, rx1181_pos, $I10)
  rxscan1185_done:
.annotate 'line', 545
  # rx literal  "qq"
    add $I11, rx1181_pos, 2
    gt $I11, rx1181_eos, rx1181_fail
    sub $I11, rx1181_pos, rx1181_off
    substr $S10, rx1181_tgt, $I11, 2
    ne $S10, "qq", rx1181_fail
    add rx1181_pos, 2
  # rxanchor rwb
    le rx1181_pos, 0, rx1181_fail
    sub $I10, rx1181_pos, rx1181_off
    is_cclass $I11, 8192, rx1181_tgt, $I10
    if $I11, rx1181_fail
    dec $I10
    is_cclass $I11, 8192, rx1181_tgt, $I10
    unless $I11, rx1181_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1181_pos, rx1181_off
    substr $S10, rx1181_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1181_fail
  # rx subrule "ws" subtype=method negate=
    rx1181_cur."!cursor_pos"(rx1181_pos)
    $P10 = rx1181_cur."ws"()
    unless $P10, rx1181_fail
    rx1181_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1181_cur."!cursor_pos"(rx1181_pos)
    $P10 = rx1181_cur."quote_EXPR"(":qq")
    unless $P10, rx1181_fail
    rx1181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1181_pos = $P10."pos"()
  # rx pass
    rx1181_cur."!cursor_pass"(rx1181_pos, "quote:sym<qq>")
    if_null rx1181_debug, debug_880
    rx1181_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1181_pos)
  debug_880:
    .return (rx1181_cur)
  rx1181_restart:
.annotate 'line', 4
    if_null rx1181_debug, debug_881
    rx1181_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_881:
  rx1181_fail:
    (rx1181_rep, rx1181_pos, $I10, $P10) = rx1181_cur."!mark_fail"(0)
    lt rx1181_pos, -1, rx1181_done
    eq rx1181_pos, -1, rx1181_fail
    jump $I10
  rx1181_done:
    rx1181_cur."!cursor_fail"()
    if_null rx1181_debug, debug_882
    rx1181_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_882:
    .return (rx1181_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("243_1300051172.188") :method
.annotate 'line', 4
    $P1183 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1184, "ResizablePMCArray"
    push $P1184, $P1183
    .return ($P1184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("244_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1187_tgt
    .local int rx1187_pos
    .local int rx1187_off
    .local int rx1187_eos
    .local int rx1187_rep
    .local pmc rx1187_cur
    .local pmc rx1187_debug
    (rx1187_cur, rx1187_pos, rx1187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1187_cur
    .local pmc match
    .lex "$/", match
    length rx1187_eos, rx1187_tgt
    gt rx1187_pos, rx1187_eos, rx1187_done
    set rx1187_off, 0
    lt rx1187_pos, 2, rx1187_start
    sub rx1187_off, rx1187_pos, 1
    substr rx1187_tgt, rx1187_tgt, rx1187_off
  rx1187_start:
    eq $I10, 1, rx1187_restart
    if_null rx1187_debug, debug_883
    rx1187_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_883:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1191_done
    goto rxscan1191_scan
  rxscan1191_loop:
    (rx1187_pos) = rx1187_cur."from"()
    inc rx1187_pos
    rx1187_cur."!cursor_from"(rx1187_pos)
    ge rx1187_pos, rx1187_eos, rxscan1191_done
  rxscan1191_scan:
    set_addr $I10, rxscan1191_loop
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  rxscan1191_done:
.annotate 'line', 546
  # rx literal  "Q"
    add $I11, rx1187_pos, 1
    gt $I11, rx1187_eos, rx1187_fail
    sub $I11, rx1187_pos, rx1187_off
    ord $I11, rx1187_tgt, $I11
    ne $I11, 81, rx1187_fail
    add rx1187_pos, 1
  # rxanchor rwb
    le rx1187_pos, 0, rx1187_fail
    sub $I10, rx1187_pos, rx1187_off
    is_cclass $I11, 8192, rx1187_tgt, $I10
    if $I11, rx1187_fail
    dec $I10
    is_cclass $I11, 8192, rx1187_tgt, $I10
    unless $I11, rx1187_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1187_pos, rx1187_off
    substr $S10, rx1187_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1187_fail
  # rx subrule "ws" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."ws"()
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."quote_EXPR"()
    unless $P10, rx1187_fail
    rx1187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1187_pos = $P10."pos"()
  # rx pass
    rx1187_cur."!cursor_pass"(rx1187_pos, "quote:sym<Q>")
    if_null rx1187_debug, debug_884
    rx1187_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1187_pos)
  debug_884:
    .return (rx1187_cur)
  rx1187_restart:
.annotate 'line', 4
    if_null rx1187_debug, debug_885
    rx1187_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_885:
  rx1187_fail:
    (rx1187_rep, rx1187_pos, $I10, $P10) = rx1187_cur."!mark_fail"(0)
    lt rx1187_pos, -1, rx1187_done
    eq rx1187_pos, -1, rx1187_fail
    jump $I10
  rx1187_done:
    rx1187_cur."!cursor_fail"()
    if_null rx1187_debug, debug_886
    rx1187_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_886:
    .return (rx1187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("245_1300051172.188") :method
.annotate 'line', 4
    $P1189 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1190, "ResizablePMCArray"
    push $P1190, $P1189
    .return ($P1190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("246_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1193_tgt
    .local int rx1193_pos
    .local int rx1193_off
    .local int rx1193_eos
    .local int rx1193_rep
    .local pmc rx1193_cur
    .local pmc rx1193_debug
    (rx1193_cur, rx1193_pos, rx1193_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1193_cur
    .local pmc match
    .lex "$/", match
    length rx1193_eos, rx1193_tgt
    gt rx1193_pos, rx1193_eos, rx1193_done
    set rx1193_off, 0
    lt rx1193_pos, 2, rx1193_start
    sub rx1193_off, rx1193_pos, 1
    substr rx1193_tgt, rx1193_tgt, rx1193_off
  rx1193_start:
    eq $I10, 1, rx1193_restart
    if_null rx1193_debug, debug_887
    rx1193_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_887:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1197_done
    goto rxscan1197_scan
  rxscan1197_loop:
    (rx1193_pos) = rx1193_cur."from"()
    inc rx1193_pos
    rx1193_cur."!cursor_from"(rx1193_pos)
    ge rx1193_pos, rx1193_eos, rxscan1197_done
  rxscan1197_scan:
    set_addr $I10, rxscan1197_loop
    rx1193_cur."!mark_push"(0, rx1193_pos, $I10)
  rxscan1197_done:
.annotate 'line', 547
  # rx literal  "Q:PIR"
    add $I11, rx1193_pos, 5
    gt $I11, rx1193_eos, rx1193_fail
    sub $I11, rx1193_pos, rx1193_off
    substr $S10, rx1193_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1193_fail
    add rx1193_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1193_cur."!cursor_pos"(rx1193_pos)
    $P10 = rx1193_cur."ws"()
    unless $P10, rx1193_fail
    rx1193_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1193_cur."!cursor_pos"(rx1193_pos)
    $P10 = rx1193_cur."quote_EXPR"()
    unless $P10, rx1193_fail
    rx1193_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1193_pos = $P10."pos"()
  # rx pass
    rx1193_cur."!cursor_pass"(rx1193_pos, "quote:sym<Q:PIR>")
    if_null rx1193_debug, debug_888
    rx1193_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1193_pos)
  debug_888:
    .return (rx1193_cur)
  rx1193_restart:
.annotate 'line', 4
    if_null rx1193_debug, debug_889
    rx1193_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_889:
  rx1193_fail:
    (rx1193_rep, rx1193_pos, $I10, $P10) = rx1193_cur."!mark_fail"(0)
    lt rx1193_pos, -1, rx1193_done
    eq rx1193_pos, -1, rx1193_fail
    jump $I10
  rx1193_done:
    rx1193_cur."!cursor_fail"()
    if_null rx1193_debug, debug_890
    rx1193_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_890:
    .return (rx1193_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("247_1300051172.188") :method
.annotate 'line', 4
    $P1195 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1196, "ResizablePMCArray"
    push $P1196, $P1195
    .return ($P1196)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("248_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1199_tgt
    .local int rx1199_pos
    .local int rx1199_off
    .local int rx1199_eos
    .local int rx1199_rep
    .local pmc rx1199_cur
    .local pmc rx1199_debug
    (rx1199_cur, rx1199_pos, rx1199_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1199_cur
    .local pmc match
    .lex "$/", match
    length rx1199_eos, rx1199_tgt
    gt rx1199_pos, rx1199_eos, rx1199_done
    set rx1199_off, 0
    lt rx1199_pos, 2, rx1199_start
    sub rx1199_off, rx1199_pos, 1
    substr rx1199_tgt, rx1199_tgt, rx1199_off
  rx1199_start:
    eq $I10, 1, rx1199_restart
    if_null rx1199_debug, debug_891
    rx1199_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_891:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1203_done
    goto rxscan1203_scan
  rxscan1203_loop:
    (rx1199_pos) = rx1199_cur."from"()
    inc rx1199_pos
    rx1199_cur."!cursor_from"(rx1199_pos)
    ge rx1199_pos, rx1199_eos, rxscan1203_done
  rxscan1203_scan:
    set_addr $I10, rxscan1203_loop
    rx1199_cur."!mark_push"(0, rx1199_pos, $I10)
  rxscan1203_done:
.annotate 'line', 549
  # rx literal  "/"
    add $I11, rx1199_pos, 1
    gt $I11, rx1199_eos, rx1199_fail
    sub $I11, rx1199_pos, rx1199_off
    ord $I11, rx1199_tgt, $I11
    ne $I11, 47, rx1199_fail
    add rx1199_pos, 1
.annotate 'line', 550
  # rx subrule "newpad" subtype=method negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."newpad"()
    unless $P10, rx1199_fail
    rx1199_pos = $P10."pos"()
.annotate 'line', 551
  # rx reduce name="quote:sym</ />" key="open"
    rx1199_cur."!cursor_pos"(rx1199_pos)
    rx1199_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 552
  # rx subrule "LANG" subtype=capture negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1199_fail
    rx1199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1199_pos = $P10."pos"()
.annotate 'line', 553
  # rx literal  "/"
    add $I11, rx1199_pos, 1
    gt $I11, rx1199_eos, rx1199_fail
    sub $I11, rx1199_pos, rx1199_off
    ord $I11, rx1199_tgt, $I11
    ne $I11, 47, rx1199_fail
    add rx1199_pos, 1
.annotate 'line', 548
  # rx pass
    rx1199_cur."!cursor_pass"(rx1199_pos, "quote:sym</ />")
    if_null rx1199_debug, debug_892
    rx1199_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1199_pos)
  debug_892:
    .return (rx1199_cur)
  rx1199_restart:
.annotate 'line', 4
    if_null rx1199_debug, debug_893
    rx1199_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_893:
  rx1199_fail:
    (rx1199_rep, rx1199_pos, $I10, $P10) = rx1199_cur."!mark_fail"(0)
    lt rx1199_pos, -1, rx1199_done
    eq rx1199_pos, -1, rx1199_fail
    jump $I10
  rx1199_done:
    rx1199_cur."!cursor_fail"()
    if_null rx1199_debug, debug_894
    rx1199_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_894:
    .return (rx1199_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("249_1300051172.188") :method
.annotate 'line', 4
    $P1201 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1202, "ResizablePMCArray"
    push $P1202, $P1201
    .return ($P1202)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("250_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1205_tgt
    .local int rx1205_pos
    .local int rx1205_off
    .local int rx1205_eos
    .local int rx1205_rep
    .local pmc rx1205_cur
    .local pmc rx1205_debug
    (rx1205_cur, rx1205_pos, rx1205_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1205_cur
    .local pmc match
    .lex "$/", match
    length rx1205_eos, rx1205_tgt
    gt rx1205_pos, rx1205_eos, rx1205_done
    set rx1205_off, 0
    lt rx1205_pos, 2, rx1205_start
    sub rx1205_off, rx1205_pos, 1
    substr rx1205_tgt, rx1205_tgt, rx1205_off
  rx1205_start:
    eq $I10, 1, rx1205_restart
    if_null rx1205_debug, debug_895
    rx1205_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1208_done
    goto rxscan1208_scan
  rxscan1208_loop:
    (rx1205_pos) = rx1205_cur."from"()
    inc rx1205_pos
    rx1205_cur."!cursor_from"(rx1205_pos)
    ge rx1205_pos, rx1205_eos, rxscan1208_done
  rxscan1208_scan:
    set_addr $I10, rxscan1208_loop
    rx1205_cur."!mark_push"(0, rx1205_pos, $I10)
  rxscan1208_done:
.annotate 'line', 556
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1205_pos, rx1205_off
    substr $S10, rx1205_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1205_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1205_cur."!cursor_pos"(rx1205_pos)
    $P10 = rx1205_cur."quotemod_check"("s")
    unless $P10, rx1205_fail
  # rx subrule "variable" subtype=capture negate=
    rx1205_cur."!cursor_pos"(rx1205_pos)
    $P10 = rx1205_cur."variable"()
    unless $P10, rx1205_fail
    rx1205_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1205_pos = $P10."pos"()
  # rx pass
    rx1205_cur."!cursor_pass"(rx1205_pos, "quote_escape:sym<$>")
    if_null rx1205_debug, debug_896
    rx1205_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1205_pos)
  debug_896:
    .return (rx1205_cur)
  rx1205_restart:
.annotate 'line', 4
    if_null rx1205_debug, debug_897
    rx1205_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_897:
  rx1205_fail:
    (rx1205_rep, rx1205_pos, $I10, $P10) = rx1205_cur."!mark_fail"(0)
    lt rx1205_pos, -1, rx1205_done
    eq rx1205_pos, -1, rx1205_fail
    jump $I10
  rx1205_done:
    rx1205_cur."!cursor_fail"()
    if_null rx1205_debug, debug_898
    rx1205_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_898:
    .return (rx1205_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("251_1300051172.188") :method
.annotate 'line', 4
    new $P1207, "ResizablePMCArray"
    push $P1207, "$"
    .return ($P1207)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("252_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1210_tgt
    .local int rx1210_pos
    .local int rx1210_off
    .local int rx1210_eos
    .local int rx1210_rep
    .local pmc rx1210_cur
    .local pmc rx1210_debug
    (rx1210_cur, rx1210_pos, rx1210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1210_cur
    .local pmc match
    .lex "$/", match
    length rx1210_eos, rx1210_tgt
    gt rx1210_pos, rx1210_eos, rx1210_done
    set rx1210_off, 0
    lt rx1210_pos, 2, rx1210_start
    sub rx1210_off, rx1210_pos, 1
    substr rx1210_tgt, rx1210_tgt, rx1210_off
  rx1210_start:
    eq $I10, 1, rx1210_restart
    if_null rx1210_debug, debug_899
    rx1210_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1213_done
    goto rxscan1213_scan
  rxscan1213_loop:
    (rx1210_pos) = rx1210_cur."from"()
    inc rx1210_pos
    rx1210_cur."!cursor_from"(rx1210_pos)
    ge rx1210_pos, rx1210_eos, rxscan1213_done
  rxscan1213_scan:
    set_addr $I10, rxscan1213_loop
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  rxscan1213_done:
.annotate 'line', 557
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1210_pos, rx1210_off
    substr $S10, rx1210_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1210_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."quotemod_check"("c")
    unless $P10, rx1210_fail
  # rx subrule "block" subtype=capture negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."block"()
    unless $P10, rx1210_fail
    rx1210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1210_pos = $P10."pos"()
  # rx pass
    rx1210_cur."!cursor_pass"(rx1210_pos, "quote_escape:sym<{ }>")
    if_null rx1210_debug, debug_900
    rx1210_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1210_pos)
  debug_900:
    .return (rx1210_cur)
  rx1210_restart:
.annotate 'line', 4
    if_null rx1210_debug, debug_901
    rx1210_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_901:
  rx1210_fail:
    (rx1210_rep, rx1210_pos, $I10, $P10) = rx1210_cur."!mark_fail"(0)
    lt rx1210_pos, -1, rx1210_done
    eq rx1210_pos, -1, rx1210_fail
    jump $I10
  rx1210_done:
    rx1210_cur."!cursor_fail"()
    if_null rx1210_debug, debug_902
    rx1210_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_902:
    .return (rx1210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("253_1300051172.188") :method
.annotate 'line', 4
    new $P1212, "ResizablePMCArray"
    push $P1212, "{"
    .return ($P1212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("254_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1215_tgt
    .local int rx1215_pos
    .local int rx1215_off
    .local int rx1215_eos
    .local int rx1215_rep
    .local pmc rx1215_cur
    .local pmc rx1215_debug
    (rx1215_cur, rx1215_pos, rx1215_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1215_cur
    .local pmc match
    .lex "$/", match
    length rx1215_eos, rx1215_tgt
    gt rx1215_pos, rx1215_eos, rx1215_done
    set rx1215_off, 0
    lt rx1215_pos, 2, rx1215_start
    sub rx1215_off, rx1215_pos, 1
    substr rx1215_tgt, rx1215_tgt, rx1215_off
  rx1215_start:
    eq $I10, 1, rx1215_restart
    if_null rx1215_debug, debug_903
    rx1215_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1218_done
    goto rxscan1218_scan
  rxscan1218_loop:
    (rx1215_pos) = rx1215_cur."from"()
    inc rx1215_pos
    rx1215_cur."!cursor_from"(rx1215_pos)
    ge rx1215_pos, rx1215_eos, rxscan1218_done
  rxscan1218_scan:
    set_addr $I10, rxscan1218_loop
    rx1215_cur."!mark_push"(0, rx1215_pos, $I10)
  rxscan1218_done:
.annotate 'line', 558
  # rx literal  "\\e"
    add $I11, rx1215_pos, 2
    gt $I11, rx1215_eos, rx1215_fail
    sub $I11, rx1215_pos, rx1215_off
    substr $S10, rx1215_tgt, $I11, 2
    ne $S10, "\\e", rx1215_fail
    add rx1215_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."quotemod_check"("b")
    unless $P10, rx1215_fail
  # rx pass
    rx1215_cur."!cursor_pass"(rx1215_pos, "quote_escape:sym<esc>")
    if_null rx1215_debug, debug_904
    rx1215_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1215_pos)
  debug_904:
    .return (rx1215_cur)
  rx1215_restart:
.annotate 'line', 4
    if_null rx1215_debug, debug_905
    rx1215_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_905:
  rx1215_fail:
    (rx1215_rep, rx1215_pos, $I10, $P10) = rx1215_cur."!mark_fail"(0)
    lt rx1215_pos, -1, rx1215_done
    eq rx1215_pos, -1, rx1215_fail
    jump $I10
  rx1215_done:
    rx1215_cur."!cursor_fail"()
    if_null rx1215_debug, debug_906
    rx1215_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_906:
    .return (rx1215_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("255_1300051172.188") :method
.annotate 'line', 4
    new $P1217, "ResizablePMCArray"
    push $P1217, "\\e"
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("256_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1220_tgt
    .local int rx1220_pos
    .local int rx1220_off
    .local int rx1220_eos
    .local int rx1220_rep
    .local pmc rx1220_cur
    .local pmc rx1220_debug
    (rx1220_cur, rx1220_pos, rx1220_tgt, $I10) = self."!cursor_start"()
    rx1220_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1220_cur
    .local pmc match
    .lex "$/", match
    length rx1220_eos, rx1220_tgt
    gt rx1220_pos, rx1220_eos, rx1220_done
    set rx1220_off, 0
    lt rx1220_pos, 2, rx1220_start
    sub rx1220_off, rx1220_pos, 1
    substr rx1220_tgt, rx1220_tgt, rx1220_off
  rx1220_start:
    eq $I10, 1, rx1220_restart
    if_null rx1220_debug, debug_907
    rx1220_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_907:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1220_pos) = rx1220_cur."from"()
    inc rx1220_pos
    rx1220_cur."!cursor_from"(rx1220_pos)
    ge rx1220_pos, rx1220_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxscan1224_done:
.annotate 'line', 560
  # rx literal  "("
    add $I11, rx1220_pos, 1
    gt $I11, rx1220_eos, rx1220_fail
    sub $I11, rx1220_pos, rx1220_off
    ord $I11, rx1220_tgt, $I11
    ne $I11, 40, rx1220_fail
    add rx1220_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."ws"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
  # rx rxquantr1225 ** 0..1
    set_addr $I10, rxquantr1225_done
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxquantr1225_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."EXPR"()
    unless $P10, rx1220_fail
    goto rxsubrule1226_pass
  rxsubrule1226_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1220_fail
  rxsubrule1226_pass:
    set_addr $I10, rxsubrule1226_back
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1220_pos = $P10."pos"()
    set_addr $I10, rxquantr1225_done
    (rx1220_rep) = rx1220_cur."!mark_commit"($I10)
  rxquantr1225_done:
  # rx literal  ")"
    add $I11, rx1220_pos, 1
    gt $I11, rx1220_eos, rx1220_fail
    sub $I11, rx1220_pos, rx1220_off
    ord $I11, rx1220_tgt, $I11
    ne $I11, 41, rx1220_fail
    add rx1220_pos, 1
  # rx pass
    rx1220_cur."!cursor_pass"(rx1220_pos, "circumfix:sym<( )>")
    if_null rx1220_debug, debug_908
    rx1220_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1220_pos)
  debug_908:
    .return (rx1220_cur)
  rx1220_restart:
.annotate 'line', 4
    if_null rx1220_debug, debug_909
    rx1220_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_909:
  rx1220_fail:
    (rx1220_rep, rx1220_pos, $I10, $P10) = rx1220_cur."!mark_fail"(0)
    lt rx1220_pos, -1, rx1220_done
    eq rx1220_pos, -1, rx1220_fail
    jump $I10
  rx1220_done:
    rx1220_cur."!cursor_fail"()
    if_null rx1220_debug, debug_910
    rx1220_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_910:
    .return (rx1220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("257_1300051172.188") :method
.annotate 'line', 4
    $P1222 = self."!PREFIX__!subrule"("ws", "(")
    new $P1223, "ResizablePMCArray"
    push $P1223, $P1222
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("258_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1228_tgt
    .local int rx1228_pos
    .local int rx1228_off
    .local int rx1228_eos
    .local int rx1228_rep
    .local pmc rx1228_cur
    .local pmc rx1228_debug
    (rx1228_cur, rx1228_pos, rx1228_tgt, $I10) = self."!cursor_start"()
    rx1228_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1228_cur
    .local pmc match
    .lex "$/", match
    length rx1228_eos, rx1228_tgt
    gt rx1228_pos, rx1228_eos, rx1228_done
    set rx1228_off, 0
    lt rx1228_pos, 2, rx1228_start
    sub rx1228_off, rx1228_pos, 1
    substr rx1228_tgt, rx1228_tgt, rx1228_off
  rx1228_start:
    eq $I10, 1, rx1228_restart
    if_null rx1228_debug, debug_911
    rx1228_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1232_done
    goto rxscan1232_scan
  rxscan1232_loop:
    (rx1228_pos) = rx1228_cur."from"()
    inc rx1228_pos
    rx1228_cur."!cursor_from"(rx1228_pos)
    ge rx1228_pos, rx1228_eos, rxscan1232_done
  rxscan1232_scan:
    set_addr $I10, rxscan1232_loop
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
  rxscan1232_done:
.annotate 'line', 561
  # rx literal  "["
    add $I11, rx1228_pos, 1
    gt $I11, rx1228_eos, rx1228_fail
    sub $I11, rx1228_pos, rx1228_off
    ord $I11, rx1228_tgt, $I11
    ne $I11, 91, rx1228_fail
    add rx1228_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."ws"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
  # rx rxquantr1233 ** 0..1
    set_addr $I10, rxquantr1233_done
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
  rxquantr1233_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."EXPR"()
    unless $P10, rx1228_fail
    goto rxsubrule1234_pass
  rxsubrule1234_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1228_fail
  rxsubrule1234_pass:
    set_addr $I10, rxsubrule1234_back
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1228_pos = $P10."pos"()
    set_addr $I10, rxquantr1233_done
    (rx1228_rep) = rx1228_cur."!mark_commit"($I10)
  rxquantr1233_done:
  # rx literal  "]"
    add $I11, rx1228_pos, 1
    gt $I11, rx1228_eos, rx1228_fail
    sub $I11, rx1228_pos, rx1228_off
    ord $I11, rx1228_tgt, $I11
    ne $I11, 93, rx1228_fail
    add rx1228_pos, 1
  # rx pass
    rx1228_cur."!cursor_pass"(rx1228_pos, "circumfix:sym<[ ]>")
    if_null rx1228_debug, debug_912
    rx1228_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1228_pos)
  debug_912:
    .return (rx1228_cur)
  rx1228_restart:
.annotate 'line', 4
    if_null rx1228_debug, debug_913
    rx1228_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_913:
  rx1228_fail:
    (rx1228_rep, rx1228_pos, $I10, $P10) = rx1228_cur."!mark_fail"(0)
    lt rx1228_pos, -1, rx1228_done
    eq rx1228_pos, -1, rx1228_fail
    jump $I10
  rx1228_done:
    rx1228_cur."!cursor_fail"()
    if_null rx1228_debug, debug_914
    rx1228_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_914:
    .return (rx1228_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("259_1300051172.188") :method
.annotate 'line', 4
    $P1230 = self."!PREFIX__!subrule"("ws", "[")
    new $P1231, "ResizablePMCArray"
    push $P1231, $P1230
    .return ($P1231)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("260_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1236_tgt
    .local int rx1236_pos
    .local int rx1236_off
    .local int rx1236_eos
    .local int rx1236_rep
    .local pmc rx1236_cur
    .local pmc rx1236_debug
    (rx1236_cur, rx1236_pos, rx1236_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1236_cur
    .local pmc match
    .lex "$/", match
    length rx1236_eos, rx1236_tgt
    gt rx1236_pos, rx1236_eos, rx1236_done
    set rx1236_off, 0
    lt rx1236_pos, 2, rx1236_start
    sub rx1236_off, rx1236_pos, 1
    substr rx1236_tgt, rx1236_tgt, rx1236_off
  rx1236_start:
    eq $I10, 1, rx1236_restart
    if_null rx1236_debug, debug_915
    rx1236_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_915:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1239_done
    goto rxscan1239_scan
  rxscan1239_loop:
    (rx1236_pos) = rx1236_cur."from"()
    inc rx1236_pos
    rx1236_cur."!cursor_from"(rx1236_pos)
    ge rx1236_pos, rx1236_eos, rxscan1239_done
  rxscan1239_scan:
    set_addr $I10, rxscan1239_loop
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxscan1239_done:
.annotate 'line', 562
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1236_pos, rx1236_off
    substr $S10, rx1236_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1236_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1236_fail
    rx1236_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1236_pos = $P10."pos"()
  # rx pass
    rx1236_cur."!cursor_pass"(rx1236_pos, "circumfix:sym<ang>")
    if_null rx1236_debug, debug_916
    rx1236_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1236_pos)
  debug_916:
    .return (rx1236_cur)
  rx1236_restart:
.annotate 'line', 4
    if_null rx1236_debug, debug_917
    rx1236_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_917:
  rx1236_fail:
    (rx1236_rep, rx1236_pos, $I10, $P10) = rx1236_cur."!mark_fail"(0)
    lt rx1236_pos, -1, rx1236_done
    eq rx1236_pos, -1, rx1236_fail
    jump $I10
  rx1236_done:
    rx1236_cur."!cursor_fail"()
    if_null rx1236_debug, debug_918
    rx1236_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_918:
    .return (rx1236_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("261_1300051172.188") :method
.annotate 'line', 4
    new $P1238, "ResizablePMCArray"
    push $P1238, "<"
    .return ($P1238)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("262_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1241_tgt
    .local int rx1241_pos
    .local int rx1241_off
    .local int rx1241_eos
    .local int rx1241_rep
    .local pmc rx1241_cur
    .local pmc rx1241_debug
    (rx1241_cur, rx1241_pos, rx1241_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1241_cur
    .local pmc match
    .lex "$/", match
    length rx1241_eos, rx1241_tgt
    gt rx1241_pos, rx1241_eos, rx1241_done
    set rx1241_off, 0
    lt rx1241_pos, 2, rx1241_start
    sub rx1241_off, rx1241_pos, 1
    substr rx1241_tgt, rx1241_tgt, rx1241_off
  rx1241_start:
    eq $I10, 1, rx1241_restart
    if_null rx1241_debug, debug_919
    rx1241_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1244_done
    goto rxscan1244_scan
  rxscan1244_loop:
    (rx1241_pos) = rx1241_cur."from"()
    inc rx1241_pos
    rx1241_cur."!cursor_from"(rx1241_pos)
    ge rx1241_pos, rx1241_eos, rxscan1244_done
  rxscan1244_scan:
    set_addr $I10, rxscan1244_loop
    rx1241_cur."!mark_push"(0, rx1241_pos, $I10)
  rxscan1244_done:
.annotate 'line', 563
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1241_pos, rx1241_off
    substr $S10, rx1241_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1241_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1241_cur."!cursor_pos"(rx1241_pos)
    $P10 = rx1241_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1241_fail
    rx1241_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1241_pos = $P10."pos"()
  # rx pass
    rx1241_cur."!cursor_pass"(rx1241_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1241_debug, debug_920
    rx1241_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1241_pos)
  debug_920:
    .return (rx1241_cur)
  rx1241_restart:
.annotate 'line', 4
    if_null rx1241_debug, debug_921
    rx1241_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_921:
  rx1241_fail:
    (rx1241_rep, rx1241_pos, $I10, $P10) = rx1241_cur."!mark_fail"(0)
    lt rx1241_pos, -1, rx1241_done
    eq rx1241_pos, -1, rx1241_fail
    jump $I10
  rx1241_done:
    rx1241_cur."!cursor_fail"()
    if_null rx1241_debug, debug_922
    rx1241_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_922:
    .return (rx1241_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("263_1300051172.188") :method
.annotate 'line', 4
    new $P1243, "ResizablePMCArray"
    push $P1243, unicode:"\x{ab}"
    .return ($P1243)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("264_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1246_tgt
    .local int rx1246_pos
    .local int rx1246_off
    .local int rx1246_eos
    .local int rx1246_rep
    .local pmc rx1246_cur
    .local pmc rx1246_debug
    (rx1246_cur, rx1246_pos, rx1246_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1246_cur
    .local pmc match
    .lex "$/", match
    length rx1246_eos, rx1246_tgt
    gt rx1246_pos, rx1246_eos, rx1246_done
    set rx1246_off, 0
    lt rx1246_pos, 2, rx1246_start
    sub rx1246_off, rx1246_pos, 1
    substr rx1246_tgt, rx1246_tgt, rx1246_off
  rx1246_start:
    eq $I10, 1, rx1246_restart
    if_null rx1246_debug, debug_923
    rx1246_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_923:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1249_done
    goto rxscan1249_scan
  rxscan1249_loop:
    (rx1246_pos) = rx1246_cur."from"()
    inc rx1246_pos
    rx1246_cur."!cursor_from"(rx1246_pos)
    ge rx1246_pos, rx1246_eos, rxscan1249_done
  rxscan1249_scan:
    set_addr $I10, rxscan1249_loop
    rx1246_cur."!mark_push"(0, rx1246_pos, $I10)
  rxscan1249_done:
.annotate 'line', 564
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1246_pos, rx1246_off
    substr $S10, rx1246_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1246_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1246_cur."!cursor_pos"(rx1246_pos)
    $P10 = rx1246_cur."pblock"()
    unless $P10, rx1246_fail
    rx1246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1246_pos = $P10."pos"()
  # rx pass
    rx1246_cur."!cursor_pass"(rx1246_pos, "circumfix:sym<{ }>")
    if_null rx1246_debug, debug_924
    rx1246_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1246_pos)
  debug_924:
    .return (rx1246_cur)
  rx1246_restart:
.annotate 'line', 4
    if_null rx1246_debug, debug_925
    rx1246_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_925:
  rx1246_fail:
    (rx1246_rep, rx1246_pos, $I10, $P10) = rx1246_cur."!mark_fail"(0)
    lt rx1246_pos, -1, rx1246_done
    eq rx1246_pos, -1, rx1246_fail
    jump $I10
  rx1246_done:
    rx1246_cur."!cursor_fail"()
    if_null rx1246_debug, debug_926
    rx1246_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_926:
    .return (rx1246_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("265_1300051172.188") :method
.annotate 'line', 4
    new $P1248, "ResizablePMCArray"
    push $P1248, "{"
    .return ($P1248)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("266_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1251_tgt
    .local int rx1251_pos
    .local int rx1251_off
    .local int rx1251_eos
    .local int rx1251_rep
    .local pmc rx1251_cur
    .local pmc rx1251_debug
    (rx1251_cur, rx1251_pos, rx1251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1251_cur
    .local pmc match
    .lex "$/", match
    length rx1251_eos, rx1251_tgt
    gt rx1251_pos, rx1251_eos, rx1251_done
    set rx1251_off, 0
    lt rx1251_pos, 2, rx1251_start
    sub rx1251_off, rx1251_pos, 1
    substr rx1251_tgt, rx1251_tgt, rx1251_off
  rx1251_start:
    eq $I10, 1, rx1251_restart
    if_null rx1251_debug, debug_927
    rx1251_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_927:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1251_pos) = rx1251_cur."from"()
    inc rx1251_pos
    rx1251_cur."!cursor_from"(rx1251_pos)
    ge rx1251_pos, rx1251_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  rxscan1255_done:
.annotate 'line', 565
  # rx subrule "sigil" subtype=capture negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."sigil"()
    unless $P10, rx1251_fail
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1251_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1251_pos, 1
    gt $I11, rx1251_eos, rx1251_fail
    sub $I11, rx1251_pos, rx1251_off
    ord $I11, rx1251_tgt, $I11
    ne $I11, 40, rx1251_fail
    add rx1251_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."semilist"()
    unless $P10, rx1251_fail
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1251_pos = $P10."pos"()
  alt1256_0:
    set_addr $I10, alt1256_1
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  # rx literal  ")"
    add $I11, rx1251_pos, 1
    gt $I11, rx1251_eos, rx1251_fail
    sub $I11, rx1251_pos, rx1251_off
    ord $I11, rx1251_tgt, $I11
    ne $I11, 41, rx1251_fail
    add rx1251_pos, 1
    goto alt1256_end
  alt1256_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."FAILGOAL"("')'")
    unless $P10, rx1251_fail
    goto rxsubrule1258_pass
  rxsubrule1258_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1251_fail
  rxsubrule1258_pass:
    set_addr $I10, rxsubrule1258_back
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10, $P10)
    rx1251_pos = $P10."pos"()
  alt1256_end:
  # rx pass
    rx1251_cur."!cursor_pass"(rx1251_pos, "circumfix:sym<sigil>")
    if_null rx1251_debug, debug_928
    rx1251_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1251_pos)
  debug_928:
    .return (rx1251_cur)
  rx1251_restart:
.annotate 'line', 4
    if_null rx1251_debug, debug_929
    rx1251_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_929:
  rx1251_fail:
    (rx1251_rep, rx1251_pos, $I10, $P10) = rx1251_cur."!mark_fail"(0)
    lt rx1251_pos, -1, rx1251_done
    eq rx1251_pos, -1, rx1251_fail
    jump $I10
  rx1251_done:
    rx1251_cur."!cursor_fail"()
    if_null rx1251_debug, debug_930
    rx1251_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_930:
    .return (rx1251_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("267_1300051172.188") :method
.annotate 'line', 4
    $P1253 = self."!PREFIX__!subrule"("sigil", "")
    new $P1254, "ResizablePMCArray"
    push $P1254, $P1253
    .return ($P1254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("268_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1260_tgt
    .local int rx1260_pos
    .local int rx1260_off
    .local int rx1260_eos
    .local int rx1260_rep
    .local pmc rx1260_cur
    .local pmc rx1260_debug
    (rx1260_cur, rx1260_pos, rx1260_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1260_cur
    .local pmc match
    .lex "$/", match
    length rx1260_eos, rx1260_tgt
    gt rx1260_pos, rx1260_eos, rx1260_done
    set rx1260_off, 0
    lt rx1260_pos, 2, rx1260_start
    sub rx1260_off, rx1260_pos, 1
    substr rx1260_tgt, rx1260_tgt, rx1260_off
  rx1260_start:
    eq $I10, 1, rx1260_restart
    if_null rx1260_debug, debug_931
    rx1260_cur."!cursor_debug"("START", "semilist")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1264_done
    goto rxscan1264_scan
  rxscan1264_loop:
    (rx1260_pos) = rx1260_cur."from"()
    inc rx1260_pos
    rx1260_cur."!cursor_from"(rx1260_pos)
    ge rx1260_pos, rx1260_eos, rxscan1264_done
  rxscan1264_scan:
    set_addr $I10, rxscan1264_loop
    rx1260_cur."!mark_push"(0, rx1260_pos, $I10)
  rxscan1264_done:
.annotate 'line', 567
  # rx subrule "ws" subtype=method negate=
    rx1260_cur."!cursor_pos"(rx1260_pos)
    $P10 = rx1260_cur."ws"()
    unless $P10, rx1260_fail
    rx1260_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1260_cur."!cursor_pos"(rx1260_pos)
    $P10 = rx1260_cur."statement"()
    unless $P10, rx1260_fail
    rx1260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1260_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1260_cur."!cursor_pos"(rx1260_pos)
    $P10 = rx1260_cur."ws"()
    unless $P10, rx1260_fail
    rx1260_pos = $P10."pos"()
  # rx pass
    rx1260_cur."!cursor_pass"(rx1260_pos, "semilist")
    if_null rx1260_debug, debug_932
    rx1260_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1260_pos)
  debug_932:
    .return (rx1260_cur)
  rx1260_restart:
.annotate 'line', 4
    if_null rx1260_debug, debug_933
    rx1260_cur."!cursor_debug"("NEXT", "semilist")
  debug_933:
  rx1260_fail:
    (rx1260_rep, rx1260_pos, $I10, $P10) = rx1260_cur."!mark_fail"(0)
    lt rx1260_pos, -1, rx1260_done
    eq rx1260_pos, -1, rx1260_fail
    jump $I10
  rx1260_done:
    rx1260_cur."!cursor_fail"()
    if_null rx1260_debug, debug_934
    rx1260_cur."!cursor_debug"("FAIL", "semilist")
  debug_934:
    .return (rx1260_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("269_1300051172.188") :method
.annotate 'line', 4
    $P1262 = self."!PREFIX__!subrule"("ws", "")
    new $P1263, "ResizablePMCArray"
    push $P1263, $P1262
    .return ($P1263)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1267"  :anon :subid("270_1300051172.188") :outer("11_1300051172.188")
.annotate 'line', 4
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post935") :outer("270_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P1268 = "270_1300051172.188" 
    .local pmc block
    set block, $P1268
.annotate 'line', 572
    get_hll_global $P1269, ["NQP"], "Grammar"
    $P1269."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 573
    get_hll_global $P1270, ["NQP"], "Grammar"
    $P1270."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 574
    get_hll_global $P1271, ["NQP"], "Grammar"
    $P1271."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 575
    get_hll_global $P1272, ["NQP"], "Grammar"
    $P1272."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 576
    get_hll_global $P1273, ["NQP"], "Grammar"
    $P1273."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 577
    get_hll_global $P1274, ["NQP"], "Grammar"
    $P1274."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 578
    get_hll_global $P1275, ["NQP"], "Grammar"
    $P1275."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 579
    get_hll_global $P1276, ["NQP"], "Grammar"
    $P1276."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 580
    get_hll_global $P1277, ["NQP"], "Grammar"
    $P1277."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 581
    get_hll_global $P1278, ["NQP"], "Grammar"
    $P1278."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 582
    get_hll_global $P1279, ["NQP"], "Grammar"
    $P1279."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 583
    get_hll_global $P1280, ["NQP"], "Grammar"
    $P1280."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 584
    get_hll_global $P1281, ["NQP"], "Grammar"
    $P1281."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 585
    get_hll_global $P1282, ["NQP"], "Grammar"
    $P1282."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 586
    get_hll_global $P1283, ["NQP"], "Grammar"
    $P1283."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("271_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1285_tgt
    .local int rx1285_pos
    .local int rx1285_off
    .local int rx1285_eos
    .local int rx1285_rep
    .local pmc rx1285_cur
    .local pmc rx1285_debug
    (rx1285_cur, rx1285_pos, rx1285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1285_cur
    .local pmc match
    .lex "$/", match
    length rx1285_eos, rx1285_tgt
    gt rx1285_pos, rx1285_eos, rx1285_done
    set rx1285_off, 0
    lt rx1285_pos, 2, rx1285_start
    sub rx1285_off, rx1285_pos, 1
    substr rx1285_tgt, rx1285_tgt, rx1285_off
  rx1285_start:
    eq $I10, 1, rx1285_restart
    if_null rx1285_debug, debug_936
    rx1285_cur."!cursor_debug"("START", "infixish")
  debug_936:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1288_done
    goto rxscan1288_scan
  rxscan1288_loop:
    (rx1285_pos) = rx1285_cur."from"()
    inc rx1285_pos
    rx1285_cur."!cursor_from"(rx1285_pos)
    ge rx1285_pos, rx1285_eos, rxscan1288_done
  rxscan1288_scan:
    set_addr $I10, rxscan1288_loop
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  rxscan1288_done:
.annotate 'line', 590
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."infixstopper"()
    if $P10, rx1285_fail
  # rx subrule "infix" subtype=capture negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."infix"()
    unless $P10, rx1285_fail
    rx1285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1285_pos = $P10."pos"()
  # rx pass
    rx1285_cur."!cursor_pass"(rx1285_pos, "infixish")
    if_null rx1285_debug, debug_937
    rx1285_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1285_pos)
  debug_937:
    .return (rx1285_cur)
  rx1285_restart:
.annotate 'line', 4
    if_null rx1285_debug, debug_938
    rx1285_cur."!cursor_debug"("NEXT", "infixish")
  debug_938:
  rx1285_fail:
    (rx1285_rep, rx1285_pos, $I10, $P10) = rx1285_cur."!mark_fail"(0)
    lt rx1285_pos, -1, rx1285_done
    eq rx1285_pos, -1, rx1285_fail
    jump $I10
  rx1285_done:
    rx1285_cur."!cursor_fail"()
    if_null rx1285_debug, debug_939
    rx1285_cur."!cursor_debug"("FAIL", "infixish")
  debug_939:
    .return (rx1285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("272_1300051172.188") :method
.annotate 'line', 4
    new $P1287, "ResizablePMCArray"
    push $P1287, ""
    .return ($P1287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("273_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1290_tgt
    .local int rx1290_pos
    .local int rx1290_off
    .local int rx1290_eos
    .local int rx1290_rep
    .local pmc rx1290_cur
    .local pmc rx1290_debug
    (rx1290_cur, rx1290_pos, rx1290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1290_cur
    .local pmc match
    .lex "$/", match
    length rx1290_eos, rx1290_tgt
    gt rx1290_pos, rx1290_eos, rx1290_done
    set rx1290_off, 0
    lt rx1290_pos, 2, rx1290_start
    sub rx1290_off, rx1290_pos, 1
    substr rx1290_tgt, rx1290_tgt, rx1290_off
  rx1290_start:
    eq $I10, 1, rx1290_restart
    if_null rx1290_debug, debug_940
    rx1290_cur."!cursor_debug"("START", "infixstopper")
  debug_940:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1293_done
    goto rxscan1293_scan
  rxscan1293_loop:
    (rx1290_pos) = rx1290_cur."from"()
    inc rx1290_pos
    rx1290_cur."!cursor_from"(rx1290_pos)
    ge rx1290_pos, rx1290_eos, rxscan1293_done
  rxscan1293_scan:
    set_addr $I10, rxscan1293_loop
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  rxscan1293_done:
.annotate 'line', 591
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."lambda"()
    unless $P10, rx1290_fail
  # rx pass
    rx1290_cur."!cursor_pass"(rx1290_pos, "infixstopper")
    if_null rx1290_debug, debug_941
    rx1290_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1290_pos)
  debug_941:
    .return (rx1290_cur)
  rx1290_restart:
.annotate 'line', 4
    if_null rx1290_debug, debug_942
    rx1290_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_942:
  rx1290_fail:
    (rx1290_rep, rx1290_pos, $I10, $P10) = rx1290_cur."!mark_fail"(0)
    lt rx1290_pos, -1, rx1290_done
    eq rx1290_pos, -1, rx1290_fail
    jump $I10
  rx1290_done:
    rx1290_cur."!cursor_fail"()
    if_null rx1290_debug, debug_943
    rx1290_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_943:
    .return (rx1290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("274_1300051172.188") :method
.annotate 'line', 4
    new $P1292, "ResizablePMCArray"
    push $P1292, ""
    .return ($P1292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("275_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_944
    rx1295_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_944:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1299_done
    goto rxscan1299_scan
  rxscan1299_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1299_done
  rxscan1299_scan:
    set_addr $I10, rxscan1299_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1299_done:
.annotate 'line', 594
  # rx literal  "["
    add $I11, rx1295_pos, 1
    gt $I11, rx1295_eos, rx1295_fail
    sub $I11, rx1295_pos, rx1295_off
    ord $I11, rx1295_tgt, $I11
    ne $I11, 91, rx1295_fail
    add rx1295_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."ws"()
    unless $P10, rx1295_fail
    rx1295_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."EXPR"()
    unless $P10, rx1295_fail
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1295_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1295_pos, 1
    gt $I11, rx1295_eos, rx1295_fail
    sub $I11, rx1295_pos, rx1295_off
    ord $I11, rx1295_tgt, $I11
    ne $I11, 93, rx1295_fail
    add rx1295_pos, 1
.annotate 'line', 595
  # rx subrule "O" subtype=capture negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."O"("%methodop")
    unless $P10, rx1295_fail
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1295_pos = $P10."pos"()
.annotate 'line', 593
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "postcircumfix:sym<[ ]>")
    if_null rx1295_debug, debug_945
    rx1295_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1295_pos)
  debug_945:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 4
    if_null rx1295_debug, debug_946
    rx1295_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_946:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_947
    rx1295_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_947:
    .return (rx1295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("276_1300051172.188") :method
.annotate 'line', 4
    $P1297 = self."!PREFIX__!subrule"("ws", "[")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("277_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_948
    rx1301_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_948:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1305_done
    goto rxscan1305_scan
  rxscan1305_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1305_done
  rxscan1305_scan:
    set_addr $I10, rxscan1305_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1305_done:
.annotate 'line', 599
  # rx literal  "{"
    add $I11, rx1301_pos, 1
    gt $I11, rx1301_eos, rx1301_fail
    sub $I11, rx1301_pos, rx1301_off
    ord $I11, rx1301_tgt, $I11
    ne $I11, 123, rx1301_fail
    add rx1301_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."ws"()
    unless $P10, rx1301_fail
    rx1301_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."EXPR"()
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1301_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1301_pos, 1
    gt $I11, rx1301_eos, rx1301_fail
    sub $I11, rx1301_pos, rx1301_off
    ord $I11, rx1301_tgt, $I11
    ne $I11, 125, rx1301_fail
    add rx1301_pos, 1
.annotate 'line', 600
  # rx subrule "O" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."O"("%methodop")
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1301_pos = $P10."pos"()
.annotate 'line', 598
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "postcircumfix:sym<{ }>")
    if_null rx1301_debug, debug_949
    rx1301_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1301_pos)
  debug_949:
    .return (rx1301_cur)
  rx1301_restart:
.annotate 'line', 4
    if_null rx1301_debug, debug_950
    rx1301_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_950:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_951
    rx1301_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_951:
    .return (rx1301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("278_1300051172.188") :method
.annotate 'line', 4
    $P1303 = self."!PREFIX__!subrule"("ws", "{")
    new $P1304, "ResizablePMCArray"
    push $P1304, $P1303
    .return ($P1304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("279_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1307_tgt
    .local int rx1307_pos
    .local int rx1307_off
    .local int rx1307_eos
    .local int rx1307_rep
    .local pmc rx1307_cur
    .local pmc rx1307_debug
    (rx1307_cur, rx1307_pos, rx1307_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1307_cur
    .local pmc match
    .lex "$/", match
    length rx1307_eos, rx1307_tgt
    gt rx1307_pos, rx1307_eos, rx1307_done
    set rx1307_off, 0
    lt rx1307_pos, 2, rx1307_start
    sub rx1307_off, rx1307_pos, 1
    substr rx1307_tgt, rx1307_tgt, rx1307_off
  rx1307_start:
    eq $I10, 1, rx1307_restart
    if_null rx1307_debug, debug_952
    rx1307_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_952:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1310_done
    goto rxscan1310_scan
  rxscan1310_loop:
    (rx1307_pos) = rx1307_cur."from"()
    inc rx1307_pos
    rx1307_cur."!cursor_from"(rx1307_pos)
    ge rx1307_pos, rx1307_eos, rxscan1310_done
  rxscan1310_scan:
    set_addr $I10, rxscan1310_loop
    rx1307_cur."!mark_push"(0, rx1307_pos, $I10)
  rxscan1310_done:
.annotate 'line', 604
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1307_pos, rx1307_off
    substr $S10, rx1307_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1307_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1307_cur."!cursor_pos"(rx1307_pos)
    $P10 = rx1307_cur."quote_EXPR"(":q")
    unless $P10, rx1307_fail
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1307_pos = $P10."pos"()
.annotate 'line', 605
  # rx subrule "O" subtype=capture negate=
    rx1307_cur."!cursor_pos"(rx1307_pos)
    $P10 = rx1307_cur."O"("%methodop")
    unless $P10, rx1307_fail
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1307_pos = $P10."pos"()
.annotate 'line', 603
  # rx pass
    rx1307_cur."!cursor_pass"(rx1307_pos, "postcircumfix:sym<ang>")
    if_null rx1307_debug, debug_953
    rx1307_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1307_pos)
  debug_953:
    .return (rx1307_cur)
  rx1307_restart:
.annotate 'line', 4
    if_null rx1307_debug, debug_954
    rx1307_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_954:
  rx1307_fail:
    (rx1307_rep, rx1307_pos, $I10, $P10) = rx1307_cur."!mark_fail"(0)
    lt rx1307_pos, -1, rx1307_done
    eq rx1307_pos, -1, rx1307_fail
    jump $I10
  rx1307_done:
    rx1307_cur."!cursor_fail"()
    if_null rx1307_debug, debug_955
    rx1307_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_955:
    .return (rx1307_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("280_1300051172.188") :method
.annotate 'line', 4
    new $P1309, "ResizablePMCArray"
    push $P1309, "<"
    .return ($P1309)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("281_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1312_tgt
    .local int rx1312_pos
    .local int rx1312_off
    .local int rx1312_eos
    .local int rx1312_rep
    .local pmc rx1312_cur
    .local pmc rx1312_debug
    (rx1312_cur, rx1312_pos, rx1312_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1312_cur
    .local pmc match
    .lex "$/", match
    length rx1312_eos, rx1312_tgt
    gt rx1312_pos, rx1312_eos, rx1312_done
    set rx1312_off, 0
    lt rx1312_pos, 2, rx1312_start
    sub rx1312_off, rx1312_pos, 1
    substr rx1312_tgt, rx1312_tgt, rx1312_off
  rx1312_start:
    eq $I10, 1, rx1312_restart
    if_null rx1312_debug, debug_956
    rx1312_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_956:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1316_done
    goto rxscan1316_scan
  rxscan1316_loop:
    (rx1312_pos) = rx1312_cur."from"()
    inc rx1312_pos
    rx1312_cur."!cursor_from"(rx1312_pos)
    ge rx1312_pos, rx1312_eos, rxscan1316_done
  rxscan1316_scan:
    set_addr $I10, rxscan1316_loop
    rx1312_cur."!mark_push"(0, rx1312_pos, $I10)
  rxscan1316_done:
.annotate 'line', 609
  # rx literal  "("
    add $I11, rx1312_pos, 1
    gt $I11, rx1312_eos, rx1312_fail
    sub $I11, rx1312_pos, rx1312_off
    ord $I11, rx1312_tgt, $I11
    ne $I11, 40, rx1312_fail
    add rx1312_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1312_cur."!cursor_pos"(rx1312_pos)
    $P10 = rx1312_cur."ws"()
    unless $P10, rx1312_fail
    rx1312_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1312_cur."!cursor_pos"(rx1312_pos)
    $P10 = rx1312_cur."arglist"()
    unless $P10, rx1312_fail
    rx1312_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1312_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1312_pos, 1
    gt $I11, rx1312_eos, rx1312_fail
    sub $I11, rx1312_pos, rx1312_off
    ord $I11, rx1312_tgt, $I11
    ne $I11, 41, rx1312_fail
    add rx1312_pos, 1
.annotate 'line', 610
  # rx subrule "O" subtype=capture negate=
    rx1312_cur."!cursor_pos"(rx1312_pos)
    $P10 = rx1312_cur."O"("%methodop")
    unless $P10, rx1312_fail
    rx1312_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1312_pos = $P10."pos"()
.annotate 'line', 608
  # rx pass
    rx1312_cur."!cursor_pass"(rx1312_pos, "postcircumfix:sym<( )>")
    if_null rx1312_debug, debug_957
    rx1312_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1312_pos)
  debug_957:
    .return (rx1312_cur)
  rx1312_restart:
.annotate 'line', 4
    if_null rx1312_debug, debug_958
    rx1312_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_958:
  rx1312_fail:
    (rx1312_rep, rx1312_pos, $I10, $P10) = rx1312_cur."!mark_fail"(0)
    lt rx1312_pos, -1, rx1312_done
    eq rx1312_pos, -1, rx1312_fail
    jump $I10
  rx1312_done:
    rx1312_cur."!cursor_fail"()
    if_null rx1312_debug, debug_959
    rx1312_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_959:
    .return (rx1312_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("282_1300051172.188") :method
.annotate 'line', 4
    $P1314 = self."!PREFIX__!subrule"("ws", "(")
    new $P1315, "ResizablePMCArray"
    push $P1315, $P1314
    .return ($P1315)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("283_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1318_tgt
    .local int rx1318_pos
    .local int rx1318_off
    .local int rx1318_eos
    .local int rx1318_rep
    .local pmc rx1318_cur
    .local pmc rx1318_debug
    (rx1318_cur, rx1318_pos, rx1318_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1318_cur
    .local pmc match
    .lex "$/", match
    length rx1318_eos, rx1318_tgt
    gt rx1318_pos, rx1318_eos, rx1318_done
    set rx1318_off, 0
    lt rx1318_pos, 2, rx1318_start
    sub rx1318_off, rx1318_pos, 1
    substr rx1318_tgt, rx1318_tgt, rx1318_off
  rx1318_start:
    eq $I10, 1, rx1318_restart
    if_null rx1318_debug, debug_960
    rx1318_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_960:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1322_done
    goto rxscan1322_scan
  rxscan1322_loop:
    (rx1318_pos) = rx1318_cur."from"()
    inc rx1318_pos
    rx1318_cur."!cursor_from"(rx1318_pos)
    ge rx1318_pos, rx1318_eos, rxscan1322_done
  rxscan1322_scan:
    set_addr $I10, rxscan1322_loop
    rx1318_cur."!mark_push"(0, rx1318_pos, $I10)
  rxscan1322_done:
.annotate 'line', 613
  # rx subrule "dotty" subtype=capture negate=
    rx1318_cur."!cursor_pos"(rx1318_pos)
    $P10 = rx1318_cur."dotty"()
    unless $P10, rx1318_fail
    rx1318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1318_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1318_cur."!cursor_pos"(rx1318_pos)
    $P10 = rx1318_cur."O"("%methodop")
    unless $P10, rx1318_fail
    rx1318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1318_pos = $P10."pos"()
  # rx pass
    rx1318_cur."!cursor_pass"(rx1318_pos, "postfix:sym<.>")
    if_null rx1318_debug, debug_961
    rx1318_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1318_pos)
  debug_961:
    .return (rx1318_cur)
  rx1318_restart:
.annotate 'line', 4
    if_null rx1318_debug, debug_962
    rx1318_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_962:
  rx1318_fail:
    (rx1318_rep, rx1318_pos, $I10, $P10) = rx1318_cur."!mark_fail"(0)
    lt rx1318_pos, -1, rx1318_done
    eq rx1318_pos, -1, rx1318_fail
    jump $I10
  rx1318_done:
    rx1318_cur."!cursor_fail"()
    if_null rx1318_debug, debug_963
    rx1318_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_963:
    .return (rx1318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("284_1300051172.188") :method
.annotate 'line', 4
    $P1320 = self."!PREFIX__!subrule"("dotty", "")
    new $P1321, "ResizablePMCArray"
    push $P1321, $P1320
    .return ($P1321)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("285_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1324_tgt
    .local int rx1324_pos
    .local int rx1324_off
    .local int rx1324_eos
    .local int rx1324_rep
    .local pmc rx1324_cur
    .local pmc rx1324_debug
    (rx1324_cur, rx1324_pos, rx1324_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1324_cur
    .local pmc match
    .lex "$/", match
    length rx1324_eos, rx1324_tgt
    gt rx1324_pos, rx1324_eos, rx1324_done
    set rx1324_off, 0
    lt rx1324_pos, 2, rx1324_start
    sub rx1324_off, rx1324_pos, 1
    substr rx1324_tgt, rx1324_tgt, rx1324_off
  rx1324_start:
    eq $I10, 1, rx1324_restart
    if_null rx1324_debug, debug_964
    rx1324_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_964:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1328_done
    goto rxscan1328_scan
  rxscan1328_loop:
    (rx1324_pos) = rx1324_cur."from"()
    inc rx1324_pos
    rx1324_cur."!cursor_from"(rx1324_pos)
    ge rx1324_pos, rx1324_eos, rxscan1328_done
  rxscan1328_scan:
    set_addr $I10, rxscan1328_loop
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  rxscan1328_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1329_fail
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  # rx literal  "++"
    add $I11, rx1324_pos, 2
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    substr $S10, rx1324_tgt, $I11, 2
    ne $S10, "++", rx1324_fail
    add rx1324_pos, 2
    set_addr $I10, rxcap_1329_fail
    ($I12, $I11) = rx1324_cur."!mark_peek"($I10)
    rx1324_cur."!cursor_pos"($I11)
    ($P10) = rx1324_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1324_pos, "")
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1329_done
  rxcap_1329_fail:
    goto rx1324_fail
  rxcap_1329_done:
  # rx subrule "O" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1324_pos = $P10."pos"()
  # rx pass
    rx1324_cur."!cursor_pass"(rx1324_pos, "prefix:sym<++>")
    if_null rx1324_debug, debug_965
    rx1324_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1324_pos)
  debug_965:
    .return (rx1324_cur)
  rx1324_restart:
.annotate 'line', 4
    if_null rx1324_debug, debug_966
    rx1324_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_966:
  rx1324_fail:
    (rx1324_rep, rx1324_pos, $I10, $P10) = rx1324_cur."!mark_fail"(0)
    lt rx1324_pos, -1, rx1324_done
    eq rx1324_pos, -1, rx1324_fail
    jump $I10
  rx1324_done:
    rx1324_cur."!cursor_fail"()
    if_null rx1324_debug, debug_967
    rx1324_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_967:
    .return (rx1324_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("286_1300051172.188") :method
.annotate 'line', 4
    $P1326 = self."!PREFIX__!subrule"("O", "++")
    new $P1327, "ResizablePMCArray"
    push $P1327, $P1326
    .return ($P1327)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("287_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1331_tgt
    .local int rx1331_pos
    .local int rx1331_off
    .local int rx1331_eos
    .local int rx1331_rep
    .local pmc rx1331_cur
    .local pmc rx1331_debug
    (rx1331_cur, rx1331_pos, rx1331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1331_cur
    .local pmc match
    .lex "$/", match
    length rx1331_eos, rx1331_tgt
    gt rx1331_pos, rx1331_eos, rx1331_done
    set rx1331_off, 0
    lt rx1331_pos, 2, rx1331_start
    sub rx1331_off, rx1331_pos, 1
    substr rx1331_tgt, rx1331_tgt, rx1331_off
  rx1331_start:
    eq $I10, 1, rx1331_restart
    if_null rx1331_debug, debug_968
    rx1331_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_968:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1335_done
    goto rxscan1335_scan
  rxscan1335_loop:
    (rx1331_pos) = rx1331_cur."from"()
    inc rx1331_pos
    rx1331_cur."!cursor_from"(rx1331_pos)
    ge rx1331_pos, rx1331_eos, rxscan1335_done
  rxscan1335_scan:
    set_addr $I10, rxscan1335_loop
    rx1331_cur."!mark_push"(0, rx1331_pos, $I10)
  rxscan1335_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1336_fail
    rx1331_cur."!mark_push"(0, rx1331_pos, $I10)
  # rx literal  "--"
    add $I11, rx1331_pos, 2
    gt $I11, rx1331_eos, rx1331_fail
    sub $I11, rx1331_pos, rx1331_off
    substr $S10, rx1331_tgt, $I11, 2
    ne $S10, "--", rx1331_fail
    add rx1331_pos, 2
    set_addr $I10, rxcap_1336_fail
    ($I12, $I11) = rx1331_cur."!mark_peek"($I10)
    rx1331_cur."!cursor_pos"($I11)
    ($P10) = rx1331_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1331_pos, "")
    rx1331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1336_done
  rxcap_1336_fail:
    goto rx1331_fail
  rxcap_1336_done:
  # rx subrule "O" subtype=capture negate=
    rx1331_cur."!cursor_pos"(rx1331_pos)
    $P10 = rx1331_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1331_fail
    rx1331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1331_pos = $P10."pos"()
  # rx pass
    rx1331_cur."!cursor_pass"(rx1331_pos, "prefix:sym<-->")
    if_null rx1331_debug, debug_969
    rx1331_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1331_pos)
  debug_969:
    .return (rx1331_cur)
  rx1331_restart:
.annotate 'line', 4
    if_null rx1331_debug, debug_970
    rx1331_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_970:
  rx1331_fail:
    (rx1331_rep, rx1331_pos, $I10, $P10) = rx1331_cur."!mark_fail"(0)
    lt rx1331_pos, -1, rx1331_done
    eq rx1331_pos, -1, rx1331_fail
    jump $I10
  rx1331_done:
    rx1331_cur."!cursor_fail"()
    if_null rx1331_debug, debug_971
    rx1331_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_971:
    .return (rx1331_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("288_1300051172.188") :method
.annotate 'line', 4
    $P1333 = self."!PREFIX__!subrule"("O", "--")
    new $P1334, "ResizablePMCArray"
    push $P1334, $P1333
    .return ($P1334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("289_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1338_tgt
    .local int rx1338_pos
    .local int rx1338_off
    .local int rx1338_eos
    .local int rx1338_rep
    .local pmc rx1338_cur
    .local pmc rx1338_debug
    (rx1338_cur, rx1338_pos, rx1338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1338_cur
    .local pmc match
    .lex "$/", match
    length rx1338_eos, rx1338_tgt
    gt rx1338_pos, rx1338_eos, rx1338_done
    set rx1338_off, 0
    lt rx1338_pos, 2, rx1338_start
    sub rx1338_off, rx1338_pos, 1
    substr rx1338_tgt, rx1338_tgt, rx1338_off
  rx1338_start:
    eq $I10, 1, rx1338_restart
    if_null rx1338_debug, debug_972
    rx1338_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_972:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1342_done
    goto rxscan1342_scan
  rxscan1342_loop:
    (rx1338_pos) = rx1338_cur."from"()
    inc rx1338_pos
    rx1338_cur."!cursor_from"(rx1338_pos)
    ge rx1338_pos, rx1338_eos, rxscan1342_done
  rxscan1342_scan:
    set_addr $I10, rxscan1342_loop
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
  rxscan1342_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1343_fail
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
  # rx literal  "++"
    add $I11, rx1338_pos, 2
    gt $I11, rx1338_eos, rx1338_fail
    sub $I11, rx1338_pos, rx1338_off
    substr $S10, rx1338_tgt, $I11, 2
    ne $S10, "++", rx1338_fail
    add rx1338_pos, 2
    set_addr $I10, rxcap_1343_fail
    ($I12, $I11) = rx1338_cur."!mark_peek"($I10)
    rx1338_cur."!cursor_pos"($I11)
    ($P10) = rx1338_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1338_pos, "")
    rx1338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1343_done
  rxcap_1343_fail:
    goto rx1338_fail
  rxcap_1343_done:
  # rx subrule "O" subtype=capture negate=
    rx1338_cur."!cursor_pos"(rx1338_pos)
    $P10 = rx1338_cur."O"("%autoincrement")
    unless $P10, rx1338_fail
    rx1338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1338_pos = $P10."pos"()
  # rx pass
    rx1338_cur."!cursor_pass"(rx1338_pos, "postfix:sym<++>")
    if_null rx1338_debug, debug_973
    rx1338_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1338_pos)
  debug_973:
    .return (rx1338_cur)
  rx1338_restart:
.annotate 'line', 4
    if_null rx1338_debug, debug_974
    rx1338_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_974:
  rx1338_fail:
    (rx1338_rep, rx1338_pos, $I10, $P10) = rx1338_cur."!mark_fail"(0)
    lt rx1338_pos, -1, rx1338_done
    eq rx1338_pos, -1, rx1338_fail
    jump $I10
  rx1338_done:
    rx1338_cur."!cursor_fail"()
    if_null rx1338_debug, debug_975
    rx1338_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_975:
    .return (rx1338_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("290_1300051172.188") :method
.annotate 'line', 4
    $P1340 = self."!PREFIX__!subrule"("O", "++")
    new $P1341, "ResizablePMCArray"
    push $P1341, $P1340
    .return ($P1341)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("291_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1345_tgt
    .local int rx1345_pos
    .local int rx1345_off
    .local int rx1345_eos
    .local int rx1345_rep
    .local pmc rx1345_cur
    .local pmc rx1345_debug
    (rx1345_cur, rx1345_pos, rx1345_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1345_cur
    .local pmc match
    .lex "$/", match
    length rx1345_eos, rx1345_tgt
    gt rx1345_pos, rx1345_eos, rx1345_done
    set rx1345_off, 0
    lt rx1345_pos, 2, rx1345_start
    sub rx1345_off, rx1345_pos, 1
    substr rx1345_tgt, rx1345_tgt, rx1345_off
  rx1345_start:
    eq $I10, 1, rx1345_restart
    if_null rx1345_debug, debug_976
    rx1345_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_976:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1349_done
    goto rxscan1349_scan
  rxscan1349_loop:
    (rx1345_pos) = rx1345_cur."from"()
    inc rx1345_pos
    rx1345_cur."!cursor_from"(rx1345_pos)
    ge rx1345_pos, rx1345_eos, rxscan1349_done
  rxscan1349_scan:
    set_addr $I10, rxscan1349_loop
    rx1345_cur."!mark_push"(0, rx1345_pos, $I10)
  rxscan1349_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1350_fail
    rx1345_cur."!mark_push"(0, rx1345_pos, $I10)
  # rx literal  "--"
    add $I11, rx1345_pos, 2
    gt $I11, rx1345_eos, rx1345_fail
    sub $I11, rx1345_pos, rx1345_off
    substr $S10, rx1345_tgt, $I11, 2
    ne $S10, "--", rx1345_fail
    add rx1345_pos, 2
    set_addr $I10, rxcap_1350_fail
    ($I12, $I11) = rx1345_cur."!mark_peek"($I10)
    rx1345_cur."!cursor_pos"($I11)
    ($P10) = rx1345_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1345_pos, "")
    rx1345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1350_done
  rxcap_1350_fail:
    goto rx1345_fail
  rxcap_1350_done:
  # rx subrule "O" subtype=capture negate=
    rx1345_cur."!cursor_pos"(rx1345_pos)
    $P10 = rx1345_cur."O"("%autoincrement")
    unless $P10, rx1345_fail
    rx1345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1345_pos = $P10."pos"()
  # rx pass
    rx1345_cur."!cursor_pass"(rx1345_pos, "postfix:sym<-->")
    if_null rx1345_debug, debug_977
    rx1345_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1345_pos)
  debug_977:
    .return (rx1345_cur)
  rx1345_restart:
.annotate 'line', 4
    if_null rx1345_debug, debug_978
    rx1345_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_978:
  rx1345_fail:
    (rx1345_rep, rx1345_pos, $I10, $P10) = rx1345_cur."!mark_fail"(0)
    lt rx1345_pos, -1, rx1345_done
    eq rx1345_pos, -1, rx1345_fail
    jump $I10
  rx1345_done:
    rx1345_cur."!cursor_fail"()
    if_null rx1345_debug, debug_979
    rx1345_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_979:
    .return (rx1345_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("292_1300051172.188") :method
.annotate 'line', 4
    $P1347 = self."!PREFIX__!subrule"("O", "--")
    new $P1348, "ResizablePMCArray"
    push $P1348, $P1347
    .return ($P1348)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("293_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1352_tgt
    .local int rx1352_pos
    .local int rx1352_off
    .local int rx1352_eos
    .local int rx1352_rep
    .local pmc rx1352_cur
    .local pmc rx1352_debug
    (rx1352_cur, rx1352_pos, rx1352_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1352_cur
    .local pmc match
    .lex "$/", match
    length rx1352_eos, rx1352_tgt
    gt rx1352_pos, rx1352_eos, rx1352_done
    set rx1352_off, 0
    lt rx1352_pos, 2, rx1352_start
    sub rx1352_off, rx1352_pos, 1
    substr rx1352_tgt, rx1352_tgt, rx1352_off
  rx1352_start:
    eq $I10, 1, rx1352_restart
    if_null rx1352_debug, debug_980
    rx1352_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_980:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1356_done
    goto rxscan1356_scan
  rxscan1356_loop:
    (rx1352_pos) = rx1352_cur."from"()
    inc rx1352_pos
    rx1352_cur."!cursor_from"(rx1352_pos)
    ge rx1352_pos, rx1352_eos, rxscan1356_done
  rxscan1356_scan:
    set_addr $I10, rxscan1356_loop
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxscan1356_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1357_fail
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  # rx literal  "**"
    add $I11, rx1352_pos, 2
    gt $I11, rx1352_eos, rx1352_fail
    sub $I11, rx1352_pos, rx1352_off
    substr $S10, rx1352_tgt, $I11, 2
    ne $S10, "**", rx1352_fail
    add rx1352_pos, 2
    set_addr $I10, rxcap_1357_fail
    ($I12, $I11) = rx1352_cur."!mark_peek"($I10)
    rx1352_cur."!cursor_pos"($I11)
    ($P10) = rx1352_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1352_pos, "")
    rx1352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1357_done
  rxcap_1357_fail:
    goto rx1352_fail
  rxcap_1357_done:
  # rx subrule "O" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1352_fail
    rx1352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1352_pos = $P10."pos"()
  # rx pass
    rx1352_cur."!cursor_pass"(rx1352_pos, "infix:sym<**>")
    if_null rx1352_debug, debug_981
    rx1352_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1352_pos)
  debug_981:
    .return (rx1352_cur)
  rx1352_restart:
.annotate 'line', 4
    if_null rx1352_debug, debug_982
    rx1352_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_982:
  rx1352_fail:
    (rx1352_rep, rx1352_pos, $I10, $P10) = rx1352_cur."!mark_fail"(0)
    lt rx1352_pos, -1, rx1352_done
    eq rx1352_pos, -1, rx1352_fail
    jump $I10
  rx1352_done:
    rx1352_cur."!cursor_fail"()
    if_null rx1352_debug, debug_983
    rx1352_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_983:
    .return (rx1352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("294_1300051172.188") :method
.annotate 'line', 4
    $P1354 = self."!PREFIX__!subrule"("O", "**")
    new $P1355, "ResizablePMCArray"
    push $P1355, $P1354
    .return ($P1355)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("295_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_984
    rx1359_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_984:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1363_done
    goto rxscan1363_scan
  rxscan1363_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1363_done
  rxscan1363_scan:
    set_addr $I10, rxscan1363_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1363_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1364_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "+"
    add $I11, rx1359_pos, 1
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    ord $I11, rx1359_tgt, $I11
    ne $I11, 43, rx1359_fail
    add rx1359_pos, 1
    set_addr $I10, rxcap_1364_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1364_done
  rxcap_1364_fail:
    goto rx1359_fail
  rxcap_1364_done:
  # rx subrule "O" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1359_pos = $P10."pos"()
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "prefix:sym<+>")
    if_null rx1359_debug, debug_985
    rx1359_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1359_pos)
  debug_985:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 4
    if_null rx1359_debug, debug_986
    rx1359_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_986:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_987
    rx1359_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_987:
    .return (rx1359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("296_1300051172.188") :method
.annotate 'line', 4
    $P1361 = self."!PREFIX__!subrule"("O", "+")
    new $P1362, "ResizablePMCArray"
    push $P1362, $P1361
    .return ($P1362)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("297_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1366_tgt
    .local int rx1366_pos
    .local int rx1366_off
    .local int rx1366_eos
    .local int rx1366_rep
    .local pmc rx1366_cur
    .local pmc rx1366_debug
    (rx1366_cur, rx1366_pos, rx1366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1366_cur
    .local pmc match
    .lex "$/", match
    length rx1366_eos, rx1366_tgt
    gt rx1366_pos, rx1366_eos, rx1366_done
    set rx1366_off, 0
    lt rx1366_pos, 2, rx1366_start
    sub rx1366_off, rx1366_pos, 1
    substr rx1366_tgt, rx1366_tgt, rx1366_off
  rx1366_start:
    eq $I10, 1, rx1366_restart
    if_null rx1366_debug, debug_988
    rx1366_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_988:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1370_done
    goto rxscan1370_scan
  rxscan1370_loop:
    (rx1366_pos) = rx1366_cur."from"()
    inc rx1366_pos
    rx1366_cur."!cursor_from"(rx1366_pos)
    ge rx1366_pos, rx1366_eos, rxscan1370_done
  rxscan1370_scan:
    set_addr $I10, rxscan1370_loop
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  rxscan1370_done:
.annotate 'line', 625
  # rx subcapture "sym"
    set_addr $I10, rxcap_1371_fail
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  # rx literal  "~"
    add $I11, rx1366_pos, 1
    gt $I11, rx1366_eos, rx1366_fail
    sub $I11, rx1366_pos, rx1366_off
    ord $I11, rx1366_tgt, $I11
    ne $I11, 126, rx1366_fail
    add rx1366_pos, 1
    set_addr $I10, rxcap_1371_fail
    ($I12, $I11) = rx1366_cur."!mark_peek"($I10)
    rx1366_cur."!cursor_pos"($I11)
    ($P10) = rx1366_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1366_pos, "")
    rx1366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1371_done
  rxcap_1371_fail:
    goto rx1366_fail
  rxcap_1371_done:
  # rx subrule "O" subtype=capture negate=
    rx1366_cur."!cursor_pos"(rx1366_pos)
    $P10 = rx1366_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1366_fail
    rx1366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1366_pos = $P10."pos"()
  # rx pass
    rx1366_cur."!cursor_pass"(rx1366_pos, "prefix:sym<~>")
    if_null rx1366_debug, debug_989
    rx1366_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1366_pos)
  debug_989:
    .return (rx1366_cur)
  rx1366_restart:
.annotate 'line', 4
    if_null rx1366_debug, debug_990
    rx1366_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_990:
  rx1366_fail:
    (rx1366_rep, rx1366_pos, $I10, $P10) = rx1366_cur."!mark_fail"(0)
    lt rx1366_pos, -1, rx1366_done
    eq rx1366_pos, -1, rx1366_fail
    jump $I10
  rx1366_done:
    rx1366_cur."!cursor_fail"()
    if_null rx1366_debug, debug_991
    rx1366_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_991:
    .return (rx1366_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("298_1300051172.188") :method
.annotate 'line', 4
    $P1368 = self."!PREFIX__!subrule"("O", "~")
    new $P1369, "ResizablePMCArray"
    push $P1369, $P1368
    .return ($P1369)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("299_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1373_tgt
    .local int rx1373_pos
    .local int rx1373_off
    .local int rx1373_eos
    .local int rx1373_rep
    .local pmc rx1373_cur
    .local pmc rx1373_debug
    (rx1373_cur, rx1373_pos, rx1373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1373_cur
    .local pmc match
    .lex "$/", match
    length rx1373_eos, rx1373_tgt
    gt rx1373_pos, rx1373_eos, rx1373_done
    set rx1373_off, 0
    lt rx1373_pos, 2, rx1373_start
    sub rx1373_off, rx1373_pos, 1
    substr rx1373_tgt, rx1373_tgt, rx1373_off
  rx1373_start:
    eq $I10, 1, rx1373_restart
    if_null rx1373_debug, debug_992
    rx1373_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_992:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1376_done
    goto rxscan1376_scan
  rxscan1376_loop:
    (rx1373_pos) = rx1373_cur."from"()
    inc rx1373_pos
    rx1373_cur."!cursor_from"(rx1373_pos)
    ge rx1373_pos, rx1373_eos, rxscan1376_done
  rxscan1376_scan:
    set_addr $I10, rxscan1376_loop
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  rxscan1376_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1377_fail
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  # rx literal  "-"
    add $I11, rx1373_pos, 1
    gt $I11, rx1373_eos, rx1373_fail
    sub $I11, rx1373_pos, rx1373_off
    ord $I11, rx1373_tgt, $I11
    ne $I11, 45, rx1373_fail
    add rx1373_pos, 1
    set_addr $I10, rxcap_1377_fail
    ($I12, $I11) = rx1373_cur."!mark_peek"($I10)
    rx1373_cur."!cursor_pos"($I11)
    ($P10) = rx1373_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1373_pos, "")
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1377_done
  rxcap_1377_fail:
    goto rx1373_fail
  rxcap_1377_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1373_pos, rx1373_off
    substr $S10, rx1373_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1373_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."number"()
    if $P10, rx1373_fail
  # rx subrule "O" subtype=capture negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1373_fail
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1373_pos = $P10."pos"()
  # rx pass
    rx1373_cur."!cursor_pass"(rx1373_pos, "prefix:sym<->")
    if_null rx1373_debug, debug_993
    rx1373_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1373_pos)
  debug_993:
    .return (rx1373_cur)
  rx1373_restart:
.annotate 'line', 4
    if_null rx1373_debug, debug_994
    rx1373_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_994:
  rx1373_fail:
    (rx1373_rep, rx1373_pos, $I10, $P10) = rx1373_cur."!mark_fail"(0)
    lt rx1373_pos, -1, rx1373_done
    eq rx1373_pos, -1, rx1373_fail
    jump $I10
  rx1373_done:
    rx1373_cur."!cursor_fail"()
    if_null rx1373_debug, debug_995
    rx1373_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_995:
    .return (rx1373_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("300_1300051172.188") :method
.annotate 'line', 4
    new $P1375, "ResizablePMCArray"
    push $P1375, "-"
    .return ($P1375)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("301_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1379_tgt
    .local int rx1379_pos
    .local int rx1379_off
    .local int rx1379_eos
    .local int rx1379_rep
    .local pmc rx1379_cur
    .local pmc rx1379_debug
    (rx1379_cur, rx1379_pos, rx1379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1379_cur
    .local pmc match
    .lex "$/", match
    length rx1379_eos, rx1379_tgt
    gt rx1379_pos, rx1379_eos, rx1379_done
    set rx1379_off, 0
    lt rx1379_pos, 2, rx1379_start
    sub rx1379_off, rx1379_pos, 1
    substr rx1379_tgt, rx1379_tgt, rx1379_off
  rx1379_start:
    eq $I10, 1, rx1379_restart
    if_null rx1379_debug, debug_996
    rx1379_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_996:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1383_done
    goto rxscan1383_scan
  rxscan1383_loop:
    (rx1379_pos) = rx1379_cur."from"()
    inc rx1379_pos
    rx1379_cur."!cursor_from"(rx1379_pos)
    ge rx1379_pos, rx1379_eos, rxscan1383_done
  rxscan1383_scan:
    set_addr $I10, rxscan1383_loop
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxscan1383_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1384_fail
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  # rx literal  "?"
    add $I11, rx1379_pos, 1
    gt $I11, rx1379_eos, rx1379_fail
    sub $I11, rx1379_pos, rx1379_off
    ord $I11, rx1379_tgt, $I11
    ne $I11, 63, rx1379_fail
    add rx1379_pos, 1
    set_addr $I10, rxcap_1384_fail
    ($I12, $I11) = rx1379_cur."!mark_peek"($I10)
    rx1379_cur."!cursor_pos"($I11)
    ($P10) = rx1379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1379_pos, "")
    rx1379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1384_done
  rxcap_1384_fail:
    goto rx1379_fail
  rxcap_1384_done:
  # rx subrule "O" subtype=capture negate=
    rx1379_cur."!cursor_pos"(rx1379_pos)
    $P10 = rx1379_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1379_fail
    rx1379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1379_pos = $P10."pos"()
  # rx pass
    rx1379_cur."!cursor_pass"(rx1379_pos, "prefix:sym<?>")
    if_null rx1379_debug, debug_997
    rx1379_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1379_pos)
  debug_997:
    .return (rx1379_cur)
  rx1379_restart:
.annotate 'line', 4
    if_null rx1379_debug, debug_998
    rx1379_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_998:
  rx1379_fail:
    (rx1379_rep, rx1379_pos, $I10, $P10) = rx1379_cur."!mark_fail"(0)
    lt rx1379_pos, -1, rx1379_done
    eq rx1379_pos, -1, rx1379_fail
    jump $I10
  rx1379_done:
    rx1379_cur."!cursor_fail"()
    if_null rx1379_debug, debug_999
    rx1379_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_999:
    .return (rx1379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("302_1300051172.188") :method
.annotate 'line', 4
    $P1381 = self."!PREFIX__!subrule"("O", "?")
    new $P1382, "ResizablePMCArray"
    push $P1382, $P1381
    .return ($P1382)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("303_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1386_tgt
    .local int rx1386_pos
    .local int rx1386_off
    .local int rx1386_eos
    .local int rx1386_rep
    .local pmc rx1386_cur
    .local pmc rx1386_debug
    (rx1386_cur, rx1386_pos, rx1386_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1386_cur
    .local pmc match
    .lex "$/", match
    length rx1386_eos, rx1386_tgt
    gt rx1386_pos, rx1386_eos, rx1386_done
    set rx1386_off, 0
    lt rx1386_pos, 2, rx1386_start
    sub rx1386_off, rx1386_pos, 1
    substr rx1386_tgt, rx1386_tgt, rx1386_off
  rx1386_start:
    eq $I10, 1, rx1386_restart
    if_null rx1386_debug, debug_1000
    rx1386_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1000:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1390_done
    goto rxscan1390_scan
  rxscan1390_loop:
    (rx1386_pos) = rx1386_cur."from"()
    inc rx1386_pos
    rx1386_cur."!cursor_from"(rx1386_pos)
    ge rx1386_pos, rx1386_eos, rxscan1390_done
  rxscan1390_scan:
    set_addr $I10, rxscan1390_loop
    rx1386_cur."!mark_push"(0, rx1386_pos, $I10)
  rxscan1390_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1391_fail
    rx1386_cur."!mark_push"(0, rx1386_pos, $I10)
  # rx literal  "!"
    add $I11, rx1386_pos, 1
    gt $I11, rx1386_eos, rx1386_fail
    sub $I11, rx1386_pos, rx1386_off
    ord $I11, rx1386_tgt, $I11
    ne $I11, 33, rx1386_fail
    add rx1386_pos, 1
    set_addr $I10, rxcap_1391_fail
    ($I12, $I11) = rx1386_cur."!mark_peek"($I10)
    rx1386_cur."!cursor_pos"($I11)
    ($P10) = rx1386_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1386_pos, "")
    rx1386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1391_done
  rxcap_1391_fail:
    goto rx1386_fail
  rxcap_1391_done:
  # rx subrule "O" subtype=capture negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1386_fail
    rx1386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1386_pos = $P10."pos"()
  # rx pass
    rx1386_cur."!cursor_pass"(rx1386_pos, "prefix:sym<!>")
    if_null rx1386_debug, debug_1001
    rx1386_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1386_pos)
  debug_1001:
    .return (rx1386_cur)
  rx1386_restart:
.annotate 'line', 4
    if_null rx1386_debug, debug_1002
    rx1386_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1002:
  rx1386_fail:
    (rx1386_rep, rx1386_pos, $I10, $P10) = rx1386_cur."!mark_fail"(0)
    lt rx1386_pos, -1, rx1386_done
    eq rx1386_pos, -1, rx1386_fail
    jump $I10
  rx1386_done:
    rx1386_cur."!cursor_fail"()
    if_null rx1386_debug, debug_1003
    rx1386_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1003:
    .return (rx1386_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("304_1300051172.188") :method
.annotate 'line', 4
    $P1388 = self."!PREFIX__!subrule"("O", "!")
    new $P1389, "ResizablePMCArray"
    push $P1389, $P1388
    .return ($P1389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("305_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1393_tgt
    .local int rx1393_pos
    .local int rx1393_off
    .local int rx1393_eos
    .local int rx1393_rep
    .local pmc rx1393_cur
    .local pmc rx1393_debug
    (rx1393_cur, rx1393_pos, rx1393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1393_cur
    .local pmc match
    .lex "$/", match
    length rx1393_eos, rx1393_tgt
    gt rx1393_pos, rx1393_eos, rx1393_done
    set rx1393_off, 0
    lt rx1393_pos, 2, rx1393_start
    sub rx1393_off, rx1393_pos, 1
    substr rx1393_tgt, rx1393_tgt, rx1393_off
  rx1393_start:
    eq $I10, 1, rx1393_restart
    if_null rx1393_debug, debug_1004
    rx1393_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1004:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1397_done
    goto rxscan1397_scan
  rxscan1397_loop:
    (rx1393_pos) = rx1393_cur."from"()
    inc rx1393_pos
    rx1393_cur."!cursor_from"(rx1393_pos)
    ge rx1393_pos, rx1393_eos, rxscan1397_done
  rxscan1397_scan:
    set_addr $I10, rxscan1397_loop
    rx1393_cur."!mark_push"(0, rx1393_pos, $I10)
  rxscan1397_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1398_fail
    rx1393_cur."!mark_push"(0, rx1393_pos, $I10)
  # rx literal  "|"
    add $I11, rx1393_pos, 1
    gt $I11, rx1393_eos, rx1393_fail
    sub $I11, rx1393_pos, rx1393_off
    ord $I11, rx1393_tgt, $I11
    ne $I11, 124, rx1393_fail
    add rx1393_pos, 1
    set_addr $I10, rxcap_1398_fail
    ($I12, $I11) = rx1393_cur."!mark_peek"($I10)
    rx1393_cur."!cursor_pos"($I11)
    ($P10) = rx1393_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1393_pos, "")
    rx1393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1398_done
  rxcap_1398_fail:
    goto rx1393_fail
  rxcap_1398_done:
  # rx subrule "O" subtype=capture negate=
    rx1393_cur."!cursor_pos"(rx1393_pos)
    $P10 = rx1393_cur."O"("%symbolic_unary")
    unless $P10, rx1393_fail
    rx1393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1393_pos = $P10."pos"()
  # rx pass
    rx1393_cur."!cursor_pass"(rx1393_pos, "prefix:sym<|>")
    if_null rx1393_debug, debug_1005
    rx1393_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1393_pos)
  debug_1005:
    .return (rx1393_cur)
  rx1393_restart:
.annotate 'line', 4
    if_null rx1393_debug, debug_1006
    rx1393_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1006:
  rx1393_fail:
    (rx1393_rep, rx1393_pos, $I10, $P10) = rx1393_cur."!mark_fail"(0)
    lt rx1393_pos, -1, rx1393_done
    eq rx1393_pos, -1, rx1393_fail
    jump $I10
  rx1393_done:
    rx1393_cur."!cursor_fail"()
    if_null rx1393_debug, debug_1007
    rx1393_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1007:
    .return (rx1393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("306_1300051172.188") :method
.annotate 'line', 4
    $P1395 = self."!PREFIX__!subrule"("O", "|")
    new $P1396, "ResizablePMCArray"
    push $P1396, $P1395
    .return ($P1396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("307_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1400_tgt
    .local int rx1400_pos
    .local int rx1400_off
    .local int rx1400_eos
    .local int rx1400_rep
    .local pmc rx1400_cur
    .local pmc rx1400_debug
    (rx1400_cur, rx1400_pos, rx1400_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1400_cur
    .local pmc match
    .lex "$/", match
    length rx1400_eos, rx1400_tgt
    gt rx1400_pos, rx1400_eos, rx1400_done
    set rx1400_off, 0
    lt rx1400_pos, 2, rx1400_start
    sub rx1400_off, rx1400_pos, 1
    substr rx1400_tgt, rx1400_tgt, rx1400_off
  rx1400_start:
    eq $I10, 1, rx1400_restart
    if_null rx1400_debug, debug_1008
    rx1400_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1008:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1404_done
    goto rxscan1404_scan
  rxscan1404_loop:
    (rx1400_pos) = rx1400_cur."from"()
    inc rx1400_pos
    rx1400_cur."!cursor_from"(rx1400_pos)
    ge rx1400_pos, rx1400_eos, rxscan1404_done
  rxscan1404_scan:
    set_addr $I10, rxscan1404_loop
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  rxscan1404_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1405_fail
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  # rx literal  "*"
    add $I11, rx1400_pos, 1
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    ord $I11, rx1400_tgt, $I11
    ne $I11, 42, rx1400_fail
    add rx1400_pos, 1
    set_addr $I10, rxcap_1405_fail
    ($I12, $I11) = rx1400_cur."!mark_peek"($I10)
    rx1400_cur."!cursor_pos"($I11)
    ($P10) = rx1400_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1400_pos, "")
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1405_done
  rxcap_1405_fail:
    goto rx1400_fail
  rxcap_1405_done:
  # rx subrule "O" subtype=capture negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1400_fail
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1400_pos = $P10."pos"()
  # rx pass
    rx1400_cur."!cursor_pass"(rx1400_pos, "infix:sym<*>")
    if_null rx1400_debug, debug_1009
    rx1400_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1400_pos)
  debug_1009:
    .return (rx1400_cur)
  rx1400_restart:
.annotate 'line', 4
    if_null rx1400_debug, debug_1010
    rx1400_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1010:
  rx1400_fail:
    (rx1400_rep, rx1400_pos, $I10, $P10) = rx1400_cur."!mark_fail"(0)
    lt rx1400_pos, -1, rx1400_done
    eq rx1400_pos, -1, rx1400_fail
    jump $I10
  rx1400_done:
    rx1400_cur."!cursor_fail"()
    if_null rx1400_debug, debug_1011
    rx1400_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1011:
    .return (rx1400_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("308_1300051172.188") :method
.annotate 'line', 4
    $P1402 = self."!PREFIX__!subrule"("O", "*")
    new $P1403, "ResizablePMCArray"
    push $P1403, $P1402
    .return ($P1403)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("309_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1407_tgt
    .local int rx1407_pos
    .local int rx1407_off
    .local int rx1407_eos
    .local int rx1407_rep
    .local pmc rx1407_cur
    .local pmc rx1407_debug
    (rx1407_cur, rx1407_pos, rx1407_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1407_cur
    .local pmc match
    .lex "$/", match
    length rx1407_eos, rx1407_tgt
    gt rx1407_pos, rx1407_eos, rx1407_done
    set rx1407_off, 0
    lt rx1407_pos, 2, rx1407_start
    sub rx1407_off, rx1407_pos, 1
    substr rx1407_tgt, rx1407_tgt, rx1407_off
  rx1407_start:
    eq $I10, 1, rx1407_restart
    if_null rx1407_debug, debug_1012
    rx1407_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1012:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1411_done
    goto rxscan1411_scan
  rxscan1411_loop:
    (rx1407_pos) = rx1407_cur."from"()
    inc rx1407_pos
    rx1407_cur."!cursor_from"(rx1407_pos)
    ge rx1407_pos, rx1407_eos, rxscan1411_done
  rxscan1411_scan:
    set_addr $I10, rxscan1411_loop
    rx1407_cur."!mark_push"(0, rx1407_pos, $I10)
  rxscan1411_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1412_fail
    rx1407_cur."!mark_push"(0, rx1407_pos, $I10)
  # rx literal  "/"
    add $I11, rx1407_pos, 1
    gt $I11, rx1407_eos, rx1407_fail
    sub $I11, rx1407_pos, rx1407_off
    ord $I11, rx1407_tgt, $I11
    ne $I11, 47, rx1407_fail
    add rx1407_pos, 1
    set_addr $I10, rxcap_1412_fail
    ($I12, $I11) = rx1407_cur."!mark_peek"($I10)
    rx1407_cur."!cursor_pos"($I11)
    ($P10) = rx1407_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1407_pos, "")
    rx1407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1412_done
  rxcap_1412_fail:
    goto rx1407_fail
  rxcap_1412_done:
  # rx subrule "O" subtype=capture negate=
    rx1407_cur."!cursor_pos"(rx1407_pos)
    $P10 = rx1407_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1407_fail
    rx1407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1407_pos = $P10."pos"()
  # rx pass
    rx1407_cur."!cursor_pass"(rx1407_pos, "infix:sym</>")
    if_null rx1407_debug, debug_1013
    rx1407_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1407_pos)
  debug_1013:
    .return (rx1407_cur)
  rx1407_restart:
.annotate 'line', 4
    if_null rx1407_debug, debug_1014
    rx1407_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1014:
  rx1407_fail:
    (rx1407_rep, rx1407_pos, $I10, $P10) = rx1407_cur."!mark_fail"(0)
    lt rx1407_pos, -1, rx1407_done
    eq rx1407_pos, -1, rx1407_fail
    jump $I10
  rx1407_done:
    rx1407_cur."!cursor_fail"()
    if_null rx1407_debug, debug_1015
    rx1407_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1015:
    .return (rx1407_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("310_1300051172.188") :method
.annotate 'line', 4
    $P1409 = self."!PREFIX__!subrule"("O", "/")
    new $P1410, "ResizablePMCArray"
    push $P1410, $P1409
    .return ($P1410)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("311_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1414_tgt
    .local int rx1414_pos
    .local int rx1414_off
    .local int rx1414_eos
    .local int rx1414_rep
    .local pmc rx1414_cur
    .local pmc rx1414_debug
    (rx1414_cur, rx1414_pos, rx1414_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1414_cur
    .local pmc match
    .lex "$/", match
    length rx1414_eos, rx1414_tgt
    gt rx1414_pos, rx1414_eos, rx1414_done
    set rx1414_off, 0
    lt rx1414_pos, 2, rx1414_start
    sub rx1414_off, rx1414_pos, 1
    substr rx1414_tgt, rx1414_tgt, rx1414_off
  rx1414_start:
    eq $I10, 1, rx1414_restart
    if_null rx1414_debug, debug_1016
    rx1414_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1016:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1418_done
    goto rxscan1418_scan
  rxscan1418_loop:
    (rx1414_pos) = rx1414_cur."from"()
    inc rx1414_pos
    rx1414_cur."!cursor_from"(rx1414_pos)
    ge rx1414_pos, rx1414_eos, rxscan1418_done
  rxscan1418_scan:
    set_addr $I10, rxscan1418_loop
    rx1414_cur."!mark_push"(0, rx1414_pos, $I10)
  rxscan1418_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1419_fail
    rx1414_cur."!mark_push"(0, rx1414_pos, $I10)
  # rx literal  "%"
    add $I11, rx1414_pos, 1
    gt $I11, rx1414_eos, rx1414_fail
    sub $I11, rx1414_pos, rx1414_off
    ord $I11, rx1414_tgt, $I11
    ne $I11, 37, rx1414_fail
    add rx1414_pos, 1
    set_addr $I10, rxcap_1419_fail
    ($I12, $I11) = rx1414_cur."!mark_peek"($I10)
    rx1414_cur."!cursor_pos"($I11)
    ($P10) = rx1414_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1414_pos, "")
    rx1414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1419_done
  rxcap_1419_fail:
    goto rx1414_fail
  rxcap_1419_done:
  # rx subrule "O" subtype=capture negate=
    rx1414_cur."!cursor_pos"(rx1414_pos)
    $P10 = rx1414_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1414_fail
    rx1414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1414_pos = $P10."pos"()
  # rx pass
    rx1414_cur."!cursor_pass"(rx1414_pos, "infix:sym<%>")
    if_null rx1414_debug, debug_1017
    rx1414_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1414_pos)
  debug_1017:
    .return (rx1414_cur)
  rx1414_restart:
.annotate 'line', 4
    if_null rx1414_debug, debug_1018
    rx1414_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1018:
  rx1414_fail:
    (rx1414_rep, rx1414_pos, $I10, $P10) = rx1414_cur."!mark_fail"(0)
    lt rx1414_pos, -1, rx1414_done
    eq rx1414_pos, -1, rx1414_fail
    jump $I10
  rx1414_done:
    rx1414_cur."!cursor_fail"()
    if_null rx1414_debug, debug_1019
    rx1414_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1019:
    .return (rx1414_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("312_1300051172.188") :method
.annotate 'line', 4
    $P1416 = self."!PREFIX__!subrule"("O", "%")
    new $P1417, "ResizablePMCArray"
    push $P1417, $P1416
    .return ($P1417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("313_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1421_tgt
    .local int rx1421_pos
    .local int rx1421_off
    .local int rx1421_eos
    .local int rx1421_rep
    .local pmc rx1421_cur
    .local pmc rx1421_debug
    (rx1421_cur, rx1421_pos, rx1421_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1421_cur
    .local pmc match
    .lex "$/", match
    length rx1421_eos, rx1421_tgt
    gt rx1421_pos, rx1421_eos, rx1421_done
    set rx1421_off, 0
    lt rx1421_pos, 2, rx1421_start
    sub rx1421_off, rx1421_pos, 1
    substr rx1421_tgt, rx1421_tgt, rx1421_off
  rx1421_start:
    eq $I10, 1, rx1421_restart
    if_null rx1421_debug, debug_1020
    rx1421_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1020:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1425_done
    goto rxscan1425_scan
  rxscan1425_loop:
    (rx1421_pos) = rx1421_cur."from"()
    inc rx1421_pos
    rx1421_cur."!cursor_from"(rx1421_pos)
    ge rx1421_pos, rx1421_eos, rxscan1425_done
  rxscan1425_scan:
    set_addr $I10, rxscan1425_loop
    rx1421_cur."!mark_push"(0, rx1421_pos, $I10)
  rxscan1425_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1426_fail
    rx1421_cur."!mark_push"(0, rx1421_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1421_pos, 2
    gt $I11, rx1421_eos, rx1421_fail
    sub $I11, rx1421_pos, rx1421_off
    substr $S10, rx1421_tgt, $I11, 2
    ne $S10, "+&", rx1421_fail
    add rx1421_pos, 2
    set_addr $I10, rxcap_1426_fail
    ($I12, $I11) = rx1421_cur."!mark_peek"($I10)
    rx1421_cur."!cursor_pos"($I11)
    ($P10) = rx1421_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1421_pos, "")
    rx1421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1426_done
  rxcap_1426_fail:
    goto rx1421_fail
  rxcap_1426_done:
  # rx subrule "O" subtype=capture negate=
    rx1421_cur."!cursor_pos"(rx1421_pos)
    $P10 = rx1421_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1421_fail
    rx1421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1421_pos = $P10."pos"()
  # rx pass
    rx1421_cur."!cursor_pass"(rx1421_pos, "infix:sym<+&>")
    if_null rx1421_debug, debug_1021
    rx1421_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1421_pos)
  debug_1021:
    .return (rx1421_cur)
  rx1421_restart:
.annotate 'line', 4
    if_null rx1421_debug, debug_1022
    rx1421_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1022:
  rx1421_fail:
    (rx1421_rep, rx1421_pos, $I10, $P10) = rx1421_cur."!mark_fail"(0)
    lt rx1421_pos, -1, rx1421_done
    eq rx1421_pos, -1, rx1421_fail
    jump $I10
  rx1421_done:
    rx1421_cur."!cursor_fail"()
    if_null rx1421_debug, debug_1023
    rx1421_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1023:
    .return (rx1421_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("314_1300051172.188") :method
.annotate 'line', 4
    $P1423 = self."!PREFIX__!subrule"("O", "+&")
    new $P1424, "ResizablePMCArray"
    push $P1424, $P1423
    .return ($P1424)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("315_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1428_tgt
    .local int rx1428_pos
    .local int rx1428_off
    .local int rx1428_eos
    .local int rx1428_rep
    .local pmc rx1428_cur
    .local pmc rx1428_debug
    (rx1428_cur, rx1428_pos, rx1428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1428_cur
    .local pmc match
    .lex "$/", match
    length rx1428_eos, rx1428_tgt
    gt rx1428_pos, rx1428_eos, rx1428_done
    set rx1428_off, 0
    lt rx1428_pos, 2, rx1428_start
    sub rx1428_off, rx1428_pos, 1
    substr rx1428_tgt, rx1428_tgt, rx1428_off
  rx1428_start:
    eq $I10, 1, rx1428_restart
    if_null rx1428_debug, debug_1024
    rx1428_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1432_done
    goto rxscan1432_scan
  rxscan1432_loop:
    (rx1428_pos) = rx1428_cur."from"()
    inc rx1428_pos
    rx1428_cur."!cursor_from"(rx1428_pos)
    ge rx1428_pos, rx1428_eos, rxscan1432_done
  rxscan1432_scan:
    set_addr $I10, rxscan1432_loop
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxscan1432_done:
.annotate 'line', 636
  # rx subcapture "sym"
    set_addr $I10, rxcap_1433_fail
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  # rx literal  "+"
    add $I11, rx1428_pos, 1
    gt $I11, rx1428_eos, rx1428_fail
    sub $I11, rx1428_pos, rx1428_off
    ord $I11, rx1428_tgt, $I11
    ne $I11, 43, rx1428_fail
    add rx1428_pos, 1
    set_addr $I10, rxcap_1433_fail
    ($I12, $I11) = rx1428_cur."!mark_peek"($I10)
    rx1428_cur."!cursor_pos"($I11)
    ($P10) = rx1428_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1428_pos, "")
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1433_done
  rxcap_1433_fail:
    goto rx1428_fail
  rxcap_1433_done:
  # rx subrule "O" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1428_pos = $P10."pos"()
  # rx pass
    rx1428_cur."!cursor_pass"(rx1428_pos, "infix:sym<+>")
    if_null rx1428_debug, debug_1025
    rx1428_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1428_pos)
  debug_1025:
    .return (rx1428_cur)
  rx1428_restart:
.annotate 'line', 4
    if_null rx1428_debug, debug_1026
    rx1428_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1026:
  rx1428_fail:
    (rx1428_rep, rx1428_pos, $I10, $P10) = rx1428_cur."!mark_fail"(0)
    lt rx1428_pos, -1, rx1428_done
    eq rx1428_pos, -1, rx1428_fail
    jump $I10
  rx1428_done:
    rx1428_cur."!cursor_fail"()
    if_null rx1428_debug, debug_1027
    rx1428_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1027:
    .return (rx1428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("316_1300051172.188") :method
.annotate 'line', 4
    $P1430 = self."!PREFIX__!subrule"("O", "+")
    new $P1431, "ResizablePMCArray"
    push $P1431, $P1430
    .return ($P1431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("317_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_1028
    rx1435_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1439_done
    goto rxscan1439_scan
  rxscan1439_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1439_done
  rxscan1439_scan:
    set_addr $I10, rxscan1439_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1439_done:
.annotate 'line', 637
  # rx subcapture "sym"
    set_addr $I10, rxcap_1440_fail
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  # rx literal  "-"
    add $I11, rx1435_pos, 1
    gt $I11, rx1435_eos, rx1435_fail
    sub $I11, rx1435_pos, rx1435_off
    ord $I11, rx1435_tgt, $I11
    ne $I11, 45, rx1435_fail
    add rx1435_pos, 1
    set_addr $I10, rxcap_1440_fail
    ($I12, $I11) = rx1435_cur."!mark_peek"($I10)
    rx1435_cur."!cursor_pos"($I11)
    ($P10) = rx1435_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1435_pos, "")
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1440_done
  rxcap_1440_fail:
    goto rx1435_fail
  rxcap_1440_done:
  # rx subrule "O" subtype=capture negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1435_fail
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1435_pos = $P10."pos"()
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "infix:sym<->")
    if_null rx1435_debug, debug_1029
    rx1435_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1435_pos)
  debug_1029:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 4
    if_null rx1435_debug, debug_1030
    rx1435_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1030:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_1031
    rx1435_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1031:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("318_1300051172.188") :method
.annotate 'line', 4
    $P1437 = self."!PREFIX__!subrule"("O", "-")
    new $P1438, "ResizablePMCArray"
    push $P1438, $P1437
    .return ($P1438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("319_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1442_tgt
    .local int rx1442_pos
    .local int rx1442_off
    .local int rx1442_eos
    .local int rx1442_rep
    .local pmc rx1442_cur
    .local pmc rx1442_debug
    (rx1442_cur, rx1442_pos, rx1442_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1442_cur
    .local pmc match
    .lex "$/", match
    length rx1442_eos, rx1442_tgt
    gt rx1442_pos, rx1442_eos, rx1442_done
    set rx1442_off, 0
    lt rx1442_pos, 2, rx1442_start
    sub rx1442_off, rx1442_pos, 1
    substr rx1442_tgt, rx1442_tgt, rx1442_off
  rx1442_start:
    eq $I10, 1, rx1442_restart
    if_null rx1442_debug, debug_1032
    rx1442_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1032:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1446_done
    goto rxscan1446_scan
  rxscan1446_loop:
    (rx1442_pos) = rx1442_cur."from"()
    inc rx1442_pos
    rx1442_cur."!cursor_from"(rx1442_pos)
    ge rx1442_pos, rx1442_eos, rxscan1446_done
  rxscan1446_scan:
    set_addr $I10, rxscan1446_loop
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  rxscan1446_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1447_fail
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1442_pos, 2
    gt $I11, rx1442_eos, rx1442_fail
    sub $I11, rx1442_pos, rx1442_off
    substr $S10, rx1442_tgt, $I11, 2
    ne $S10, "+|", rx1442_fail
    add rx1442_pos, 2
    set_addr $I10, rxcap_1447_fail
    ($I12, $I11) = rx1442_cur."!mark_peek"($I10)
    rx1442_cur."!cursor_pos"($I11)
    ($P10) = rx1442_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1442_pos, "")
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1447_done
  rxcap_1447_fail:
    goto rx1442_fail
  rxcap_1447_done:
  # rx subrule "O" subtype=capture negate=
    rx1442_cur."!cursor_pos"(rx1442_pos)
    $P10 = rx1442_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1442_fail
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1442_pos = $P10."pos"()
  # rx pass
    rx1442_cur."!cursor_pass"(rx1442_pos, "infix:sym<+|>")
    if_null rx1442_debug, debug_1033
    rx1442_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1442_pos)
  debug_1033:
    .return (rx1442_cur)
  rx1442_restart:
.annotate 'line', 4
    if_null rx1442_debug, debug_1034
    rx1442_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1034:
  rx1442_fail:
    (rx1442_rep, rx1442_pos, $I10, $P10) = rx1442_cur."!mark_fail"(0)
    lt rx1442_pos, -1, rx1442_done
    eq rx1442_pos, -1, rx1442_fail
    jump $I10
  rx1442_done:
    rx1442_cur."!cursor_fail"()
    if_null rx1442_debug, debug_1035
    rx1442_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1035:
    .return (rx1442_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("320_1300051172.188") :method
.annotate 'line', 4
    $P1444 = self."!PREFIX__!subrule"("O", "+|")
    new $P1445, "ResizablePMCArray"
    push $P1445, $P1444
    .return ($P1445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("321_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1036
    rx1449_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1036:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1453_done
    goto rxscan1453_scan
  rxscan1453_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1453_done
  rxscan1453_scan:
    set_addr $I10, rxscan1453_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1453_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1454_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1449_pos, 2
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 2
    ne $S10, "+^", rx1449_fail
    add rx1449_pos, 2
    set_addr $I10, rxcap_1454_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1454_done
  rxcap_1454_fail:
    goto rx1449_fail
  rxcap_1454_done:
  # rx subrule "O" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1449_pos = $P10."pos"()
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "infix:sym<+^>")
    if_null rx1449_debug, debug_1037
    rx1449_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1449_pos)
  debug_1037:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 4
    if_null rx1449_debug, debug_1038
    rx1449_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1038:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1039
    rx1449_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1039:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("322_1300051172.188") :method
.annotate 'line', 4
    $P1451 = self."!PREFIX__!subrule"("O", "+^")
    new $P1452, "ResizablePMCArray"
    push $P1452, $P1451
    .return ($P1452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("323_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1456_tgt
    .local int rx1456_pos
    .local int rx1456_off
    .local int rx1456_eos
    .local int rx1456_rep
    .local pmc rx1456_cur
    .local pmc rx1456_debug
    (rx1456_cur, rx1456_pos, rx1456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1456_cur
    .local pmc match
    .lex "$/", match
    length rx1456_eos, rx1456_tgt
    gt rx1456_pos, rx1456_eos, rx1456_done
    set rx1456_off, 0
    lt rx1456_pos, 2, rx1456_start
    sub rx1456_off, rx1456_pos, 1
    substr rx1456_tgt, rx1456_tgt, rx1456_off
  rx1456_start:
    eq $I10, 1, rx1456_restart
    if_null rx1456_debug, debug_1040
    rx1456_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1040:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1460_done
    goto rxscan1460_scan
  rxscan1460_loop:
    (rx1456_pos) = rx1456_cur."from"()
    inc rx1456_pos
    rx1456_cur."!cursor_from"(rx1456_pos)
    ge rx1456_pos, rx1456_eos, rxscan1460_done
  rxscan1460_scan:
    set_addr $I10, rxscan1460_loop
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  rxscan1460_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1461_fail
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  # rx literal  "~"
    add $I11, rx1456_pos, 1
    gt $I11, rx1456_eos, rx1456_fail
    sub $I11, rx1456_pos, rx1456_off
    ord $I11, rx1456_tgt, $I11
    ne $I11, 126, rx1456_fail
    add rx1456_pos, 1
    set_addr $I10, rxcap_1461_fail
    ($I12, $I11) = rx1456_cur."!mark_peek"($I10)
    rx1456_cur."!cursor_pos"($I11)
    ($P10) = rx1456_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1456_pos, "")
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1461_done
  rxcap_1461_fail:
    goto rx1456_fail
  rxcap_1461_done:
  # rx subrule "O" subtype=capture negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1456_fail
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1456_pos = $P10."pos"()
  # rx pass
    rx1456_cur."!cursor_pass"(rx1456_pos, "infix:sym<~>")
    if_null rx1456_debug, debug_1041
    rx1456_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1456_pos)
  debug_1041:
    .return (rx1456_cur)
  rx1456_restart:
.annotate 'line', 4
    if_null rx1456_debug, debug_1042
    rx1456_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1042:
  rx1456_fail:
    (rx1456_rep, rx1456_pos, $I10, $P10) = rx1456_cur."!mark_fail"(0)
    lt rx1456_pos, -1, rx1456_done
    eq rx1456_pos, -1, rx1456_fail
    jump $I10
  rx1456_done:
    rx1456_cur."!cursor_fail"()
    if_null rx1456_debug, debug_1043
    rx1456_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1043:
    .return (rx1456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("324_1300051172.188") :method
.annotate 'line', 4
    $P1458 = self."!PREFIX__!subrule"("O", "~")
    new $P1459, "ResizablePMCArray"
    push $P1459, $P1458
    .return ($P1459)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("325_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1463_tgt
    .local int rx1463_pos
    .local int rx1463_off
    .local int rx1463_eos
    .local int rx1463_rep
    .local pmc rx1463_cur
    .local pmc rx1463_debug
    (rx1463_cur, rx1463_pos, rx1463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1463_cur
    .local pmc match
    .lex "$/", match
    length rx1463_eos, rx1463_tgt
    gt rx1463_pos, rx1463_eos, rx1463_done
    set rx1463_off, 0
    lt rx1463_pos, 2, rx1463_start
    sub rx1463_off, rx1463_pos, 1
    substr rx1463_tgt, rx1463_tgt, rx1463_off
  rx1463_start:
    eq $I10, 1, rx1463_restart
    if_null rx1463_debug, debug_1044
    rx1463_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1044:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1467_done
    goto rxscan1467_scan
  rxscan1467_loop:
    (rx1463_pos) = rx1463_cur."from"()
    inc rx1463_pos
    rx1463_cur."!cursor_from"(rx1463_pos)
    ge rx1463_pos, rx1463_eos, rxscan1467_done
  rxscan1467_scan:
    set_addr $I10, rxscan1467_loop
    rx1463_cur."!mark_push"(0, rx1463_pos, $I10)
  rxscan1467_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1468_fail
    rx1463_cur."!mark_push"(0, rx1463_pos, $I10)
  # rx literal  "=="
    add $I11, rx1463_pos, 2
    gt $I11, rx1463_eos, rx1463_fail
    sub $I11, rx1463_pos, rx1463_off
    substr $S10, rx1463_tgt, $I11, 2
    ne $S10, "==", rx1463_fail
    add rx1463_pos, 2
    set_addr $I10, rxcap_1468_fail
    ($I12, $I11) = rx1463_cur."!mark_peek"($I10)
    rx1463_cur."!cursor_pos"($I11)
    ($P10) = rx1463_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1463_pos, "")
    rx1463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1468_done
  rxcap_1468_fail:
    goto rx1463_fail
  rxcap_1468_done:
  # rx subrule "O" subtype=capture negate=
    rx1463_cur."!cursor_pos"(rx1463_pos)
    $P10 = rx1463_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1463_fail
    rx1463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1463_pos = $P10."pos"()
  # rx pass
    rx1463_cur."!cursor_pass"(rx1463_pos, "infix:sym<==>")
    if_null rx1463_debug, debug_1045
    rx1463_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1463_pos)
  debug_1045:
    .return (rx1463_cur)
  rx1463_restart:
.annotate 'line', 4
    if_null rx1463_debug, debug_1046
    rx1463_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1046:
  rx1463_fail:
    (rx1463_rep, rx1463_pos, $I10, $P10) = rx1463_cur."!mark_fail"(0)
    lt rx1463_pos, -1, rx1463_done
    eq rx1463_pos, -1, rx1463_fail
    jump $I10
  rx1463_done:
    rx1463_cur."!cursor_fail"()
    if_null rx1463_debug, debug_1047
    rx1463_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1047:
    .return (rx1463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("326_1300051172.188") :method
.annotate 'line', 4
    $P1465 = self."!PREFIX__!subrule"("O", "==")
    new $P1466, "ResizablePMCArray"
    push $P1466, $P1465
    .return ($P1466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("327_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1470_tgt
    .local int rx1470_pos
    .local int rx1470_off
    .local int rx1470_eos
    .local int rx1470_rep
    .local pmc rx1470_cur
    .local pmc rx1470_debug
    (rx1470_cur, rx1470_pos, rx1470_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1470_cur
    .local pmc match
    .lex "$/", match
    length rx1470_eos, rx1470_tgt
    gt rx1470_pos, rx1470_eos, rx1470_done
    set rx1470_off, 0
    lt rx1470_pos, 2, rx1470_start
    sub rx1470_off, rx1470_pos, 1
    substr rx1470_tgt, rx1470_tgt, rx1470_off
  rx1470_start:
    eq $I10, 1, rx1470_restart
    if_null rx1470_debug, debug_1048
    rx1470_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1048:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1474_done
    goto rxscan1474_scan
  rxscan1474_loop:
    (rx1470_pos) = rx1470_cur."from"()
    inc rx1470_pos
    rx1470_cur."!cursor_from"(rx1470_pos)
    ge rx1470_pos, rx1470_eos, rxscan1474_done
  rxscan1474_scan:
    set_addr $I10, rxscan1474_loop
    rx1470_cur."!mark_push"(0, rx1470_pos, $I10)
  rxscan1474_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1475_fail
    rx1470_cur."!mark_push"(0, rx1470_pos, $I10)
  # rx literal  "!="
    add $I11, rx1470_pos, 2
    gt $I11, rx1470_eos, rx1470_fail
    sub $I11, rx1470_pos, rx1470_off
    substr $S10, rx1470_tgt, $I11, 2
    ne $S10, "!=", rx1470_fail
    add rx1470_pos, 2
    set_addr $I10, rxcap_1475_fail
    ($I12, $I11) = rx1470_cur."!mark_peek"($I10)
    rx1470_cur."!cursor_pos"($I11)
    ($P10) = rx1470_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1470_pos, "")
    rx1470_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1475_done
  rxcap_1475_fail:
    goto rx1470_fail
  rxcap_1475_done:
  # rx subrule "O" subtype=capture negate=
    rx1470_cur."!cursor_pos"(rx1470_pos)
    $P10 = rx1470_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1470_fail
    rx1470_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1470_pos = $P10."pos"()
  # rx pass
    rx1470_cur."!cursor_pass"(rx1470_pos, "infix:sym<!=>")
    if_null rx1470_debug, debug_1049
    rx1470_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1470_pos)
  debug_1049:
    .return (rx1470_cur)
  rx1470_restart:
.annotate 'line', 4
    if_null rx1470_debug, debug_1050
    rx1470_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1050:
  rx1470_fail:
    (rx1470_rep, rx1470_pos, $I10, $P10) = rx1470_cur."!mark_fail"(0)
    lt rx1470_pos, -1, rx1470_done
    eq rx1470_pos, -1, rx1470_fail
    jump $I10
  rx1470_done:
    rx1470_cur."!cursor_fail"()
    if_null rx1470_debug, debug_1051
    rx1470_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1051:
    .return (rx1470_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("328_1300051172.188") :method
.annotate 'line', 4
    $P1472 = self."!PREFIX__!subrule"("O", "!=")
    new $P1473, "ResizablePMCArray"
    push $P1473, $P1472
    .return ($P1473)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("329_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1477_tgt
    .local int rx1477_pos
    .local int rx1477_off
    .local int rx1477_eos
    .local int rx1477_rep
    .local pmc rx1477_cur
    .local pmc rx1477_debug
    (rx1477_cur, rx1477_pos, rx1477_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1477_cur
    .local pmc match
    .lex "$/", match
    length rx1477_eos, rx1477_tgt
    gt rx1477_pos, rx1477_eos, rx1477_done
    set rx1477_off, 0
    lt rx1477_pos, 2, rx1477_start
    sub rx1477_off, rx1477_pos, 1
    substr rx1477_tgt, rx1477_tgt, rx1477_off
  rx1477_start:
    eq $I10, 1, rx1477_restart
    if_null rx1477_debug, debug_1052
    rx1477_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1052:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1481_done
    goto rxscan1481_scan
  rxscan1481_loop:
    (rx1477_pos) = rx1477_cur."from"()
    inc rx1477_pos
    rx1477_cur."!cursor_from"(rx1477_pos)
    ge rx1477_pos, rx1477_eos, rxscan1481_done
  rxscan1481_scan:
    set_addr $I10, rxscan1481_loop
    rx1477_cur."!mark_push"(0, rx1477_pos, $I10)
  rxscan1481_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1482_fail
    rx1477_cur."!mark_push"(0, rx1477_pos, $I10)
  # rx literal  "<="
    add $I11, rx1477_pos, 2
    gt $I11, rx1477_eos, rx1477_fail
    sub $I11, rx1477_pos, rx1477_off
    substr $S10, rx1477_tgt, $I11, 2
    ne $S10, "<=", rx1477_fail
    add rx1477_pos, 2
    set_addr $I10, rxcap_1482_fail
    ($I12, $I11) = rx1477_cur."!mark_peek"($I10)
    rx1477_cur."!cursor_pos"($I11)
    ($P10) = rx1477_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1477_pos, "")
    rx1477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1482_done
  rxcap_1482_fail:
    goto rx1477_fail
  rxcap_1482_done:
  # rx subrule "O" subtype=capture negate=
    rx1477_cur."!cursor_pos"(rx1477_pos)
    $P10 = rx1477_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1477_fail
    rx1477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1477_pos = $P10."pos"()
  # rx pass
    rx1477_cur."!cursor_pass"(rx1477_pos, "infix:sym<<=>")
    if_null rx1477_debug, debug_1053
    rx1477_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1477_pos)
  debug_1053:
    .return (rx1477_cur)
  rx1477_restart:
.annotate 'line', 4
    if_null rx1477_debug, debug_1054
    rx1477_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1054:
  rx1477_fail:
    (rx1477_rep, rx1477_pos, $I10, $P10) = rx1477_cur."!mark_fail"(0)
    lt rx1477_pos, -1, rx1477_done
    eq rx1477_pos, -1, rx1477_fail
    jump $I10
  rx1477_done:
    rx1477_cur."!cursor_fail"()
    if_null rx1477_debug, debug_1055
    rx1477_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1055:
    .return (rx1477_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("330_1300051172.188") :method
.annotate 'line', 4
    $P1479 = self."!PREFIX__!subrule"("O", "<=")
    new $P1480, "ResizablePMCArray"
    push $P1480, $P1479
    .return ($P1480)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("331_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1484_tgt
    .local int rx1484_pos
    .local int rx1484_off
    .local int rx1484_eos
    .local int rx1484_rep
    .local pmc rx1484_cur
    .local pmc rx1484_debug
    (rx1484_cur, rx1484_pos, rx1484_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1484_cur
    .local pmc match
    .lex "$/", match
    length rx1484_eos, rx1484_tgt
    gt rx1484_pos, rx1484_eos, rx1484_done
    set rx1484_off, 0
    lt rx1484_pos, 2, rx1484_start
    sub rx1484_off, rx1484_pos, 1
    substr rx1484_tgt, rx1484_tgt, rx1484_off
  rx1484_start:
    eq $I10, 1, rx1484_restart
    if_null rx1484_debug, debug_1056
    rx1484_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1056:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1488_done
    goto rxscan1488_scan
  rxscan1488_loop:
    (rx1484_pos) = rx1484_cur."from"()
    inc rx1484_pos
    rx1484_cur."!cursor_from"(rx1484_pos)
    ge rx1484_pos, rx1484_eos, rxscan1488_done
  rxscan1488_scan:
    set_addr $I10, rxscan1488_loop
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  rxscan1488_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1489_fail
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  # rx literal  ">="
    add $I11, rx1484_pos, 2
    gt $I11, rx1484_eos, rx1484_fail
    sub $I11, rx1484_pos, rx1484_off
    substr $S10, rx1484_tgt, $I11, 2
    ne $S10, ">=", rx1484_fail
    add rx1484_pos, 2
    set_addr $I10, rxcap_1489_fail
    ($I12, $I11) = rx1484_cur."!mark_peek"($I10)
    rx1484_cur."!cursor_pos"($I11)
    ($P10) = rx1484_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1484_pos, "")
    rx1484_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1489_done
  rxcap_1489_fail:
    goto rx1484_fail
  rxcap_1489_done:
  # rx subrule "O" subtype=capture negate=
    rx1484_cur."!cursor_pos"(rx1484_pos)
    $P10 = rx1484_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1484_fail
    rx1484_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1484_pos = $P10."pos"()
  # rx pass
    rx1484_cur."!cursor_pass"(rx1484_pos, "infix:sym<>=>")
    if_null rx1484_debug, debug_1057
    rx1484_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1484_pos)
  debug_1057:
    .return (rx1484_cur)
  rx1484_restart:
.annotate 'line', 4
    if_null rx1484_debug, debug_1058
    rx1484_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1058:
  rx1484_fail:
    (rx1484_rep, rx1484_pos, $I10, $P10) = rx1484_cur."!mark_fail"(0)
    lt rx1484_pos, -1, rx1484_done
    eq rx1484_pos, -1, rx1484_fail
    jump $I10
  rx1484_done:
    rx1484_cur."!cursor_fail"()
    if_null rx1484_debug, debug_1059
    rx1484_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1059:
    .return (rx1484_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("332_1300051172.188") :method
.annotate 'line', 4
    $P1486 = self."!PREFIX__!subrule"("O", ">=")
    new $P1487, "ResizablePMCArray"
    push $P1487, $P1486
    .return ($P1487)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("333_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1491_tgt
    .local int rx1491_pos
    .local int rx1491_off
    .local int rx1491_eos
    .local int rx1491_rep
    .local pmc rx1491_cur
    .local pmc rx1491_debug
    (rx1491_cur, rx1491_pos, rx1491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1491_cur
    .local pmc match
    .lex "$/", match
    length rx1491_eos, rx1491_tgt
    gt rx1491_pos, rx1491_eos, rx1491_done
    set rx1491_off, 0
    lt rx1491_pos, 2, rx1491_start
    sub rx1491_off, rx1491_pos, 1
    substr rx1491_tgt, rx1491_tgt, rx1491_off
  rx1491_start:
    eq $I10, 1, rx1491_restart
    if_null rx1491_debug, debug_1060
    rx1491_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1060:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1495_done
    goto rxscan1495_scan
  rxscan1495_loop:
    (rx1491_pos) = rx1491_cur."from"()
    inc rx1491_pos
    rx1491_cur."!cursor_from"(rx1491_pos)
    ge rx1491_pos, rx1491_eos, rxscan1495_done
  rxscan1495_scan:
    set_addr $I10, rxscan1495_loop
    rx1491_cur."!mark_push"(0, rx1491_pos, $I10)
  rxscan1495_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1496_fail
    rx1491_cur."!mark_push"(0, rx1491_pos, $I10)
  # rx literal  "<"
    add $I11, rx1491_pos, 1
    gt $I11, rx1491_eos, rx1491_fail
    sub $I11, rx1491_pos, rx1491_off
    ord $I11, rx1491_tgt, $I11
    ne $I11, 60, rx1491_fail
    add rx1491_pos, 1
    set_addr $I10, rxcap_1496_fail
    ($I12, $I11) = rx1491_cur."!mark_peek"($I10)
    rx1491_cur."!cursor_pos"($I11)
    ($P10) = rx1491_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1491_pos, "")
    rx1491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1496_done
  rxcap_1496_fail:
    goto rx1491_fail
  rxcap_1496_done:
  # rx subrule "O" subtype=capture negate=
    rx1491_cur."!cursor_pos"(rx1491_pos)
    $P10 = rx1491_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1491_fail
    rx1491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1491_pos = $P10."pos"()
  # rx pass
    rx1491_cur."!cursor_pass"(rx1491_pos, "infix:sym<<>")
    if_null rx1491_debug, debug_1061
    rx1491_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1491_pos)
  debug_1061:
    .return (rx1491_cur)
  rx1491_restart:
.annotate 'line', 4
    if_null rx1491_debug, debug_1062
    rx1491_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1062:
  rx1491_fail:
    (rx1491_rep, rx1491_pos, $I10, $P10) = rx1491_cur."!mark_fail"(0)
    lt rx1491_pos, -1, rx1491_done
    eq rx1491_pos, -1, rx1491_fail
    jump $I10
  rx1491_done:
    rx1491_cur."!cursor_fail"()
    if_null rx1491_debug, debug_1063
    rx1491_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1063:
    .return (rx1491_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("334_1300051172.188") :method
.annotate 'line', 4
    $P1493 = self."!PREFIX__!subrule"("O", "<")
    new $P1494, "ResizablePMCArray"
    push $P1494, $P1493
    .return ($P1494)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("335_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1498_tgt
    .local int rx1498_pos
    .local int rx1498_off
    .local int rx1498_eos
    .local int rx1498_rep
    .local pmc rx1498_cur
    .local pmc rx1498_debug
    (rx1498_cur, rx1498_pos, rx1498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1498_cur
    .local pmc match
    .lex "$/", match
    length rx1498_eos, rx1498_tgt
    gt rx1498_pos, rx1498_eos, rx1498_done
    set rx1498_off, 0
    lt rx1498_pos, 2, rx1498_start
    sub rx1498_off, rx1498_pos, 1
    substr rx1498_tgt, rx1498_tgt, rx1498_off
  rx1498_start:
    eq $I10, 1, rx1498_restart
    if_null rx1498_debug, debug_1064
    rx1498_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1064:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1502_done
    goto rxscan1502_scan
  rxscan1502_loop:
    (rx1498_pos) = rx1498_cur."from"()
    inc rx1498_pos
    rx1498_cur."!cursor_from"(rx1498_pos)
    ge rx1498_pos, rx1498_eos, rxscan1502_done
  rxscan1502_scan:
    set_addr $I10, rxscan1502_loop
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  rxscan1502_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1503_fail
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  # rx literal  ">"
    add $I11, rx1498_pos, 1
    gt $I11, rx1498_eos, rx1498_fail
    sub $I11, rx1498_pos, rx1498_off
    ord $I11, rx1498_tgt, $I11
    ne $I11, 62, rx1498_fail
    add rx1498_pos, 1
    set_addr $I10, rxcap_1503_fail
    ($I12, $I11) = rx1498_cur."!mark_peek"($I10)
    rx1498_cur."!cursor_pos"($I11)
    ($P10) = rx1498_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1498_pos, "")
    rx1498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1503_done
  rxcap_1503_fail:
    goto rx1498_fail
  rxcap_1503_done:
  # rx subrule "O" subtype=capture negate=
    rx1498_cur."!cursor_pos"(rx1498_pos)
    $P10 = rx1498_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1498_fail
    rx1498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1498_pos = $P10."pos"()
  # rx pass
    rx1498_cur."!cursor_pass"(rx1498_pos, "infix:sym<>>")
    if_null rx1498_debug, debug_1065
    rx1498_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1498_pos)
  debug_1065:
    .return (rx1498_cur)
  rx1498_restart:
.annotate 'line', 4
    if_null rx1498_debug, debug_1066
    rx1498_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1066:
  rx1498_fail:
    (rx1498_rep, rx1498_pos, $I10, $P10) = rx1498_cur."!mark_fail"(0)
    lt rx1498_pos, -1, rx1498_done
    eq rx1498_pos, -1, rx1498_fail
    jump $I10
  rx1498_done:
    rx1498_cur."!cursor_fail"()
    if_null rx1498_debug, debug_1067
    rx1498_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1067:
    .return (rx1498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("336_1300051172.188") :method
.annotate 'line', 4
    $P1500 = self."!PREFIX__!subrule"("O", ">")
    new $P1501, "ResizablePMCArray"
    push $P1501, $P1500
    .return ($P1501)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("337_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1505_tgt
    .local int rx1505_pos
    .local int rx1505_off
    .local int rx1505_eos
    .local int rx1505_rep
    .local pmc rx1505_cur
    .local pmc rx1505_debug
    (rx1505_cur, rx1505_pos, rx1505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1505_cur
    .local pmc match
    .lex "$/", match
    length rx1505_eos, rx1505_tgt
    gt rx1505_pos, rx1505_eos, rx1505_done
    set rx1505_off, 0
    lt rx1505_pos, 2, rx1505_start
    sub rx1505_off, rx1505_pos, 1
    substr rx1505_tgt, rx1505_tgt, rx1505_off
  rx1505_start:
    eq $I10, 1, rx1505_restart
    if_null rx1505_debug, debug_1068
    rx1505_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1068:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1509_done
    goto rxscan1509_scan
  rxscan1509_loop:
    (rx1505_pos) = rx1505_cur."from"()
    inc rx1505_pos
    rx1505_cur."!cursor_from"(rx1505_pos)
    ge rx1505_pos, rx1505_eos, rxscan1509_done
  rxscan1509_scan:
    set_addr $I10, rxscan1509_loop
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  rxscan1509_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1510_fail
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1505_pos, 2
    gt $I11, rx1505_eos, rx1505_fail
    sub $I11, rx1505_pos, rx1505_off
    substr $S10, rx1505_tgt, $I11, 2
    ne $S10, "eq", rx1505_fail
    add rx1505_pos, 2
    set_addr $I10, rxcap_1510_fail
    ($I12, $I11) = rx1505_cur."!mark_peek"($I10)
    rx1505_cur."!cursor_pos"($I11)
    ($P10) = rx1505_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1505_pos, "")
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1510_done
  rxcap_1510_fail:
    goto rx1505_fail
  rxcap_1510_done:
  # rx subrule "O" subtype=capture negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    $P10 = rx1505_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1505_fail
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1505_pos = $P10."pos"()
  # rx pass
    rx1505_cur."!cursor_pass"(rx1505_pos, "infix:sym<eq>")
    if_null rx1505_debug, debug_1069
    rx1505_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1505_pos)
  debug_1069:
    .return (rx1505_cur)
  rx1505_restart:
.annotate 'line', 4
    if_null rx1505_debug, debug_1070
    rx1505_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1070:
  rx1505_fail:
    (rx1505_rep, rx1505_pos, $I10, $P10) = rx1505_cur."!mark_fail"(0)
    lt rx1505_pos, -1, rx1505_done
    eq rx1505_pos, -1, rx1505_fail
    jump $I10
  rx1505_done:
    rx1505_cur."!cursor_fail"()
    if_null rx1505_debug, debug_1071
    rx1505_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1071:
    .return (rx1505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("338_1300051172.188") :method
.annotate 'line', 4
    $P1507 = self."!PREFIX__!subrule"("O", "eq")
    new $P1508, "ResizablePMCArray"
    push $P1508, $P1507
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("339_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1512_tgt
    .local int rx1512_pos
    .local int rx1512_off
    .local int rx1512_eos
    .local int rx1512_rep
    .local pmc rx1512_cur
    .local pmc rx1512_debug
    (rx1512_cur, rx1512_pos, rx1512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1512_cur
    .local pmc match
    .lex "$/", match
    length rx1512_eos, rx1512_tgt
    gt rx1512_pos, rx1512_eos, rx1512_done
    set rx1512_off, 0
    lt rx1512_pos, 2, rx1512_start
    sub rx1512_off, rx1512_pos, 1
    substr rx1512_tgt, rx1512_tgt, rx1512_off
  rx1512_start:
    eq $I10, 1, rx1512_restart
    if_null rx1512_debug, debug_1072
    rx1512_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1072:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1516_done
    goto rxscan1516_scan
  rxscan1516_loop:
    (rx1512_pos) = rx1512_cur."from"()
    inc rx1512_pos
    rx1512_cur."!cursor_from"(rx1512_pos)
    ge rx1512_pos, rx1512_eos, rxscan1516_done
  rxscan1516_scan:
    set_addr $I10, rxscan1516_loop
    rx1512_cur."!mark_push"(0, rx1512_pos, $I10)
  rxscan1516_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1517_fail
    rx1512_cur."!mark_push"(0, rx1512_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1512_pos, 2
    gt $I11, rx1512_eos, rx1512_fail
    sub $I11, rx1512_pos, rx1512_off
    substr $S10, rx1512_tgt, $I11, 2
    ne $S10, "ne", rx1512_fail
    add rx1512_pos, 2
    set_addr $I10, rxcap_1517_fail
    ($I12, $I11) = rx1512_cur."!mark_peek"($I10)
    rx1512_cur."!cursor_pos"($I11)
    ($P10) = rx1512_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1512_pos, "")
    rx1512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1517_done
  rxcap_1517_fail:
    goto rx1512_fail
  rxcap_1517_done:
  # rx subrule "O" subtype=capture negate=
    rx1512_cur."!cursor_pos"(rx1512_pos)
    $P10 = rx1512_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1512_fail
    rx1512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1512_pos = $P10."pos"()
  # rx pass
    rx1512_cur."!cursor_pass"(rx1512_pos, "infix:sym<ne>")
    if_null rx1512_debug, debug_1073
    rx1512_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1512_pos)
  debug_1073:
    .return (rx1512_cur)
  rx1512_restart:
.annotate 'line', 4
    if_null rx1512_debug, debug_1074
    rx1512_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1074:
  rx1512_fail:
    (rx1512_rep, rx1512_pos, $I10, $P10) = rx1512_cur."!mark_fail"(0)
    lt rx1512_pos, -1, rx1512_done
    eq rx1512_pos, -1, rx1512_fail
    jump $I10
  rx1512_done:
    rx1512_cur."!cursor_fail"()
    if_null rx1512_debug, debug_1075
    rx1512_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1075:
    .return (rx1512_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("340_1300051172.188") :method
.annotate 'line', 4
    $P1514 = self."!PREFIX__!subrule"("O", "ne")
    new $P1515, "ResizablePMCArray"
    push $P1515, $P1514
    .return ($P1515)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("341_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1076
    rx1519_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1076:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1523_done
    goto rxscan1523_scan
  rxscan1523_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1523_done
  rxscan1523_scan:
    set_addr $I10, rxscan1523_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1523_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1524_fail
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  # rx literal  "le"
    add $I11, rx1519_pos, 2
    gt $I11, rx1519_eos, rx1519_fail
    sub $I11, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I11, 2
    ne $S10, "le", rx1519_fail
    add rx1519_pos, 2
    set_addr $I10, rxcap_1524_fail
    ($I12, $I11) = rx1519_cur."!mark_peek"($I10)
    rx1519_cur."!cursor_pos"($I11)
    ($P10) = rx1519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1519_pos, "")
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1524_done
  rxcap_1524_fail:
    goto rx1519_fail
  rxcap_1524_done:
  # rx subrule "O" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "infix:sym<le>")
    if_null rx1519_debug, debug_1077
    rx1519_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1519_pos)
  debug_1077:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 4
    if_null rx1519_debug, debug_1078
    rx1519_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1078:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1079
    rx1519_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1079:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("342_1300051172.188") :method
.annotate 'line', 4
    $P1521 = self."!PREFIX__!subrule"("O", "le")
    new $P1522, "ResizablePMCArray"
    push $P1522, $P1521
    .return ($P1522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("343_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1526_tgt
    .local int rx1526_pos
    .local int rx1526_off
    .local int rx1526_eos
    .local int rx1526_rep
    .local pmc rx1526_cur
    .local pmc rx1526_debug
    (rx1526_cur, rx1526_pos, rx1526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1526_cur
    .local pmc match
    .lex "$/", match
    length rx1526_eos, rx1526_tgt
    gt rx1526_pos, rx1526_eos, rx1526_done
    set rx1526_off, 0
    lt rx1526_pos, 2, rx1526_start
    sub rx1526_off, rx1526_pos, 1
    substr rx1526_tgt, rx1526_tgt, rx1526_off
  rx1526_start:
    eq $I10, 1, rx1526_restart
    if_null rx1526_debug, debug_1080
    rx1526_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1080:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1530_done
    goto rxscan1530_scan
  rxscan1530_loop:
    (rx1526_pos) = rx1526_cur."from"()
    inc rx1526_pos
    rx1526_cur."!cursor_from"(rx1526_pos)
    ge rx1526_pos, rx1526_eos, rxscan1530_done
  rxscan1530_scan:
    set_addr $I10, rxscan1530_loop
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  rxscan1530_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1531_fail
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1526_pos, 2
    gt $I11, rx1526_eos, rx1526_fail
    sub $I11, rx1526_pos, rx1526_off
    substr $S10, rx1526_tgt, $I11, 2
    ne $S10, "ge", rx1526_fail
    add rx1526_pos, 2
    set_addr $I10, rxcap_1531_fail
    ($I12, $I11) = rx1526_cur."!mark_peek"($I10)
    rx1526_cur."!cursor_pos"($I11)
    ($P10) = rx1526_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1526_pos, "")
    rx1526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1531_done
  rxcap_1531_fail:
    goto rx1526_fail
  rxcap_1531_done:
  # rx subrule "O" subtype=capture negate=
    rx1526_cur."!cursor_pos"(rx1526_pos)
    $P10 = rx1526_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1526_fail
    rx1526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1526_pos = $P10."pos"()
  # rx pass
    rx1526_cur."!cursor_pass"(rx1526_pos, "infix:sym<ge>")
    if_null rx1526_debug, debug_1081
    rx1526_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1526_pos)
  debug_1081:
    .return (rx1526_cur)
  rx1526_restart:
.annotate 'line', 4
    if_null rx1526_debug, debug_1082
    rx1526_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1082:
  rx1526_fail:
    (rx1526_rep, rx1526_pos, $I10, $P10) = rx1526_cur."!mark_fail"(0)
    lt rx1526_pos, -1, rx1526_done
    eq rx1526_pos, -1, rx1526_fail
    jump $I10
  rx1526_done:
    rx1526_cur."!cursor_fail"()
    if_null rx1526_debug, debug_1083
    rx1526_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1083:
    .return (rx1526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("344_1300051172.188") :method
.annotate 'line', 4
    $P1528 = self."!PREFIX__!subrule"("O", "ge")
    new $P1529, "ResizablePMCArray"
    push $P1529, $P1528
    .return ($P1529)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("345_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1533_tgt
    .local int rx1533_pos
    .local int rx1533_off
    .local int rx1533_eos
    .local int rx1533_rep
    .local pmc rx1533_cur
    .local pmc rx1533_debug
    (rx1533_cur, rx1533_pos, rx1533_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1533_cur
    .local pmc match
    .lex "$/", match
    length rx1533_eos, rx1533_tgt
    gt rx1533_pos, rx1533_eos, rx1533_done
    set rx1533_off, 0
    lt rx1533_pos, 2, rx1533_start
    sub rx1533_off, rx1533_pos, 1
    substr rx1533_tgt, rx1533_tgt, rx1533_off
  rx1533_start:
    eq $I10, 1, rx1533_restart
    if_null rx1533_debug, debug_1084
    rx1533_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1084:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1537_done
    goto rxscan1537_scan
  rxscan1537_loop:
    (rx1533_pos) = rx1533_cur."from"()
    inc rx1533_pos
    rx1533_cur."!cursor_from"(rx1533_pos)
    ge rx1533_pos, rx1533_eos, rxscan1537_done
  rxscan1537_scan:
    set_addr $I10, rxscan1537_loop
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxscan1537_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1538_fail
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1533_pos, 2
    gt $I11, rx1533_eos, rx1533_fail
    sub $I11, rx1533_pos, rx1533_off
    substr $S10, rx1533_tgt, $I11, 2
    ne $S10, "lt", rx1533_fail
    add rx1533_pos, 2
    set_addr $I10, rxcap_1538_fail
    ($I12, $I11) = rx1533_cur."!mark_peek"($I10)
    rx1533_cur."!cursor_pos"($I11)
    ($P10) = rx1533_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1533_pos, "")
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1538_done
  rxcap_1538_fail:
    goto rx1533_fail
  rxcap_1538_done:
  # rx subrule "O" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1533_fail
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1533_pos = $P10."pos"()
  # rx pass
    rx1533_cur."!cursor_pass"(rx1533_pos, "infix:sym<lt>")
    if_null rx1533_debug, debug_1085
    rx1533_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1533_pos)
  debug_1085:
    .return (rx1533_cur)
  rx1533_restart:
.annotate 'line', 4
    if_null rx1533_debug, debug_1086
    rx1533_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1086:
  rx1533_fail:
    (rx1533_rep, rx1533_pos, $I10, $P10) = rx1533_cur."!mark_fail"(0)
    lt rx1533_pos, -1, rx1533_done
    eq rx1533_pos, -1, rx1533_fail
    jump $I10
  rx1533_done:
    rx1533_cur."!cursor_fail"()
    if_null rx1533_debug, debug_1087
    rx1533_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1087:
    .return (rx1533_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("346_1300051172.188") :method
.annotate 'line', 4
    $P1535 = self."!PREFIX__!subrule"("O", "lt")
    new $P1536, "ResizablePMCArray"
    push $P1536, $P1535
    .return ($P1536)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("347_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1540_tgt
    .local int rx1540_pos
    .local int rx1540_off
    .local int rx1540_eos
    .local int rx1540_rep
    .local pmc rx1540_cur
    .local pmc rx1540_debug
    (rx1540_cur, rx1540_pos, rx1540_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1540_cur
    .local pmc match
    .lex "$/", match
    length rx1540_eos, rx1540_tgt
    gt rx1540_pos, rx1540_eos, rx1540_done
    set rx1540_off, 0
    lt rx1540_pos, 2, rx1540_start
    sub rx1540_off, rx1540_pos, 1
    substr rx1540_tgt, rx1540_tgt, rx1540_off
  rx1540_start:
    eq $I10, 1, rx1540_restart
    if_null rx1540_debug, debug_1088
    rx1540_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1088:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1540_pos) = rx1540_cur."from"()
    inc rx1540_pos
    rx1540_cur."!cursor_from"(rx1540_pos)
    ge rx1540_pos, rx1540_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  rxscan1544_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1545_fail
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1540_pos, 2
    gt $I11, rx1540_eos, rx1540_fail
    sub $I11, rx1540_pos, rx1540_off
    substr $S10, rx1540_tgt, $I11, 2
    ne $S10, "gt", rx1540_fail
    add rx1540_pos, 2
    set_addr $I10, rxcap_1545_fail
    ($I12, $I11) = rx1540_cur."!mark_peek"($I10)
    rx1540_cur."!cursor_pos"($I11)
    ($P10) = rx1540_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1540_pos, "")
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1545_done
  rxcap_1545_fail:
    goto rx1540_fail
  rxcap_1545_done:
  # rx subrule "O" subtype=capture negate=
    rx1540_cur."!cursor_pos"(rx1540_pos)
    $P10 = rx1540_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1540_fail
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1540_pos = $P10."pos"()
  # rx pass
    rx1540_cur."!cursor_pass"(rx1540_pos, "infix:sym<gt>")
    if_null rx1540_debug, debug_1089
    rx1540_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1540_pos)
  debug_1089:
    .return (rx1540_cur)
  rx1540_restart:
.annotate 'line', 4
    if_null rx1540_debug, debug_1090
    rx1540_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1090:
  rx1540_fail:
    (rx1540_rep, rx1540_pos, $I10, $P10) = rx1540_cur."!mark_fail"(0)
    lt rx1540_pos, -1, rx1540_done
    eq rx1540_pos, -1, rx1540_fail
    jump $I10
  rx1540_done:
    rx1540_cur."!cursor_fail"()
    if_null rx1540_debug, debug_1091
    rx1540_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1091:
    .return (rx1540_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("348_1300051172.188") :method
.annotate 'line', 4
    $P1542 = self."!PREFIX__!subrule"("O", "gt")
    new $P1543, "ResizablePMCArray"
    push $P1543, $P1542
    .return ($P1543)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("349_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1547_tgt
    .local int rx1547_pos
    .local int rx1547_off
    .local int rx1547_eos
    .local int rx1547_rep
    .local pmc rx1547_cur
    .local pmc rx1547_debug
    (rx1547_cur, rx1547_pos, rx1547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1547_cur
    .local pmc match
    .lex "$/", match
    length rx1547_eos, rx1547_tgt
    gt rx1547_pos, rx1547_eos, rx1547_done
    set rx1547_off, 0
    lt rx1547_pos, 2, rx1547_start
    sub rx1547_off, rx1547_pos, 1
    substr rx1547_tgt, rx1547_tgt, rx1547_off
  rx1547_start:
    eq $I10, 1, rx1547_restart
    if_null rx1547_debug, debug_1092
    rx1547_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1092:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1551_done
    goto rxscan1551_scan
  rxscan1551_loop:
    (rx1547_pos) = rx1547_cur."from"()
    inc rx1547_pos
    rx1547_cur."!cursor_from"(rx1547_pos)
    ge rx1547_pos, rx1547_eos, rxscan1551_done
  rxscan1551_scan:
    set_addr $I10, rxscan1551_loop
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  rxscan1551_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1552_fail
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1547_pos, 3
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 3
    ne $S10, "=:=", rx1547_fail
    add rx1547_pos, 3
    set_addr $I10, rxcap_1552_fail
    ($I12, $I11) = rx1547_cur."!mark_peek"($I10)
    rx1547_cur."!cursor_pos"($I11)
    ($P10) = rx1547_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1547_pos, "")
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1552_done
  rxcap_1552_fail:
    goto rx1547_fail
  rxcap_1552_done:
  # rx subrule "O" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1547_pos = $P10."pos"()
  # rx pass
    rx1547_cur."!cursor_pass"(rx1547_pos, "infix:sym<=:=>")
    if_null rx1547_debug, debug_1093
    rx1547_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1547_pos)
  debug_1093:
    .return (rx1547_cur)
  rx1547_restart:
.annotate 'line', 4
    if_null rx1547_debug, debug_1094
    rx1547_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1094:
  rx1547_fail:
    (rx1547_rep, rx1547_pos, $I10, $P10) = rx1547_cur."!mark_fail"(0)
    lt rx1547_pos, -1, rx1547_done
    eq rx1547_pos, -1, rx1547_fail
    jump $I10
  rx1547_done:
    rx1547_cur."!cursor_fail"()
    if_null rx1547_debug, debug_1095
    rx1547_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1095:
    .return (rx1547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("350_1300051172.188") :method
.annotate 'line', 4
    $P1549 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1550, "ResizablePMCArray"
    push $P1550, $P1549
    .return ($P1550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("351_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1554_tgt
    .local int rx1554_pos
    .local int rx1554_off
    .local int rx1554_eos
    .local int rx1554_rep
    .local pmc rx1554_cur
    .local pmc rx1554_debug
    (rx1554_cur, rx1554_pos, rx1554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1554_cur
    .local pmc match
    .lex "$/", match
    length rx1554_eos, rx1554_tgt
    gt rx1554_pos, rx1554_eos, rx1554_done
    set rx1554_off, 0
    lt rx1554_pos, 2, rx1554_start
    sub rx1554_off, rx1554_pos, 1
    substr rx1554_tgt, rx1554_tgt, rx1554_off
  rx1554_start:
    eq $I10, 1, rx1554_restart
    if_null rx1554_debug, debug_1096
    rx1554_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1096:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1558_done
    goto rxscan1558_scan
  rxscan1558_loop:
    (rx1554_pos) = rx1554_cur."from"()
    inc rx1554_pos
    rx1554_cur."!cursor_from"(rx1554_pos)
    ge rx1554_pos, rx1554_eos, rxscan1558_done
  rxscan1558_scan:
    set_addr $I10, rxscan1558_loop
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  rxscan1558_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1559_fail
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1554_pos, 2
    gt $I11, rx1554_eos, rx1554_fail
    sub $I11, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I11, 2
    ne $S10, "~~", rx1554_fail
    add rx1554_pos, 2
    set_addr $I10, rxcap_1559_fail
    ($I12, $I11) = rx1554_cur."!mark_peek"($I10)
    rx1554_cur."!cursor_pos"($I11)
    ($P10) = rx1554_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1554_pos, "")
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1559_done
  rxcap_1559_fail:
    goto rx1554_fail
  rxcap_1559_done:
  # rx subrule "O" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1554_pos = $P10."pos"()
  # rx pass
    rx1554_cur."!cursor_pass"(rx1554_pos, "infix:sym<~~>")
    if_null rx1554_debug, debug_1097
    rx1554_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1554_pos)
  debug_1097:
    .return (rx1554_cur)
  rx1554_restart:
.annotate 'line', 4
    if_null rx1554_debug, debug_1098
    rx1554_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1098:
  rx1554_fail:
    (rx1554_rep, rx1554_pos, $I10, $P10) = rx1554_cur."!mark_fail"(0)
    lt rx1554_pos, -1, rx1554_done
    eq rx1554_pos, -1, rx1554_fail
    jump $I10
  rx1554_done:
    rx1554_cur."!cursor_fail"()
    if_null rx1554_debug, debug_1099
    rx1554_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1099:
    .return (rx1554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("352_1300051172.188") :method
.annotate 'line', 4
    $P1556 = self."!PREFIX__!subrule"("O", "~~")
    new $P1557, "ResizablePMCArray"
    push $P1557, $P1556
    .return ($P1557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("353_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1100
    rx1561_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1100:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1565_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1566_fail
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1561_pos, 2
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    substr $S10, rx1561_tgt, $I11, 2
    ne $S10, "&&", rx1561_fail
    add rx1561_pos, 2
    set_addr $I10, rxcap_1566_fail
    ($I12, $I11) = rx1561_cur."!mark_peek"($I10)
    rx1561_cur."!cursor_pos"($I11)
    ($P10) = rx1561_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1561_pos, "")
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1566_done
  rxcap_1566_fail:
    goto rx1561_fail
  rxcap_1566_done:
  # rx subrule "O" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1561_pos = $P10."pos"()
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "infix:sym<&&>")
    if_null rx1561_debug, debug_1101
    rx1561_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1561_pos)
  debug_1101:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 4
    if_null rx1561_debug, debug_1102
    rx1561_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1102:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1103
    rx1561_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1103:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("354_1300051172.188") :method
.annotate 'line', 4
    $P1563 = self."!PREFIX__!subrule"("O", "&&")
    new $P1564, "ResizablePMCArray"
    push $P1564, $P1563
    .return ($P1564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("355_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1568_tgt
    .local int rx1568_pos
    .local int rx1568_off
    .local int rx1568_eos
    .local int rx1568_rep
    .local pmc rx1568_cur
    .local pmc rx1568_debug
    (rx1568_cur, rx1568_pos, rx1568_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1568_cur
    .local pmc match
    .lex "$/", match
    length rx1568_eos, rx1568_tgt
    gt rx1568_pos, rx1568_eos, rx1568_done
    set rx1568_off, 0
    lt rx1568_pos, 2, rx1568_start
    sub rx1568_off, rx1568_pos, 1
    substr rx1568_tgt, rx1568_tgt, rx1568_off
  rx1568_start:
    eq $I10, 1, rx1568_restart
    if_null rx1568_debug, debug_1104
    rx1568_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1572_done
    goto rxscan1572_scan
  rxscan1572_loop:
    (rx1568_pos) = rx1568_cur."from"()
    inc rx1568_pos
    rx1568_cur."!cursor_from"(rx1568_pos)
    ge rx1568_pos, rx1568_eos, rxscan1572_done
  rxscan1572_scan:
    set_addr $I10, rxscan1572_loop
    rx1568_cur."!mark_push"(0, rx1568_pos, $I10)
  rxscan1572_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1573_fail
    rx1568_cur."!mark_push"(0, rx1568_pos, $I10)
  # rx literal  "||"
    add $I11, rx1568_pos, 2
    gt $I11, rx1568_eos, rx1568_fail
    sub $I11, rx1568_pos, rx1568_off
    substr $S10, rx1568_tgt, $I11, 2
    ne $S10, "||", rx1568_fail
    add rx1568_pos, 2
    set_addr $I10, rxcap_1573_fail
    ($I12, $I11) = rx1568_cur."!mark_peek"($I10)
    rx1568_cur."!cursor_pos"($I11)
    ($P10) = rx1568_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1568_pos, "")
    rx1568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1573_done
  rxcap_1573_fail:
    goto rx1568_fail
  rxcap_1573_done:
  # rx subrule "O" subtype=capture negate=
    rx1568_cur."!cursor_pos"(rx1568_pos)
    $P10 = rx1568_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1568_fail
    rx1568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1568_pos = $P10."pos"()
  # rx pass
    rx1568_cur."!cursor_pass"(rx1568_pos, "infix:sym<||>")
    if_null rx1568_debug, debug_1105
    rx1568_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1568_pos)
  debug_1105:
    .return (rx1568_cur)
  rx1568_restart:
.annotate 'line', 4
    if_null rx1568_debug, debug_1106
    rx1568_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1106:
  rx1568_fail:
    (rx1568_rep, rx1568_pos, $I10, $P10) = rx1568_cur."!mark_fail"(0)
    lt rx1568_pos, -1, rx1568_done
    eq rx1568_pos, -1, rx1568_fail
    jump $I10
  rx1568_done:
    rx1568_cur."!cursor_fail"()
    if_null rx1568_debug, debug_1107
    rx1568_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1107:
    .return (rx1568_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("356_1300051172.188") :method
.annotate 'line', 4
    $P1570 = self."!PREFIX__!subrule"("O", "||")
    new $P1571, "ResizablePMCArray"
    push $P1571, $P1570
    .return ($P1571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("357_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1575_tgt
    .local int rx1575_pos
    .local int rx1575_off
    .local int rx1575_eos
    .local int rx1575_rep
    .local pmc rx1575_cur
    .local pmc rx1575_debug
    (rx1575_cur, rx1575_pos, rx1575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1575_cur
    .local pmc match
    .lex "$/", match
    length rx1575_eos, rx1575_tgt
    gt rx1575_pos, rx1575_eos, rx1575_done
    set rx1575_off, 0
    lt rx1575_pos, 2, rx1575_start
    sub rx1575_off, rx1575_pos, 1
    substr rx1575_tgt, rx1575_tgt, rx1575_off
  rx1575_start:
    eq $I10, 1, rx1575_restart
    if_null rx1575_debug, debug_1108
    rx1575_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1108:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1579_done
    goto rxscan1579_scan
  rxscan1579_loop:
    (rx1575_pos) = rx1575_cur."from"()
    inc rx1575_pos
    rx1575_cur."!cursor_from"(rx1575_pos)
    ge rx1575_pos, rx1575_eos, rxscan1579_done
  rxscan1579_scan:
    set_addr $I10, rxscan1579_loop
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  rxscan1579_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1580_fail
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  # rx literal  "//"
    add $I11, rx1575_pos, 2
    gt $I11, rx1575_eos, rx1575_fail
    sub $I11, rx1575_pos, rx1575_off
    substr $S10, rx1575_tgt, $I11, 2
    ne $S10, "//", rx1575_fail
    add rx1575_pos, 2
    set_addr $I10, rxcap_1580_fail
    ($I12, $I11) = rx1575_cur."!mark_peek"($I10)
    rx1575_cur."!cursor_pos"($I11)
    ($P10) = rx1575_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1575_pos, "")
    rx1575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1580_done
  rxcap_1580_fail:
    goto rx1575_fail
  rxcap_1580_done:
  # rx subrule "O" subtype=capture negate=
    rx1575_cur."!cursor_pos"(rx1575_pos)
    $P10 = rx1575_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1575_fail
    rx1575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1575_pos = $P10."pos"()
  # rx pass
    rx1575_cur."!cursor_pass"(rx1575_pos, "infix:sym<//>")
    if_null rx1575_debug, debug_1109
    rx1575_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1575_pos)
  debug_1109:
    .return (rx1575_cur)
  rx1575_restart:
.annotate 'line', 4
    if_null rx1575_debug, debug_1110
    rx1575_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1110:
  rx1575_fail:
    (rx1575_rep, rx1575_pos, $I10, $P10) = rx1575_cur."!mark_fail"(0)
    lt rx1575_pos, -1, rx1575_done
    eq rx1575_pos, -1, rx1575_fail
    jump $I10
  rx1575_done:
    rx1575_cur."!cursor_fail"()
    if_null rx1575_debug, debug_1111
    rx1575_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1111:
    .return (rx1575_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("358_1300051172.188") :method
.annotate 'line', 4
    $P1577 = self."!PREFIX__!subrule"("O", "//")
    new $P1578, "ResizablePMCArray"
    push $P1578, $P1577
    .return ($P1578)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("359_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1582_tgt
    .local int rx1582_pos
    .local int rx1582_off
    .local int rx1582_eos
    .local int rx1582_rep
    .local pmc rx1582_cur
    .local pmc rx1582_debug
    (rx1582_cur, rx1582_pos, rx1582_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1582_cur
    .local pmc match
    .lex "$/", match
    length rx1582_eos, rx1582_tgt
    gt rx1582_pos, rx1582_eos, rx1582_done
    set rx1582_off, 0
    lt rx1582_pos, 2, rx1582_start
    sub rx1582_off, rx1582_pos, 1
    substr rx1582_tgt, rx1582_tgt, rx1582_off
  rx1582_start:
    eq $I10, 1, rx1582_restart
    if_null rx1582_debug, debug_1112
    rx1582_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1582_pos) = rx1582_cur."from"()
    inc rx1582_pos
    rx1582_cur."!cursor_from"(rx1582_pos)
    ge rx1582_pos, rx1582_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  rxscan1586_done:
.annotate 'line', 664
  # rx literal  "??"
    add $I11, rx1582_pos, 2
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 2
    ne $S10, "??", rx1582_fail
    add rx1582_pos, 2
.annotate 'line', 665
  # rx subrule "ws" subtype=method negate=
    rx1582_cur."!cursor_pos"(rx1582_pos)
    $P10 = rx1582_cur."ws"()
    unless $P10, rx1582_fail
    rx1582_pos = $P10."pos"()
.annotate 'line', 666
  # rx subrule "EXPR" subtype=capture negate=
    rx1582_cur."!cursor_pos"(rx1582_pos)
    $P10 = rx1582_cur."EXPR"("i=")
    unless $P10, rx1582_fail
    rx1582_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1582_pos = $P10."pos"()
.annotate 'line', 667
  # rx literal  "!!"
    add $I11, rx1582_pos, 2
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 2
    ne $S10, "!!", rx1582_fail
    add rx1582_pos, 2
.annotate 'line', 668
  # rx subrule "O" subtype=capture negate=
    rx1582_cur."!cursor_pos"(rx1582_pos)
    $P10 = rx1582_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1582_fail
    rx1582_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1582_pos = $P10."pos"()
.annotate 'line', 663
  # rx pass
    rx1582_cur."!cursor_pass"(rx1582_pos, "infix:sym<?? !!>")
    if_null rx1582_debug, debug_1113
    rx1582_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1582_pos)
  debug_1113:
    .return (rx1582_cur)
  rx1582_restart:
.annotate 'line', 4
    if_null rx1582_debug, debug_1114
    rx1582_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1114:
  rx1582_fail:
    (rx1582_rep, rx1582_pos, $I10, $P10) = rx1582_cur."!mark_fail"(0)
    lt rx1582_pos, -1, rx1582_done
    eq rx1582_pos, -1, rx1582_fail
    jump $I10
  rx1582_done:
    rx1582_cur."!cursor_fail"()
    if_null rx1582_debug, debug_1115
    rx1582_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1115:
    .return (rx1582_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("360_1300051172.188") :method
.annotate 'line', 4
    $P1584 = self."!PREFIX__!subrule"("ws", "??")
    new $P1585, "ResizablePMCArray"
    push $P1585, $P1584
    .return ($P1585)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("361_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1588_tgt
    .local int rx1588_pos
    .local int rx1588_off
    .local int rx1588_eos
    .local int rx1588_rep
    .local pmc rx1588_cur
    .local pmc rx1588_debug
    (rx1588_cur, rx1588_pos, rx1588_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1588_cur
    .local pmc match
    .lex "$/", match
    length rx1588_eos, rx1588_tgt
    gt rx1588_pos, rx1588_eos, rx1588_done
    set rx1588_off, 0
    lt rx1588_pos, 2, rx1588_start
    sub rx1588_off, rx1588_pos, 1
    substr rx1588_tgt, rx1588_tgt, rx1588_off
  rx1588_start:
    eq $I10, 1, rx1588_restart
    if_null rx1588_debug, debug_1116
    rx1588_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1116:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    (rx1588_pos) = rx1588_cur."from"()
    inc rx1588_pos
    rx1588_cur."!cursor_from"(rx1588_pos)
    ge rx1588_pos, rx1588_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1588_cur."!mark_push"(0, rx1588_pos, $I10)
  rxscan1592_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1593_fail
    rx1588_cur."!mark_push"(0, rx1588_pos, $I10)
  # rx literal  "="
    add $I11, rx1588_pos, 1
    gt $I11, rx1588_eos, rx1588_fail
    sub $I11, rx1588_pos, rx1588_off
    ord $I11, rx1588_tgt, $I11
    ne $I11, 61, rx1588_fail
    add rx1588_pos, 1
    set_addr $I10, rxcap_1593_fail
    ($I12, $I11) = rx1588_cur."!mark_peek"($I10)
    rx1588_cur."!cursor_pos"($I11)
    ($P10) = rx1588_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1588_pos, "")
    rx1588_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1593_done
  rxcap_1593_fail:
    goto rx1588_fail
  rxcap_1593_done:
  # rx subrule "panic" subtype=method negate=
    rx1588_cur."!cursor_pos"(rx1588_pos)
    $P10 = rx1588_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1588_fail
    rx1588_pos = $P10."pos"()
.annotate 'line', 671
  # rx pass
    rx1588_cur."!cursor_pass"(rx1588_pos, "infix:sym<=>")
    if_null rx1588_debug, debug_1117
    rx1588_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1588_pos)
  debug_1117:
    .return (rx1588_cur)
  rx1588_restart:
.annotate 'line', 4
    if_null rx1588_debug, debug_1118
    rx1588_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1118:
  rx1588_fail:
    (rx1588_rep, rx1588_pos, $I10, $P10) = rx1588_cur."!mark_fail"(0)
    lt rx1588_pos, -1, rx1588_done
    eq rx1588_pos, -1, rx1588_fail
    jump $I10
  rx1588_done:
    rx1588_cur."!cursor_fail"()
    if_null rx1588_debug, debug_1119
    rx1588_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1119:
    .return (rx1588_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("362_1300051172.188") :method
.annotate 'line', 4
    $P1590 = self."!PREFIX__!subrule"("panic", "=")
    new $P1591, "ResizablePMCArray"
    push $P1591, $P1590
    .return ($P1591)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("363_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1595_tgt
    .local int rx1595_pos
    .local int rx1595_off
    .local int rx1595_eos
    .local int rx1595_rep
    .local pmc rx1595_cur
    .local pmc rx1595_debug
    (rx1595_cur, rx1595_pos, rx1595_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1595_cur
    .local pmc match
    .lex "$/", match
    length rx1595_eos, rx1595_tgt
    gt rx1595_pos, rx1595_eos, rx1595_done
    set rx1595_off, 0
    lt rx1595_pos, 2, rx1595_start
    sub rx1595_off, rx1595_pos, 1
    substr rx1595_tgt, rx1595_tgt, rx1595_off
  rx1595_start:
    eq $I10, 1, rx1595_restart
    if_null rx1595_debug, debug_1120
    rx1595_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1599_done
    goto rxscan1599_scan
  rxscan1599_loop:
    (rx1595_pos) = rx1595_cur."from"()
    inc rx1595_pos
    rx1595_cur."!cursor_from"(rx1595_pos)
    ge rx1595_pos, rx1595_eos, rxscan1599_done
  rxscan1599_scan:
    set_addr $I10, rxscan1599_loop
    rx1595_cur."!mark_push"(0, rx1595_pos, $I10)
  rxscan1599_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1600_fail
    rx1595_cur."!mark_push"(0, rx1595_pos, $I10)
  # rx literal  ":="
    add $I11, rx1595_pos, 2
    gt $I11, rx1595_eos, rx1595_fail
    sub $I11, rx1595_pos, rx1595_off
    substr $S10, rx1595_tgt, $I11, 2
    ne $S10, ":=", rx1595_fail
    add rx1595_pos, 2
    set_addr $I10, rxcap_1600_fail
    ($I12, $I11) = rx1595_cur."!mark_peek"($I10)
    rx1595_cur."!cursor_pos"($I11)
    ($P10) = rx1595_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1595_pos, "")
    rx1595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1600_done
  rxcap_1600_fail:
    goto rx1595_fail
  rxcap_1600_done:
  # rx subrule "O" subtype=capture negate=
    rx1595_cur."!cursor_pos"(rx1595_pos)
    $P10 = rx1595_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1595_fail
    rx1595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1595_pos = $P10."pos"()
  # rx pass
    rx1595_cur."!cursor_pass"(rx1595_pos, "infix:sym<:=>")
    if_null rx1595_debug, debug_1121
    rx1595_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1595_pos)
  debug_1121:
    .return (rx1595_cur)
  rx1595_restart:
.annotate 'line', 4
    if_null rx1595_debug, debug_1122
    rx1595_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1122:
  rx1595_fail:
    (rx1595_rep, rx1595_pos, $I10, $P10) = rx1595_cur."!mark_fail"(0)
    lt rx1595_pos, -1, rx1595_done
    eq rx1595_pos, -1, rx1595_fail
    jump $I10
  rx1595_done:
    rx1595_cur."!cursor_fail"()
    if_null rx1595_debug, debug_1123
    rx1595_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1123:
    .return (rx1595_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("364_1300051172.188") :method
.annotate 'line', 4
    $P1597 = self."!PREFIX__!subrule"("O", ":=")
    new $P1598, "ResizablePMCArray"
    push $P1598, $P1597
    .return ($P1598)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("365_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1602_tgt
    .local int rx1602_pos
    .local int rx1602_off
    .local int rx1602_eos
    .local int rx1602_rep
    .local pmc rx1602_cur
    .local pmc rx1602_debug
    (rx1602_cur, rx1602_pos, rx1602_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1602_cur
    .local pmc match
    .lex "$/", match
    length rx1602_eos, rx1602_tgt
    gt rx1602_pos, rx1602_eos, rx1602_done
    set rx1602_off, 0
    lt rx1602_pos, 2, rx1602_start
    sub rx1602_off, rx1602_pos, 1
    substr rx1602_tgt, rx1602_tgt, rx1602_off
  rx1602_start:
    eq $I10, 1, rx1602_restart
    if_null rx1602_debug, debug_1124
    rx1602_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1606_done
    goto rxscan1606_scan
  rxscan1606_loop:
    (rx1602_pos) = rx1602_cur."from"()
    inc rx1602_pos
    rx1602_cur."!cursor_from"(rx1602_pos)
    ge rx1602_pos, rx1602_eos, rxscan1606_done
  rxscan1606_scan:
    set_addr $I10, rxscan1606_loop
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
  rxscan1606_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1607_fail
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
  # rx literal  "::="
    add $I11, rx1602_pos, 3
    gt $I11, rx1602_eos, rx1602_fail
    sub $I11, rx1602_pos, rx1602_off
    substr $S10, rx1602_tgt, $I11, 3
    ne $S10, "::=", rx1602_fail
    add rx1602_pos, 3
    set_addr $I10, rxcap_1607_fail
    ($I12, $I11) = rx1602_cur."!mark_peek"($I10)
    rx1602_cur."!cursor_pos"($I11)
    ($P10) = rx1602_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1602_pos, "")
    rx1602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1607_done
  rxcap_1607_fail:
    goto rx1602_fail
  rxcap_1607_done:
  # rx subrule "O" subtype=capture negate=
    rx1602_cur."!cursor_pos"(rx1602_pos)
    $P10 = rx1602_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1602_fail
    rx1602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1602_pos = $P10."pos"()
  # rx pass
    rx1602_cur."!cursor_pass"(rx1602_pos, "infix:sym<::=>")
    if_null rx1602_debug, debug_1125
    rx1602_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1602_pos)
  debug_1125:
    .return (rx1602_cur)
  rx1602_restart:
.annotate 'line', 4
    if_null rx1602_debug, debug_1126
    rx1602_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1126:
  rx1602_fail:
    (rx1602_rep, rx1602_pos, $I10, $P10) = rx1602_cur."!mark_fail"(0)
    lt rx1602_pos, -1, rx1602_done
    eq rx1602_pos, -1, rx1602_fail
    jump $I10
  rx1602_done:
    rx1602_cur."!cursor_fail"()
    if_null rx1602_debug, debug_1127
    rx1602_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1127:
    .return (rx1602_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("366_1300051172.188") :method
.annotate 'line', 4
    $P1604 = self."!PREFIX__!subrule"("O", "::=")
    new $P1605, "ResizablePMCArray"
    push $P1605, $P1604
    .return ($P1605)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("367_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1609_tgt
    .local int rx1609_pos
    .local int rx1609_off
    .local int rx1609_eos
    .local int rx1609_rep
    .local pmc rx1609_cur
    .local pmc rx1609_debug
    (rx1609_cur, rx1609_pos, rx1609_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1609_cur
    .local pmc match
    .lex "$/", match
    length rx1609_eos, rx1609_tgt
    gt rx1609_pos, rx1609_eos, rx1609_done
    set rx1609_off, 0
    lt rx1609_pos, 2, rx1609_start
    sub rx1609_off, rx1609_pos, 1
    substr rx1609_tgt, rx1609_tgt, rx1609_off
  rx1609_start:
    eq $I10, 1, rx1609_restart
    if_null rx1609_debug, debug_1128
    rx1609_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1609_pos) = rx1609_cur."from"()
    inc rx1609_pos
    rx1609_cur."!cursor_from"(rx1609_pos)
    ge rx1609_pos, rx1609_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1609_cur."!mark_push"(0, rx1609_pos, $I10)
  rxscan1613_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1614_fail
    rx1609_cur."!mark_push"(0, rx1609_pos, $I10)
  # rx literal  ","
    add $I11, rx1609_pos, 1
    gt $I11, rx1609_eos, rx1609_fail
    sub $I11, rx1609_pos, rx1609_off
    ord $I11, rx1609_tgt, $I11
    ne $I11, 44, rx1609_fail
    add rx1609_pos, 1
    set_addr $I10, rxcap_1614_fail
    ($I12, $I11) = rx1609_cur."!mark_peek"($I10)
    rx1609_cur."!cursor_pos"($I11)
    ($P10) = rx1609_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1609_pos, "")
    rx1609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1614_done
  rxcap_1614_fail:
    goto rx1609_fail
  rxcap_1614_done:
  # rx subrule "O" subtype=capture negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    $P10 = rx1609_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1609_fail
    rx1609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1609_pos = $P10."pos"()
  # rx pass
    rx1609_cur."!cursor_pass"(rx1609_pos, "infix:sym<,>")
    if_null rx1609_debug, debug_1129
    rx1609_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1609_pos)
  debug_1129:
    .return (rx1609_cur)
  rx1609_restart:
.annotate 'line', 4
    if_null rx1609_debug, debug_1130
    rx1609_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1130:
  rx1609_fail:
    (rx1609_rep, rx1609_pos, $I10, $P10) = rx1609_cur."!mark_fail"(0)
    lt rx1609_pos, -1, rx1609_done
    eq rx1609_pos, -1, rx1609_fail
    jump $I10
  rx1609_done:
    rx1609_cur."!cursor_fail"()
    if_null rx1609_debug, debug_1131
    rx1609_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1131:
    .return (rx1609_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("368_1300051172.188") :method
.annotate 'line', 4
    $P1611 = self."!PREFIX__!subrule"("O", ",")
    new $P1612, "ResizablePMCArray"
    push $P1612, $P1611
    .return ($P1612)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("369_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P1624 = "371_1300051172.188" 
    capture_lex $P1624
    .local string rx1616_tgt
    .local int rx1616_pos
    .local int rx1616_off
    .local int rx1616_eos
    .local int rx1616_rep
    .local pmc rx1616_cur
    .local pmc rx1616_debug
    (rx1616_cur, rx1616_pos, rx1616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1616_cur
    .local pmc match
    .lex "$/", match
    length rx1616_eos, rx1616_tgt
    gt rx1616_pos, rx1616_eos, rx1616_done
    set rx1616_off, 0
    lt rx1616_pos, 2, rx1616_start
    sub rx1616_off, rx1616_pos, 1
    substr rx1616_tgt, rx1616_tgt, rx1616_off
  rx1616_start:
    eq $I10, 1, rx1616_restart
    if_null rx1616_debug, debug_1132
    rx1616_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1132:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1619_done
    goto rxscan1619_scan
  rxscan1619_loop:
    (rx1616_pos) = rx1616_cur."from"()
    inc rx1616_pos
    rx1616_cur."!cursor_from"(rx1616_pos)
    ge rx1616_pos, rx1616_eos, rxscan1619_done
  rxscan1619_scan:
    set_addr $I10, rxscan1619_loop
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  rxscan1619_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1620_fail
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  # rx literal  "return"
    add $I11, rx1616_pos, 6
    gt $I11, rx1616_eos, rx1616_fail
    sub $I11, rx1616_pos, rx1616_off
    substr $S10, rx1616_tgt, $I11, 6
    ne $S10, "return", rx1616_fail
    add rx1616_pos, 6
    set_addr $I10, rxcap_1620_fail
    ($I12, $I11) = rx1616_cur."!mark_peek"($I10)
    rx1616_cur."!cursor_pos"($I11)
    ($P10) = rx1616_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1616_pos, "")
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1620_done
  rxcap_1620_fail:
    goto rx1616_fail
  rxcap_1620_done:
  # rx charclass s
    ge rx1616_pos, rx1616_eos, rx1616_fail
    sub $I10, rx1616_pos, rx1616_off
    is_cclass $I11, 32, rx1616_tgt, $I10
    unless $I11, rx1616_fail
    inc rx1616_pos
  # rx subrule "O" subtype=capture negate=
    rx1616_cur."!cursor_pos"(rx1616_pos)
    $P10 = rx1616_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1616_fail
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1616_pos = $P10."pos"()
    rx1616_cur."!cursor_pos"(rx1616_pos)
    find_lex $P1621, unicode:"$\x{a2}"
    $P1622 = $P1621."MATCH"()
    store_lex "$/", $P1622
    .const 'Sub' $P1624 = "371_1300051172.188" 
    capture_lex $P1624
    $P1626 = $P1624()
  # rx pass
    rx1616_cur."!cursor_pass"(rx1616_pos, "prefix:sym<return>")
    if_null rx1616_debug, debug_1133
    rx1616_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1616_pos)
  debug_1133:
    .return (rx1616_cur)
  rx1616_restart:
.annotate 'line', 4
    if_null rx1616_debug, debug_1134
    rx1616_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1134:
  rx1616_fail:
    (rx1616_rep, rx1616_pos, $I10, $P10) = rx1616_cur."!mark_fail"(0)
    lt rx1616_pos, -1, rx1616_done
    eq rx1616_pos, -1, rx1616_fail
    jump $I10
  rx1616_done:
    rx1616_cur."!cursor_fail"()
    if_null rx1616_debug, debug_1135
    rx1616_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1135:
    .return (rx1616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("370_1300051172.188") :method
.annotate 'line', 4
    new $P1618, "ResizablePMCArray"
    push $P1618, "return"
    .return ($P1618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1623"  :anon :subid("371_1300051172.188") :outer("369_1300051172.188")
.annotate 'line', 679
    new $P1625, "Integer"
    assign $P1625, 1
    store_dynamic_lex "$*RETURN_USED", $P1625
    .return ($P1625)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("372_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1628_tgt
    .local int rx1628_pos
    .local int rx1628_off
    .local int rx1628_eos
    .local int rx1628_rep
    .local pmc rx1628_cur
    .local pmc rx1628_debug
    (rx1628_cur, rx1628_pos, rx1628_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1628_cur
    .local pmc match
    .lex "$/", match
    length rx1628_eos, rx1628_tgt
    gt rx1628_pos, rx1628_eos, rx1628_done
    set rx1628_off, 0
    lt rx1628_pos, 2, rx1628_start
    sub rx1628_off, rx1628_pos, 1
    substr rx1628_tgt, rx1628_tgt, rx1628_off
  rx1628_start:
    eq $I10, 1, rx1628_restart
    if_null rx1628_debug, debug_1136
    rx1628_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1631_done
    goto rxscan1631_scan
  rxscan1631_loop:
    (rx1628_pos) = rx1628_cur."from"()
    inc rx1628_pos
    rx1628_cur."!cursor_from"(rx1628_pos)
    ge rx1628_pos, rx1628_eos, rxscan1631_done
  rxscan1631_scan:
    set_addr $I10, rxscan1631_loop
    rx1628_cur."!mark_push"(0, rx1628_pos, $I10)
  rxscan1631_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1632_fail
    rx1628_cur."!mark_push"(0, rx1628_pos, $I10)
  # rx literal  "make"
    add $I11, rx1628_pos, 4
    gt $I11, rx1628_eos, rx1628_fail
    sub $I11, rx1628_pos, rx1628_off
    substr $S10, rx1628_tgt, $I11, 4
    ne $S10, "make", rx1628_fail
    add rx1628_pos, 4
    set_addr $I10, rxcap_1632_fail
    ($I12, $I11) = rx1628_cur."!mark_peek"($I10)
    rx1628_cur."!cursor_pos"($I11)
    ($P10) = rx1628_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1628_pos, "")
    rx1628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1632_done
  rxcap_1632_fail:
    goto rx1628_fail
  rxcap_1632_done:
  # rx charclass s
    ge rx1628_pos, rx1628_eos, rx1628_fail
    sub $I10, rx1628_pos, rx1628_off
    is_cclass $I11, 32, rx1628_tgt, $I10
    unless $I11, rx1628_fail
    inc rx1628_pos
  # rx subrule "O" subtype=capture negate=
    rx1628_cur."!cursor_pos"(rx1628_pos)
    $P10 = rx1628_cur."O"("%list_prefix")
    unless $P10, rx1628_fail
    rx1628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1628_pos = $P10."pos"()
  # rx pass
    rx1628_cur."!cursor_pass"(rx1628_pos, "prefix:sym<make>")
    if_null rx1628_debug, debug_1137
    rx1628_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1628_pos)
  debug_1137:
    .return (rx1628_cur)
  rx1628_restart:
.annotate 'line', 4
    if_null rx1628_debug, debug_1138
    rx1628_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1138:
  rx1628_fail:
    (rx1628_rep, rx1628_pos, $I10, $P10) = rx1628_cur."!mark_fail"(0)
    lt rx1628_pos, -1, rx1628_done
    eq rx1628_pos, -1, rx1628_fail
    jump $I10
  rx1628_done:
    rx1628_cur."!cursor_fail"()
    if_null rx1628_debug, debug_1139
    rx1628_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1139:
    .return (rx1628_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("373_1300051172.188") :method
.annotate 'line', 4
    new $P1630, "ResizablePMCArray"
    push $P1630, "make"
    .return ($P1630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("374_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1634_tgt
    .local int rx1634_pos
    .local int rx1634_off
    .local int rx1634_eos
    .local int rx1634_rep
    .local pmc rx1634_cur
    .local pmc rx1634_debug
    (rx1634_cur, rx1634_pos, rx1634_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1634_cur
    .local pmc match
    .lex "$/", match
    length rx1634_eos, rx1634_tgt
    gt rx1634_pos, rx1634_eos, rx1634_done
    set rx1634_off, 0
    lt rx1634_pos, 2, rx1634_start
    sub rx1634_off, rx1634_pos, 1
    substr rx1634_tgt, rx1634_tgt, rx1634_off
  rx1634_start:
    eq $I10, 1, rx1634_restart
    if_null rx1634_debug, debug_1140
    rx1634_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1637_done
    goto rxscan1637_scan
  rxscan1637_loop:
    (rx1634_pos) = rx1634_cur."from"()
    inc rx1634_pos
    rx1634_cur."!cursor_from"(rx1634_pos)
    ge rx1634_pos, rx1634_eos, rxscan1637_done
  rxscan1637_scan:
    set_addr $I10, rxscan1637_loop
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  rxscan1637_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1638_fail
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  # rx literal  "last"
    add $I11, rx1634_pos, 4
    gt $I11, rx1634_eos, rx1634_fail
    sub $I11, rx1634_pos, rx1634_off
    substr $S10, rx1634_tgt, $I11, 4
    ne $S10, "last", rx1634_fail
    add rx1634_pos, 4
    set_addr $I10, rxcap_1638_fail
    ($I12, $I11) = rx1634_cur."!mark_peek"($I10)
    rx1634_cur."!cursor_pos"($I11)
    ($P10) = rx1634_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1634_pos, "")
    rx1634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1638_done
  rxcap_1638_fail:
    goto rx1634_fail
  rxcap_1638_done:
  # rx pass
    rx1634_cur."!cursor_pass"(rx1634_pos, "term:sym<last>")
    if_null rx1634_debug, debug_1141
    rx1634_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1634_pos)
  debug_1141:
    .return (rx1634_cur)
  rx1634_restart:
.annotate 'line', 4
    if_null rx1634_debug, debug_1142
    rx1634_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1142:
  rx1634_fail:
    (rx1634_rep, rx1634_pos, $I10, $P10) = rx1634_cur."!mark_fail"(0)
    lt rx1634_pos, -1, rx1634_done
    eq rx1634_pos, -1, rx1634_fail
    jump $I10
  rx1634_done:
    rx1634_cur."!cursor_fail"()
    if_null rx1634_debug, debug_1143
    rx1634_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1143:
    .return (rx1634_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("375_1300051172.188") :method
.annotate 'line', 4
    new $P1636, "ResizablePMCArray"
    push $P1636, "last"
    .return ($P1636)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("376_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1640_tgt
    .local int rx1640_pos
    .local int rx1640_off
    .local int rx1640_eos
    .local int rx1640_rep
    .local pmc rx1640_cur
    .local pmc rx1640_debug
    (rx1640_cur, rx1640_pos, rx1640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1640_cur
    .local pmc match
    .lex "$/", match
    length rx1640_eos, rx1640_tgt
    gt rx1640_pos, rx1640_eos, rx1640_done
    set rx1640_off, 0
    lt rx1640_pos, 2, rx1640_start
    sub rx1640_off, rx1640_pos, 1
    substr rx1640_tgt, rx1640_tgt, rx1640_off
  rx1640_start:
    eq $I10, 1, rx1640_restart
    if_null rx1640_debug, debug_1144
    rx1640_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1144:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1643_done
    goto rxscan1643_scan
  rxscan1643_loop:
    (rx1640_pos) = rx1640_cur."from"()
    inc rx1640_pos
    rx1640_cur."!cursor_from"(rx1640_pos)
    ge rx1640_pos, rx1640_eos, rxscan1643_done
  rxscan1643_scan:
    set_addr $I10, rxscan1643_loop
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  rxscan1643_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1644_fail
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  # rx literal  "next"
    add $I11, rx1640_pos, 4
    gt $I11, rx1640_eos, rx1640_fail
    sub $I11, rx1640_pos, rx1640_off
    substr $S10, rx1640_tgt, $I11, 4
    ne $S10, "next", rx1640_fail
    add rx1640_pos, 4
    set_addr $I10, rxcap_1644_fail
    ($I12, $I11) = rx1640_cur."!mark_peek"($I10)
    rx1640_cur."!cursor_pos"($I11)
    ($P10) = rx1640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1640_pos, "")
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1644_done
  rxcap_1644_fail:
    goto rx1640_fail
  rxcap_1644_done:
  # rx pass
    rx1640_cur."!cursor_pass"(rx1640_pos, "term:sym<next>")
    if_null rx1640_debug, debug_1145
    rx1640_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1640_pos)
  debug_1145:
    .return (rx1640_cur)
  rx1640_restart:
.annotate 'line', 4
    if_null rx1640_debug, debug_1146
    rx1640_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1146:
  rx1640_fail:
    (rx1640_rep, rx1640_pos, $I10, $P10) = rx1640_cur."!mark_fail"(0)
    lt rx1640_pos, -1, rx1640_done
    eq rx1640_pos, -1, rx1640_fail
    jump $I10
  rx1640_done:
    rx1640_cur."!cursor_fail"()
    if_null rx1640_debug, debug_1147
    rx1640_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1147:
    .return (rx1640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("377_1300051172.188") :method
.annotate 'line', 4
    new $P1642, "ResizablePMCArray"
    push $P1642, "next"
    .return ($P1642)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("378_1300051172.188") :method :outer("11_1300051172.188")
.annotate 'line', 4
    .local string rx1646_tgt
    .local int rx1646_pos
    .local int rx1646_off
    .local int rx1646_eos
    .local int rx1646_rep
    .local pmc rx1646_cur
    .local pmc rx1646_debug
    (rx1646_cur, rx1646_pos, rx1646_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1646_cur
    .local pmc match
    .lex "$/", match
    length rx1646_eos, rx1646_tgt
    gt rx1646_pos, rx1646_eos, rx1646_done
    set rx1646_off, 0
    lt rx1646_pos, 2, rx1646_start
    sub rx1646_off, rx1646_pos, 1
    substr rx1646_tgt, rx1646_tgt, rx1646_off
  rx1646_start:
    eq $I10, 1, rx1646_restart
    if_null rx1646_debug, debug_1148
    rx1646_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1649_done
    goto rxscan1649_scan
  rxscan1649_loop:
    (rx1646_pos) = rx1646_cur."from"()
    inc rx1646_pos
    rx1646_cur."!cursor_from"(rx1646_pos)
    ge rx1646_pos, rx1646_eos, rxscan1649_done
  rxscan1649_scan:
    set_addr $I10, rxscan1649_loop
    rx1646_cur."!mark_push"(0, rx1646_pos, $I10)
  rxscan1649_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1650_fail
    rx1646_cur."!mark_push"(0, rx1646_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1646_pos, 4
    gt $I11, rx1646_eos, rx1646_fail
    sub $I11, rx1646_pos, rx1646_off
    substr $S10, rx1646_tgt, $I11, 4
    ne $S10, "redo", rx1646_fail
    add rx1646_pos, 4
    set_addr $I10, rxcap_1650_fail
    ($I12, $I11) = rx1646_cur."!mark_peek"($I10)
    rx1646_cur."!cursor_pos"($I11)
    ($P10) = rx1646_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1646_pos, "")
    rx1646_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1650_done
  rxcap_1650_fail:
    goto rx1646_fail
  rxcap_1650_done:
  # rx pass
    rx1646_cur."!cursor_pass"(rx1646_pos, "term:sym<redo>")
    if_null rx1646_debug, debug_1149
    rx1646_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1646_pos)
  debug_1149:
    .return (rx1646_cur)
  rx1646_restart:
.annotate 'line', 4
    if_null rx1646_debug, debug_1150
    rx1646_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1150:
  rx1646_fail:
    (rx1646_rep, rx1646_pos, $I10, $P10) = rx1646_cur."!mark_fail"(0)
    lt rx1646_pos, -1, rx1646_done
    eq rx1646_pos, -1, rx1646_fail
    jump $I10
  rx1646_done:
    rx1646_cur."!cursor_fail"()
    if_null rx1646_debug, debug_1151
    rx1646_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1151:
    .return (rx1646_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("379_1300051172.188") :method
.annotate 'line', 4
    new $P1648, "ResizablePMCArray"
    push $P1648, "redo"
    .return ($P1648)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("380_1300051172.188") :outer("11_1300051172.188")
    .param pmc param_1652
    .param pmc param_1653
.annotate 'line', 685
    .lex "self", param_1652
    .lex "$/", param_1653
.annotate 'line', 687
    new $P1654, "Undef"
    .lex "$t", $P1654
    find_lex $P1655, "$/"
    unless_null $P1655, vivify_1152
    $P1655 = root_new ['parrot';'ResizablePMCArray']
  vivify_1152:
    set $P1656, $P1655[0]
    unless_null $P1656, vivify_1153
    new $P1656, "Undef"
  vivify_1153:
    store_lex "$t", $P1656
    find_lex $P1657, "$/"
    unless_null $P1657, vivify_1154
    $P1657 = root_new ['parrot';'ResizablePMCArray']
  vivify_1154:
    set $P1658, $P1657[1]
    unless_null $P1658, vivify_1155
    new $P1658, "Undef"
  vivify_1155:
    find_lex $P1659, "$/"
    unless_null $P1659, vivify_1156
    $P1659 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1659
  vivify_1156:
    set $P1659[0], $P1658
    find_lex $P1660, "$t"
    find_lex $P1661, "$/"
    unless_null $P1661, vivify_1157
    $P1661 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1661
  vivify_1157:
    set $P1661[1], $P1660
.annotate 'line', 685
    .return ($P1660)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1662"  :subid("381_1300051172.188") :outer("11_1300051172.188")
.annotate 'line', 691
    .const 'Sub' $P1727 = "402_1300051172.188" 
    capture_lex $P1727
    .const 'Sub' $P1720 = "400_1300051172.188" 
    capture_lex $P1720
    .const 'Sub' $P1715 = "398_1300051172.188" 
    capture_lex $P1715
    .const 'Sub' $P1703 = "395_1300051172.188" 
    capture_lex $P1703
    .const 'Sub' $P1693 = "392_1300051172.188" 
    capture_lex $P1693
    .const 'Sub' $P1688 = "390_1300051172.188" 
    capture_lex $P1688
    .const 'Sub' $P1679 = "387_1300051172.188" 
    capture_lex $P1679
    .const 'Sub' $P1674 = "385_1300051172.188" 
    capture_lex $P1674
    .const 'Sub' $P1665 = "382_1300051172.188" 
    capture_lex $P1665
    get_global $P1664, "$?CLASS"
    .const 'Sub' $P1720 = "400_1300051172.188" 
    capture_lex $P1720
    .return ($P1720)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1158") :outer("381_1300051172.188")
.annotate 'line', 691
    get_hll_global $P1663, ["NQP";"Regex"], "_block1662" 
    .local pmc block
    set block, $P1663
    .const 'Sub' $P1727 = "402_1300051172.188" 
    capture_lex $P1727
    $P1727()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1726"  :anon :subid("402_1300051172.188") :outer("381_1300051172.188")
.annotate 'line', 691
    nqp_get_sc_object $P1728, "1300051166.695", 1
    .local pmc type_obj
    set type_obj, $P1728
    set_global "$?CLASS", type_obj
    get_how $P1729, type_obj
    .const 'Sub' $P1730 = "382_1300051172.188" 
    $P1729."add_method"(type_obj, "metachar:sym<:my>", $P1730)
    get_how $P1731, type_obj
    get_global $P1732, "!PREFIX__metachar:sym<:my>"
    $P1731."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1732)
    get_how $P1733, type_obj
    .const 'Sub' $P1734 = "385_1300051172.188" 
    $P1733."add_method"(type_obj, "metachar:sym<{ }>", $P1734)
    get_how $P1735, type_obj
    get_global $P1736, "!PREFIX__metachar:sym<{ }>"
    $P1735."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1736)
    get_how $P1737, type_obj
    .const 'Sub' $P1738 = "387_1300051172.188" 
    $P1737."add_method"(type_obj, "metachar:sym<nqpvar>", $P1738)
    get_how $P1739, type_obj
    get_global $P1740, "!PREFIX__metachar:sym<nqpvar>"
    $P1739."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1740)
    get_how $P1741, type_obj
    .const 'Sub' $P1742 = "390_1300051172.188" 
    $P1741."add_method"(type_obj, "assertion:sym<{ }>", $P1742)
    get_how $P1743, type_obj
    get_global $P1744, "!PREFIX__assertion:sym<{ }>"
    $P1743."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1744)
    get_how $P1745, type_obj
    .const 'Sub' $P1746 = "392_1300051172.188" 
    $P1745."add_method"(type_obj, "assertion:sym<?{ }>", $P1746)
    get_how $P1747, type_obj
    get_global $P1748, "!PREFIX__assertion:sym<?{ }>"
    $P1747."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1748)
    get_how $P1749, type_obj
    .const 'Sub' $P1750 = "395_1300051172.188" 
    $P1749."add_method"(type_obj, "assertion:sym<name>", $P1750)
    get_how $P1751, type_obj
    get_global $P1752, "!PREFIX__assertion:sym<name>"
    $P1751."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1752)
    get_how $P1753, type_obj
    .const 'Sub' $P1754 = "398_1300051172.188" 
    $P1753."add_method"(type_obj, "assertion:sym<var>", $P1754)
    get_how $P1755, type_obj
    get_global $P1756, "!PREFIX__assertion:sym<var>"
    $P1755."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1756)
    get_how $P1757, type_obj
    .const 'Sub' $P1758 = "400_1300051172.188" 
    $P1757."add_method"(type_obj, "codeblock", $P1758)
    get_how $P1759, type_obj
    get_global $P1760, "!PREFIX__codeblock"
    $P1759."add_method"(type_obj, "!PREFIX__codeblock", $P1760)
    get_how $P1761, type_obj
    get_hll_global $P1762, ["Regex";"P6Regex"], "Grammar"
    $P1761."add_parent"(type_obj, $P1762)
    get_how $P1763, type_obj
    $P1764 = $P1763."compose"(type_obj)
    .return ($P1764)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("382_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .const 'Sub' $P1671 = "384_1300051172.188" 
    capture_lex $P1671
    .local string rx1666_tgt
    .local int rx1666_pos
    .local int rx1666_off
    .local int rx1666_eos
    .local int rx1666_rep
    .local pmc rx1666_cur
    .local pmc rx1666_debug
    (rx1666_cur, rx1666_pos, rx1666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1666_cur
    .local pmc match
    .lex "$/", match
    length rx1666_eos, rx1666_tgt
    gt rx1666_pos, rx1666_eos, rx1666_done
    set rx1666_off, 0
    lt rx1666_pos, 2, rx1666_start
    sub rx1666_off, rx1666_pos, 1
    substr rx1666_tgt, rx1666_tgt, rx1666_off
  rx1666_start:
    eq $I10, 1, rx1666_restart
    if_null rx1666_debug, debug_1159
    rx1666_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1159:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1669_done
    goto rxscan1669_scan
  rxscan1669_loop:
    (rx1666_pos) = rx1666_cur."from"()
    inc rx1666_pos
    rx1666_cur."!cursor_from"(rx1666_pos)
    ge rx1666_pos, rx1666_eos, rxscan1669_done
  rxscan1669_scan:
    set_addr $I10, rxscan1669_loop
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  rxscan1669_done:
.annotate 'line', 693
  # rx literal  ":"
    add $I11, rx1666_pos, 1
    gt $I11, rx1666_eos, rx1666_fail
    sub $I11, rx1666_pos, rx1666_off
    ord $I11, rx1666_tgt, $I11
    ne $I11, 58, rx1666_fail
    add rx1666_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    .const 'Sub' $P1671 = "384_1300051172.188" 
    capture_lex $P1671
    $P10 = rx1666_cur."before"($P1671)
    unless $P10, rx1666_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    $P10 = rx1666_cur."LANG"("MAIN", "statement")
    unless $P10, rx1666_fail
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1666_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    $P10 = rx1666_cur."ws"()
    unless $P10, rx1666_fail
    rx1666_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1666_pos, 1
    gt $I11, rx1666_eos, rx1666_fail
    sub $I11, rx1666_pos, rx1666_off
    ord $I11, rx1666_tgt, $I11
    ne $I11, 59, rx1666_fail
    add rx1666_pos, 1
.annotate 'line', 692
  # rx pass
    rx1666_cur."!cursor_pass"(rx1666_pos, "metachar:sym<:my>")
    if_null rx1666_debug, debug_1164
    rx1666_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1666_pos)
  debug_1164:
    .return (rx1666_cur)
  rx1666_restart:
.annotate 'line', 691
    if_null rx1666_debug, debug_1165
    rx1666_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1165:
  rx1666_fail:
    (rx1666_rep, rx1666_pos, $I10, $P10) = rx1666_cur."!mark_fail"(0)
    lt rx1666_pos, -1, rx1666_done
    eq rx1666_pos, -1, rx1666_fail
    jump $I10
  rx1666_done:
    rx1666_cur."!cursor_fail"()
    if_null rx1666_debug, debug_1166
    rx1666_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1166:
    .return (rx1666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("383_1300051172.188") :method
.annotate 'line', 691
    new $P1668, "ResizablePMCArray"
    push $P1668, ":"
    .return ($P1668)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1670"  :anon :subid("384_1300051172.188") :method :outer("382_1300051172.188")
.annotate 'line', 693
    .local string rx1672_tgt
    .local int rx1672_pos
    .local int rx1672_off
    .local int rx1672_eos
    .local int rx1672_rep
    .local pmc rx1672_cur
    .local pmc rx1672_debug
    (rx1672_cur, rx1672_pos, rx1672_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1672_cur
    .local pmc match
    .lex "$/", match
    length rx1672_eos, rx1672_tgt
    gt rx1672_pos, rx1672_eos, rx1672_done
    set rx1672_off, 0
    lt rx1672_pos, 2, rx1672_start
    sub rx1672_off, rx1672_pos, 1
    substr rx1672_tgt, rx1672_tgt, rx1672_off
  rx1672_start:
    eq $I10, 1, rx1672_restart
    if_null rx1672_debug, debug_1160
    rx1672_cur."!cursor_debug"("START", "")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1673_done
    goto rxscan1673_scan
  rxscan1673_loop:
    (rx1672_pos) = rx1672_cur."from"()
    inc rx1672_pos
    rx1672_cur."!cursor_from"(rx1672_pos)
    ge rx1672_pos, rx1672_eos, rxscan1673_done
  rxscan1673_scan:
    set_addr $I10, rxscan1673_loop
    rx1672_cur."!mark_push"(0, rx1672_pos, $I10)
  rxscan1673_done:
  # rx literal  "my"
    add $I11, rx1672_pos, 2
    gt $I11, rx1672_eos, rx1672_fail
    sub $I11, rx1672_pos, rx1672_off
    substr $S10, rx1672_tgt, $I11, 2
    ne $S10, "my", rx1672_fail
    add rx1672_pos, 2
  # rx pass
    rx1672_cur."!cursor_pass"(rx1672_pos, "")
    if_null rx1672_debug, debug_1161
    rx1672_cur."!cursor_debug"("PASS", "", " at pos=", rx1672_pos)
  debug_1161:
    .return (rx1672_cur)
  rx1672_restart:
    if_null rx1672_debug, debug_1162
    rx1672_cur."!cursor_debug"("NEXT", "")
  debug_1162:
  rx1672_fail:
    (rx1672_rep, rx1672_pos, $I10, $P10) = rx1672_cur."!mark_fail"(0)
    lt rx1672_pos, -1, rx1672_done
    eq rx1672_pos, -1, rx1672_fail
    jump $I10
  rx1672_done:
    rx1672_cur."!cursor_fail"()
    if_null rx1672_debug, debug_1163
    rx1672_cur."!cursor_debug"("FAIL", "")
  debug_1163:
    .return (rx1672_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("385_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .local string rx1675_tgt
    .local int rx1675_pos
    .local int rx1675_off
    .local int rx1675_eos
    .local int rx1675_rep
    .local pmc rx1675_cur
    .local pmc rx1675_debug
    (rx1675_cur, rx1675_pos, rx1675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1675_cur
    .local pmc match
    .lex "$/", match
    length rx1675_eos, rx1675_tgt
    gt rx1675_pos, rx1675_eos, rx1675_done
    set rx1675_off, 0
    lt rx1675_pos, 2, rx1675_start
    sub rx1675_off, rx1675_pos, 1
    substr rx1675_tgt, rx1675_tgt, rx1675_off
  rx1675_start:
    eq $I10, 1, rx1675_restart
    if_null rx1675_debug, debug_1167
    rx1675_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1167:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1678_done
    goto rxscan1678_scan
  rxscan1678_loop:
    (rx1675_pos) = rx1675_cur."from"()
    inc rx1675_pos
    rx1675_cur."!cursor_from"(rx1675_pos)
    ge rx1675_pos, rx1675_eos, rxscan1678_done
  rxscan1678_scan:
    set_addr $I10, rxscan1678_loop
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  rxscan1678_done:
.annotate 'line', 697
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1675_pos, rx1675_off
    substr $S10, rx1675_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1675_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1675_cur."!cursor_pos"(rx1675_pos)
    $P10 = rx1675_cur."codeblock"()
    unless $P10, rx1675_fail
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1675_pos = $P10."pos"()
.annotate 'line', 696
  # rx pass
    rx1675_cur."!cursor_pass"(rx1675_pos, "metachar:sym<{ }>")
    if_null rx1675_debug, debug_1168
    rx1675_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1675_pos)
  debug_1168:
    .return (rx1675_cur)
  rx1675_restart:
.annotate 'line', 691
    if_null rx1675_debug, debug_1169
    rx1675_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1169:
  rx1675_fail:
    (rx1675_rep, rx1675_pos, $I10, $P10) = rx1675_cur."!mark_fail"(0)
    lt rx1675_pos, -1, rx1675_done
    eq rx1675_pos, -1, rx1675_fail
    jump $I10
  rx1675_done:
    rx1675_cur."!cursor_fail"()
    if_null rx1675_debug, debug_1170
    rx1675_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1170:
    .return (rx1675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("386_1300051172.188") :method
.annotate 'line', 691
    new $P1677, "ResizablePMCArray"
    push $P1677, "{"
    .return ($P1677)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("387_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .const 'Sub' $P1685 = "389_1300051172.188" 
    capture_lex $P1685
    .local string rx1680_tgt
    .local int rx1680_pos
    .local int rx1680_off
    .local int rx1680_eos
    .local int rx1680_rep
    .local pmc rx1680_cur
    .local pmc rx1680_debug
    (rx1680_cur, rx1680_pos, rx1680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1680_cur
    .local pmc match
    .lex "$/", match
    length rx1680_eos, rx1680_tgt
    gt rx1680_pos, rx1680_eos, rx1680_done
    set rx1680_off, 0
    lt rx1680_pos, 2, rx1680_start
    sub rx1680_off, rx1680_pos, 1
    substr rx1680_tgt, rx1680_tgt, rx1680_off
  rx1680_start:
    eq $I10, 1, rx1680_restart
    if_null rx1680_debug, debug_1171
    rx1680_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1171:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1683_done
    goto rxscan1683_scan
  rxscan1683_loop:
    (rx1680_pos) = rx1680_cur."from"()
    inc rx1680_pos
    rx1680_cur."!cursor_from"(rx1680_pos)
    ge rx1680_pos, rx1680_eos, rxscan1683_done
  rxscan1683_scan:
    set_addr $I10, rxscan1683_loop
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  rxscan1683_done:
.annotate 'line', 701
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1680_pos, rx1680_off
    substr $S10, rx1680_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1680_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    .const 'Sub' $P1685 = "389_1300051172.188" 
    capture_lex $P1685
    $P10 = rx1680_cur."before"($P1685)
    unless $P10, rx1680_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    $P10 = rx1680_cur."LANG"("MAIN", "variable")
    unless $P10, rx1680_fail
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1680_pos = $P10."pos"()
.annotate 'line', 700
  # rx pass
    rx1680_cur."!cursor_pass"(rx1680_pos, "metachar:sym<nqpvar>")
    if_null rx1680_debug, debug_1176
    rx1680_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1680_pos)
  debug_1176:
    .return (rx1680_cur)
  rx1680_restart:
.annotate 'line', 691
    if_null rx1680_debug, debug_1177
    rx1680_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1177:
  rx1680_fail:
    (rx1680_rep, rx1680_pos, $I10, $P10) = rx1680_cur."!mark_fail"(0)
    lt rx1680_pos, -1, rx1680_done
    eq rx1680_pos, -1, rx1680_fail
    jump $I10
  rx1680_done:
    rx1680_cur."!cursor_fail"()
    if_null rx1680_debug, debug_1178
    rx1680_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1178:
    .return (rx1680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("388_1300051172.188") :method
.annotate 'line', 691
    new $P1682, "ResizablePMCArray"
    push $P1682, "$"
    push $P1682, "@"
    .return ($P1682)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1684"  :anon :subid("389_1300051172.188") :method :outer("387_1300051172.188")
.annotate 'line', 701
    .local string rx1686_tgt
    .local int rx1686_pos
    .local int rx1686_off
    .local int rx1686_eos
    .local int rx1686_rep
    .local pmc rx1686_cur
    .local pmc rx1686_debug
    (rx1686_cur, rx1686_pos, rx1686_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1686_cur
    .local pmc match
    .lex "$/", match
    length rx1686_eos, rx1686_tgt
    gt rx1686_pos, rx1686_eos, rx1686_done
    set rx1686_off, 0
    lt rx1686_pos, 2, rx1686_start
    sub rx1686_off, rx1686_pos, 1
    substr rx1686_tgt, rx1686_tgt, rx1686_off
  rx1686_start:
    eq $I10, 1, rx1686_restart
    if_null rx1686_debug, debug_1172
    rx1686_cur."!cursor_debug"("START", "")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1687_done
    goto rxscan1687_scan
  rxscan1687_loop:
    (rx1686_pos) = rx1686_cur."from"()
    inc rx1686_pos
    rx1686_cur."!cursor_from"(rx1686_pos)
    ge rx1686_pos, rx1686_eos, rxscan1687_done
  rxscan1687_scan:
    set_addr $I10, rxscan1687_loop
    rx1686_cur."!mark_push"(0, rx1686_pos, $I10)
  rxscan1687_done:
  # rx charclass .
    ge rx1686_pos, rx1686_eos, rx1686_fail
    inc rx1686_pos
  # rx charclass w
    ge rx1686_pos, rx1686_eos, rx1686_fail
    sub $I10, rx1686_pos, rx1686_off
    is_cclass $I11, 8192, rx1686_tgt, $I10
    unless $I11, rx1686_fail
    inc rx1686_pos
  # rx pass
    rx1686_cur."!cursor_pass"(rx1686_pos, "")
    if_null rx1686_debug, debug_1173
    rx1686_cur."!cursor_debug"("PASS", "", " at pos=", rx1686_pos)
  debug_1173:
    .return (rx1686_cur)
  rx1686_restart:
    if_null rx1686_debug, debug_1174
    rx1686_cur."!cursor_debug"("NEXT", "")
  debug_1174:
  rx1686_fail:
    (rx1686_rep, rx1686_pos, $I10, $P10) = rx1686_cur."!mark_fail"(0)
    lt rx1686_pos, -1, rx1686_done
    eq rx1686_pos, -1, rx1686_fail
    jump $I10
  rx1686_done:
    rx1686_cur."!cursor_fail"()
    if_null rx1686_debug, debug_1175
    rx1686_cur."!cursor_debug"("FAIL", "")
  debug_1175:
    .return (rx1686_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("390_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .local string rx1689_tgt
    .local int rx1689_pos
    .local int rx1689_off
    .local int rx1689_eos
    .local int rx1689_rep
    .local pmc rx1689_cur
    .local pmc rx1689_debug
    (rx1689_cur, rx1689_pos, rx1689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1689_cur
    .local pmc match
    .lex "$/", match
    length rx1689_eos, rx1689_tgt
    gt rx1689_pos, rx1689_eos, rx1689_done
    set rx1689_off, 0
    lt rx1689_pos, 2, rx1689_start
    sub rx1689_off, rx1689_pos, 1
    substr rx1689_tgt, rx1689_tgt, rx1689_off
  rx1689_start:
    eq $I10, 1, rx1689_restart
    if_null rx1689_debug, debug_1179
    rx1689_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1179:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1692_done
    goto rxscan1692_scan
  rxscan1692_loop:
    (rx1689_pos) = rx1689_cur."from"()
    inc rx1689_pos
    rx1689_cur."!cursor_from"(rx1689_pos)
    ge rx1689_pos, rx1689_eos, rxscan1692_done
  rxscan1692_scan:
    set_addr $I10, rxscan1692_loop
    rx1689_cur."!mark_push"(0, rx1689_pos, $I10)
  rxscan1692_done:
.annotate 'line', 705
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1689_pos, rx1689_off
    substr $S10, rx1689_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1689_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."codeblock"()
    unless $P10, rx1689_fail
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1689_pos = $P10."pos"()
.annotate 'line', 704
  # rx pass
    rx1689_cur."!cursor_pass"(rx1689_pos, "assertion:sym<{ }>")
    if_null rx1689_debug, debug_1180
    rx1689_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1689_pos)
  debug_1180:
    .return (rx1689_cur)
  rx1689_restart:
.annotate 'line', 691
    if_null rx1689_debug, debug_1181
    rx1689_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1181:
  rx1689_fail:
    (rx1689_rep, rx1689_pos, $I10, $P10) = rx1689_cur."!mark_fail"(0)
    lt rx1689_pos, -1, rx1689_done
    eq rx1689_pos, -1, rx1689_fail
    jump $I10
  rx1689_done:
    rx1689_cur."!cursor_fail"()
    if_null rx1689_debug, debug_1182
    rx1689_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1182:
    .return (rx1689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("391_1300051172.188") :method
.annotate 'line', 691
    new $P1691, "ResizablePMCArray"
    push $P1691, "{"
    .return ($P1691)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("392_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .const 'Sub' $P1699 = "394_1300051172.188" 
    capture_lex $P1699
    .local string rx1694_tgt
    .local int rx1694_pos
    .local int rx1694_off
    .local int rx1694_eos
    .local int rx1694_rep
    .local pmc rx1694_cur
    .local pmc rx1694_debug
    (rx1694_cur, rx1694_pos, rx1694_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1694_cur
    .local pmc match
    .lex "$/", match
    length rx1694_eos, rx1694_tgt
    gt rx1694_pos, rx1694_eos, rx1694_done
    set rx1694_off, 0
    lt rx1694_pos, 2, rx1694_start
    sub rx1694_off, rx1694_pos, 1
    substr rx1694_tgt, rx1694_tgt, rx1694_off
  rx1694_start:
    eq $I10, 1, rx1694_restart
    if_null rx1694_debug, debug_1183
    rx1694_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1697_done
    goto rxscan1697_scan
  rxscan1697_loop:
    (rx1694_pos) = rx1694_cur."from"()
    inc rx1694_pos
    rx1694_cur."!cursor_from"(rx1694_pos)
    ge rx1694_pos, rx1694_eos, rxscan1697_done
  rxscan1697_scan:
    set_addr $I10, rxscan1697_loop
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  rxscan1697_done:
.annotate 'line', 709
  # rx subcapture "zw"
    set_addr $I10, rxcap_1702_fail
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1694_pos, rx1694_eos, rx1694_fail
    sub $I10, rx1694_pos, rx1694_off
    substr $S10, rx1694_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1694_fail
    inc rx1694_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    .const 'Sub' $P1699 = "394_1300051172.188" 
    capture_lex $P1699
    $P10 = rx1694_cur."before"($P1699)
    unless $P10, rx1694_fail
    set_addr $I10, rxcap_1702_fail
    ($I12, $I11) = rx1694_cur."!mark_peek"($I10)
    rx1694_cur."!cursor_pos"($I11)
    ($P10) = rx1694_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1694_pos, "")
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1702_done
  rxcap_1702_fail:
    goto rx1694_fail
  rxcap_1702_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    $P10 = rx1694_cur."codeblock"()
    unless $P10, rx1694_fail
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1694_pos = $P10."pos"()
.annotate 'line', 708
  # rx pass
    rx1694_cur."!cursor_pass"(rx1694_pos, "assertion:sym<?{ }>")
    if_null rx1694_debug, debug_1188
    rx1694_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1694_pos)
  debug_1188:
    .return (rx1694_cur)
  rx1694_restart:
.annotate 'line', 691
    if_null rx1694_debug, debug_1189
    rx1694_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1189:
  rx1694_fail:
    (rx1694_rep, rx1694_pos, $I10, $P10) = rx1694_cur."!mark_fail"(0)
    lt rx1694_pos, -1, rx1694_done
    eq rx1694_pos, -1, rx1694_fail
    jump $I10
  rx1694_done:
    rx1694_cur."!cursor_fail"()
    if_null rx1694_debug, debug_1190
    rx1694_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1190:
    .return (rx1694_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("393_1300051172.188") :method
.annotate 'line', 691
    new $P1696, "ResizablePMCArray"
    push $P1696, "!"
    push $P1696, "?"
    .return ($P1696)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1698"  :anon :subid("394_1300051172.188") :method :outer("392_1300051172.188")
.annotate 'line', 709
    .local string rx1700_tgt
    .local int rx1700_pos
    .local int rx1700_off
    .local int rx1700_eos
    .local int rx1700_rep
    .local pmc rx1700_cur
    .local pmc rx1700_debug
    (rx1700_cur, rx1700_pos, rx1700_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1700_cur
    .local pmc match
    .lex "$/", match
    length rx1700_eos, rx1700_tgt
    gt rx1700_pos, rx1700_eos, rx1700_done
    set rx1700_off, 0
    lt rx1700_pos, 2, rx1700_start
    sub rx1700_off, rx1700_pos, 1
    substr rx1700_tgt, rx1700_tgt, rx1700_off
  rx1700_start:
    eq $I10, 1, rx1700_restart
    if_null rx1700_debug, debug_1184
    rx1700_cur."!cursor_debug"("START", "")
  debug_1184:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1701_done
    goto rxscan1701_scan
  rxscan1701_loop:
    (rx1700_pos) = rx1700_cur."from"()
    inc rx1700_pos
    rx1700_cur."!cursor_from"(rx1700_pos)
    ge rx1700_pos, rx1700_eos, rxscan1701_done
  rxscan1701_scan:
    set_addr $I10, rxscan1701_loop
    rx1700_cur."!mark_push"(0, rx1700_pos, $I10)
  rxscan1701_done:
  # rx literal  "{"
    add $I11, rx1700_pos, 1
    gt $I11, rx1700_eos, rx1700_fail
    sub $I11, rx1700_pos, rx1700_off
    ord $I11, rx1700_tgt, $I11
    ne $I11, 123, rx1700_fail
    add rx1700_pos, 1
  # rx pass
    rx1700_cur."!cursor_pass"(rx1700_pos, "")
    if_null rx1700_debug, debug_1185
    rx1700_cur."!cursor_debug"("PASS", "", " at pos=", rx1700_pos)
  debug_1185:
    .return (rx1700_cur)
  rx1700_restart:
    if_null rx1700_debug, debug_1186
    rx1700_cur."!cursor_debug"("NEXT", "")
  debug_1186:
  rx1700_fail:
    (rx1700_rep, rx1700_pos, $I10, $P10) = rx1700_cur."!mark_fail"(0)
    lt rx1700_pos, -1, rx1700_done
    eq rx1700_pos, -1, rx1700_fail
    jump $I10
  rx1700_done:
    rx1700_cur."!cursor_fail"()
    if_null rx1700_debug, debug_1187
    rx1700_cur."!cursor_debug"("FAIL", "")
  debug_1187:
    .return (rx1700_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("395_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .const 'Sub' $P1712 = "397_1300051172.188" 
    capture_lex $P1712
    .local string rx1704_tgt
    .local int rx1704_pos
    .local int rx1704_off
    .local int rx1704_eos
    .local int rx1704_rep
    .local pmc rx1704_cur
    .local pmc rx1704_debug
    (rx1704_cur, rx1704_pos, rx1704_tgt, $I10) = self."!cursor_start"()
    rx1704_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1704_cur
    .local pmc match
    .lex "$/", match
    length rx1704_eos, rx1704_tgt
    gt rx1704_pos, rx1704_eos, rx1704_done
    set rx1704_off, 0
    lt rx1704_pos, 2, rx1704_start
    sub rx1704_off, rx1704_pos, 1
    substr rx1704_tgt, rx1704_tgt, rx1704_off
  rx1704_start:
    eq $I10, 1, rx1704_restart
    if_null rx1704_debug, debug_1191
    rx1704_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1708_done
    goto rxscan1708_scan
  rxscan1708_loop:
    (rx1704_pos) = rx1704_cur."from"()
    inc rx1704_pos
    rx1704_cur."!cursor_from"(rx1704_pos)
    ge rx1704_pos, rx1704_eos, rxscan1708_done
  rxscan1708_scan:
    set_addr $I10, rxscan1708_loop
    rx1704_cur."!mark_push"(0, rx1704_pos, $I10)
  rxscan1708_done:
.annotate 'line', 713
  # rx subrule "identifier" subtype=capture negate=
    rx1704_cur."!cursor_pos"(rx1704_pos)
    $P10 = rx1704_cur."identifier"()
    unless $P10, rx1704_fail
    rx1704_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1704_pos = $P10."pos"()
.annotate 'line', 720
  # rx rxquantr1709 ** 0..1
    set_addr $I10, rxquantr1709_done
    rx1704_cur."!mark_push"(0, rx1704_pos, $I10)
  rxquantr1709_loop:
  alt1710_0:
.annotate 'line', 714
    set_addr $I10, alt1710_1
    rx1704_cur."!mark_push"(0, rx1704_pos, $I10)
.annotate 'line', 715
  # rx subrule "before" subtype=zerowidth negate=
    rx1704_cur."!cursor_pos"(rx1704_pos)
    .const 'Sub' $P1712 = "397_1300051172.188" 
    capture_lex $P1712
    $P10 = rx1704_cur."before"($P1712)
    unless $P10, rx1704_fail
    goto alt1710_end
  alt1710_1:
    set_addr $I10, alt1710_2
    rx1704_cur."!mark_push"(0, rx1704_pos, $I10)
.annotate 'line', 716
  # rx literal  "="
    add $I11, rx1704_pos, 1
    gt $I11, rx1704_eos, rx1704_fail
    sub $I11, rx1704_pos, rx1704_off
    ord $I11, rx1704_tgt, $I11
    ne $I11, 61, rx1704_fail
    add rx1704_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1704_cur."!cursor_pos"(rx1704_pos)
    $P10 = rx1704_cur."assertion"()
    unless $P10, rx1704_fail
    rx1704_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1704_pos = $P10."pos"()
    goto alt1710_end
  alt1710_2:
    set_addr $I10, alt1710_3
    rx1704_cur."!mark_push"(0, rx1704_pos, $I10)
.annotate 'line', 717
  # rx literal  ":"
    add $I11, rx1704_pos, 1
    gt $I11, rx1704_eos, rx1704_fail
    sub $I11, rx1704_pos, rx1704_off
    ord $I11, rx1704_tgt, $I11
    ne $I11, 58, rx1704_fail
    add rx1704_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1704_cur."!cursor_pos"(rx1704_pos)
    $P10 = rx1704_cur."arglist"()
    unless $P10, rx1704_fail
    rx1704_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1704_pos = $P10."pos"()
    goto alt1710_end
  alt1710_3:
    set_addr $I10, alt1710_4
    rx1704_cur."!mark_push"(0, rx1704_pos, $I10)
.annotate 'line', 718
  # rx literal  "("
    add $I11, rx1704_pos, 1
    gt $I11, rx1704_eos, rx1704_fail
    sub $I11, rx1704_pos, rx1704_off
    ord $I11, rx1704_tgt, $I11
    ne $I11, 40, rx1704_fail
    add rx1704_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1704_cur."!cursor_pos"(rx1704_pos)
    $P10 = rx1704_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1704_fail
    rx1704_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1704_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1704_pos, 1
    gt $I11, rx1704_eos, rx1704_fail
    sub $I11, rx1704_pos, rx1704_off
    ord $I11, rx1704_tgt, $I11
    ne $I11, 41, rx1704_fail
    add rx1704_pos, 1
    goto alt1710_end
  alt1710_4:
.annotate 'line', 719
  # rx subrule "normspace" subtype=method negate=
    rx1704_cur."!cursor_pos"(rx1704_pos)
    $P10 = rx1704_cur."normspace"()
    unless $P10, rx1704_fail
    rx1704_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1704_cur."!cursor_pos"(rx1704_pos)
    $P10 = rx1704_cur."nibbler"()
    unless $P10, rx1704_fail
    rx1704_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1704_pos = $P10."pos"()
  alt1710_end:
.annotate 'line', 720
    set_addr $I10, rxquantr1709_done
    (rx1704_rep) = rx1704_cur."!mark_commit"($I10)
  rxquantr1709_done:
.annotate 'line', 712
  # rx pass
    rx1704_cur."!cursor_pass"(rx1704_pos, "assertion:sym<name>")
    if_null rx1704_debug, debug_1196
    rx1704_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1704_pos)
  debug_1196:
    .return (rx1704_cur)
  rx1704_restart:
.annotate 'line', 691
    if_null rx1704_debug, debug_1197
    rx1704_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1197:
  rx1704_fail:
    (rx1704_rep, rx1704_pos, $I10, $P10) = rx1704_cur."!mark_fail"(0)
    lt rx1704_pos, -1, rx1704_done
    eq rx1704_pos, -1, rx1704_fail
    jump $I10
  rx1704_done:
    rx1704_cur."!cursor_fail"()
    if_null rx1704_debug, debug_1198
    rx1704_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1198:
    .return (rx1704_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("396_1300051172.188") :method
.annotate 'line', 691
    $P1706 = self."!PREFIX__!subrule"("identifier", "")
    new $P1707, "ResizablePMCArray"
    push $P1707, $P1706
    .return ($P1707)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1711"  :anon :subid("397_1300051172.188") :method :outer("395_1300051172.188")
.annotate 'line', 715
    .local string rx1713_tgt
    .local int rx1713_pos
    .local int rx1713_off
    .local int rx1713_eos
    .local int rx1713_rep
    .local pmc rx1713_cur
    .local pmc rx1713_debug
    (rx1713_cur, rx1713_pos, rx1713_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1713_cur
    .local pmc match
    .lex "$/", match
    length rx1713_eos, rx1713_tgt
    gt rx1713_pos, rx1713_eos, rx1713_done
    set rx1713_off, 0
    lt rx1713_pos, 2, rx1713_start
    sub rx1713_off, rx1713_pos, 1
    substr rx1713_tgt, rx1713_tgt, rx1713_off
  rx1713_start:
    eq $I10, 1, rx1713_restart
    if_null rx1713_debug, debug_1192
    rx1713_cur."!cursor_debug"("START", "")
  debug_1192:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1714_done
    goto rxscan1714_scan
  rxscan1714_loop:
    (rx1713_pos) = rx1713_cur."from"()
    inc rx1713_pos
    rx1713_cur."!cursor_from"(rx1713_pos)
    ge rx1713_pos, rx1713_eos, rxscan1714_done
  rxscan1714_scan:
    set_addr $I10, rxscan1714_loop
    rx1713_cur."!mark_push"(0, rx1713_pos, $I10)
  rxscan1714_done:
  # rx literal  ">"
    add $I11, rx1713_pos, 1
    gt $I11, rx1713_eos, rx1713_fail
    sub $I11, rx1713_pos, rx1713_off
    ord $I11, rx1713_tgt, $I11
    ne $I11, 62, rx1713_fail
    add rx1713_pos, 1
  # rx pass
    rx1713_cur."!cursor_pass"(rx1713_pos, "")
    if_null rx1713_debug, debug_1193
    rx1713_cur."!cursor_debug"("PASS", "", " at pos=", rx1713_pos)
  debug_1193:
    .return (rx1713_cur)
  rx1713_restart:
    if_null rx1713_debug, debug_1194
    rx1713_cur."!cursor_debug"("NEXT", "")
  debug_1194:
  rx1713_fail:
    (rx1713_rep, rx1713_pos, $I10, $P10) = rx1713_cur."!mark_fail"(0)
    lt rx1713_pos, -1, rx1713_done
    eq rx1713_pos, -1, rx1713_fail
    jump $I10
  rx1713_done:
    rx1713_cur."!cursor_fail"()
    if_null rx1713_debug, debug_1195
    rx1713_cur."!cursor_debug"("FAIL", "")
  debug_1195:
    .return (rx1713_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("398_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .local string rx1716_tgt
    .local int rx1716_pos
    .local int rx1716_off
    .local int rx1716_eos
    .local int rx1716_rep
    .local pmc rx1716_cur
    .local pmc rx1716_debug
    (rx1716_cur, rx1716_pos, rx1716_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1716_cur
    .local pmc match
    .lex "$/", match
    length rx1716_eos, rx1716_tgt
    gt rx1716_pos, rx1716_eos, rx1716_done
    set rx1716_off, 0
    lt rx1716_pos, 2, rx1716_start
    sub rx1716_off, rx1716_pos, 1
    substr rx1716_tgt, rx1716_tgt, rx1716_off
  rx1716_start:
    eq $I10, 1, rx1716_restart
    if_null rx1716_debug, debug_1199
    rx1716_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1719_done
    goto rxscan1719_scan
  rxscan1719_loop:
    (rx1716_pos) = rx1716_cur."from"()
    inc rx1716_pos
    rx1716_cur."!cursor_from"(rx1716_pos)
    ge rx1716_pos, rx1716_eos, rxscan1719_done
  rxscan1719_scan:
    set_addr $I10, rxscan1719_loop
    rx1716_cur."!mark_push"(0, rx1716_pos, $I10)
  rxscan1719_done:
.annotate 'line', 724
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1716_pos, rx1716_off
    substr $S10, rx1716_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1716_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1716_cur."!cursor_pos"(rx1716_pos)
    $P10 = rx1716_cur."LANG"("MAIN", "variable")
    unless $P10, rx1716_fail
    rx1716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1716_pos = $P10."pos"()
.annotate 'line', 723
  # rx pass
    rx1716_cur."!cursor_pass"(rx1716_pos, "assertion:sym<var>")
    if_null rx1716_debug, debug_1200
    rx1716_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1716_pos)
  debug_1200:
    .return (rx1716_cur)
  rx1716_restart:
.annotate 'line', 691
    if_null rx1716_debug, debug_1201
    rx1716_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1201:
  rx1716_fail:
    (rx1716_rep, rx1716_pos, $I10, $P10) = rx1716_cur."!mark_fail"(0)
    lt rx1716_pos, -1, rx1716_done
    eq rx1716_pos, -1, rx1716_fail
    jump $I10
  rx1716_done:
    rx1716_cur."!cursor_fail"()
    if_null rx1716_debug, debug_1202
    rx1716_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1202:
    .return (rx1716_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("399_1300051172.188") :method
.annotate 'line', 691
    new $P1718, "ResizablePMCArray"
    push $P1718, "$"
    push $P1718, "@"
    .return ($P1718)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("400_1300051172.188") :method :outer("381_1300051172.188")
.annotate 'line', 691
    .local string rx1721_tgt
    .local int rx1721_pos
    .local int rx1721_off
    .local int rx1721_eos
    .local int rx1721_rep
    .local pmc rx1721_cur
    .local pmc rx1721_debug
    (rx1721_cur, rx1721_pos, rx1721_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1721_cur
    .local pmc match
    .lex "$/", match
    length rx1721_eos, rx1721_tgt
    gt rx1721_pos, rx1721_eos, rx1721_done
    set rx1721_off, 0
    lt rx1721_pos, 2, rx1721_start
    sub rx1721_off, rx1721_pos, 1
    substr rx1721_tgt, rx1721_tgt, rx1721_off
  rx1721_start:
    eq $I10, 1, rx1721_restart
    if_null rx1721_debug, debug_1203
    rx1721_cur."!cursor_debug"("START", "codeblock")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1725_done
    goto rxscan1725_scan
  rxscan1725_loop:
    (rx1721_pos) = rx1721_cur."from"()
    inc rx1721_pos
    rx1721_cur."!cursor_from"(rx1721_pos)
    ge rx1721_pos, rx1721_eos, rxscan1725_done
  rxscan1725_scan:
    set_addr $I10, rxscan1725_loop
    rx1721_cur."!mark_push"(0, rx1721_pos, $I10)
  rxscan1725_done:
.annotate 'line', 728
  # rx subrule "LANG" subtype=capture negate=
    rx1721_cur."!cursor_pos"(rx1721_pos)
    $P10 = rx1721_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1721_fail
    rx1721_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1721_pos = $P10."pos"()
.annotate 'line', 727
  # rx pass
    rx1721_cur."!cursor_pass"(rx1721_pos, "codeblock")
    if_null rx1721_debug, debug_1204
    rx1721_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1721_pos)
  debug_1204:
    .return (rx1721_cur)
  rx1721_restart:
.annotate 'line', 691
    if_null rx1721_debug, debug_1205
    rx1721_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1205:
  rx1721_fail:
    (rx1721_rep, rx1721_pos, $I10, $P10) = rx1721_cur."!mark_fail"(0)
    lt rx1721_pos, -1, rx1721_done
    eq rx1721_pos, -1, rx1721_fail
    jump $I10
  rx1721_done:
    rx1721_cur."!cursor_fail"()
    if_null rx1721_debug, debug_1206
    rx1721_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1206:
    .return (rx1721_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("401_1300051172.188") :method
.annotate 'line', 691
    $P1723 = self."!PREFIX__!subrule"("LANG", "")
    new $P1724, "ResizablePMCArray"
    push $P1724, $P1723
    .return ($P1724)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1766" :load :anon :subid("403_1300051172.188")
.annotate 'line', 4
    .const 'Sub' $P1768 = "11_1300051172.188" 
    $P1769 = $P1768()
    .return ($P1769)
.end


.HLL "nqp"

.namespace []
.sub "_block2502" :load :anon :subid("405_1300051172.188")
.annotate 'line', 1
    .const 'Sub' $P2504 = "10_1300051172.188" 
    $P2505 = $P2504()
    .return ($P2505)
.end

### .include 'gen/nqp-actions.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300051186.829")
.annotate 'line', 0
    get_hll_global $P17, ["NQP";"Actions"], "_block16" 
    capture_lex $P17
.annotate 'line', 1
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P17, ["NQP";"Actions"], "_block16" 
    capture_lex $P17
    $P3342 = $P17()
.annotate 'line', 1
    .return ($P3342)
    .const 'Sub' $P3344 = "174_1300051186.829" 
    .return ($P3344)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post175") :outer("10_1300051186.829")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300051186.829" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P3348, "1300051176.112"
    isnull $I3349, $P3348
    if $I3349, if_3347
    nqp_get_sc_object $P3359, "1300051176.112", 1
    set_hll_global ["NQP"], "RegexActions", $P3359
    nqp_get_sc_object $P3360, "1300051176.112", 0
    set_hll_global ["NQP"], "Actions", $P3360
    goto if_3347_end
  if_3347:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P3350, "1300051176.112"
    .local pmc cur_sc
    set cur_sc, $P3350
    load_bytecode "SettingManager.pbc"
    get_hll_global $P3351, ["HLL"], "SettingManager"
    $P3352 = $P3351."load_setting"("NQPCORE")
    block."set_outer_ctx"($P3352)
    get_hll_global $P3353, "NQPClassHOW"
    $P3354 = $P3353."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P3354, cur_sc
    nqp_set_sc_object "1300051176.112", 0, $P3354
    get_hll_global $P3355, "NQPClassHOW"
    $P3356 = $P3355."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P3356, cur_sc
    nqp_set_sc_object "1300051176.112", 1, $P3356
    nqp_get_sc_object $P3357, "1300051176.112", 1
    set_hll_global ["NQP"], "RegexActions", $P3357
    nqp_get_sc_object $P3358, "1300051176.112", 0
    set_hll_global ["NQP"], "Actions", $P3358
  if_3347_end:
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block16"  :subid("11_1300051186.829") :outer("10_1300051186.829")
.annotate 'line', 3
    .const 'Sub' $P3120 = "173_1300051186.829" 
    capture_lex $P3120
    get_hll_global $P2983, ["NQP";"RegexActions"], "_block2982" 
    capture_lex $P2983
    .const 'Sub' $P2974 = "162_1300051186.829" 
    capture_lex $P2974
    .const 'Sub' $P2969 = "161_1300051186.829" 
    capture_lex $P2969
    .const 'Sub' $P2964 = "160_1300051186.829" 
    capture_lex $P2964
    .const 'Sub' $P2959 = "159_1300051186.829" 
    capture_lex $P2959
    .const 'Sub' $P2948 = "158_1300051186.829" 
    capture_lex $P2948
    .const 'Sub' $P2940 = "157_1300051186.829" 
    capture_lex $P2940
    .const 'Sub' $P2932 = "156_1300051186.829" 
    capture_lex $P2932
    .const 'Sub' $P2924 = "155_1300051186.829" 
    capture_lex $P2924
    .const 'Sub' $P2919 = "154_1300051186.829" 
    capture_lex $P2919
    .const 'Sub' $P2907 = "153_1300051186.829" 
    capture_lex $P2907
    .const 'Sub' $P2899 = "152_1300051186.829" 
    capture_lex $P2899
    .const 'Sub' $P2861 = "151_1300051186.829" 
    capture_lex $P2861
    .const 'Sub' $P2849 = "150_1300051186.829" 
    capture_lex $P2849
    .const 'Sub' $P2841 = "149_1300051186.829" 
    capture_lex $P2841
    .const 'Sub' $P2833 = "148_1300051186.829" 
    capture_lex $P2833
    .const 'Sub' $P2825 = "147_1300051186.829" 
    capture_lex $P2825
    .const 'Sub' $P2817 = "146_1300051186.829" 
    capture_lex $P2817
    .const 'Sub' $P2809 = "145_1300051186.829" 
    capture_lex $P2809
    .const 'Sub' $P2783 = "144_1300051186.829" 
    capture_lex $P2783
    .const 'Sub' $P2768 = "143_1300051186.829" 
    capture_lex $P2768
    .const 'Sub' $P2760 = "142_1300051186.829" 
    capture_lex $P2760
    .const 'Sub' $P2749 = "141_1300051186.829" 
    capture_lex $P2749
    .const 'Sub' $P2738 = "140_1300051186.829" 
    capture_lex $P2738
    .const 'Sub' $P2727 = "139_1300051186.829" 
    capture_lex $P2727
    .const 'Sub' $P2719 = "138_1300051186.829" 
    capture_lex $P2719
    .const 'Sub' $P2692 = "137_1300051186.829" 
    capture_lex $P2692
    .const 'Sub' $P2654 = "135_1300051186.829" 
    capture_lex $P2654
    .const 'Sub' $P2646 = "134_1300051186.829" 
    capture_lex $P2646
    .const 'Sub' $P2638 = "133_1300051186.829" 
    capture_lex $P2638
    .const 'Sub' $P2613 = "132_1300051186.829" 
    capture_lex $P2613
    .const 'Sub' $P2597 = "131_1300051186.829" 
    capture_lex $P2597
    .const 'Sub' $P2589 = "130_1300051186.829" 
    capture_lex $P2589
    .const 'Sub' $P2581 = "129_1300051186.829" 
    capture_lex $P2581
    .const 'Sub' $P2479 = "126_1300051186.829" 
    capture_lex $P2479
    .const 'Sub' $P2471 = "125_1300051186.829" 
    capture_lex $P2471
    .const 'Sub' $P2464 = "124_1300051186.829" 
    capture_lex $P2464
    .const 'Sub' $P2437 = "123_1300051186.829" 
    capture_lex $P2437
    .const 'Sub' $P2383 = "121_1300051186.829" 
    capture_lex $P2383
    .const 'Sub' $P2369 = "120_1300051186.829" 
    capture_lex $P2369
    .const 'Sub' $P2362 = "119_1300051186.829" 
    capture_lex $P2362
    .const 'Sub' $P2313 = "118_1300051186.829" 
    capture_lex $P2313
    .const 'Sub' $P2148 = "114_1300051186.829" 
    capture_lex $P2148
    .const 'Sub' $P2085 = "112_1300051186.829" 
    capture_lex $P2085
    .const 'Sub' $P2077 = "111_1300051186.829" 
    capture_lex $P2077
    .const 'Sub' $P2062 = "110_1300051186.829" 
    capture_lex $P2062
    .const 'Sub' $P2047 = "109_1300051186.829" 
    capture_lex $P2047
    .const 'Sub' $P2029 = "108_1300051186.829" 
    capture_lex $P2029
    .const 'Sub' $P1930 = "107_1300051186.829" 
    capture_lex $P1930
    .const 'Sub' $P1886 = "104_1300051186.829" 
    capture_lex $P1886
    .const 'Sub' $P1761 = "101_1300051186.829" 
    capture_lex $P1761
    .const 'Sub' $P1519 = "94_1300051186.829" 
    capture_lex $P1519
    .const 'Sub' $P1511 = "93_1300051186.829" 
    capture_lex $P1511
    .const 'Sub' $P1503 = "92_1300051186.829" 
    capture_lex $P1503
    .const 'Sub' $P1402 = "88_1300051186.829" 
    capture_lex $P1402
    .const 'Sub' $P1394 = "87_1300051186.829" 
    capture_lex $P1394
    .const 'Sub' $P1379 = "86_1300051186.829" 
    capture_lex $P1379
    .const 'Sub' $P1364 = "85_1300051186.829" 
    capture_lex $P1364
    .const 'Sub' $P1349 = "84_1300051186.829" 
    capture_lex $P1349
    .const 'Sub' $P1327 = "83_1300051186.829" 
    capture_lex $P1327
    .const 'Sub' $P1319 = "82_1300051186.829" 
    capture_lex $P1319
    .const 'Sub' $P1311 = "81_1300051186.829" 
    capture_lex $P1311
    .const 'Sub' $P1303 = "80_1300051186.829" 
    capture_lex $P1303
    .const 'Sub' $P1106 = "77_1300051186.829" 
    capture_lex $P1106
    .const 'Sub' $P1098 = "76_1300051186.829" 
    capture_lex $P1098
    .const 'Sub' $P1090 = "75_1300051186.829" 
    capture_lex $P1090
    .const 'Sub' $P1082 = "74_1300051186.829" 
    capture_lex $P1082
    .const 'Sub' $P1074 = "73_1300051186.829" 
    capture_lex $P1074
    .const 'Sub' $P1066 = "72_1300051186.829" 
    capture_lex $P1066
    .const 'Sub' $P1058 = "71_1300051186.829" 
    capture_lex $P1058
    .const 'Sub' $P968 = "69_1300051186.829" 
    capture_lex $P968
    .const 'Sub' $P944 = "68_1300051186.829" 
    capture_lex $P944
    .const 'Sub' $P930 = "67_1300051186.829" 
    capture_lex $P930
    .const 'Sub' $P922 = "66_1300051186.829" 
    capture_lex $P922
    .const 'Sub' $P914 = "65_1300051186.829" 
    capture_lex $P914
    .const 'Sub' $P906 = "64_1300051186.829" 
    capture_lex $P906
    .const 'Sub' $P898 = "63_1300051186.829" 
    capture_lex $P898
    .const 'Sub' $P890 = "62_1300051186.829" 
    capture_lex $P890
    .const 'Sub' $P882 = "61_1300051186.829" 
    capture_lex $P882
    .const 'Sub' $P874 = "60_1300051186.829" 
    capture_lex $P874
    .const 'Sub' $P866 = "59_1300051186.829" 
    capture_lex $P866
    .const 'Sub' $P858 = "58_1300051186.829" 
    capture_lex $P858
    .const 'Sub' $P850 = "57_1300051186.829" 
    capture_lex $P850
    .const 'Sub' $P842 = "56_1300051186.829" 
    capture_lex $P842
    .const 'Sub' $P834 = "55_1300051186.829" 
    capture_lex $P834
    .const 'Sub' $P826 = "54_1300051186.829" 
    capture_lex $P826
    .const 'Sub' $P810 = "53_1300051186.829" 
    capture_lex $P810
    .const 'Sub' $P777 = "52_1300051186.829" 
    capture_lex $P777
    .const 'Sub' $P763 = "51_1300051186.829" 
    capture_lex $P763
    .const 'Sub' $P744 = "50_1300051186.829" 
    capture_lex $P744
    .const 'Sub' $P726 = "49_1300051186.829" 
    capture_lex $P726
    .const 'Sub' $P702 = "48_1300051186.829" 
    capture_lex $P702
    .const 'Sub' $P668 = "47_1300051186.829" 
    capture_lex $P668
    .const 'Sub' $P653 = "46_1300051186.829" 
    capture_lex $P653
    .const 'Sub' $P641 = "45_1300051186.829" 
    capture_lex $P641
    .const 'Sub' $P590 = "43_1300051186.829" 
    capture_lex $P590
    .const 'Sub' $P579 = "42_1300051186.829" 
    capture_lex $P579
    .const 'Sub' $P572 = "41_1300051186.829" 
    capture_lex $P572
    .const 'Sub' $P550 = "40_1300051186.829" 
    capture_lex $P550
    .const 'Sub' $P539 = "39_1300051186.829" 
    capture_lex $P539
    .const 'Sub' $P504 = "37_1300051186.829" 
    capture_lex $P504
    .const 'Sub' $P496 = "36_1300051186.829" 
    capture_lex $P496
    .const 'Sub' $P488 = "35_1300051186.829" 
    capture_lex $P488
    .const 'Sub' $P474 = "34_1300051186.829" 
    capture_lex $P474
    .const 'Sub' $P393 = "32_1300051186.829" 
    capture_lex $P393
    .const 'Sub' $P352 = "30_1300051186.829" 
    capture_lex $P352
    .const 'Sub' $P305 = "29_1300051186.829" 
    capture_lex $P305
    .const 'Sub' $P274 = "28_1300051186.829" 
    capture_lex $P274
    .const 'Sub' $P266 = "27_1300051186.829" 
    capture_lex $P266
    .const 'Sub' $P258 = "25_1300051186.829" 
    capture_lex $P258
    .const 'Sub' $P244 = "24_1300051186.829" 
    capture_lex $P244
    .const 'Sub' $P218 = "22_1300051186.829" 
    capture_lex $P218
    .const 'Sub' $P153 = "20_1300051186.829" 
    capture_lex $P153
    .const 'Sub' $P143 = "19_1300051186.829" 
    capture_lex $P143
    .const 'Sub' $P95 = "18_1300051186.829" 
    capture_lex $P95
    .const 'Sub' $P82 = "17_1300051186.829" 
    capture_lex $P82
    .const 'Sub' $P64 = "16_1300051186.829" 
    capture_lex $P64
    .const 'Sub' $P31 = "13_1300051186.829" 
    capture_lex $P31
    .const 'Sub' $P23 = "12_1300051186.829" 
    capture_lex $P23
    get_global $P18, "$?CLASS"
    getinterp $P19
    get_class $P20, "LexPad"
    get_class $P21, "NQPLexPad"
    $P19."hll_map"($P20, $P21)
    get_global $P22, "@BLOCK"
    unless_null $P22, vivify_177
    $P22 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P22
  vivify_177:
.annotate 'line', 9
    .const 'Sub' $P23 = "12_1300051186.829" 
    newclosure $P30, $P23
    .lex "xblock_immediate", $P30
.annotate 'line', 14
    .const 'Sub' $P31 = "13_1300051186.829" 
    newclosure $P63, $P31
    .lex "block_immediate", $P63
.annotate 'line', 24
    .const 'Sub' $P64 = "16_1300051186.829" 
    newclosure $P81, $P64
    .lex "vivitype", $P81
.annotate 'line', 43
    .const 'Sub' $P82 = "17_1300051186.829" 
    newclosure $P94, $P82
    .lex "colonpair_str", $P94
.annotate 'line', 262
    .const 'Sub' $P95 = "18_1300051186.829" 
    newclosure $P142, $P95
    .lex "push_block_handler", $P142
.annotate 'line', 799
    .const 'Sub' $P143 = "19_1300051186.829" 
    newclosure $P152, $P143
    .lex "only_star_block", $P152
.annotate 'line', 808
    .const 'Sub' $P153 = "20_1300051186.829" 
    newclosure $P217, $P153
    .lex "attach_multi_signature", $P217
.annotate 'line', 1096
    .const 'Sub' $P218 = "22_1300051186.829" 
    newclosure $P243, $P218
    .lex "is_lexical", $P243
.annotate 'line', 1304
    .const 'Sub' $P244 = "24_1300051186.829" 
    newclosure $P255, $P244
    .lex "control", $P255
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P256, "@BLOCK"
    .const 'Sub' $P258 = "25_1300051186.829" 
    capture_lex $P258
    $P258()
    find_lex $P263, "xblock_immediate"
    find_lex $P264, "block_immediate"
    find_lex $P265, "vivitype"
.annotate 'line', 35
    find_lex $P304, "colonpair_str"
.annotate 'line', 255
    find_lex $P762, "push_block_handler"
.annotate 'line', 727
    find_lex $P1884, "only_star_block"
    find_lex $P1885, "attach_multi_signature"
.annotate 'line', 1074
    find_lex $P2436, "is_lexical"
.annotate 'line', 1295
    find_lex $P2958, "control"
.annotate 'line', 1322
    get_hll_global $P2983, ["NQP";"RegexActions"], "_block2982" 
    capture_lex $P2983
    $P3102 = $P2983()
.annotate 'line', 3
    .return ($P3102)
    .const 'Sub' $P3104 = "172_1300051186.829" 
    .return ($P3104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post176") :outer("11_1300051186.829")
.annotate 'line', 3
    get_hll_global $P17, ["NQP";"Actions"], "_block16" 
    .local pmc block
    set block, $P17
    nqp_get_sc $P3108, "1300051176.112"
    isnull $I3109, $P3108
    if $I3109, if_3107
    nqp_get_sc_object $P3118, "1300051176.112", 1
    set_hll_global ["NQP"], "RegexActions", $P3118
    goto if_3107_end
  if_3107:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P3110, "1300051176.112"
    .local pmc cur_sc
    set cur_sc, $P3110
    load_bytecode "SettingManager.pbc"
    get_hll_global $P3111, ["HLL"], "SettingManager"
    $P3112 = $P3111."load_setting"("NQPCORE")
    block."set_outer_ctx"($P3112)
    get_hll_global $P3113, "NQPClassHOW"
    $P3114 = $P3113."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P3114, cur_sc
    nqp_set_sc_object "1300051176.112", 0, $P3114
    get_hll_global $P3115, "NQPClassHOW"
    $P3116 = $P3115."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P3116, cur_sc
    nqp_set_sc_object "1300051176.112", 1, $P3116
    nqp_get_sc_object $P3117, "1300051176.112", 1
    set_hll_global ["NQP"], "RegexActions", $P3117
  if_3107_end:
    .const 'Sub' $P3120 = "173_1300051186.829" 
    capture_lex $P3120
    $P3120()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3119"  :anon :subid("173_1300051186.829") :outer("11_1300051186.829")
.annotate 'line', 3
    nqp_get_sc_object $P3121, "1300051176.112", 0
    .local pmc type_obj
    set type_obj, $P3121
    set_global "$?CLASS", type_obj
    get_how $P3122, type_obj
    .const 'Sub' $P3123 = "27_1300051186.829" 
    $P3122."add_method"(type_obj, "TOP", $P3123)
    get_how $P3124, type_obj
    .const 'Sub' $P3125 = "28_1300051186.829" 
    $P3124."add_method"(type_obj, "deflongname", $P3125)
    get_how $P3126, type_obj
    .const 'Sub' $P3127 = "29_1300051186.829" 
    $P3126."add_method"(type_obj, "comp_unit", $P3127)
    get_how $P3128, type_obj
    .const 'Sub' $P3129 = "30_1300051186.829" 
    $P3128."add_method"(type_obj, "statementlist", $P3129)
    get_how $P3130, type_obj
    .const 'Sub' $P3131 = "32_1300051186.829" 
    $P3130."add_method"(type_obj, "statement", $P3131)
    get_how $P3132, type_obj
    .const 'Sub' $P3133 = "34_1300051186.829" 
    $P3132."add_method"(type_obj, "xblock", $P3133)
    get_how $P3134, type_obj
    .const 'Sub' $P3135 = "35_1300051186.829" 
    $P3134."add_method"(type_obj, "pblock", $P3135)
    get_how $P3136, type_obj
    .const 'Sub' $P3137 = "36_1300051186.829" 
    $P3136."add_method"(type_obj, "block", $P3137)
    get_how $P3138, type_obj
    .const 'Sub' $P3139 = "37_1300051186.829" 
    $P3138."add_method"(type_obj, "blockoid", $P3139)
    get_how $P3140, type_obj
    .const 'Sub' $P3141 = "39_1300051186.829" 
    $P3140."add_method"(type_obj, "newpad", $P3141)
    get_how $P3142, type_obj
    .const 'Sub' $P3143 = "40_1300051186.829" 
    $P3142."add_method"(type_obj, "outerctx", $P3143)
    get_how $P3144, type_obj
    .const 'Sub' $P3145 = "41_1300051186.829" 
    $P3144."add_method"(type_obj, "you_are_here", $P3145)
    get_how $P3146, type_obj
    .const 'Sub' $P3147 = "42_1300051186.829" 
    $P3146."add_method"(type_obj, "statement_control:sym<use>", $P3147)
    get_how $P3148, type_obj
    .const 'Sub' $P3149 = "43_1300051186.829" 
    $P3148."add_method"(type_obj, "statement_control:sym<if>", $P3149)
    get_how $P3150, type_obj
    .const 'Sub' $P3151 = "45_1300051186.829" 
    $P3150."add_method"(type_obj, "statement_control:sym<unless>", $P3151)
    get_how $P3152, type_obj
    .const 'Sub' $P3153 = "46_1300051186.829" 
    $P3152."add_method"(type_obj, "statement_control:sym<while>", $P3153)
    get_how $P3154, type_obj
    .const 'Sub' $P3155 = "47_1300051186.829" 
    $P3154."add_method"(type_obj, "statement_control:sym<repeat>", $P3155)
    get_how $P3156, type_obj
    .const 'Sub' $P3157 = "48_1300051186.829" 
    $P3156."add_method"(type_obj, "statement_control:sym<for>", $P3157)
    get_how $P3158, type_obj
    .const 'Sub' $P3159 = "49_1300051186.829" 
    $P3158."add_method"(type_obj, "statement_control:sym<CATCH>", $P3159)
    get_how $P3160, type_obj
    .const 'Sub' $P3161 = "50_1300051186.829" 
    $P3160."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3161)
    get_how $P3162, type_obj
    .const 'Sub' $P3163 = "51_1300051186.829" 
    $P3162."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3163)
    get_how $P3164, type_obj
    .const 'Sub' $P3165 = "52_1300051186.829" 
    $P3164."add_method"(type_obj, "statement_prefix:sym<try>", $P3165)
    get_how $P3166, type_obj
    .const 'Sub' $P3167 = "53_1300051186.829" 
    $P3166."add_method"(type_obj, "blorst", $P3167)
    get_how $P3168, type_obj
    .const 'Sub' $P3169 = "54_1300051186.829" 
    $P3168."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3169)
    get_how $P3170, type_obj
    .const 'Sub' $P3171 = "55_1300051186.829" 
    $P3170."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3171)
    get_how $P3172, type_obj
    .const 'Sub' $P3173 = "56_1300051186.829" 
    $P3172."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3173)
    get_how $P3174, type_obj
    .const 'Sub' $P3175 = "57_1300051186.829" 
    $P3174."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3175)
    get_how $P3176, type_obj
    .const 'Sub' $P3177 = "58_1300051186.829" 
    $P3176."add_method"(type_obj, "term:sym<fatarrow>", $P3177)
    get_how $P3178, type_obj
    .const 'Sub' $P3179 = "59_1300051186.829" 
    $P3178."add_method"(type_obj, "term:sym<colonpair>", $P3179)
    get_how $P3180, type_obj
    .const 'Sub' $P3181 = "60_1300051186.829" 
    $P3180."add_method"(type_obj, "term:sym<variable>", $P3181)
    get_how $P3182, type_obj
    .const 'Sub' $P3183 = "61_1300051186.829" 
    $P3182."add_method"(type_obj, "term:sym<package_declarator>", $P3183)
    get_how $P3184, type_obj
    .const 'Sub' $P3185 = "62_1300051186.829" 
    $P3184."add_method"(type_obj, "term:sym<scope_declarator>", $P3185)
    get_how $P3186, type_obj
    .const 'Sub' $P3187 = "63_1300051186.829" 
    $P3186."add_method"(type_obj, "term:sym<routine_declarator>", $P3187)
    get_how $P3188, type_obj
    .const 'Sub' $P3189 = "64_1300051186.829" 
    $P3188."add_method"(type_obj, "term:sym<regex_declarator>", $P3189)
    get_how $P3190, type_obj
    .const 'Sub' $P3191 = "65_1300051186.829" 
    $P3190."add_method"(type_obj, "term:sym<statement_prefix>", $P3191)
    get_how $P3192, type_obj
    .const 'Sub' $P3193 = "66_1300051186.829" 
    $P3192."add_method"(type_obj, "term:sym<lambda>", $P3193)
    get_how $P3194, type_obj
    .const 'Sub' $P3195 = "67_1300051186.829" 
    $P3194."add_method"(type_obj, "fatarrow", $P3195)
    get_how $P3196, type_obj
    .const 'Sub' $P3197 = "68_1300051186.829" 
    $P3196."add_method"(type_obj, "colonpair", $P3197)
    get_how $P3198, type_obj
    .const 'Sub' $P3199 = "69_1300051186.829" 
    $P3198."add_method"(type_obj, "variable", $P3199)
    get_how $P3200, type_obj
    .const 'Sub' $P3201 = "71_1300051186.829" 
    $P3200."add_method"(type_obj, "package_declarator:sym<module>", $P3201)
    get_how $P3202, type_obj
    .const 'Sub' $P3203 = "72_1300051186.829" 
    $P3202."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3203)
    get_how $P3204, type_obj
    .const 'Sub' $P3205 = "73_1300051186.829" 
    $P3204."add_method"(type_obj, "package_declarator:sym<class>", $P3205)
    get_how $P3206, type_obj
    .const 'Sub' $P3207 = "74_1300051186.829" 
    $P3206."add_method"(type_obj, "package_declarator:sym<grammar>", $P3207)
    get_how $P3208, type_obj
    .const 'Sub' $P3209 = "75_1300051186.829" 
    $P3208."add_method"(type_obj, "package_declarator:sym<role>", $P3209)
    get_how $P3210, type_obj
    .const 'Sub' $P3211 = "76_1300051186.829" 
    $P3210."add_method"(type_obj, "package_declarator:sym<native>", $P3211)
    get_how $P3212, type_obj
    .const 'Sub' $P3213 = "77_1300051186.829" 
    $P3212."add_method"(type_obj, "package_def", $P3213)
    get_how $P3214, type_obj
    .const 'Sub' $P3215 = "80_1300051186.829" 
    $P3214."add_method"(type_obj, "scope_declarator:sym<my>", $P3215)
    get_how $P3216, type_obj
    .const 'Sub' $P3217 = "81_1300051186.829" 
    $P3216."add_method"(type_obj, "scope_declarator:sym<our>", $P3217)
    get_how $P3218, type_obj
    .const 'Sub' $P3219 = "82_1300051186.829" 
    $P3218."add_method"(type_obj, "scope_declarator:sym<has>", $P3219)
    get_how $P3220, type_obj
    .const 'Sub' $P3221 = "83_1300051186.829" 
    $P3220."add_method"(type_obj, "scoped", $P3221)
    get_how $P3222, type_obj
    .const 'Sub' $P3223 = "84_1300051186.829" 
    $P3222."add_method"(type_obj, "declarator", $P3223)
    get_how $P3224, type_obj
    .const 'Sub' $P3225 = "85_1300051186.829" 
    $P3224."add_method"(type_obj, "multi_declarator:sym<multi>", $P3225)
    get_how $P3226, type_obj
    .const 'Sub' $P3227 = "86_1300051186.829" 
    $P3226."add_method"(type_obj, "multi_declarator:sym<proto>", $P3227)
    get_how $P3228, type_obj
    .const 'Sub' $P3229 = "87_1300051186.829" 
    $P3228."add_method"(type_obj, "multi_declarator:sym<null>", $P3229)
    get_how $P3230, type_obj
    .const 'Sub' $P3231 = "88_1300051186.829" 
    $P3230."add_method"(type_obj, "variable_declarator", $P3231)
    get_how $P3232, type_obj
    .const 'Sub' $P3233 = "92_1300051186.829" 
    $P3232."add_method"(type_obj, "routine_declarator:sym<sub>", $P3233)
    get_how $P3234, type_obj
    .const 'Sub' $P3235 = "93_1300051186.829" 
    $P3234."add_method"(type_obj, "routine_declarator:sym<method>", $P3235)
    get_how $P3236, type_obj
    .const 'Sub' $P3237 = "94_1300051186.829" 
    $P3236."add_method"(type_obj, "routine_def", $P3237)
    get_how $P3238, type_obj
    .const 'Sub' $P3239 = "101_1300051186.829" 
    $P3238."add_method"(type_obj, "method_def", $P3239)
    get_how $P3240, type_obj
    .const 'Sub' $P3241 = "104_1300051186.829" 
    $P3240."add_method"(type_obj, "signature", $P3241)
    get_how $P3242, type_obj
    .const 'Sub' $P3243 = "107_1300051186.829" 
    $P3242."add_method"(type_obj, "parameter", $P3243)
    get_how $P3244, type_obj
    .const 'Sub' $P3245 = "108_1300051186.829" 
    $P3244."add_method"(type_obj, "param_var", $P3245)
    get_how $P3246, type_obj
    .const 'Sub' $P3247 = "109_1300051186.829" 
    $P3246."add_method"(type_obj, "named_param", $P3247)
    get_how $P3248, type_obj
    .const 'Sub' $P3249 = "110_1300051186.829" 
    $P3248."add_method"(type_obj, "typename", $P3249)
    get_how $P3250, type_obj
    .const 'Sub' $P3251 = "111_1300051186.829" 
    $P3250."add_method"(type_obj, "trait", $P3251)
    get_how $P3252, type_obj
    .const 'Sub' $P3253 = "112_1300051186.829" 
    $P3252."add_method"(type_obj, "trait_mod:sym<is>", $P3253)
    get_how $P3254, type_obj
    .const 'Sub' $P3255 = "114_1300051186.829" 
    $P3254."add_method"(type_obj, "regex_declarator", $P3255)
    get_how $P3256, type_obj
    .const 'Sub' $P3257 = "118_1300051186.829" 
    $P3256."add_method"(type_obj, "dotty", $P3257)
    get_how $P3258, type_obj
    .const 'Sub' $P3259 = "119_1300051186.829" 
    $P3258."add_method"(type_obj, "term:sym<self>", $P3259)
    get_how $P3260, type_obj
    .const 'Sub' $P3261 = "120_1300051186.829" 
    $P3260."add_method"(type_obj, "term:sym<identifier>", $P3261)
    get_how $P3262, type_obj
    .const 'Sub' $P3263 = "121_1300051186.829" 
    $P3262."add_method"(type_obj, "term:sym<name>", $P3263)
    get_how $P3264, type_obj
    .const 'Sub' $P3265 = "123_1300051186.829" 
    $P3264."add_method"(type_obj, "term:sym<pir::op>", $P3265)
    get_how $P3266, type_obj
    .const 'Sub' $P3267 = "124_1300051186.829" 
    $P3266."add_method"(type_obj, "term:sym<onlystar>", $P3267)
    get_how $P3268, type_obj
    .const 'Sub' $P3269 = "125_1300051186.829" 
    $P3268."add_method"(type_obj, "args", $P3269)
    get_how $P3270, type_obj
    .const 'Sub' $P3271 = "126_1300051186.829" 
    $P3270."add_method"(type_obj, "arglist", $P3271)
    get_how $P3272, type_obj
    .const 'Sub' $P3273 = "129_1300051186.829" 
    $P3272."add_method"(type_obj, "term:sym<multi_declarator>", $P3273)
    get_how $P3274, type_obj
    .const 'Sub' $P3275 = "130_1300051186.829" 
    $P3274."add_method"(type_obj, "term:sym<value>", $P3275)
    get_how $P3276, type_obj
    .const 'Sub' $P3277 = "131_1300051186.829" 
    $P3276."add_method"(type_obj, "circumfix:sym<( )>", $P3277)
    get_how $P3278, type_obj
    .const 'Sub' $P3279 = "132_1300051186.829" 
    $P3278."add_method"(type_obj, "circumfix:sym<[ ]>", $P3279)
    get_how $P3280, type_obj
    .const 'Sub' $P3281 = "133_1300051186.829" 
    $P3280."add_method"(type_obj, "circumfix:sym<ang>", $P3281)
    get_how $P3282, type_obj
    .const 'Sub' $P3283 = "134_1300051186.829" 
    $P3282."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3283)
    get_how $P3284, type_obj
    .const 'Sub' $P3285 = "135_1300051186.829" 
    $P3284."add_method"(type_obj, "circumfix:sym<{ }>", $P3285)
    get_how $P3286, type_obj
    .const 'Sub' $P3287 = "137_1300051186.829" 
    $P3286."add_method"(type_obj, "circumfix:sym<sigil>", $P3287)
    get_how $P3288, type_obj
    .const 'Sub' $P3289 = "138_1300051186.829" 
    $P3288."add_method"(type_obj, "semilist", $P3289)
    get_how $P3290, type_obj
    .const 'Sub' $P3291 = "139_1300051186.829" 
    $P3290."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3291)
    get_how $P3292, type_obj
    .const 'Sub' $P3293 = "140_1300051186.829" 
    $P3292."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3293)
    get_how $P3294, type_obj
    .const 'Sub' $P3295 = "141_1300051186.829" 
    $P3294."add_method"(type_obj, "postcircumfix:sym<ang>", $P3295)
    get_how $P3296, type_obj
    .const 'Sub' $P3297 = "142_1300051186.829" 
    $P3296."add_method"(type_obj, "postcircumfix:sym<( )>", $P3297)
    get_how $P3298, type_obj
    .const 'Sub' $P3299 = "143_1300051186.829" 
    $P3298."add_method"(type_obj, "value", $P3299)
    get_how $P3300, type_obj
    .const 'Sub' $P3301 = "144_1300051186.829" 
    $P3300."add_method"(type_obj, "number", $P3301)
    get_how $P3302, type_obj
    .const 'Sub' $P3303 = "145_1300051186.829" 
    $P3302."add_method"(type_obj, "quote:sym<apos>", $P3303)
    get_how $P3304, type_obj
    .const 'Sub' $P3305 = "146_1300051186.829" 
    $P3304."add_method"(type_obj, "quote:sym<dblq>", $P3305)
    get_how $P3306, type_obj
    .const 'Sub' $P3307 = "147_1300051186.829" 
    $P3306."add_method"(type_obj, "quote:sym<qq>", $P3307)
    get_how $P3308, type_obj
    .const 'Sub' $P3309 = "148_1300051186.829" 
    $P3308."add_method"(type_obj, "quote:sym<q>", $P3309)
    get_how $P3310, type_obj
    .const 'Sub' $P3311 = "149_1300051186.829" 
    $P3310."add_method"(type_obj, "quote:sym<Q>", $P3311)
    get_how $P3312, type_obj
    .const 'Sub' $P3313 = "150_1300051186.829" 
    $P3312."add_method"(type_obj, "quote:sym<Q:PIR>", $P3313)
    get_how $P3314, type_obj
    .const 'Sub' $P3315 = "151_1300051186.829" 
    $P3314."add_method"(type_obj, "quote:sym</ />", $P3315)
    get_how $P3316, type_obj
    .const 'Sub' $P3317 = "152_1300051186.829" 
    $P3316."add_method"(type_obj, "quote_escape:sym<$>", $P3317)
    get_how $P3318, type_obj
    .const 'Sub' $P3319 = "153_1300051186.829" 
    $P3318."add_method"(type_obj, "quote_escape:sym<{ }>", $P3319)
    get_how $P3320, type_obj
    .const 'Sub' $P3321 = "154_1300051186.829" 
    $P3320."add_method"(type_obj, "quote_escape:sym<esc>", $P3321)
    get_how $P3322, type_obj
    .const 'Sub' $P3323 = "155_1300051186.829" 
    $P3322."add_method"(type_obj, "postfix:sym<.>", $P3323)
    get_how $P3324, type_obj
    .const 'Sub' $P3325 = "156_1300051186.829" 
    $P3324."add_method"(type_obj, "postfix:sym<++>", $P3325)
    get_how $P3326, type_obj
    .const 'Sub' $P3327 = "157_1300051186.829" 
    $P3326."add_method"(type_obj, "postfix:sym<-->", $P3327)
    get_how $P3328, type_obj
    .const 'Sub' $P3329 = "158_1300051186.829" 
    $P3328."add_method"(type_obj, "prefix:sym<make>", $P3329)
    get_how $P3330, type_obj
    .const 'Sub' $P3331 = "159_1300051186.829" 
    $P3330."add_method"(type_obj, "term:sym<next>", $P3331)
    get_how $P3332, type_obj
    .const 'Sub' $P3333 = "160_1300051186.829" 
    $P3332."add_method"(type_obj, "term:sym<last>", $P3333)
    get_how $P3334, type_obj
    .const 'Sub' $P3335 = "161_1300051186.829" 
    $P3334."add_method"(type_obj, "term:sym<redo>", $P3335)
    get_how $P3336, type_obj
    .const 'Sub' $P3337 = "162_1300051186.829" 
    $P3336."add_method"(type_obj, "infix:sym<~~>", $P3337)
    get_how $P3338, type_obj
    get_hll_global $P3339, ["HLL"], "Actions"
    $P3338."add_parent"(type_obj, $P3339)
    get_how $P3340, type_obj
    $P3341 = $P3340."compose"(type_obj)
    .return ($P3341)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_24
.annotate 'line', 9
    .lex "$xblock", param_24
.annotate 'line', 10
    find_lex $P25, "$xblock"
    unless_null $P25, vivify_178
    $P25 = root_new ['parrot';'ResizablePMCArray']
  vivify_178:
    set $P26, $P25[1]
    unless_null $P26, vivify_179
    new $P26, "Undef"
  vivify_179:
    $P27 = "block_immediate"($P26)
    find_lex $P28, "$xblock"
    unless_null $P28, vivify_180
    $P28 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P28
  vivify_180:
    set $P28[1], $P27
    find_lex $P29, "$xblock"
.annotate 'line', 9
    .return ($P29)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_32
.annotate 'line', 14
    .const 'Sub' $P42 = "14_1300051186.829" 
    capture_lex $P42
    .lex "$block", param_32
.annotate 'line', 15
    find_lex $P33, "$block"
    $P33."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P37, "$block"
    $P38 = $P37."symtable"()
    unless $P38, unless_36
    set $P35, $P38
    goto unless_36_end
  unless_36:
    find_lex $P39, "$block"
    $P40 = $P39."handlers"()
    set $P35, $P40
  unless_36_end:
    if $P35, unless_34_end
    .const 'Sub' $P42 = "14_1300051186.829" 
    capture_lex $P42
    $P42()
  unless_34_end:
    find_lex $P62, "$block"
.annotate 'line', 14
    .return ($P62)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block41"  :anon :subid("14_1300051186.829") :outer("13_1300051186.829")
.annotate 'line', 16
    .const 'Sub' $P53 = "15_1300051186.829" 
    capture_lex $P53
.annotate 'line', 17
    new $P43, "Undef"
    .lex "$stmts", $P43
    get_hll_global $P44, ["PAST"], "Stmts"
    find_lex $P45, "$block"
    $P46 = $P44."new"($P45 :named("node"))
    store_lex "$stmts", $P46
.annotate 'line', 18
    find_lex $P48, "$block"
    $P49 = $P48."list"()
    defined $I50, $P49
    unless $I50, for_undef_181
    iter $P47, $P49
    new $P59, 'ExceptionHandler'
    set_label $P59, loop58_handler
    $P59."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P59
  loop58_test:
    unless $P47, loop58_done
    shift $P51, $P47
  loop58_redo:
    .const 'Sub' $P53 = "15_1300051186.829" 
    capture_lex $P53
    $P53($P51)
  loop58_next:
    goto loop58_test
  loop58_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P60, exception, 'type'
    eq $P60, .CONTROL_LOOP_NEXT, loop58_next
    eq $P60, .CONTROL_LOOP_REDO, loop58_redo
  loop58_done:
    pop_eh 
  for_undef_181:
.annotate 'line', 19
    find_lex $P61, "$stmts"
    store_lex "$block", $P61
.annotate 'line', 16
    .return ($P61)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block52"  :anon :subid("15_1300051186.829") :outer("14_1300051186.829")
    .param pmc param_54
.annotate 'line', 18
    .lex "$_", param_54
    find_lex $P55, "$stmts"
    find_lex $P56, "$_"
    $P57 = $P55."push"($P56)
    .return ($P57)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_65
.annotate 'line', 24
    .lex "$sigil", param_65
.annotate 'line', 25
    find_lex $P68, "$sigil"
    set $S69, $P68
    iseq $I70, $S69, "%"
    if $I70, if_67
.annotate 'line', 27
    find_lex $P75, "$sigil"
    set $S76, $P75
    iseq $I77, $S76, "@"
    if $I77, if_74
    new $P80, "String"
    assign $P80, "Undef"
    set $P73, $P80
    goto if_74_end
  if_74:
.annotate 'line', 28
    get_hll_global $P78, ["PAST"], "Op"
    $P79 = $P78."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P73, $P79
  if_74_end:
    set $P66, $P73
.annotate 'line', 25
    goto if_67_end
  if_67:
.annotate 'line', 26
    get_hll_global $P71, ["PAST"], "Op"
    $P72 = $P71."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P66, $P72
  if_67_end:
.annotate 'line', 24
    .return ($P66)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_83
.annotate 'line', 43
    .lex "$ast", param_83
.annotate 'line', 44
    get_hll_global $P86, ["PAST"], "Op"
    find_lex $P87, "$ast"
    $P88 = $P86."ACCEPTS"($P87)
    if $P88, if_85
.annotate 'line', 46
    find_lex $P92, "$ast"
    $P93 = $P92."value"()
    set $P84, $P93
.annotate 'line', 44
    goto if_85_end
  if_85:
.annotate 'line', 45
    find_lex $P89, "$ast"
    $P90 = $P89."list"()
    join $S91, " ", $P90
    new $P84, 'String'
    set $P84, $S91
  if_85_end:
.annotate 'line', 43
    .return ($P84)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_96
    .param pmc param_97
.annotate 'line', 262
    .lex "$/", param_96
    .lex "$block", param_97
.annotate 'line', 263
    get_global $P99, "@BLOCK"
    unless_null $P99, vivify_182
    $P99 = root_new ['parrot';'ResizablePMCArray']
  vivify_182:
    set $P100, $P99[0]
    unless_null $P100, vivify_183
    new $P100, "Undef"
  vivify_183:
    $P101 = $P100."handlers"()
    if $P101, unless_98_end
.annotate 'line', 264
    get_global $P102, "@BLOCK"
    unless_null $P102, vivify_184
    $P102 = root_new ['parrot';'ResizablePMCArray']
  vivify_184:
    set $P103, $P102[0]
    unless_null $P103, vivify_185
    new $P103, "Undef"
  vivify_185:
    new $P104, "ResizablePMCArray"
    $P103."handlers"($P104)
  unless_98_end:
.annotate 'line', 266
    find_lex $P106, "$block"
    $P107 = $P106."arity"()
    if $P107, unless_105_end
.annotate 'line', 267
    find_lex $P108, "$block"
.annotate 'line', 268
    get_hll_global $P109, ["PAST"], "Op"
.annotate 'line', 269
    get_hll_global $P110, ["PAST"], "Var"
    $P111 = $P110."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 270
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("lexical" :named("scope"), "$_" :named("name"))
    $P114 = $P109."new"($P111, $P113, "bind" :named("pasttype"))
.annotate 'line', 268
    $P108."unshift"($P114)
.annotate 'line', 273
    find_lex $P115, "$block"
    get_hll_global $P116, ["PAST"], "Var"
    $P117 = $P116."new"("$_" :named("name"), "parameter" :named("scope"))
    $P115."unshift"($P117)
.annotate 'line', 274
    find_lex $P118, "$block"
    $P118."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 275
    find_lex $P119, "$block"
    $P119."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 276
    find_lex $P120, "$block"
    $P120."arity"(1)
  unless_105_end:
.annotate 'line', 278
    find_lex $P121, "$block"
    $P121."blocktype"("declaration")
.annotate 'line', 279
    get_global $P122, "@BLOCK"
    unless_null $P122, vivify_186
    $P122 = root_new ['parrot';'ResizablePMCArray']
  vivify_186:
    set $P123, $P122[0]
    unless_null $P123, vivify_187
    new $P123, "Undef"
  vivify_187:
    $P124 = $P123."handlers"()
.annotate 'line', 280
    get_hll_global $P125, ["PAST"], "Control"
    find_lex $P126, "$/"
.annotate 'line', 282
    get_hll_global $P127, ["PAST"], "Stmts"
.annotate 'line', 283
    get_hll_global $P128, ["PAST"], "Op"
    find_lex $P129, "$block"
.annotate 'line', 285
    get_hll_global $P130, ["PAST"], "Var"
    $P131 = $P130."new"("register" :named("scope"), "exception" :named("name"))
    $P132 = $P128."new"($P129, $P131, "call" :named("pasttype"))
.annotate 'line', 287
    get_hll_global $P133, ["PAST"], "Op"
.annotate 'line', 288
    get_hll_global $P134, ["PAST"], "Var"
.annotate 'line', 289
    get_hll_global $P135, ["PAST"], "Var"
    $P136 = $P135."new"("register" :named("scope"), "exception" :named("name"))
    $P137 = $P134."new"($P136, "handled", "keyed" :named("scope"))
.annotate 'line', 288
    $P138 = $P133."new"($P137, 1, "bind" :named("pasttype"))
.annotate 'line', 287
    $P139 = $P127."new"($P132, $P138)
.annotate 'line', 282
    $P140 = $P125."new"($P139, $P126 :named("node"))
.annotate 'line', 280
    $P141 = $P124."unshift"($P140)
.annotate 'line', 262
    .return ($P141)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1300051186.829") :outer("11_1300051186.829")
.annotate 'line', 800
    new $P144, "Undef"
    .lex "$past", $P144
    get_global $P145, "@BLOCK"
    $P146 = $P145."shift"()
    store_lex "$past", $P146
.annotate 'line', 801
    find_lex $P147, "$past"
    $P147."closure"(1)
.annotate 'line', 802
    find_lex $P148, "$past"
    get_hll_global $P149, ["PAST"], "Op"
    $P150 = $P149."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P148."push"($P150)
    find_lex $P151, "$past"
.annotate 'line', 799
    .return ($P151)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_154
.annotate 'line', 808
    .const 'Sub' $P168 = "21_1300051186.829" 
    capture_lex $P168
    .lex "$routine", param_154
.annotate 'line', 812
    new $P155, "Undef"
    .lex "$types", $P155
.annotate 'line', 813
    new $P156, "Undef"
    .lex "$definednesses", $P156
.annotate 'line', 812
    get_hll_global $P157, ["PAST"], "Op"
    $P158 = $P157."new"("list" :named("pasttype"))
    store_lex "$types", $P158
.annotate 'line', 813
    get_hll_global $P159, ["PAST"], "Op"
    $P160 = $P159."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P160
.annotate 'line', 814
    find_lex $P162, "$routine"
    unless_null $P162, vivify_188
    $P162 = root_new ['parrot';'ResizablePMCArray']
  vivify_188:
    set $P163, $P162[0]
    unless_null $P163, vivify_189
    new $P163, "Undef"
  vivify_189:
    $P164 = $P163."list"()
    defined $I165, $P164
    unless $I165, for_undef_190
    iter $P161, $P164
    new $P206, 'ExceptionHandler'
    set_label $P206, loop205_handler
    $P206."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P206
  loop205_test:
    unless $P161, loop205_done
    shift $P166, $P161
  loop205_redo:
    .const 'Sub' $P168 = "21_1300051186.829" 
    capture_lex $P168
    $P168($P166)
  loop205_next:
    goto loop205_test
  loop205_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P207, exception, 'type'
    eq $P207, .CONTROL_LOOP_NEXT, loop205_next
    eq $P207, .CONTROL_LOOP_REDO, loop205_redo
  loop205_done:
    pop_eh 
  for_undef_190:
.annotate 'line', 821
    find_lex $P208, "$routine"
    $P209 = $P208."loadinit"()
    get_hll_global $P210, ["PAST"], "Op"
.annotate 'line', 822
    get_hll_global $P211, ["PAST"], "Var"
    $P212 = $P211."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P213, "$types"
    find_lex $P214, "$definednesses"
    $P215 = $P210."new"($P212, $P213, $P214, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 821
    $P216 = $P209."push"($P215)
.annotate 'line', 808
    .return ($P216)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block167"  :anon :subid("21_1300051186.829") :outer("20_1300051186.829")
    .param pmc param_169
.annotate 'line', 814
    .lex "$_", param_169
.annotate 'line', 815
    get_hll_global $P174, ["PAST"], "Var"
    find_lex $P175, "$_"
    $P176 = $P174."ACCEPTS"($P175)
    if $P176, if_173
    set $P172, $P176
    goto if_173_end
  if_173:
    find_lex $P177, "$_"
    $S178 = $P177."scope"()
    iseq $I179, $S178, "parameter"
    new $P172, 'Integer'
    set $P172, $I179
  if_173_end:
    if $P172, if_171
    set $P170, $P172
    goto if_171_end
  if_171:
.annotate 'line', 816
    find_lex $P180, "$types"
    find_lex $P182, "$_"
    $P183 = $P182."multitype"()
    set $P181, $P183
    defined $I185, $P181
    if $I185, default_184
    get_hll_global $P186, ["PAST"], "Op"
    $P187 = $P186."new"("null P" :named("pirop"))
    set $P181, $P187
  default_184:
    $P180."push"($P181)
.annotate 'line', 817
    find_lex $P188, "$definednesses"
    find_lex $P191, "$_"
    unless_null $P191, vivify_191
    $P191 = root_new ['parrot';'Hash']
  vivify_191:
    set $P192, $P191["definedness"]
    unless_null $P192, vivify_192
    new $P192, "Undef"
  vivify_192:
    set $S193, $P192
    iseq $I194, $S193, "D"
    if $I194, if_190
.annotate 'line', 818
    find_lex $P198, "$_"
    unless_null $P198, vivify_193
    $P198 = root_new ['parrot';'Hash']
  vivify_193:
    set $P199, $P198["definedness"]
    unless_null $P199, vivify_194
    new $P199, "Undef"
  vivify_194:
    set $S200, $P199
    iseq $I201, $S200, "U"
    if $I201, if_197
    new $P203, "Integer"
    assign $P203, 0
    set $P196, $P203
    goto if_197_end
  if_197:
    new $P202, "Integer"
    assign $P202, 2
    set $P196, $P202
  if_197_end:
    set $P189, $P196
.annotate 'line', 817
    goto if_190_end
  if_190:
    new $P195, "Integer"
    assign $P195, 1
    set $P189, $P195
  if_190_end:
    $P204 = $P188."push"($P189)
.annotate 'line', 815
    set $P170, $P204
  if_171_end:
.annotate 'line', 814
    .return ($P170)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_lexical"  :subid("22_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_221
.annotate 'line', 1096
    .const 'Sub' $P227 = "23_1300051186.829" 
    capture_lex $P227
    new $P220, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P220, control_219
    push_eh $P220
    .lex "$name", param_221
.annotate 'line', 1097
    get_global $P223, "@BLOCK"
    defined $I224, $P223
    unless $I224, for_undef_195
    iter $P222, $P223
    new $P240, 'ExceptionHandler'
    set_label $P240, loop239_handler
    $P240."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P240
  loop239_test:
    unless $P222, loop239_done
    shift $P225, $P222
  loop239_redo:
    .const 'Sub' $P227 = "23_1300051186.829" 
    capture_lex $P227
    $P227($P225)
  loop239_next:
    goto loop239_test
  loop239_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P241, exception, 'type'
    eq $P241, .CONTROL_LOOP_NEXT, loop239_next
    eq $P241, .CONTROL_LOOP_REDO, loop239_redo
  loop239_done:
    pop_eh 
  for_undef_195:
.annotate 'line', 1096
    .return (0)
  control_219:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P242, exception, "payload"
    .return ($P242)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block226"  :anon :subid("23_1300051186.829") :outer("22_1300051186.829")
    .param pmc param_229
.annotate 'line', 1098
    $P228 = root_new ['parrot';'Hash']
    .lex "%sym", $P228
    .lex "$_", param_229
    find_lex $P230, "$_"
    find_lex $P231, "$name"
    $P232 = $P230."symbol"($P231)
    store_lex "%sym", $P232
.annotate 'line', 1099
    find_lex $P235, "%sym"
    set $N236, $P235
    if $N236, if_234
    new $P233, 'Float'
    set $P233, $N236
    goto if_234_end
  if_234:
.annotate 'line', 1100
    new $P237, "Exception"
    set $P237['type'], .CONTROL_RETURN
    new $P238, "Integer"
    assign $P238, 1
    setattribute $P237, 'payload', $P238
    throw $P237
  if_234_end:
.annotate 'line', 1097
    .return ($P233)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("24_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_245
    .param pmc param_246
.annotate 'line', 1304
    .lex "$/", param_245
    .lex "$type", param_246
.annotate 'line', 1305
    find_lex $P247, "$/"
    get_hll_global $P248, ["PAST"], "Op"
    find_lex $P249, "$/"
.annotate 'line', 1309
    get_hll_global $P250, ["PAST"], "Val"
    find_lex $P251, "$type"
    $P252 = $P250."new"($P251 :named("value"), "!except_types" :named("returns"))
    $P253 = $P248."new"(0, $P252, $P249 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1305
    $P254 = $P247."!make"($P253)
.annotate 'line', 1304
    .return ($P254)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block257"  :anon :subid("25_1300051186.829") :outer("11_1300051186.829")
.annotate 'line', 3
    .const 'Sub' $P260 = "26_1300051186.829" 
    capture_lex $P260
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post196") :outer("25_1300051186.829")
.annotate 'line', 3
    .const 'Sub' $P258 = "25_1300051186.829" 
    .local pmc block
    set block, $P258
.annotate 'line', 5
    .const 'Sub' $P260 = "26_1300051186.829" 
    capture_lex $P260
    $P260()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block259"  :anon :subid("26_1300051186.829") :outer("25_1300051186.829")
.annotate 'line', 6
    get_global $P261, "@BLOCK"
    unless_null $P261, vivify_197
    $P261 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P261
  vivify_197:
 $P262 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P262
.annotate 'line', 5
    .return ($P262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("27_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_267
    .param pmc param_268
.annotate 'line', 33
    .lex "self", param_267
    .lex "$/", param_268
    find_lex $P269, "$/"
    find_lex $P270, "$/"
    unless_null $P270, vivify_198
    $P270 = root_new ['parrot';'Hash']
  vivify_198:
    set $P271, $P270["comp_unit"]
    unless_null $P271, vivify_199
    new $P271, "Undef"
  vivify_199:
    $P272 = $P271."ast"()
    $P273 = $P269."!make"($P272)
    .return ($P273)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("28_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_275
    .param pmc param_276
.annotate 'line', 35
    .lex "self", param_275
    .lex "$/", param_276
.annotate 'line', 36
    find_lex $P277, "$/"
.annotate 'line', 37
    find_lex $P280, "$/"
    unless_null $P280, vivify_200
    $P280 = root_new ['parrot';'Hash']
  vivify_200:
    set $P281, $P280["colonpair"]
    unless_null $P281, vivify_201
    new $P281, "Undef"
  vivify_201:
    if $P281, if_279
.annotate 'line', 39
    find_lex $P301, "$/"
    set $S302, $P301
    new $P278, 'String'
    set $P278, $S302
.annotate 'line', 37
    goto if_279_end
  if_279:
    find_lex $P282, "$/"
    unless_null $P282, vivify_202
    $P282 = root_new ['parrot';'Hash']
  vivify_202:
    set $P283, $P282["identifier"]
    unless_null $P283, vivify_203
    new $P283, "Undef"
  vivify_203:
    set $S284, $P283
    new $P285, 'String'
    set $P285, $S284
    concat $P286, $P285, ":"
    find_lex $P287, "$/"
    unless_null $P287, vivify_204
    $P287 = root_new ['parrot';'Hash']
  vivify_204:
    set $P288, $P287["colonpair"]
    unless_null $P288, vivify_205
    $P288 = root_new ['parrot';'ResizablePMCArray']
  vivify_205:
    set $P289, $P288[0]
    unless_null $P289, vivify_206
    new $P289, "Undef"
  vivify_206:
    $P290 = $P289."ast"()
    $S291 = $P290."named"()
    concat $P292, $P286, $S291
    concat $P293, $P292, "<"
.annotate 'line', 38
    find_lex $P294, "$/"
    unless_null $P294, vivify_207
    $P294 = root_new ['parrot';'Hash']
  vivify_207:
    set $P295, $P294["colonpair"]
    unless_null $P295, vivify_208
    $P295 = root_new ['parrot';'ResizablePMCArray']
  vivify_208:
    set $P296, $P295[0]
    unless_null $P296, vivify_209
    new $P296, "Undef"
  vivify_209:
    $P297 = $P296."ast"()
    $S298 = "colonpair_str"($P297)
    concat $P299, $P293, $S298
    concat $P300, $P299, ">"
    set $P278, $P300
  if_279_end:
.annotate 'line', 37
    $P303 = $P277."!make"($P278)
.annotate 'line', 35
    .return ($P303)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("29_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_306
    .param pmc param_307
.annotate 'line', 49
    .lex "self", param_306
    .lex "$/", param_307
.annotate 'line', 50
    new $P308, "Undef"
    .lex "$mainline", $P308
.annotate 'line', 51
    new $P309, "Undef"
    .lex "$unit", $P309
.annotate 'line', 50
    find_lex $P310, "$/"
    unless_null $P310, vivify_210
    $P310 = root_new ['parrot';'Hash']
  vivify_210:
    set $P311, $P310["statementlist"]
    unless_null $P311, vivify_211
    new $P311, "Undef"
  vivify_211:
    $P312 = $P311."ast"()
    store_lex "$mainline", $P312
.annotate 'line', 51
    get_global $P313, "@BLOCK"
    $P314 = $P313."shift"()
    store_lex "$unit", $P314
.annotate 'line', 55
    find_lex $P315, "$unit"
    $P316 = $P315."loadinit"()
    find_dynamic_lex $P317, "$*SC"
    unless_null $P317, vivify_212
    get_hll_global $P317, "$SC"
    unless_null $P317, vivify_213
    die "Contextual $*SC not found"
  vivify_213:
  vivify_212:
    $P318 = $P317."to_past"()
    $P316."push"($P318)
.annotate 'line', 60
    find_dynamic_lex $P320, "$*HAS_YOU_ARE_HERE"
    unless_null $P320, vivify_214
    get_hll_global $P320, "$HAS_YOU_ARE_HERE"
    unless_null $P320, vivify_215
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_215:
  vivify_214:
    if $P320, unless_319_end
.annotate 'line', 61
    find_lex $P321, "$unit"
    find_lex $P322, "self"
    $P323 = $P322."CTXSAVE"()
    $P321."push"($P323)
  unless_319_end:
.annotate 'line', 65
    find_lex $P324, "$unit"
    $P324."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 66
    find_lex $P325, "$unit"
    get_hll_global $P326, ["PAST"], "Op"
.annotate 'line', 68
    get_hll_global $P327, ["PAST"], "Op"
    $P328 = $P327."new"("getinterp P" :named("pirop"))
.annotate 'line', 69
    get_hll_global $P329, ["PAST"], "Op"
    $P330 = $P329."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 70
    get_hll_global $P331, ["PAST"], "Op"
    $P332 = $P331."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P333 = $P326."new"($P328, $P330, $P332, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 66
    $P325."unshift"($P333)
.annotate 'line', 76
    find_lex $P334, "$unit"
.annotate 'line', 77
    get_hll_global $P335, ["PAST"], "Op"
    find_lex $P336, "$mainline"
    $P337 = $P335."new"($P336, "return" :named("pirop"))
    $P334."push"($P337)
.annotate 'line', 82
    find_lex $P338, "$unit"
.annotate 'line', 83
    get_hll_global $P339, ["PAST"], "Block"
.annotate 'line', 85
    get_hll_global $P340, ["PAST"], "Op"
    get_hll_global $P341, ["PAST"], "Val"
    find_lex $P342, "$unit"
    $P343 = $P341."new"($P342 :named("value"))
    $P344 = $P340."new"($P343, "call" :named("pasttype"))
    $P345 = $P339."new"($P344, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 83
    $P338."push"($P345)
.annotate 'line', 88
    find_lex $P346, "$unit"
    find_lex $P347, "$/"
    $P346."node"($P347)
.annotate 'line', 91
    find_lex $P348, "$unit"
    $P348."hll"("nqp")
.annotate 'line', 93
    find_lex $P349, "$/"
    find_lex $P350, "$unit"
    $P351 = $P349."!make"($P350)
.annotate 'line', 49
    .return ($P351)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("30_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_353
    .param pmc param_354
.annotate 'line', 96
    .const 'Sub' $P368 = "31_1300051186.829" 
    capture_lex $P368
    .lex "self", param_353
    .lex "$/", param_354
.annotate 'line', 97
    new $P355, "Undef"
    .lex "$past", $P355
    get_hll_global $P356, ["PAST"], "Stmts"
    find_lex $P357, "$/"
    $P358 = $P356."new"($P357 :named("node"))
    store_lex "$past", $P358
.annotate 'line', 98
    find_lex $P360, "$/"
    unless_null $P360, vivify_216
    $P360 = root_new ['parrot';'Hash']
  vivify_216:
    set $P361, $P360["statement"]
    unless_null $P361, vivify_217
    new $P361, "Undef"
  vivify_217:
    unless $P361, if_359_end
.annotate 'line', 99
    find_lex $P363, "$/"
    unless_null $P363, vivify_218
    $P363 = root_new ['parrot';'Hash']
  vivify_218:
    set $P364, $P363["statement"]
    unless_null $P364, vivify_219
    new $P364, "Undef"
  vivify_219:
    defined $I365, $P364
    unless $I365, for_undef_220
    iter $P362, $P364
    new $P388, 'ExceptionHandler'
    set_label $P388, loop387_handler
    $P388."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P388
  loop387_test:
    unless $P362, loop387_done
    shift $P366, $P362
  loop387_redo:
    .const 'Sub' $P368 = "31_1300051186.829" 
    capture_lex $P368
    $P368($P366)
  loop387_next:
    goto loop387_test
  loop387_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P389, exception, 'type'
    eq $P389, .CONTROL_LOOP_NEXT, loop387_next
    eq $P389, .CONTROL_LOOP_REDO, loop387_redo
  loop387_done:
    pop_eh 
  for_undef_220:
  if_359_end:
.annotate 'line', 106
    find_lex $P390, "$/"
    find_lex $P391, "$past"
    $P392 = $P390."!make"($P391)
.annotate 'line', 96
    .return ($P392)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block367"  :anon :subid("31_1300051186.829") :outer("30_1300051186.829")
    .param pmc param_370
.annotate 'line', 100
    new $P369, "Undef"
    .lex "$ast", $P369
    .lex "$_", param_370
    find_lex $P371, "$_"
    $P372 = $P371."ast"()
    store_lex "$ast", $P372
.annotate 'line', 101
    find_lex $P374, "$ast"
    unless_null $P374, vivify_221
    $P374 = root_new ['parrot';'Hash']
  vivify_221:
    set $P375, $P374["sink"]
    unless_null $P375, vivify_222
    new $P375, "Undef"
  vivify_222:
    defined $I376, $P375
    unless $I376, if_373_end
    find_lex $P377, "$ast"
    unless_null $P377, vivify_223
    $P377 = root_new ['parrot';'Hash']
  vivify_223:
    set $P378, $P377["sink"]
    unless_null $P378, vivify_224
    new $P378, "Undef"
  vivify_224:
    store_lex "$ast", $P378
  if_373_end:
.annotate 'line', 102
    find_lex $P380, "$ast"
    unless_null $P380, vivify_225
    $P380 = root_new ['parrot';'Hash']
  vivify_225:
    set $P381, $P380["bareblock"]
    unless_null $P381, vivify_226
    new $P381, "Undef"
  vivify_226:
    unless $P381, if_379_end
    find_lex $P382, "$ast"
    $P383 = "block_immediate"($P382)
    store_lex "$ast", $P383
  if_379_end:
.annotate 'line', 103
    find_lex $P384, "$past"
    find_lex $P385, "$ast"
    $P386 = $P384."push"($P385)
.annotate 'line', 99
    .return ($P386)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("32_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_394
    .param pmc param_395
    .param pmc param_396 :optional
    .param int has_param_396 :opt_flag
.annotate 'line', 109
    .const 'Sub' $P404 = "33_1300051186.829" 
    capture_lex $P404
    .lex "self", param_394
    .lex "$/", param_395
    if has_param_396, optparam_227
    new $P397, "Undef"
    set param_396, $P397
  optparam_227:
    .lex "$key", param_396
.annotate 'line', 110
    new $P398, "Undef"
    .lex "$past", $P398
.annotate 'line', 109
    find_lex $P399, "$past"
.annotate 'line', 111
    find_lex $P401, "$/"
    unless_null $P401, vivify_228
    $P401 = root_new ['parrot';'Hash']
  vivify_228:
    set $P402, $P401["EXPR"]
    unless_null $P402, vivify_229
    new $P402, "Undef"
  vivify_229:
    if $P402, if_400
.annotate 'line', 132
    find_lex $P465, "$/"
    unless_null $P465, vivify_230
    $P465 = root_new ['parrot';'Hash']
  vivify_230:
    set $P466, $P465["statement_control"]
    unless_null $P466, vivify_231
    new $P466, "Undef"
  vivify_231:
    if $P466, if_464
.annotate 'line', 133
    new $P470, "Integer"
    assign $P470, 0
    store_lex "$past", $P470
    goto if_464_end
  if_464:
.annotate 'line', 132
    find_lex $P467, "$/"
    unless_null $P467, vivify_232
    $P467 = root_new ['parrot';'Hash']
  vivify_232:
    set $P468, $P467["statement_control"]
    unless_null $P468, vivify_233
    new $P468, "Undef"
  vivify_233:
    $P469 = $P468."ast"()
    store_lex "$past", $P469
  if_464_end:
    goto if_400_end
  if_400:
.annotate 'line', 111
    .const 'Sub' $P404 = "33_1300051186.829" 
    capture_lex $P404
    $P404()
  if_400_end:
.annotate 'line', 134
    find_lex $P471, "$/"
    find_lex $P472, "$past"
    $P473 = $P471."!make"($P472)
.annotate 'line', 109
    .return ($P473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block403"  :anon :subid("33_1300051186.829") :outer("32_1300051186.829")
.annotate 'line', 112
    new $P405, "Undef"
    .lex "$mc", $P405
.annotate 'line', 113
    new $P406, "Undef"
    .lex "$ml", $P406
.annotate 'line', 112
    find_lex $P407, "$/"
    unless_null $P407, vivify_234
    $P407 = root_new ['parrot';'Hash']
  vivify_234:
    set $P408, $P407["statement_mod_cond"]
    unless_null $P408, vivify_235
    $P408 = root_new ['parrot';'ResizablePMCArray']
  vivify_235:
    set $P409, $P408[0]
    unless_null $P409, vivify_236
    new $P409, "Undef"
  vivify_236:
    store_lex "$mc", $P409
.annotate 'line', 113
    find_lex $P410, "$/"
    unless_null $P410, vivify_237
    $P410 = root_new ['parrot';'Hash']
  vivify_237:
    set $P411, $P410["statement_mod_loop"]
    unless_null $P411, vivify_238
    $P411 = root_new ['parrot';'ResizablePMCArray']
  vivify_238:
    set $P412, $P411[0]
    unless_null $P412, vivify_239
    new $P412, "Undef"
  vivify_239:
    store_lex "$ml", $P412
.annotate 'line', 114
    find_lex $P413, "$/"
    unless_null $P413, vivify_240
    $P413 = root_new ['parrot';'Hash']
  vivify_240:
    set $P414, $P413["EXPR"]
    unless_null $P414, vivify_241
    new $P414, "Undef"
  vivify_241:
    $P415 = $P414."ast"()
    store_lex "$past", $P415
.annotate 'line', 115
    find_lex $P417, "$mc"
    unless $P417, if_416_end
.annotate 'line', 116
    get_hll_global $P418, ["PAST"], "Op"
    find_lex $P419, "$mc"
    unless_null $P419, vivify_242
    $P419 = root_new ['parrot';'Hash']
  vivify_242:
    set $P420, $P419["cond"]
    unless_null $P420, vivify_243
    new $P420, "Undef"
  vivify_243:
    $P421 = $P420."ast"()
    find_lex $P422, "$past"
    find_lex $P423, "$mc"
    unless_null $P423, vivify_244
    $P423 = root_new ['parrot';'Hash']
  vivify_244:
    set $P424, $P423["sym"]
    unless_null $P424, vivify_245
    new $P424, "Undef"
  vivify_245:
    set $S425, $P424
    find_lex $P426, "$/"
    $P427 = $P418."new"($P421, $P422, $S425 :named("pasttype"), $P426 :named("node"))
    store_lex "$past", $P427
  if_416_end:
.annotate 'line', 118
    find_lex $P430, "$ml"
    if $P430, if_429
    set $P428, $P430
    goto if_429_end
  if_429:
.annotate 'line', 119
    find_lex $P433, "$ml"
    unless_null $P433, vivify_246
    $P433 = root_new ['parrot';'Hash']
  vivify_246:
    set $P434, $P433["sym"]
    unless_null $P434, vivify_247
    new $P434, "Undef"
  vivify_247:
    set $S435, $P434
    iseq $I436, $S435, "for"
    if $I436, if_432
.annotate 'line', 128
    get_hll_global $P454, ["PAST"], "Op"
    find_lex $P455, "$ml"
    unless_null $P455, vivify_248
    $P455 = root_new ['parrot';'Hash']
  vivify_248:
    set $P456, $P455["cond"]
    unless_null $P456, vivify_249
    new $P456, "Undef"
  vivify_249:
    $P457 = $P456."ast"()
    find_lex $P458, "$past"
    find_lex $P459, "$ml"
    unless_null $P459, vivify_250
    $P459 = root_new ['parrot';'Hash']
  vivify_250:
    set $P460, $P459["sym"]
    unless_null $P460, vivify_251
    new $P460, "Undef"
  vivify_251:
    set $S461, $P460
    find_lex $P462, "$/"
    $P463 = $P454."new"($P457, $P458, $S461 :named("pasttype"), $P462 :named("node"))
    store_lex "$past", $P463
.annotate 'line', 127
    set $P431, $P463
.annotate 'line', 119
    goto if_432_end
  if_432:
.annotate 'line', 120
    get_hll_global $P437, ["PAST"], "Block"
.annotate 'line', 121
    get_hll_global $P438, ["PAST"], "Var"
    $P439 = $P438."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P440, "$past"
    $P441 = $P437."new"($P439, $P440, "immediate" :named("blocktype"))
.annotate 'line', 120
    store_lex "$past", $P441
.annotate 'line', 123
    find_lex $P442, "$past"
    $P442."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 124
    find_lex $P443, "$past"
    $P443."arity"(1)
.annotate 'line', 125
    get_hll_global $P444, ["PAST"], "Op"
    find_lex $P445, "$ml"
    unless_null $P445, vivify_252
    $P445 = root_new ['parrot';'Hash']
  vivify_252:
    set $P446, $P445["cond"]
    unless_null $P446, vivify_253
    new $P446, "Undef"
  vivify_253:
    $P447 = $P446."ast"()
    find_lex $P448, "$past"
    find_lex $P449, "$ml"
    unless_null $P449, vivify_254
    $P449 = root_new ['parrot';'Hash']
  vivify_254:
    set $P450, $P449["sym"]
    unless_null $P450, vivify_255
    new $P450, "Undef"
  vivify_255:
    set $S451, $P450
    find_lex $P452, "$/"
    $P453 = $P444."new"($P447, $P448, $S451 :named("pasttype"), $P452 :named("node"))
    store_lex "$past", $P453
.annotate 'line', 119
    set $P431, $P453
  if_432_end:
.annotate 'line', 118
    set $P428, $P431
  if_429_end:
.annotate 'line', 111
    .return ($P428)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("34_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_475
    .param pmc param_476
.annotate 'line', 137
    .lex "self", param_475
    .lex "$/", param_476
.annotate 'line', 138
    find_lex $P477, "$/"
    get_hll_global $P478, ["PAST"], "Op"
    find_lex $P479, "$/"
    unless_null $P479, vivify_256
    $P479 = root_new ['parrot';'Hash']
  vivify_256:
    set $P480, $P479["EXPR"]
    unless_null $P480, vivify_257
    new $P480, "Undef"
  vivify_257:
    $P481 = $P480."ast"()
    find_lex $P482, "$/"
    unless_null $P482, vivify_258
    $P482 = root_new ['parrot';'Hash']
  vivify_258:
    set $P483, $P482["pblock"]
    unless_null $P483, vivify_259
    new $P483, "Undef"
  vivify_259:
    $P484 = $P483."ast"()
    find_lex $P485, "$/"
    $P486 = $P478."new"($P481, $P484, "if" :named("pasttype"), $P485 :named("node"))
    $P487 = $P477."!make"($P486)
.annotate 'line', 137
    .return ($P487)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("35_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_489
    .param pmc param_490
.annotate 'line', 141
    .lex "self", param_489
    .lex "$/", param_490
.annotate 'line', 142
    find_lex $P491, "$/"
    find_lex $P492, "$/"
    unless_null $P492, vivify_260
    $P492 = root_new ['parrot';'Hash']
  vivify_260:
    set $P493, $P492["blockoid"]
    unless_null $P493, vivify_261
    new $P493, "Undef"
  vivify_261:
    $P494 = $P493."ast"()
    $P495 = $P491."!make"($P494)
.annotate 'line', 141
    .return ($P495)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("36_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_497
    .param pmc param_498
.annotate 'line', 145
    .lex "self", param_497
    .lex "$/", param_498
.annotate 'line', 146
    find_lex $P499, "$/"
    find_lex $P500, "$/"
    unless_null $P500, vivify_262
    $P500 = root_new ['parrot';'Hash']
  vivify_262:
    set $P501, $P500["blockoid"]
    unless_null $P501, vivify_263
    new $P501, "Undef"
  vivify_263:
    $P502 = $P501."ast"()
    $P503 = $P499."!make"($P502)
.annotate 'line', 145
    .return ($P503)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("37_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_505
    .param pmc param_506
.annotate 'line', 149
    .const 'Sub' $P515 = "38_1300051186.829" 
    capture_lex $P515
    .lex "self", param_505
    .lex "$/", param_506
.annotate 'line', 150
    new $P507, "Undef"
    .lex "$BLOCK", $P507
    get_global $P508, "@BLOCK"
    $P509 = $P508."shift"()
    store_lex "$BLOCK", $P509
.annotate 'line', 151
    find_lex $P512, "$/"
    unless_null $P512, vivify_264
    $P512 = root_new ['parrot';'Hash']
  vivify_264:
    set $P513, $P512["statementlist"]
    unless_null $P513, vivify_265
    new $P513, "Undef"
  vivify_265:
    if $P513, if_511
.annotate 'line', 159
    find_dynamic_lex $P530, "$*HAS_YOU_ARE_HERE"
    unless_null $P530, vivify_266
    get_hll_global $P530, "$HAS_YOU_ARE_HERE"
    unless_null $P530, vivify_267
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_267:
  vivify_266:
    unless $P530, if_529_end
.annotate 'line', 160
    find_lex $P531, "$/"
    $P532 = $P531."CURSOR"()
    $P532."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_529_end:
.annotate 'line', 162
    new $P533, "Integer"
    assign $P533, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P533
.annotate 'line', 163
    find_lex $P534, "$/"
    find_lex $P535, "$/"
    unless_null $P535, vivify_268
    $P535 = root_new ['parrot';'Hash']
  vivify_268:
    set $P536, $P535["you_are_here"]
    unless_null $P536, vivify_269
    new $P536, "Undef"
  vivify_269:
    $P537 = $P536."ast"()
    $P538 = $P534."!make"($P537)
.annotate 'line', 158
    set $P510, $P538
.annotate 'line', 151
    goto if_511_end
  if_511:
    .const 'Sub' $P515 = "38_1300051186.829" 
    capture_lex $P515
    $P528 = $P515()
    set $P510, $P528
  if_511_end:
.annotate 'line', 149
    .return ($P510)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block514"  :anon :subid("38_1300051186.829") :outer("37_1300051186.829")
.annotate 'line', 152
    new $P516, "Undef"
    .lex "$past", $P516
    find_lex $P517, "$/"
    unless_null $P517, vivify_270
    $P517 = root_new ['parrot';'Hash']
  vivify_270:
    set $P518, $P517["statementlist"]
    unless_null $P518, vivify_271
    new $P518, "Undef"
  vivify_271:
    $P519 = $P518."ast"()
    store_lex "$past", $P519
.annotate 'line', 153
    find_lex $P520, "$BLOCK"
    find_lex $P521, "$past"
    $P520."push"($P521)
.annotate 'line', 154
    find_lex $P522, "$BLOCK"
    find_lex $P523, "$/"
    $P522."node"($P523)
.annotate 'line', 155
    find_lex $P524, "$BLOCK"
    $P524."closure"(1)
.annotate 'line', 156
    find_dynamic_lex $P525, "$/"
    find_lex $P526, "$BLOCK"
    $P527 = $P525."!make"($P526)
.annotate 'line', 151
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("39_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_540
    .param pmc param_541
.annotate 'line', 167
    .lex "self", param_540
    .lex "$/", param_541
.annotate 'line', 168
    get_global $P542, "@BLOCK"
    unless_null $P542, vivify_272
    $P542 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P542
  vivify_272:
.annotate 'line', 167
    get_global $P543, "@BLOCK"
.annotate 'line', 169
    get_global $P544, "@BLOCK"
    get_hll_global $P545, ["PAST"], "Block"
    get_hll_global $P546, ["PAST"], "Stmts"
    $P547 = $P546."new"()
    $P548 = $P545."new"($P547)
    $P549 = $P544."unshift"($P548)
.annotate 'line', 167
    .return ($P549)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("40_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_551
    .param pmc param_552
.annotate 'line', 172
    .lex "self", param_551
    .lex "$/", param_552
.annotate 'line', 173
    get_global $P553, "@BLOCK"
    unless_null $P553, vivify_273
    $P553 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P553
  vivify_273:
.annotate 'line', 172
    get_global $P554, "@BLOCK"
.annotate 'line', 174
    find_dynamic_lex $P556, "%*COMPILING"
    unless_null $P556, vivify_274
    get_hll_global $P556, "%COMPILING"
    unless_null $P556, vivify_275
    die "Contextual %*COMPILING not found"
  vivify_275:
  vivify_274:
    set $P557, $P556["%?OPTIONS"]
    unless_null $P557, vivify_276
    $P557 = root_new ['parrot';'Hash']
  vivify_276:
    set $P558, $P557["outer_ctx"]
    unless_null $P558, vivify_277
    new $P558, "Undef"
  vivify_277:
    defined $I559, $P558
    if $I559, unless_555_end
.annotate 'line', 177
    find_dynamic_lex $P560, "$*SC"
    unless_null $P560, vivify_278
    get_hll_global $P560, "$SC"
    unless_null $P560, vivify_279
    die "Contextual $*SC not found"
  vivify_279:
  vivify_278:
    find_dynamic_lex $P562, "%*COMPILING"
    unless_null $P562, vivify_280
    get_hll_global $P562, "%COMPILING"
    unless_null $P562, vivify_281
    die "Contextual %*COMPILING not found"
  vivify_281:
  vivify_280:
    set $P563, $P562["%?OPTIONS"]
    unless_null $P563, vivify_282
    $P563 = root_new ['parrot';'Hash']
  vivify_282:
    set $P564, $P563["setting"]
    unless_null $P564, vivify_283
    new $P564, "Undef"
  vivify_283:
    set $P561, $P564
    defined $I566, $P561
    if $I566, default_565
    new $P567, "String"
    assign $P567, "NQPCORE"
    set $P561, $P567
  default_565:
    $P560."load_setting"($P561)
  unless_555_end:
.annotate 'line', 179
    find_lex $P568, "self"
    get_global $P569, "@BLOCK"
    unless_null $P569, vivify_284
    $P569 = root_new ['parrot';'ResizablePMCArray']
  vivify_284:
    set $P570, $P569[0]
    unless_null $P570, vivify_285
    new $P570, "Undef"
  vivify_285:
    $P571 = $P568."SET_BLOCK_OUTER_CTX"($P570)
.annotate 'line', 172
    .return ($P571)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("41_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_573
    .param pmc param_574
.annotate 'line', 182
    .lex "self", param_573
    .lex "$/", param_574
.annotate 'line', 183
    find_lex $P575, "$/"
    find_lex $P576, "self"
    $P577 = $P576."CTXSAVE"()
    $P578 = $P575."!make"($P577)
.annotate 'line', 182
    .return ($P578)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("42_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_580
    .param pmc param_581
.annotate 'line', 188
    .lex "self", param_580
    .lex "$/", param_581
.annotate 'line', 189
    find_dynamic_lex $P582, "$*SC"
    unless_null $P582, vivify_286
    get_hll_global $P582, "$SC"
    unless_null $P582, vivify_287
    die "Contextual $*SC not found"
  vivify_287:
  vivify_286:
    find_lex $P583, "$/"
    unless_null $P583, vivify_288
    $P583 = root_new ['parrot';'Hash']
  vivify_288:
    set $P584, $P583["name"]
    unless_null $P584, vivify_289
    new $P584, "Undef"
  vivify_289:
    set $S585, $P584
    $P582."load_module"($S585)
.annotate 'line', 190
    find_lex $P586, "$/"
    get_hll_global $P587, ["PAST"], "Stmts"
    $P588 = $P587."new"()
    $P589 = $P586."!make"($P588)
.annotate 'line', 188
    .return ($P589)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("43_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_591
    .param pmc param_592
.annotate 'line', 193
    .const 'Sub' $P620 = "44_1300051186.829" 
    capture_lex $P620
    .lex "self", param_591
    .lex "$/", param_592
.annotate 'line', 194
    new $P593, "Undef"
    .lex "$count", $P593
.annotate 'line', 195
    new $P594, "Undef"
    .lex "$past", $P594
.annotate 'line', 194
    find_lex $P595, "$/"
    unless_null $P595, vivify_290
    $P595 = root_new ['parrot';'Hash']
  vivify_290:
    set $P596, $P595["xblock"]
    unless_null $P596, vivify_291
    new $P596, "Undef"
  vivify_291:
    set $N597, $P596
    new $P598, 'Float'
    set $P598, $N597
    sub $P599, $P598, 1
    store_lex "$count", $P599
.annotate 'line', 195
    find_lex $P600, "$count"
    set $I601, $P600
    find_lex $P602, "$/"
    unless_null $P602, vivify_292
    $P602 = root_new ['parrot';'Hash']
  vivify_292:
    set $P603, $P602["xblock"]
    unless_null $P603, vivify_293
    $P603 = root_new ['parrot';'ResizablePMCArray']
  vivify_293:
    set $P604, $P603[$I601]
    unless_null $P604, vivify_294
    new $P604, "Undef"
  vivify_294:
    $P605 = $P604."ast"()
    $P606 = "xblock_immediate"($P605)
    store_lex "$past", $P606
.annotate 'line', 196
    find_lex $P608, "$/"
    unless_null $P608, vivify_295
    $P608 = root_new ['parrot';'Hash']
  vivify_295:
    set $P609, $P608["else"]
    unless_null $P609, vivify_296
    new $P609, "Undef"
  vivify_296:
    unless $P609, if_607_end
.annotate 'line', 197
    find_lex $P610, "$past"
    find_lex $P611, "$/"
    unless_null $P611, vivify_297
    $P611 = root_new ['parrot';'Hash']
  vivify_297:
    set $P612, $P611["else"]
    unless_null $P612, vivify_298
    $P612 = root_new ['parrot';'ResizablePMCArray']
  vivify_298:
    set $P613, $P612[0]
    unless_null $P613, vivify_299
    new $P613, "Undef"
  vivify_299:
    $P614 = $P613."ast"()
    $P615 = "block_immediate"($P614)
    $P610."push"($P615)
  if_607_end:
.annotate 'line', 200
    new $P636, 'ExceptionHandler'
    set_label $P636, loop635_handler
    $P636."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P636
  loop635_test:
    find_lex $P616, "$count"
    set $N617, $P616
    isgt $I618, $N617, 0.0
    unless $I618, loop635_done
  loop635_redo:
    .const 'Sub' $P620 = "44_1300051186.829" 
    capture_lex $P620
    $P620()
  loop635_next:
    goto loop635_test
  loop635_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P637, exception, 'type'
    eq $P637, .CONTROL_LOOP_NEXT, loop635_next
    eq $P637, .CONTROL_LOOP_REDO, loop635_redo
  loop635_done:
    pop_eh 
.annotate 'line', 206
    find_lex $P638, "$/"
    find_lex $P639, "$past"
    $P640 = $P638."!make"($P639)
.annotate 'line', 193
    .return ($P640)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block619"  :anon :subid("44_1300051186.829") :outer("43_1300051186.829")
.annotate 'line', 202
    new $P621, "Undef"
    .lex "$else", $P621
.annotate 'line', 200
    find_lex $P622, "$count"
    clone $P623, $P622
    dec $P622
.annotate 'line', 202
    find_lex $P624, "$past"
    store_lex "$else", $P624
.annotate 'line', 203
    find_lex $P625, "$count"
    set $I626, $P625
    find_lex $P627, "$/"
    unless_null $P627, vivify_300
    $P627 = root_new ['parrot';'Hash']
  vivify_300:
    set $P628, $P627["xblock"]
    unless_null $P628, vivify_301
    $P628 = root_new ['parrot';'ResizablePMCArray']
  vivify_301:
    set $P629, $P628[$I626]
    unless_null $P629, vivify_302
    new $P629, "Undef"
  vivify_302:
    $P630 = $P629."ast"()
    $P631 = "xblock_immediate"($P630)
    store_lex "$past", $P631
.annotate 'line', 204
    find_lex $P632, "$past"
    find_lex $P633, "$else"
    $P634 = $P632."push"($P633)
.annotate 'line', 200
    .return ($P634)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("45_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_642
    .param pmc param_643
.annotate 'line', 209
    .lex "self", param_642
    .lex "$/", param_643
.annotate 'line', 210
    new $P644, "Undef"
    .lex "$past", $P644
    find_lex $P645, "$/"
    unless_null $P645, vivify_303
    $P645 = root_new ['parrot';'Hash']
  vivify_303:
    set $P646, $P645["xblock"]
    unless_null $P646, vivify_304
    new $P646, "Undef"
  vivify_304:
    $P647 = $P646."ast"()
    $P648 = "xblock_immediate"($P647)
    store_lex "$past", $P648
.annotate 'line', 211
    find_lex $P649, "$past"
    $P649."pasttype"("unless")
.annotate 'line', 212
    find_lex $P650, "$/"
    find_lex $P651, "$past"
    $P652 = $P650."!make"($P651)
.annotate 'line', 209
    .return ($P652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("46_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_654
    .param pmc param_655
.annotate 'line', 215
    .lex "self", param_654
    .lex "$/", param_655
.annotate 'line', 216
    new $P656, "Undef"
    .lex "$past", $P656
    find_lex $P657, "$/"
    unless_null $P657, vivify_305
    $P657 = root_new ['parrot';'Hash']
  vivify_305:
    set $P658, $P657["xblock"]
    unless_null $P658, vivify_306
    new $P658, "Undef"
  vivify_306:
    $P659 = $P658."ast"()
    $P660 = "xblock_immediate"($P659)
    store_lex "$past", $P660
.annotate 'line', 217
    find_lex $P661, "$past"
    find_lex $P662, "$/"
    unless_null $P662, vivify_307
    $P662 = root_new ['parrot';'Hash']
  vivify_307:
    set $P663, $P662["sym"]
    unless_null $P663, vivify_308
    new $P663, "Undef"
  vivify_308:
    set $S664, $P663
    $P661."pasttype"($S664)
.annotate 'line', 218
    find_lex $P665, "$/"
    find_lex $P666, "$past"
    $P667 = $P665."!make"($P666)
.annotate 'line', 215
    .return ($P667)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("47_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_669
    .param pmc param_670
.annotate 'line', 221
    .lex "self", param_669
    .lex "$/", param_670
.annotate 'line', 222
    new $P671, "Undef"
    .lex "$pasttype", $P671
.annotate 'line', 223
    new $P672, "Undef"
    .lex "$past", $P672
.annotate 'line', 222
    new $P673, "String"
    assign $P673, "repeat_"
    find_lex $P674, "$/"
    unless_null $P674, vivify_309
    $P674 = root_new ['parrot';'Hash']
  vivify_309:
    set $P675, $P674["wu"]
    unless_null $P675, vivify_310
    new $P675, "Undef"
  vivify_310:
    set $S676, $P675
    concat $P677, $P673, $S676
    store_lex "$pasttype", $P677
    find_lex $P678, "$past"
.annotate 'line', 224
    find_lex $P680, "$/"
    unless_null $P680, vivify_311
    $P680 = root_new ['parrot';'Hash']
  vivify_311:
    set $P681, $P680["xblock"]
    unless_null $P681, vivify_312
    new $P681, "Undef"
  vivify_312:
    if $P681, if_679
.annotate 'line', 229
    get_hll_global $P688, ["PAST"], "Op"
    find_lex $P689, "$/"
    unless_null $P689, vivify_313
    $P689 = root_new ['parrot';'Hash']
  vivify_313:
    set $P690, $P689["EXPR"]
    unless_null $P690, vivify_314
    new $P690, "Undef"
  vivify_314:
    $P691 = $P690."ast"()
    find_lex $P692, "$/"
    unless_null $P692, vivify_315
    $P692 = root_new ['parrot';'Hash']
  vivify_315:
    set $P693, $P692["pblock"]
    unless_null $P693, vivify_316
    new $P693, "Undef"
  vivify_316:
    $P694 = $P693."ast"()
    $P695 = "block_immediate"($P694)
    find_lex $P696, "$pasttype"
    find_lex $P697, "$/"
    $P698 = $P688."new"($P691, $P695, $P696 :named("pasttype"), $P697 :named("node"))
    store_lex "$past", $P698
.annotate 'line', 228
    goto if_679_end
  if_679:
.annotate 'line', 225
    find_lex $P682, "$/"
    unless_null $P682, vivify_317
    $P682 = root_new ['parrot';'Hash']
  vivify_317:
    set $P683, $P682["xblock"]
    unless_null $P683, vivify_318
    new $P683, "Undef"
  vivify_318:
    $P684 = $P683."ast"()
    $P685 = "xblock_immediate"($P684)
    store_lex "$past", $P685
.annotate 'line', 226
    find_lex $P686, "$past"
    find_lex $P687, "$pasttype"
    $P686."pasttype"($P687)
  if_679_end:
.annotate 'line', 232
    find_lex $P699, "$/"
    find_lex $P700, "$past"
    $P701 = $P699."!make"($P700)
.annotate 'line', 221
    .return ($P701)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("48_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_703
    .param pmc param_704
.annotate 'line', 235
    .lex "self", param_703
    .lex "$/", param_704
.annotate 'line', 236
    new $P705, "Undef"
    .lex "$past", $P705
.annotate 'line', 238
    new $P706, "Undef"
    .lex "$block", $P706
.annotate 'line', 236
    find_lex $P707, "$/"
    unless_null $P707, vivify_319
    $P707 = root_new ['parrot';'Hash']
  vivify_319:
    set $P708, $P707["xblock"]
    unless_null $P708, vivify_320
    new $P708, "Undef"
  vivify_320:
    $P709 = $P708."ast"()
    store_lex "$past", $P709
.annotate 'line', 237
    find_lex $P710, "$past"
    $P710."pasttype"("for")
.annotate 'line', 238
    find_lex $P711, "$past"
    unless_null $P711, vivify_321
    $P711 = root_new ['parrot';'ResizablePMCArray']
  vivify_321:
    set $P712, $P711[1]
    unless_null $P712, vivify_322
    new $P712, "Undef"
  vivify_322:
    store_lex "$block", $P712
.annotate 'line', 239
    find_lex $P714, "$block"
    $P715 = $P714."arity"()
    if $P715, unless_713_end
.annotate 'line', 240
    find_lex $P716, "$block"
    unless_null $P716, vivify_323
    $P716 = root_new ['parrot';'ResizablePMCArray']
  vivify_323:
    set $P717, $P716[0]
    unless_null $P717, vivify_324
    new $P717, "Undef"
  vivify_324:
    get_hll_global $P718, ["PAST"], "Var"
    $P719 = $P718."new"("$_" :named("name"), "parameter" :named("scope"))
    $P717."push"($P719)
.annotate 'line', 241
    find_lex $P720, "$block"
    $P720."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 242
    find_lex $P721, "$block"
    $P721."arity"(1)
  unless_713_end:
.annotate 'line', 244
    find_lex $P722, "$block"
    $P722."blocktype"("immediate")
.annotate 'line', 245
    find_lex $P723, "$/"
    find_lex $P724, "$past"
    $P725 = $P723."!make"($P724)
.annotate 'line', 235
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("49_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_727
    .param pmc param_728
.annotate 'line', 248
    .lex "self", param_727
    .lex "$/", param_728
.annotate 'line', 249
    new $P729, "Undef"
    .lex "$block", $P729
    find_lex $P730, "$/"
    unless_null $P730, vivify_325
    $P730 = root_new ['parrot';'Hash']
  vivify_325:
    set $P731, $P730["block"]
    unless_null $P731, vivify_326
    new $P731, "Undef"
  vivify_326:
    $P732 = $P731."ast"()
    store_lex "$block", $P732
.annotate 'line', 250
    find_lex $P733, "$/"
    find_lex $P734, "$block"
    "push_block_handler"($P733, $P734)
.annotate 'line', 251
    get_global $P735, "@BLOCK"
    unless_null $P735, vivify_327
    $P735 = root_new ['parrot';'ResizablePMCArray']
  vivify_327:
    set $P736, $P735[0]
    unless_null $P736, vivify_328
    new $P736, "Undef"
  vivify_328:
    $P737 = $P736."handlers"()
    set $P738, $P737[0]
    unless_null $P738, vivify_329
    new $P738, "Undef"
  vivify_329:
    $P738."handle_types_except"("CONTROL")
.annotate 'line', 252
    find_lex $P739, "$/"
    get_hll_global $P740, ["PAST"], "Stmts"
    find_lex $P741, "$/"
    $P742 = $P740."new"($P741 :named("node"))
    $P743 = $P739."!make"($P742)
.annotate 'line', 248
    .return ($P743)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("50_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_745
    .param pmc param_746
.annotate 'line', 255
    .lex "self", param_745
    .lex "$/", param_746
.annotate 'line', 256
    new $P747, "Undef"
    .lex "$block", $P747
    find_lex $P748, "$/"
    unless_null $P748, vivify_330
    $P748 = root_new ['parrot';'Hash']
  vivify_330:
    set $P749, $P748["block"]
    unless_null $P749, vivify_331
    new $P749, "Undef"
  vivify_331:
    $P750 = $P749."ast"()
    store_lex "$block", $P750
.annotate 'line', 257
    find_lex $P751, "$/"
    find_lex $P752, "$block"
    "push_block_handler"($P751, $P752)
.annotate 'line', 258
    get_global $P753, "@BLOCK"
    unless_null $P753, vivify_332
    $P753 = root_new ['parrot';'ResizablePMCArray']
  vivify_332:
    set $P754, $P753[0]
    unless_null $P754, vivify_333
    new $P754, "Undef"
  vivify_333:
    $P755 = $P754."handlers"()
    set $P756, $P755[0]
    unless_null $P756, vivify_334
    new $P756, "Undef"
  vivify_334:
    $P756."handle_types"("CONTROL")
.annotate 'line', 259
    find_lex $P757, "$/"
    get_hll_global $P758, ["PAST"], "Stmts"
    find_lex $P759, "$/"
    $P760 = $P758."new"($P759 :named("node"))
    $P761 = $P757."!make"($P760)
.annotate 'line', 255
    .return ($P761)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("51_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_764
    .param pmc param_765
.annotate 'line', 299
    .lex "self", param_764
    .lex "$/", param_765
.annotate 'line', 300
    new $P766, "Undef"
    .lex "$init_block", $P766
    get_hll_global $P767, ["PAST"], "Block"
    $P768 = $P767."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P768
.annotate 'line', 301
    find_lex $P769, "$init_block"
    $P770 = $P769."loadinit"()
    find_lex $P771, "$/"
    unless_null $P771, vivify_335
    $P771 = root_new ['parrot';'Hash']
  vivify_335:
    set $P772, $P771["blorst"]
    unless_null $P772, vivify_336
    new $P772, "Undef"
  vivify_336:
    $P773 = $P772."ast"()
    $P770."push"($P773)
.annotate 'line', 302
    find_lex $P774, "$/"
    find_lex $P775, "$init_block"
    $P776 = $P774."!make"($P775)
.annotate 'line', 299
    .return ($P776)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("52_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_778
    .param pmc param_779
.annotate 'line', 305
    .lex "self", param_778
    .lex "$/", param_779
.annotate 'line', 306
    new $P780, "Undef"
    .lex "$past", $P780
    find_lex $P781, "$/"
    unless_null $P781, vivify_337
    $P781 = root_new ['parrot';'Hash']
  vivify_337:
    set $P782, $P781["blorst"]
    unless_null $P782, vivify_338
    new $P782, "Undef"
  vivify_338:
    $P783 = $P782."ast"()
    store_lex "$past", $P783
.annotate 'line', 307
    get_hll_global $P785, ["PAST"], "Block"
    find_lex $P786, "$past"
    $P787 = $P785."ACCEPTS"($P786)
    if $P787, unless_784_end
.annotate 'line', 308
    get_hll_global $P788, ["PAST"], "Block"
    find_lex $P789, "$past"
    find_lex $P790, "$/"
    $P791 = $P788."new"($P789, "immediate" :named("blocktype"), $P790 :named("node"))
    store_lex "$past", $P791
  unless_784_end:
.annotate 'line', 310
    find_lex $P793, "$past"
    $P794 = $P793."handlers"()
    if $P794, unless_792_end
.annotate 'line', 311
    find_lex $P795, "$past"
    get_hll_global $P796, ["PAST"], "Control"
.annotate 'line', 313
    get_hll_global $P797, ["PAST"], "Stmts"
.annotate 'line', 314
    get_hll_global $P798, ["PAST"], "Op"
.annotate 'line', 315
    get_hll_global $P799, ["PAST"], "Var"
.annotate 'line', 316
    get_hll_global $P800, ["PAST"], "Var"
    $P801 = $P800."new"("register" :named("scope"), "exception" :named("name"))
    $P802 = $P799."new"($P801, "handled", "keyed" :named("scope"))
.annotate 'line', 315
    $P803 = $P798."new"($P802, 1, "bind" :named("pasttype"))
.annotate 'line', 314
    $P804 = $P797."new"($P803)
.annotate 'line', 313
    $P805 = $P796."new"($P804, "CONTROL" :named("handle_types_except"))
.annotate 'line', 311
    new $P806, "ResizablePMCArray"
    push $P806, $P805
    $P795."handlers"($P806)
  unless_792_end:
.annotate 'line', 325
    find_lex $P807, "$/"
    find_lex $P808, "$past"
    $P809 = $P807."!make"($P808)
.annotate 'line', 305
    .return ($P809)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("53_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_811
    .param pmc param_812
.annotate 'line', 328
    .lex "self", param_811
    .lex "$/", param_812
.annotate 'line', 329
    find_lex $P813, "$/"
.annotate 'line', 330
    find_lex $P816, "$/"
    unless_null $P816, vivify_339
    $P816 = root_new ['parrot';'Hash']
  vivify_339:
    set $P817, $P816["block"]
    unless_null $P817, vivify_340
    new $P817, "Undef"
  vivify_340:
    if $P817, if_815
.annotate 'line', 331
    find_lex $P822, "$/"
    unless_null $P822, vivify_341
    $P822 = root_new ['parrot';'Hash']
  vivify_341:
    set $P823, $P822["statement"]
    unless_null $P823, vivify_342
    new $P823, "Undef"
  vivify_342:
    $P824 = $P823."ast"()
    set $P814, $P824
.annotate 'line', 330
    goto if_815_end
  if_815:
    find_lex $P818, "$/"
    unless_null $P818, vivify_343
    $P818 = root_new ['parrot';'Hash']
  vivify_343:
    set $P819, $P818["block"]
    unless_null $P819, vivify_344
    new $P819, "Undef"
  vivify_344:
    $P820 = $P819."ast"()
    $P821 = "block_immediate"($P820)
    set $P814, $P821
  if_815_end:
    $P825 = $P813."!make"($P814)
.annotate 'line', 328
    .return ($P825)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("54_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_827
    .param pmc param_828
.annotate 'line', 336
    .lex "self", param_827
    .lex "$/", param_828
    find_lex $P829, "$/"
    find_lex $P830, "$/"
    unless_null $P830, vivify_345
    $P830 = root_new ['parrot';'Hash']
  vivify_345:
    set $P831, $P830["cond"]
    unless_null $P831, vivify_346
    new $P831, "Undef"
  vivify_346:
    $P832 = $P831."ast"()
    $P833 = $P829."!make"($P832)
    .return ($P833)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("55_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_835
    .param pmc param_836
.annotate 'line', 337
    .lex "self", param_835
    .lex "$/", param_836
    find_lex $P837, "$/"
    find_lex $P838, "$/"
    unless_null $P838, vivify_347
    $P838 = root_new ['parrot';'Hash']
  vivify_347:
    set $P839, $P838["cond"]
    unless_null $P839, vivify_348
    new $P839, "Undef"
  vivify_348:
    $P840 = $P839."ast"()
    $P841 = $P837."!make"($P840)
    .return ($P841)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("56_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_843
    .param pmc param_844
.annotate 'line', 339
    .lex "self", param_843
    .lex "$/", param_844
    find_lex $P845, "$/"
    find_lex $P846, "$/"
    unless_null $P846, vivify_349
    $P846 = root_new ['parrot';'Hash']
  vivify_349:
    set $P847, $P846["cond"]
    unless_null $P847, vivify_350
    new $P847, "Undef"
  vivify_350:
    $P848 = $P847."ast"()
    $P849 = $P845."!make"($P848)
    .return ($P849)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("57_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_851
    .param pmc param_852
.annotate 'line', 340
    .lex "self", param_851
    .lex "$/", param_852
    find_lex $P853, "$/"
    find_lex $P854, "$/"
    unless_null $P854, vivify_351
    $P854 = root_new ['parrot';'Hash']
  vivify_351:
    set $P855, $P854["cond"]
    unless_null $P855, vivify_352
    new $P855, "Undef"
  vivify_352:
    $P856 = $P855."ast"()
    $P857 = $P853."!make"($P856)
    .return ($P857)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("58_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_859
    .param pmc param_860
.annotate 'line', 344
    .lex "self", param_859
    .lex "$/", param_860
    find_lex $P861, "$/"
    find_lex $P862, "$/"
    unless_null $P862, vivify_353
    $P862 = root_new ['parrot';'Hash']
  vivify_353:
    set $P863, $P862["fatarrow"]
    unless_null $P863, vivify_354
    new $P863, "Undef"
  vivify_354:
    $P864 = $P863."ast"()
    $P865 = $P861."!make"($P864)
    .return ($P865)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("59_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_867
    .param pmc param_868
.annotate 'line', 345
    .lex "self", param_867
    .lex "$/", param_868
    find_lex $P869, "$/"
    find_lex $P870, "$/"
    unless_null $P870, vivify_355
    $P870 = root_new ['parrot';'Hash']
  vivify_355:
    set $P871, $P870["colonpair"]
    unless_null $P871, vivify_356
    new $P871, "Undef"
  vivify_356:
    $P872 = $P871."ast"()
    $P873 = $P869."!make"($P872)
    .return ($P873)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("60_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_875
    .param pmc param_876
.annotate 'line', 346
    .lex "self", param_875
    .lex "$/", param_876
    find_lex $P877, "$/"
    find_lex $P878, "$/"
    unless_null $P878, vivify_357
    $P878 = root_new ['parrot';'Hash']
  vivify_357:
    set $P879, $P878["variable"]
    unless_null $P879, vivify_358
    new $P879, "Undef"
  vivify_358:
    $P880 = $P879."ast"()
    $P881 = $P877."!make"($P880)
    .return ($P881)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("61_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_883
    .param pmc param_884
.annotate 'line', 347
    .lex "self", param_883
    .lex "$/", param_884
    find_lex $P885, "$/"
    find_lex $P886, "$/"
    unless_null $P886, vivify_359
    $P886 = root_new ['parrot';'Hash']
  vivify_359:
    set $P887, $P886["package_declarator"]
    unless_null $P887, vivify_360
    new $P887, "Undef"
  vivify_360:
    $P888 = $P887."ast"()
    $P889 = $P885."!make"($P888)
    .return ($P889)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("62_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_891
    .param pmc param_892
.annotate 'line', 348
    .lex "self", param_891
    .lex "$/", param_892
    find_lex $P893, "$/"
    find_lex $P894, "$/"
    unless_null $P894, vivify_361
    $P894 = root_new ['parrot';'Hash']
  vivify_361:
    set $P895, $P894["scope_declarator"]
    unless_null $P895, vivify_362
    new $P895, "Undef"
  vivify_362:
    $P896 = $P895."ast"()
    $P897 = $P893."!make"($P896)
    .return ($P897)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("63_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_899
    .param pmc param_900
.annotate 'line', 349
    .lex "self", param_899
    .lex "$/", param_900
    find_lex $P901, "$/"
    find_lex $P902, "$/"
    unless_null $P902, vivify_363
    $P902 = root_new ['parrot';'Hash']
  vivify_363:
    set $P903, $P902["routine_declarator"]
    unless_null $P903, vivify_364
    new $P903, "Undef"
  vivify_364:
    $P904 = $P903."ast"()
    $P905 = $P901."!make"($P904)
    .return ($P905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("64_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_907
    .param pmc param_908
.annotate 'line', 350
    .lex "self", param_907
    .lex "$/", param_908
    find_lex $P909, "$/"
    find_lex $P910, "$/"
    unless_null $P910, vivify_365
    $P910 = root_new ['parrot';'Hash']
  vivify_365:
    set $P911, $P910["regex_declarator"]
    unless_null $P911, vivify_366
    new $P911, "Undef"
  vivify_366:
    $P912 = $P911."ast"()
    $P913 = $P909."!make"($P912)
    .return ($P913)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("65_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_915
    .param pmc param_916
.annotate 'line', 351
    .lex "self", param_915
    .lex "$/", param_916
    find_lex $P917, "$/"
    find_lex $P918, "$/"
    unless_null $P918, vivify_367
    $P918 = root_new ['parrot';'Hash']
  vivify_367:
    set $P919, $P918["statement_prefix"]
    unless_null $P919, vivify_368
    new $P919, "Undef"
  vivify_368:
    $P920 = $P919."ast"()
    $P921 = $P917."!make"($P920)
    .return ($P921)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("66_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_923
    .param pmc param_924
.annotate 'line', 352
    .lex "self", param_923
    .lex "$/", param_924
    find_lex $P925, "$/"
    find_lex $P926, "$/"
    unless_null $P926, vivify_369
    $P926 = root_new ['parrot';'Hash']
  vivify_369:
    set $P927, $P926["pblock"]
    unless_null $P927, vivify_370
    new $P927, "Undef"
  vivify_370:
    $P928 = $P927."ast"()
    $P929 = $P925."!make"($P928)
    .return ($P929)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("67_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_931
    .param pmc param_932
.annotate 'line', 354
    .lex "self", param_931
    .lex "$/", param_932
.annotate 'line', 355
    new $P933, "Undef"
    .lex "$past", $P933
    find_lex $P934, "$/"
    unless_null $P934, vivify_371
    $P934 = root_new ['parrot';'Hash']
  vivify_371:
    set $P935, $P934["val"]
    unless_null $P935, vivify_372
    new $P935, "Undef"
  vivify_372:
    $P936 = $P935."ast"()
    store_lex "$past", $P936
.annotate 'line', 356
    find_lex $P937, "$past"
    find_lex $P938, "$/"
    unless_null $P938, vivify_373
    $P938 = root_new ['parrot';'Hash']
  vivify_373:
    set $P939, $P938["key"]
    unless_null $P939, vivify_374
    new $P939, "Undef"
  vivify_374:
    $P940 = $P939."Str"()
    $P937."named"($P940)
.annotate 'line', 357
    find_lex $P941, "$/"
    find_lex $P942, "$past"
    $P943 = $P941."!make"($P942)
.annotate 'line', 354
    .return ($P943)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("68_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_945
    .param pmc param_946
.annotate 'line', 360
    .lex "self", param_945
    .lex "$/", param_946
.annotate 'line', 361
    new $P947, "Undef"
    .lex "$past", $P947
.annotate 'line', 362
    find_lex $P950, "$/"
    unless_null $P950, vivify_375
    $P950 = root_new ['parrot';'Hash']
  vivify_375:
    set $P951, $P950["circumfix"]
    unless_null $P951, vivify_376
    new $P951, "Undef"
  vivify_376:
    if $P951, if_949
.annotate 'line', 363
    get_hll_global $P956, ["PAST"], "Val"
    find_lex $P957, "$/"
    unless_null $P957, vivify_377
    $P957 = root_new ['parrot';'Hash']
  vivify_377:
    set $P958, $P957["not"]
    unless_null $P958, vivify_378
    new $P958, "Undef"
  vivify_378:
    isfalse $I959, $P958
    $P960 = $P956."new"($I959 :named("value"))
    set $P948, $P960
.annotate 'line', 362
    goto if_949_end
  if_949:
    find_lex $P952, "$/"
    unless_null $P952, vivify_379
    $P952 = root_new ['parrot';'Hash']
  vivify_379:
    set $P953, $P952["circumfix"]
    unless_null $P953, vivify_380
    $P953 = root_new ['parrot';'ResizablePMCArray']
  vivify_380:
    set $P954, $P953[0]
    unless_null $P954, vivify_381
    new $P954, "Undef"
  vivify_381:
    $P955 = $P954."ast"()
    set $P948, $P955
  if_949_end:
    store_lex "$past", $P948
.annotate 'line', 364
    find_lex $P961, "$past"
    find_lex $P962, "$/"
    unless_null $P962, vivify_382
    $P962 = root_new ['parrot';'Hash']
  vivify_382:
    set $P963, $P962["identifier"]
    unless_null $P963, vivify_383
    new $P963, "Undef"
  vivify_383:
    set $S964, $P963
    $P961."named"($S964)
.annotate 'line', 365
    find_lex $P965, "$/"
    find_lex $P966, "$past"
    $P967 = $P965."!make"($P966)
.annotate 'line', 360
    .return ($P967)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("69_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_969
    .param pmc param_970
.annotate 'line', 368
    .const 'Sub' $P983 = "70_1300051186.829" 
    capture_lex $P983
    .lex "self", param_969
    .lex "$/", param_970
.annotate 'line', 369
    new $P971, "Undef"
    .lex "$past", $P971
.annotate 'line', 368
    find_lex $P972, "$past"
.annotate 'line', 370
    find_lex $P974, "$/"
    unless_null $P974, vivify_384
    $P974 = root_new ['parrot';'Hash']
  vivify_384:
    set $P975, $P974["postcircumfix"]
    unless_null $P975, vivify_385
    new $P975, "Undef"
  vivify_385:
    if $P975, if_973
.annotate 'line', 374
    .const 'Sub' $P983 = "70_1300051186.829" 
    capture_lex $P983
    $P983()
    goto if_973_end
  if_973:
.annotate 'line', 371
    find_lex $P976, "$/"
    unless_null $P976, vivify_402
    $P976 = root_new ['parrot';'Hash']
  vivify_402:
    set $P977, $P976["postcircumfix"]
    unless_null $P977, vivify_403
    new $P977, "Undef"
  vivify_403:
    $P978 = $P977."ast"()
    store_lex "$past", $P978
.annotate 'line', 372
    find_lex $P979, "$past"
    get_hll_global $P980, ["PAST"], "Var"
    $P981 = $P980."new"("$/" :named("name"))
    $P979."unshift"($P981)
  if_973_end:
.annotate 'line', 404
    find_lex $P1055, "$/"
    find_lex $P1056, "$past"
    $P1057 = $P1055."!make"($P1056)
.annotate 'line', 368
    .return ($P1057)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block982"  :anon :subid("70_1300051186.829") :outer("69_1300051186.829")
.annotate 'line', 375
    $P984 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P984
    get_hll_global $P985, ["NQP"], "Compiler"
    find_lex $P986, "$/"
    set $S987, $P986
    $P988 = $P985."parse_name"($S987)
    store_lex "@name", $P988
.annotate 'line', 376
    get_hll_global $P989, ["PAST"], "Var"
    find_lex $P990, "@name"
    $P991 = $P990."pop"()
    set $S992, $P991
    $P993 = $P989."new"($S992 :named("name"))
    store_lex "$past", $P993
.annotate 'line', 377
    find_lex $P995, "@name"
    unless $P995, if_994_end
.annotate 'line', 378
    find_lex $P997, "@name"
    unless_null $P997, vivify_386
    $P997 = root_new ['parrot';'ResizablePMCArray']
  vivify_386:
    set $P998, $P997[0]
    unless_null $P998, vivify_387
    new $P998, "Undef"
  vivify_387:
    set $S999, $P998
    iseq $I1000, $S999, "GLOBAL"
    unless $I1000, if_996_end
    find_lex $P1001, "@name"
    $P1001."shift"()
  if_996_end:
.annotate 'line', 379
    find_lex $P1002, "$past"
    find_lex $P1003, "@name"
    $P1002."namespace"($P1003)
.annotate 'line', 380
    find_lex $P1004, "$past"
    $P1004."scope"("package")
.annotate 'line', 381
    find_lex $P1005, "$past"
    find_lex $P1006, "$/"
    unless_null $P1006, vivify_388
    $P1006 = root_new ['parrot';'Hash']
  vivify_388:
    set $P1007, $P1006["sigil"]
    unless_null $P1007, vivify_389
    new $P1007, "Undef"
  vivify_389:
    $P1008 = "vivitype"($P1007)
    $P1005."viviself"($P1008)
.annotate 'line', 382
    find_lex $P1009, "$past"
    $P1009."lvalue"(1)
  if_994_end:
.annotate 'line', 384
    find_lex $P1012, "$/"
    unless_null $P1012, vivify_390
    $P1012 = root_new ['parrot';'Hash']
  vivify_390:
    set $P1013, $P1012["twigil"]
    unless_null $P1013, vivify_391
    $P1013 = root_new ['parrot';'ResizablePMCArray']
  vivify_391:
    set $P1014, $P1013[0]
    unless_null $P1014, vivify_392
    new $P1014, "Undef"
  vivify_392:
    set $S1015, $P1014
    iseq $I1016, $S1015, "*"
    if $I1016, if_1011
.annotate 'line', 397
    find_lex $P1038, "$/"
    unless_null $P1038, vivify_393
    $P1038 = root_new ['parrot';'Hash']
  vivify_393:
    set $P1039, $P1038["twigil"]
    unless_null $P1039, vivify_394
    $P1039 = root_new ['parrot';'ResizablePMCArray']
  vivify_394:
    set $P1040, $P1039[0]
    unless_null $P1040, vivify_395
    new $P1040, "Undef"
  vivify_395:
    set $S1041, $P1040
    iseq $I1042, $S1041, "!"
    if $I1042, if_1037
    new $P1036, 'Integer'
    set $P1036, $I1042
    goto if_1037_end
  if_1037:
.annotate 'line', 398
    find_lex $P1043, "$past"
    get_hll_global $P1044, ["PAST"], "Var"
    $P1045 = $P1044."new"("self" :named("name"))
    $P1043."push"($P1045)
.annotate 'line', 399
    find_lex $P1046, "$past"
    $P1046."scope"("attribute")
.annotate 'line', 400
    find_lex $P1047, "$past"
    find_lex $P1048, "$/"
    unless_null $P1048, vivify_396
    $P1048 = root_new ['parrot';'Hash']
  vivify_396:
    set $P1049, $P1048["sigil"]
    unless_null $P1049, vivify_397
    new $P1049, "Undef"
  vivify_397:
    $P1050 = "vivitype"($P1049)
    $P1047."viviself"($P1050)
.annotate 'line', 401
    find_lex $P1051, "$past"
    get_hll_global $P1052, ["PAST"], "Var"
    $P1053 = $P1052."new"("$?CLASS" :named("name"))
    $P1054 = $P1051."push"($P1053)
.annotate 'line', 397
    set $P1036, $P1054
  if_1037_end:
    set $P1010, $P1036
.annotate 'line', 384
    goto if_1011_end
  if_1011:
.annotate 'line', 385
    find_lex $P1017, "$past"
    $P1017."scope"("contextual")
.annotate 'line', 386
    find_lex $P1018, "$past"
.annotate 'line', 387
    get_hll_global $P1019, ["PAST"], "Var"
.annotate 'line', 389
    find_lex $P1020, "$/"
    unless_null $P1020, vivify_398
    $P1020 = root_new ['parrot';'Hash']
  vivify_398:
    set $P1021, $P1020["sigil"]
    unless_null $P1021, vivify_399
    new $P1021, "Undef"
  vivify_399:
    set $S1022, $P1021
    new $P1023, 'String'
    set $P1023, $S1022
    find_lex $P1024, "$/"
    unless_null $P1024, vivify_400
    $P1024 = root_new ['parrot';'Hash']
  vivify_400:
    set $P1025, $P1024["desigilname"]
    unless_null $P1025, vivify_401
    new $P1025, "Undef"
  vivify_401:
    concat $P1026, $P1023, $P1025
.annotate 'line', 391
    get_hll_global $P1027, ["PAST"], "Op"
    new $P1028, "String"
    assign $P1028, "Contextual "
    find_lex $P1029, "$/"
    set $S1030, $P1029
    concat $P1031, $P1028, $S1030
    concat $P1032, $P1031, " not found"
    $P1033 = $P1027."new"($P1032, "die" :named("pirop"))
    $P1034 = $P1019."new"("package" :named("scope"), "" :named("namespace"), $P1026 :named("name"), $P1033 :named("viviself"))
.annotate 'line', 387
    $P1035 = $P1018."viviself"($P1034)
.annotate 'line', 384
    set $P1010, $P1035
  if_1011_end:
.annotate 'line', 374
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("71_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1059
    .param pmc param_1060
.annotate 'line', 407
    .lex "self", param_1059
    .lex "$/", param_1060
    find_lex $P1061, "$/"
    find_lex $P1062, "$/"
    unless_null $P1062, vivify_404
    $P1062 = root_new ['parrot';'Hash']
  vivify_404:
    set $P1063, $P1062["package_def"]
    unless_null $P1063, vivify_405
    new $P1063, "Undef"
  vivify_405:
    $P1064 = $P1063."ast"()
    $P1065 = $P1061."!make"($P1064)
    .return ($P1065)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("72_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1067
    .param pmc param_1068
.annotate 'line', 408
    .lex "self", param_1067
    .lex "$/", param_1068
    find_lex $P1069, "$/"
    find_lex $P1070, "$/"
    unless_null $P1070, vivify_406
    $P1070 = root_new ['parrot';'Hash']
  vivify_406:
    set $P1071, $P1070["package_def"]
    unless_null $P1071, vivify_407
    new $P1071, "Undef"
  vivify_407:
    $P1072 = $P1071."ast"()
    $P1073 = $P1069."!make"($P1072)
    .return ($P1073)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("73_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1075
    .param pmc param_1076
.annotate 'line', 409
    .lex "self", param_1075
    .lex "$/", param_1076
    find_lex $P1077, "$/"
    find_lex $P1078, "$/"
    unless_null $P1078, vivify_408
    $P1078 = root_new ['parrot';'Hash']
  vivify_408:
    set $P1079, $P1078["package_def"]
    unless_null $P1079, vivify_409
    new $P1079, "Undef"
  vivify_409:
    $P1080 = $P1079."ast"()
    $P1081 = $P1077."!make"($P1080)
    .return ($P1081)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("74_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1083
    .param pmc param_1084
.annotate 'line', 410
    .lex "self", param_1083
    .lex "$/", param_1084
    find_lex $P1085, "$/"
    find_lex $P1086, "$/"
    unless_null $P1086, vivify_410
    $P1086 = root_new ['parrot';'Hash']
  vivify_410:
    set $P1087, $P1086["package_def"]
    unless_null $P1087, vivify_411
    new $P1087, "Undef"
  vivify_411:
    $P1088 = $P1087."ast"()
    $P1089 = $P1085."!make"($P1088)
    .return ($P1089)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("75_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1091
    .param pmc param_1092
.annotate 'line', 411
    .lex "self", param_1091
    .lex "$/", param_1092
    find_lex $P1093, "$/"
    find_lex $P1094, "$/"
    unless_null $P1094, vivify_412
    $P1094 = root_new ['parrot';'Hash']
  vivify_412:
    set $P1095, $P1094["package_def"]
    unless_null $P1095, vivify_413
    new $P1095, "Undef"
  vivify_413:
    $P1096 = $P1095."ast"()
    $P1097 = $P1093."!make"($P1096)
    .return ($P1097)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("76_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1099
    .param pmc param_1100
.annotate 'line', 412
    .lex "self", param_1099
    .lex "$/", param_1100
    find_lex $P1101, "$/"
    find_lex $P1102, "$/"
    unless_null $P1102, vivify_414
    $P1102 = root_new ['parrot';'Hash']
  vivify_414:
    set $P1103, $P1102["package_def"]
    unless_null $P1103, vivify_415
    new $P1103, "Undef"
  vivify_415:
    $P1104 = $P1103."ast"()
    $P1105 = $P1101."!make"($P1104)
    .return ($P1105)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("77_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1107
    .param pmc param_1108
.annotate 'line', 414
    .const 'Sub' $P1257 = "79_1300051186.829" 
    capture_lex $P1257
    .const 'Sub' $P1206 = "78_1300051186.829" 
    capture_lex $P1206
    .lex "self", param_1107
    .lex "$/", param_1108
.annotate 'line', 416
    $P1109 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1109
.annotate 'line', 417
    new $P1110, "Undef"
    .lex "$name", $P1110
.annotate 'line', 418
    new $P1111, "Undef"
    .lex "$how", $P1111
.annotate 'line', 421
    new $P1112, "Undef"
    .lex "$past", $P1112
.annotate 'line', 416
    find_lex $P1113, "$/"
    unless_null $P1113, vivify_416
    $P1113 = root_new ['parrot';'Hash']
  vivify_416:
    set $P1114, $P1113["name"]
    unless_null $P1114, vivify_417
    $P1114 = root_new ['parrot';'Hash']
  vivify_417:
    set $P1115, $P1114["identifier"]
    unless_null $P1115, vivify_418
    new $P1115, "Undef"
  vivify_418:
    clone $P1116, $P1115
    store_lex "@ns", $P1116
.annotate 'line', 417
    find_lex $P1117, "@ns"
    $P1118 = $P1117."pop"()
    set $S1119, $P1118
    new $P1120, 'String'
    set $P1120, $S1119
    store_lex "$name", $P1120
.annotate 'line', 418
    find_dynamic_lex $P1121, "$*PKGDECL"
    unless_null $P1121, vivify_419
    get_hll_global $P1121, "$PKGDECL"
    unless_null $P1121, vivify_420
    die "Contextual $*PKGDECL not found"
  vivify_420:
  vivify_419:
    find_dynamic_lex $P1122, "%*HOW"
    unless_null $P1122, vivify_421
    get_hll_global $P1122, "%HOW"
    unless_null $P1122, vivify_422
    die "Contextual %*HOW not found"
  vivify_422:
  vivify_421:
    set $P1123, $P1122[$P1121]
    unless_null $P1123, vivify_423
    new $P1123, "Undef"
  vivify_423:
    store_lex "$how", $P1123
.annotate 'line', 421
    find_lex $P1126, "$/"
    unless_null $P1126, vivify_424
    $P1126 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1127, $P1126["block"]
    unless_null $P1127, vivify_425
    new $P1127, "Undef"
  vivify_425:
    if $P1127, if_1125
    find_lex $P1131, "$/"
    unless_null $P1131, vivify_426
    $P1131 = root_new ['parrot';'Hash']
  vivify_426:
    set $P1132, $P1131["comp_unit"]
    unless_null $P1132, vivify_427
    new $P1132, "Undef"
  vivify_427:
    $P1133 = $P1132."ast"()
    set $P1124, $P1133
    goto if_1125_end
  if_1125:
    find_lex $P1128, "$/"
    unless_null $P1128, vivify_428
    $P1128 = root_new ['parrot';'Hash']
  vivify_428:
    set $P1129, $P1128["block"]
    unless_null $P1129, vivify_429
    new $P1129, "Undef"
  vivify_429:
    $P1130 = $P1129."ast"()
    set $P1124, $P1130
  if_1125_end:
    store_lex "$past", $P1124
.annotate 'line', 424
    find_dynamic_lex $P1137, "$*SCOPE"
    unless_null $P1137, vivify_430
    get_hll_global $P1137, "$SCOPE"
    unless_null $P1137, vivify_431
    die "Contextual $*SCOPE not found"
  vivify_431:
  vivify_430:
    set $S1138, $P1137
    iseq $I1139, $S1138, "our"
    unless $I1139, unless_1136
    new $P1135, 'Integer'
    set $P1135, $I1139
    goto unless_1136_end
  unless_1136:
    find_dynamic_lex $P1140, "$*SCOPE"
    unless_null $P1140, vivify_432
    get_hll_global $P1140, "$SCOPE"
    unless_null $P1140, vivify_433
    die "Contextual $*SCOPE not found"
  vivify_433:
  vivify_432:
    set $S1141, $P1140
    iseq $I1142, $S1141, ""
    new $P1135, 'Integer'
    set $P1135, $I1142
  unless_1136_end:
    if $P1135, if_1134
.annotate 'line', 429
    find_lex $P1152, "$/"
    $P1153 = $P1152."CURSOR"()
    find_dynamic_lex $P1154, "$*SCOPE"
    unless_null $P1154, vivify_434
    get_hll_global $P1154, "$SCOPE"
    unless_null $P1154, vivify_435
    die "Contextual $*SCOPE not found"
  vivify_435:
  vivify_434:
    concat $P1155, $P1154, " scoped packages are not supported"
    $P1153."panic"($P1155)
.annotate 'line', 428
    goto if_1134_end
  if_1134:
.annotate 'line', 425
    find_lex $P1143, "$past"
    find_lex $P1144, "$/"
    unless_null $P1144, vivify_436
    $P1144 = root_new ['parrot';'Hash']
  vivify_436:
    set $P1145, $P1144["name"]
    unless_null $P1145, vivify_437
    $P1145 = root_new ['parrot';'Hash']
  vivify_437:
    set $P1146, $P1145["identifier"]
    unless_null $P1146, vivify_438
    new $P1146, "Undef"
  vivify_438:
    $P1143."namespace"($P1146)
.annotate 'line', 426
    find_dynamic_lex $P1147, "$*SC"
    unless_null $P1147, vivify_439
    get_hll_global $P1147, "$SC"
    unless_null $P1147, vivify_440
    die "Contextual $*SC not found"
  vivify_440:
  vivify_439:
    find_lex $P1148, "$/"
    unless_null $P1148, vivify_441
    $P1148 = root_new ['parrot';'Hash']
  vivify_441:
    set $P1149, $P1148["name"]
    unless_null $P1149, vivify_442
    $P1149 = root_new ['parrot';'Hash']
  vivify_442:
    set $P1150, $P1149["identifier"]
    unless_null $P1150, vivify_443
    new $P1150, "Undef"
  vivify_443:
    find_dynamic_lex $P1151, "$*PKGMETA"
    unless_null $P1151, vivify_444
    get_hll_global $P1151, "$PKGMETA"
    unless_null $P1151, vivify_445
    die "Contextual $*PKGMETA not found"
  vivify_445:
  vivify_444:
    $P1147."install_package_symbol"($P1150, $P1151)
  if_1134_end:
.annotate 'line', 433
    find_dynamic_lex $P1156, "$*PACKAGE-SETUP"
    unless_null $P1156, vivify_446
    get_hll_global $P1156, "$PACKAGE-SETUP"
    unless_null $P1156, vivify_447
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_447:
  vivify_446:
    get_hll_global $P1157, ["PAST"], "Stmts"
.annotate 'line', 434
    get_hll_global $P1158, ["PAST"], "Op"
.annotate 'line', 435
    get_hll_global $P1159, ["PAST"], "Var"
    $P1160 = $P1159."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 436
    find_dynamic_lex $P1161, "$*SC"
    unless_null $P1161, vivify_448
    get_hll_global $P1161, "$SC"
    unless_null $P1161, vivify_449
    die "Contextual $*SC not found"
  vivify_449:
  vivify_448:
    find_dynamic_lex $P1162, "$*PKGMETA"
    unless_null $P1162, vivify_450
    get_hll_global $P1162, "$PKGMETA"
    unless_null $P1162, vivify_451
    die "Contextual $*PKGMETA not found"
  vivify_451:
  vivify_450:
    $P1163 = $P1161."get_slot_past_for_object"($P1162)
    $P1164 = $P1158."new"($P1160, $P1163, "bind" :named("pasttype"))
.annotate 'line', 438
    get_hll_global $P1165, ["PAST"], "Op"
.annotate 'line', 439
    get_hll_global $P1166, ["PAST"], "Var"
    $P1167 = $P1166."new"("$?CLASS" :named("name"))
.annotate 'line', 440
    get_hll_global $P1168, ["PAST"], "Var"
    $P1169 = $P1168."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1170 = $P1165."new"($P1167, $P1169, "bind" :named("pasttype"))
.annotate 'line', 438
    $P1171 = $P1157."new"($P1164, $P1170)
.annotate 'line', 433
    $P1156."unshift"($P1171)
.annotate 'line', 449
    find_lex $P1175, "$how"
    can $I1176, $P1175, "parametric"
    if $I1176, if_1174
    new $P1173, 'Integer'
    set $P1173, $I1176
    goto if_1174_end
  if_1174:
    find_lex $P1177, "$how"
    find_lex $P1178, "$how"
    $P1179 = $P1177."parametric"($P1178)
    set $P1173, $P1179
  if_1174_end:
    if $P1173, if_1172
.annotate 'line', 465
    find_lex $P1197, "$past"
    $P1197."blocktype"("immediate")
.annotate 'line', 466
    find_lex $P1198, "$past"
    get_hll_global $P1199, ["PAST"], "Var"
    $P1200 = $P1199."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1198."unshift"($P1200)
.annotate 'line', 467
    find_lex $P1201, "$past"
    $P1201."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 464
    goto if_1172_end
  if_1172:
.annotate 'line', 450
    find_lex $P1180, "$past"
    $P1180."blocktype"("declaration")
.annotate 'line', 451
    find_lex $P1181, "$past"
    get_hll_global $P1182, ["PAST"], "Var"
    $P1183 = $P1182."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1181."unshift"($P1183)
.annotate 'line', 452
    find_lex $P1184, "$past"
    $P1184."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 453
    find_dynamic_lex $P1185, "$*PACKAGE-SETUP"
    unless_null $P1185, vivify_452
    get_hll_global $P1185, "$PACKAGE-SETUP"
    unless_null $P1185, vivify_453
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_453:
  vivify_452:
    get_hll_global $P1186, ["PAST"], "Op"
.annotate 'line', 455
    get_hll_global $P1187, ["PAST"], "Op"
.annotate 'line', 458
    get_hll_global $P1188, ["PAST"], "Var"
    $P1189 = $P1188."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1190 = $P1187."new"($P1189, "get_how PP" :named("pirop"))
.annotate 'line', 460
    get_hll_global $P1191, ["PAST"], "Var"
    $P1192 = $P1191."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 461
    get_hll_global $P1193, ["PAST"], "Val"
    find_lex $P1194, "$past"
    $P1195 = $P1193."new"($P1194 :named("value"))
    $P1196 = $P1186."new"($P1190, $P1192, $P1195, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 453
    $P1185."push"($P1196)
  if_1172_end:
.annotate 'line', 472
    find_lex $P1203, "$/"
    unless_null $P1203, vivify_454
    $P1203 = root_new ['parrot';'Hash']
  vivify_454:
    set $P1204, $P1203["parent"]
    unless_null $P1204, vivify_455
    new $P1204, "Undef"
  vivify_455:
    if $P1204, if_1202
.annotate 'line', 486
    find_dynamic_lex $P1234, "$*PKGDECL"
    unless_null $P1234, vivify_456
    get_hll_global $P1234, "$PKGDECL"
    unless_null $P1234, vivify_457
    die "Contextual $*PKGDECL not found"
  vivify_457:
  vivify_456:
    set $S1235, $P1234
    iseq $I1236, $S1235, "grammar"
    unless $I1236, if_1233_end
.annotate 'line', 487
    find_dynamic_lex $P1237, "$*PACKAGE-SETUP"
    unless_null $P1237, vivify_458
    get_hll_global $P1237, "$PACKAGE-SETUP"
    unless_null $P1237, vivify_459
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_459:
  vivify_458:
    get_hll_global $P1238, ["PAST"], "Op"
.annotate 'line', 489
    get_hll_global $P1239, ["PAST"], "Op"
.annotate 'line', 492
    get_hll_global $P1240, ["PAST"], "Var"
    $P1241 = $P1240."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1242 = $P1239."new"($P1241, "get_how PP" :named("pirop"))
.annotate 'line', 494
    get_hll_global $P1243, ["PAST"], "Var"
    $P1244 = $P1243."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 495
    get_hll_global $P1245, ["PAST"], "Var"
    $P1246 = $P1245."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1247 = $P1238."new"($P1242, $P1244, $P1246, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 487
    $P1237."push"($P1247)
  if_1233_end:
.annotate 'line', 486
    goto if_1202_end
  if_1202:
.annotate 'line', 472
    .const 'Sub' $P1206 = "78_1300051186.829" 
    capture_lex $P1206
    $P1206()
  if_1202_end:
.annotate 'line', 500
    find_lex $P1249, "$/"
    unless_null $P1249, vivify_466
    $P1249 = root_new ['parrot';'Hash']
  vivify_466:
    set $P1250, $P1249["role"]
    unless_null $P1250, vivify_467
    new $P1250, "Undef"
  vivify_467:
    unless $P1250, if_1248_end
.annotate 'line', 501
    find_lex $P1252, "$/"
    unless_null $P1252, vivify_468
    $P1252 = root_new ['parrot';'Hash']
  vivify_468:
    set $P1253, $P1252["role"]
    unless_null $P1253, vivify_469
    new $P1253, "Undef"
  vivify_469:
    defined $I1254, $P1253
    unless $I1254, for_undef_470
    iter $P1251, $P1253
    new $P1284, 'ExceptionHandler'
    set_label $P1284, loop1283_handler
    $P1284."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1284
  loop1283_test:
    unless $P1251, loop1283_done
    shift $P1255, $P1251
  loop1283_redo:
    .const 'Sub' $P1257 = "79_1300051186.829" 
    capture_lex $P1257
    $P1257($P1255)
  loop1283_next:
    goto loop1283_test
  loop1283_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1285, exception, 'type'
    eq $P1285, .CONTROL_LOOP_NEXT, loop1283_next
    eq $P1285, .CONTROL_LOOP_REDO, loop1283_redo
  loop1283_done:
    pop_eh 
  for_undef_470:
  if_1248_end:
.annotate 'line', 518
    find_dynamic_lex $P1286, "$*PACKAGE-SETUP"
    unless_null $P1286, vivify_475
    get_hll_global $P1286, "$PACKAGE-SETUP"
    unless_null $P1286, vivify_476
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_476:
  vivify_475:
    get_hll_global $P1287, ["PAST"], "Op"
.annotate 'line', 520
    get_hll_global $P1288, ["PAST"], "Op"
.annotate 'line', 523
    get_hll_global $P1289, ["PAST"], "Var"
    $P1290 = $P1289."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1291 = $P1288."new"($P1290, "get_how PP" :named("pirop"))
.annotate 'line', 525
    get_hll_global $P1292, ["PAST"], "Var"
    $P1293 = $P1292."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1294 = $P1287."new"($P1291, $P1293, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 518
    $P1286."push"($P1294)
.annotate 'line', 529
    find_lex $P1295, "$past"
    $P1296 = $P1295."loadinit"()
    get_hll_global $P1297, ["PAST"], "Block"
    find_dynamic_lex $P1298, "$*PACKAGE-SETUP"
    unless_null $P1298, vivify_477
    get_hll_global $P1298, "$PACKAGE-SETUP"
    unless_null $P1298, vivify_478
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_478:
  vivify_477:
    $P1299 = $P1297."new"($P1298, "immediate" :named("blocktype"))
    $P1296."push"($P1299)
.annotate 'line', 531
    find_lex $P1300, "$/"
    find_lex $P1301, "$past"
    $P1302 = $P1300."!make"($P1301)
.annotate 'line', 414
    .return ($P1302)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1205"  :anon :subid("78_1300051186.829") :outer("77_1300051186.829")
.annotate 'line', 473
    $P1207 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1207
.annotate 'line', 474
    new $P1208, "Undef"
    .lex "$name", $P1208
.annotate 'line', 473
    find_lex $P1209, "$/"
    unless_null $P1209, vivify_460
    $P1209 = root_new ['parrot';'Hash']
  vivify_460:
    set $P1210, $P1209["parent"]
    unless_null $P1210, vivify_461
    $P1210 = root_new ['parrot';'ResizablePMCArray']
  vivify_461:
    set $P1211, $P1210[0]
    unless_null $P1211, vivify_462
    $P1211 = root_new ['parrot';'Hash']
  vivify_462:
    set $P1212, $P1211["identifier"]
    unless_null $P1212, vivify_463
    new $P1212, "Undef"
  vivify_463:
    clone $P1213, $P1212
    store_lex "@ns", $P1213
.annotate 'line', 474
    find_lex $P1214, "@ns"
    $P1215 = $P1214."pop"()
    set $S1216, $P1215
    new $P1217, 'String'
    set $P1217, $S1216
    store_lex "$name", $P1217
.annotate 'line', 475
    find_dynamic_lex $P1218, "$*PACKAGE-SETUP"
    unless_null $P1218, vivify_464
    get_hll_global $P1218, "$PACKAGE-SETUP"
    unless_null $P1218, vivify_465
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_465:
  vivify_464:
    get_hll_global $P1219, ["PAST"], "Op"
.annotate 'line', 477
    get_hll_global $P1220, ["PAST"], "Op"
.annotate 'line', 480
    get_hll_global $P1221, ["PAST"], "Var"
    $P1222 = $P1221."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1223 = $P1220."new"($P1222, "get_how PP" :named("pirop"))
.annotate 'line', 482
    get_hll_global $P1224, ["PAST"], "Var"
    $P1225 = $P1224."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 483
    get_hll_global $P1226, ["PAST"], "Var"
    find_lex $P1227, "$name"
    set $S1228, $P1227
    find_lex $P1229, "@ns"
    $P1230 = $P1226."new"($S1228 :named("name"), $P1229 :named("namespace"), "package" :named("scope"))
    $P1231 = $P1219."new"($P1223, $P1225, $P1230, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 475
    $P1232 = $P1218."push"($P1231)
.annotate 'line', 472
    .return ($P1232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1256"  :anon :subid("79_1300051186.829") :outer("77_1300051186.829")
    .param pmc param_1260
.annotate 'line', 502
    $P1258 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1258
.annotate 'line', 503
    new $P1259, "Undef"
    .lex "$name", $P1259
    .lex "$_", param_1260
.annotate 'line', 502
    find_lex $P1261, "$_"
    unless_null $P1261, vivify_471
    $P1261 = root_new ['parrot';'Hash']
  vivify_471:
    set $P1262, $P1261["identifier"]
    unless_null $P1262, vivify_472
    new $P1262, "Undef"
  vivify_472:
    clone $P1263, $P1262
    store_lex "@ns", $P1263
.annotate 'line', 503
    find_lex $P1264, "@ns"
    $P1265 = $P1264."pop"()
    set $S1266, $P1265
    new $P1267, 'String'
    set $P1267, $S1266
    store_lex "$name", $P1267
.annotate 'line', 504
    find_dynamic_lex $P1268, "$*PACKAGE-SETUP"
    unless_null $P1268, vivify_473
    get_hll_global $P1268, "$PACKAGE-SETUP"
    unless_null $P1268, vivify_474
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_474:
  vivify_473:
    get_hll_global $P1269, ["PAST"], "Op"
.annotate 'line', 506
    get_hll_global $P1270, ["PAST"], "Op"
.annotate 'line', 509
    get_hll_global $P1271, ["PAST"], "Var"
    $P1272 = $P1271."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1273 = $P1270."new"($P1272, "get_how PP" :named("pirop"))
.annotate 'line', 511
    get_hll_global $P1274, ["PAST"], "Var"
    $P1275 = $P1274."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 512
    get_hll_global $P1276, ["PAST"], "Var"
    find_lex $P1277, "$name"
    set $S1278, $P1277
    find_lex $P1279, "@ns"
    $P1280 = $P1276."new"($S1278 :named("name"), $P1279 :named("namespace"), "package" :named("scope"))
    $P1281 = $P1269."new"($P1273, $P1275, $P1280, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 504
    $P1282 = $P1268."push"($P1281)
.annotate 'line', 501
    .return ($P1282)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("80_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1304
    .param pmc param_1305
.annotate 'line', 534
    .lex "self", param_1304
    .lex "$/", param_1305
    find_lex $P1306, "$/"
    find_lex $P1307, "$/"
    unless_null $P1307, vivify_479
    $P1307 = root_new ['parrot';'Hash']
  vivify_479:
    set $P1308, $P1307["scoped"]
    unless_null $P1308, vivify_480
    new $P1308, "Undef"
  vivify_480:
    $P1309 = $P1308."ast"()
    $P1310 = $P1306."!make"($P1309)
    .return ($P1310)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("81_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1312
    .param pmc param_1313
.annotate 'line', 535
    .lex "self", param_1312
    .lex "$/", param_1313
    find_lex $P1314, "$/"
    find_lex $P1315, "$/"
    unless_null $P1315, vivify_481
    $P1315 = root_new ['parrot';'Hash']
  vivify_481:
    set $P1316, $P1315["scoped"]
    unless_null $P1316, vivify_482
    new $P1316, "Undef"
  vivify_482:
    $P1317 = $P1316."ast"()
    $P1318 = $P1314."!make"($P1317)
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("82_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1320
    .param pmc param_1321
.annotate 'line', 536
    .lex "self", param_1320
    .lex "$/", param_1321
    find_lex $P1322, "$/"
    find_lex $P1323, "$/"
    unless_null $P1323, vivify_483
    $P1323 = root_new ['parrot';'Hash']
  vivify_483:
    set $P1324, $P1323["scoped"]
    unless_null $P1324, vivify_484
    new $P1324, "Undef"
  vivify_484:
    $P1325 = $P1324."ast"()
    $P1326 = $P1322."!make"($P1325)
    .return ($P1326)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("83_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1328
    .param pmc param_1329
.annotate 'line', 538
    .lex "self", param_1328
    .lex "$/", param_1329
.annotate 'line', 539
    find_lex $P1330, "$/"
    find_lex $P1333, "$/"
    unless_null $P1333, vivify_485
    $P1333 = root_new ['parrot';'Hash']
  vivify_485:
    set $P1334, $P1333["declarator"]
    unless_null $P1334, vivify_486
    new $P1334, "Undef"
  vivify_486:
    if $P1334, if_1332
.annotate 'line', 540
    find_lex $P1340, "$/"
    unless_null $P1340, vivify_487
    $P1340 = root_new ['parrot';'Hash']
  vivify_487:
    set $P1341, $P1340["multi_declarator"]
    unless_null $P1341, vivify_488
    new $P1341, "Undef"
  vivify_488:
    if $P1341, if_1339
.annotate 'line', 541
    find_lex $P1345, "$/"
    unless_null $P1345, vivify_489
    $P1345 = root_new ['parrot';'Hash']
  vivify_489:
    set $P1346, $P1345["package_declarator"]
    unless_null $P1346, vivify_490
    new $P1346, "Undef"
  vivify_490:
    $P1347 = $P1346."ast"()
    set $P1338, $P1347
.annotate 'line', 540
    goto if_1339_end
  if_1339:
    find_lex $P1342, "$/"
    unless_null $P1342, vivify_491
    $P1342 = root_new ['parrot';'Hash']
  vivify_491:
    set $P1343, $P1342["multi_declarator"]
    unless_null $P1343, vivify_492
    new $P1343, "Undef"
  vivify_492:
    $P1344 = $P1343."ast"()
    set $P1338, $P1344
  if_1339_end:
    set $P1331, $P1338
.annotate 'line', 539
    goto if_1332_end
  if_1332:
    find_lex $P1335, "$/"
    unless_null $P1335, vivify_493
    $P1335 = root_new ['parrot';'Hash']
  vivify_493:
    set $P1336, $P1335["declarator"]
    unless_null $P1336, vivify_494
    new $P1336, "Undef"
  vivify_494:
    $P1337 = $P1336."ast"()
    set $P1331, $P1337
  if_1332_end:
    $P1348 = $P1330."!make"($P1331)
.annotate 'line', 538
    .return ($P1348)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("84_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1350
    .param pmc param_1351
.annotate 'line', 544
    .lex "self", param_1350
    .lex "$/", param_1351
.annotate 'line', 545
    find_lex $P1352, "$/"
.annotate 'line', 546
    find_lex $P1355, "$/"
    unless_null $P1355, vivify_495
    $P1355 = root_new ['parrot';'Hash']
  vivify_495:
    set $P1356, $P1355["routine_declarator"]
    unless_null $P1356, vivify_496
    new $P1356, "Undef"
  vivify_496:
    if $P1356, if_1354
.annotate 'line', 547
    find_lex $P1360, "$/"
    unless_null $P1360, vivify_497
    $P1360 = root_new ['parrot';'Hash']
  vivify_497:
    set $P1361, $P1360["variable_declarator"]
    unless_null $P1361, vivify_498
    new $P1361, "Undef"
  vivify_498:
    $P1362 = $P1361."ast"()
    set $P1353, $P1362
.annotate 'line', 546
    goto if_1354_end
  if_1354:
    find_lex $P1357, "$/"
    unless_null $P1357, vivify_499
    $P1357 = root_new ['parrot';'Hash']
  vivify_499:
    set $P1358, $P1357["routine_declarator"]
    unless_null $P1358, vivify_500
    new $P1358, "Undef"
  vivify_500:
    $P1359 = $P1358."ast"()
    set $P1353, $P1359
  if_1354_end:
    $P1363 = $P1352."!make"($P1353)
.annotate 'line', 544
    .return ($P1363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("85_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1365
    .param pmc param_1366
.annotate 'line', 550
    .lex "self", param_1365
    .lex "$/", param_1366
    find_lex $P1367, "$/"
    find_lex $P1370, "$/"
    unless_null $P1370, vivify_501
    $P1370 = root_new ['parrot';'Hash']
  vivify_501:
    set $P1371, $P1370["declarator"]
    unless_null $P1371, vivify_502
    new $P1371, "Undef"
  vivify_502:
    if $P1371, if_1369
    find_lex $P1375, "$/"
    unless_null $P1375, vivify_503
    $P1375 = root_new ['parrot';'Hash']
  vivify_503:
    set $P1376, $P1375["routine_def"]
    unless_null $P1376, vivify_504
    new $P1376, "Undef"
  vivify_504:
    $P1377 = $P1376."ast"()
    set $P1368, $P1377
    goto if_1369_end
  if_1369:
    find_lex $P1372, "$/"
    unless_null $P1372, vivify_505
    $P1372 = root_new ['parrot';'Hash']
  vivify_505:
    set $P1373, $P1372["declarator"]
    unless_null $P1373, vivify_506
    new $P1373, "Undef"
  vivify_506:
    $P1374 = $P1373."ast"()
    set $P1368, $P1374
  if_1369_end:
    $P1378 = $P1367."!make"($P1368)
    .return ($P1378)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("86_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1380
    .param pmc param_1381
.annotate 'line', 551
    .lex "self", param_1380
    .lex "$/", param_1381
    find_lex $P1382, "$/"
    find_lex $P1385, "$/"
    unless_null $P1385, vivify_507
    $P1385 = root_new ['parrot';'Hash']
  vivify_507:
    set $P1386, $P1385["declarator"]
    unless_null $P1386, vivify_508
    new $P1386, "Undef"
  vivify_508:
    if $P1386, if_1384
    find_lex $P1390, "$/"
    unless_null $P1390, vivify_509
    $P1390 = root_new ['parrot';'Hash']
  vivify_509:
    set $P1391, $P1390["routine_def"]
    unless_null $P1391, vivify_510
    new $P1391, "Undef"
  vivify_510:
    $P1392 = $P1391."ast"()
    set $P1383, $P1392
    goto if_1384_end
  if_1384:
    find_lex $P1387, "$/"
    unless_null $P1387, vivify_511
    $P1387 = root_new ['parrot';'Hash']
  vivify_511:
    set $P1388, $P1387["declarator"]
    unless_null $P1388, vivify_512
    new $P1388, "Undef"
  vivify_512:
    $P1389 = $P1388."ast"()
    set $P1383, $P1389
  if_1384_end:
    $P1393 = $P1382."!make"($P1383)
    .return ($P1393)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("87_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1395
    .param pmc param_1396
.annotate 'line', 552
    .lex "self", param_1395
    .lex "$/", param_1396
    find_lex $P1397, "$/"
    find_lex $P1398, "$/"
    unless_null $P1398, vivify_513
    $P1398 = root_new ['parrot';'Hash']
  vivify_513:
    set $P1399, $P1398["declarator"]
    unless_null $P1399, vivify_514
    new $P1399, "Undef"
  vivify_514:
    $P1400 = $P1399."ast"()
    $P1401 = $P1397."!make"($P1400)
    .return ($P1401)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("88_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1403
    .param pmc param_1404
.annotate 'line', 555
    .const 'Sub' $P1476 = "91_1300051186.829" 
    capture_lex $P1476
    .const 'Sub' $P1431 = "89_1300051186.829" 
    capture_lex $P1431
    .lex "self", param_1403
    .lex "$/", param_1404
.annotate 'line', 556
    new $P1405, "Undef"
    .lex "$past", $P1405
.annotate 'line', 557
    new $P1406, "Undef"
    .lex "$sigil", $P1406
.annotate 'line', 558
    new $P1407, "Undef"
    .lex "$name", $P1407
.annotate 'line', 559
    new $P1408, "Undef"
    .lex "$BLOCK", $P1408
.annotate 'line', 556
    find_lex $P1409, "$/"
    unless_null $P1409, vivify_515
    $P1409 = root_new ['parrot';'Hash']
  vivify_515:
    set $P1410, $P1409["variable"]
    unless_null $P1410, vivify_516
    new $P1410, "Undef"
  vivify_516:
    $P1411 = $P1410."ast"()
    store_lex "$past", $P1411
.annotate 'line', 557
    find_lex $P1412, "$/"
    unless_null $P1412, vivify_517
    $P1412 = root_new ['parrot';'Hash']
  vivify_517:
    set $P1413, $P1412["variable"]
    unless_null $P1413, vivify_518
    $P1413 = root_new ['parrot';'Hash']
  vivify_518:
    set $P1414, $P1413["sigil"]
    unless_null $P1414, vivify_519
    new $P1414, "Undef"
  vivify_519:
    store_lex "$sigil", $P1414
.annotate 'line', 558
    find_lex $P1415, "$past"
    $P1416 = $P1415."name"()
    store_lex "$name", $P1416
.annotate 'line', 559
    get_global $P1417, "@BLOCK"
    unless_null $P1417, vivify_520
    $P1417 = root_new ['parrot';'ResizablePMCArray']
  vivify_520:
    set $P1418, $P1417[0]
    unless_null $P1418, vivify_521
    new $P1418, "Undef"
  vivify_521:
    store_lex "$BLOCK", $P1418
.annotate 'line', 560
    find_lex $P1420, "$BLOCK"
    find_lex $P1421, "$name"
    $P1422 = $P1420."symbol"($P1421)
    unless $P1422, if_1419_end
.annotate 'line', 561
    find_lex $P1423, "$/"
    $P1424 = $P1423."CURSOR"()
    find_lex $P1425, "$name"
    $P1424."panic"("Redeclaration of symbol ", $P1425)
  if_1419_end:
.annotate 'line', 563
    find_dynamic_lex $P1427, "$*SCOPE"
    unless_null $P1427, vivify_522
    get_hll_global $P1427, "$SCOPE"
    unless_null $P1427, vivify_523
    die "Contextual $*SCOPE not found"
  vivify_523:
  vivify_522:
    set $S1428, $P1427
    iseq $I1429, $S1428, "has"
    if $I1429, if_1426
.annotate 'line', 588
    .const 'Sub' $P1476 = "91_1300051186.829" 
    capture_lex $P1476
    $P1476()
    goto if_1426_end
  if_1426:
.annotate 'line', 563
    .const 'Sub' $P1431 = "89_1300051186.829" 
    capture_lex $P1431
    $P1431()
  if_1426_end:
.annotate 'line', 596
    find_lex $P1500, "$/"
    find_lex $P1501, "$past"
    $P1502 = $P1500."!make"($P1501)
.annotate 'line', 555
    .return ($P1502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1475"  :anon :subid("91_1300051186.829") :outer("88_1300051186.829")
.annotate 'line', 589
    new $P1477, "Undef"
    .lex "$scope", $P1477
.annotate 'line', 590
    new $P1478, "Undef"
    .lex "$decl", $P1478
.annotate 'line', 589
    find_dynamic_lex $P1481, "$*SCOPE"
    unless_null $P1481, vivify_524
    get_hll_global $P1481, "$SCOPE"
    unless_null $P1481, vivify_525
    die "Contextual $*SCOPE not found"
  vivify_525:
  vivify_524:
    set $S1482, $P1481
    iseq $I1483, $S1482, "our"
    if $I1483, if_1480
    new $P1485, "String"
    assign $P1485, "lexical"
    set $P1479, $P1485
    goto if_1480_end
  if_1480:
    new $P1484, "String"
    assign $P1484, "package"
    set $P1479, $P1484
  if_1480_end:
    store_lex "$scope", $P1479
.annotate 'line', 590
    get_hll_global $P1486, ["PAST"], "Var"
    find_lex $P1487, "$name"
    find_lex $P1488, "$scope"
.annotate 'line', 591
    find_lex $P1489, "$sigil"
    $P1490 = "vivitype"($P1489)
    find_lex $P1491, "$/"
    $P1492 = $P1486."new"($P1487 :named("name"), $P1488 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1490 :named("viviself"), $P1491 :named("node"))
.annotate 'line', 590
    store_lex "$decl", $P1492
.annotate 'line', 593
    find_lex $P1493, "$BLOCK"
    find_lex $P1494, "$name"
    find_lex $P1495, "$scope"
    $P1493."symbol"($P1494, $P1495 :named("scope"))
.annotate 'line', 594
    find_lex $P1496, "$BLOCK"
    unless_null $P1496, vivify_526
    $P1496 = root_new ['parrot';'ResizablePMCArray']
  vivify_526:
    set $P1497, $P1496[0]
    unless_null $P1497, vivify_527
    new $P1497, "Undef"
  vivify_527:
    find_lex $P1498, "$decl"
    $P1499 = $P1497."push"($P1498)
.annotate 'line', 588
    .return ($P1499)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1430"  :anon :subid("89_1300051186.829") :outer("88_1300051186.829")
.annotate 'line', 563
    .const 'Sub' $P1461 = "90_1300051186.829" 
    capture_lex $P1461
.annotate 'line', 565
    new $P1432, "Undef"
    .lex "$meta-attr-type", $P1432
.annotate 'line', 573
    new $P1433, "Undef"
    .lex "$meta_args", $P1433
.annotate 'line', 565
    find_dynamic_lex $P1436, "$*PKGDECL"
    unless_null $P1436, vivify_528
    get_hll_global $P1436, "$PKGDECL"
    unless_null $P1436, vivify_529
    die "Contextual $*PKGDECL not found"
  vivify_529:
  vivify_528:
    find_dynamic_lex $P1437, "%*HOW-METAATTR"
    unless_null $P1437, vivify_530
    get_hll_global $P1437, "%HOW-METAATTR"
    unless_null $P1437, vivify_531
    die "Contextual %*HOW-METAATTR not found"
  vivify_531:
  vivify_530:
    set $P1438, $P1437[$P1436]
    unless_null $P1438, vivify_532
    new $P1438, "Undef"
  vivify_532:
    unless $P1438, unless_1435
    set $P1434, $P1438
    goto unless_1435_end
  unless_1435:
    find_dynamic_lex $P1439, "$*DEFAULT-METAATTR"
    unless_null $P1439, vivify_533
    get_hll_global $P1439, "$DEFAULT-METAATTR"
    unless_null $P1439, vivify_534
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_534:
  vivify_533:
    set $P1434, $P1439
  unless_1435_end:
    store_lex "$meta-attr-type", $P1434
.annotate 'line', 566
    find_dynamic_lex $P1440, "$*PACKAGE-SETUP"
    unless_null $P1440, vivify_535
    get_hll_global $P1440, "$PACKAGE-SETUP"
    unless_null $P1440, vivify_536
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_536:
  vivify_535:
    get_hll_global $P1441, ["PAST"], "Op"
.annotate 'line', 568
    get_hll_global $P1442, ["PAST"], "Op"
.annotate 'line', 570
    get_hll_global $P1443, ["PAST"], "Var"
    $P1444 = $P1443."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1445 = $P1442."new"($P1444, "get_how PP" :named("pirop"))
.annotate 'line', 572
    get_hll_global $P1446, ["PAST"], "Var"
    $P1447 = $P1446."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 573
    get_hll_global $P1448, ["PAST"], "Op"
.annotate 'line', 575
    get_hll_global $P1449, ["PAST"], "Var"
    find_lex $P1450, "$meta-attr-type"
    $P1451 = $P1449."new"($P1450 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 576
    get_hll_global $P1452, ["PAST"], "Val"
    find_lex $P1453, "$name"
    $P1454 = $P1452."new"($P1453 :named("value"), "name" :named("named"))
    $P1455 = $P1448."new"($P1451, $P1454, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 573
    store_lex "$meta_args", $P1455
    $P1456 = $P1441."new"($P1445, $P1447, $P1455, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 566
    $P1440."push"($P1456)
.annotate 'line', 579
    find_lex $P1458, "$/"
    unless_null $P1458, vivify_537
    $P1458 = root_new ['parrot';'Hash']
  vivify_537:
    set $P1459, $P1458["typename"]
    unless_null $P1459, vivify_538
    new $P1459, "Undef"
  vivify_538:
    unless $P1459, if_1457_end
    .const 'Sub' $P1461 = "90_1300051186.829" 
    capture_lex $P1461
    $P1461()
  if_1457_end:
.annotate 'line', 585
    find_lex $P1471, "$BLOCK"
    find_lex $P1472, "$name"
    $P1471."symbol"($P1472, "attribute" :named("scope"))
.annotate 'line', 586
    get_hll_global $P1473, ["PAST"], "Stmts"
    $P1474 = $P1473."new"()
    store_lex "$past", $P1474
.annotate 'line', 563
    .return ($P1474)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1460"  :anon :subid("90_1300051186.829") :outer("89_1300051186.829")
.annotate 'line', 580
    new $P1462, "Undef"
    .lex "$type", $P1462
    find_lex $P1463, "$/"
    unless_null $P1463, vivify_539
    $P1463 = root_new ['parrot';'Hash']
  vivify_539:
    set $P1464, $P1463["typename"]
    unless_null $P1464, vivify_540
    $P1464 = root_new ['parrot';'ResizablePMCArray']
  vivify_540:
    set $P1465, $P1464[0]
    unless_null $P1465, vivify_541
    new $P1465, "Undef"
  vivify_541:
    $P1466 = $P1465."ast"()
    store_lex "$type", $P1466
.annotate 'line', 581
    find_lex $P1467, "$type"
    $P1467."named"("type")
.annotate 'line', 582
    find_lex $P1468, "$meta_args"
    find_lex $P1469, "$type"
    $P1470 = $P1468."push"($P1469)
.annotate 'line', 579
    .return ($P1470)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("92_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1504
    .param pmc param_1505
.annotate 'line', 599
    .lex "self", param_1504
    .lex "$/", param_1505
    find_lex $P1506, "$/"
    find_lex $P1507, "$/"
    unless_null $P1507, vivify_542
    $P1507 = root_new ['parrot';'Hash']
  vivify_542:
    set $P1508, $P1507["routine_def"]
    unless_null $P1508, vivify_543
    new $P1508, "Undef"
  vivify_543:
    $P1509 = $P1508."ast"()
    $P1510 = $P1506."!make"($P1509)
    .return ($P1510)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("93_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1512
    .param pmc param_1513
.annotate 'line', 600
    .lex "self", param_1512
    .lex "$/", param_1513
    find_lex $P1514, "$/"
    find_lex $P1515, "$/"
    unless_null $P1515, vivify_544
    $P1515 = root_new ['parrot';'Hash']
  vivify_544:
    set $P1516, $P1515["method_def"]
    unless_null $P1516, vivify_545
    new $P1516, "Undef"
  vivify_545:
    $P1517 = $P1516."ast"()
    $P1518 = $P1514."!make"($P1517)
    .return ($P1518)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("94_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1520
    .param pmc param_1521
.annotate 'line', 602
    .const 'Sub' $P1749 = "100_1300051186.829" 
    capture_lex $P1749
    .const 'Sub' $P1541 = "95_1300051186.829" 
    capture_lex $P1541
    .lex "self", param_1520
    .lex "$/", param_1521
.annotate 'line', 605
    new $P1522, "Undef"
    .lex "$past", $P1522
.annotate 'line', 616
    new $P1523, "Undef"
    .lex "$block", $P1523
.annotate 'line', 602
    find_lex $P1524, "$past"
.annotate 'line', 606
    find_lex $P1526, "$/"
    unless_null $P1526, vivify_546
    $P1526 = root_new ['parrot';'Hash']
  vivify_546:
    set $P1527, $P1526["onlystar"]
    unless_null $P1527, vivify_547
    new $P1527, "Undef"
  vivify_547:
    if $P1527, if_1525
.annotate 'line', 610
    find_lex $P1529, "$/"
    unless_null $P1529, vivify_548
    $P1529 = root_new ['parrot';'Hash']
  vivify_548:
    set $P1530, $P1529["blockoid"]
    unless_null $P1530, vivify_549
    new $P1530, "Undef"
  vivify_549:
    $P1531 = $P1530."ast"()
    store_lex "$past", $P1531
.annotate 'line', 611
    find_lex $P1532, "$past"
    $P1532."blocktype"("declaration")
.annotate 'line', 612
    find_dynamic_lex $P1534, "$*RETURN_USED"
    unless_null $P1534, vivify_550
    get_hll_global $P1534, "$RETURN_USED"
    unless_null $P1534, vivify_551
    die "Contextual $*RETURN_USED not found"
  vivify_551:
  vivify_550:
    unless $P1534, if_1533_end
.annotate 'line', 613
    find_lex $P1535, "$past"
    $P1535."control"("return_pir")
  if_1533_end:
.annotate 'line', 609
    goto if_1525_end
  if_1525:
.annotate 'line', 607
    $P1528 = "only_star_block"()
    store_lex "$past", $P1528
  if_1525_end:
.annotate 'line', 616
    find_lex $P1536, "$past"
    store_lex "$block", $P1536
.annotate 'line', 618
    find_lex $P1538, "$/"
    unless_null $P1538, vivify_552
    $P1538 = root_new ['parrot';'Hash']
  vivify_552:
    set $P1539, $P1538["deflongname"]
    unless_null $P1539, vivify_553
    new $P1539, "Undef"
  vivify_553:
    unless $P1539, if_1537_end
    .const 'Sub' $P1541 = "95_1300051186.829" 
    capture_lex $P1541
    $P1541()
  if_1537_end:
.annotate 'line', 718
    find_lex $P1738, "$block"
    find_lex $P1739, "$past"
    unless_null $P1739, vivify_614
    $P1739 = root_new ['parrot';'Hash']
    store_lex "$past", $P1739
  vivify_614:
    set $P1739["block_past"], $P1738
.annotate 'line', 719
    find_lex $P1741, "$/"
    unless_null $P1741, vivify_615
    $P1741 = root_new ['parrot';'Hash']
  vivify_615:
    set $P1742, $P1741["trait"]
    unless_null $P1742, vivify_616
    new $P1742, "Undef"
  vivify_616:
    unless $P1742, if_1740_end
.annotate 'line', 720
    find_lex $P1744, "$/"
    unless_null $P1744, vivify_617
    $P1744 = root_new ['parrot';'Hash']
  vivify_617:
    set $P1745, $P1744["trait"]
    unless_null $P1745, vivify_618
    new $P1745, "Undef"
  vivify_618:
    defined $I1746, $P1745
    unless $I1746, for_undef_619
    iter $P1743, $P1745
    new $P1756, 'ExceptionHandler'
    set_label $P1756, loop1755_handler
    $P1756."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1756
  loop1755_test:
    unless $P1743, loop1755_done
    shift $P1747, $P1743
  loop1755_redo:
    .const 'Sub' $P1749 = "100_1300051186.829" 
    capture_lex $P1749
    $P1749($P1747)
  loop1755_next:
    goto loop1755_test
  loop1755_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1757, exception, 'type'
    eq $P1757, .CONTROL_LOOP_NEXT, loop1755_next
    eq $P1757, .CONTROL_LOOP_REDO, loop1755_redo
  loop1755_done:
    pop_eh 
  for_undef_619:
  if_1740_end:
.annotate 'line', 723
    find_lex $P1758, "$/"
    find_lex $P1759, "$past"
    $P1760 = $P1758."!make"($P1759)
.annotate 'line', 602
    .return ($P1760)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1540"  :anon :subid("95_1300051186.829") :outer("94_1300051186.829")
.annotate 'line', 618
    .const 'Sub' $P1664 = "99_1300051186.829" 
    capture_lex $P1664
    .const 'Sub' $P1575 = "96_1300051186.829" 
    capture_lex $P1575
.annotate 'line', 619
    new $P1542, "Undef"
    .lex "$name", $P1542
    find_lex $P1543, "$/"
    unless_null $P1543, vivify_554
    $P1543 = root_new ['parrot';'Hash']
  vivify_554:
    set $P1544, $P1543["sigil"]
    unless_null $P1544, vivify_555
    $P1544 = root_new ['parrot';'ResizablePMCArray']
  vivify_555:
    set $P1545, $P1544[0]
    unless_null $P1545, vivify_556
    new $P1545, "Undef"
  vivify_556:
    set $S1546, $P1545
    new $P1547, 'String'
    set $P1547, $S1546
    find_lex $P1548, "$/"
    unless_null $P1548, vivify_557
    $P1548 = root_new ['parrot';'Hash']
  vivify_557:
    set $P1549, $P1548["deflongname"]
    unless_null $P1549, vivify_558
    $P1549 = root_new ['parrot';'ResizablePMCArray']
  vivify_558:
    set $P1550, $P1549[0]
    unless_null $P1550, vivify_559
    new $P1550, "Undef"
  vivify_559:
    $S1551 = $P1550."ast"()
    concat $P1552, $P1547, $S1551
    store_lex "$name", $P1552
.annotate 'line', 620
    find_lex $P1553, "$past"
    find_lex $P1554, "$name"
    $P1553."name"($P1554)
.annotate 'line', 621
    find_dynamic_lex $P1561, "$*SCOPE"
    unless_null $P1561, vivify_560
    get_hll_global $P1561, "$SCOPE"
    unless_null $P1561, vivify_561
    die "Contextual $*SCOPE not found"
  vivify_561:
  vivify_560:
    set $S1562, $P1561
    iseq $I1563, $S1562, ""
    unless $I1563, unless_1560
    new $P1559, 'Integer'
    set $P1559, $I1563
    goto unless_1560_end
  unless_1560:
    find_dynamic_lex $P1564, "$*SCOPE"
    unless_null $P1564, vivify_562
    get_hll_global $P1564, "$SCOPE"
    unless_null $P1564, vivify_563
    die "Contextual $*SCOPE not found"
  vivify_563:
  vivify_562:
    set $S1565, $P1564
    iseq $I1566, $S1565, "my"
    new $P1559, 'Integer'
    set $P1559, $I1566
  unless_1560_end:
    unless $P1559, unless_1558
    set $P1557, $P1559
    goto unless_1558_end
  unless_1558:
    find_dynamic_lex $P1567, "$*SCOPE"
    unless_null $P1567, vivify_564
    get_hll_global $P1567, "$SCOPE"
    unless_null $P1567, vivify_565
    die "Contextual $*SCOPE not found"
  vivify_565:
  vivify_564:
    set $S1568, $P1567
    iseq $I1569, $S1568, "our"
    new $P1557, 'Integer'
    set $P1557, $I1569
  unless_1558_end:
    if $P1557, if_1556
.annotate 'line', 713
    find_lex $P1733, "$/"
    $P1734 = $P1733."CURSOR"()
    find_dynamic_lex $P1735, "$*SCOPE"
    unless_null $P1735, vivify_566
    get_hll_global $P1735, "$SCOPE"
    unless_null $P1735, vivify_567
    die "Contextual $*SCOPE not found"
  vivify_567:
  vivify_566:
    concat $P1736, $P1735, " scoped routines are not supported yet"
    $P1737 = $P1734."panic"($P1736)
.annotate 'line', 712
    set $P1555, $P1737
.annotate 'line', 621
    goto if_1556_end
  if_1556:
.annotate 'line', 622
    find_dynamic_lex $P1571, "$*MULTINESS"
    unless_null $P1571, vivify_568
    get_hll_global $P1571, "$MULTINESS"
    unless_null $P1571, vivify_569
    die "Contextual $*MULTINESS not found"
  vivify_569:
  vivify_568:
    set $S1572, $P1571
    iseq $I1573, $S1572, "multi"
    if $I1573, if_1570
.annotate 'line', 673
    find_dynamic_lex $P1660, "$*MULTINESS"
    unless_null $P1660, vivify_570
    get_hll_global $P1660, "$MULTINESS"
    unless_null $P1660, vivify_571
    die "Contextual $*MULTINESS not found"
  vivify_571:
  vivify_570:
    set $S1661, $P1660
    iseq $I1662, $S1661, "proto"
    if $I1662, if_1659
.annotate 'line', 692
    get_global $P1694, "@BLOCK"
    unless_null $P1694, vivify_572
    $P1694 = root_new ['parrot';'ResizablePMCArray']
  vivify_572:
    set $P1695, $P1694[0]
    unless_null $P1695, vivify_573
    $P1695 = root_new ['parrot';'ResizablePMCArray']
  vivify_573:
    set $P1696, $P1695[0]
    unless_null $P1696, vivify_574
    new $P1696, "Undef"
  vivify_574:
    get_hll_global $P1697, ["PAST"], "Var"
    find_lex $P1698, "$name"
    find_lex $P1699, "$past"
    $P1700 = $P1697."new"($P1698 :named("name"), 1 :named("isdecl"), $P1699 :named("viviself"), "lexical" :named("scope"))
    $P1696."push"($P1700)
.annotate 'line', 694
    get_global $P1701, "@BLOCK"
    unless_null $P1701, vivify_575
    $P1701 = root_new ['parrot';'ResizablePMCArray']
  vivify_575:
    set $P1702, $P1701[0]
    unless_null $P1702, vivify_576
    new $P1702, "Undef"
  vivify_576:
    find_lex $P1703, "$name"
    $P1702."symbol"($P1703, "lexical" :named("scope"))
.annotate 'line', 695
    find_dynamic_lex $P1705, "$*SCOPE"
    unless_null $P1705, vivify_577
    get_hll_global $P1705, "$SCOPE"
    unless_null $P1705, vivify_578
    die "Contextual $*SCOPE not found"
  vivify_578:
  vivify_577:
    set $S1706, $P1705
    iseq $I1707, $S1706, "our"
    unless $I1707, if_1704_end
.annotate 'line', 698
    get_global $P1708, "@BLOCK"
    unless_null $P1708, vivify_579
    $P1708 = root_new ['parrot';'ResizablePMCArray']
  vivify_579:
    set $P1709, $P1708[0]
    unless_null $P1709, vivify_580
    $P1709 = root_new ['parrot';'ResizablePMCArray']
  vivify_580:
    set $P1710, $P1709[0]
    unless_null $P1710, vivify_581
    new $P1710, "Undef"
  vivify_581:
    get_hll_global $P1711, ["PAST"], "Op"
.annotate 'line', 700
    get_hll_global $P1712, ["PAST"], "Var"
    find_lex $P1713, "$name"
    $P1714 = $P1712."new"($P1713 :named("name"), "package" :named("scope"))
.annotate 'line', 701
    get_hll_global $P1715, ["PAST"], "Var"
    find_lex $P1716, "$name"
    $P1717 = $P1715."new"($P1716 :named("name"), "lexical" :named("scope"))
    $P1718 = $P1711."new"($P1714, $P1717, "bind" :named("pasttype"))
.annotate 'line', 698
    $P1710."push"($P1718)
.annotate 'line', 703
    get_global $P1719, "@BLOCK"
    unless_null $P1719, vivify_582
    $P1719 = root_new ['parrot';'ResizablePMCArray']
  vivify_582:
    set $P1720, $P1719[0]
    unless_null $P1720, vivify_583
    new $P1720, "Undef"
  vivify_583:
    $P1721 = $P1720."loadinit"()
    get_hll_global $P1722, ["PAST"], "Op"
.annotate 'line', 705
    get_hll_global $P1723, ["PAST"], "Var"
    find_lex $P1724, "$name"
    $P1725 = $P1723."new"($P1724 :named("name"), "package" :named("scope"))
.annotate 'line', 706
    get_hll_global $P1726, ["PAST"], "Val"
    find_lex $P1727, "$past"
    $P1728 = $P1726."new"($P1727 :named("value"))
    $P1729 = $P1722."new"($P1725, $P1728, "bind" :named("pasttype"))
.annotate 'line', 703
    $P1721."push"($P1729)
  if_1704_end:
.annotate 'line', 691
    goto if_1659_end
  if_1659:
.annotate 'line', 673
    .const 'Sub' $P1664 = "99_1300051186.829" 
    capture_lex $P1664
    $P1664()
  if_1659_end:
    goto if_1570_end
  if_1570:
.annotate 'line', 622
    .const 'Sub' $P1575 = "96_1300051186.829" 
    capture_lex $P1575
    $P1575()
  if_1570_end:
.annotate 'line', 710
    get_hll_global $P1730, ["PAST"], "Var"
    find_lex $P1731, "$name"
    $P1732 = $P1730."new"($P1731 :named("name"))
    store_lex "$past", $P1732
.annotate 'line', 621
    set $P1555, $P1732
  if_1556_end:
.annotate 'line', 618
    .return ($P1555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1663"  :anon :subid("99_1300051186.829") :outer("95_1300051186.829")
.annotate 'line', 678
    new $P1665, "Undef"
    .lex "$cholder", $P1665
.annotate 'line', 677
    find_dynamic_lex $P1667, "$*SCOPE"
    unless_null $P1667, vivify_584
    get_hll_global $P1667, "$SCOPE"
    unless_null $P1667, vivify_585
    die "Contextual $*SCOPE not found"
  vivify_585:
  vivify_584:
    set $S1668, $P1667
    iseq $I1669, $S1668, "our"
    unless $I1669, if_1666_end
    die "our-scoped protos not yet implemented"
  if_1666_end:
.annotate 'line', 678
    get_hll_global $P1670, ["PAST"], "Op"
    $P1671 = $P1670."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1671
.annotate 'line', 679
    get_global $P1672, "@BLOCK"
    unless_null $P1672, vivify_586
    $P1672 = root_new ['parrot';'ResizablePMCArray']
  vivify_586:
    set $P1673, $P1672[0]
    unless_null $P1673, vivify_587
    $P1673 = root_new ['parrot';'ResizablePMCArray']
  vivify_587:
    set $P1674, $P1673[0]
    unless_null $P1674, vivify_588
    new $P1674, "Undef"
  vivify_588:
    get_hll_global $P1675, ["PAST"], "Var"
    find_lex $P1676, "$name"
    find_lex $P1677, "$past"
    $P1678 = $P1675."new"($P1676 :named("name"), 1 :named("isdecl"), $P1677 :named("viviself"), "lexical" :named("scope"))
    $P1674."push"($P1678)
.annotate 'line', 681
    get_global $P1679, "@BLOCK"
    unless_null $P1679, vivify_589
    $P1679 = root_new ['parrot';'ResizablePMCArray']
  vivify_589:
    set $P1680, $P1679[0]
    unless_null $P1680, vivify_590
    $P1680 = root_new ['parrot';'ResizablePMCArray']
  vivify_590:
    set $P1681, $P1680[0]
    unless_null $P1681, vivify_591
    new $P1681, "Undef"
  vivify_591:
    get_hll_global $P1682, ["PAST"], "Op"
.annotate 'line', 683
    get_hll_global $P1683, ["PAST"], "Var"
    find_lex $P1684, "$name"
    $P1685 = $P1683."new"($P1684 :named("name"))
    find_lex $P1686, "$cholder"
    $P1687 = $P1682."new"($P1685, $P1686, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 681
    $P1681."push"($P1687)
.annotate 'line', 686
    get_global $P1688, "@BLOCK"
    unless_null $P1688, vivify_592
    $P1688 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    set $P1689, $P1688[0]
    unless_null $P1689, vivify_593
    new $P1689, "Undef"
  vivify_593:
    find_lex $P1690, "$name"
    find_lex $P1691, "$cholder"
    $P1689."symbol"($P1690, "lexical" :named("scope"), 1 :named("proto"), $P1691 :named("cholder"))
.annotate 'line', 689
    find_lex $P1692, "$past"
    $P1693 = $P1692."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 673
    .return ($P1693)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1574"  :anon :subid("96_1300051186.829") :outer("95_1300051186.829")
.annotate 'line', 622
    .const 'Sub' $P1593 = "97_1300051186.829" 
    capture_lex $P1593
.annotate 'line', 625
    new $P1576, "Undef"
    .lex "$cholder", $P1576
.annotate 'line', 626
    $P1577 = root_new ['parrot';'Hash']
    .lex "%sym", $P1577
.annotate 'line', 624
    find_dynamic_lex $P1579, "$*SCOPE"
    unless_null $P1579, vivify_594
    get_hll_global $P1579, "$SCOPE"
    unless_null $P1579, vivify_595
    die "Contextual $*SCOPE not found"
  vivify_595:
  vivify_594:
    set $S1580, $P1579
    iseq $I1581, $S1580, "our"
    unless $I1581, if_1578_end
    die "our-scoped multis not yet implemented"
  if_1578_end:
    find_lex $P1582, "$cholder"
.annotate 'line', 626
    get_global $P1583, "@BLOCK"
    unless_null $P1583, vivify_596
    $P1583 = root_new ['parrot';'ResizablePMCArray']
  vivify_596:
    set $P1584, $P1583[0]
    unless_null $P1584, vivify_597
    new $P1584, "Undef"
  vivify_597:
    find_lex $P1585, "$name"
    $P1586 = $P1584."symbol"($P1585)
    store_lex "%sym", $P1586
.annotate 'line', 627
    find_lex $P1588, "%sym"
    unless_null $P1588, vivify_598
    $P1588 = root_new ['parrot';'Hash']
  vivify_598:
    set $P1589, $P1588["cholder"]
    unless_null $P1589, vivify_599
    new $P1589, "Undef"
  vivify_599:
    if $P1589, if_1587
.annotate 'line', 632
    .const 'Sub' $P1593 = "97_1300051186.829" 
    capture_lex $P1593
    $P1593()
    goto if_1587_end
  if_1587:
.annotate 'line', 628
    find_lex $P1590, "%sym"
    unless_null $P1590, vivify_612
    $P1590 = root_new ['parrot';'Hash']
  vivify_612:
    set $P1591, $P1590["cholder"]
    unless_null $P1591, vivify_613
    new $P1591, "Undef"
  vivify_613:
    store_lex "$cholder", $P1591
  if_1587_end:
.annotate 'line', 668
    find_lex $P1655, "$cholder"
    find_lex $P1656, "$past"
    $P1655."push"($P1656)
.annotate 'line', 671
    find_lex $P1657, "$past"
    $P1658 = "attach_multi_signature"($P1657)
.annotate 'line', 622
    .return ($P1658)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1592"  :anon :subid("97_1300051186.829") :outer("96_1300051186.829")
.annotate 'line', 632
    .const 'Sub' $P1607 = "98_1300051186.829" 
    capture_lex $P1607
.annotate 'line', 639
    new $P1594, "Undef"
    .lex "$found_proto", $P1594
.annotate 'line', 657
    new $P1595, "Undef"
    .lex "$dispatch_setup", $P1595
.annotate 'line', 634
    find_lex $P1597, "%sym"
    unless_null $P1597, vivify_600
    $P1597 = root_new ['parrot';'Hash']
  vivify_600:
    set $P1598, $P1597["proto"]
    unless_null $P1598, vivify_601
    new $P1598, "Undef"
  vivify_601:
    unless $P1598, if_1596_end
.annotate 'line', 637
    find_lex $P1599, "$/"
    $P1600 = $P1599."CURSOR"()
    $P1600."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1596_end:
.annotate 'line', 634
    find_lex $P1601, "$found_proto"
.annotate 'line', 640
    get_global $P1603, "@BLOCK"
    defined $I1604, $P1603
    unless $I1604, for_undef_602
    iter $P1602, $P1603
    new $P1629, 'ExceptionHandler'
    set_label $P1629, loop1628_handler
    $P1629."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1629
  loop1628_test:
    unless $P1602, loop1628_done
    shift $P1605, $P1602
  loop1628_redo:
    .const 'Sub' $P1607 = "98_1300051186.829" 
    capture_lex $P1607
    $P1607($P1605)
  loop1628_next:
    goto loop1628_test
  loop1628_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1630, exception, 'type'
    eq $P1630, .CONTROL_LOOP_NEXT, loop1628_next
    eq $P1630, .CONTROL_LOOP_REDO, loop1628_redo
  loop1628_done:
    pop_eh 
  for_undef_602:
.annotate 'line', 651
    find_lex $P1632, "$found_proto"
    if $P1632, unless_1631_end
.annotate 'line', 652
    find_lex $P1633, "$/"
    $P1634 = $P1633."CURSOR"()
    $P1634."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1631_end:
.annotate 'line', 656
    get_hll_global $P1635, ["PAST"], "Op"
    $P1636 = $P1635."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1636
.annotate 'line', 657
    get_hll_global $P1637, ["PAST"], "Op"
.annotate 'line', 659
    get_hll_global $P1638, ["PAST"], "Var"
    find_lex $P1639, "$name"
    $P1640 = $P1638."new"($P1639 :named("name"), "outer" :named("scope"))
    find_lex $P1641, "$cholder"
    $P1642 = $P1637."new"($P1640, $P1641, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 657
    store_lex "$dispatch_setup", $P1642
.annotate 'line', 662
    get_global $P1643, "@BLOCK"
    unless_null $P1643, vivify_607
    $P1643 = root_new ['parrot';'ResizablePMCArray']
  vivify_607:
    set $P1644, $P1643[0]
    unless_null $P1644, vivify_608
    $P1644 = root_new ['parrot';'ResizablePMCArray']
  vivify_608:
    set $P1645, $P1644[0]
    unless_null $P1645, vivify_609
    new $P1645, "Undef"
  vivify_609:
    get_hll_global $P1646, ["PAST"], "Var"
    find_lex $P1647, "$name"
    find_lex $P1648, "$dispatch_setup"
    $P1649 = $P1646."new"($P1647 :named("name"), 1 :named("isdecl"), $P1648 :named("viviself"), "lexical" :named("scope"))
    $P1645."push"($P1649)
.annotate 'line', 664
    get_global $P1650, "@BLOCK"
    unless_null $P1650, vivify_610
    $P1650 = root_new ['parrot';'ResizablePMCArray']
  vivify_610:
    set $P1651, $P1650[0]
    unless_null $P1651, vivify_611
    new $P1651, "Undef"
  vivify_611:
    find_lex $P1652, "$name"
    find_lex $P1653, "$cholder"
    $P1654 = $P1651."symbol"($P1652, "lexical" :named("scope"), $P1653 :named("cholder"))
.annotate 'line', 632
    .return ($P1654)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1606"  :anon :subid("98_1300051186.829") :outer("97_1300051186.829")
    .param pmc param_1609
.annotate 'line', 641
    $P1608 = root_new ['parrot';'Hash']
    .lex "%sym", $P1608
    .lex "$_", param_1609
    find_lex $P1610, "$_"
    find_lex $P1611, "$name"
    $P1612 = $P1610."symbol"($P1611)
    store_lex "%sym", $P1612
.annotate 'line', 642
    find_lex $P1617, "%sym"
    unless_null $P1617, vivify_603
    $P1617 = root_new ['parrot';'Hash']
  vivify_603:
    set $P1618, $P1617["proto"]
    unless_null $P1618, vivify_604
    new $P1618, "Undef"
  vivify_604:
    unless $P1618, unless_1616
    set $P1615, $P1618
    goto unless_1616_end
  unless_1616:
    find_lex $P1619, "%sym"
    unless_null $P1619, vivify_605
    $P1619 = root_new ['parrot';'Hash']
  vivify_605:
    set $P1620, $P1619["cholder"]
    unless_null $P1620, vivify_606
    new $P1620, "Undef"
  vivify_606:
    set $P1615, $P1620
  unless_1616_end:
    if $P1615, if_1614
.annotate 'line', 645
    find_lex $P1624, "%sym"
    if $P1624, if_1623
    set $P1622, $P1624
    goto if_1623_end
  if_1623:
.annotate 'line', 646
    find_lex $P1625, "$/"
    $P1626 = $P1625."CURSOR"()
    $P1627 = $P1626."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 645
    set $P1622, $P1627
  if_1623_end:
    set $P1613, $P1622
.annotate 'line', 642
    goto if_1614_end
  if_1614:
.annotate 'line', 643
    new $P1621, "Integer"
    assign $P1621, 1
    store_lex "$found_proto", $P1621
.annotate 'line', 642
    set $P1613, $P1621
  if_1614_end:
.annotate 'line', 640
    .return ($P1613)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1748"  :anon :subid("100_1300051186.829") :outer("94_1300051186.829")
    .param pmc param_1750
.annotate 'line', 720
    .lex "$_", param_1750
    find_lex $P1751, "$_"
    $P1752 = $P1751."ast"()
    find_lex $P1753, "$/"
    $P1754 = $P1752($P1753)
    .return ($P1754)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("101_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1762
    .param pmc param_1763
.annotate 'line', 727
    .const 'Sub' $P1875 = "103_1300051186.829" 
    capture_lex $P1875
    .const 'Sub' $P1791 = "102_1300051186.829" 
    capture_lex $P1791
    .lex "self", param_1762
    .lex "$/", param_1763
.annotate 'line', 730
    new $P1764, "Undef"
    .lex "$past", $P1764
.annotate 'line', 727
    find_lex $P1765, "$past"
.annotate 'line', 731
    find_lex $P1767, "$/"
    unless_null $P1767, vivify_620
    $P1767 = root_new ['parrot';'Hash']
  vivify_620:
    set $P1768, $P1767["onlystar"]
    unless_null $P1768, vivify_621
    new $P1768, "Undef"
  vivify_621:
    if $P1768, if_1766
.annotate 'line', 735
    find_lex $P1770, "$/"
    unless_null $P1770, vivify_622
    $P1770 = root_new ['parrot';'Hash']
  vivify_622:
    set $P1771, $P1770["blockoid"]
    unless_null $P1771, vivify_623
    new $P1771, "Undef"
  vivify_623:
    $P1772 = $P1771."ast"()
    store_lex "$past", $P1772
.annotate 'line', 736
    find_lex $P1773, "$past"
    $P1773."blocktype"("declaration")
.annotate 'line', 737
    find_dynamic_lex $P1775, "$*RETURN_USED"
    unless_null $P1775, vivify_624
    get_hll_global $P1775, "$RETURN_USED"
    unless_null $P1775, vivify_625
    die "Contextual $*RETURN_USED not found"
  vivify_625:
  vivify_624:
    unless $P1775, if_1774_end
.annotate 'line', 738
    find_lex $P1776, "$past"
    $P1776."control"("return_pir")
  if_1774_end:
.annotate 'line', 734
    goto if_1766_end
  if_1766:
.annotate 'line', 732
    $P1769 = "only_star_block"()
    store_lex "$past", $P1769
  if_1766_end:
.annotate 'line', 743
    find_lex $P1778, "$past"
    unless_null $P1778, vivify_626
    $P1778 = root_new ['parrot';'Hash']
  vivify_626:
    set $P1779, $P1778["signature_has_invocant"]
    unless_null $P1779, vivify_627
    new $P1779, "Undef"
  vivify_627:
    if $P1779, unless_1777_end
.annotate 'line', 744
    find_lex $P1780, "$past"
    unless_null $P1780, vivify_628
    $P1780 = root_new ['parrot';'ResizablePMCArray']
  vivify_628:
    set $P1781, $P1780[0]
    unless_null $P1781, vivify_629
    new $P1781, "Undef"
  vivify_629:
    get_hll_global $P1782, ["PAST"], "Var"
.annotate 'line', 746
    get_hll_global $P1783, ["PAST"], "Var"
    $P1784 = $P1783."new"("$?CLASS" :named("name"))
    $P1785 = $P1782."new"("self" :named("name"), "parameter" :named("scope"), $P1784 :named("multitype"))
.annotate 'line', 744
    $P1781."unshift"($P1785)
  unless_1777_end:
.annotate 'line', 749
    find_lex $P1786, "$past"
    $P1786."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 752
    find_lex $P1788, "$/"
    unless_null $P1788, vivify_630
    $P1788 = root_new ['parrot';'Hash']
  vivify_630:
    set $P1789, $P1788["deflongname"]
    unless_null $P1789, vivify_631
    new $P1789, "Undef"
  vivify_631:
    unless $P1789, if_1787_end
    .const 'Sub' $P1791 = "102_1300051186.829" 
    capture_lex $P1791
    $P1791()
  if_1787_end:
.annotate 'line', 787
    find_dynamic_lex $P1857, "$*SCOPE"
    unless_null $P1857, vivify_649
    get_hll_global $P1857, "$SCOPE"
    unless_null $P1857, vivify_650
    die "Contextual $*SCOPE not found"
  vivify_650:
  vivify_649:
    set $S1858, $P1857
    iseq $I1859, $S1858, "our"
    unless $I1859, if_1856_end
.annotate 'line', 788
    find_lex $P1860, "$past"
    $P1860."pirflags"(":nsentry")
  if_1856_end:
.annotate 'line', 792
    find_lex $P1861, "$/"
    find_lex $P1862, "$past"
    $P1861."!make"($P1862)
.annotate 'line', 793
    find_lex $P1863, "$past"
    find_lex $P1864, "$past"
    unless_null $P1864, vivify_651
    $P1864 = root_new ['parrot';'Hash']
    store_lex "$past", $P1864
  vivify_651:
    set $P1864["block_past"], $P1863
.annotate 'line', 794
    find_lex $P1867, "$/"
    unless_null $P1867, vivify_652
    $P1867 = root_new ['parrot';'Hash']
  vivify_652:
    set $P1868, $P1867["trait"]
    unless_null $P1868, vivify_653
    new $P1868, "Undef"
  vivify_653:
    if $P1868, if_1866
    set $P1865, $P1868
    goto if_1866_end
  if_1866:
.annotate 'line', 795
    find_lex $P1870, "$/"
    unless_null $P1870, vivify_654
    $P1870 = root_new ['parrot';'Hash']
  vivify_654:
    set $P1871, $P1870["trait"]
    unless_null $P1871, vivify_655
    new $P1871, "Undef"
  vivify_655:
    defined $I1872, $P1871
    unless $I1872, for_undef_656
    iter $P1869, $P1871
    new $P1882, 'ExceptionHandler'
    set_label $P1882, loop1881_handler
    $P1882."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1882
  loop1881_test:
    unless $P1869, loop1881_done
    shift $P1873, $P1869
  loop1881_redo:
    .const 'Sub' $P1875 = "103_1300051186.829" 
    capture_lex $P1875
    $P1875($P1873)
  loop1881_next:
    goto loop1881_test
  loop1881_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1883, exception, 'type'
    eq $P1883, .CONTROL_LOOP_NEXT, loop1881_next
    eq $P1883, .CONTROL_LOOP_REDO, loop1881_redo
  loop1881_done:
    pop_eh 
  for_undef_656:
.annotate 'line', 794
    set $P1865, $P1869
  if_1866_end:
.annotate 'line', 727
    .return ($P1865)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1790"  :anon :subid("102_1300051186.829") :outer("101_1300051186.829")
.annotate 'line', 754
    new $P1792, "Undef"
    .lex "$name", $P1792
.annotate 'line', 759
    new $P1793, "Undef"
    .lex "$to_add", $P1793
.annotate 'line', 754
    find_lex $P1794, "$/"
    unless_null $P1794, vivify_632
    $P1794 = root_new ['parrot';'Hash']
  vivify_632:
    set $P1795, $P1794["private"]
    unless_null $P1795, vivify_633
    new $P1795, "Undef"
  vivify_633:
    set $S1796, $P1795
    new $P1797, 'String'
    set $P1797, $S1796
    find_lex $P1798, "$/"
    unless_null $P1798, vivify_634
    $P1798 = root_new ['parrot';'Hash']
  vivify_634:
    set $P1799, $P1798["deflongname"]
    unless_null $P1799, vivify_635
    $P1799 = root_new ['parrot';'ResizablePMCArray']
  vivify_635:
    set $P1800, $P1799[0]
    unless_null $P1800, vivify_636
    new $P1800, "Undef"
  vivify_636:
    $P1801 = $P1800."ast"()
    set $S1802, $P1801
    concat $P1803, $P1797, $S1802
    store_lex "$name", $P1803
.annotate 'line', 755
    find_lex $P1804, "$past"
    find_lex $P1805, "$name"
    $P1804."name"($P1805)
.annotate 'line', 759
    find_dynamic_lex $P1808, "$*MULTINESS"
    unless_null $P1808, vivify_637
    get_hll_global $P1808, "$MULTINESS"
    unless_null $P1808, vivify_638
    die "Contextual $*MULTINESS not found"
  vivify_638:
  vivify_637:
    set $S1809, $P1808
    isne $I1810, $S1809, "proto"
    if $I1810, if_1807
.annotate 'line', 761
    get_hll_global $P1814, ["PAST"], "Op"
.annotate 'line', 763
    get_hll_global $P1815, ["PAST"], "Val"
    find_lex $P1816, "$past"
    $P1817 = $P1815."new"($P1816 :named("value"))
.annotate 'line', 764
    get_hll_global $P1818, ["PAST"], "Op"
    $P1819 = $P1818."new"("list" :named("pasttype"))
    $P1820 = $P1814."new"($P1817, $P1819, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 761
    set $P1806, $P1820
.annotate 'line', 759
    goto if_1807_end
  if_1807:
.annotate 'line', 760
    get_hll_global $P1811, ["PAST"], "Val"
    find_lex $P1812, "$past"
    $P1813 = $P1811."new"($P1812 :named("value"))
    set $P1806, $P1813
  if_1807_end:
.annotate 'line', 759
    store_lex "$to_add", $P1806
.annotate 'line', 766
    find_dynamic_lex $P1822, "$*MULTINESS"
    unless_null $P1822, vivify_639
    get_hll_global $P1822, "$MULTINESS"
    unless_null $P1822, vivify_640
    die "Contextual $*MULTINESS not found"
  vivify_640:
  vivify_639:
    set $S1823, $P1822
    iseq $I1824, $S1823, "proto"
    unless $I1824, if_1821_end
    find_lex $P1825, "$past"
    $P1825."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1821_end:
.annotate 'line', 770
    find_dynamic_lex $P1827, "$*MULTINESS"
    unless_null $P1827, vivify_641
    get_hll_global $P1827, "$MULTINESS"
    unless_null $P1827, vivify_642
    die "Contextual $*MULTINESS not found"
  vivify_642:
  vivify_641:
    set $S1828, $P1827
    iseq $I1829, $S1828, "multi"
    unless $I1829, if_1826_end
    find_lex $P1830, "$past"
    "attach_multi_signature"($P1830)
  if_1826_end:
.annotate 'line', 773
    find_dynamic_lex $P1833, "$*PACKAGE-SETUP"
    unless_null $P1833, vivify_643
    get_hll_global $P1833, "$PACKAGE-SETUP"
    unless_null $P1833, vivify_644
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_644:
  vivify_643:
    defined $I1834, $P1833
    if $I1834, if_1832
    new $P1831, 'Integer'
    set $P1831, $I1834
    goto if_1832_end
  if_1832:
.annotate 'line', 774
    find_dynamic_lex $P1835, "$*PACKAGE-SETUP"
    unless_null $P1835, vivify_645
    get_hll_global $P1835, "$PACKAGE-SETUP"
    unless_null $P1835, vivify_646
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_646:
  vivify_645:
    get_hll_global $P1836, ["PAST"], "Op"
.annotate 'line', 775
    find_dynamic_lex $P1839, "$*MULTINESS"
    unless_null $P1839, vivify_647
    get_hll_global $P1839, "$MULTINESS"
    unless_null $P1839, vivify_648
    die "Contextual $*MULTINESS not found"
  vivify_648:
  vivify_647:
    set $S1840, $P1839
    iseq $I1841, $S1840, "multi"
    if $I1841, if_1838
    new $P1843, "String"
    assign $P1843, "add_method"
    set $P1837, $P1843
    goto if_1838_end
  if_1838:
    new $P1842, "String"
    assign $P1842, "add_multi_method"
    set $P1837, $P1842
  if_1838_end:
.annotate 'line', 776
    get_hll_global $P1844, ["PAST"], "Op"
.annotate 'line', 779
    get_hll_global $P1845, ["PAST"], "Var"
    $P1846 = $P1845."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1847 = $P1844."new"($P1846, "get_how PP" :named("pirop"))
.annotate 'line', 781
    get_hll_global $P1848, ["PAST"], "Var"
    $P1849 = $P1848."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 782
    get_hll_global $P1850, ["PAST"], "Val"
    find_lex $P1851, "$name"
    $P1852 = $P1850."new"($P1851 :named("value"))
    find_lex $P1853, "$to_add"
    $P1854 = $P1836."new"($P1847, $P1849, $P1852, $P1853, "callmethod" :named("pasttype"), $P1837 :named("name"))
.annotate 'line', 774
    $P1855 = $P1835."push"($P1854)
.annotate 'line', 773
    set $P1831, $P1855
  if_1832_end:
.annotate 'line', 752
    .return ($P1831)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1874"  :anon :subid("103_1300051186.829") :outer("101_1300051186.829")
    .param pmc param_1876
.annotate 'line', 795
    .lex "$_", param_1876
    find_lex $P1877, "$_"
    $P1878 = $P1877."ast"()
    find_lex $P1879, "$/"
    $P1880 = $P1878($P1879)
    .return ($P1880)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("104_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1887
    .param pmc param_1888
.annotate 'line', 827
    .const 'Sub' $P1921 = "106_1300051186.829" 
    capture_lex $P1921
    .const 'Sub' $P1897 = "105_1300051186.829" 
    capture_lex $P1897
    .lex "self", param_1887
    .lex "$/", param_1888
.annotate 'line', 828
    new $P1889, "Undef"
    .lex "$BLOCKINIT", $P1889
    get_global $P1890, "@BLOCK"
    unless_null $P1890, vivify_657
    $P1890 = root_new ['parrot';'ResizablePMCArray']
  vivify_657:
    set $P1891, $P1890[0]
    unless_null $P1891, vivify_658
    $P1891 = root_new ['parrot';'ResizablePMCArray']
  vivify_658:
    set $P1892, $P1891[0]
    unless_null $P1892, vivify_659
    new $P1892, "Undef"
  vivify_659:
    store_lex "$BLOCKINIT", $P1892
.annotate 'line', 829
    find_lex $P1894, "$/"
    unless_null $P1894, vivify_660
    $P1894 = root_new ['parrot';'Hash']
  vivify_660:
    set $P1895, $P1894["invocant"]
    unless_null $P1895, vivify_661
    new $P1895, "Undef"
  vivify_661:
    unless $P1895, if_1893_end
    .const 'Sub' $P1897 = "105_1300051186.829" 
    capture_lex $P1897
    $P1897()
  if_1893_end:
.annotate 'line', 838
    find_lex $P1916, "$/"
    unless_null $P1916, vivify_667
    $P1916 = root_new ['parrot';'Hash']
  vivify_667:
    set $P1917, $P1916["parameter"]
    unless_null $P1917, vivify_668
    new $P1917, "Undef"
  vivify_668:
    defined $I1918, $P1917
    unless $I1918, for_undef_669
    iter $P1915, $P1917
    new $P1928, 'ExceptionHandler'
    set_label $P1928, loop1927_handler
    $P1928."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1928
  loop1927_test:
    unless $P1915, loop1927_done
    shift $P1919, $P1915
  loop1927_redo:
    .const 'Sub' $P1921 = "106_1300051186.829" 
    capture_lex $P1921
    $P1921($P1919)
  loop1927_next:
    goto loop1927_test
  loop1927_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1929, exception, 'type'
    eq $P1929, .CONTROL_LOOP_NEXT, loop1927_next
    eq $P1929, .CONTROL_LOOP_REDO, loop1927_redo
  loop1927_done:
    pop_eh 
  for_undef_669:
.annotate 'line', 827
    .return ($P1915)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1896"  :anon :subid("105_1300051186.829") :outer("104_1300051186.829")
.annotate 'line', 830
    new $P1898, "Undef"
    .lex "$inv", $P1898
    find_lex $P1899, "$/"
    unless_null $P1899, vivify_662
    $P1899 = root_new ['parrot';'Hash']
  vivify_662:
    set $P1900, $P1899["invocant"]
    unless_null $P1900, vivify_663
    $P1900 = root_new ['parrot';'ResizablePMCArray']
  vivify_663:
    set $P1901, $P1900[0]
    unless_null $P1901, vivify_664
    new $P1901, "Undef"
  vivify_664:
    $P1902 = $P1901."ast"()
    store_lex "$inv", $P1902
.annotate 'line', 831
    find_lex $P1903, "$BLOCKINIT"
    find_lex $P1904, "$inv"
    $P1903."push"($P1904)
.annotate 'line', 832
    find_lex $P1905, "$BLOCKINIT"
    get_hll_global $P1906, ["PAST"], "Var"
.annotate 'line', 834
    get_hll_global $P1907, ["PAST"], "Var"
    find_lex $P1908, "$inv"
    $P1909 = $P1908."name"()
    $P1910 = $P1907."new"("lexical" :named("scope"), $P1909 :named("name"))
    $P1911 = $P1906."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1910 :named("viviself"))
.annotate 'line', 832
    $P1905."push"($P1911)
.annotate 'line', 836
    new $P1912, "Integer"
    assign $P1912, 1
    get_global $P1913, "@BLOCK"
    unless_null $P1913, vivify_665
    $P1913 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1913
  vivify_665:
    set $P1914, $P1913[0]
    unless_null $P1914, vivify_666
    $P1914 = root_new ['parrot';'Hash']
    set $P1913[0], $P1914
  vivify_666:
    set $P1914["signature_has_invocant"], $P1912
.annotate 'line', 829
    .return ($P1912)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1920"  :anon :subid("106_1300051186.829") :outer("104_1300051186.829")
    .param pmc param_1922
.annotate 'line', 838
    .lex "$_", param_1922
    find_lex $P1923, "$BLOCKINIT"
    find_lex $P1924, "$_"
    $P1925 = $P1924."ast"()
    $P1926 = $P1923."push"($P1925)
    .return ($P1926)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("107_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_1931
    .param pmc param_1932
.annotate 'line', 841
    .lex "self", param_1931
    .lex "$/", param_1932
.annotate 'line', 842
    new $P1933, "Undef"
    .lex "$quant", $P1933
.annotate 'line', 843
    new $P1934, "Undef"
    .lex "$past", $P1934
.annotate 'line', 842
    find_lex $P1935, "$/"
    unless_null $P1935, vivify_670
    $P1935 = root_new ['parrot';'Hash']
  vivify_670:
    set $P1936, $P1935["quant"]
    unless_null $P1936, vivify_671
    new $P1936, "Undef"
  vivify_671:
    store_lex "$quant", $P1936
    find_lex $P1937, "$past"
.annotate 'line', 844
    find_lex $P1939, "$/"
    unless_null $P1939, vivify_672
    $P1939 = root_new ['parrot';'Hash']
  vivify_672:
    set $P1940, $P1939["named_param"]
    unless_null $P1940, vivify_673
    new $P1940, "Undef"
  vivify_673:
    if $P1940, if_1938
.annotate 'line', 851
    find_lex $P1954, "$/"
    unless_null $P1954, vivify_674
    $P1954 = root_new ['parrot';'Hash']
  vivify_674:
    set $P1955, $P1954["param_var"]
    unless_null $P1955, vivify_675
    new $P1955, "Undef"
  vivify_675:
    $P1956 = $P1955."ast"()
    store_lex "$past", $P1956
.annotate 'line', 852
    find_lex $P1958, "$quant"
    set $S1959, $P1958
    iseq $I1960, $S1959, "*"
    if $I1960, if_1957
.annotate 'line', 856
    find_lex $P1969, "$quant"
    set $S1970, $P1969
    iseq $I1971, $S1970, "?"
    unless $I1971, if_1968_end
.annotate 'line', 857
    find_lex $P1972, "$past"
    find_lex $P1973, "$/"
    unless_null $P1973, vivify_676
    $P1973 = root_new ['parrot';'Hash']
  vivify_676:
    set $P1974, $P1973["param_var"]
    unless_null $P1974, vivify_677
    $P1974 = root_new ['parrot';'Hash']
  vivify_677:
    set $P1975, $P1974["sigil"]
    unless_null $P1975, vivify_678
    new $P1975, "Undef"
  vivify_678:
    $P1976 = "vivitype"($P1975)
    $P1972."viviself"($P1976)
  if_1968_end:
.annotate 'line', 856
    goto if_1957_end
  if_1957:
.annotate 'line', 853
    find_lex $P1961, "$past"
    $P1961."slurpy"(1)
.annotate 'line', 854
    find_lex $P1962, "$past"
    find_lex $P1963, "$/"
    unless_null $P1963, vivify_679
    $P1963 = root_new ['parrot';'Hash']
  vivify_679:
    set $P1964, $P1963["param_var"]
    unless_null $P1964, vivify_680
    $P1964 = root_new ['parrot';'Hash']
  vivify_680:
    set $P1965, $P1964["sigil"]
    unless_null $P1965, vivify_681
    new $P1965, "Undef"
  vivify_681:
    set $S1966, $P1965
    iseq $I1967, $S1966, "%"
    $P1962."named"($I1967)
  if_1957_end:
.annotate 'line', 850
    goto if_1938_end
  if_1938:
.annotate 'line', 845
    find_lex $P1941, "$/"
    unless_null $P1941, vivify_682
    $P1941 = root_new ['parrot';'Hash']
  vivify_682:
    set $P1942, $P1941["named_param"]
    unless_null $P1942, vivify_683
    new $P1942, "Undef"
  vivify_683:
    $P1943 = $P1942."ast"()
    store_lex "$past", $P1943
.annotate 'line', 846
    find_lex $P1945, "$quant"
    set $S1946, $P1945
    isne $I1947, $S1946, "!"
    unless $I1947, if_1944_end
.annotate 'line', 847
    find_lex $P1948, "$past"
    find_lex $P1949, "$/"
    unless_null $P1949, vivify_684
    $P1949 = root_new ['parrot';'Hash']
  vivify_684:
    set $P1950, $P1949["named_param"]
    unless_null $P1950, vivify_685
    $P1950 = root_new ['parrot';'Hash']
  vivify_685:
    set $P1951, $P1950["param_var"]
    unless_null $P1951, vivify_686
    $P1951 = root_new ['parrot';'Hash']
  vivify_686:
    set $P1952, $P1951["sigil"]
    unless_null $P1952, vivify_687
    new $P1952, "Undef"
  vivify_687:
    $P1953 = "vivitype"($P1952)
    $P1948."viviself"($P1953)
  if_1944_end:
  if_1938_end:
.annotate 'line', 860
    find_lex $P1978, "$/"
    unless_null $P1978, vivify_688
    $P1978 = root_new ['parrot';'Hash']
  vivify_688:
    set $P1979, $P1978["default_value"]
    unless_null $P1979, vivify_689
    new $P1979, "Undef"
  vivify_689:
    unless $P1979, if_1977_end
.annotate 'line', 861
    find_lex $P1981, "$quant"
    set $S1982, $P1981
    iseq $I1983, $S1982, "*"
    unless $I1983, if_1980_end
.annotate 'line', 862
    find_lex $P1984, "$/"
    $P1985 = $P1984."CURSOR"()
    $P1985."panic"("Can't put default on slurpy parameter")
  if_1980_end:
.annotate 'line', 864
    find_lex $P1987, "$quant"
    set $S1988, $P1987
    iseq $I1989, $S1988, "!"
    unless $I1989, if_1986_end
.annotate 'line', 865
    find_lex $P1990, "$/"
    $P1991 = $P1990."CURSOR"()
    $P1991."panic"("Can't put default on required parameter")
  if_1986_end:
.annotate 'line', 867
    find_lex $P1992, "$past"
    find_lex $P1993, "$/"
    unless_null $P1993, vivify_690
    $P1993 = root_new ['parrot';'Hash']
  vivify_690:
    set $P1994, $P1993["default_value"]
    unless_null $P1994, vivify_691
    $P1994 = root_new ['parrot';'ResizablePMCArray']
  vivify_691:
    set $P1995, $P1994[0]
    unless_null $P1995, vivify_692
    $P1995 = root_new ['parrot';'Hash']
  vivify_692:
    set $P1996, $P1995["EXPR"]
    unless_null $P1996, vivify_693
    new $P1996, "Undef"
  vivify_693:
    $P1997 = $P1996."ast"()
    $P1992."viviself"($P1997)
  if_1977_end:
.annotate 'line', 869
    find_lex $P1999, "$past"
    $P2000 = $P1999."viviself"()
    if $P2000, unless_1998_end
    get_global $P2001, "@BLOCK"
    unless_null $P2001, vivify_694
    $P2001 = root_new ['parrot';'ResizablePMCArray']
  vivify_694:
    set $P2002, $P2001[0]
    unless_null $P2002, vivify_695
    new $P2002, "Undef"
  vivify_695:
    get_global $P2003, "@BLOCK"
    unless_null $P2003, vivify_696
    $P2003 = root_new ['parrot';'ResizablePMCArray']
  vivify_696:
    set $P2004, $P2003[0]
    unless_null $P2004, vivify_697
    new $P2004, "Undef"
  vivify_697:
    $P2005 = $P2004."arity"()
    set $N2006, $P2005
    new $P2007, 'Float'
    set $P2007, $N2006
    add $P2008, $P2007, 1
    $P2002."arity"($P2008)
  unless_1998_end:
.annotate 'line', 873
    find_lex $P2010, "$/"
    unless_null $P2010, vivify_698
    $P2010 = root_new ['parrot';'Hash']
  vivify_698:
    set $P2011, $P2010["typename"]
    unless_null $P2011, vivify_699
    new $P2011, "Undef"
  vivify_699:
    unless $P2011, if_2009_end
.annotate 'line', 874
    find_lex $P2012, "$past"
    find_lex $P2013, "$/"
    unless_null $P2013, vivify_700
    $P2013 = root_new ['parrot';'Hash']
  vivify_700:
    set $P2014, $P2013["typename"]
    unless_null $P2014, vivify_701
    $P2014 = root_new ['parrot';'ResizablePMCArray']
  vivify_701:
    set $P2015, $P2014[0]
    unless_null $P2015, vivify_702
    new $P2015, "Undef"
  vivify_702:
    $P2016 = $P2015."ast"()
    $P2012."multitype"($P2016)
  if_2009_end:
.annotate 'line', 878
    find_lex $P2018, "$/"
    unless_null $P2018, vivify_703
    $P2018 = root_new ['parrot';'Hash']
  vivify_703:
    set $P2019, $P2018["definedness"]
    unless_null $P2019, vivify_704
    new $P2019, "Undef"
  vivify_704:
    unless $P2019, if_2017_end
.annotate 'line', 879
    find_lex $P2020, "$/"
    unless_null $P2020, vivify_705
    $P2020 = root_new ['parrot';'Hash']
  vivify_705:
    set $P2021, $P2020["definedness"]
    unless_null $P2021, vivify_706
    $P2021 = root_new ['parrot';'ResizablePMCArray']
  vivify_706:
    set $P2022, $P2021[0]
    unless_null $P2022, vivify_707
    new $P2022, "Undef"
  vivify_707:
    set $S2023, $P2022
    new $P2024, 'String'
    set $P2024, $S2023
    find_lex $P2025, "$past"
    unless_null $P2025, vivify_708
    $P2025 = root_new ['parrot';'Hash']
    store_lex "$past", $P2025
  vivify_708:
    set $P2025["definedness"], $P2024
  if_2017_end:
.annotate 'line', 882
    find_lex $P2026, "$/"
    find_lex $P2027, "$past"
    $P2028 = $P2026."!make"($P2027)
.annotate 'line', 841
    .return ($P2028)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("108_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2030
    .param pmc param_2031
.annotate 'line', 885
    .lex "self", param_2030
    .lex "$/", param_2031
.annotate 'line', 886
    new $P2032, "Undef"
    .lex "$name", $P2032
.annotate 'line', 887
    new $P2033, "Undef"
    .lex "$past", $P2033
.annotate 'line', 886
    find_lex $P2034, "$/"
    set $S2035, $P2034
    new $P2036, 'String'
    set $P2036, $S2035
    store_lex "$name", $P2036
.annotate 'line', 887
    get_hll_global $P2037, ["PAST"], "Var"
    find_lex $P2038, "$name"
    find_lex $P2039, "$/"
    $P2040 = $P2037."new"($P2038 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P2039 :named("node"))
    store_lex "$past", $P2040
.annotate 'line', 889
    get_global $P2041, "@BLOCK"
    unless_null $P2041, vivify_709
    $P2041 = root_new ['parrot';'ResizablePMCArray']
  vivify_709:
    set $P2042, $P2041[0]
    unless_null $P2042, vivify_710
    new $P2042, "Undef"
  vivify_710:
    find_lex $P2043, "$name"
    $P2042."symbol"($P2043, "lexical" :named("scope"))
.annotate 'line', 890
    find_lex $P2044, "$/"
    find_lex $P2045, "$past"
    $P2046 = $P2044."!make"($P2045)
.annotate 'line', 885
    .return ($P2046)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("109_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2048
    .param pmc param_2049
.annotate 'line', 893
    .lex "self", param_2048
    .lex "$/", param_2049
.annotate 'line', 894
    new $P2050, "Undef"
    .lex "$past", $P2050
    find_lex $P2051, "$/"
    unless_null $P2051, vivify_711
    $P2051 = root_new ['parrot';'Hash']
  vivify_711:
    set $P2052, $P2051["param_var"]
    unless_null $P2052, vivify_712
    new $P2052, "Undef"
  vivify_712:
    $P2053 = $P2052."ast"()
    store_lex "$past", $P2053
.annotate 'line', 895
    find_lex $P2054, "$past"
    find_lex $P2055, "$/"
    unless_null $P2055, vivify_713
    $P2055 = root_new ['parrot';'Hash']
  vivify_713:
    set $P2056, $P2055["param_var"]
    unless_null $P2056, vivify_714
    $P2056 = root_new ['parrot';'Hash']
  vivify_714:
    set $P2057, $P2056["name"]
    unless_null $P2057, vivify_715
    new $P2057, "Undef"
  vivify_715:
    set $S2058, $P2057
    $P2054."named"($S2058)
.annotate 'line', 896
    find_lex $P2059, "$/"
    find_lex $P2060, "$past"
    $P2061 = $P2059."!make"($P2060)
.annotate 'line', 893
    .return ($P2061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("110_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2063
    .param pmc param_2064
.annotate 'line', 899
    .lex "self", param_2063
    .lex "$/", param_2064
.annotate 'line', 900
    $P2065 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2065
    get_hll_global $P2066, ["HLL"], "Compiler"
    find_lex $P2067, "$/"
    set $S2068, $P2067
    $P2069 = $P2066."parse_name"($S2068)
    store_lex "@name", $P2069
.annotate 'line', 901
    find_lex $P2070, "$/"
    get_hll_global $P2071, ["PAST"], "Var"
.annotate 'line', 902
    find_lex $P2072, "@name"
    $P2073 = $P2072."pop"()
    find_lex $P2074, "@name"
    $P2075 = $P2071."new"($P2073 :named("name"), $P2074 :named("namespace"), "package" :named("scope"))
.annotate 'line', 901
    $P2076 = $P2070."!make"($P2075)
.annotate 'line', 899
    .return ($P2076)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("111_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2078
    .param pmc param_2079
.annotate 'line', 908
    .lex "self", param_2078
    .lex "$/", param_2079
.annotate 'line', 909
    find_lex $P2080, "$/"
    find_lex $P2081, "$/"
    unless_null $P2081, vivify_716
    $P2081 = root_new ['parrot';'Hash']
  vivify_716:
    set $P2082, $P2081["trait_mod"]
    unless_null $P2082, vivify_717
    new $P2082, "Undef"
  vivify_717:
    $P2083 = $P2082."ast"()
    $P2084 = $P2080."!make"($P2083)
.annotate 'line', 908
    .return ($P2084)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("112_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2086
    .param pmc param_2087
.annotate 'line', 912
    .const 'Sub' $P2107 = "113_1300051186.829" 
    capture_lex $P2107
    .lex "self", param_2086
    .lex "$/", param_2087
.annotate 'line', 913
    new $P2088, "Undef"
    .lex "$cpast", $P2088
    find_lex $P2089, "$/"
    unless_null $P2089, vivify_718
    $P2089 = root_new ['parrot';'Hash']
  vivify_718:
    set $P2090, $P2089["circumfix"]
    unless_null $P2090, vivify_719
    $P2090 = root_new ['parrot';'ResizablePMCArray']
  vivify_719:
    set $P2091, $P2090[0]
    unless_null $P2091, vivify_720
    new $P2091, "Undef"
  vivify_720:
    $P2092 = $P2091."ast"()
    store_lex "$cpast", $P2092
.annotate 'line', 914
    find_lex $P2095, "$/"
    unless_null $P2095, vivify_721
    $P2095 = root_new ['parrot';'Hash']
  vivify_721:
    set $P2096, $P2095["longname"]
    unless_null $P2096, vivify_722
    new $P2096, "Undef"
  vivify_722:
    set $S2097, $P2096
    iseq $I2098, $S2097, "parrot_vtable"
    if $I2098, if_2094
.annotate 'line', 934
    find_lex $P2133, "$/"
    unless_null $P2133, vivify_723
    $P2133 = root_new ['parrot';'Hash']
  vivify_723:
    set $P2134, $P2133["longname"]
    unless_null $P2134, vivify_724
    new $P2134, "Undef"
  vivify_724:
    set $S2135, $P2134
    iseq $I2136, $S2135, "pirflags"
    if $I2136, if_2132
.annotate 'line', 938
    find_lex $P2140, "$/"
    $P2141 = $P2140."CURSOR"()
    new $P2142, 'String'
    set $P2142, "Trait '"
    find_lex $P2143, "$/"
    unless_null $P2143, vivify_725
    $P2143 = root_new ['parrot';'Hash']
  vivify_725:
    set $P2144, $P2143["longname"]
    unless_null $P2144, vivify_726
    new $P2144, "Undef"
  vivify_726:
    concat $P2145, $P2142, $P2144
    concat $P2146, $P2145, "' not implemented"
    $P2147 = $P2141."panic"($P2146)
.annotate 'line', 937
    set $P2131, $P2147
.annotate 'line', 934
    goto if_2132_end
  if_2132:
.annotate 'line', 935
    find_lex $P2137, "$/"
    $P2138 = $P2137."CURSOR"()
    $P2139 = $P2138."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 934
    set $P2131, $P2139
  if_2132_end:
    set $P2093, $P2131
.annotate 'line', 914
    goto if_2094_end
  if_2094:
.annotate 'line', 917
    get_hll_global $P2100, ["PAST"], "Val"
    find_lex $P2101, "$cpast"
    $P2102 = $P2100."ACCEPTS"($P2101)
    if $P2102, unless_2099_end
.annotate 'line', 916
    find_lex $P2103, "$/"
    $P2104 = $P2103."CURSOR"()
    $P2104."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2099_end:
.annotate 'line', 918
    find_lex $P2105, "$/"
    .const 'Sub' $P2107 = "113_1300051186.829" 
    newclosure $P2129, $P2107
    $P2130 = $P2105."!make"($P2129)
.annotate 'line', 914
    set $P2093, $P2130
  if_2094_end:
.annotate 'line', 912
    .return ($P2093)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2106"  :anon :subid("113_1300051186.829") :outer("112_1300051186.829")
    .param pmc param_2108
.annotate 'line', 918
    .lex "$match", param_2108
.annotate 'line', 919
    new $P2109, "Undef"
    .lex "$meth", $P2109
    find_lex $P2110, "$match"
    $P2111 = $P2110."ast"()
    set $P2112, $P2111["block_past"]
    unless_null $P2112, vivify_727
    new $P2112, "Undef"
  vivify_727:
    store_lex "$meth", $P2112
.annotate 'line', 920
    find_dynamic_lex $P2115, "$*PACKAGE-SETUP"
    unless_null $P2115, vivify_728
    get_hll_global $P2115, "$PACKAGE-SETUP"
    unless_null $P2115, vivify_729
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_729:
  vivify_728:
    defined $I2116, $P2115
    if $I2116, if_2114
    new $P2113, 'Integer'
    set $P2113, $I2116
    goto if_2114_end
  if_2114:
.annotate 'line', 921
    find_dynamic_lex $P2117, "$*PACKAGE-SETUP"
    unless_null $P2117, vivify_730
    get_hll_global $P2117, "$PACKAGE-SETUP"
    unless_null $P2117, vivify_731
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_731:
  vivify_730:
    get_hll_global $P2118, ["PAST"], "Op"
.annotate 'line', 923
    get_hll_global $P2119, ["PAST"], "Op"
.annotate 'line', 926
    get_hll_global $P2120, ["PAST"], "Var"
    $P2121 = $P2120."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2122 = $P2119."new"($P2121, "get_how PP" :named("pirop"))
.annotate 'line', 928
    get_hll_global $P2123, ["PAST"], "Var"
    $P2124 = $P2123."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2125, "$cpast"
    find_lex $P2126, "$meth"
    $P2127 = $P2118."new"($P2122, $P2124, $P2125, $P2126, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 921
    $P2128 = $P2117."push"($P2127)
.annotate 'line', 920
    set $P2113, $P2128
  if_2114_end:
.annotate 'line', 918
    .return ($P2113)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("114_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2151
    .param pmc param_2152
    .param pmc param_2153 :optional
    .param int has_param_2153 :opt_flag
.annotate 'line', 942
    .const 'Sub' $P2251 = "117_1300051186.829" 
    capture_lex $P2251
    .const 'Sub' $P2223 = "116_1300051186.829" 
    capture_lex $P2223
    .const 'Sub' $P2196 = "115_1300051186.829" 
    capture_lex $P2196
    new $P2150, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2150, control_2149
    push_eh $P2150
    .lex "self", param_2151
    .lex "$/", param_2152
    if has_param_2153, optparam_732
    new $P2154, "Undef"
    set param_2153, $P2154
  optparam_732:
    .lex "$key", param_2153
.annotate 'line', 943
    $P2155 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2155
.annotate 'line', 946
    new $P2156, "Undef"
    .lex "$name", $P2156
.annotate 'line', 947
    new $P2157, "Undef"
    .lex "$past", $P2157
.annotate 'line', 943

        $P2158 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2158
.annotate 'line', 946
    find_lex $P2159, "$/"
    unless_null $P2159, vivify_733
    $P2159 = root_new ['parrot';'Hash']
  vivify_733:
    set $P2160, $P2159["deflongname"]
    unless_null $P2160, vivify_734
    new $P2160, "Undef"
  vivify_734:
    $P2161 = $P2160."ast"()
    set $S2162, $P2161
    new $P2163, 'String'
    set $P2163, $S2162
    store_lex "$name", $P2163
    find_lex $P2164, "$past"
.annotate 'line', 948
    find_lex $P2166, "$/"
    unless_null $P2166, vivify_735
    $P2166 = root_new ['parrot';'Hash']
  vivify_735:
    set $P2167, $P2166["proto"]
    unless_null $P2167, vivify_736
    new $P2167, "Undef"
  vivify_736:
    if $P2167, if_2165
.annotate 'line', 987
    find_lex $P2219, "$key"
    set $S2220, $P2219
    iseq $I2221, $S2220, "open"
    if $I2221, if_2218
.annotate 'line', 1000
    .const 'Sub' $P2251 = "117_1300051186.829" 
    capture_lex $P2251
    $P2251()
    goto if_2218_end
  if_2218:
.annotate 'line', 987
    .const 'Sub' $P2223 = "116_1300051186.829" 
    capture_lex $P2223
    $P2223()
  if_2218_end:
    goto if_2165_end
  if_2165:
.annotate 'line', 950
    get_hll_global $P2168, ["PAST"], "Stmts"
.annotate 'line', 951
    get_hll_global $P2169, ["PAST"], "Block"
    find_lex $P2170, "$name"
.annotate 'line', 952
    get_hll_global $P2171, ["PAST"], "Op"
.annotate 'line', 953
    get_hll_global $P2172, ["PAST"], "Var"
    $P2173 = $P2172."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2174, "$name"
    $P2175 = $P2171."new"($P2173, $P2174, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 952
    find_lex $P2176, "$/"
    $P2177 = $P2169."new"($P2175, $P2170 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2176 :named("node"))
.annotate 'line', 962
    get_hll_global $P2178, ["PAST"], "Block"
    new $P2179, "String"
    assign $P2179, "!PREFIX__"
    find_lex $P2180, "$name"
    concat $P2181, $P2179, $P2180
.annotate 'line', 963
    get_hll_global $P2182, ["PAST"], "Op"
.annotate 'line', 964
    get_hll_global $P2183, ["PAST"], "Var"
    $P2184 = $P2183."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2185, "$name"
    $P2186 = $P2182."new"($P2184, $P2185, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 963
    find_lex $P2187, "$/"
    $P2188 = $P2178."new"($P2186, $P2181 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2187 :named("node"))
.annotate 'line', 962
    $P2189 = $P2168."new"($P2177, $P2188)
.annotate 'line', 950
    store_lex "$past", $P2189
.annotate 'line', 974
    find_lex $P2191, "$past"
    $P2192 = $P2191."list"()
    defined $I2193, $P2192
    unless $I2193, for_undef_757
    iter $P2190, $P2192
    new $P2216, 'ExceptionHandler'
    set_label $P2216, loop2215_handler
    $P2216."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2216
  loop2215_test:
    unless $P2190, loop2215_done
    shift $P2194, $P2190
  loop2215_redo:
    .const 'Sub' $P2196 = "115_1300051186.829" 
    capture_lex $P2196
    $P2196($P2194)
  loop2215_next:
    goto loop2215_test
  loop2215_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2217, exception, 'type'
    eq $P2217, .CONTROL_LOOP_NEXT, loop2215_next
    eq $P2217, .CONTROL_LOOP_REDO, loop2215_redo
  loop2215_done:
    pop_eh 
  for_undef_757:
  if_2165_end:
.annotate 'line', 1036
    find_lex $P2309, "$/"
    find_lex $P2310, "$past"
    $P2311 = $P2309."!make"($P2310)
.annotate 'line', 942
    .return ($P2311)
  control_2149:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2312, exception, "payload"
    .return ($P2312)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2250"  :anon :subid("117_1300051186.829") :outer("114_1300051186.829")
.annotate 'line', 1001
    new $P2252, "Undef"
    .lex "$regex", $P2252
.annotate 'line', 1002
    get_hll_global $P2253, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2254, "$/"
    unless_null $P2254, vivify_737
    $P2254 = root_new ['parrot';'Hash']
  vivify_737:
    set $P2255, $P2254["p6regex"]
    unless_null $P2255, vivify_738
    new $P2255, "Undef"
  vivify_738:
    $P2256 = $P2255."ast"()
    get_global $P2257, "@BLOCK"
    $P2258 = $P2257."shift"()
    $P2259 = $P2253($P2256, $P2258)
    store_lex "$regex", $P2259
.annotate 'line', 1003
    find_lex $P2260, "$regex"
    find_lex $P2261, "$name"
    $P2260."name"($P2261)
.annotate 'line', 1005
    get_hll_global $P2262, ["PAST"], "Op"
.annotate 'line', 1007
    get_hll_global $P2263, ["PAST"], "Var"
    new $P2264, "ResizablePMCArray"
    push $P2264, "Regex"
    $P2265 = $P2263."new"("Method" :named("name"), $P2264 :named("namespace"), "package" :named("scope"))
    find_lex $P2266, "$regex"
    $P2267 = $P2262."new"($P2265, $P2266, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1005
    store_lex "$past", $P2267
.annotate 'line', 1010
    find_dynamic_lex $P2269, "$*PACKAGE-SETUP"
    unless_null $P2269, vivify_739
    get_hll_global $P2269, "$PACKAGE-SETUP"
    unless_null $P2269, vivify_740
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_740:
  vivify_739:
    defined $I2270, $P2269
    unless $I2270, if_2268_end
.annotate 'line', 1011
    find_dynamic_lex $P2271, "$*PACKAGE-SETUP"
    unless_null $P2271, vivify_741
    get_hll_global $P2271, "$PACKAGE-SETUP"
    unless_null $P2271, vivify_742
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_742:
  vivify_741:
    get_hll_global $P2272, ["PAST"], "Op"
.annotate 'line', 1013
    get_hll_global $P2273, ["PAST"], "Op"
.annotate 'line', 1015
    get_hll_global $P2274, ["PAST"], "Var"
    $P2275 = $P2274."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2276 = $P2273."new"($P2275, "get_how PP" :named("pirop"))
.annotate 'line', 1017
    get_hll_global $P2277, ["PAST"], "Var"
    $P2278 = $P2277."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1018
    get_hll_global $P2279, ["PAST"], "Val"
    find_lex $P2280, "$name"
    $P2281 = $P2279."new"($P2280 :named("value"))
.annotate 'line', 1019
    get_hll_global $P2282, ["PAST"], "Val"
    find_lex $P2283, "$regex"
    $P2284 = $P2282."new"($P2283 :named("value"))
    $P2285 = $P2272."new"($P2276, $P2278, $P2281, $P2284, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1011
    $P2271."push"($P2285)
.annotate 'line', 1021
    find_dynamic_lex $P2286, "$*PACKAGE-SETUP"
    unless_null $P2286, vivify_743
    get_hll_global $P2286, "$PACKAGE-SETUP"
    unless_null $P2286, vivify_744
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_744:
  vivify_743:
    get_hll_global $P2287, ["PAST"], "Op"
.annotate 'line', 1023
    get_hll_global $P2288, ["PAST"], "Op"
.annotate 'line', 1025
    get_hll_global $P2289, ["PAST"], "Var"
    $P2290 = $P2289."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2291 = $P2288."new"($P2290, "get_how PP" :named("pirop"))
.annotate 'line', 1027
    get_hll_global $P2292, ["PAST"], "Var"
    $P2293 = $P2292."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1028
    get_hll_global $P2294, ["PAST"], "Val"
    new $P2295, "String"
    assign $P2295, "!PREFIX__"
    find_lex $P2296, "$name"
    concat $P2297, $P2295, $P2296
    $P2298 = $P2294."new"($P2297 :named("value"))
.annotate 'line', 1029
    get_hll_global $P2299, ["PAST"], "Var"
    new $P2300, "String"
    assign $P2300, "!PREFIX__"
    find_lex $P2301, "$name"
    concat $P2302, $P2300, $P2301
    $P2303 = $P2299."new"($P2302 :named("name"), "package" :named("scope"))
    $P2304 = $P2287."new"($P2291, $P2293, $P2298, $P2303, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1021
    $P2286."push"($P2304)
  if_2268_end:
.annotate 'line', 1033
    find_lex $P2305, "$regex"
    find_lex $P2306, "$past"
    unless_null $P2306, vivify_745
    $P2306 = root_new ['parrot';'Hash']
    store_lex "$past", $P2306
  vivify_745:
    set $P2306["sink"], $P2305
.annotate 'line', 1034
    find_lex $P2307, "@MODIFIERS"
    $P2308 = $P2307."shift"()
.annotate 'line', 1000
    .return ($P2308)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2222"  :anon :subid("116_1300051186.829") :outer("114_1300051186.829")
.annotate 'line', 988
    $P2224 = root_new ['parrot';'Hash']
    .lex "%h", $P2224
.annotate 'line', 987
    find_lex $P2225, "%h"
.annotate 'line', 989
    find_lex $P2227, "$/"
    unless_null $P2227, vivify_746
    $P2227 = root_new ['parrot';'Hash']
  vivify_746:
    set $P2228, $P2227["sym"]
    unless_null $P2228, vivify_747
    new $P2228, "Undef"
  vivify_747:
    set $S2229, $P2228
    iseq $I2230, $S2229, "token"
    unless $I2230, if_2226_end
    new $P2231, "Integer"
    assign $P2231, 1
    find_lex $P2232, "%h"
    unless_null $P2232, vivify_748
    $P2232 = root_new ['parrot';'Hash']
    store_lex "%h", $P2232
  vivify_748:
    set $P2232["r"], $P2231
  if_2226_end:
.annotate 'line', 990
    find_lex $P2234, "$/"
    unless_null $P2234, vivify_749
    $P2234 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2235, $P2234["sym"]
    unless_null $P2235, vivify_750
    new $P2235, "Undef"
  vivify_750:
    set $S2236, $P2235
    iseq $I2237, $S2236, "rule"
    unless $I2237, if_2233_end
    new $P2238, "Integer"
    assign $P2238, 1
    find_lex $P2239, "%h"
    unless_null $P2239, vivify_751
    $P2239 = root_new ['parrot';'Hash']
    store_lex "%h", $P2239
  vivify_751:
    set $P2239["r"], $P2238
    new $P2240, "Integer"
    assign $P2240, 1
    find_lex $P2241, "%h"
    unless_null $P2241, vivify_752
    $P2241 = root_new ['parrot';'Hash']
    store_lex "%h", $P2241
  vivify_752:
    set $P2241["s"], $P2240
  if_2233_end:
.annotate 'line', 991
    find_lex $P2242, "@MODIFIERS"
    find_lex $P2243, "%h"
    $P2242."unshift"($P2243)
.annotate 'line', 992

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 996
    get_global $P2244, "@BLOCK"
    unless_null $P2244, vivify_753
    $P2244 = root_new ['parrot';'ResizablePMCArray']
  vivify_753:
    set $P2245, $P2244[0]
    unless_null $P2245, vivify_754
    new $P2245, "Undef"
  vivify_754:
    $P2245."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 997
    get_global $P2246, "@BLOCK"
    unless_null $P2246, vivify_755
    $P2246 = root_new ['parrot';'ResizablePMCArray']
  vivify_755:
    set $P2247, $P2246[0]
    unless_null $P2247, vivify_756
    new $P2247, "Undef"
  vivify_756:
    $P2247."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 998
    new $P2248, "Exception"
    set $P2248['type'], .CONTROL_RETURN
    new $P2249, "Integer"
    assign $P2249, 0
    setattribute $P2248, 'payload', $P2249
    throw $P2248
.annotate 'line', 987
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2195"  :anon :subid("115_1300051186.829") :outer("114_1300051186.829")
    .param pmc param_2197
.annotate 'line', 974
    .lex "$_", param_2197
.annotate 'line', 975
    find_dynamic_lex $P2198, "$*PACKAGE-SETUP"
    unless_null $P2198, vivify_758
    get_hll_global $P2198, "$PACKAGE-SETUP"
    unless_null $P2198, vivify_759
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_759:
  vivify_758:
    get_hll_global $P2199, ["PAST"], "Op"
.annotate 'line', 977
    get_hll_global $P2200, ["PAST"], "Op"
.annotate 'line', 979
    get_hll_global $P2201, ["PAST"], "Var"
    $P2202 = $P2201."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2203 = $P2200."new"($P2202, "get_how PP" :named("pirop"))
.annotate 'line', 981
    get_hll_global $P2204, ["PAST"], "Var"
    $P2205 = $P2204."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 982
    get_hll_global $P2206, ["PAST"], "Val"
    find_lex $P2207, "$_"
    $P2208 = $P2207."name"()
    $P2209 = $P2206."new"($P2208 :named("value"))
.annotate 'line', 983
    get_hll_global $P2210, ["PAST"], "Val"
    find_lex $P2211, "$_"
    $P2212 = $P2210."new"($P2211 :named("value"))
    $P2213 = $P2199."new"($P2203, $P2205, $P2209, $P2212, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 975
    $P2214 = $P2198."push"($P2213)
.annotate 'line', 974
    .return ($P2214)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("118_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2314
    .param pmc param_2315
.annotate 'line', 1040
    .lex "self", param_2314
    .lex "$/", param_2315
.annotate 'line', 1041
    new $P2316, "Undef"
    .lex "$past", $P2316
    find_lex $P2319, "$/"
    unless_null $P2319, vivify_760
    $P2319 = root_new ['parrot';'Hash']
  vivify_760:
    set $P2320, $P2319["args"]
    unless_null $P2320, vivify_761
    new $P2320, "Undef"
  vivify_761:
    if $P2320, if_2318
    get_hll_global $P2325, ["PAST"], "Op"
    find_lex $P2326, "$/"
    $P2327 = $P2325."new"($P2326 :named("node"))
    set $P2317, $P2327
    goto if_2318_end
  if_2318:
    find_lex $P2321, "$/"
    unless_null $P2321, vivify_762
    $P2321 = root_new ['parrot';'Hash']
  vivify_762:
    set $P2322, $P2321["args"]
    unless_null $P2322, vivify_763
    $P2322 = root_new ['parrot';'ResizablePMCArray']
  vivify_763:
    set $P2323, $P2322[0]
    unless_null $P2323, vivify_764
    new $P2323, "Undef"
  vivify_764:
    $P2324 = $P2323."ast"()
    set $P2317, $P2324
  if_2318_end:
    store_lex "$past", $P2317
.annotate 'line', 1042
    find_lex $P2329, "$/"
    unless_null $P2329, vivify_765
    $P2329 = root_new ['parrot';'Hash']
  vivify_765:
    set $P2330, $P2329["quote"]
    unless_null $P2330, vivify_766
    new $P2330, "Undef"
  vivify_766:
    if $P2330, if_2328
.annotate 'line', 1046
    find_lex $P2337, "$/"
    unless_null $P2337, vivify_767
    $P2337 = root_new ['parrot';'Hash']
  vivify_767:
    set $P2338, $P2337["longname"]
    unless_null $P2338, vivify_768
    new $P2338, "Undef"
  vivify_768:
    set $S2339, $P2338
    iseq $I2340, $S2339, "HOW"
    if $I2340, if_2336
.annotate 'line', 1049
    find_lex $P2343, "$/"
    unless_null $P2343, vivify_769
    $P2343 = root_new ['parrot';'Hash']
  vivify_769:
    set $P2344, $P2343["longname"]
    unless_null $P2344, vivify_770
    new $P2344, "Undef"
  vivify_770:
    set $S2345, $P2344
    iseq $I2346, $S2345, "WHAT"
    if $I2346, if_2342
.annotate 'line', 1052
    find_lex $P2349, "$/"
    unless_null $P2349, vivify_771
    $P2349 = root_new ['parrot';'Hash']
  vivify_771:
    set $P2350, $P2349["longname"]
    unless_null $P2350, vivify_772
    new $P2350, "Undef"
  vivify_772:
    set $S2351, $P2350
    iseq $I2352, $S2351, "WHO"
    if $I2352, if_2348
.annotate 'line', 1056
    find_lex $P2354, "$past"
    find_lex $P2355, "$/"
    unless_null $P2355, vivify_773
    $P2355 = root_new ['parrot';'Hash']
  vivify_773:
    set $P2356, $P2355["longname"]
    unless_null $P2356, vivify_774
    new $P2356, "Undef"
  vivify_774:
    set $S2357, $P2356
    $P2354."name"($S2357)
.annotate 'line', 1057
    find_lex $P2358, "$past"
    $P2358."pasttype"("callmethod")
.annotate 'line', 1055
    goto if_2348_end
  if_2348:
.annotate 'line', 1053
    find_lex $P2353, "$past"
    $P2353."pirop"("get_who PP")
  if_2348_end:
.annotate 'line', 1052
    goto if_2342_end
  if_2342:
.annotate 'line', 1050
    find_lex $P2347, "$past"
    $P2347."pirop"("get_what PP")
  if_2342_end:
.annotate 'line', 1049
    goto if_2336_end
  if_2336:
.annotate 'line', 1047
    find_lex $P2341, "$past"
    $P2341."pirop"("get_how PP")
  if_2336_end:
.annotate 'line', 1046
    goto if_2328_end
  if_2328:
.annotate 'line', 1043
    find_lex $P2331, "$past"
    find_lex $P2332, "$/"
    unless_null $P2332, vivify_775
    $P2332 = root_new ['parrot';'Hash']
  vivify_775:
    set $P2333, $P2332["quote"]
    unless_null $P2333, vivify_776
    new $P2333, "Undef"
  vivify_776:
    $P2334 = $P2333."ast"()
    $P2331."name"($P2334)
.annotate 'line', 1044
    find_lex $P2335, "$past"
    $P2335."pasttype"("callmethod")
  if_2328_end:
.annotate 'line', 1059
    find_lex $P2359, "$/"
    find_lex $P2360, "$past"
    $P2361 = $P2359."!make"($P2360)
.annotate 'line', 1040
    .return ($P2361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("119_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2363
    .param pmc param_2364
.annotate 'line', 1064
    .lex "self", param_2363
    .lex "$/", param_2364
.annotate 'line', 1065
    find_lex $P2365, "$/"
    get_hll_global $P2366, ["PAST"], "Var"
    $P2367 = $P2366."new"("self" :named("name"))
    $P2368 = $P2365."!make"($P2367)
.annotate 'line', 1064
    .return ($P2368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("120_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2370
    .param pmc param_2371
.annotate 'line', 1068
    .lex "self", param_2370
    .lex "$/", param_2371
.annotate 'line', 1069
    new $P2372, "Undef"
    .lex "$past", $P2372
    find_lex $P2373, "$/"
    unless_null $P2373, vivify_777
    $P2373 = root_new ['parrot';'Hash']
  vivify_777:
    set $P2374, $P2373["args"]
    unless_null $P2374, vivify_778
    new $P2374, "Undef"
  vivify_778:
    $P2375 = $P2374."ast"()
    store_lex "$past", $P2375
.annotate 'line', 1070
    find_lex $P2376, "$past"
    find_lex $P2377, "$/"
    unless_null $P2377, vivify_779
    $P2377 = root_new ['parrot';'Hash']
  vivify_779:
    set $P2378, $P2377["deflongname"]
    unless_null $P2378, vivify_780
    new $P2378, "Undef"
  vivify_780:
    set $S2379, $P2378
    $P2376."name"($S2379)
.annotate 'line', 1071
    find_lex $P2380, "$/"
    find_lex $P2381, "$past"
    $P2382 = $P2380."!make"($P2381)
.annotate 'line', 1068
    .return ($P2382)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("121_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2384
    .param pmc param_2385
.annotate 'line', 1074
    .const 'Sub' $P2400 = "122_1300051186.829" 
    capture_lex $P2400
    .lex "self", param_2384
    .lex "$/", param_2385
.annotate 'line', 1076
    new $P2386, "Undef"
    .lex "$var", $P2386
.annotate 'line', 1088
    new $P2387, "Undef"
    .lex "$past", $P2387
.annotate 'line', 1074
    find_lex $P2388, "$var"
.annotate 'line', 1077
    find_lex $P2390, "$/"
    unless_null $P2390, vivify_781
    $P2390 = root_new ['parrot';'Hash']
  vivify_781:
    set $P2391, $P2390["name"]
    unless_null $P2391, vivify_782
    new $P2391, "Undef"
  vivify_782:
    set $S2392, $P2391
    $P2393 = "is_lexical"($S2392)
    if $P2393, if_2389
.annotate 'line', 1080
    .const 'Sub' $P2400 = "122_1300051186.829" 
    capture_lex $P2400
    $P2400()
    goto if_2389_end
  if_2389:
.annotate 'line', 1078
    get_hll_global $P2394, ["PAST"], "Var"
    find_lex $P2395, "$/"
    unless_null $P2395, vivify_788
    $P2395 = root_new ['parrot';'Hash']
  vivify_788:
    set $P2396, $P2395["name"]
    unless_null $P2396, vivify_789
    new $P2396, "Undef"
  vivify_789:
    set $S2397, $P2396
    $P2398 = $P2394."new"($S2397 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P2398
  if_2389_end:
.annotate 'line', 1088
    find_lex $P2423, "$var"
    store_lex "$past", $P2423
.annotate 'line', 1089
    find_lex $P2425, "$/"
    unless_null $P2425, vivify_790
    $P2425 = root_new ['parrot';'Hash']
  vivify_790:
    set $P2426, $P2425["args"]
    unless_null $P2426, vivify_791
    new $P2426, "Undef"
  vivify_791:
    unless $P2426, if_2424_end
.annotate 'line', 1090
    find_lex $P2427, "$/"
    unless_null $P2427, vivify_792
    $P2427 = root_new ['parrot';'Hash']
  vivify_792:
    set $P2428, $P2427["args"]
    unless_null $P2428, vivify_793
    $P2428 = root_new ['parrot';'ResizablePMCArray']
  vivify_793:
    set $P2429, $P2428[0]
    unless_null $P2429, vivify_794
    new $P2429, "Undef"
  vivify_794:
    $P2430 = $P2429."ast"()
    store_lex "$past", $P2430
.annotate 'line', 1091
    find_lex $P2431, "$past"
    find_lex $P2432, "$var"
    $P2431."unshift"($P2432)
  if_2424_end:
.annotate 'line', 1093
    find_lex $P2433, "$/"
    find_lex $P2434, "$past"
    $P2435 = $P2433."!make"($P2434)
.annotate 'line', 1074
    .return ($P2435)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2399"  :anon :subid("122_1300051186.829") :outer("121_1300051186.829")
.annotate 'line', 1081
    $P2401 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2401
.annotate 'line', 1082
    new $P2402, "Undef"
    .lex "$name", $P2402
.annotate 'line', 1081
    find_lex $P2403, "$/"
    unless_null $P2403, vivify_783
    $P2403 = root_new ['parrot';'Hash']
  vivify_783:
    set $P2404, $P2403["name"]
    unless_null $P2404, vivify_784
    $P2404 = root_new ['parrot';'Hash']
  vivify_784:
    set $P2405, $P2404["identifier"]
    unless_null $P2405, vivify_785
    new $P2405, "Undef"
  vivify_785:
    clone $P2406, $P2405
    store_lex "@ns", $P2406
.annotate 'line', 1082
    find_lex $P2407, "@ns"
    $P2408 = $P2407."pop"()
    store_lex "$name", $P2408
.annotate 'line', 1083
    find_lex $P2412, "@ns"
    if $P2412, if_2411
    set $P2410, $P2412
    goto if_2411_end
  if_2411:
    find_lex $P2413, "@ns"
    unless_null $P2413, vivify_786
    $P2413 = root_new ['parrot';'ResizablePMCArray']
  vivify_786:
    set $P2414, $P2413[0]
    unless_null $P2414, vivify_787
    new $P2414, "Undef"
  vivify_787:
    set $S2415, $P2414
    iseq $I2416, $S2415, "GLOBAL"
    new $P2410, 'Integer'
    set $P2410, $I2416
  if_2411_end:
    unless $P2410, if_2409_end
    find_lex $P2417, "@ns"
    $P2417."shift"()
  if_2409_end:
.annotate 'line', 1084
    get_hll_global $P2418, ["PAST"], "Var"
    find_lex $P2419, "$name"
    set $S2420, $P2419
    find_lex $P2421, "@ns"
    $P2422 = $P2418."new"($S2420 :named("name"), $P2421 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2422
.annotate 'line', 1080
    .return ($P2422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("123_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2438
    .param pmc param_2439
.annotate 'line', 1106
    .lex "self", param_2438
    .lex "$/", param_2439
.annotate 'line', 1107
    new $P2440, "Undef"
    .lex "$past", $P2440
.annotate 'line', 1108
    new $P2441, "Undef"
    .lex "$pirop", $P2441
.annotate 'line', 1107
    find_lex $P2444, "$/"
    unless_null $P2444, vivify_795
    $P2444 = root_new ['parrot';'Hash']
  vivify_795:
    set $P2445, $P2444["args"]
    unless_null $P2445, vivify_796
    new $P2445, "Undef"
  vivify_796:
    if $P2445, if_2443
    get_hll_global $P2450, ["PAST"], "Op"
    find_lex $P2451, "$/"
    $P2452 = $P2450."new"($P2451 :named("node"))
    set $P2442, $P2452
    goto if_2443_end
  if_2443:
    find_lex $P2446, "$/"
    unless_null $P2446, vivify_797
    $P2446 = root_new ['parrot';'Hash']
  vivify_797:
    set $P2447, $P2446["args"]
    unless_null $P2447, vivify_798
    $P2447 = root_new ['parrot';'ResizablePMCArray']
  vivify_798:
    set $P2448, $P2447[0]
    unless_null $P2448, vivify_799
    new $P2448, "Undef"
  vivify_799:
    $P2449 = $P2448."ast"()
    set $P2442, $P2449
  if_2443_end:
    store_lex "$past", $P2442
.annotate 'line', 1108
    find_lex $P2453, "$/"
    unless_null $P2453, vivify_800
    $P2453 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2454, $P2453["op"]
    unless_null $P2454, vivify_801
    new $P2454, "Undef"
  vivify_801:
    set $S2455, $P2454
    new $P2456, 'String'
    set $P2456, $S2455
    store_lex "$pirop", $P2456
.annotate 'line', 1109

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2457 = box $S0
    
    store_lex "$pirop", $P2457
.annotate 'line', 1116
    find_lex $P2458, "$past"
    find_lex $P2459, "$pirop"
    $P2458."pirop"($P2459)
.annotate 'line', 1117
    find_lex $P2460, "$past"
    $P2460."pasttype"("pirop")
.annotate 'line', 1118
    find_lex $P2461, "$/"
    find_lex $P2462, "$past"
    $P2463 = $P2461."!make"($P2462)
.annotate 'line', 1106
    .return ($P2463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("124_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2465
    .param pmc param_2466
.annotate 'line', 1121
    .lex "self", param_2465
    .lex "$/", param_2466
.annotate 'line', 1122
    find_lex $P2467, "$/"
    get_hll_global $P2468, ["PAST"], "Op"
    $P2469 = $P2468."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2470 = $P2467."!make"($P2469)
.annotate 'line', 1121
    .return ($P2470)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("125_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2472
    .param pmc param_2473
.annotate 'line', 1127
    .lex "self", param_2472
    .lex "$/", param_2473
    find_lex $P2474, "$/"
    find_lex $P2475, "$/"
    unless_null $P2475, vivify_802
    $P2475 = root_new ['parrot';'Hash']
  vivify_802:
    set $P2476, $P2475["arglist"]
    unless_null $P2476, vivify_803
    new $P2476, "Undef"
  vivify_803:
    $P2477 = $P2476."ast"()
    $P2478 = $P2474."!make"($P2477)
    .return ($P2478)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("126_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2480
    .param pmc param_2481
.annotate 'line', 1129
    .const 'Sub' $P2492 = "127_1300051186.829" 
    capture_lex $P2492
    .lex "self", param_2480
    .lex "$/", param_2481
.annotate 'line', 1130
    new $P2482, "Undef"
    .lex "$past", $P2482
.annotate 'line', 1138
    new $P2483, "Undef"
    .lex "$i", $P2483
.annotate 'line', 1139
    new $P2484, "Undef"
    .lex "$n", $P2484
.annotate 'line', 1130
    get_hll_global $P2485, ["PAST"], "Op"
    find_lex $P2486, "$/"
    $P2487 = $P2485."new"("call" :named("pasttype"), $P2486 :named("node"))
    store_lex "$past", $P2487
.annotate 'line', 1131
    find_lex $P2489, "$/"
    unless_null $P2489, vivify_804
    $P2489 = root_new ['parrot';'Hash']
  vivify_804:
    set $P2490, $P2489["EXPR"]
    unless_null $P2490, vivify_805
    new $P2490, "Undef"
  vivify_805:
    unless $P2490, if_2488_end
    .const 'Sub' $P2492 = "127_1300051186.829" 
    capture_lex $P2492
    $P2492()
  if_2488_end:
.annotate 'line', 1138
    new $P2524, "Integer"
    assign $P2524, 0
    store_lex "$i", $P2524
.annotate 'line', 1139
    find_lex $P2525, "$past"
    $P2526 = $P2525."list"()
    set $N2527, $P2526
    new $P2528, 'Float'
    set $P2528, $N2527
    store_lex "$n", $P2528
.annotate 'line', 1140
    new $P2576, 'ExceptionHandler'
    set_label $P2576, loop2575_handler
    $P2576."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2576
  loop2575_test:
    find_lex $P2529, "$i"
    set $N2530, $P2529
    find_lex $P2531, "$n"
    set $N2532, $P2531
    islt $I2533, $N2530, $N2532
    unless $I2533, loop2575_done
  loop2575_redo:
.annotate 'line', 1141
    find_lex $P2535, "$i"
    set $I2536, $P2535
    find_lex $P2537, "$past"
    unless_null $P2537, vivify_809
    $P2537 = root_new ['parrot';'ResizablePMCArray']
  vivify_809:
    set $P2538, $P2537[$I2536]
    unless_null $P2538, vivify_810
    new $P2538, "Undef"
  vivify_810:
    $S2539 = $P2538."name"()
    iseq $I2540, $S2539, "&prefix:<|>"
    unless $I2540, if_2534_end
.annotate 'line', 1142
    find_lex $P2541, "$i"
    set $I2542, $P2541
    find_lex $P2543, "$past"
    unless_null $P2543, vivify_811
    $P2543 = root_new ['parrot';'ResizablePMCArray']
  vivify_811:
    set $P2544, $P2543[$I2542]
    unless_null $P2544, vivify_812
    $P2544 = root_new ['parrot';'ResizablePMCArray']
  vivify_812:
    set $P2545, $P2544[0]
    unless_null $P2545, vivify_813
    new $P2545, "Undef"
  vivify_813:
    find_lex $P2546, "$i"
    set $I2547, $P2546
    find_lex $P2548, "$past"
    unless_null $P2548, vivify_814
    $P2548 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2548
  vivify_814:
    set $P2548[$I2547], $P2545
.annotate 'line', 1143
    find_lex $P2549, "$i"
    set $I2550, $P2549
    find_lex $P2551, "$past"
    unless_null $P2551, vivify_815
    $P2551 = root_new ['parrot';'ResizablePMCArray']
  vivify_815:
    set $P2552, $P2551[$I2550]
    unless_null $P2552, vivify_816
    new $P2552, "Undef"
  vivify_816:
    $P2552."flat"(1)
.annotate 'line', 1144
    find_lex $P2556, "$i"
    set $I2557, $P2556
    find_lex $P2558, "$past"
    unless_null $P2558, vivify_817
    $P2558 = root_new ['parrot';'ResizablePMCArray']
  vivify_817:
    set $P2559, $P2558[$I2557]
    unless_null $P2559, vivify_818
    new $P2559, "Undef"
  vivify_818:
    get_hll_global $P2560, ["PAST"], "Val"
    $P2561 = $P2559."isa"($P2560)
    if $P2561, if_2555
    set $P2554, $P2561
    goto if_2555_end
  if_2555:
.annotate 'line', 1145
    find_lex $P2562, "$i"
    set $I2563, $P2562
    find_lex $P2564, "$past"
    unless_null $P2564, vivify_819
    $P2564 = root_new ['parrot';'ResizablePMCArray']
  vivify_819:
    set $P2565, $P2564[$I2563]
    unless_null $P2565, vivify_820
    new $P2565, "Undef"
  vivify_820:
    $S2566 = $P2565."name"()
    substr $S2567, $S2566, 0, 1
    iseq $I2568, $S2567, "%"
    new $P2554, 'Integer'
    set $P2554, $I2568
  if_2555_end:
    unless $P2554, if_2553_end
.annotate 'line', 1146
    find_lex $P2569, "$i"
    set $I2570, $P2569
    find_lex $P2571, "$past"
    unless_null $P2571, vivify_821
    $P2571 = root_new ['parrot';'ResizablePMCArray']
  vivify_821:
    set $P2572, $P2571[$I2570]
    unless_null $P2572, vivify_822
    new $P2572, "Undef"
  vivify_822:
    $P2572."named"(1)
  if_2553_end:
  if_2534_end:
.annotate 'line', 1141
    find_lex $P2573, "$i"
    clone $P2574, $P2573
    inc $P2573
  loop2575_next:
.annotate 'line', 1140
    goto loop2575_test
  loop2575_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2577, exception, 'type'
    eq $P2577, .CONTROL_LOOP_NEXT, loop2575_next
    eq $P2577, .CONTROL_LOOP_REDO, loop2575_redo
  loop2575_done:
    pop_eh 
.annotate 'line', 1151
    find_lex $P2578, "$/"
    find_lex $P2579, "$past"
    $P2580 = $P2578."!make"($P2579)
.annotate 'line', 1129
    .return ($P2580)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2491"  :anon :subid("127_1300051186.829") :outer("126_1300051186.829")
.annotate 'line', 1131
    .const 'Sub' $P2513 = "128_1300051186.829" 
    capture_lex $P2513
.annotate 'line', 1132
    new $P2493, "Undef"
    .lex "$expr", $P2493
    find_lex $P2494, "$/"
    unless_null $P2494, vivify_806
    $P2494 = root_new ['parrot';'Hash']
  vivify_806:
    set $P2495, $P2494["EXPR"]
    unless_null $P2495, vivify_807
    new $P2495, "Undef"
  vivify_807:
    $P2496 = $P2495."ast"()
    store_lex "$expr", $P2496
.annotate 'line', 1133
    find_lex $P2501, "$expr"
    $S2502 = $P2501."name"()
    iseq $I2503, $S2502, "&infix:<,>"
    if $I2503, if_2500
    new $P2499, 'Integer'
    set $P2499, $I2503
    goto if_2500_end
  if_2500:
    find_lex $P2504, "$expr"
    $P2505 = $P2504."named"()
    isfalse $I2506, $P2505
    new $P2499, 'Integer'
    set $P2499, $I2506
  if_2500_end:
    if $P2499, if_2498
.annotate 'line', 1136
    find_lex $P2521, "$past"
    find_lex $P2522, "$expr"
    $P2523 = $P2521."push"($P2522)
    set $P2497, $P2523
.annotate 'line', 1133
    goto if_2498_end
  if_2498:
.annotate 'line', 1134
    find_lex $P2508, "$expr"
    $P2509 = $P2508."list"()
    defined $I2510, $P2509
    unless $I2510, for_undef_808
    iter $P2507, $P2509
    new $P2519, 'ExceptionHandler'
    set_label $P2519, loop2518_handler
    $P2519."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2519
  loop2518_test:
    unless $P2507, loop2518_done
    shift $P2511, $P2507
  loop2518_redo:
    .const 'Sub' $P2513 = "128_1300051186.829" 
    capture_lex $P2513
    $P2513($P2511)
  loop2518_next:
    goto loop2518_test
  loop2518_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2520, exception, 'type'
    eq $P2520, .CONTROL_LOOP_NEXT, loop2518_next
    eq $P2520, .CONTROL_LOOP_REDO, loop2518_redo
  loop2518_done:
    pop_eh 
  for_undef_808:
.annotate 'line', 1133
    set $P2497, $P2507
  if_2498_end:
.annotate 'line', 1131
    .return ($P2497)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2512"  :anon :subid("128_1300051186.829") :outer("127_1300051186.829")
    .param pmc param_2514
.annotate 'line', 1134
    .lex "$_", param_2514
    find_lex $P2515, "$past"
    find_lex $P2516, "$_"
    $P2517 = $P2515."push"($P2516)
    .return ($P2517)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("129_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2582
    .param pmc param_2583
.annotate 'line', 1154
    .lex "self", param_2582
    .lex "$/", param_2583
    find_lex $P2584, "$/"
    find_lex $P2585, "$/"
    unless_null $P2585, vivify_823
    $P2585 = root_new ['parrot';'Hash']
  vivify_823:
    set $P2586, $P2585["multi_declarator"]
    unless_null $P2586, vivify_824
    new $P2586, "Undef"
  vivify_824:
    $P2587 = $P2586."ast"()
    $P2588 = $P2584."!make"($P2587)
    .return ($P2588)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("130_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2590
    .param pmc param_2591
.annotate 'line', 1156
    .lex "self", param_2590
    .lex "$/", param_2591
    find_lex $P2592, "$/"
    find_lex $P2593, "$/"
    unless_null $P2593, vivify_825
    $P2593 = root_new ['parrot';'Hash']
  vivify_825:
    set $P2594, $P2593["value"]
    unless_null $P2594, vivify_826
    new $P2594, "Undef"
  vivify_826:
    $P2595 = $P2594."ast"()
    $P2596 = $P2592."!make"($P2595)
    .return ($P2596)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("131_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2598
    .param pmc param_2599
.annotate 'line', 1158
    .lex "self", param_2598
    .lex "$/", param_2599
.annotate 'line', 1159
    find_lex $P2600, "$/"
.annotate 'line', 1160
    find_lex $P2603, "$/"
    unless_null $P2603, vivify_827
    $P2603 = root_new ['parrot';'Hash']
  vivify_827:
    set $P2604, $P2603["EXPR"]
    unless_null $P2604, vivify_828
    new $P2604, "Undef"
  vivify_828:
    if $P2604, if_2602
.annotate 'line', 1161
    get_hll_global $P2609, ["PAST"], "Op"
    find_lex $P2610, "$/"
    $P2611 = $P2609."new"("list" :named("pasttype"), $P2610 :named("node"))
    set $P2601, $P2611
.annotate 'line', 1160
    goto if_2602_end
  if_2602:
    find_lex $P2605, "$/"
    unless_null $P2605, vivify_829
    $P2605 = root_new ['parrot';'Hash']
  vivify_829:
    set $P2606, $P2605["EXPR"]
    unless_null $P2606, vivify_830
    $P2606 = root_new ['parrot';'ResizablePMCArray']
  vivify_830:
    set $P2607, $P2606[0]
    unless_null $P2607, vivify_831
    new $P2607, "Undef"
  vivify_831:
    $P2608 = $P2607."ast"()
    set $P2601, $P2608
  if_2602_end:
    $P2612 = $P2600."!make"($P2601)
.annotate 'line', 1158
    .return ($P2612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("132_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2614
    .param pmc param_2615
.annotate 'line', 1164
    .lex "self", param_2614
    .lex "$/", param_2615
.annotate 'line', 1165
    new $P2616, "Undef"
    .lex "$past", $P2616
.annotate 'line', 1164
    find_lex $P2617, "$past"
.annotate 'line', 1166
    find_lex $P2619, "$/"
    unless_null $P2619, vivify_832
    $P2619 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2620, $P2619["EXPR"]
    unless_null $P2620, vivify_833
    new $P2620, "Undef"
  vivify_833:
    if $P2620, if_2618
.annotate 'line', 1173
    get_hll_global $P2632, ["PAST"], "Op"
    $P2633 = $P2632."new"("list" :named("pasttype"))
    store_lex "$past", $P2633
.annotate 'line', 1172
    goto if_2618_end
  if_2618:
.annotate 'line', 1167
    find_lex $P2621, "$/"
    unless_null $P2621, vivify_834
    $P2621 = root_new ['parrot';'Hash']
  vivify_834:
    set $P2622, $P2621["EXPR"]
    unless_null $P2622, vivify_835
    $P2622 = root_new ['parrot';'ResizablePMCArray']
  vivify_835:
    set $P2623, $P2622[0]
    unless_null $P2623, vivify_836
    new $P2623, "Undef"
  vivify_836:
    $P2624 = $P2623."ast"()
    store_lex "$past", $P2624
.annotate 'line', 1168
    find_lex $P2626, "$past"
    $S2627 = $P2626."name"()
    isne $I2628, $S2627, "&infix:<,>"
    unless $I2628, if_2625_end
.annotate 'line', 1169
    get_hll_global $P2629, ["PAST"], "Op"
    find_lex $P2630, "$past"
    $P2631 = $P2629."new"($P2630, "list" :named("pasttype"))
    store_lex "$past", $P2631
  if_2625_end:
  if_2618_end:
.annotate 'line', 1175
    find_lex $P2634, "$past"
    $P2634."name"("&circumfix:<[ ]>")
.annotate 'line', 1176
    find_lex $P2635, "$/"
    find_lex $P2636, "$past"
    $P2637 = $P2635."!make"($P2636)
.annotate 'line', 1164
    .return ($P2637)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("133_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2639
    .param pmc param_2640
.annotate 'line', 1179
    .lex "self", param_2639
    .lex "$/", param_2640
    find_lex $P2641, "$/"
    find_lex $P2642, "$/"
    unless_null $P2642, vivify_837
    $P2642 = root_new ['parrot';'Hash']
  vivify_837:
    set $P2643, $P2642["quote_EXPR"]
    unless_null $P2643, vivify_838
    new $P2643, "Undef"
  vivify_838:
    $P2644 = $P2643."ast"()
    $P2645 = $P2641."!make"($P2644)
    .return ($P2645)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("134_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2647
    .param pmc param_2648
.annotate 'line', 1180
    .lex "self", param_2647
    .lex "$/", param_2648
    find_lex $P2649, "$/"
    find_lex $P2650, "$/"
    unless_null $P2650, vivify_839
    $P2650 = root_new ['parrot';'Hash']
  vivify_839:
    set $P2651, $P2650["quote_EXPR"]
    unless_null $P2651, vivify_840
    new $P2651, "Undef"
  vivify_840:
    $P2652 = $P2651."ast"()
    $P2653 = $P2649."!make"($P2652)
    .return ($P2653)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("135_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2655
    .param pmc param_2656
.annotate 'line', 1182
    .const 'Sub' $P2667 = "136_1300051186.829" 
    capture_lex $P2667
    .lex "self", param_2655
    .lex "$/", param_2656
.annotate 'line', 1183
    find_lex $P2659, "$/"
    unless_null $P2659, vivify_841
    $P2659 = root_new ['parrot';'Hash']
  vivify_841:
    set $P2660, $P2659["pblock"]
    unless_null $P2660, vivify_842
    $P2660 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2661, $P2660["blockoid"]
    unless_null $P2661, vivify_843
    $P2661 = root_new ['parrot';'Hash']
  vivify_843:
    set $P2662, $P2661["statementlist"]
    unless_null $P2662, vivify_844
    $P2662 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2663, $P2662["statement"]
    unless_null $P2663, vivify_845
    new $P2663, "Undef"
  vivify_845:
    set $N2664, $P2663
    isgt $I2665, $N2664, 0.0
    if $I2665, if_2658
.annotate 'line', 1188
    find_lex $P2680, "$/"
    unless_null $P2680, vivify_846
    $P2680 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2681, $P2680["pblock"]
    unless_null $P2681, vivify_847
    $P2681 = root_new ['parrot';'Hash']
  vivify_847:
    set $P2682, $P2681["blockoid"]
    unless_null $P2682, vivify_848
    $P2682 = root_new ['parrot';'Hash']
  vivify_848:
    set $P2683, $P2682["you_are_here"]
    unless_null $P2683, vivify_849
    new $P2683, "Undef"
  vivify_849:
    if $P2683, if_2679
.annotate 'line', 1192
    find_lex $P2689, "$/"
    $P2690 = "vivitype"("%")
    $P2691 = $P2689."!make"($P2690)
.annotate 'line', 1191
    set $P2678, $P2691
.annotate 'line', 1188
    goto if_2679_end
  if_2679:
.annotate 'line', 1189
    find_lex $P2684, "$/"
    find_lex $P2685, "$/"
    unless_null $P2685, vivify_850
    $P2685 = root_new ['parrot';'Hash']
  vivify_850:
    set $P2686, $P2685["pblock"]
    unless_null $P2686, vivify_851
    new $P2686, "Undef"
  vivify_851:
    $P2687 = $P2686."ast"()
    $P2688 = $P2684."!make"($P2687)
.annotate 'line', 1188
    set $P2678, $P2688
  if_2679_end:
    set $P2657, $P2678
.annotate 'line', 1183
    goto if_2658_end
  if_2658:
    .const 'Sub' $P2667 = "136_1300051186.829" 
    capture_lex $P2667
    $P2677 = $P2667()
    set $P2657, $P2677
  if_2658_end:
.annotate 'line', 1182
    .return ($P2657)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2666"  :anon :subid("136_1300051186.829") :outer("135_1300051186.829")
.annotate 'line', 1184
    new $P2668, "Undef"
    .lex "$past", $P2668
    find_lex $P2669, "$/"
    unless_null $P2669, vivify_852
    $P2669 = root_new ['parrot';'Hash']
  vivify_852:
    set $P2670, $P2669["pblock"]
    unless_null $P2670, vivify_853
    new $P2670, "Undef"
  vivify_853:
    $P2671 = $P2670."ast"()
    store_lex "$past", $P2671
.annotate 'line', 1185
    new $P2672, "Integer"
    assign $P2672, 1
    find_lex $P2673, "$past"
    unless_null $P2673, vivify_854
    $P2673 = root_new ['parrot';'Hash']
    store_lex "$past", $P2673
  vivify_854:
    set $P2673["bareblock"], $P2672
.annotate 'line', 1186
    find_dynamic_lex $P2674, "$/"
    find_lex $P2675, "$past"
    $P2676 = $P2674."!make"($P2675)
.annotate 'line', 1183
    .return ($P2676)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("137_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2693
    .param pmc param_2694
.annotate 'line', 1196
    .lex "self", param_2693
    .lex "$/", param_2694
.annotate 'line', 1197
    new $P2695, "Undef"
    .lex "$name", $P2695
    find_lex $P2698, "$/"
    unless_null $P2698, vivify_855
    $P2698 = root_new ['parrot';'Hash']
  vivify_855:
    set $P2699, $P2698["sigil"]
    unless_null $P2699, vivify_856
    new $P2699, "Undef"
  vivify_856:
    set $S2700, $P2699
    iseq $I2701, $S2700, "@"
    if $I2701, if_2697
.annotate 'line', 1198
    find_lex $P2705, "$/"
    unless_null $P2705, vivify_857
    $P2705 = root_new ['parrot';'Hash']
  vivify_857:
    set $P2706, $P2705["sigil"]
    unless_null $P2706, vivify_858
    new $P2706, "Undef"
  vivify_858:
    set $S2707, $P2706
    iseq $I2708, $S2707, "%"
    if $I2708, if_2704
    new $P2710, "String"
    assign $P2710, "item"
    set $P2703, $P2710
    goto if_2704_end
  if_2704:
    new $P2709, "String"
    assign $P2709, "hash"
    set $P2703, $P2709
  if_2704_end:
    set $P2696, $P2703
.annotate 'line', 1197
    goto if_2697_end
  if_2697:
    new $P2702, "String"
    assign $P2702, "list"
    set $P2696, $P2702
  if_2697_end:
    store_lex "$name", $P2696
.annotate 'line', 1200
    find_lex $P2711, "$/"
    get_hll_global $P2712, ["PAST"], "Op"
    find_lex $P2713, "$name"
    find_lex $P2714, "$/"
    unless_null $P2714, vivify_859
    $P2714 = root_new ['parrot';'Hash']
  vivify_859:
    set $P2715, $P2714["semilist"]
    unless_null $P2715, vivify_860
    new $P2715, "Undef"
  vivify_860:
    $P2716 = $P2715."ast"()
    $P2717 = $P2712."new"($P2716, "callmethod" :named("pasttype"), $P2713 :named("name"))
    $P2718 = $P2711."!make"($P2717)
.annotate 'line', 1196
    .return ($P2718)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("138_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2720
    .param pmc param_2721
.annotate 'line', 1203
    .lex "self", param_2720
    .lex "$/", param_2721
    find_lex $P2722, "$/"
    find_lex $P2723, "$/"
    unless_null $P2723, vivify_861
    $P2723 = root_new ['parrot';'Hash']
  vivify_861:
    set $P2724, $P2723["statement"]
    unless_null $P2724, vivify_862
    new $P2724, "Undef"
  vivify_862:
    $P2725 = $P2724."ast"()
    $P2726 = $P2722."!make"($P2725)
    .return ($P2726)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("139_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2728
    .param pmc param_2729
.annotate 'line', 1205
    .lex "self", param_2728
    .lex "$/", param_2729
.annotate 'line', 1206
    find_lex $P2730, "$/"
    get_hll_global $P2731, ["PAST"], "Var"
    find_lex $P2732, "$/"
    unless_null $P2732, vivify_863
    $P2732 = root_new ['parrot';'Hash']
  vivify_863:
    set $P2733, $P2732["EXPR"]
    unless_null $P2733, vivify_864
    new $P2733, "Undef"
  vivify_864:
    $P2734 = $P2733."ast"()
.annotate 'line', 1208
    $P2735 = "vivitype"("@")
    $P2736 = $P2731."new"($P2734, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2735 :named("vivibase"))
.annotate 'line', 1206
    $P2737 = $P2730."!make"($P2736)
.annotate 'line', 1205
    .return ($P2737)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("140_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2739
    .param pmc param_2740
.annotate 'line', 1211
    .lex "self", param_2739
    .lex "$/", param_2740
.annotate 'line', 1212
    find_lex $P2741, "$/"
    get_hll_global $P2742, ["PAST"], "Var"
    find_lex $P2743, "$/"
    unless_null $P2743, vivify_865
    $P2743 = root_new ['parrot';'Hash']
  vivify_865:
    set $P2744, $P2743["EXPR"]
    unless_null $P2744, vivify_866
    new $P2744, "Undef"
  vivify_866:
    $P2745 = $P2744."ast"()
.annotate 'line', 1214
    $P2746 = "vivitype"("%")
    $P2747 = $P2742."new"($P2745, "keyed" :named("scope"), "Undef" :named("viviself"), $P2746 :named("vivibase"))
.annotate 'line', 1212
    $P2748 = $P2741."!make"($P2747)
.annotate 'line', 1211
    .return ($P2748)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("141_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2750
    .param pmc param_2751
.annotate 'line', 1217
    .lex "self", param_2750
    .lex "$/", param_2751
.annotate 'line', 1218
    find_lex $P2752, "$/"
    get_hll_global $P2753, ["PAST"], "Var"
    find_lex $P2754, "$/"
    unless_null $P2754, vivify_867
    $P2754 = root_new ['parrot';'Hash']
  vivify_867:
    set $P2755, $P2754["quote_EXPR"]
    unless_null $P2755, vivify_868
    new $P2755, "Undef"
  vivify_868:
    $P2756 = $P2755."ast"()
.annotate 'line', 1220
    $P2757 = "vivitype"("%")
    $P2758 = $P2753."new"($P2756, "keyed" :named("scope"), "Undef" :named("viviself"), $P2757 :named("vivibase"))
.annotate 'line', 1218
    $P2759 = $P2752."!make"($P2758)
.annotate 'line', 1217
    .return ($P2759)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("142_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2761
    .param pmc param_2762
.annotate 'line', 1223
    .lex "self", param_2761
    .lex "$/", param_2762
.annotate 'line', 1224
    find_lex $P2763, "$/"
    find_lex $P2764, "$/"
    unless_null $P2764, vivify_869
    $P2764 = root_new ['parrot';'Hash']
  vivify_869:
    set $P2765, $P2764["arglist"]
    unless_null $P2765, vivify_870
    new $P2765, "Undef"
  vivify_870:
    $P2766 = $P2765."ast"()
    $P2767 = $P2763."!make"($P2766)
.annotate 'line', 1223
    .return ($P2767)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("143_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2769
    .param pmc param_2770
.annotate 'line', 1227
    .lex "self", param_2769
    .lex "$/", param_2770
.annotate 'line', 1228
    find_lex $P2771, "$/"
    find_lex $P2774, "$/"
    unless_null $P2774, vivify_871
    $P2774 = root_new ['parrot';'Hash']
  vivify_871:
    set $P2775, $P2774["quote"]
    unless_null $P2775, vivify_872
    new $P2775, "Undef"
  vivify_872:
    if $P2775, if_2773
    find_lex $P2779, "$/"
    unless_null $P2779, vivify_873
    $P2779 = root_new ['parrot';'Hash']
  vivify_873:
    set $P2780, $P2779["number"]
    unless_null $P2780, vivify_874
    new $P2780, "Undef"
  vivify_874:
    $P2781 = $P2780."ast"()
    set $P2772, $P2781
    goto if_2773_end
  if_2773:
    find_lex $P2776, "$/"
    unless_null $P2776, vivify_875
    $P2776 = root_new ['parrot';'Hash']
  vivify_875:
    set $P2777, $P2776["quote"]
    unless_null $P2777, vivify_876
    new $P2777, "Undef"
  vivify_876:
    $P2778 = $P2777."ast"()
    set $P2772, $P2778
  if_2773_end:
    $P2782 = $P2771."!make"($P2772)
.annotate 'line', 1227
    .return ($P2782)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("144_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2784
    .param pmc param_2785
.annotate 'line', 1231
    .lex "self", param_2784
    .lex "$/", param_2785
.annotate 'line', 1232
    new $P2786, "Undef"
    .lex "$value", $P2786
    find_lex $P2789, "$/"
    unless_null $P2789, vivify_877
    $P2789 = root_new ['parrot';'Hash']
  vivify_877:
    set $P2790, $P2789["dec_number"]
    unless_null $P2790, vivify_878
    new $P2790, "Undef"
  vivify_878:
    if $P2790, if_2788
    find_lex $P2794, "$/"
    unless_null $P2794, vivify_879
    $P2794 = root_new ['parrot';'Hash']
  vivify_879:
    set $P2795, $P2794["integer"]
    unless_null $P2795, vivify_880
    new $P2795, "Undef"
  vivify_880:
    $P2796 = $P2795."ast"()
    set $P2787, $P2796
    goto if_2788_end
  if_2788:
    find_lex $P2791, "$/"
    unless_null $P2791, vivify_881
    $P2791 = root_new ['parrot';'Hash']
  vivify_881:
    set $P2792, $P2791["dec_number"]
    unless_null $P2792, vivify_882
    new $P2792, "Undef"
  vivify_882:
    $P2793 = $P2792."ast"()
    set $P2787, $P2793
  if_2788_end:
    store_lex "$value", $P2787
.annotate 'line', 1233
    find_lex $P2798, "$/"
    unless_null $P2798, vivify_883
    $P2798 = root_new ['parrot';'Hash']
  vivify_883:
    set $P2799, $P2798["sign"]
    unless_null $P2799, vivify_884
    new $P2799, "Undef"
  vivify_884:
    set $S2800, $P2799
    iseq $I2801, $S2800, "-"
    unless $I2801, if_2797_end
    find_lex $P2802, "$value"
    neg $P2803, $P2802
    store_lex "$value", $P2803
  if_2797_end:
.annotate 'line', 1234
    find_lex $P2804, "$/"
    get_hll_global $P2805, ["PAST"], "Val"
    find_lex $P2806, "$value"
    $P2807 = $P2805."new"($P2806 :named("value"))
    $P2808 = $P2804."!make"($P2807)
.annotate 'line', 1231
    .return ($P2808)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("145_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2810
    .param pmc param_2811
.annotate 'line', 1237
    .lex "self", param_2810
    .lex "$/", param_2811
    find_lex $P2812, "$/"
    find_lex $P2813, "$/"
    unless_null $P2813, vivify_885
    $P2813 = root_new ['parrot';'Hash']
  vivify_885:
    set $P2814, $P2813["quote_EXPR"]
    unless_null $P2814, vivify_886
    new $P2814, "Undef"
  vivify_886:
    $P2815 = $P2814."ast"()
    $P2816 = $P2812."!make"($P2815)
    .return ($P2816)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("146_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2818
    .param pmc param_2819
.annotate 'line', 1238
    .lex "self", param_2818
    .lex "$/", param_2819
    find_lex $P2820, "$/"
    find_lex $P2821, "$/"
    unless_null $P2821, vivify_887
    $P2821 = root_new ['parrot';'Hash']
  vivify_887:
    set $P2822, $P2821["quote_EXPR"]
    unless_null $P2822, vivify_888
    new $P2822, "Undef"
  vivify_888:
    $P2823 = $P2822."ast"()
    $P2824 = $P2820."!make"($P2823)
    .return ($P2824)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("147_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2826
    .param pmc param_2827
.annotate 'line', 1239
    .lex "self", param_2826
    .lex "$/", param_2827
    find_lex $P2828, "$/"
    find_lex $P2829, "$/"
    unless_null $P2829, vivify_889
    $P2829 = root_new ['parrot';'Hash']
  vivify_889:
    set $P2830, $P2829["quote_EXPR"]
    unless_null $P2830, vivify_890
    new $P2830, "Undef"
  vivify_890:
    $P2831 = $P2830."ast"()
    $P2832 = $P2828."!make"($P2831)
    .return ($P2832)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("148_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2834
    .param pmc param_2835
.annotate 'line', 1240
    .lex "self", param_2834
    .lex "$/", param_2835
    find_lex $P2836, "$/"
    find_lex $P2837, "$/"
    unless_null $P2837, vivify_891
    $P2837 = root_new ['parrot';'Hash']
  vivify_891:
    set $P2838, $P2837["quote_EXPR"]
    unless_null $P2838, vivify_892
    new $P2838, "Undef"
  vivify_892:
    $P2839 = $P2838."ast"()
    $P2840 = $P2836."!make"($P2839)
    .return ($P2840)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("149_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2842
    .param pmc param_2843
.annotate 'line', 1241
    .lex "self", param_2842
    .lex "$/", param_2843
    find_lex $P2844, "$/"
    find_lex $P2845, "$/"
    unless_null $P2845, vivify_893
    $P2845 = root_new ['parrot';'Hash']
  vivify_893:
    set $P2846, $P2845["quote_EXPR"]
    unless_null $P2846, vivify_894
    new $P2846, "Undef"
  vivify_894:
    $P2847 = $P2846."ast"()
    $P2848 = $P2844."!make"($P2847)
    .return ($P2848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("150_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2850
    .param pmc param_2851
.annotate 'line', 1242
    .lex "self", param_2850
    .lex "$/", param_2851
.annotate 'line', 1243
    find_lex $P2852, "$/"
    get_hll_global $P2853, ["PAST"], "Op"
    find_lex $P2854, "$/"
    unless_null $P2854, vivify_895
    $P2854 = root_new ['parrot';'Hash']
  vivify_895:
    set $P2855, $P2854["quote_EXPR"]
    unless_null $P2855, vivify_896
    new $P2855, "Undef"
  vivify_896:
    $P2856 = $P2855."ast"()
    $P2857 = $P2856."value"()
    find_lex $P2858, "$/"
    $P2859 = $P2853."new"($P2857 :named("inline"), "inline" :named("pasttype"), $P2858 :named("node"))
    $P2860 = $P2852."!make"($P2859)
.annotate 'line', 1242
    .return ($P2860)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("151_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2864
    .param pmc param_2865
    .param pmc param_2866 :optional
    .param int has_param_2866 :opt_flag
.annotate 'line', 1248
    new $P2863, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2863, control_2862
    push_eh $P2863
    .lex "self", param_2864
    .lex "$/", param_2865
    if has_param_2866, optparam_897
    new $P2867, "Undef"
    set param_2866, $P2867
  optparam_897:
    .lex "$key", param_2866
.annotate 'line', 1258
    new $P2868, "Undef"
    .lex "$regex", $P2868
.annotate 'line', 1260
    new $P2869, "Undef"
    .lex "$past", $P2869
.annotate 'line', 1249
    find_lex $P2871, "$key"
    set $S2872, $P2871
    iseq $I2873, $S2872, "open"
    unless $I2873, if_2870_end
.annotate 'line', 1250

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1254
    get_global $P2874, "@BLOCK"
    unless_null $P2874, vivify_898
    $P2874 = root_new ['parrot';'ResizablePMCArray']
  vivify_898:
    set $P2875, $P2874[0]
    unless_null $P2875, vivify_899
    new $P2875, "Undef"
  vivify_899:
    $P2875."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1255
    get_global $P2876, "@BLOCK"
    unless_null $P2876, vivify_900
    $P2876 = root_new ['parrot';'ResizablePMCArray']
  vivify_900:
    set $P2877, $P2876[0]
    unless_null $P2877, vivify_901
    new $P2877, "Undef"
  vivify_901:
    $P2877."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1256
    new $P2878, "Exception"
    set $P2878['type'], .CONTROL_RETURN
    new $P2879, "Integer"
    assign $P2879, 0
    setattribute $P2878, 'payload', $P2879
    throw $P2878
  if_2870_end:
.annotate 'line', 1259
    get_hll_global $P2880, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2881, "$/"
    unless_null $P2881, vivify_902
    $P2881 = root_new ['parrot';'Hash']
  vivify_902:
    set $P2882, $P2881["p6regex"]
    unless_null $P2882, vivify_903
    new $P2882, "Undef"
  vivify_903:
    $P2883 = $P2882."ast"()
    get_global $P2884, "@BLOCK"
    $P2885 = $P2884."shift"()
    $P2886 = $P2880($P2883, $P2885)
    store_lex "$regex", $P2886
.annotate 'line', 1261
    get_hll_global $P2887, ["PAST"], "Op"
.annotate 'line', 1263
    get_hll_global $P2888, ["PAST"], "Var"
    new $P2889, "ResizablePMCArray"
    push $P2889, "Regex"
    $P2890 = $P2888."new"("Regex" :named("name"), $P2889 :named("namespace"), "package" :named("scope"))
    find_lex $P2891, "$regex"
    $P2892 = $P2887."new"($P2890, $P2891, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1261
    store_lex "$past", $P2892
.annotate 'line', 1267
    find_lex $P2893, "$regex"
    find_lex $P2894, "$past"
    unless_null $P2894, vivify_904
    $P2894 = root_new ['parrot';'Hash']
    store_lex "$past", $P2894
  vivify_904:
    set $P2894["sink"], $P2893
.annotate 'line', 1268
    find_lex $P2895, "$/"
    find_lex $P2896, "$past"
    $P2897 = $P2895."!make"($P2896)
.annotate 'line', 1248
    .return ($P2897)
  control_2862:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2898, exception, "payload"
    .return ($P2898)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("152_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2900
    .param pmc param_2901
.annotate 'line', 1271
    .lex "self", param_2900
    .lex "$/", param_2901
    find_lex $P2902, "$/"
    find_lex $P2903, "$/"
    unless_null $P2903, vivify_905
    $P2903 = root_new ['parrot';'Hash']
  vivify_905:
    set $P2904, $P2903["variable"]
    unless_null $P2904, vivify_906
    new $P2904, "Undef"
  vivify_906:
    $P2905 = $P2904."ast"()
    $P2906 = $P2902."!make"($P2905)
    .return ($P2906)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("153_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2908
    .param pmc param_2909
.annotate 'line', 1272
    .lex "self", param_2908
    .lex "$/", param_2909
.annotate 'line', 1273
    find_lex $P2910, "$/"
    get_hll_global $P2911, ["PAST"], "Op"
.annotate 'line', 1274
    find_lex $P2912, "$/"
    unless_null $P2912, vivify_907
    $P2912 = root_new ['parrot';'Hash']
  vivify_907:
    set $P2913, $P2912["block"]
    unless_null $P2913, vivify_908
    new $P2913, "Undef"
  vivify_908:
    $P2914 = $P2913."ast"()
    $P2915 = "block_immediate"($P2914)
    find_lex $P2916, "$/"
    $P2917 = $P2911."new"($P2915, "set S*" :named("pirop"), $P2916 :named("node"))
.annotate 'line', 1273
    $P2918 = $P2910."!make"($P2917)
.annotate 'line', 1272
    .return ($P2918)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("154_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2920
    .param pmc param_2921
.annotate 'line', 1277
    .lex "self", param_2920
    .lex "$/", param_2921
    find_lex $P2922, "$/"
    $P2923 = $P2922."!make"("\e")
    .return ($P2923)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("155_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2925
    .param pmc param_2926
.annotate 'line', 1281
    .lex "self", param_2925
    .lex "$/", param_2926
    find_lex $P2927, "$/"
    find_lex $P2928, "$/"
    unless_null $P2928, vivify_909
    $P2928 = root_new ['parrot';'Hash']
  vivify_909:
    set $P2929, $P2928["dotty"]
    unless_null $P2929, vivify_910
    new $P2929, "Undef"
  vivify_910:
    $P2930 = $P2929."ast"()
    $P2931 = $P2927."!make"($P2930)
    .return ($P2931)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("156_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2933
    .param pmc param_2934
.annotate 'line', 1283
    .lex "self", param_2933
    .lex "$/", param_2934
.annotate 'line', 1284
    find_lex $P2935, "$/"
    get_hll_global $P2936, ["PAST"], "Op"
.annotate 'line', 1285
    new $P2937, "ResizablePMCArray"
    push $P2937, "    clone %r, %0"
    push $P2937, "    inc %0"
    $P2938 = $P2936."new"("postfix:<++>" :named("name"), $P2937 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1284
    $P2939 = $P2935."!make"($P2938)
.annotate 'line', 1283
    .return ($P2939)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("157_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2941
    .param pmc param_2942
.annotate 'line', 1289
    .lex "self", param_2941
    .lex "$/", param_2942
.annotate 'line', 1290
    find_lex $P2943, "$/"
    get_hll_global $P2944, ["PAST"], "Op"
.annotate 'line', 1291
    new $P2945, "ResizablePMCArray"
    push $P2945, "    clone %r, %0"
    push $P2945, "    dec %0"
    $P2946 = $P2944."new"("postfix:<-->" :named("name"), $P2945 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1290
    $P2947 = $P2943."!make"($P2946)
.annotate 'line', 1289
    .return ($P2947)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("158_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2949
    .param pmc param_2950
.annotate 'line', 1295
    .lex "self", param_2949
    .lex "$/", param_2950
.annotate 'line', 1296
    find_lex $P2951, "$/"
    get_hll_global $P2952, ["PAST"], "Op"
.annotate 'line', 1297
    get_hll_global $P2953, ["PAST"], "Var"
    $P2954 = $P2953."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2955, "$/"
    $P2956 = $P2952."new"($P2954, "callmethod" :named("pasttype"), "!make" :named("name"), $P2955 :named("node"))
.annotate 'line', 1296
    $P2957 = $P2951."!make"($P2956)
.annotate 'line', 1295
    .return ($P2957)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("159_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2960
    .param pmc param_2961
.annotate 'line', 1313
    .lex "self", param_2960
    .lex "$/", param_2961
    find_lex $P2962, "$/"
    $P2963 = "control"($P2962, "CONTROL_LOOP_NEXT")
    .return ($P2963)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("160_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2965
    .param pmc param_2966
.annotate 'line', 1314
    .lex "self", param_2965
    .lex "$/", param_2966
    find_lex $P2967, "$/"
    $P2968 = "control"($P2967, "CONTROL_LOOP_LAST")
    .return ($P2968)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("161_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2970
    .param pmc param_2971
.annotate 'line', 1315
    .lex "self", param_2970
    .lex "$/", param_2971
    find_lex $P2972, "$/"
    $P2973 = "control"($P2972, "CONTROL_LOOP_REDO")
    .return ($P2973)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("162_1300051186.829") :outer("11_1300051186.829")
    .param pmc param_2975
    .param pmc param_2976
.annotate 'line', 1317
    .lex "self", param_2975
    .lex "$/", param_2976
.annotate 'line', 1318
    find_lex $P2977, "$/"
    get_hll_global $P2978, ["PAST"], "Op"
    find_lex $P2979, "$/"
    $P2980 = $P2978."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2979 :named("node"))
    $P2981 = $P2977."!make"($P2980)
.annotate 'line', 1317
    .return ($P2981)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block2982"  :subid("163_1300051186.829") :outer("11_1300051186.829")
.annotate 'line', 1322
    .const 'Sub' $P3082 = "171_1300051186.829" 
    capture_lex $P3082
    .const 'Sub' $P3057 = "170_1300051186.829" 
    capture_lex $P3057
    .const 'Sub' $P3046 = "169_1300051186.829" 
    capture_lex $P3046
    .const 'Sub' $P3031 = "168_1300051186.829" 
    capture_lex $P3031
    .const 'Sub' $P3020 = "167_1300051186.829" 
    capture_lex $P3020
    .const 'Sub' $P3009 = "166_1300051186.829" 
    capture_lex $P3009
    .const 'Sub' $P2998 = "165_1300051186.829" 
    capture_lex $P2998
    .const 'Sub' $P2985 = "164_1300051186.829" 
    capture_lex $P2985
    get_global $P2984, "$?CLASS"
.annotate 'line', 1356
    .const 'Sub' $P3057 = "170_1300051186.829" 
    newclosure $P3080, $P3057
.annotate 'line', 1322
    .return ($P3080)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post911") :outer("163_1300051186.829")
.annotate 'line', 1322
    get_hll_global $P2983, ["NQP";"RegexActions"], "_block2982" 
    .local pmc block
    set block, $P2983
    .const 'Sub' $P3082 = "171_1300051186.829" 
    capture_lex $P3082
    $P3082()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3081"  :anon :subid("171_1300051186.829") :outer("163_1300051186.829")
.annotate 'line', 1322
    nqp_get_sc_object $P3083, "1300051176.112", 1
    .local pmc type_obj
    set type_obj, $P3083
    set_global "$?CLASS", type_obj
    get_how $P3084, type_obj
    .const 'Sub' $P3085 = "164_1300051186.829" 
    $P3084."add_method"(type_obj, "metachar:sym<:my>", $P3085)
    get_how $P3086, type_obj
    .const 'Sub' $P3087 = "165_1300051186.829" 
    $P3086."add_method"(type_obj, "metachar:sym<{ }>", $P3087)
    get_how $P3088, type_obj
    .const 'Sub' $P3089 = "166_1300051186.829" 
    $P3088."add_method"(type_obj, "metachar:sym<nqpvar>", $P3089)
    get_how $P3090, type_obj
    .const 'Sub' $P3091 = "167_1300051186.829" 
    $P3090."add_method"(type_obj, "assertion:sym<{ }>", $P3091)
    get_how $P3092, type_obj
    .const 'Sub' $P3093 = "168_1300051186.829" 
    $P3092."add_method"(type_obj, "assertion:sym<?{ }>", $P3093)
    get_how $P3094, type_obj
    .const 'Sub' $P3095 = "169_1300051186.829" 
    $P3094."add_method"(type_obj, "assertion:sym<var>", $P3095)
    get_how $P3096, type_obj
    .const 'Sub' $P3097 = "170_1300051186.829" 
    $P3096."add_method"(type_obj, "codeblock", $P3097)
    get_how $P3098, type_obj
    get_hll_global $P3099, ["Regex";"P6Regex"], "Actions"
    $P3098."add_parent"(type_obj, $P3099)
    get_how $P3100, type_obj
    $P3101 = $P3100."compose"(type_obj)
    .return ($P3101)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("164_1300051186.829") :outer("163_1300051186.829")
    .param pmc param_2986
    .param pmc param_2987
.annotate 'line', 1324
    .lex "self", param_2986
    .lex "$/", param_2987
.annotate 'line', 1325
    new $P2988, "Undef"
    .lex "$past", $P2988
    find_lex $P2989, "$/"
    unless_null $P2989, vivify_912
    $P2989 = root_new ['parrot';'Hash']
  vivify_912:
    set $P2990, $P2989["statement"]
    unless_null $P2990, vivify_913
    new $P2990, "Undef"
  vivify_913:
    $P2991 = $P2990."ast"()
    store_lex "$past", $P2991
.annotate 'line', 1326
    find_lex $P2992, "$/"
    get_hll_global $P2993, ["PAST"], "Regex"
    find_lex $P2994, "$past"
    find_lex $P2995, "$/"
    $P2996 = $P2993."new"($P2994, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2995 :named("node"))
    $P2997 = $P2992."!make"($P2996)
.annotate 'line', 1324
    .return ($P2997)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("165_1300051186.829") :outer("163_1300051186.829")
    .param pmc param_2999
    .param pmc param_3000
.annotate 'line', 1330
    .lex "self", param_2999
    .lex "$/", param_3000
.annotate 'line', 1331
    find_lex $P3001, "$/"
    get_hll_global $P3002, ["PAST"], "Regex"
    find_lex $P3003, "$/"
    unless_null $P3003, vivify_914
    $P3003 = root_new ['parrot';'Hash']
  vivify_914:
    set $P3004, $P3003["codeblock"]
    unless_null $P3004, vivify_915
    new $P3004, "Undef"
  vivify_915:
    $P3005 = $P3004."ast"()
    find_lex $P3006, "$/"
    $P3007 = $P3002."new"($P3005, "pastnode" :named("pasttype"), $P3006 :named("node"))
    $P3008 = $P3001."!make"($P3007)
.annotate 'line', 1330
    .return ($P3008)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("166_1300051186.829") :outer("163_1300051186.829")
    .param pmc param_3010
    .param pmc param_3011
.annotate 'line', 1335
    .lex "self", param_3010
    .lex "$/", param_3011
.annotate 'line', 1336
    find_lex $P3012, "$/"
    get_hll_global $P3013, ["PAST"], "Regex"
    find_lex $P3014, "$/"
    unless_null $P3014, vivify_916
    $P3014 = root_new ['parrot';'Hash']
  vivify_916:
    set $P3015, $P3014["var"]
    unless_null $P3015, vivify_917
    new $P3015, "Undef"
  vivify_917:
    $P3016 = $P3015."ast"()
    find_lex $P3017, "$/"
    $P3018 = $P3013."new"("!INTERPOLATE", $P3016, "subrule" :named("pasttype"), "method" :named("subtype"), $P3017 :named("node"))
    $P3019 = $P3012."!make"($P3018)
.annotate 'line', 1335
    .return ($P3019)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("167_1300051186.829") :outer("163_1300051186.829")
    .param pmc param_3021
    .param pmc param_3022
.annotate 'line', 1340
    .lex "self", param_3021
    .lex "$/", param_3022
.annotate 'line', 1341
    find_lex $P3023, "$/"
    get_hll_global $P3024, ["PAST"], "Regex"
    find_lex $P3025, "$/"
    unless_null $P3025, vivify_918
    $P3025 = root_new ['parrot';'Hash']
  vivify_918:
    set $P3026, $P3025["codeblock"]
    unless_null $P3026, vivify_919
    new $P3026, "Undef"
  vivify_919:
    $P3027 = $P3026."ast"()
    find_lex $P3028, "$/"
    $P3029 = $P3024."new"("!INTERPOLATE_REGEX", $P3027, "subrule" :named("pasttype"), "method" :named("subtype"), $P3028 :named("node"))
    $P3030 = $P3023."!make"($P3029)
.annotate 'line', 1340
    .return ($P3030)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("168_1300051186.829") :outer("163_1300051186.829")
    .param pmc param_3032
    .param pmc param_3033
.annotate 'line', 1345
    .lex "self", param_3032
    .lex "$/", param_3033
.annotate 'line', 1346
    find_lex $P3034, "$/"
    get_hll_global $P3035, ["PAST"], "Regex"
    find_lex $P3036, "$/"
    unless_null $P3036, vivify_920
    $P3036 = root_new ['parrot';'Hash']
  vivify_920:
    set $P3037, $P3036["codeblock"]
    unless_null $P3037, vivify_921
    new $P3037, "Undef"
  vivify_921:
    $P3038 = $P3037."ast"()
.annotate 'line', 1347
    find_lex $P3039, "$/"
    unless_null $P3039, vivify_922
    $P3039 = root_new ['parrot';'Hash']
  vivify_922:
    set $P3040, $P3039["zw"]
    unless_null $P3040, vivify_923
    new $P3040, "Undef"
  vivify_923:
    set $S3041, $P3040
    iseq $I3042, $S3041, "!"
    find_lex $P3043, "$/"
    $P3044 = $P3035."new"($P3038, "zerowidth" :named("subtype"), $I3042 :named("negate"), "pastnode" :named("pasttype"), $P3043 :named("node"))
.annotate 'line', 1346
    $P3045 = $P3034."!make"($P3044)
.annotate 'line', 1345
    .return ($P3045)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("169_1300051186.829") :outer("163_1300051186.829")
    .param pmc param_3047
    .param pmc param_3048
.annotate 'line', 1351
    .lex "self", param_3047
    .lex "$/", param_3048
.annotate 'line', 1352
    find_lex $P3049, "$/"
    get_hll_global $P3050, ["PAST"], "Regex"
    find_lex $P3051, "$/"
    unless_null $P3051, vivify_924
    $P3051 = root_new ['parrot';'Hash']
  vivify_924:
    set $P3052, $P3051["var"]
    unless_null $P3052, vivify_925
    new $P3052, "Undef"
  vivify_925:
    $P3053 = $P3052."ast"()
    find_lex $P3054, "$/"
    $P3055 = $P3050."new"("!INTERPOLATE_REGEX", $P3053, "subrule" :named("pasttype"), "method" :named("subtype"), $P3054 :named("node"))
    $P3056 = $P3049."!make"($P3055)
.annotate 'line', 1351
    .return ($P3056)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("170_1300051186.829") :outer("163_1300051186.829")
    .param pmc param_3058
    .param pmc param_3059
.annotate 'line', 1356
    .lex "self", param_3058
    .lex "$/", param_3059
.annotate 'line', 1357
    new $P3060, "Undef"
    .lex "$block", $P3060
.annotate 'line', 1359
    new $P3061, "Undef"
    .lex "$past", $P3061
.annotate 'line', 1357
    find_lex $P3062, "$/"
    unless_null $P3062, vivify_926
    $P3062 = root_new ['parrot';'Hash']
  vivify_926:
    set $P3063, $P3062["block"]
    unless_null $P3063, vivify_927
    new $P3063, "Undef"
  vivify_927:
    $P3064 = $P3063."ast"()
    store_lex "$block", $P3064
.annotate 'line', 1358
    find_lex $P3065, "$block"
    $P3065."blocktype"("immediate")
.annotate 'line', 1360
    get_hll_global $P3066, ["PAST"], "Stmts"
.annotate 'line', 1361
    get_hll_global $P3067, ["PAST"], "Op"
.annotate 'line', 1362
    get_hll_global $P3068, ["PAST"], "Var"
    $P3069 = $P3068."new"("$/" :named("name"))
.annotate 'line', 1363
    get_hll_global $P3070, ["PAST"], "Op"
.annotate 'line', 1364
    get_hll_global $P3071, ["PAST"], "Var"
    $P3072 = $P3071."new"(unicode:"$\x{a2}" :named("name"))
    $P3073 = $P3070."new"($P3072, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1363
    $P3074 = $P3067."new"($P3069, $P3073, "bind" :named("pasttype"))
.annotate 'line', 1361
    find_lex $P3075, "$block"
    $P3076 = $P3066."new"($P3074, $P3075)
.annotate 'line', 1360
    store_lex "$past", $P3076
.annotate 'line', 1372
    find_lex $P3077, "$/"
    find_lex $P3078, "$past"
    $P3079 = $P3077."!make"($P3078)
.annotate 'line', 1356
    .return ($P3079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3103" :load :anon :subid("172_1300051186.829")
.annotate 'line', 3
    .const 'Sub' $P3105 = "11_1300051186.829" 
    $P3106 = $P3105()
    .return ($P3106)
.end


.HLL "nqp"

.namespace []
.sub "_block3343" :load :anon :subid("174_1300051186.829")
.annotate 'line', 1
    .const 'Sub' $P3345 = "10_1300051186.829" 
    $P3346 = $P3345()
    .return ($P3346)
.end

### .include 'gen/nqp-compiler.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300051189.281")
.annotate 'line', 0
    get_hll_global $P17, ["NQP";"Compiler"], "_block16" 
    capture_lex $P17
.annotate 'line', 1
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P17, ["NQP";"Compiler"], "_block16" 
    capture_lex $P17
    $P26 = $P17()
    .return ($P26)
    .const 'Sub' $P28 = "13_1300051189.281" 
    .return ($P28)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post14") :outer("10_1300051189.281")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300051189.281" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P32, "1300051189.269"
    isnull $I33, $P32
    if $I33, if_31
    nqp_get_sc_object $P40, "1300051189.269", 0
    set_hll_global ["NQP"], "Compiler", $P40
    goto if_31_end
  if_31:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P34, "1300051189.269"
    .local pmc cur_sc
    set cur_sc, $P34
    load_bytecode "SettingManager.pbc"
    get_hll_global $P35, ["HLL"], "SettingManager"
    $P36 = $P35."load_setting"("NQPCORE")
    block."set_outer_ctx"($P36)
    get_hll_global $P37, "NQPClassHOW"
    $P38 = $P37."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P38, cur_sc
    nqp_set_sc_object "1300051189.269", 0, $P38
    nqp_get_sc_object $P39, "1300051189.269", 0
    set_hll_global ["NQP"], "Compiler", $P39
  if_31_end:
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block16"  :subid("11_1300051189.281") :outer("10_1300051189.281")
.annotate 'line', 1
    .const 'Sub' $P20 = "12_1300051189.281" 
    capture_lex $P20
    get_global $P18, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post15") :outer("11_1300051189.281")
.annotate 'line', 1
    get_hll_global $P17, ["NQP";"Compiler"], "_block16" 
    .local pmc block
    set block, $P17
    .const 'Sub' $P20 = "12_1300051189.281" 
    capture_lex $P20
    $P20()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block19"  :anon :subid("12_1300051189.281") :outer("11_1300051189.281")
.annotate 'line', 1
    nqp_get_sc_object $P21, "1300051189.269", 0
    .local pmc type_obj
    set type_obj, $P21
    set_global "$?CLASS", type_obj
    get_how $P22, type_obj
    get_hll_global $P23, ["HLL"], "Compiler"
    $P22."add_parent"(type_obj, $P23)
    get_how $P24, type_obj
    $P25 = $P24."compose"(type_obj)
    .return ($P25)
.end


.HLL "nqp"

.namespace []
.sub "_block27" :load :anon :subid("13_1300051189.281")
.annotate 'line', 1
    .const 'Sub' $P29 = "10_1300051189.281" 
    $P30 = $P29()
    .return ($P30)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('nqp')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
    push $P0, 'setting=s'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'nqp'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
