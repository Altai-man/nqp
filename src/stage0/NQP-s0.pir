# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

.HLL 'nqp'

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup

    .local pmc interp, lexpad, nqplexpad
    interp = getinterp
    lexpad = get_class 'LexPad'
    nqplexpad = get_class 'NQPLexPad'
    interp.'hll_map'(lexpad, nqplexpad)
.end
### .include 'gen/nqp-how.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299465710.053")
.annotate 'line', 0
    get_hll_global $P2799, ["str"], "_block2798" 
    capture_lex $P2799
    get_hll_global $P2790, ["num"], "_block2789" 
    capture_lex $P2790
    get_hll_global $P2781, ["int"], "_block2780" 
    capture_lex $P2781
    get_hll_global $P2627, ["NQPMu"], "_block2626" 
    capture_lex $P2627
    get_hll_global $P2538, ["NQPModuleHOW"], "_block2537" 
    capture_lex $P2538
    get_hll_global $P2308, ["RoleToRoleApplier"], "_block2307" 
    capture_lex $P2308
    get_hll_global $P2092, ["RoleToClassApplier"], "_block2091" 
    capture_lex $P2092
    get_hll_global $P1736, ["NQPParametricRoleHOW"], "_block1735" 
    capture_lex $P1736
    get_hll_global $P1414, ["NQPConcreteRoleHOW"], "_block1413" 
    capture_lex $P1414
    get_hll_global $P1202, ["NQPAttribute"], "_block1201" 
    capture_lex $P1202
    get_hll_global $P1114, ["NQPNativeHOW"], "_block1113" 
    capture_lex $P1114
    get_hll_global $P56, ["NQPClassHOW"], "_block55" 
    capture_lex $P56
    get_hll_global $P30, ["KnowHOWAttribute"], "_block29" 
    capture_lex $P30
.annotate 'line', 1
    nqp_dynop_setup 
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    get_hll_global $P16, "str"
    get_hll_global $P17, "num"
    get_hll_global $P18, "int"
    get_hll_global $P19, "NQPMu"
    get_hll_global $P20, "NQPModuleHOW"
    get_hll_global $P21, "RoleToRoleApplier"
    get_hll_global $P22, "RoleToClassApplier"
    get_hll_global $P23, "NQPParametricRoleHOW"
    get_hll_global $P24, "NQPConcreteRoleHOW"
    get_hll_global $P25, "NQPAttribute"
    get_hll_global $P26, "NQPNativeHOW"
    get_hll_global $P27, "NQPClassHOW"
    get_hll_global $P28, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P30, ["KnowHOWAttribute"], "_block29" 
    capture_lex $P30
    $P30()
.annotate 'line', 26
    get_hll_global $P56, ["NQPClassHOW"], "_block55" 
    capture_lex $P56
    $P56()
.annotate 'line', 454
    get_hll_global $P1114, ["NQPNativeHOW"], "_block1113" 
    capture_lex $P1114
    $P1114()
.annotate 'line', 498
    get_hll_global $P1202, ["NQPAttribute"], "_block1201" 
    capture_lex $P1202
    $P1202()
.annotate 'line', 571
    get_hll_global $P1414, ["NQPConcreteRoleHOW"], "_block1413" 
    capture_lex $P1414
    $P1414()
.annotate 'line', 720
    get_hll_global $P1736, ["NQPParametricRoleHOW"], "_block1735" 
    capture_lex $P1736
    $P1736()
.annotate 'line', 886
    get_hll_global $P2092, ["RoleToClassApplier"], "_block2091" 
    capture_lex $P2092
    $P2092()
.annotate 'line', 958
    get_hll_global $P2308, ["RoleToRoleApplier"], "_block2307" 
    capture_lex $P2308
    $P2308()
.annotate 'line', 1048
    get_hll_global $P2538, ["NQPModuleHOW"], "_block2537" 
    capture_lex $P2538
    $P2538()
.annotate 'line', 1093
    get_hll_global $P2627, ["NQPMu"], "_block2626" 
    capture_lex $P2627
    $P2627()
.annotate 'line', 1142
    get_hll_global $P2781, ["int"], "_block2780" 
    capture_lex $P2781
    $P2781()
.annotate 'line', 1144
    get_hll_global $P2790, ["num"], "_block2789" 
    capture_lex $P2790
    $P2790()
.annotate 'line', 1146
    get_hll_global $P2799, ["str"], "_block2798" 
    capture_lex $P2799
    $P2807 = $P2799()
.annotate 'line', 1
    .return ($P2807)
    .const 'Sub' $P2809 = "194_1299465710.053" 
    .return ($P2809)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "_block29"  :subid("11_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 10
    .const 'Sub' $P46 = "14_1299465710.053" 
    capture_lex $P46
    .const 'Sub' $P40 = "13_1299465710.053" 
    capture_lex $P40
    .const 'Sub' $P32 = "12_1299465710.053" 
    capture_lex $P32
    get_global $P31, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P40 = "13_1299465710.053" 
    newclosure $P44, $P40
.annotate 'line', 10
    .return ($P44)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post195") :outer("11_1299465710.053")
.annotate 'line', 10
    get_hll_global $P30, ["KnowHOWAttribute"], "_block29" 
    .local pmc block
    set block, $P30
    .const 'Sub' $P46 = "14_1299465710.053" 
    capture_lex $P46
    $P46()
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "_block45"  :anon :subid("14_1299465710.053") :outer("11_1299465710.053")
.annotate 'line', 10
    get_hll_global $P47, "KnowHOW"
    $P48 = $P47."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P48
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P49, type_obj
    .const 'Sub' $P50 = "12_1299465710.053" 
    $P49."add_method"(type_obj, "new", $P50)
    get_how $P51, type_obj
    .const 'Sub' $P52 = "13_1299465710.053" 
    $P51."add_method"(type_obj, "name", $P52)
    get_how $P53, type_obj
    $P54 = $P53."compose"(type_obj)
    .return ($P54)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1299465710.053") :outer("11_1299465710.053")
    .param pmc param_33
    .param pmc param_34 :optional :named("name")
    .param int has_param_34 :opt_flag
.annotate 'line', 11
    .lex "self", param_33
    if has_param_34, optparam_196
    new $P35, "Undef"
    set param_34, $P35
  optparam_196:
    .lex "$name", param_34
.annotate 'line', 12
    find_lex $P36, "$name"
    set $S37, $P36
    get_hll_global $P38, "KnowHOWAttribute"
    repr_box_str $P39, $S37, $P38
.annotate 'line', 11
    .return ($P39)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1299465710.053") :outer("11_1299465710.053")
    .param pmc param_41
.annotate 'line', 14
    .lex "self", param_41
.annotate 'line', 15
    find_lex $P42, "self"
    repr_unbox_str $S43, $P42
.annotate 'line', 14
    .return ($S43)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block55"  :subid("15_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 26
    .const 'Sub' $P1022 = "70_1299465710.053" 
    capture_lex $P1022
    .const 'Sub' $P985 = "68_1299465710.053" 
    capture_lex $P985
    .const 'Sub' $P949 = "66_1299465710.053" 
    capture_lex $P949
    .const 'Sub' $P915 = "65_1299465710.053" 
    capture_lex $P915
    .const 'Sub' $P878 = "64_1299465710.053" 
    capture_lex $P878
    .const 'Sub' $P871 = "63_1299465710.053" 
    capture_lex $P871
    .const 'Sub' $P848 = "61_1299465710.053" 
    capture_lex $P848
    .const 'Sub' $P842 = "60_1299465710.053" 
    capture_lex $P842
    .const 'Sub' $P836 = "59_1299465710.053" 
    capture_lex $P836
    .const 'Sub' $P813 = "57_1299465710.053" 
    capture_lex $P813
    .const 'Sub' $P806 = "56_1299465710.053" 
    capture_lex $P806
    .const 'Sub' $P792 = "55_1299465710.053" 
    capture_lex $P792
    .const 'Sub' $P743 = "52_1299465710.053" 
    capture_lex $P743
    .const 'Sub' $P698 = "49_1299465710.053" 
    capture_lex $P698
    .const 'Sub' $P661 = "46_1299465710.053" 
    capture_lex $P661
    .const 'Sub' $P531 = "41_1299465710.053" 
    capture_lex $P531
    .const 'Sub' $P427 = "37_1299465710.053" 
    capture_lex $P427
    .const 'Sub' $P401 = "36_1299465710.053" 
    capture_lex $P401
    .const 'Sub' $P367 = "34_1299465710.053" 
    capture_lex $P367
    .const 'Sub' $P329 = "32_1299465710.053" 
    capture_lex $P329
    .const 'Sub' $P308 = "31_1299465710.053" 
    capture_lex $P308
    .const 'Sub' $P287 = "30_1299465710.053" 
    capture_lex $P287
    .const 'Sub' $P268 = "29_1299465710.053" 
    capture_lex $P268
    .const 'Sub' $P254 = "28_1299465710.053" 
    capture_lex $P254
    .const 'Sub' $P247 = "27_1299465710.053" 
    capture_lex $P247
    .const 'Sub' $P237 = "26_1299465710.053" 
    capture_lex $P237
    .const 'Sub' $P100 = "19_1299465710.053" 
    capture_lex $P100
    .const 'Sub' $P58 = "16_1299465710.053" 
    capture_lex $P58
    get_global $P57, "$?CLASS"
.annotate 'line', 235
    .const 'Sub' $P58 = "16_1299465710.053" 
    newclosure $P99, $P58
    .lex "compute_c3_mro", $P99
.annotate 'line', 257
    .const 'Sub' $P100 = "19_1299465710.053" 
    newclosure $P236, $P100
    .lex "c3_merge", $P236
.annotate 'line', 181
    find_lex $P659, "compute_c3_mro"
    find_lex $P660, "c3_merge"
.annotate 'line', 441
    .const 'Sub' $P985 = "68_1299465710.053" 
    newclosure $P1020, $P985
.annotate 'line', 26
    .return ($P1020)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post197") :outer("15_1299465710.053")
.annotate 'line', 26
    get_hll_global $P56, ["NQPClassHOW"], "_block55" 
    .local pmc block
    set block, $P56
    .const 'Sub' $P1022 = "70_1299465710.053" 
    capture_lex $P1022
    $P1022()
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block1021"  :anon :subid("70_1299465710.053") :outer("15_1299465710.053")
.annotate 'line', 26
    get_hll_global $P1023, "KnowHOW"
    $P1024 = $P1023."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1024
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1025, type_obj
    get_hll_global $P1026, "KnowHOWAttribute"
    $P1027 = $P1026."new"("$!name" :named("name"))
    $P1025."add_attribute"(type_obj, $P1027)
    get_how $P1028, type_obj
    get_hll_global $P1029, "KnowHOWAttribute"
    $P1030 = $P1029."new"("%!attributes" :named("name"))
    $P1028."add_attribute"(type_obj, $P1030)
    get_how $P1031, type_obj
    get_hll_global $P1032, "KnowHOWAttribute"
    $P1033 = $P1032."new"("%!methods" :named("name"))
    $P1031."add_attribute"(type_obj, $P1033)
    get_how $P1034, type_obj
    get_hll_global $P1035, "KnowHOWAttribute"
    $P1036 = $P1035."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1034."add_attribute"(type_obj, $P1036)
    get_how $P1037, type_obj
    get_hll_global $P1038, "KnowHOWAttribute"
    $P1039 = $P1038."new"("@!parents" :named("name"))
    $P1037."add_attribute"(type_obj, $P1039)
    get_how $P1040, type_obj
    get_hll_global $P1041, "KnowHOWAttribute"
    $P1042 = $P1041."new"("@!roles" :named("name"))
    $P1040."add_attribute"(type_obj, $P1042)
    get_how $P1043, type_obj
    get_hll_global $P1044, "KnowHOWAttribute"
    $P1045 = $P1044."new"("@!vtable" :named("name"))
    $P1043."add_attribute"(type_obj, $P1045)
    get_how $P1046, type_obj
    get_hll_global $P1047, "KnowHOWAttribute"
    $P1048 = $P1047."new"("%!method-vtable-slots" :named("name"))
    $P1046."add_attribute"(type_obj, $P1048)
    get_how $P1049, type_obj
    get_hll_global $P1050, "KnowHOWAttribute"
    $P1051 = $P1050."new"("$!composed" :named("name"))
    $P1049."add_attribute"(type_obj, $P1051)
    get_how $P1052, type_obj
    get_hll_global $P1053, "KnowHOWAttribute"
    $P1054 = $P1053."new"("@!mro" :named("name"))
    $P1052."add_attribute"(type_obj, $P1054)
    get_how $P1055, type_obj
    get_hll_global $P1056, "KnowHOWAttribute"
    $P1057 = $P1056."new"("@!done" :named("name"))
    $P1055."add_attribute"(type_obj, $P1057)
    get_how $P1058, type_obj
    get_hll_global $P1059, "KnowHOWAttribute"
    $P1060 = $P1059."new"("%!parrot_vtable_mapping" :named("name"))
    $P1058."add_attribute"(type_obj, $P1060)
    get_how $P1061, type_obj
    .const 'Sub' $P1062 = "26_1299465710.053" 
    $P1061."add_method"(type_obj, "new", $P1062)
    get_how $P1063, type_obj
    .const 'Sub' $P1064 = "27_1299465710.053" 
    $P1063."add_method"(type_obj, "BUILD", $P1064)
    get_how $P1065, type_obj
    .const 'Sub' $P1066 = "28_1299465710.053" 
    $P1065."add_method"(type_obj, "new_type", $P1066)
    get_how $P1067, type_obj
    .const 'Sub' $P1068 = "29_1299465710.053" 
    $P1067."add_method"(type_obj, "add_method", $P1068)
    get_how $P1069, type_obj
    .const 'Sub' $P1070 = "30_1299465710.053" 
    $P1069."add_method"(type_obj, "add_multi_method", $P1070)
    get_how $P1071, type_obj
    .const 'Sub' $P1072 = "31_1299465710.053" 
    $P1071."add_method"(type_obj, "add_attribute", $P1072)
    get_how $P1073, type_obj
    .const 'Sub' $P1074 = "32_1299465710.053" 
    $P1073."add_method"(type_obj, "add_parent", $P1074)
    get_how $P1075, type_obj
    .const 'Sub' $P1076 = "34_1299465710.053" 
    $P1075."add_method"(type_obj, "add_role", $P1076)
    get_how $P1077, type_obj
    .const 'Sub' $P1078 = "36_1299465710.053" 
    $P1077."add_method"(type_obj, "add_parrot_vtable_mapping", $P1078)
    get_how $P1079, type_obj
    .const 'Sub' $P1080 = "37_1299465710.053" 
    $P1079."add_method"(type_obj, "compose", $P1080)
    get_how $P1081, type_obj
    .const 'Sub' $P1082 = "41_1299465710.053" 
    $P1081."add_method"(type_obj, "incorporate_multi_candidates", $P1082)
    get_how $P1083, type_obj
    .const 'Sub' $P1084 = "46_1299465710.053" 
    $P1083."add_method"(type_obj, "publish_type_cache", $P1084)
    get_how $P1085, type_obj
    .const 'Sub' $P1086 = "49_1299465710.053" 
    $P1085."add_method"(type_obj, "publish_method_cache", $P1086)
    get_how $P1087, type_obj
    .const 'Sub' $P1088 = "52_1299465710.053" 
    $P1087."add_method"(type_obj, "publish_parrot_vtable_mapping", $P1088)
    get_how $P1089, type_obj
    .const 'Sub' $P1090 = "55_1299465710.053" 
    $P1089."add_method"(type_obj, "parents", $P1090)
    get_how $P1091, type_obj
    .const 'Sub' $P1092 = "56_1299465710.053" 
    $P1091."add_method"(type_obj, "roles", $P1092)
    get_how $P1093, type_obj
    .const 'Sub' $P1094 = "57_1299465710.053" 
    $P1093."add_method"(type_obj, "methods", $P1094)
    get_how $P1095, type_obj
    .const 'Sub' $P1096 = "59_1299465710.053" 
    $P1095."add_method"(type_obj, "method_table", $P1096)
    get_how $P1097, type_obj
    .const 'Sub' $P1098 = "60_1299465710.053" 
    $P1097."add_method"(type_obj, "name", $P1098)
    get_how $P1099, type_obj
    .const 'Sub' $P1100 = "61_1299465710.053" 
    $P1099."add_method"(type_obj, "attributes", $P1100)
    get_how $P1101, type_obj
    .const 'Sub' $P1102 = "63_1299465710.053" 
    $P1101."add_method"(type_obj, "parrot_vtable_mappings", $P1102)
    get_how $P1103, type_obj
    .const 'Sub' $P1104 = "64_1299465710.053" 
    $P1103."add_method"(type_obj, "isa", $P1104)
    get_how $P1105, type_obj
    .const 'Sub' $P1106 = "65_1299465710.053" 
    $P1105."add_method"(type_obj, "does", $P1106)
    get_how $P1107, type_obj
    .const 'Sub' $P1108 = "66_1299465710.053" 
    $P1107."add_method"(type_obj, "can", $P1108)
    get_how $P1109, type_obj
    .const 'Sub' $P1110 = "68_1299465710.053" 
    $P1109."add_method"(type_obj, "find_method", $P1110)
    get_how $P1111, type_obj
    $P1112 = $P1111."compose"(type_obj)
    .return ($P1112)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_61
.annotate 'line', 235
    .const 'Sub' $P73 = "17_1299465710.053" 
    capture_lex $P73
    new $P60, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P60, control_59
    push_eh $P60
    .lex "$class", param_61
.annotate 'line', 236
    $P62 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P62
.annotate 'line', 239
    $P63 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P63
.annotate 'line', 236
    find_lex $P64, "$class"
    get_how $P65, $P64
    find_lex $P66, "$class"
    $P67 = $P65."parents"($P66, 1 :named("local"))
    store_lex "@immediate_parents", $P67
    find_lex $P68, "@result"
.annotate 'line', 240
    find_lex $P70, "@immediate_parents"
    set $N71, $P70
    unless $N71, if_69_end
    .const 'Sub' $P73 = "17_1299465710.053" 
    capture_lex $P73
    $P73()
  if_69_end:
.annotate 'line', 252
    find_lex $P94, "@result"
    find_lex $P95, "$class"
    $P94."unshift"($P95)
.annotate 'line', 253
    new $P96, "Exception"
    set $P96['type'], .CONTROL_RETURN
    find_lex $P97, "@result"
    setattribute $P96, 'payload', $P97
    throw $P96
.annotate 'line', 235
    .return ()
  control_59:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P98, exception, "payload"
    .return ($P98)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block72"  :anon :subid("17_1299465710.053") :outer("16_1299465710.053")
.annotate 'line', 240
    .const 'Sub' $P81 = "18_1299465710.053" 
    capture_lex $P81
.annotate 'line', 243
    $P74 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P74
.annotate 'line', 240
    find_lex $P75, "@merge_list"
.annotate 'line', 244
    find_lex $P77, "@immediate_parents"
    defined $I78, $P77
    unless $I78, for_undef_198
    iter $P76, $P77
    new $P88, 'ExceptionHandler'
    set_label $P88, loop87_handler
    $P88."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P88
  loop87_test:
    unless $P76, loop87_done
    shift $P79, $P76
  loop87_redo:
    .const 'Sub' $P81 = "18_1299465710.053" 
    capture_lex $P81
    $P81($P79)
  loop87_next:
    goto loop87_test
  loop87_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P89, exception, 'type'
    eq $P89, .CONTROL_LOOP_NEXT, loop87_next
    eq $P89, .CONTROL_LOOP_REDO, loop87_redo
  loop87_done:
    pop_eh 
  for_undef_198:
.annotate 'line', 247
    find_lex $P90, "@merge_list"
    find_lex $P91, "@immediate_parents"
    $P90."push"($P91)
.annotate 'line', 248
    find_lex $P92, "@merge_list"
    $P93 = "c3_merge"($P92)
    store_lex "@result", $P93
.annotate 'line', 240
    .return ($P93)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block80"  :anon :subid("18_1299465710.053") :outer("17_1299465710.053")
    .param pmc param_82
.annotate 'line', 244
    .lex "$_", param_82
.annotate 'line', 245
    find_lex $P83, "@merge_list"
    find_lex $P84, "$_"
    $P85 = "compute_c3_mro"($P84)
    $P86 = $P83."push"($P85)
.annotate 'line', 244
    .return ($P86)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_103
.annotate 'line', 257
    .const 'Sub' $P196 = "24_1299465710.053" 
    capture_lex $P196
    .const 'Sub' $P118 = "20_1299465710.053" 
    capture_lex $P118
    new $P102, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P102, control_101
    push_eh $P102
    .lex "@merge_list", param_103
.annotate 'line', 258
    $P104 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P104
.annotate 'line', 259
    new $P105, "Undef"
    .lex "$accepted", $P105
.annotate 'line', 260
    new $P106, "Undef"
    .lex "$something_accepted", $P106
.annotate 'line', 261
    new $P107, "Undef"
    .lex "$cand_count", $P107
.annotate 'line', 304
    new $P108, "Undef"
    .lex "$i", $P108
.annotate 'line', 257
    find_lex $P109, "@result"
    find_lex $P110, "$accepted"
.annotate 'line', 260
    new $P111, "Integer"
    assign $P111, 0
    store_lex "$something_accepted", $P111
.annotate 'line', 261
    new $P112, "Integer"
    assign $P112, 0
    store_lex "$cand_count", $P112
.annotate 'line', 264
    find_lex $P114, "@merge_list"
    defined $I115, $P114
    unless $I115, for_undef_199
    iter $P113, $P114
    new $P179, 'ExceptionHandler'
    set_label $P179, loop178_handler
    $P179."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P179
  loop178_test:
    unless $P113, loop178_done
    shift $P116, $P113
  loop178_redo:
    .const 'Sub' $P118 = "20_1299465710.053" 
    capture_lex $P118
    $P118($P116)
  loop178_next:
    goto loop178_test
  loop178_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P180, exception, 'type'
    eq $P180, .CONTROL_LOOP_NEXT, loop178_next
    eq $P180, .CONTROL_LOOP_REDO, loop178_redo
  loop178_done:
    pop_eh 
  for_undef_199:
.annotate 'line', 294
    find_lex $P182, "$cand_count"
    set $N183, $P182
    iseq $I184, $N183, 0.0
    unless $I184, if_181_end
.annotate 'line', 295
    new $P185, "Exception"
    set $P185['type'], .CONTROL_RETURN
    find_lex $P186, "@result"
    setattribute $P185, 'payload', $P186
    throw $P185
  if_181_end:
.annotate 'line', 299
    find_lex $P188, "$something_accepted"
    if $P188, unless_187_end
.annotate 'line', 300
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_187_end:
.annotate 'line', 304
    new $P189, "Integer"
    assign $P189, 0
    store_lex "$i", $P189
.annotate 'line', 305
    new $P227, 'ExceptionHandler'
    set_label $P227, loop226_handler
    $P227."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P227
  loop226_test:
    find_lex $P190, "$i"
    set $N191, $P190
    find_lex $P192, "@merge_list"
    set $N193, $P192
    islt $I194, $N191, $N193
    unless $I194, loop226_done
  loop226_redo:
    .const 'Sub' $P196 = "24_1299465710.053" 
    capture_lex $P196
    $P196()
  loop226_next:
    goto loop226_test
  loop226_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P228, exception, 'type'
    eq $P228, .CONTROL_LOOP_NEXT, loop226_next
    eq $P228, .CONTROL_LOOP_REDO, loop226_redo
  loop226_done:
    pop_eh 
.annotate 'line', 318
    find_lex $P229, "@merge_list"
    $P230 = "c3_merge"($P229)
    store_lex "@result", $P230
.annotate 'line', 319
    find_lex $P231, "@result"
    find_lex $P232, "$accepted"
    $P231."unshift"($P232)
.annotate 'line', 320
    new $P233, "Exception"
    set $P233['type'], .CONTROL_RETURN
    find_lex $P234, "@result"
    setattribute $P233, 'payload', $P234
    throw $P233
.annotate 'line', 257
    .return ()
  control_101:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P235, exception, "payload"
    .return ($P235)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block117"  :anon :subid("20_1299465710.053") :outer("19_1299465710.053")
    .param pmc param_120
.annotate 'line', 264
    .const 'Sub' $P127 = "21_1299465710.053" 
    capture_lex $P127
.annotate 'line', 265
    $P119 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P119
    .lex "$_", param_120
    find_lex $P121, "$_"
    store_lex "@cand_list", $P121
.annotate 'line', 266
    find_lex $P124, "@cand_list"
    set $N125, $P124
    if $N125, if_123
    new $P122, 'Float'
    set $P122, $N125
    goto if_123_end
  if_123:
    .const 'Sub' $P127 = "21_1299465710.053" 
    capture_lex $P127
    $P177 = $P127()
    set $P122, $P177
  if_123_end:
.annotate 'line', 264
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block126"  :anon :subid("21_1299465710.053") :outer("20_1299465710.053")
.annotate 'line', 266
    .const 'Sub' $P140 = "22_1299465710.053" 
    capture_lex $P140
.annotate 'line', 267
    new $P128, "Undef"
    .lex "$rejected", $P128
.annotate 'line', 268
    new $P129, "Undef"
    .lex "$cand_class", $P129
.annotate 'line', 267
    new $P130, "Integer"
    assign $P130, 0
    store_lex "$rejected", $P130
.annotate 'line', 268
    find_lex $P131, "@cand_list"
    unless_null $P131, vivify_200
    $P131 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P132, $P131[0]
    unless_null $P132, vivify_201
    new $P132, "Undef"
  vivify_201:
    store_lex "$cand_class", $P132
.annotate 'line', 269
    find_lex $P133, "$cand_count"
    add $P134, $P133, 1
    store_lex "$cand_count", $P134
.annotate 'line', 270
    find_lex $P136, "@merge_list"
    defined $I137, $P136
    unless $I137, for_undef_202
    iter $P135, $P136
    new $P175, 'ExceptionHandler'
    set_label $P175, loop174_handler
    $P175."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P175
  loop174_test:
    unless $P135, loop174_done
    shift $P138, $P135
  loop174_redo:
    .const 'Sub' $P140 = "22_1299465710.053" 
    capture_lex $P140
    $P140($P138)
  loop174_next:
    goto loop174_test
  loop174_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P176, exception, 'type'
    eq $P176, .CONTROL_LOOP_NEXT, loop174_next
    eq $P176, .CONTROL_LOOP_REDO, loop174_redo
  loop174_done:
    pop_eh 
  for_undef_202:
.annotate 'line', 266
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block139"  :anon :subid("22_1299465710.053") :outer("21_1299465710.053")
    .param pmc param_141
.annotate 'line', 270
    .const 'Sub' $P147 = "23_1299465710.053" 
    capture_lex $P147
    .lex "$_", param_141
.annotate 'line', 272
    find_lex $P143, "$_"
    find_lex $P144, "@cand_list"
    issame $I145, $P143, $P144
    if $I145, unless_142_end
    .const 'Sub' $P147 = "23_1299465710.053" 
    capture_lex $P147
    $P147()
  unless_142_end:
.annotate 'line', 284
    find_lex $P170, "$rejected"
    unless $P170, unless_169
    set $P168, $P170
    goto unless_169_end
  unless_169:
.annotate 'line', 285
    find_lex $P171, "$cand_class"
    store_lex "$accepted", $P171
.annotate 'line', 286
    new $P172, "Integer"
    assign $P172, 1
    store_lex "$something_accepted", $P172
.annotate 'line', 287
    set $I173, .CONTROL_LOOP_LAST
    die 0, $I173
  unless_169_end:
.annotate 'line', 270
    .return ($P168)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block146"  :anon :subid("23_1299465710.053") :outer("22_1299465710.053")
.annotate 'line', 274
    new $P148, "Undef"
    .lex "$cur_pos", $P148
    new $P149, "Integer"
    assign $P149, 1
    store_lex "$cur_pos", $P149
.annotate 'line', 275
    new $P166, 'ExceptionHandler'
    set_label $P166, loop165_handler
    $P166."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P166
  loop165_test:
    find_lex $P150, "$cur_pos"
    set $N151, $P150
    find_lex $P152, "$_"
    set $N153, $P152
    isle $I154, $N151, $N153
    unless $I154, loop165_done
  loop165_redo:
.annotate 'line', 276
    find_lex $P156, "$cur_pos"
    set $I157, $P156
    find_lex $P158, "$_"
    unless_null $P158, vivify_203
    $P158 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P159, $P158[$I157]
    unless_null $P159, vivify_204
    new $P159, "Undef"
  vivify_204:
    find_lex $P160, "$cand_class"
    issame $I161, $P159, $P160
    unless $I161, if_155_end
.annotate 'line', 277
    new $P162, "Integer"
    assign $P162, 1
    store_lex "$rejected", $P162
  if_155_end:
.annotate 'line', 279
    find_lex $P163, "$cur_pos"
    add $P164, $P163, 1
    store_lex "$cur_pos", $P164
  loop165_next:
.annotate 'line', 275
    goto loop165_test
  loop165_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P167, exception, 'type'
    eq $P167, .CONTROL_LOOP_NEXT, loop165_next
    eq $P167, .CONTROL_LOOP_REDO, loop165_redo
  loop165_done:
    pop_eh 
.annotate 'line', 272
    .return ($I154)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block195"  :anon :subid("24_1299465710.053") :outer("19_1299465710.053")
.annotate 'line', 305
    .const 'Sub' $P207 = "25_1299465710.053" 
    capture_lex $P207
.annotate 'line', 306
    $P197 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P197
.annotate 'line', 305
    find_lex $P198, "@new_list"
.annotate 'line', 307
    find_lex $P200, "$i"
    set $I201, $P200
    find_lex $P202, "@merge_list"
    unless_null $P202, vivify_205
    $P202 = root_new ['parrot';'ResizablePMCArray']
  vivify_205:
    set $P203, $P202[$I201]
    unless_null $P203, vivify_206
    new $P203, "Undef"
  vivify_206:
    defined $I204, $P203
    unless $I204, for_undef_207
    iter $P199, $P203
    new $P218, 'ExceptionHandler'
    set_label $P218, loop217_handler
    $P218."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P218
  loop217_test:
    unless $P199, loop217_done
    shift $P205, $P199
  loop217_redo:
    .const 'Sub' $P207 = "25_1299465710.053" 
    capture_lex $P207
    $P207($P205)
  loop217_next:
    goto loop217_test
  loop217_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P219, exception, 'type'
    eq $P219, .CONTROL_LOOP_NEXT, loop217_next
    eq $P219, .CONTROL_LOOP_REDO, loop217_redo
  loop217_done:
    pop_eh 
  for_undef_207:
.annotate 'line', 312
    find_lex $P220, "@new_list"
    find_lex $P221, "$i"
    set $I222, $P221
    find_lex $P223, "@merge_list"
    unless_null $P223, vivify_208
    $P223 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P223
  vivify_208:
    set $P223[$I222], $P220
.annotate 'line', 313
    find_lex $P224, "$i"
    add $P225, $P224, 1
    store_lex "$i", $P225
.annotate 'line', 305
    .return ($P225)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block206"  :anon :subid("25_1299465710.053") :outer("24_1299465710.053")
    .param pmc param_208
.annotate 'line', 307
    .lex "$_", param_208
.annotate 'line', 308
    find_lex $P211, "$_"
    find_lex $P212, "$accepted"
    issame $I213, $P211, $P212
    unless $I213, unless_210
    new $P209, 'Integer'
    set $P209, $I213
    goto unless_210_end
  unless_210:
.annotate 'line', 309
    find_lex $P214, "@new_list"
    find_lex $P215, "$_"
    $P216 = $P214."push"($P215)
.annotate 'line', 308
    set $P209, $P216
  unless_210_end:
.annotate 'line', 307
    .return ($P209)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_238
    .param pmc param_239 :optional :named("name")
    .param int has_param_239 :opt_flag
.annotate 'line', 62
    .lex "self", param_238
    if has_param_239, optparam_209
    new $P240, "Undef"
    set param_239, $P240
  optparam_209:
    .lex "$name", param_239
.annotate 'line', 63
    new $P241, "Undef"
    .lex "$obj", $P241
    find_lex $P242, "self"
    repr_instance_of $P243, $P242
    store_lex "$obj", $P243
.annotate 'line', 64
    find_lex $P244, "$obj"
    find_lex $P245, "$name"
    $P244."BUILD"($P245 :named("name"))
    find_lex $P246, "$obj"
.annotate 'line', 62
    .return ($P246)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_248
    .param pmc param_249 :optional :named("name")
    .param int has_param_249 :opt_flag
.annotate 'line', 68
    .lex "self", param_248
    if has_param_249, optparam_210
    new $P250, "Undef"
    set param_249, $P250
  optparam_210:
    .lex "$name", param_249
.annotate 'line', 69
    find_lex $P251, "$name"
    find_lex $P252, "self"
    get_global $P253, "$?CLASS"
    setattribute $P252, $P253, "$!name", $P251
.annotate 'line', 68
    .return ($P251)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_255
    .param pmc param_256 :optional :named("name")
    .param int has_param_256 :opt_flag
    .param pmc param_258 :optional :named("repr")
    .param int has_param_258 :opt_flag
.annotate 'line', 74
    .lex "self", param_255
    if has_param_256, optparam_211
    new $P257, "String"
    assign $P257, "<anon>"
    set param_256, $P257
  optparam_211:
    .lex "$name", param_256
    if has_param_258, optparam_212
    new $P259, "String"
    assign $P259, "P6opaque"
    set param_258, $P259
  optparam_212:
    .lex "$repr", param_258
.annotate 'line', 75
    new $P260, "Undef"
    .lex "$metaclass", $P260
    find_lex $P261, "self"
    find_lex $P262, "$name"
    $P263 = $P261."new"($P262 :named("name"))
    store_lex "$metaclass", $P263
.annotate 'line', 76
    find_lex $P264, "$metaclass"
    find_lex $P265, "$repr"
    set $S266, $P265
    repr_type_object_for $P267, $P264, $S266
.annotate 'line', 74
    .return ($P267)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_269
    .param pmc param_270
    .param pmc param_271
    .param pmc param_272
.annotate 'line', 79
    .lex "self", param_269
    .lex "$obj", param_270
    .lex "$name", param_271
    .lex "$code_obj", param_272
.annotate 'line', 80
    find_lex $P274, "$name"
    find_lex $P275, "self"
    get_global $P276, "$?CLASS"
    getattribute $P277, $P275, $P276, "%!methods"
    unless_null $P277, vivify_213
    $P277 = root_new ['parrot';'Hash']
  vivify_213:
    set $P278, $P277[$P274]
    unless_null $P278, vivify_214
    new $P278, "Undef"
  vivify_214:
    unless $P278, if_273_end
.annotate 'line', 81
    new $P279, "String"
    assign $P279, "This class already has a method named "
    find_lex $P280, "$name"
    concat $P281, $P279, $P280
    die $P281
  if_273_end:
.annotate 'line', 83
    find_lex $P282, "$code_obj"
    find_lex $P283, "$name"
    find_lex $P284, "self"
    get_global $P285, "$?CLASS"
    getattribute $P286, $P284, $P285, "%!methods"
    unless_null $P286, vivify_215
    $P286 = root_new ['parrot';'Hash']
    setattribute $P284, $P285, "%!methods", $P286
  vivify_215:
    set $P286[$P283], $P282
.annotate 'line', 79
    .return ($P282)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_288
    .param pmc param_289
    .param pmc param_290
    .param pmc param_291
.annotate 'line', 86
    .lex "self", param_288
    .lex "$obj", param_289
    .lex "$name", param_290
    .lex "$code_obj", param_291
.annotate 'line', 92
    $P292 = root_new ['parrot';'Hash']
    .lex "%todo", $P292
.annotate 'line', 86
    find_lex $P293, "%todo"
.annotate 'line', 93
    find_lex $P294, "$name"
    find_lex $P295, "%todo"
    unless_null $P295, vivify_216
    $P295 = root_new ['parrot';'Hash']
    store_lex "%todo", $P295
  vivify_216:
    set $P295["name"], $P294
.annotate 'line', 94
    find_lex $P296, "$code_obj"
    find_lex $P297, "%todo"
    unless_null $P297, vivify_217
    $P297 = root_new ['parrot';'Hash']
    store_lex "%todo", $P297
  vivify_217:
    set $P297["code"], $P296
.annotate 'line', 95
    find_lex $P298, "%todo"
    find_lex $P299, "self"
    get_global $P300, "$?CLASS"
    getattribute $P301, $P299, $P300, "@!multi_methods_to_incorporate"
    unless_null $P301, vivify_218
    $P301 = root_new ['parrot';'ResizablePMCArray']
  vivify_218:
    set $N302, $P301
    set $I303, $N302
    find_lex $P304, "self"
    get_global $P305, "$?CLASS"
    getattribute $P306, $P304, $P305, "@!multi_methods_to_incorporate"
    unless_null $P306, vivify_219
    $P306 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P304, $P305, "@!multi_methods_to_incorporate", $P306
  vivify_219:
    set $P306[$I303], $P298
    find_lex $P307, "$code_obj"
.annotate 'line', 86
    .return ($P307)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_309
    .param pmc param_310
    .param pmc param_311
.annotate 'line', 99
    .lex "self", param_309
    .lex "$obj", param_310
    .lex "$meta_attr", param_311
.annotate 'line', 100
    new $P312, "Undef"
    .lex "$name", $P312
    find_lex $P313, "$meta_attr"
    $P314 = $P313."name"()
    store_lex "$name", $P314
.annotate 'line', 101
    find_lex $P316, "$name"
    find_lex $P317, "self"
    get_global $P318, "$?CLASS"
    getattribute $P319, $P317, $P318, "%!attributes"
    unless_null $P319, vivify_220
    $P319 = root_new ['parrot';'Hash']
  vivify_220:
    set $P320, $P319[$P316]
    unless_null $P320, vivify_221
    new $P320, "Undef"
  vivify_221:
    unless $P320, if_315_end
.annotate 'line', 102
    new $P321, "String"
    assign $P321, "This class already has an attribute named "
    find_lex $P322, "$name"
    concat $P323, $P321, $P322
    die $P323
  if_315_end:
.annotate 'line', 104
    find_lex $P324, "$meta_attr"
    find_lex $P325, "$name"
    find_lex $P326, "self"
    get_global $P327, "$?CLASS"
    getattribute $P328, $P326, $P327, "%!attributes"
    unless_null $P328, vivify_222
    $P328 = root_new ['parrot';'Hash']
    setattribute $P326, $P327, "%!attributes", $P328
  vivify_222:
    set $P328[$P325], $P324
.annotate 'line', 99
    .return ($P324)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_330
    .param pmc param_331
    .param pmc param_332
.annotate 'line', 107
    .const 'Sub' $P344 = "33_1299465710.053" 
    capture_lex $P344
    .lex "self", param_330
    .lex "$obj", param_331
    .lex "$parent", param_332
.annotate 'line', 108
    find_lex $P334, "self"
    get_global $P335, "$?CLASS"
    getattribute $P336, $P334, $P335, "$!composed"
    unless_null $P336, vivify_223
    new $P336, "Undef"
  vivify_223:
    unless $P336, if_333_end
.annotate 'line', 109
    die "NQPClassHOW does not support adding parents after being composed."
  if_333_end:
.annotate 'line', 111
    find_lex $P338, "self"
    get_global $P339, "$?CLASS"
    getattribute $P340, $P338, $P339, "@!parents"
    unless_null $P340, vivify_224
    $P340 = root_new ['parrot';'ResizablePMCArray']
  vivify_224:
    defined $I341, $P340
    unless $I341, for_undef_225
    iter $P337, $P340
    new $P356, 'ExceptionHandler'
    set_label $P356, loop355_handler
    $P356."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P356
  loop355_test:
    unless $P337, loop355_done
    shift $P342, $P337
  loop355_redo:
    .const 'Sub' $P344 = "33_1299465710.053" 
    capture_lex $P344
    $P344($P342)
  loop355_next:
    goto loop355_test
  loop355_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P357, exception, 'type'
    eq $P357, .CONTROL_LOOP_NEXT, loop355_next
    eq $P357, .CONTROL_LOOP_REDO, loop355_redo
  loop355_done:
    pop_eh 
  for_undef_225:
.annotate 'line', 116
    find_lex $P358, "$parent"
    find_lex $P359, "self"
    get_global $P360, "$?CLASS"
    getattribute $P361, $P359, $P360, "@!parents"
    unless_null $P361, vivify_226
    $P361 = root_new ['parrot';'ResizablePMCArray']
  vivify_226:
    set $N362, $P361
    set $I363, $N362
    find_lex $P364, "self"
    get_global $P365, "$?CLASS"
    getattribute $P366, $P364, $P365, "@!parents"
    unless_null $P366, vivify_227
    $P366 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P364, $P365, "@!parents", $P366
  vivify_227:
    set $P366[$I363], $P358
.annotate 'line', 107
    .return ($P358)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block343"  :anon :subid("33_1299465710.053") :outer("32_1299465710.053")
    .param pmc param_345
.annotate 'line', 111
    .lex "$_", param_345
.annotate 'line', 112
    find_lex $P348, "$_"
    find_lex $P349, "$parent"
    issame $I350, $P348, $P349
    if $I350, if_347
    new $P346, 'Integer'
    set $P346, $I350
    goto if_347_end
  if_347:
.annotate 'line', 113
    new $P351, "String"
    assign $P351, "Already have "
    find_lex $P352, "$parent"
    concat $P353, $P351, $P352
    concat $P354, $P353, " as a parent class."
    die $P354
  if_347_end:
.annotate 'line', 111
    .return ($P346)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_role"  :subid("34_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_368
    .param pmc param_369
    .param pmc param_370
.annotate 'line', 119
    .const 'Sub' $P378 = "35_1299465710.053" 
    capture_lex $P378
    .lex "self", param_368
    .lex "$obj", param_369
    .lex "$role", param_370
.annotate 'line', 120
    find_lex $P372, "self"
    get_global $P373, "$?CLASS"
    getattribute $P374, $P372, $P373, "@!roles"
    unless_null $P374, vivify_228
    $P374 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    defined $I375, $P374
    unless $I375, for_undef_229
    iter $P371, $P374
    new $P390, 'ExceptionHandler'
    set_label $P390, loop389_handler
    $P390."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P390
  loop389_test:
    unless $P371, loop389_done
    shift $P376, $P371
  loop389_redo:
    .const 'Sub' $P378 = "35_1299465710.053" 
    capture_lex $P378
    $P378($P376)
  loop389_next:
    goto loop389_test
  loop389_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P391, exception, 'type'
    eq $P391, .CONTROL_LOOP_NEXT, loop389_next
    eq $P391, .CONTROL_LOOP_REDO, loop389_redo
  loop389_done:
    pop_eh 
  for_undef_229:
.annotate 'line', 125
    find_lex $P392, "$role"
    find_lex $P393, "self"
    get_global $P394, "$?CLASS"
    getattribute $P395, $P393, $P394, "@!roles"
    unless_null $P395, vivify_230
    $P395 = root_new ['parrot';'ResizablePMCArray']
  vivify_230:
    set $N396, $P395
    set $I397, $N396
    find_lex $P398, "self"
    get_global $P399, "$?CLASS"
    getattribute $P400, $P398, $P399, "@!roles"
    unless_null $P400, vivify_231
    $P400 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P398, $P399, "@!roles", $P400
  vivify_231:
    set $P400[$I397], $P392
.annotate 'line', 119
    .return ($P392)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block377"  :anon :subid("35_1299465710.053") :outer("34_1299465710.053")
    .param pmc param_379
.annotate 'line', 120
    .lex "$_", param_379
.annotate 'line', 121
    find_lex $P382, "$_"
    find_lex $P383, "$role"
    issame $I384, $P382, $P383
    if $I384, if_381
    new $P380, 'Integer'
    set $P380, $I384
    goto if_381_end
  if_381:
.annotate 'line', 122
    new $P385, "String"
    assign $P385, "The role "
    find_lex $P386, "$role"
    concat $P387, $P385, $P386
    concat $P388, $P387, " has already been added."
    die $P388
  if_381_end:
.annotate 'line', 120
    .return ($P380)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_parrot_vtable_mapping"  :subid("36_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_402
    .param pmc param_403
    .param pmc param_404
    .param pmc param_405
.annotate 'line', 128
    .lex "self", param_402
    .lex "$obj", param_403
    .lex "$name", param_404
    .lex "$meth", param_405
.annotate 'line', 129
    find_lex $P407, "$name"
    find_lex $P408, "self"
    get_global $P409, "$?CLASS"
    getattribute $P410, $P408, $P409, "%!parrot_vtable_mapping"
    unless_null $P410, vivify_232
    $P410 = root_new ['parrot';'Hash']
  vivify_232:
    set $P411, $P410[$P407]
    unless_null $P411, vivify_233
    new $P411, "Undef"
  vivify_233:
    defined $I412, $P411
    unless $I412, if_406_end
.annotate 'line', 130
    new $P413, "String"
    assign $P413, "Class '"
    find_lex $P414, "self"
    get_global $P415, "$?CLASS"
    getattribute $P416, $P414, $P415, "$!name"
    unless_null $P416, vivify_234
    new $P416, "Undef"
  vivify_234:
    concat $P417, $P413, $P416
    concat $P418, $P417, "' already has a Parrot v-table override for '"
    find_lex $P419, "$name"
    concat $P420, $P418, $P419
.annotate 'line', 131
    concat $P421, $P420, "'"
.annotate 'line', 132
    die $P421
  if_406_end:
.annotate 'line', 134
    find_lex $P422, "$meth"
    find_lex $P423, "$name"
    find_lex $P424, "self"
    get_global $P425, "$?CLASS"
    getattribute $P426, $P424, $P425, "%!parrot_vtable_mapping"
    unless_null $P426, vivify_235
    $P426 = root_new ['parrot';'Hash']
    setattribute $P424, $P425, "%!parrot_vtable_mapping", $P426
  vivify_235:
    set $P426[$P423], $P422
.annotate 'line', 128
    .return ($P422)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("37_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_428
    .param pmc param_429
.annotate 'line', 137
    .const 'Sub' $P516 = "40_1299465710.053" 
    capture_lex $P516
    .const 'Sub' $P435 = "38_1299465710.053" 
    capture_lex $P435
    .lex "self", param_428
    .lex "$obj", param_429
.annotate 'line', 141
    find_lex $P431, "self"
    get_global $P432, "$?CLASS"
    getattribute $P433, $P431, $P432, "@!roles"
    unless_null $P433, vivify_236
    $P433 = root_new ['parrot';'ResizablePMCArray']
  vivify_236:
    unless $P433, if_430_end
    .const 'Sub' $P435 = "38_1299465710.053" 
    capture_lex $P435
    $P435()
  if_430_end:
.annotate 'line', 154
    find_lex $P483, "self"
    get_global $P484, "$?CLASS"
    getattribute $P485, $P483, $P484, "@!parents"
    unless_null $P485, vivify_243
    $P485 = root_new ['parrot';'ResizablePMCArray']
  vivify_243:
    set $N486, $P485
    iseq $I487, $N486, 0.0
    if $I487, if_482
    new $P481, 'Integer'
    set $P481, $I487
    goto if_482_end
  if_482:
    find_lex $P488, "self"
    get_global $P489, "$?CLASS"
    getattribute $P490, $P488, $P489, "$!name"
    unless_null $P490, vivify_244
    new $P490, "Undef"
  vivify_244:
    set $S491, $P490
    isne $I492, $S491, "NQPMu"
    new $P481, 'Integer'
    set $P481, $I492
  if_482_end:
    unless $P481, if_480_end
.annotate 'line', 155
    find_lex $P493, "self"
    find_lex $P494, "$obj"
    get_hll_global $P495, "NQPMu"
    $P493."add_parent"($P494, $P495)
  if_480_end:
.annotate 'line', 160
    find_lex $P497, "self"
    get_global $P498, "$?CLASS"
    getattribute $P499, $P497, $P498, "$!composed"
    unless_null $P499, vivify_245
    new $P499, "Undef"
  vivify_245:
    if $P499, unless_496_end
.annotate 'line', 161
    find_lex $P500, "$obj"
    $P501 = "compute_c3_mro"($P500)
    find_lex $P502, "self"
    get_global $P503, "$?CLASS"
    setattribute $P502, $P503, "@!mro", $P501
.annotate 'line', 162
    new $P504, "Integer"
    assign $P504, 1
    find_lex $P505, "self"
    get_global $P506, "$?CLASS"
    setattribute $P505, $P506, "$!composed", $P504
  unless_496_end:
.annotate 'line', 166
    find_lex $P507, "self"
    find_lex $P508, "$obj"
    $P507."incorporate_multi_candidates"($P508)
.annotate 'line', 169
    find_lex $P510, "self"
    find_lex $P511, "$obj"
    $P512 = $P510."attributes"($P511, "0" :named("local"))
    defined $I513, $P512
    unless $I513, for_undef_246
    iter $P509, $P512
    new $P522, 'ExceptionHandler'
    set_label $P522, loop521_handler
    $P522."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P522
  loop521_test:
    unless $P509, loop521_done
    shift $P514, $P509
  loop521_redo:
    .const 'Sub' $P516 = "40_1299465710.053" 
    capture_lex $P516
    $P516($P514)
  loop521_next:
    goto loop521_test
  loop521_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P523, exception, 'type'
    eq $P523, .CONTROL_LOOP_NEXT, loop521_next
    eq $P523, .CONTROL_LOOP_REDO, loop521_redo
  loop521_done:
    pop_eh 
  for_undef_246:
.annotate 'line', 172
    find_lex $P524, "self"
    find_lex $P525, "$obj"
    $P524."publish_type_cache"($P525)
.annotate 'line', 173
    find_lex $P526, "self"
    find_lex $P527, "$obj"
    $P526."publish_method_cache"($P527)
.annotate 'line', 176
    find_lex $P528, "self"
    find_lex $P529, "$obj"
    $P528."publish_parrot_vtable_mapping"($P529)
    find_lex $P530, "$obj"
.annotate 'line', 137
    .return ($P530)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block434"  :anon :subid("38_1299465710.053") :outer("37_1299465710.053")
.annotate 'line', 141
    .const 'Sub' $P445 = "39_1299465710.053" 
    capture_lex $P445
.annotate 'line', 142
    $P436 = root_new ['parrot';'ResizablePMCArray']
    .lex "@instantiated_roles", $P436
.annotate 'line', 141
    find_lex $P437, "@instantiated_roles"
.annotate 'line', 143
    find_lex $P439, "self"
    get_global $P440, "$?CLASS"
    getattribute $P441, $P439, $P440, "@!roles"
    unless_null $P441, vivify_237
    $P441 = root_new ['parrot';'ResizablePMCArray']
  vivify_237:
    defined $I442, $P441
    unless $I442, for_undef_238
    iter $P438, $P441
    new $P474, 'ExceptionHandler'
    set_label $P474, loop473_handler
    $P474."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P474
  loop473_test:
    unless $P438, loop473_done
    shift $P443, $P438
  loop473_redo:
    .const 'Sub' $P445 = "39_1299465710.053" 
    capture_lex $P445
    $P445($P443)
  loop473_next:
    goto loop473_test
  loop473_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P475, exception, 'type'
    eq $P475, .CONTROL_LOOP_NEXT, loop473_next
    eq $P475, .CONTROL_LOOP_REDO, loop473_redo
  loop473_done:
    pop_eh 
  for_undef_238:
.annotate 'line', 149
    get_hll_global $P476, "RoleToClassApplier"
    find_lex $P477, "$obj"
    find_lex $P478, "@instantiated_roles"
    $P479 = $P476."apply"($P477, $P478)
.annotate 'line', 141
    .return ($P479)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block444"  :anon :subid("39_1299465710.053") :outer("38_1299465710.053")
    .param pmc param_447
.annotate 'line', 144
    new $P446, "Undef"
    .lex "$ins", $P446
    .lex "$_", param_447
    find_lex $P448, "$_"
    get_how $P449, $P448
    find_lex $P450, "$_"
    find_lex $P451, "$obj"
    $P452 = $P449."instantiate"($P450, $P451)
    store_lex "$ins", $P452
.annotate 'line', 145
    find_lex $P453, "@instantiated_roles"
    find_lex $P454, "$ins"
    $P453."push"($P454)
.annotate 'line', 146
    find_lex $P455, "$_"
    find_lex $P456, "self"
    get_global $P457, "$?CLASS"
    getattribute $P458, $P456, $P457, "@!done"
    unless_null $P458, vivify_239
    $P458 = root_new ['parrot';'ResizablePMCArray']
  vivify_239:
    set $N459, $P458
    set $I460, $N459
    find_lex $P461, "self"
    get_global $P462, "$?CLASS"
    getattribute $P463, $P461, $P462, "@!done"
    unless_null $P463, vivify_240
    $P463 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P461, $P462, "@!done", $P463
  vivify_240:
    set $P463[$I460], $P455
.annotate 'line', 147
    find_lex $P464, "$ins"
    find_lex $P465, "self"
    get_global $P466, "$?CLASS"
    getattribute $P467, $P465, $P466, "@!done"
    unless_null $P467, vivify_241
    $P467 = root_new ['parrot';'ResizablePMCArray']
  vivify_241:
    set $N468, $P467
    set $I469, $N468
    find_lex $P470, "self"
    get_global $P471, "$?CLASS"
    getattribute $P472, $P470, $P471, "@!done"
    unless_null $P472, vivify_242
    $P472 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P470, $P471, "@!done", $P472
  vivify_242:
    set $P472[$I469], $P464
.annotate 'line', 143
    .return ($P464)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block515"  :anon :subid("40_1299465710.053") :outer("37_1299465710.053")
    .param pmc param_517
.annotate 'line', 169
    .lex "$_", param_517
    find_lex $P518, "$_"
    find_lex $P519, "$obj"
    $P520 = $P518."compose"($P519)
    .return ($P520)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("41_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_532
    .param pmc param_533
.annotate 'line', 181
    .const 'Sub' $P548 = "42_1299465710.053" 
    capture_lex $P548
    .lex "self", param_532
    .lex "$obj", param_533
.annotate 'line', 182
    new $P534, "Undef"
    .lex "$num_todo", $P534
.annotate 'line', 183
    new $P535, "Undef"
    .lex "$i", $P535
.annotate 'line', 182
    find_lex $P536, "self"
    get_global $P537, "$?CLASS"
    getattribute $P538, $P536, $P537, "@!multi_methods_to_incorporate"
    unless_null $P538, vivify_247
    $P538 = root_new ['parrot';'ResizablePMCArray']
  vivify_247:
    set $N539, $P538
    new $P540, 'Float'
    set $P540, $N539
    store_lex "$num_todo", $P540
.annotate 'line', 183
    new $P541, "Integer"
    assign $P541, 0
    store_lex "$i", $P541
.annotate 'line', 184
    new $P657, 'ExceptionHandler'
    set_label $P657, loop656_handler
    $P657."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P657
  loop656_test:
    find_lex $P542, "$i"
    set $N543, $P542
    find_lex $P544, "$num_todo"
    set $N545, $P544
    isne $I546, $N543, $N545
    unless $I546, loop656_done
  loop656_redo:
    .const 'Sub' $P548 = "42_1299465710.053" 
    capture_lex $P548
    $P548()
  loop656_next:
    goto loop656_test
  loop656_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P658, exception, 'type'
    eq $P658, .CONTROL_LOOP_NEXT, loop656_next
    eq $P658, .CONTROL_LOOP_REDO, loop656_redo
  loop656_done:
    pop_eh 
.annotate 'line', 181
    .return ($I546)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block547"  :anon :subid("42_1299465710.053") :outer("41_1299465710.053")
.annotate 'line', 184
    .const 'Sub' $P584 = "43_1299465710.053" 
    capture_lex $P584
.annotate 'line', 186
    new $P549, "Undef"
    .lex "$name", $P549
.annotate 'line', 187
    new $P550, "Undef"
    .lex "$code", $P550
.annotate 'line', 191
    new $P551, "Undef"
    .lex "$dispatcher", $P551
.annotate 'line', 186
    find_lex $P552, "$i"
    set $I553, $P552
    find_lex $P554, "self"
    get_global $P555, "$?CLASS"
    getattribute $P556, $P554, $P555, "@!multi_methods_to_incorporate"
    unless_null $P556, vivify_248
    $P556 = root_new ['parrot';'ResizablePMCArray']
  vivify_248:
    set $P557, $P556[$I553]
    unless_null $P557, vivify_249
    $P557 = root_new ['parrot';'Hash']
  vivify_249:
    set $P558, $P557["name"]
    unless_null $P558, vivify_250
    new $P558, "Undef"
  vivify_250:
    store_lex "$name", $P558
.annotate 'line', 187
    find_lex $P559, "$i"
    set $I560, $P559
    find_lex $P561, "self"
    get_global $P562, "$?CLASS"
    getattribute $P563, $P561, $P562, "@!multi_methods_to_incorporate"
    unless_null $P563, vivify_251
    $P563 = root_new ['parrot';'ResizablePMCArray']
  vivify_251:
    set $P564, $P563[$I560]
    unless_null $P564, vivify_252
    $P564 = root_new ['parrot';'Hash']
  vivify_252:
    set $P565, $P564["code"]
    unless_null $P565, vivify_253
    new $P565, "Undef"
  vivify_253:
    store_lex "$code", $P565
.annotate 'line', 191
    find_lex $P566, "$name"
    find_lex $P567, "self"
    get_global $P568, "$?CLASS"
    getattribute $P569, $P567, $P568, "%!methods"
    unless_null $P569, vivify_254
    $P569 = root_new ['parrot';'Hash']
  vivify_254:
    set $P570, $P569[$P566]
    unless_null $P570, vivify_255
    new $P570, "Undef"
  vivify_255:
    store_lex "$dispatcher", $P570
.annotate 'line', 192
    find_lex $P572, "$dispatcher"
    defined $I573, $P572
    if $I573, if_571
.annotate 'line', 202
    .const 'Sub' $P584 = "43_1299465710.053" 
    capture_lex $P584
    $P584()
    goto if_571_end
  if_571:
.annotate 'line', 195
    find_lex $P575, "$dispatcher"
    is_dispatcher $I576, $P575
    if $I576, if_574
.annotate 'line', 199
    new $P579, 'String'
    set $P579, "Cannot have a multi candidate for "
    find_lex $P580, "$name"
    concat $P581, $P579, $P580
    concat $P582, $P581, " when an only method is also in the class"
    die $P582
.annotate 'line', 198
    goto if_574_end
  if_574:
.annotate 'line', 196
    find_lex $P577, "$dispatcher"
    find_lex $P578, "$code"
    push_dispatchee $P577, $P578
  if_574_end:
  if_571_end:
.annotate 'line', 230
    find_lex $P654, "$i"
    add $P655, $P654, 1
    store_lex "$i", $P655
.annotate 'line', 184
    .return ($P655)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block583"  :anon :subid("43_1299465710.053") :outer("42_1299465710.053")
.annotate 'line', 202
    .const 'Sub' $P601 = "44_1299465710.053" 
    capture_lex $P601
.annotate 'line', 204
    new $P585, "Undef"
    .lex "$j", $P585
.annotate 'line', 205
    new $P586, "Undef"
    .lex "$found", $P586
.annotate 'line', 204
    new $P587, "Integer"
    assign $P587, 1
    store_lex "$j", $P587
.annotate 'line', 205
    new $P588, "Integer"
    assign $P588, 0
    store_lex "$found", $P588
.annotate 'line', 206
    new $P645, 'ExceptionHandler'
    set_label $P645, loop644_handler
    $P645."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P645
  loop644_test:
    find_lex $P591, "$j"
    set $N592, $P591
    find_lex $P593, "self"
    get_global $P594, "$?CLASS"
    getattribute $P595, $P593, $P594, "@!mro"
    unless_null $P595, vivify_256
    $P595 = root_new ['parrot';'ResizablePMCArray']
  vivify_256:
    set $N596, $P595
    isne $I597, $N592, $N596
    if $I597, if_590
    new $P589, 'Integer'
    set $P589, $I597
    goto if_590_end
  if_590:
    find_lex $P598, "$found"
    isfalse $I599, $P598
    new $P589, 'Integer'
    set $P589, $I599
  if_590_end:
    unless $P589, loop644_done
  loop644_redo:
    .const 'Sub' $P601 = "44_1299465710.053" 
    capture_lex $P601
    $P601()
  loop644_next:
    goto loop644_test
  loop644_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P646, exception, 'type'
    eq $P646, .CONTROL_LOOP_NEXT, loop644_next
    eq $P646, .CONTROL_LOOP_REDO, loop644_redo
  loop644_done:
    pop_eh 
.annotate 'line', 226
    find_lex $P649, "$found"
    unless $P649, unless_648
    set $P647, $P649
    goto unless_648_end
  unless_648:
.annotate 'line', 227
    new $P650, 'String'
    set $P650, "Could not find a proto for multi "
    find_lex $P651, "$name"
    concat $P652, $P650, $P651
    concat $P653, $P652, ", and proto generation is NYI"
    die $P653
  unless_648_end:
.annotate 'line', 202
    .return ($P647)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block600"  :anon :subid("44_1299465710.053") :outer("43_1299465710.053")
.annotate 'line', 206
    .const 'Sub' $P625 = "45_1299465710.053" 
    capture_lex $P625
.annotate 'line', 207
    new $P602, "Undef"
    .lex "$parent", $P602
.annotate 'line', 208
    $P603 = root_new ['parrot';'Hash']
    .lex "%meths", $P603
.annotate 'line', 209
    new $P604, "Undef"
    .lex "$dispatcher", $P604
.annotate 'line', 207
    find_lex $P605, "$j"
    set $I606, $P605
    find_lex $P607, "self"
    get_global $P608, "$?CLASS"
    getattribute $P609, $P607, $P608, "@!mro"
    unless_null $P609, vivify_257
    $P609 = root_new ['parrot';'ResizablePMCArray']
  vivify_257:
    set $P610, $P609[$I606]
    unless_null $P610, vivify_258
    new $P610, "Undef"
  vivify_258:
    store_lex "$parent", $P610
.annotate 'line', 208
    find_lex $P611, "$parent"
    get_how $P612, $P611
    find_lex $P613, "$parent"
    $P614 = $P612."method_table"($P613)
    store_lex "%meths", $P614
.annotate 'line', 209
    find_lex $P615, "$name"
    find_lex $P616, "%meths"
    unless_null $P616, vivify_259
    $P616 = root_new ['parrot';'Hash']
  vivify_259:
    set $P617, $P616[$P615]
    unless_null $P617, vivify_260
    new $P617, "Undef"
  vivify_260:
    store_lex "$dispatcher", $P617
.annotate 'line', 210
    find_lex $P619, "$dispatcher"
    defined $I620, $P619
    unless $I620, if_618_end
.annotate 'line', 213
    find_lex $P622, "$dispatcher"
    is_dispatcher $I623, $P622
    if $I623, if_621
.annotate 'line', 221
    new $P638, 'String'
    set $P638, "Could not find a proto for multi "
    find_lex $P639, "$name"
    concat $P640, $P638, $P639
    concat $P641, $P640, " (it may exist, but an only is hiding it if so)"
    die $P641
.annotate 'line', 220
    goto if_621_end
  if_621:
.annotate 'line', 213
    .const 'Sub' $P625 = "45_1299465710.053" 
    capture_lex $P625
    $P625()
  if_621_end:
  if_618_end:
.annotate 'line', 224
    find_lex $P642, "$j"
    add $P643, $P642, 1
    store_lex "$j", $P643
.annotate 'line', 206
    .return ($P643)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block624"  :anon :subid("45_1299465710.053") :outer("44_1299465710.053")
.annotate 'line', 215
    $P626 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P626
.annotate 'line', 213
    find_lex $P627, "@new_dispatchees"
.annotate 'line', 216
    find_lex $P628, "$code"
    find_lex $P629, "@new_dispatchees"
    unless_null $P629, vivify_261
    $P629 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P629
  vivify_261:
    set $P629[0], $P628
.annotate 'line', 217
    find_lex $P630, "$dispatcher"
    find_lex $P631, "@new_dispatchees"
    create_dispatch_and_add_candidates $P632, $P630, $P631
    find_lex $P633, "$name"
    find_lex $P634, "self"
    get_global $P635, "$?CLASS"
    getattribute $P636, $P634, $P635, "%!methods"
    unless_null $P636, vivify_262
    $P636 = root_new ['parrot';'Hash']
    setattribute $P634, $P635, "%!methods", $P636
  vivify_262:
    set $P636[$P633], $P632
.annotate 'line', 218
    new $P637, "Integer"
    assign $P637, 1
    store_lex "$found", $P637
.annotate 'line', 213
    .return ($P637)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_type_cache"  :subid("46_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_662
    .param pmc param_663
.annotate 'line', 323
    .const 'Sub' $P688 = "48_1299465710.053" 
    capture_lex $P688
    .const 'Sub' $P673 = "47_1299465710.053" 
    capture_lex $P673
    .lex "self", param_662
    .lex "$obj", param_663
.annotate 'line', 324
    $P664 = root_new ['parrot';'ResizablePMCArray']
    .lex "@tc", $P664
.annotate 'line', 323
    find_lex $P665, "@tc"
.annotate 'line', 325
    find_lex $P667, "self"
    get_global $P668, "$?CLASS"
    getattribute $P669, $P667, $P668, "@!mro"
    unless_null $P669, vivify_263
    $P669 = root_new ['parrot';'ResizablePMCArray']
  vivify_263:
    defined $I670, $P669
    unless $I670, for_undef_264
    iter $P666, $P669
    new $P679, 'ExceptionHandler'
    set_label $P679, loop678_handler
    $P679."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P679
  loop678_test:
    unless $P666, loop678_done
    shift $P671, $P666
  loop678_redo:
    .const 'Sub' $P673 = "47_1299465710.053" 
    capture_lex $P673
    $P673($P671)
  loop678_next:
    goto loop678_test
  loop678_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P680, exception, 'type'
    eq $P680, .CONTROL_LOOP_NEXT, loop678_next
    eq $P680, .CONTROL_LOOP_REDO, loop678_redo
  loop678_done:
    pop_eh 
  for_undef_264:
.annotate 'line', 326
    find_lex $P682, "self"
    get_global $P683, "$?CLASS"
    getattribute $P684, $P682, $P683, "@!done"
    unless_null $P684, vivify_265
    $P684 = root_new ['parrot';'ResizablePMCArray']
  vivify_265:
    defined $I685, $P684
    unless $I685, for_undef_266
    iter $P681, $P684
    new $P694, 'ExceptionHandler'
    set_label $P694, loop693_handler
    $P694."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P694
  loop693_test:
    unless $P681, loop693_done
    shift $P686, $P681
  loop693_redo:
    .const 'Sub' $P688 = "48_1299465710.053" 
    capture_lex $P688
    $P688($P686)
  loop693_next:
    goto loop693_test
  loop693_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P695, exception, 'type'
    eq $P695, .CONTROL_LOOP_NEXT, loop693_next
    eq $P695, .CONTROL_LOOP_REDO, loop693_redo
  loop693_done:
    pop_eh 
  for_undef_266:
.annotate 'line', 327
    find_lex $P696, "$obj"
    find_lex $P697, "@tc"
    publish_type_check_cache $P696, $P697
.annotate 'line', 323
    .return ()
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block672"  :anon :subid("47_1299465710.053") :outer("46_1299465710.053")
    .param pmc param_674
.annotate 'line', 325
    .lex "$_", param_674
    find_lex $P675, "@tc"
    find_lex $P676, "$_"
    $P677 = $P675."push"($P676)
    .return ($P677)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block687"  :anon :subid("48_1299465710.053") :outer("46_1299465710.053")
    .param pmc param_689
.annotate 'line', 326
    .lex "$_", param_689
    find_lex $P690, "@tc"
    find_lex $P691, "$_"
    $P692 = $P690."push"($P691)
    .return ($P692)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("49_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_699
    .param pmc param_700
.annotate 'line', 330
    .const 'Sub' $P710 = "50_1299465710.053" 
    capture_lex $P710
    .lex "self", param_699
    .lex "$obj", param_700
.annotate 'line', 333
    $P701 = root_new ['parrot';'Hash']
    .lex "%cache", $P701
.annotate 'line', 330
    find_lex $P702, "%cache"
.annotate 'line', 334
    find_lex $P704, "self"
    get_global $P705, "$?CLASS"
    getattribute $P706, $P704, $P705, "@!mro"
    unless_null $P706, vivify_267
    $P706 = root_new ['parrot';'ResizablePMCArray']
  vivify_267:
    defined $I707, $P706
    unless $I707, for_undef_268
    iter $P703, $P706
    new $P739, 'ExceptionHandler'
    set_label $P739, loop738_handler
    $P739."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P739
  loop738_test:
    unless $P703, loop738_done
    shift $P708, $P703
  loop738_redo:
    .const 'Sub' $P710 = "50_1299465710.053" 
    capture_lex $P710
    $P710($P708)
  loop738_next:
    goto loop738_test
  loop738_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P740, exception, 'type'
    eq $P740, .CONTROL_LOOP_NEXT, loop738_next
    eq $P740, .CONTROL_LOOP_REDO, loop738_redo
  loop738_done:
    pop_eh 
  for_undef_268:
.annotate 'line', 342
    find_lex $P741, "$obj"
    find_lex $P742, "%cache"
    publish_method_cache $P741, $P742
.annotate 'line', 330
    .return ()
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block709"  :anon :subid("50_1299465710.053") :outer("49_1299465710.053")
    .param pmc param_712
.annotate 'line', 334
    .const 'Sub' $P722 = "51_1299465710.053" 
    capture_lex $P722
.annotate 'line', 335
    $P711 = root_new ['parrot';'Hash']
    .lex "%methods", $P711
    .lex "$_", param_712
    find_lex $P713, "$_"
    get_how $P714, $P713
    find_lex $P715, "$_"
    $P716 = $P714."method_table"($P715)
    store_lex "%methods", $P716
.annotate 'line', 336
    find_lex $P718, "%methods"
    defined $I719, $P718
    unless $I719, for_undef_269
    iter $P717, $P718
    new $P736, 'ExceptionHandler'
    set_label $P736, loop735_handler
    $P736."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P736
  loop735_test:
    unless $P717, loop735_done
    shift $P720, $P717
  loop735_redo:
    .const 'Sub' $P722 = "51_1299465710.053" 
    capture_lex $P722
    $P722($P720)
  loop735_next:
    goto loop735_test
  loop735_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P737, exception, 'type'
    eq $P737, .CONTROL_LOOP_NEXT, loop735_next
    eq $P737, .CONTROL_LOOP_REDO, loop735_redo
  loop735_done:
    pop_eh 
  for_undef_269:
.annotate 'line', 334
    .return ($P717)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block721"  :anon :subid("51_1299465710.053") :outer("50_1299465710.053")
    .param pmc param_723
.annotate 'line', 336
    .lex "$_", param_723
.annotate 'line', 337
    find_lex $P726, "$_"
    $P727 = $P726."key"()
    find_lex $P728, "%cache"
    unless_null $P728, vivify_270
    $P728 = root_new ['parrot';'Hash']
  vivify_270:
    set $P729, $P728[$P727]
    unless_null $P729, vivify_271
    new $P729, "Undef"
  vivify_271:
    unless $P729, unless_725
    set $P724, $P729
    goto unless_725_end
  unless_725:
.annotate 'line', 338
    find_lex $P730, "$_"
    $P731 = $P730."value"()
    find_lex $P732, "$_"
    $P733 = $P732."key"()
    find_lex $P734, "%cache"
    unless_null $P734, vivify_272
    $P734 = root_new ['parrot';'Hash']
    store_lex "%cache", $P734
  vivify_272:
    set $P734[$P733], $P731
.annotate 'line', 337
    set $P724, $P731
  unless_725_end:
.annotate 'line', 336
    .return ($P724)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_parrot_vtable_mapping"  :subid("52_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_744
    .param pmc param_745
.annotate 'line', 345
    .const 'Sub' $P755 = "53_1299465710.053" 
    capture_lex $P755
    .lex "self", param_744
    .lex "$obj", param_745
.annotate 'line', 346
    $P746 = root_new ['parrot';'Hash']
    .lex "%mapping", $P746
.annotate 'line', 345
    find_lex $P747, "%mapping"
.annotate 'line', 347
    find_lex $P749, "self"
    get_global $P750, "$?CLASS"
    getattribute $P751, $P749, $P750, "@!mro"
    unless_null $P751, vivify_273
    $P751 = root_new ['parrot';'ResizablePMCArray']
  vivify_273:
    defined $I752, $P751
    unless $I752, for_undef_274
    iter $P748, $P751
    new $P784, 'ExceptionHandler'
    set_label $P784, loop783_handler
    $P784."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P784
  loop783_test:
    unless $P748, loop783_done
    shift $P753, $P748
  loop783_redo:
    .const 'Sub' $P755 = "53_1299465710.053" 
    capture_lex $P755
    $P755($P753)
  loop783_next:
    goto loop783_test
  loop783_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P785, exception, 'type'
    eq $P785, .CONTROL_LOOP_NEXT, loop783_next
    eq $P785, .CONTROL_LOOP_REDO, loop783_redo
  loop783_done:
    pop_eh 
  for_undef_274:
.annotate 'line', 355
    find_lex $P788, "%mapping"
    set $N789, $P788
    if $N789, if_787
    new $P786, 'Float'
    set $P786, $N789
    goto if_787_end
  if_787:
.annotate 'line', 356
    find_lex $P790, "$obj"
    find_lex $P791, "%mapping"
    stable_publish_vtable_mapping $P790, $P791
  if_787_end:
.annotate 'line', 345
    .return ($P786)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block754"  :anon :subid("53_1299465710.053") :outer("52_1299465710.053")
    .param pmc param_757
.annotate 'line', 347
    .const 'Sub' $P767 = "54_1299465710.053" 
    capture_lex $P767
.annotate 'line', 348
    $P756 = root_new ['parrot';'Hash']
    .lex "%map", $P756
    .lex "$_", param_757
    find_lex $P758, "$_"
    get_how $P759, $P758
    find_lex $P760, "$_"
    $P761 = $P759."parrot_vtable_mappings"($P760, 1 :named("local"))
    store_lex "%map", $P761
.annotate 'line', 349
    find_lex $P763, "%map"
    defined $I764, $P763
    unless $I764, for_undef_275
    iter $P762, $P763
    new $P781, 'ExceptionHandler'
    set_label $P781, loop780_handler
    $P781."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P781
  loop780_test:
    unless $P762, loop780_done
    shift $P765, $P762
  loop780_redo:
    .const 'Sub' $P767 = "54_1299465710.053" 
    capture_lex $P767
    $P767($P765)
  loop780_next:
    goto loop780_test
  loop780_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P782, exception, 'type'
    eq $P782, .CONTROL_LOOP_NEXT, loop780_next
    eq $P782, .CONTROL_LOOP_REDO, loop780_redo
  loop780_done:
    pop_eh 
  for_undef_275:
.annotate 'line', 347
    .return ($P762)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block766"  :anon :subid("54_1299465710.053") :outer("53_1299465710.053")
    .param pmc param_768
.annotate 'line', 349
    .lex "$_", param_768
.annotate 'line', 350
    find_lex $P771, "$_"
    $P772 = $P771."key"()
    find_lex $P773, "%mapping"
    unless_null $P773, vivify_276
    $P773 = root_new ['parrot';'Hash']
  vivify_276:
    set $P774, $P773[$P772]
    unless_null $P774, vivify_277
    new $P774, "Undef"
  vivify_277:
    unless $P774, unless_770
    set $P769, $P774
    goto unless_770_end
  unless_770:
.annotate 'line', 351
    find_lex $P775, "$_"
    $P776 = $P775."value"()
    find_lex $P777, "$_"
    $P778 = $P777."key"()
    find_lex $P779, "%mapping"
    unless_null $P779, vivify_278
    $P779 = root_new ['parrot';'Hash']
    store_lex "%mapping", $P779
  vivify_278:
    set $P779[$P778], $P776
.annotate 'line', 350
    set $P769, $P776
  unless_770_end:
.annotate 'line', 349
    .return ($P769)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "parents"  :subid("55_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_793
    .param pmc param_794
    .param pmc param_795 :optional :named("local")
    .param int has_param_795 :opt_flag
.annotate 'line', 364
    .lex "self", param_793
    .lex "$obj", param_794
    if has_param_795, optparam_279
    new $P796, "Undef"
    set param_795, $P796
  optparam_279:
    .lex "$local", param_795
.annotate 'line', 365
    find_lex $P799, "$local"
    if $P799, if_798
    find_lex $P803, "self"
    get_global $P804, "$?CLASS"
    getattribute $P805, $P803, $P804, "@!mro"
    unless_null $P805, vivify_280
    $P805 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $P797, $P805
    goto if_798_end
  if_798:
    find_lex $P800, "self"
    get_global $P801, "$?CLASS"
    getattribute $P802, $P800, $P801, "@!parents"
    unless_null $P802, vivify_281
    $P802 = root_new ['parrot';'ResizablePMCArray']
  vivify_281:
    set $P797, $P802
  if_798_end:
.annotate 'line', 364
    .return ($P797)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "roles"  :subid("56_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_807
    .param pmc param_808
    .param pmc param_809 :named("local")
.annotate 'line', 368
    .lex "self", param_807
    .lex "$obj", param_808
    .lex "$local", param_809
    find_lex $P810, "self"
    get_global $P811, "$?CLASS"
    getattribute $P812, $P810, $P811, "@!roles"
    unless_null $P812, vivify_282
    $P812 = root_new ['parrot';'ResizablePMCArray']
  vivify_282:
    .return ($P812)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("57_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_814
    .param pmc param_815
    .param pmc param_816 :named("local")
.annotate 'line', 372
    .const 'Sub' $P826 = "58_1299465710.053" 
    capture_lex $P826
    .lex "self", param_814
    .lex "$obj", param_815
    .lex "$local", param_816
.annotate 'line', 373
    $P817 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P817
.annotate 'line', 372
    find_lex $P818, "@meths"
.annotate 'line', 374
    find_lex $P820, "self"
    get_global $P821, "$?CLASS"
    getattribute $P822, $P820, $P821, "%!methods"
    unless_null $P822, vivify_283
    $P822 = root_new ['parrot';'Hash']
  vivify_283:
    defined $I823, $P822
    unless $I823, for_undef_284
    iter $P819, $P822
    new $P833, 'ExceptionHandler'
    set_label $P833, loop832_handler
    $P833."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P833
  loop832_test:
    unless $P819, loop832_done
    shift $P824, $P819
  loop832_redo:
    .const 'Sub' $P826 = "58_1299465710.053" 
    capture_lex $P826
    $P826($P824)
  loop832_next:
    goto loop832_test
  loop832_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P834, exception, 'type'
    eq $P834, .CONTROL_LOOP_NEXT, loop832_next
    eq $P834, .CONTROL_LOOP_REDO, loop832_redo
  loop832_done:
    pop_eh 
  for_undef_284:
    find_lex $P835, "@meths"
.annotate 'line', 372
    .return ($P835)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block825"  :anon :subid("58_1299465710.053") :outer("57_1299465710.053")
    .param pmc param_827
.annotate 'line', 374
    .lex "$_", param_827
.annotate 'line', 375
    find_lex $P828, "@meths"
    find_lex $P829, "$_"
    $P830 = $P829."value"()
    $P831 = $P828."push"($P830)
.annotate 'line', 374
    .return ($P831)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("59_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_837
    .param pmc param_838
.annotate 'line', 380
    .lex "self", param_837
    .lex "$obj", param_838
    find_lex $P839, "self"
    get_global $P840, "$?CLASS"
    getattribute $P841, $P839, $P840, "%!methods"
    unless_null $P841, vivify_285
    $P841 = root_new ['parrot';'Hash']
  vivify_285:
    .return ($P841)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "name"  :subid("60_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_843
    .param pmc param_844
.annotate 'line', 384
    .lex "self", param_843
    .lex "$obj", param_844
    find_lex $P845, "self"
    get_global $P846, "$?CLASS"
    getattribute $P847, $P845, $P846, "$!name"
    unless_null $P847, vivify_286
    new $P847, "Undef"
  vivify_286:
    .return ($P847)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("61_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_849
    .param pmc param_850
    .param pmc param_851 :named("local")
.annotate 'line', 388
    .const 'Sub' $P861 = "62_1299465710.053" 
    capture_lex $P861
    .lex "self", param_849
    .lex "$obj", param_850
    .lex "$local", param_851
.annotate 'line', 389
    $P852 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P852
.annotate 'line', 388
    find_lex $P853, "@attrs"
.annotate 'line', 390
    find_lex $P855, "self"
    get_global $P856, "$?CLASS"
    getattribute $P857, $P855, $P856, "%!attributes"
    unless_null $P857, vivify_287
    $P857 = root_new ['parrot';'Hash']
  vivify_287:
    defined $I858, $P857
    unless $I858, for_undef_288
    iter $P854, $P857
    new $P868, 'ExceptionHandler'
    set_label $P868, loop867_handler
    $P868."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P868
  loop867_test:
    unless $P854, loop867_done
    shift $P859, $P854
  loop867_redo:
    .const 'Sub' $P861 = "62_1299465710.053" 
    capture_lex $P861
    $P861($P859)
  loop867_next:
    goto loop867_test
  loop867_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P869, exception, 'type'
    eq $P869, .CONTROL_LOOP_NEXT, loop867_next
    eq $P869, .CONTROL_LOOP_REDO, loop867_redo
  loop867_done:
    pop_eh 
  for_undef_288:
    find_lex $P870, "@attrs"
.annotate 'line', 388
    .return ($P870)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block860"  :anon :subid("62_1299465710.053") :outer("61_1299465710.053")
    .param pmc param_862
.annotate 'line', 390
    .lex "$_", param_862
.annotate 'line', 391
    find_lex $P863, "@attrs"
    find_lex $P864, "$_"
    $P865 = $P864."value"()
    $P866 = $P863."push"($P865)
.annotate 'line', 390
    .return ($P866)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "parrot_vtable_mappings"  :subid("63_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_872
    .param pmc param_873
    .param pmc param_874 :named("local")
.annotate 'line', 396
    .lex "self", param_872
    .lex "$obj", param_873
    .lex "$local", param_874
    find_lex $P875, "self"
    get_global $P876, "$?CLASS"
    getattribute $P877, $P875, $P876, "%!parrot_vtable_mapping"
    unless_null $P877, vivify_289
    $P877 = root_new ['parrot';'Hash']
  vivify_289:
    .return ($P877)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("64_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_881
    .param pmc param_882
    .param pmc param_883
.annotate 'line', 404
    new $P880, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P880, control_879
    push_eh $P880
    .lex "self", param_881
    .lex "$obj", param_882
    .lex "$check", param_883
.annotate 'line', 405
    new $P884, "Undef"
    .lex "$check-class", $P884
.annotate 'line', 406
    new $P885, "Undef"
    .lex "$i", $P885
.annotate 'line', 405
    find_lex $P886, "$check"
    get_what $P887, $P886
    store_lex "$check-class", $P887
.annotate 'line', 406
    find_lex $P888, "self"
    get_global $P889, "$?CLASS"
    getattribute $P890, $P888, $P889, "@!mro"
    unless_null $P890, vivify_290
    $P890 = root_new ['parrot';'ResizablePMCArray']
  vivify_290:
    set $N891, $P890
    new $P892, 'Float'
    set $P892, $N891
    store_lex "$i", $P892
.annotate 'line', 407
    new $P910, 'ExceptionHandler'
    set_label $P910, loop909_handler
    $P910."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P910
  loop909_test:
    find_lex $P893, "$i"
    set $N894, $P893
    isgt $I895, $N894, 0.0
    unless $I895, loop909_done
  loop909_redo:
.annotate 'line', 408
    find_lex $P896, "$i"
    sub $P897, $P896, 1
    store_lex "$i", $P897
.annotate 'line', 409
    find_lex $P899, "$i"
    set $I900, $P899
    find_lex $P901, "self"
    get_global $P902, "$?CLASS"
    getattribute $P903, $P901, $P902, "@!mro"
    unless_null $P903, vivify_291
    $P903 = root_new ['parrot';'ResizablePMCArray']
  vivify_291:
    set $P904, $P903[$I900]
    unless_null $P904, vivify_292
    new $P904, "Undef"
  vivify_292:
    find_lex $P905, "$check-class"
    issame $I906, $P904, $P905
    unless $I906, if_898_end
.annotate 'line', 410
    new $P907, "Exception"
    set $P907['type'], .CONTROL_RETURN
    new $P908, "Integer"
    assign $P908, 1
    setattribute $P907, 'payload', $P908
    throw $P907
  if_898_end:
  loop909_next:
.annotate 'line', 407
    goto loop909_test
  loop909_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P911, exception, 'type'
    eq $P911, .CONTROL_LOOP_NEXT, loop909_next
    eq $P911, .CONTROL_LOOP_REDO, loop909_redo
  loop909_done:
    pop_eh 
.annotate 'line', 413
    new $P912, "Exception"
    set $P912['type'], .CONTROL_RETURN
    new $P913, "Integer"
    assign $P913, 0
    setattribute $P912, 'payload', $P913
    throw $P912
.annotate 'line', 404
    .return ()
  control_879:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P914, exception, "payload"
    .return ($P914)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("65_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_918
    .param pmc param_919
    .param pmc param_920
.annotate 'line', 416
    new $P917, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P917, control_916
    push_eh $P917
    .lex "self", param_918
    .lex "$obj", param_919
    .lex "$check", param_920
.annotate 'line', 417
    new $P921, "Undef"
    .lex "$i", $P921
    find_lex $P922, "self"
    get_global $P923, "$?CLASS"
    getattribute $P924, $P922, $P923, "@!done"
    unless_null $P924, vivify_293
    $P924 = root_new ['parrot';'ResizablePMCArray']
  vivify_293:
    set $N925, $P924
    new $P926, 'Float'
    set $P926, $N925
    store_lex "$i", $P926
.annotate 'line', 418
    new $P944, 'ExceptionHandler'
    set_label $P944, loop943_handler
    $P944."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P944
  loop943_test:
    find_lex $P927, "$i"
    set $N928, $P927
    isgt $I929, $N928, 0.0
    unless $I929, loop943_done
  loop943_redo:
.annotate 'line', 419
    find_lex $P930, "$i"
    sub $P931, $P930, 1
    store_lex "$i", $P931
.annotate 'line', 420
    find_lex $P933, "$i"
    set $I934, $P933
    find_lex $P935, "self"
    get_global $P936, "$?CLASS"
    getattribute $P937, $P935, $P936, "@!done"
    unless_null $P937, vivify_294
    $P937 = root_new ['parrot';'ResizablePMCArray']
  vivify_294:
    set $P938, $P937[$I934]
    unless_null $P938, vivify_295
    new $P938, "Undef"
  vivify_295:
    find_lex $P939, "$check"
    issame $I940, $P938, $P939
    unless $I940, if_932_end
.annotate 'line', 421
    new $P941, "Exception"
    set $P941['type'], .CONTROL_RETURN
    new $P942, "Integer"
    assign $P942, 1
    setattribute $P941, 'payload', $P942
    throw $P941
  if_932_end:
  loop943_next:
.annotate 'line', 418
    goto loop943_test
  loop943_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P945, exception, 'type'
    eq $P945, .CONTROL_LOOP_NEXT, loop943_next
    eq $P945, .CONTROL_LOOP_REDO, loop943_redo
  loop943_done:
    pop_eh 
.annotate 'line', 424
    new $P946, "Exception"
    set $P946['type'], .CONTROL_RETURN
    new $P947, "Integer"
    assign $P947, 0
    setattribute $P946, 'payload', $P947
    throw $P946
.annotate 'line', 416
    .return ()
  control_916:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P948, exception, "payload"
    .return ($P948)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("66_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_952
    .param pmc param_953
    .param pmc param_954
.annotate 'line', 427
    .const 'Sub' $P962 = "67_1299465710.053" 
    capture_lex $P962
    new $P951, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P951, control_950
    push_eh $P951
    .lex "self", param_952
    .lex "$obj", param_953
    .lex "$name", param_954
.annotate 'line', 428
    find_lex $P956, "self"
    get_global $P957, "$?CLASS"
    getattribute $P958, $P956, $P957, "@!mro"
    unless_null $P958, vivify_296
    $P958 = root_new ['parrot';'ResizablePMCArray']
  vivify_296:
    defined $I959, $P958
    unless $I959, for_undef_297
    iter $P955, $P958
    new $P980, 'ExceptionHandler'
    set_label $P980, loop979_handler
    $P980."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P980
  loop979_test:
    unless $P955, loop979_done
    shift $P960, $P955
  loop979_redo:
    .const 'Sub' $P962 = "67_1299465710.053" 
    capture_lex $P962
    $P962($P960)
  loop979_next:
    goto loop979_test
  loop979_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P981, exception, 'type'
    eq $P981, .CONTROL_LOOP_NEXT, loop979_next
    eq $P981, .CONTROL_LOOP_REDO, loop979_redo
  loop979_done:
    pop_eh 
  for_undef_297:
.annotate 'line', 435
    new $P982, "Exception"
    set $P982['type'], .CONTROL_RETURN
    new $P983, "Integer"
    assign $P983, 0
    setattribute $P982, 'payload', $P983
    throw $P982
.annotate 'line', 427
    .return ()
  control_950:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P984, exception, "payload"
    .return ($P984)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block961"  :anon :subid("67_1299465710.053") :outer("66_1299465710.053")
    .param pmc param_965
.annotate 'line', 429
    $P963 = root_new ['parrot';'Hash']
    .lex "%meths", $P963
.annotate 'line', 430
    new $P964, "Undef"
    .lex "$can", $P964
    .lex "$_", param_965
.annotate 'line', 429
    find_lex $P966, "$_"
    get_how $P967, $P966
    find_lex $P968, "$obj"
    $P969 = $P967."method_table"($P968)
    store_lex "%meths", $P969
.annotate 'line', 430
    find_lex $P970, "$name"
    find_lex $P971, "%meths"
    unless_null $P971, vivify_298
    $P971 = root_new ['parrot';'Hash']
  vivify_298:
    set $P972, $P971[$P970]
    unless_null $P972, vivify_299
    new $P972, "Undef"
  vivify_299:
    store_lex "$can", $P972
.annotate 'line', 431
    find_lex $P975, "$can"
    defined $I976, $P975
    if $I976, if_974
    new $P973, 'Integer'
    set $P973, $I976
    goto if_974_end
  if_974:
.annotate 'line', 432
    new $P977, "Exception"
    set $P977['type'], .CONTROL_RETURN
    find_lex $P978, "$can"
    setattribute $P977, 'payload', $P978
    throw $P977
  if_974_end:
.annotate 'line', 428
    .return ($P973)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("68_1299465710.053") :outer("15_1299465710.053")
    .param pmc param_988
    .param pmc param_989
    .param pmc param_990
.annotate 'line', 441
    .const 'Sub' $P998 = "69_1299465710.053" 
    capture_lex $P998
    new $P987, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P987, control_986
    push_eh $P987
    .lex "self", param_988
    .lex "$obj", param_989
    .lex "$name", param_990
.annotate 'line', 442
    find_lex $P992, "self"
    get_global $P993, "$?CLASS"
    getattribute $P994, $P992, $P993, "@!mro"
    unless_null $P994, vivify_300
    $P994 = root_new ['parrot';'ResizablePMCArray']
  vivify_300:
    defined $I995, $P994
    unless $I995, for_undef_301
    iter $P991, $P994
    new $P1016, 'ExceptionHandler'
    set_label $P1016, loop1015_handler
    $P1016."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1016
  loop1015_test:
    unless $P991, loop1015_done
    shift $P996, $P991
  loop1015_redo:
    .const 'Sub' $P998 = "69_1299465710.053" 
    capture_lex $P998
    $P998($P996)
  loop1015_next:
    goto loop1015_test
  loop1015_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1017, exception, 'type'
    eq $P1017, .CONTROL_LOOP_NEXT, loop1015_next
    eq $P1017, .CONTROL_LOOP_REDO, loop1015_redo
  loop1015_done:
    pop_eh 
  for_undef_301:
.annotate 'line', 449
    null $P1018
.annotate 'line', 441
    .return ($P1018)
  control_986:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1019, exception, "payload"
    .return ($P1019)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block997"  :anon :subid("69_1299465710.053") :outer("68_1299465710.053")
    .param pmc param_1001
.annotate 'line', 443
    $P999 = root_new ['parrot';'Hash']
    .lex "%meths", $P999
.annotate 'line', 444
    new $P1000, "Undef"
    .lex "$found", $P1000
    .lex "$_", param_1001
.annotate 'line', 443
    find_lex $P1002, "$_"
    get_how $P1003, $P1002
    find_lex $P1004, "$obj"
    $P1005 = $P1003."method_table"($P1004)
    store_lex "%meths", $P1005
.annotate 'line', 444
    find_lex $P1006, "$name"
    find_lex $P1007, "%meths"
    unless_null $P1007, vivify_302
    $P1007 = root_new ['parrot';'Hash']
  vivify_302:
    set $P1008, $P1007[$P1006]
    unless_null $P1008, vivify_303
    new $P1008, "Undef"
  vivify_303:
    store_lex "$found", $P1008
.annotate 'line', 445
    find_lex $P1011, "$found"
    defined $I1012, $P1011
    if $I1012, if_1010
    new $P1009, 'Integer'
    set $P1009, $I1012
    goto if_1010_end
  if_1010:
.annotate 'line', 446
    new $P1013, "Exception"
    set $P1013['type'], .CONTROL_RETURN
    find_lex $P1014, "$found"
    setattribute $P1013, 'payload', $P1014
    throw $P1013
  if_1010_end:
.annotate 'line', 442
    .return ($P1009)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "_block1113"  :subid("71_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 454
    .const 'Sub' $P1174 = "80_1299465710.053" 
    capture_lex $P1174
    .const 'Sub' $P1166 = "79_1299465710.053" 
    capture_lex $P1166
    .const 'Sub' $P1160 = "78_1299465710.053" 
    capture_lex $P1160
    .const 'Sub' $P1156 = "77_1299465710.053" 
    capture_lex $P1156
    .const 'Sub' $P1151 = "76_1299465710.053" 
    capture_lex $P1151
    .const 'Sub' $P1146 = "75_1299465710.053" 
    capture_lex $P1146
    .const 'Sub' $P1133 = "74_1299465710.053" 
    capture_lex $P1133
    .const 'Sub' $P1126 = "73_1299465710.053" 
    capture_lex $P1126
    .const 'Sub' $P1116 = "72_1299465710.053" 
    capture_lex $P1116
    get_global $P1115, "$?CLASS"
.annotate 'line', 492
    .const 'Sub' $P1166 = "79_1299465710.053" 
    newclosure $P1172, $P1166
.annotate 'line', 454
    .return ($P1172)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "" :load :init :subid("post304") :outer("71_1299465710.053")
.annotate 'line', 454
    get_hll_global $P1114, ["NQPNativeHOW"], "_block1113" 
    .local pmc block
    set block, $P1114
    .const 'Sub' $P1174 = "80_1299465710.053" 
    capture_lex $P1174
    $P1174()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "_block1173"  :anon :subid("80_1299465710.053") :outer("71_1299465710.053")
.annotate 'line', 454
    get_hll_global $P1175, "KnowHOW"
    $P1176 = $P1175."new_type"("NQPNativeHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1176
    set_hll_global "NQPNativeHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1177, type_obj
    get_hll_global $P1178, "KnowHOWAttribute"
    $P1179 = $P1178."new"("$!name" :named("name"))
    $P1177."add_attribute"(type_obj, $P1179)
    get_how $P1180, type_obj
    get_hll_global $P1181, "KnowHOWAttribute"
    $P1182 = $P1181."new"("$!composed" :named("name"))
    $P1180."add_attribute"(type_obj, $P1182)
    get_how $P1183, type_obj
    .const 'Sub' $P1184 = "72_1299465710.053" 
    $P1183."add_method"(type_obj, "new", $P1184)
    get_how $P1185, type_obj
    .const 'Sub' $P1186 = "73_1299465710.053" 
    $P1185."add_method"(type_obj, "BUILD", $P1186)
    get_how $P1187, type_obj
    .const 'Sub' $P1188 = "74_1299465710.053" 
    $P1187."add_method"(type_obj, "new_type", $P1188)
    get_how $P1189, type_obj
    .const 'Sub' $P1190 = "75_1299465710.053" 
    $P1189."add_method"(type_obj, "add_method", $P1190)
    get_how $P1191, type_obj
    .const 'Sub' $P1192 = "76_1299465710.053" 
    $P1191."add_method"(type_obj, "add_multi_method", $P1192)
    get_how $P1193, type_obj
    .const 'Sub' $P1194 = "77_1299465710.053" 
    $P1193."add_method"(type_obj, "add_attribute", $P1194)
    get_how $P1195, type_obj
    .const 'Sub' $P1196 = "78_1299465710.053" 
    $P1195."add_method"(type_obj, "compose", $P1196)
    get_how $P1197, type_obj
    .const 'Sub' $P1198 = "79_1299465710.053" 
    $P1197."add_method"(type_obj, "name", $P1198)
    get_how $P1199, type_obj
    $P1200 = $P1199."compose"(type_obj)
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "new"  :subid("72_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1117
    .param pmc param_1118 :optional :named("name")
    .param int has_param_1118 :opt_flag
.annotate 'line', 458
    .lex "self", param_1117
    if has_param_1118, optparam_305
    new $P1119, "Undef"
    set param_1118, $P1119
  optparam_305:
    .lex "$name", param_1118
.annotate 'line', 459
    new $P1120, "Undef"
    .lex "$obj", $P1120
    find_lex $P1121, "self"
    repr_instance_of $P1122, $P1121
    store_lex "$obj", $P1122
.annotate 'line', 460
    find_lex $P1123, "$obj"
    find_lex $P1124, "$name"
    $P1123."BUILD"($P1124 :named("name"))
    find_lex $P1125, "$obj"
.annotate 'line', 458
    .return ($P1125)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "BUILD"  :subid("73_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1127
    .param pmc param_1128 :optional :named("name")
    .param int has_param_1128 :opt_flag
.annotate 'line', 464
    .lex "self", param_1127
    if has_param_1128, optparam_306
    new $P1129, "Undef"
    set param_1128, $P1129
  optparam_306:
    .lex "$name", param_1128
.annotate 'line', 465
    find_lex $P1130, "$name"
    find_lex $P1131, "self"
    get_global $P1132, "$?CLASS"
    setattribute $P1131, $P1132, "$!name", $P1130
.annotate 'line', 464
    .return ($P1130)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "new_type"  :subid("74_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1134
    .param pmc param_1137 :named("repr")
    .param pmc param_1135 :optional :named("name")
    .param int has_param_1135 :opt_flag
.annotate 'line', 471
    .lex "self", param_1134
    if has_param_1135, optparam_307
    new $P1136, "String"
    assign $P1136, "<anon>"
    set param_1135, $P1136
  optparam_307:
    .lex "$name", param_1135
    .lex "$repr", param_1137
.annotate 'line', 472
    new $P1138, "Undef"
    .lex "$metaclass", $P1138
    find_lex $P1139, "self"
    find_lex $P1140, "$name"
    $P1141 = $P1139."new"($P1140 :named("name"))
    store_lex "$metaclass", $P1141
.annotate 'line', 473
    find_lex $P1142, "$metaclass"
    find_lex $P1143, "$repr"
    set $S1144, $P1143
    repr_type_object_for $P1145, $P1142, $S1144
.annotate 'line', 471
    .return ($P1145)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "add_method"  :subid("75_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1147
    .param pmc param_1148
    .param pmc param_1149
    .param pmc param_1150
.annotate 'line', 476
    .lex "self", param_1147
    .lex "$obj", param_1148
    .lex "$name", param_1149
    .lex "$code_obj", param_1150
.annotate 'line', 477
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 476
    .return ()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "add_multi_method"  :subid("76_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1152
    .param pmc param_1153
    .param pmc param_1154
    .param pmc param_1155
.annotate 'line', 480
    .lex "self", param_1152
    .lex "$obj", param_1153
    .lex "$name", param_1154
    .lex "$code_obj", param_1155
.annotate 'line', 481
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 480
    .return ()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "add_attribute"  :subid("77_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1157
    .param pmc param_1158
    .param pmc param_1159
.annotate 'line', 484
    .lex "self", param_1157
    .lex "$obj", param_1158
    .lex "$meta_attr", param_1159
.annotate 'line', 485
    die "Native types may not have attributes"
.annotate 'line', 484
    .return ()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "compose"  :subid("78_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1161
    .param pmc param_1162
.annotate 'line', 488
    .lex "self", param_1161
    .lex "$obj", param_1162
.annotate 'line', 489
    new $P1163, "Integer"
    assign $P1163, 1
    find_lex $P1164, "self"
    get_global $P1165, "$?CLASS"
    setattribute $P1164, $P1165, "$!composed", $P1163
.annotate 'line', 488
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "name"  :subid("79_1299465710.053") :outer("71_1299465710.053")
    .param pmc param_1167
    .param pmc param_1168
.annotate 'line', 492
    .lex "self", param_1167
    .lex "$obj", param_1168
    find_lex $P1169, "self"
    get_global $P1170, "$?CLASS"
    getattribute $P1171, $P1169, $P1170, "$!name"
    unless_null $P1171, vivify_308
    new $P1171, "Undef"
  vivify_308:
    .return ($P1171)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1201"  :subid("81_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 498
    .const 'Sub' $P1385 = "95_1299465710.053" 
    capture_lex $P1385
    .const 'Sub' $P1375 = "94_1299465710.053" 
    capture_lex $P1375
    .const 'Sub' $P1294 = "89_1299465710.053" 
    capture_lex $P1294
    .const 'Sub' $P1285 = "88_1299465710.053" 
    capture_lex $P1285
    .const 'Sub' $P1276 = "87_1299465710.053" 
    capture_lex $P1276
    .const 'Sub' $P1271 = "86_1299465710.053" 
    capture_lex $P1271
    .const 'Sub' $P1254 = "85_1299465710.053" 
    capture_lex $P1254
    .const 'Sub' $P1239 = "84_1299465710.053" 
    capture_lex $P1239
    .const 'Sub' $P1204 = "82_1299465710.053" 
    capture_lex $P1204
    get_global $P1203, "$?CLASS"
.annotate 'line', 558
    .const 'Sub' $P1204 = "82_1299465710.053" 
    newclosure $P1238, $P1204
    .lex "has_method", $P1238
.annotate 'line', 554
    find_lex $P1383, "has_method"
.annotate 'line', 498
    .return ($P1383)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post309") :outer("81_1299465710.053")
.annotate 'line', 498
    get_hll_global $P1202, ["NQPAttribute"], "_block1201" 
    .local pmc block
    set block, $P1202
    .const 'Sub' $P1385 = "95_1299465710.053" 
    capture_lex $P1385
    $P1385()
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1384"  :anon :subid("95_1299465710.053") :outer("81_1299465710.053")
.annotate 'line', 498
    get_hll_global $P1386, "KnowHOW"
    $P1387 = $P1386."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P1387
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1388, type_obj
    get_hll_global $P1389, "KnowHOWAttribute"
    $P1390 = $P1389."new"("$!name" :named("name"))
    $P1388."add_attribute"(type_obj, $P1390)
    get_how $P1391, type_obj
    get_hll_global $P1392, "KnowHOWAttribute"
    $P1393 = $P1392."new"("$!type" :named("name"))
    $P1391."add_attribute"(type_obj, $P1393)
    get_how $P1394, type_obj
    get_hll_global $P1395, "KnowHOWAttribute"
    $P1396 = $P1395."new"("$!box_target" :named("name"))
    $P1394."add_attribute"(type_obj, $P1396)
    get_how $P1397, type_obj
    .const 'Sub' $P1398 = "84_1299465710.053" 
    $P1397."add_method"(type_obj, "new", $P1398)
    get_how $P1399, type_obj
    .const 'Sub' $P1400 = "85_1299465710.053" 
    $P1399."add_method"(type_obj, "BUILD", $P1400)
    get_how $P1401, type_obj
    .const 'Sub' $P1402 = "86_1299465710.053" 
    $P1401."add_method"(type_obj, "name", $P1402)
    get_how $P1403, type_obj
    .const 'Sub' $P1404 = "87_1299465710.053" 
    $P1403."add_method"(type_obj, "type", $P1404)
    get_how $P1405, type_obj
    .const 'Sub' $P1406 = "88_1299465710.053" 
    $P1405."add_method"(type_obj, "box_target", $P1406)
    get_how $P1407, type_obj
    .const 'Sub' $P1408 = "89_1299465710.053" 
    $P1407."add_method"(type_obj, "compose", $P1408)
    get_how $P1409, type_obj
    .const 'Sub' $P1410 = "94_1299465710.053" 
    $P1409."add_method"(type_obj, "has_mutator", $P1410)
    get_how $P1411, type_obj
    $P1412 = $P1411."compose"(type_obj)
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "has_method"  :subid("82_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1207
    .param pmc param_1208
    .param pmc param_1209
.annotate 'line', 558
    .const 'Sub' $P1221 = "83_1299465710.053" 
    capture_lex $P1221
    new $P1206, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1206, control_1205
    push_eh $P1206
    .lex "$target", param_1207
    .lex "$name", param_1208
    .lex "$local", param_1209
.annotate 'line', 559
    $P1210 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P1210
    find_lex $P1211, "$target"
    get_how $P1212, $P1211
    find_lex $P1213, "$target"
    find_lex $P1214, "$local"
    $P1215 = $P1212."methods"($P1213, $P1214 :named("local"))
    store_lex "@methods", $P1215
.annotate 'line', 560
    find_lex $P1217, "@methods"
    defined $I1218, $P1217
    unless $I1218, for_undef_310
    iter $P1216, $P1217
    new $P1233, 'ExceptionHandler'
    set_label $P1233, loop1232_handler
    $P1233."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1233
  loop1232_test:
    unless $P1216, loop1232_done
    shift $P1219, $P1216
  loop1232_redo:
    .const 'Sub' $P1221 = "83_1299465710.053" 
    capture_lex $P1221
    $P1221($P1219)
  loop1232_next:
    goto loop1232_test
  loop1232_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1234, exception, 'type'
    eq $P1234, .CONTROL_LOOP_NEXT, loop1232_next
    eq $P1234, .CONTROL_LOOP_REDO, loop1232_redo
  loop1232_done:
    pop_eh 
  for_undef_310:
.annotate 'line', 563
    new $P1235, "Exception"
    set $P1235['type'], .CONTROL_RETURN
    new $P1236, "Integer"
    assign $P1236, 0
    setattribute $P1235, 'payload', $P1236
    throw $P1235
.annotate 'line', 558
    .return ()
  control_1205:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1237, exception, "payload"
    .return ($P1237)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "_block1220"  :anon :subid("83_1299465710.053") :outer("82_1299465710.053")
    .param pmc param_1222
.annotate 'line', 560
    .lex "$_", param_1222
.annotate 'line', 561
    find_lex $P1225, "$_"
    set $S1226, $P1225
    find_lex $P1227, "$name"
    set $S1228, $P1227
    iseq $I1229, $S1226, $S1228
    if $I1229, if_1224
    new $P1223, 'Integer'
    set $P1223, $I1229
    goto if_1224_end
  if_1224:
    new $P1230, "Exception"
    set $P1230['type'], .CONTROL_RETURN
    new $P1231, "Integer"
    assign $P1231, 1
    setattribute $P1230, 'payload', $P1231
    throw $P1230
  if_1224_end:
.annotate 'line', 560
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "new"  :subid("84_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1240
    .param pmc param_1241 :named("name")
    .param pmc param_1242 :optional :named("type")
    .param int has_param_1242 :opt_flag
    .param pmc param_1244 :optional :named("box_target")
    .param int has_param_1244 :opt_flag
.annotate 'line', 503
    .lex "self", param_1240
    .lex "$name", param_1241
    if has_param_1242, optparam_311
    new $P1243, "Undef"
    set param_1242, $P1243
  optparam_311:
    .lex "$type", param_1242
    if has_param_1244, optparam_312
    new $P1245, "Undef"
    set param_1244, $P1245
  optparam_312:
    .lex "$box_target", param_1244
.annotate 'line', 504
    new $P1246, "Undef"
    .lex "$attr", $P1246
    find_lex $P1247, "self"
    repr_instance_of $P1248, $P1247
    store_lex "$attr", $P1248
.annotate 'line', 505
    find_lex $P1249, "$attr"
    find_lex $P1250, "$name"
    find_lex $P1251, "$type"
    find_lex $P1252, "$box_target"
    $P1249."BUILD"($P1250 :named("name"), $P1251 :named("type"), $P1252 :named("box_target"))
    find_lex $P1253, "$attr"
.annotate 'line', 503
    .return ($P1253)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("85_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1255
    .param pmc param_1256 :optional :named("name")
    .param int has_param_1256 :opt_flag
    .param pmc param_1258 :optional :named("type")
    .param int has_param_1258 :opt_flag
    .param pmc param_1260 :optional :named("box_target")
    .param int has_param_1260 :opt_flag
.annotate 'line', 509
    .lex "self", param_1255
    if has_param_1256, optparam_313
    new $P1257, "Undef"
    set param_1256, $P1257
  optparam_313:
    .lex "$name", param_1256
    if has_param_1258, optparam_314
    new $P1259, "Undef"
    set param_1258, $P1259
  optparam_314:
    .lex "$type", param_1258
    if has_param_1260, optparam_315
    new $P1261, "Undef"
    set param_1260, $P1261
  optparam_315:
    .lex "$box_target", param_1260
.annotate 'line', 510
    find_lex $P1262, "$name"
    find_lex $P1263, "self"
    get_global $P1264, "$?CLASS"
    setattribute $P1263, $P1264, "$!name", $P1262
.annotate 'line', 511
    find_lex $P1265, "$type"
    find_lex $P1266, "self"
    get_global $P1267, "$?CLASS"
    setattribute $P1266, $P1267, "$!type", $P1265
.annotate 'line', 512
    find_lex $P1268, "$box_target"
    find_lex $P1269, "self"
    get_global $P1270, "$?CLASS"
    setattribute $P1269, $P1270, "$!box_target", $P1268
.annotate 'line', 509
    .return ($P1268)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "name"  :subid("86_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1272
.annotate 'line', 515
    .lex "self", param_1272
    find_lex $P1273, "self"
    get_global $P1274, "$?CLASS"
    getattribute $P1275, $P1273, $P1274, "$!name"
    unless_null $P1275, vivify_316
    new $P1275, "Undef"
  vivify_316:
    .return ($P1275)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "type"  :subid("87_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1277
.annotate 'line', 519
    .lex "self", param_1277
.annotate 'line', 520
    find_lex $P1279, "self"
    get_global $P1280, "$?CLASS"
    getattribute $P1281, $P1279, $P1280, "$!type"
    unless_null $P1281, vivify_317
    new $P1281, "Undef"
  vivify_317:
    set $P1278, $P1281
    defined $I1283, $P1278
    if $I1283, default_1282
    null $P1284
    set $P1278, $P1284
  default_1282:
.annotate 'line', 519
    .return ($P1278)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "box_target"  :subid("88_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1286
.annotate 'line', 523
    .lex "self", param_1286
.annotate 'line', 524
    find_lex $P1289, "self"
    get_global $P1290, "$?CLASS"
    getattribute $P1291, $P1289, $P1290, "$!box_target"
    unless_null $P1291, vivify_318
    new $P1291, "Undef"
  vivify_318:
    if $P1291, if_1288
    new $P1293, "Integer"
    assign $P1293, 0
    set $P1287, $P1293
    goto if_1288_end
  if_1288:
    new $P1292, "Integer"
    assign $P1292, 1
    set $P1287, $P1292
  if_1288_end:
.annotate 'line', 523
    .return ($P1287)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "compose"  :subid("89_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1295
    .param pmc param_1296
.annotate 'line', 527
    .const 'Sub' $P1348 = "92_1299465710.053" 
    capture_lex $P1348
    .const 'Sub' $P1308 = "90_1299465710.053" 
    capture_lex $P1308
    .lex "self", param_1295
    .lex "$obj", param_1296
.annotate 'line', 528
    new $P1297, "Undef"
    .lex "$long_name", $P1297
    find_lex $P1298, "self"
    get_global $P1299, "$?CLASS"
    getattribute $P1300, $P1298, $P1299, "$!name"
    unless_null $P1300, vivify_319
    new $P1300, "Undef"
  vivify_319:
    set $S1301, $P1300
    new $P1302, 'String'
    set $P1302, $S1301
    store_lex "$long_name", $P1302
.annotate 'line', 529
    find_lex $P1305, "self"
    $P1306 = $P1305."has_mutator"()
    if $P1306, if_1304
.annotate 'line', 541
    .const 'Sub' $P1348 = "92_1299465710.053" 
    capture_lex $P1348
    $P1374 = $P1348()
    set $P1303, $P1374
.annotate 'line', 529
    goto if_1304_end
  if_1304:
    .const 'Sub' $P1308 = "90_1299465710.053" 
    capture_lex $P1308
    $P1346 = $P1308()
    set $P1303, $P1346
  if_1304_end:
.annotate 'line', 527
    .return ($P1303)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1347"  :anon :subid("92_1299465710.053") :outer("89_1299465710.053")
.annotate 'line', 541
    .const 'Sub' $P1364 = "93_1299465710.053" 
    capture_lex $P1364
.annotate 'line', 542
    new $P1349, "Undef"
    .lex "$method", $P1349
    find_lex $P1350, "$long_name"
    set $S1351, $P1350
    substr $S1352, $S1351, 2
    new $P1353, 'String'
    set $P1353, $S1352
    store_lex "$method", $P1353
.annotate 'line', 543
    find_lex $P1356, "$obj"
    find_lex $P1357, "$method"
    $P1358 = "has_method"($P1356, $P1357, 0)
    unless $P1358, unless_1355
    set $P1354, $P1358
    goto unless_1355_end
  unless_1355:
.annotate 'line', 544
    find_lex $P1359, "$obj"
    get_how $P1360, $P1359
    find_lex $P1361, "$obj"
    find_lex $P1362, "$method"
.annotate 'line', 545
    .const 'Sub' $P1364 = "93_1299465710.053" 
    newclosure $P1372, $P1364
    $P1373 = $P1360."add_method"($P1361, $P1362, $P1372)
.annotate 'line', 543
    set $P1354, $P1373
  unless_1355_end:
.annotate 'line', 541
    .return ($P1354)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1363"  :anon :subid("93_1299465710.053") :outer("92_1299465710.053")
    .param pmc param_1365
.annotate 'line', 545
    .lex "self", param_1365
.annotate 'line', 546
    find_lex $P1366, "self"
    find_lex $P1367, "$obj"
    get_what $P1368, $P1367
    find_lex $P1369, "$long_name"
    set $S1370, $P1369
    getattribute $P1371, $P1366, $P1368, $S1370
.annotate 'line', 545
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1307"  :anon :subid("90_1299465710.053") :outer("89_1299465710.053")
.annotate 'line', 529
    .const 'Sub' $P1325 = "91_1299465710.053" 
    capture_lex $P1325
.annotate 'line', 530
    new $P1309, "Undef"
    .lex "$method", $P1309
    find_lex $P1310, "$long_name"
    set $S1311, $P1310
    substr $S1312, $S1311, 1
    new $P1313, 'String'
    set $P1313, $S1312
    store_lex "$method", $P1313
.annotate 'line', 531
    find_lex $P1316, "$obj"
    find_lex $P1317, "$method"
    $P1318 = "has_method"($P1316, $P1317, 0)
    unless $P1318, unless_1315
    set $P1314, $P1318
    goto unless_1315_end
  unless_1315:
.annotate 'line', 532
    find_lex $P1319, "$obj"
    get_how $P1320, $P1319
    find_lex $P1321, "$obj"
    get_what $P1322, $P1321
    find_lex $P1323, "$method"
    .const 'Sub' $P1325 = "91_1299465710.053" 
    newclosure $P1344, $P1325
    $P1345 = $P1320."add_method"($P1322, $P1323, $P1344)
.annotate 'line', 531
    set $P1314, $P1345
  unless_1315_end:
.annotate 'line', 529
    .return ($P1314)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1324"  :anon :subid("91_1299465710.053") :outer("90_1299465710.053")
    .param pmc param_1326
    .param pmc param_1327 :optional
    .param int has_param_1327 :opt_flag
.annotate 'line', 532
    .lex "self", param_1326
    if has_param_1327, optparam_320
    new $P1328, "Undef"
    set param_1327, $P1328
  optparam_320:
    .lex "$value", param_1327
.annotate 'line', 534
    find_lex $P1330, "$value"
    defined $I1331, $P1330
    unless $I1331, if_1329_end
.annotate 'line', 533
    find_lex $P1332, "self"
    find_lex $P1333, "$obj"
    get_what $P1334, $P1333
    find_lex $P1335, "$long_name"
    set $S1336, $P1335
    find_lex $P1337, "$value"
    setattribute $P1332, $P1334, $S1336, $P1337
  if_1329_end:
.annotate 'line', 536
    find_lex $P1338, "self"
    find_lex $P1339, "$obj"
    get_what $P1340, $P1339
    find_lex $P1341, "$long_name"
    set $S1342, $P1341
    getattribute $P1343, $P1338, $P1340, $S1342
.annotate 'line', 532
    .return ($P1343)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "has_mutator"  :subid("94_1299465710.053") :outer("81_1299465710.053")
    .param pmc param_1376
.annotate 'line', 554
    .lex "self", param_1376
.annotate 'line', 555
    find_lex $P1377, "self"
    get_global $P1378, "$?CLASS"
    getattribute $P1379, $P1377, $P1378, "$!name"
    unless_null $P1379, vivify_321
    new $P1379, "Undef"
  vivify_321:
    set $S1380, $P1379
    substr $S1381, $S1380, 1, 1
    isne $I1382, $S1381, "!"
.annotate 'line', 554
    .return ($I1382)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1413"  :subid("96_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 571
    .const 'Sub' $P1669 = "117_1299465710.053" 
    capture_lex $P1669
    .const 'Sub' $P1661 = "116_1299465710.053" 
    capture_lex $P1661
    .const 'Sub' $P1655 = "115_1299465710.053" 
    capture_lex $P1655
    .const 'Sub' $P1633 = "113_1299465710.053" 
    capture_lex $P1633
    .const 'Sub' $P1627 = "112_1299465710.053" 
    capture_lex $P1627
    .const 'Sub' $P1621 = "111_1299465710.053" 
    capture_lex $P1621
    .const 'Sub' $P1615 = "110_1299465710.053" 
    capture_lex $P1615
    .const 'Sub' $P1593 = "108_1299465710.053" 
    capture_lex $P1593
    .const 'Sub' $P1544 = "106_1299465710.053" 
    capture_lex $P1544
    .const 'Sub' $P1531 = "105_1299465710.053" 
    capture_lex $P1531
    .const 'Sub' $P1518 = "104_1299465710.053" 
    capture_lex $P1518
    .const 'Sub' $P1514 = "103_1299465710.053" 
    capture_lex $P1514
    .const 'Sub' $P1493 = "102_1299465710.053" 
    capture_lex $P1493
    .const 'Sub' $P1472 = "101_1299465710.053" 
    capture_lex $P1472
    .const 'Sub' $P1453 = "100_1299465710.053" 
    capture_lex $P1453
    .const 'Sub' $P1437 = "99_1299465710.053" 
    capture_lex $P1437
    .const 'Sub' $P1427 = "98_1299465710.053" 
    capture_lex $P1427
    .const 'Sub' $P1416 = "97_1299465710.053" 
    capture_lex $P1416
    get_global $P1415, "$?CLASS"
.annotate 'line', 710
    .const 'Sub' $P1661 = "116_1299465710.053" 
    newclosure $P1667, $P1661
.annotate 'line', 571
    .return ($P1667)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "" :load :init :subid("post322") :outer("96_1299465710.053")
.annotate 'line', 571
    get_hll_global $P1414, ["NQPConcreteRoleHOW"], "_block1413" 
    .local pmc block
    set block, $P1414
    .const 'Sub' $P1669 = "117_1299465710.053" 
    capture_lex $P1669
    $P1669()
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1668"  :anon :subid("117_1299465710.053") :outer("96_1299465710.053")
.annotate 'line', 571
    get_hll_global $P1670, "KnowHOW"
    $P1671 = $P1670."new_type"("NQPConcreteRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1671
    set_hll_global "NQPConcreteRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1672, type_obj
    get_hll_global $P1673, "KnowHOWAttribute"
    $P1674 = $P1673."new"("$!name" :named("name"))
    $P1672."add_attribute"(type_obj, $P1674)
    get_how $P1675, type_obj
    get_hll_global $P1676, "KnowHOWAttribute"
    $P1677 = $P1676."new"("$!instance_of" :named("name"))
    $P1675."add_attribute"(type_obj, $P1677)
    get_how $P1678, type_obj
    get_hll_global $P1679, "KnowHOWAttribute"
    $P1680 = $P1679."new"("%!attributes" :named("name"))
    $P1678."add_attribute"(type_obj, $P1680)
    get_how $P1681, type_obj
    get_hll_global $P1682, "KnowHOWAttribute"
    $P1683 = $P1682."new"("%!methods" :named("name"))
    $P1681."add_attribute"(type_obj, $P1683)
    get_how $P1684, type_obj
    get_hll_global $P1685, "KnowHOWAttribute"
    $P1686 = $P1685."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1684."add_attribute"(type_obj, $P1686)
    get_how $P1687, type_obj
    get_hll_global $P1688, "KnowHOWAttribute"
    $P1689 = $P1688."new"("@!collisions" :named("name"))
    $P1687."add_attribute"(type_obj, $P1689)
    get_how $P1690, type_obj
    get_hll_global $P1691, "KnowHOWAttribute"
    $P1692 = $P1691."new"("@!roles" :named("name"))
    $P1690."add_attribute"(type_obj, $P1692)
    get_how $P1693, type_obj
    get_hll_global $P1694, "KnowHOWAttribute"
    $P1695 = $P1694."new"("@!done" :named("name"))
    $P1693."add_attribute"(type_obj, $P1695)
    get_how $P1696, type_obj
    get_hll_global $P1697, "KnowHOWAttribute"
    $P1698 = $P1697."new"("$!composed" :named("name"))
    $P1696."add_attribute"(type_obj, $P1698)
    get_how $P1699, type_obj
    .const 'Sub' $P1700 = "97_1299465710.053" 
    $P1699."add_method"(type_obj, "new", $P1700)
    get_how $P1701, type_obj
    .const 'Sub' $P1702 = "98_1299465710.053" 
    $P1701."add_method"(type_obj, "BUILD", $P1702)
    get_how $P1703, type_obj
    .const 'Sub' $P1704 = "99_1299465710.053" 
    $P1703."add_method"(type_obj, "new_type", $P1704)
    get_how $P1705, type_obj
    .const 'Sub' $P1706 = "100_1299465710.053" 
    $P1705."add_method"(type_obj, "add_method", $P1706)
    get_how $P1707, type_obj
    .const 'Sub' $P1708 = "101_1299465710.053" 
    $P1707."add_method"(type_obj, "add_multi_method", $P1708)
    get_how $P1709, type_obj
    .const 'Sub' $P1710 = "102_1299465710.053" 
    $P1709."add_method"(type_obj, "add_attribute", $P1710)
    get_how $P1711, type_obj
    .const 'Sub' $P1712 = "103_1299465710.053" 
    $P1711."add_method"(type_obj, "add_parent", $P1712)
    get_how $P1713, type_obj
    .const 'Sub' $P1714 = "104_1299465710.053" 
    $P1713."add_method"(type_obj, "add_role", $P1714)
    get_how $P1715, type_obj
    .const 'Sub' $P1716 = "105_1299465710.053" 
    $P1715."add_method"(type_obj, "add_collision", $P1716)
    get_how $P1717, type_obj
    .const 'Sub' $P1718 = "106_1299465710.053" 
    $P1717."add_method"(type_obj, "compose", $P1718)
    get_how $P1719, type_obj
    .const 'Sub' $P1720 = "108_1299465710.053" 
    $P1719."add_method"(type_obj, "methods", $P1720)
    get_how $P1721, type_obj
    .const 'Sub' $P1722 = "110_1299465710.053" 
    $P1721."add_method"(type_obj, "method_table", $P1722)
    get_how $P1723, type_obj
    .const 'Sub' $P1724 = "111_1299465710.053" 
    $P1723."add_method"(type_obj, "collisions", $P1724)
    get_how $P1725, type_obj
    .const 'Sub' $P1726 = "112_1299465710.053" 
    $P1725."add_method"(type_obj, "name", $P1726)
    get_how $P1727, type_obj
    .const 'Sub' $P1728 = "113_1299465710.053" 
    $P1727."add_method"(type_obj, "attributes", $P1728)
    get_how $P1729, type_obj
    .const 'Sub' $P1730 = "115_1299465710.053" 
    $P1729."add_method"(type_obj, "roles", $P1730)
    get_how $P1731, type_obj
    .const 'Sub' $P1732 = "116_1299465710.053" 
    $P1731."add_method"(type_obj, "instance_of", $P1732)
    get_how $P1733, type_obj
    $P1734 = $P1733."compose"(type_obj)
    .return ($P1734)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "new"  :subid("97_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1417
    .param pmc param_1418 :named("name")
    .param pmc param_1419 :named("instance_of")
.annotate 'line', 603
    .lex "self", param_1417
    .lex "$name", param_1418
    .lex "$instance_of", param_1419
.annotate 'line', 604
    new $P1420, "Undef"
    .lex "$obj", $P1420
    find_lex $P1421, "self"
    repr_instance_of $P1422, $P1421
    store_lex "$obj", $P1422
.annotate 'line', 605
    find_lex $P1423, "$obj"
    find_lex $P1424, "$name"
    find_lex $P1425, "$instance_of"
    $P1423."BUILD"($P1424 :named("name"), $P1425 :named("instance_of"))
    find_lex $P1426, "$obj"
.annotate 'line', 603
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "BUILD"  :subid("98_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1428
    .param pmc param_1429 :named("name")
    .param pmc param_1430 :named("instance_of")
.annotate 'line', 609
    .lex "self", param_1428
    .lex "$name", param_1429
    .lex "$instance_of", param_1430
.annotate 'line', 610
    find_lex $P1431, "$name"
    find_lex $P1432, "self"
    get_global $P1433, "$?CLASS"
    setattribute $P1432, $P1433, "$!name", $P1431
.annotate 'line', 611
    find_lex $P1434, "$instance_of"
    find_lex $P1435, "self"
    get_global $P1436, "$?CLASS"
    setattribute $P1435, $P1436, "$!instance_of", $P1434
.annotate 'line', 609
    .return ($P1434)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "new_type"  :subid("99_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1438
    .param pmc param_1443 :named("instance_of")
    .param pmc param_1439 :optional :named("name")
    .param int has_param_1439 :opt_flag
    .param pmc param_1441 :optional :named("repr")
    .param int has_param_1441 :opt_flag
.annotate 'line', 616
    .lex "self", param_1438
    if has_param_1439, optparam_323
    new $P1440, "String"
    assign $P1440, "<anon>"
    set param_1439, $P1440
  optparam_323:
    .lex "$name", param_1439
    if has_param_1441, optparam_324
    new $P1442, "String"
    assign $P1442, "P6opaque"
    set param_1441, $P1442
  optparam_324:
    .lex "$repr", param_1441
    .lex "$instance_of", param_1443
.annotate 'line', 617
    new $P1444, "Undef"
    .lex "$metarole", $P1444
    find_lex $P1445, "self"
    find_lex $P1446, "$name"
    find_lex $P1447, "$instance_of"
    $P1448 = $P1445."new"($P1446 :named("name"), $P1447 :named("instance_of"))
    store_lex "$metarole", $P1448
.annotate 'line', 618
    find_lex $P1449, "$metarole"
    find_lex $P1450, "$repr"
    set $S1451, $P1450
    repr_type_object_for $P1452, $P1449, $S1451
.annotate 'line', 616
    .return ($P1452)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_method"  :subid("100_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1454
    .param pmc param_1455
    .param pmc param_1456
    .param pmc param_1457
.annotate 'line', 621
    .lex "self", param_1454
    .lex "$obj", param_1455
    .lex "$name", param_1456
    .lex "$code_obj", param_1457
.annotate 'line', 622
    find_lex $P1459, "$name"
    find_lex $P1460, "self"
    get_global $P1461, "$?CLASS"
    getattribute $P1462, $P1460, $P1461, "%!methods"
    unless_null $P1462, vivify_325
    $P1462 = root_new ['parrot';'Hash']
  vivify_325:
    set $P1463, $P1462[$P1459]
    unless_null $P1463, vivify_326
    new $P1463, "Undef"
  vivify_326:
    unless $P1463, if_1458_end
.annotate 'line', 623
    new $P1464, "String"
    assign $P1464, "This role already has a method named "
    find_lex $P1465, "$name"
    concat $P1466, $P1464, $P1465
    die $P1466
  if_1458_end:
.annotate 'line', 625
    find_lex $P1467, "$code_obj"
    find_lex $P1468, "$name"
    find_lex $P1469, "self"
    get_global $P1470, "$?CLASS"
    getattribute $P1471, $P1469, $P1470, "%!methods"
    unless_null $P1471, vivify_327
    $P1471 = root_new ['parrot';'Hash']
    setattribute $P1469, $P1470, "%!methods", $P1471
  vivify_327:
    set $P1471[$P1468], $P1467
.annotate 'line', 621
    .return ($P1467)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_multi_method"  :subid("101_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1473
    .param pmc param_1474
    .param pmc param_1475
    .param pmc param_1476
.annotate 'line', 628
    .lex "self", param_1473
    .lex "$obj", param_1474
    .lex "$name", param_1475
    .lex "$code_obj", param_1476
.annotate 'line', 629
    $P1477 = root_new ['parrot';'Hash']
    .lex "%todo", $P1477
.annotate 'line', 628
    find_lex $P1478, "%todo"
.annotate 'line', 630
    find_lex $P1479, "$name"
    find_lex $P1480, "%todo"
    unless_null $P1480, vivify_328
    $P1480 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1480
  vivify_328:
    set $P1480["name"], $P1479
.annotate 'line', 631
    find_lex $P1481, "$code_obj"
    find_lex $P1482, "%todo"
    unless_null $P1482, vivify_329
    $P1482 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1482
  vivify_329:
    set $P1482["code"], $P1481
.annotate 'line', 632
    find_lex $P1483, "%todo"
    find_lex $P1484, "self"
    get_global $P1485, "$?CLASS"
    getattribute $P1486, $P1484, $P1485, "@!multi_methods_to_incorporate"
    unless_null $P1486, vivify_330
    $P1486 = root_new ['parrot';'ResizablePMCArray']
  vivify_330:
    set $N1487, $P1486
    set $I1488, $N1487
    find_lex $P1489, "self"
    get_global $P1490, "$?CLASS"
    getattribute $P1491, $P1489, $P1490, "@!multi_methods_to_incorporate"
    unless_null $P1491, vivify_331
    $P1491 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1489, $P1490, "@!multi_methods_to_incorporate", $P1491
  vivify_331:
    set $P1491[$I1488], $P1483
    find_lex $P1492, "$code_obj"
.annotate 'line', 628
    .return ($P1492)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_attribute"  :subid("102_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1494
    .param pmc param_1495
    .param pmc param_1496
.annotate 'line', 636
    .lex "self", param_1494
    .lex "$obj", param_1495
    .lex "$meta_attr", param_1496
.annotate 'line', 637
    new $P1497, "Undef"
    .lex "$name", $P1497
    find_lex $P1498, "$meta_attr"
    $P1499 = $P1498."name"()
    store_lex "$name", $P1499
.annotate 'line', 638
    find_lex $P1501, "$name"
    find_lex $P1502, "self"
    get_global $P1503, "$?CLASS"
    getattribute $P1504, $P1502, $P1503, "%!attributes"
    unless_null $P1504, vivify_332
    $P1504 = root_new ['parrot';'Hash']
  vivify_332:
    set $P1505, $P1504[$P1501]
    unless_null $P1505, vivify_333
    new $P1505, "Undef"
  vivify_333:
    unless $P1505, if_1500_end
.annotate 'line', 639
    new $P1506, "String"
    assign $P1506, "This role already has an attribute named "
    find_lex $P1507, "$name"
    concat $P1508, $P1506, $P1507
    die $P1508
  if_1500_end:
.annotate 'line', 641
    find_lex $P1509, "$meta_attr"
    find_lex $P1510, "$name"
    find_lex $P1511, "self"
    get_global $P1512, "$?CLASS"
    getattribute $P1513, $P1511, $P1512, "%!attributes"
    unless_null $P1513, vivify_334
    $P1513 = root_new ['parrot';'Hash']
    setattribute $P1511, $P1512, "%!attributes", $P1513
  vivify_334:
    set $P1513[$P1510], $P1509
.annotate 'line', 636
    .return ($P1509)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_parent"  :subid("103_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1515
    .param pmc param_1516
    .param pmc param_1517
.annotate 'line', 644
    .lex "self", param_1515
    .lex "$obj", param_1516
    .lex "$parent", param_1517
.annotate 'line', 645
    die "A role cannot inherit from a class in NQP"
.annotate 'line', 644
    .return ()
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_role"  :subid("104_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1519
    .param pmc param_1520
    .param pmc param_1521
.annotate 'line', 648
    .lex "self", param_1519
    .lex "$obj", param_1520
    .lex "$role", param_1521
.annotate 'line', 649
    find_lex $P1522, "$role"
    find_lex $P1523, "self"
    get_global $P1524, "$?CLASS"
    getattribute $P1525, $P1523, $P1524, "@!roles"
    unless_null $P1525, vivify_335
    $P1525 = root_new ['parrot';'ResizablePMCArray']
  vivify_335:
    set $N1526, $P1525
    set $I1527, $N1526
    find_lex $P1528, "self"
    get_global $P1529, "$?CLASS"
    getattribute $P1530, $P1528, $P1529, "@!roles"
    unless_null $P1530, vivify_336
    $P1530 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1528, $P1529, "@!roles", $P1530
  vivify_336:
    set $P1530[$I1527], $P1522
.annotate 'line', 648
    .return ($P1522)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_collision"  :subid("105_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1532
    .param pmc param_1533
    .param pmc param_1534
.annotate 'line', 652
    .lex "self", param_1532
    .lex "$obj", param_1533
    .lex "$colliding_name", param_1534
.annotate 'line', 653
    find_lex $P1535, "$colliding_name"
    find_lex $P1536, "self"
    get_global $P1537, "$?CLASS"
    getattribute $P1538, $P1536, $P1537, "@!collisions"
    unless_null $P1538, vivify_337
    $P1538 = root_new ['parrot';'ResizablePMCArray']
  vivify_337:
    set $N1539, $P1538
    set $I1540, $N1539
    find_lex $P1541, "self"
    get_global $P1542, "$?CLASS"
    getattribute $P1543, $P1541, $P1542, "@!collisions"
    unless_null $P1543, vivify_338
    $P1543 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1541, $P1542, "@!collisions", $P1543
  vivify_338:
    set $P1543[$I1540], $P1535
.annotate 'line', 652
    .return ($P1535)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("106_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1545
    .param pmc param_1546
.annotate 'line', 657
    .const 'Sub' $P1558 = "107_1299465710.053" 
    capture_lex $P1558
    .lex "self", param_1545
    .lex "$obj", param_1546
.annotate 'line', 660
    find_lex $P1548, "self"
    get_global $P1549, "$?CLASS"
    getattribute $P1550, $P1548, $P1549, "@!roles"
    unless_null $P1550, vivify_339
    $P1550 = root_new ['parrot';'ResizablePMCArray']
  vivify_339:
    unless $P1550, if_1547_end
.annotate 'line', 661
    find_lex $P1552, "self"
    get_global $P1553, "$?CLASS"
    getattribute $P1554, $P1552, $P1553, "@!roles"
    unless_null $P1554, vivify_340
    $P1554 = root_new ['parrot';'ResizablePMCArray']
  vivify_340:
    defined $I1555, $P1554
    unless $I1555, for_undef_341
    iter $P1551, $P1554
    new $P1582, 'ExceptionHandler'
    set_label $P1582, loop1581_handler
    $P1582."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1582
  loop1581_test:
    unless $P1551, loop1581_done
    shift $P1556, $P1551
  loop1581_redo:
    .const 'Sub' $P1558 = "107_1299465710.053" 
    capture_lex $P1558
    $P1558($P1556)
  loop1581_next:
    goto loop1581_test
  loop1581_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1583, exception, 'type'
    eq $P1583, .CONTROL_LOOP_NEXT, loop1581_next
    eq $P1583, .CONTROL_LOOP_REDO, loop1581_redo
  loop1581_done:
    pop_eh 
  for_undef_341:
.annotate 'line', 665
    get_hll_global $P1584, "RoleToRoleApplier"
    find_lex $P1585, "$obj"
    find_lex $P1586, "self"
    get_global $P1587, "$?CLASS"
    getattribute $P1588, $P1586, $P1587, "@!roles"
    unless_null $P1588, vivify_346
    $P1588 = root_new ['parrot';'ResizablePMCArray']
  vivify_346:
    $P1584."apply"($P1585, $P1588)
  if_1547_end:
.annotate 'line', 669
    new $P1589, "Integer"
    assign $P1589, 1
    find_lex $P1590, "self"
    get_global $P1591, "$?CLASS"
    setattribute $P1590, $P1591, "$!composed", $P1589
    find_lex $P1592, "$obj"
.annotate 'line', 657
    .return ($P1592)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1557"  :anon :subid("107_1299465710.053") :outer("106_1299465710.053")
    .param pmc param_1559
.annotate 'line', 661
    .lex "$_", param_1559
.annotate 'line', 662
    find_lex $P1560, "$_"
    find_lex $P1561, "self"
    get_global $P1562, "$?CLASS"
    getattribute $P1563, $P1561, $P1562, "@!done"
    unless_null $P1563, vivify_342
    $P1563 = root_new ['parrot';'ResizablePMCArray']
  vivify_342:
    set $N1564, $P1563
    set $I1565, $N1564
    find_lex $P1566, "self"
    get_global $P1567, "$?CLASS"
    getattribute $P1568, $P1566, $P1567, "@!done"
    unless_null $P1568, vivify_343
    $P1568 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1566, $P1567, "@!done", $P1568
  vivify_343:
    set $P1568[$I1565], $P1560
.annotate 'line', 663
    find_lex $P1569, "$_"
    get_how $P1570, $P1569
    find_lex $P1571, "$_"
    $P1572 = $P1570."instance_of"($P1571)
    find_lex $P1573, "self"
    get_global $P1574, "$?CLASS"
    getattribute $P1575, $P1573, $P1574, "@!done"
    unless_null $P1575, vivify_344
    $P1575 = root_new ['parrot';'ResizablePMCArray']
  vivify_344:
    set $N1576, $P1575
    set $I1577, $N1576
    find_lex $P1578, "self"
    get_global $P1579, "$?CLASS"
    getattribute $P1580, $P1578, $P1579, "@!done"
    unless_null $P1580, vivify_345
    $P1580 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1578, $P1579, "@!done", $P1580
  vivify_345:
    set $P1580[$I1577], $P1572
.annotate 'line', 661
    .return ($P1572)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("108_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1594
    .param pmc param_1595
.annotate 'line', 678
    .const 'Sub' $P1605 = "109_1299465710.053" 
    capture_lex $P1605
    .lex "self", param_1594
    .lex "$obj", param_1595
.annotate 'line', 679
    $P1596 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1596
.annotate 'line', 678
    find_lex $P1597, "@meths"
.annotate 'line', 680
    find_lex $P1599, "self"
    get_global $P1600, "$?CLASS"
    getattribute $P1601, $P1599, $P1600, "%!methods"
    unless_null $P1601, vivify_347
    $P1601 = root_new ['parrot';'Hash']
  vivify_347:
    defined $I1602, $P1601
    unless $I1602, for_undef_348
    iter $P1598, $P1601
    new $P1612, 'ExceptionHandler'
    set_label $P1612, loop1611_handler
    $P1612."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1612
  loop1611_test:
    unless $P1598, loop1611_done
    shift $P1603, $P1598
  loop1611_redo:
    .const 'Sub' $P1605 = "109_1299465710.053" 
    capture_lex $P1605
    $P1605($P1603)
  loop1611_next:
    goto loop1611_test
  loop1611_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1613, exception, 'type'
    eq $P1613, .CONTROL_LOOP_NEXT, loop1611_next
    eq $P1613, .CONTROL_LOOP_REDO, loop1611_redo
  loop1611_done:
    pop_eh 
  for_undef_348:
    find_lex $P1614, "@meths"
.annotate 'line', 678
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1604"  :anon :subid("109_1299465710.053") :outer("108_1299465710.053")
    .param pmc param_1606
.annotate 'line', 680
    .lex "$_", param_1606
.annotate 'line', 681
    find_lex $P1607, "@meths"
    find_lex $P1608, "$_"
    $P1609 = $P1608."value"()
    $P1610 = $P1607."push"($P1609)
.annotate 'line', 680
    .return ($P1610)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "method_table"  :subid("110_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1616
    .param pmc param_1617
.annotate 'line', 686
    .lex "self", param_1616
    .lex "$obj", param_1617
    find_lex $P1618, "self"
    get_global $P1619, "$?CLASS"
    getattribute $P1620, $P1618, $P1619, "%!methods"
    unless_null $P1620, vivify_349
    $P1620 = root_new ['parrot';'Hash']
  vivify_349:
    .return ($P1620)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "collisions"  :subid("111_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1622
    .param pmc param_1623
.annotate 'line', 690
    .lex "self", param_1622
    .lex "$obj", param_1623
    find_lex $P1624, "self"
    get_global $P1625, "$?CLASS"
    getattribute $P1626, $P1624, $P1625, "@!collisions"
    unless_null $P1626, vivify_350
    $P1626 = root_new ['parrot';'ResizablePMCArray']
  vivify_350:
    .return ($P1626)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "name"  :subid("112_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1628
    .param pmc param_1629
.annotate 'line', 694
    .lex "self", param_1628
    .lex "$obj", param_1629
    find_lex $P1630, "self"
    get_global $P1631, "$?CLASS"
    getattribute $P1632, $P1630, $P1631, "$!name"
    unless_null $P1632, vivify_351
    new $P1632, "Undef"
  vivify_351:
    .return ($P1632)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("113_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1634
    .param pmc param_1635
.annotate 'line', 698
    .const 'Sub' $P1645 = "114_1299465710.053" 
    capture_lex $P1645
    .lex "self", param_1634
    .lex "$obj", param_1635
.annotate 'line', 699
    $P1636 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1636
.annotate 'line', 698
    find_lex $P1637, "@attrs"
.annotate 'line', 700
    find_lex $P1639, "self"
    get_global $P1640, "$?CLASS"
    getattribute $P1641, $P1639, $P1640, "%!attributes"
    unless_null $P1641, vivify_352
    $P1641 = root_new ['parrot';'Hash']
  vivify_352:
    defined $I1642, $P1641
    unless $I1642, for_undef_353
    iter $P1638, $P1641
    new $P1652, 'ExceptionHandler'
    set_label $P1652, loop1651_handler
    $P1652."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1652
  loop1651_test:
    unless $P1638, loop1651_done
    shift $P1643, $P1638
  loop1651_redo:
    .const 'Sub' $P1645 = "114_1299465710.053" 
    capture_lex $P1645
    $P1645($P1643)
  loop1651_next:
    goto loop1651_test
  loop1651_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1653, exception, 'type'
    eq $P1653, .CONTROL_LOOP_NEXT, loop1651_next
    eq $P1653, .CONTROL_LOOP_REDO, loop1651_redo
  loop1651_done:
    pop_eh 
  for_undef_353:
    find_lex $P1654, "@attrs"
.annotate 'line', 698
    .return ($P1654)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1644"  :anon :subid("114_1299465710.053") :outer("113_1299465710.053")
    .param pmc param_1646
.annotate 'line', 700
    .lex "$_", param_1646
.annotate 'line', 701
    find_lex $P1647, "@attrs"
    find_lex $P1648, "$_"
    $P1649 = $P1648."value"()
    $P1650 = $P1647."push"($P1649)
.annotate 'line', 700
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "roles"  :subid("115_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1656
    .param pmc param_1657
.annotate 'line', 706
    .lex "self", param_1656
    .lex "$obj", param_1657
    find_lex $P1658, "self"
    get_global $P1659, "$?CLASS"
    getattribute $P1660, $P1658, $P1659, "@!roles"
    unless_null $P1660, vivify_354
    $P1660 = root_new ['parrot';'ResizablePMCArray']
  vivify_354:
    .return ($P1660)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "instance_of"  :subid("116_1299465710.053") :outer("96_1299465710.053")
    .param pmc param_1662
    .param pmc param_1663
.annotate 'line', 710
    .lex "self", param_1662
    .lex "$obj", param_1663
    find_lex $P1664, "self"
    get_global $P1665, "$?CLASS"
    getattribute $P1666, $P1664, $P1665, "$!instance_of"
    unless_null $P1666, vivify_355
    new $P1666, "Undef"
  vivify_355:
    .return ($P1666)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1735"  :subid("118_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 720
    .const 'Sub' $P2033 = "141_1299465710.053" 
    capture_lex $P2033
    .const 'Sub' $P2025 = "140_1299465710.053" 
    capture_lex $P2025
    .const 'Sub' $P2003 = "138_1299465710.053" 
    capture_lex $P2003
    .const 'Sub' $P1997 = "137_1299465710.053" 
    capture_lex $P1997
    .const 'Sub' $P1991 = "136_1299465710.053" 
    capture_lex $P1991
    .const 'Sub' $P1969 = "134_1299465710.053" 
    capture_lex $P1969
    .const 'Sub' $P1863 = "129_1299465710.053" 
    capture_lex $P1863
    .const 'Sub' $P1860 = "128_1299465710.053" 
    capture_lex $P1860
    .const 'Sub' $P1853 = "127_1299465710.053" 
    capture_lex $P1853
    .const 'Sub' $P1840 = "126_1299465710.053" 
    capture_lex $P1840
    .const 'Sub' $P1836 = "125_1299465710.053" 
    capture_lex $P1836
    .const 'Sub' $P1815 = "124_1299465710.053" 
    capture_lex $P1815
    .const 'Sub' $P1794 = "123_1299465710.053" 
    capture_lex $P1794
    .const 'Sub' $P1775 = "122_1299465710.053" 
    capture_lex $P1775
    .const 'Sub' $P1759 = "121_1299465710.053" 
    capture_lex $P1759
    .const 'Sub' $P1749 = "120_1299465710.053" 
    capture_lex $P1749
    .const 'Sub' $P1738 = "119_1299465710.053" 
    capture_lex $P1738
    get_global $P1737, "$?CLASS"
.annotate 'line', 880
    .const 'Sub' $P2025 = "140_1299465710.053" 
    newclosure $P2031, $P2025
.annotate 'line', 720
    .return ($P2031)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "" :load :init :subid("post356") :outer("118_1299465710.053")
.annotate 'line', 720
    get_hll_global $P1736, ["NQPParametricRoleHOW"], "_block1735" 
    .local pmc block
    set block, $P1736
    .const 'Sub' $P2033 = "141_1299465710.053" 
    capture_lex $P2033
    $P2033()
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block2032"  :anon :subid("141_1299465710.053") :outer("118_1299465710.053")
.annotate 'line', 720
    get_hll_global $P2034, "KnowHOW"
    $P2035 = $P2034."new_type"("NQPParametricRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2035
    set_hll_global "NQPParametricRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2036, type_obj
    get_hll_global $P2037, "KnowHOWAttribute"
    $P2038 = $P2037."new"("$!name" :named("name"))
    $P2036."add_attribute"(type_obj, $P2038)
    get_how $P2039, type_obj
    get_hll_global $P2040, "KnowHOWAttribute"
    $P2041 = $P2040."new"("%!attributes" :named("name"))
    $P2039."add_attribute"(type_obj, $P2041)
    get_how $P2042, type_obj
    get_hll_global $P2043, "KnowHOWAttribute"
    $P2044 = $P2043."new"("%!methods" :named("name"))
    $P2042."add_attribute"(type_obj, $P2044)
    get_how $P2045, type_obj
    get_hll_global $P2046, "KnowHOWAttribute"
    $P2047 = $P2046."new"("@!multi_methods_to_incorporate" :named("name"))
    $P2045."add_attribute"(type_obj, $P2047)
    get_how $P2048, type_obj
    get_hll_global $P2049, "KnowHOWAttribute"
    $P2050 = $P2049."new"("@!roles" :named("name"))
    $P2048."add_attribute"(type_obj, $P2050)
    get_how $P2051, type_obj
    get_hll_global $P2052, "KnowHOWAttribute"
    $P2053 = $P2052."new"("$!composed" :named("name"))
    $P2051."add_attribute"(type_obj, $P2053)
    get_how $P2054, type_obj
    get_hll_global $P2055, "KnowHOWAttribute"
    $P2056 = $P2055."new"("$!body_block" :named("name"))
    $P2054."add_attribute"(type_obj, $P2056)
    get_how $P2057, type_obj
    .const 'Sub' $P2058 = "119_1299465710.053" 
    $P2057."add_method"(type_obj, "new", $P2058)
    get_how $P2059, type_obj
    .const 'Sub' $P2060 = "120_1299465710.053" 
    $P2059."add_method"(type_obj, "BUILD", $P2060)
    get_how $P2061, type_obj
    .const 'Sub' $P2062 = "121_1299465710.053" 
    $P2061."add_method"(type_obj, "new_type", $P2062)
    get_how $P2063, type_obj
    .const 'Sub' $P2064 = "122_1299465710.053" 
    $P2063."add_method"(type_obj, "add_method", $P2064)
    get_how $P2065, type_obj
    .const 'Sub' $P2066 = "123_1299465710.053" 
    $P2065."add_method"(type_obj, "add_multi_method", $P2066)
    get_how $P2067, type_obj
    .const 'Sub' $P2068 = "124_1299465710.053" 
    $P2067."add_method"(type_obj, "add_attribute", $P2068)
    get_how $P2069, type_obj
    .const 'Sub' $P2070 = "125_1299465710.053" 
    $P2069."add_method"(type_obj, "add_parent", $P2070)
    get_how $P2071, type_obj
    .const 'Sub' $P2072 = "126_1299465710.053" 
    $P2071."add_method"(type_obj, "add_role", $P2072)
    get_how $P2073, type_obj
    .const 'Sub' $P2074 = "127_1299465710.053" 
    $P2073."add_method"(type_obj, "compose", $P2074)
    get_how $P2075, type_obj
    .const 'Sub' $P2076 = "128_1299465710.053" 
    $P2075."add_method"(type_obj, "parametric", $P2076)
    get_how $P2077, type_obj
    .const 'Sub' $P2078 = "129_1299465710.053" 
    $P2077."add_method"(type_obj, "instantiate", $P2078)
    get_how $P2079, type_obj
    .const 'Sub' $P2080 = "134_1299465710.053" 
    $P2079."add_method"(type_obj, "methods", $P2080)
    get_how $P2081, type_obj
    .const 'Sub' $P2082 = "136_1299465710.053" 
    $P2081."add_method"(type_obj, "method_table", $P2082)
    get_how $P2083, type_obj
    .const 'Sub' $P2084 = "137_1299465710.053" 
    $P2083."add_method"(type_obj, "name", $P2084)
    get_how $P2085, type_obj
    .const 'Sub' $P2086 = "138_1299465710.053" 
    $P2085."add_method"(type_obj, "attributes", $P2086)
    get_how $P2087, type_obj
    .const 'Sub' $P2088 = "140_1299465710.053" 
    $P2087."add_method"(type_obj, "roles", $P2088)
    get_how $P2089, type_obj
    $P2090 = $P2089."compose"(type_obj)
    .return ($P2090)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "new"  :subid("119_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1739
    .param pmc param_1740 :named("name")
    .param pmc param_1741 :named("body_block")
.annotate 'line', 750
    .lex "self", param_1739
    .lex "$name", param_1740
    .lex "$body_block", param_1741
.annotate 'line', 751
    new $P1742, "Undef"
    .lex "$obj", $P1742
    find_lex $P1743, "self"
    repr_instance_of $P1744, $P1743
    store_lex "$obj", $P1744
.annotate 'line', 752
    find_lex $P1745, "$obj"
    find_lex $P1746, "$name"
    find_lex $P1747, "$body_block"
    $P1745."BUILD"($P1746 :named("name"), $P1747 :named("body_block"))
    find_lex $P1748, "$obj"
.annotate 'line', 750
    .return ($P1748)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "BUILD"  :subid("120_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1750
    .param pmc param_1751 :named("name")
    .param pmc param_1752 :named("body_block")
.annotate 'line', 756
    .lex "self", param_1750
    .lex "$name", param_1751
    .lex "$body_block", param_1752
.annotate 'line', 757
    find_lex $P1753, "$name"
    find_lex $P1754, "self"
    get_global $P1755, "$?CLASS"
    setattribute $P1754, $P1755, "$!name", $P1753
.annotate 'line', 758
    find_lex $P1756, "$body_block"
    find_lex $P1757, "self"
    get_global $P1758, "$?CLASS"
    setattribute $P1757, $P1758, "$!body_block", $P1756
.annotate 'line', 756
    .return ($P1756)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "new_type"  :subid("121_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1760
    .param pmc param_1761 :named("body_block")
    .param pmc param_1762 :optional :named("name")
    .param int has_param_1762 :opt_flag
    .param pmc param_1764 :optional :named("repr")
    .param int has_param_1764 :opt_flag
.annotate 'line', 763
    .lex "self", param_1760
    .lex "$body_block", param_1761
    if has_param_1762, optparam_357
    new $P1763, "String"
    assign $P1763, "<anon>"
    set param_1762, $P1763
  optparam_357:
    .lex "$name", param_1762
    if has_param_1764, optparam_358
    new $P1765, "String"
    assign $P1765, "P6opaque"
    set param_1764, $P1765
  optparam_358:
    .lex "$repr", param_1764
.annotate 'line', 764
    new $P1766, "Undef"
    .lex "$metarole", $P1766
    find_lex $P1767, "self"
    find_lex $P1768, "$name"
    find_lex $P1769, "$body_block"
    $P1770 = $P1767."new"($P1768 :named("name"), $P1769 :named("body_block"))
    store_lex "$metarole", $P1770
.annotate 'line', 765
    find_lex $P1771, "$metarole"
    find_lex $P1772, "$repr"
    set $S1773, $P1772
    repr_type_object_for $P1774, $P1771, $S1773
.annotate 'line', 763
    .return ($P1774)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_method"  :subid("122_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1776
    .param pmc param_1777
    .param pmc param_1778
    .param pmc param_1779
.annotate 'line', 768
    .lex "self", param_1776
    .lex "$obj", param_1777
    .lex "$name", param_1778
    .lex "$code_obj", param_1779
.annotate 'line', 769
    find_lex $P1781, "$name"
    find_lex $P1782, "self"
    get_global $P1783, "$?CLASS"
    getattribute $P1784, $P1782, $P1783, "%!methods"
    unless_null $P1784, vivify_359
    $P1784 = root_new ['parrot';'Hash']
  vivify_359:
    set $P1785, $P1784[$P1781]
    unless_null $P1785, vivify_360
    new $P1785, "Undef"
  vivify_360:
    unless $P1785, if_1780_end
.annotate 'line', 770
    new $P1786, "String"
    assign $P1786, "This role already has a method named "
    find_lex $P1787, "$name"
    concat $P1788, $P1786, $P1787
    die $P1788
  if_1780_end:
.annotate 'line', 772
    find_lex $P1789, "$code_obj"
    find_lex $P1790, "$name"
    find_lex $P1791, "self"
    get_global $P1792, "$?CLASS"
    getattribute $P1793, $P1791, $P1792, "%!methods"
    unless_null $P1793, vivify_361
    $P1793 = root_new ['parrot';'Hash']
    setattribute $P1791, $P1792, "%!methods", $P1793
  vivify_361:
    set $P1793[$P1790], $P1789
.annotate 'line', 768
    .return ($P1789)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_multi_method"  :subid("123_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1795
    .param pmc param_1796
    .param pmc param_1797
    .param pmc param_1798
.annotate 'line', 775
    .lex "self", param_1795
    .lex "$obj", param_1796
    .lex "$name", param_1797
    .lex "$code_obj", param_1798
.annotate 'line', 776
    $P1799 = root_new ['parrot';'Hash']
    .lex "%todo", $P1799
.annotate 'line', 775
    find_lex $P1800, "%todo"
.annotate 'line', 777
    find_lex $P1801, "$name"
    find_lex $P1802, "%todo"
    unless_null $P1802, vivify_362
    $P1802 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1802
  vivify_362:
    set $P1802["name"], $P1801
.annotate 'line', 778
    find_lex $P1803, "$code_obj"
    find_lex $P1804, "%todo"
    unless_null $P1804, vivify_363
    $P1804 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1804
  vivify_363:
    set $P1804["code"], $P1803
.annotate 'line', 779
    find_lex $P1805, "%todo"
    find_lex $P1806, "self"
    get_global $P1807, "$?CLASS"
    getattribute $P1808, $P1806, $P1807, "@!multi_methods_to_incorporate"
    unless_null $P1808, vivify_364
    $P1808 = root_new ['parrot';'ResizablePMCArray']
  vivify_364:
    set $N1809, $P1808
    set $I1810, $N1809
    find_lex $P1811, "self"
    get_global $P1812, "$?CLASS"
    getattribute $P1813, $P1811, $P1812, "@!multi_methods_to_incorporate"
    unless_null $P1813, vivify_365
    $P1813 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1811, $P1812, "@!multi_methods_to_incorporate", $P1813
  vivify_365:
    set $P1813[$I1810], $P1805
    find_lex $P1814, "$code_obj"
.annotate 'line', 775
    .return ($P1814)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_attribute"  :subid("124_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1816
    .param pmc param_1817
    .param pmc param_1818
.annotate 'line', 783
    .lex "self", param_1816
    .lex "$obj", param_1817
    .lex "$meta_attr", param_1818
.annotate 'line', 784
    new $P1819, "Undef"
    .lex "$name", $P1819
    find_lex $P1820, "$meta_attr"
    $P1821 = $P1820."name"()
    store_lex "$name", $P1821
.annotate 'line', 785
    find_lex $P1823, "$name"
    find_lex $P1824, "self"
    get_global $P1825, "$?CLASS"
    getattribute $P1826, $P1824, $P1825, "%!attributes"
    unless_null $P1826, vivify_366
    $P1826 = root_new ['parrot';'Hash']
  vivify_366:
    set $P1827, $P1826[$P1823]
    unless_null $P1827, vivify_367
    new $P1827, "Undef"
  vivify_367:
    unless $P1827, if_1822_end
.annotate 'line', 786
    new $P1828, "String"
    assign $P1828, "This role already has an attribute named "
    find_lex $P1829, "$name"
    concat $P1830, $P1828, $P1829
    die $P1830
  if_1822_end:
.annotate 'line', 788
    find_lex $P1831, "$meta_attr"
    find_lex $P1832, "$name"
    find_lex $P1833, "self"
    get_global $P1834, "$?CLASS"
    getattribute $P1835, $P1833, $P1834, "%!attributes"
    unless_null $P1835, vivify_368
    $P1835 = root_new ['parrot';'Hash']
    setattribute $P1833, $P1834, "%!attributes", $P1835
  vivify_368:
    set $P1835[$P1832], $P1831
.annotate 'line', 783
    .return ($P1831)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_parent"  :subid("125_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1837
    .param pmc param_1838
    .param pmc param_1839
.annotate 'line', 791
    .lex "self", param_1837
    .lex "$obj", param_1838
    .lex "$parent", param_1839
.annotate 'line', 792
    die "A role cannot inherit from a class"
.annotate 'line', 791
    .return ()
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_role"  :subid("126_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1841
    .param pmc param_1842
    .param pmc param_1843
.annotate 'line', 795
    .lex "self", param_1841
    .lex "$obj", param_1842
    .lex "$role", param_1843
.annotate 'line', 796
    find_lex $P1844, "$role"
    find_lex $P1845, "self"
    get_global $P1846, "$?CLASS"
    getattribute $P1847, $P1845, $P1846, "@!roles"
    unless_null $P1847, vivify_369
    $P1847 = root_new ['parrot';'ResizablePMCArray']
  vivify_369:
    set $N1848, $P1847
    set $I1849, $N1848
    find_lex $P1850, "self"
    get_global $P1851, "$?CLASS"
    getattribute $P1852, $P1850, $P1851, "@!roles"
    unless_null $P1852, vivify_370
    $P1852 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1850, $P1851, "@!roles", $P1852
  vivify_370:
    set $P1852[$I1849], $P1844
.annotate 'line', 795
    .return ($P1844)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "compose"  :subid("127_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1854
    .param pmc param_1855
.annotate 'line', 800
    .lex "self", param_1854
    .lex "$obj", param_1855
.annotate 'line', 801
    new $P1856, "Integer"
    assign $P1856, 1
    find_lex $P1857, "self"
    get_global $P1858, "$?CLASS"
    setattribute $P1857, $P1858, "$!composed", $P1856
    find_lex $P1859, "$obj"
.annotate 'line', 800
    .return ($P1859)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "parametric"  :subid("128_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1861
    .param pmc param_1862
.annotate 'line', 811
    .lex "self", param_1861
    .lex "$obj", param_1862
    .return (1)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "instantiate"  :subid("129_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1866
    .param pmc param_1867
    .param pmc param_1868
.annotate 'line', 817
    .const 'Sub' $P1947 = "133_1299465710.053" 
    capture_lex $P1947
    .const 'Sub' $P1926 = "132_1299465710.053" 
    capture_lex $P1926
    .const 'Sub' $P1905 = "131_1299465710.053" 
    capture_lex $P1905
    .const 'Sub' $P1887 = "130_1299465710.053" 
    capture_lex $P1887
    new $P1865, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1865, control_1864
    push_eh $P1865
    .lex "self", param_1866
    .lex "$obj", param_1867
    .lex "$class_arg", param_1868
.annotate 'line', 823
    new $P1869, "Undef"
    .lex "$irole", $P1869
.annotate 'line', 820
    find_lex $P1870, "self"
    get_global $P1871, "$?CLASS"
    getattribute $P1872, $P1870, $P1871, "$!body_block"
    unless_null $P1872, vivify_371
    new $P1872, "Undef"
  vivify_371:
    find_lex $P1873, "$class_arg"
    $P1872($P1873)
.annotate 'line', 823
    get_hll_global $P1874, "NQPConcreteRoleHOW"
    find_lex $P1875, "self"
    get_global $P1876, "$?CLASS"
    getattribute $P1877, $P1875, $P1876, "$!name"
    unless_null $P1877, vivify_372
    new $P1877, "Undef"
  vivify_372:
    find_lex $P1878, "$obj"
    $P1879 = $P1874."new_type"($P1877 :named("name"), $P1878 :named("instance_of"))
    store_lex "$irole", $P1879
.annotate 'line', 827
    find_lex $P1881, "self"
    get_global $P1882, "$?CLASS"
    getattribute $P1883, $P1881, $P1882, "%!attributes"
    unless_null $P1883, vivify_373
    $P1883 = root_new ['parrot';'Hash']
  vivify_373:
    defined $I1884, $P1883
    unless $I1884, for_undef_374
    iter $P1880, $P1883
    new $P1896, 'ExceptionHandler'
    set_label $P1896, loop1895_handler
    $P1896."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1896
  loop1895_test:
    unless $P1880, loop1895_done
    shift $P1885, $P1880
  loop1895_redo:
    .const 'Sub' $P1887 = "130_1299465710.053" 
    capture_lex $P1887
    $P1887($P1885)
  loop1895_next:
    goto loop1895_test
  loop1895_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1897, exception, 'type'
    eq $P1897, .CONTROL_LOOP_NEXT, loop1895_next
    eq $P1897, .CONTROL_LOOP_REDO, loop1895_redo
  loop1895_done:
    pop_eh 
  for_undef_374:
.annotate 'line', 833
    find_lex $P1899, "self"
    get_global $P1900, "$?CLASS"
    getattribute $P1901, $P1899, $P1900, "%!methods"
    unless_null $P1901, vivify_375
    $P1901 = root_new ['parrot';'Hash']
  vivify_375:
    defined $I1902, $P1901
    unless $I1902, for_undef_376
    iter $P1898, $P1901
    new $P1917, 'ExceptionHandler'
    set_label $P1917, loop1916_handler
    $P1917."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1917
  loop1916_test:
    unless $P1898, loop1916_done
    shift $P1903, $P1898
  loop1916_redo:
    .const 'Sub' $P1905 = "131_1299465710.053" 
    capture_lex $P1905
    $P1905($P1903)
  loop1916_next:
    goto loop1916_test
  loop1916_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1918, exception, 'type'
    eq $P1918, .CONTROL_LOOP_NEXT, loop1916_next
    eq $P1918, .CONTROL_LOOP_REDO, loop1916_redo
  loop1916_done:
    pop_eh 
  for_undef_376:
.annotate 'line', 836
    find_lex $P1920, "self"
    get_global $P1921, "$?CLASS"
    getattribute $P1922, $P1920, $P1921, "@!multi_methods_to_incorporate"
    unless_null $P1922, vivify_377
    $P1922 = root_new ['parrot';'ResizablePMCArray']
  vivify_377:
    defined $I1923, $P1922
    unless $I1923, for_undef_378
    iter $P1919, $P1922
    new $P1938, 'ExceptionHandler'
    set_label $P1938, loop1937_handler
    $P1938."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1938
  loop1937_test:
    unless $P1919, loop1937_done
    shift $P1924, $P1919
  loop1937_redo:
    .const 'Sub' $P1926 = "132_1299465710.053" 
    capture_lex $P1926
    $P1926($P1924)
  loop1937_next:
    goto loop1937_test
  loop1937_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1939, exception, 'type'
    eq $P1939, .CONTROL_LOOP_NEXT, loop1937_next
    eq $P1939, .CONTROL_LOOP_REDO, loop1937_redo
  loop1937_done:
    pop_eh 
  for_undef_378:
.annotate 'line', 841
    find_lex $P1941, "self"
    get_global $P1942, "$?CLASS"
    getattribute $P1943, $P1941, $P1942, "@!roles"
    unless_null $P1943, vivify_383
    $P1943 = root_new ['parrot';'ResizablePMCArray']
  vivify_383:
    defined $I1944, $P1943
    unless $I1944, for_undef_384
    iter $P1940, $P1943
    new $P1961, 'ExceptionHandler'
    set_label $P1961, loop1960_handler
    $P1961."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1961
  loop1960_test:
    unless $P1940, loop1960_done
    shift $P1945, $P1940
  loop1960_redo:
    .const 'Sub' $P1947 = "133_1299465710.053" 
    capture_lex $P1947
    $P1947($P1945)
  loop1960_next:
    goto loop1960_test
  loop1960_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1962, exception, 'type'
    eq $P1962, .CONTROL_LOOP_NEXT, loop1960_next
    eq $P1962, .CONTROL_LOOP_REDO, loop1960_redo
  loop1960_done:
    pop_eh 
  for_undef_384:
.annotate 'line', 847
    find_lex $P1963, "$irole"
    get_how $P1964, $P1963
    find_lex $P1965, "$irole"
    $P1964."compose"($P1965)
.annotate 'line', 848
    new $P1966, "Exception"
    set $P1966['type'], .CONTROL_RETURN
    find_lex $P1967, "$irole"
    setattribute $P1966, 'payload', $P1967
    throw $P1966
.annotate 'line', 817
    .return ()
  control_1864:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1968, exception, "payload"
    .return ($P1968)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1886"  :anon :subid("130_1299465710.053") :outer("129_1299465710.053")
    .param pmc param_1888
.annotate 'line', 827
    .lex "$_", param_1888
.annotate 'line', 828
    find_lex $P1889, "$irole"
    get_how $P1890, $P1889
    find_lex $P1891, "$irole"
    find_lex $P1892, "$_"
    $P1893 = $P1892."value"()
    $P1894 = $P1890."add_attribute"($P1891, $P1893)
.annotate 'line', 827
    .return ($P1894)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1904"  :anon :subid("131_1299465710.053") :outer("129_1299465710.053")
    .param pmc param_1906
.annotate 'line', 833
    .lex "$_", param_1906
.annotate 'line', 834
    find_lex $P1907, "$irole"
    get_how $P1908, $P1907
    find_lex $P1909, "$irole"
    find_lex $P1910, "$_"
    $P1911 = $P1910."key"()
    find_lex $P1912, "$_"
    $P1913 = $P1912."value"()
    clone $P1914, $P1913
    $P1915 = $P1908."add_method"($P1909, $P1911, $P1914)
.annotate 'line', 833
    .return ($P1915)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1925"  :anon :subid("132_1299465710.053") :outer("129_1299465710.053")
    .param pmc param_1927
.annotate 'line', 836
    .lex "$_", param_1927
.annotate 'line', 837
    find_lex $P1928, "$irole"
    get_how $P1929, $P1928
    find_lex $P1930, "$irole"
    find_lex $P1931, "$_"
    unless_null $P1931, vivify_379
    $P1931 = root_new ['parrot';'Hash']
  vivify_379:
    set $P1932, $P1931["name"]
    unless_null $P1932, vivify_380
    new $P1932, "Undef"
  vivify_380:
    find_lex $P1933, "$_"
    unless_null $P1933, vivify_381
    $P1933 = root_new ['parrot';'Hash']
  vivify_381:
    set $P1934, $P1933["code"]
    unless_null $P1934, vivify_382
    new $P1934, "Undef"
  vivify_382:
    clone $P1935, $P1934
    $P1936 = $P1929."add_multi_method"($P1930, $P1932, $P1935)
.annotate 'line', 836
    .return ($P1936)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1946"  :anon :subid("133_1299465710.053") :outer("129_1299465710.053")
    .param pmc param_1949
.annotate 'line', 842
    new $P1948, "Undef"
    .lex "$instantiated", $P1948
    .lex "$_", param_1949
    find_lex $P1950, "$irole"
    get_how $P1951, $P1950
    find_lex $P1952, "$irole"
    find_lex $P1953, "$class_arg"
    $P1954 = $P1951."instantiate"($P1952, $P1953)
    store_lex "$instantiated", $P1954
.annotate 'line', 843
    find_lex $P1955, "$irole"
    get_how $P1956, $P1955
    find_lex $P1957, "$irole"
    find_lex $P1958, "$instantiated"
    $P1959 = $P1956."add_role"($P1957, $P1958)
.annotate 'line', 841
    .return ($P1959)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("134_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1970
    .param pmc param_1971
.annotate 'line', 856
    .const 'Sub' $P1981 = "135_1299465710.053" 
    capture_lex $P1981
    .lex "self", param_1970
    .lex "$obj", param_1971
.annotate 'line', 857
    $P1972 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1972
.annotate 'line', 856
    find_lex $P1973, "@meths"
.annotate 'line', 858
    find_lex $P1975, "self"
    get_global $P1976, "$?CLASS"
    getattribute $P1977, $P1975, $P1976, "%!methods"
    unless_null $P1977, vivify_385
    $P1977 = root_new ['parrot';'Hash']
  vivify_385:
    defined $I1978, $P1977
    unless $I1978, for_undef_386
    iter $P1974, $P1977
    new $P1988, 'ExceptionHandler'
    set_label $P1988, loop1987_handler
    $P1988."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1988
  loop1987_test:
    unless $P1974, loop1987_done
    shift $P1979, $P1974
  loop1987_redo:
    .const 'Sub' $P1981 = "135_1299465710.053" 
    capture_lex $P1981
    $P1981($P1979)
  loop1987_next:
    goto loop1987_test
  loop1987_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1989, exception, 'type'
    eq $P1989, .CONTROL_LOOP_NEXT, loop1987_next
    eq $P1989, .CONTROL_LOOP_REDO, loop1987_redo
  loop1987_done:
    pop_eh 
  for_undef_386:
    find_lex $P1990, "@meths"
.annotate 'line', 856
    .return ($P1990)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1980"  :anon :subid("135_1299465710.053") :outer("134_1299465710.053")
    .param pmc param_1982
.annotate 'line', 858
    .lex "$_", param_1982
.annotate 'line', 859
    find_lex $P1983, "@meths"
    find_lex $P1984, "$_"
    $P1985 = $P1984."value"()
    $P1986 = $P1983."push"($P1985)
.annotate 'line', 858
    .return ($P1986)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "method_table"  :subid("136_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1992
    .param pmc param_1993
.annotate 'line', 864
    .lex "self", param_1992
    .lex "$obj", param_1993
    find_lex $P1994, "self"
    get_global $P1995, "$?CLASS"
    getattribute $P1996, $P1994, $P1995, "%!methods"
    unless_null $P1996, vivify_387
    $P1996 = root_new ['parrot';'Hash']
  vivify_387:
    .return ($P1996)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "name"  :subid("137_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_1998
    .param pmc param_1999
.annotate 'line', 868
    .lex "self", param_1998
    .lex "$obj", param_1999
    find_lex $P2000, "self"
    get_global $P2001, "$?CLASS"
    getattribute $P2002, $P2000, $P2001, "$!name"
    unless_null $P2002, vivify_388
    new $P2002, "Undef"
  vivify_388:
    .return ($P2002)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("138_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_2004
    .param pmc param_2005
.annotate 'line', 872
    .const 'Sub' $P2015 = "139_1299465710.053" 
    capture_lex $P2015
    .lex "self", param_2004
    .lex "$obj", param_2005
.annotate 'line', 873
    $P2006 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P2006
.annotate 'line', 872
    find_lex $P2007, "@attrs"
.annotate 'line', 874
    find_lex $P2009, "self"
    get_global $P2010, "$?CLASS"
    getattribute $P2011, $P2009, $P2010, "%!attributes"
    unless_null $P2011, vivify_389
    $P2011 = root_new ['parrot';'Hash']
  vivify_389:
    defined $I2012, $P2011
    unless $I2012, for_undef_390
    iter $P2008, $P2011
    new $P2022, 'ExceptionHandler'
    set_label $P2022, loop2021_handler
    $P2022."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2022
  loop2021_test:
    unless $P2008, loop2021_done
    shift $P2013, $P2008
  loop2021_redo:
    .const 'Sub' $P2015 = "139_1299465710.053" 
    capture_lex $P2015
    $P2015($P2013)
  loop2021_next:
    goto loop2021_test
  loop2021_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2023, exception, 'type'
    eq $P2023, .CONTROL_LOOP_NEXT, loop2021_next
    eq $P2023, .CONTROL_LOOP_REDO, loop2021_redo
  loop2021_done:
    pop_eh 
  for_undef_390:
    find_lex $P2024, "@attrs"
.annotate 'line', 872
    .return ($P2024)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block2014"  :anon :subid("139_1299465710.053") :outer("138_1299465710.053")
    .param pmc param_2016
.annotate 'line', 874
    .lex "$_", param_2016
.annotate 'line', 875
    find_lex $P2017, "@attrs"
    find_lex $P2018, "$_"
    $P2019 = $P2018."value"()
    $P2020 = $P2017."push"($P2019)
.annotate 'line', 874
    .return ($P2020)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "roles"  :subid("140_1299465710.053") :outer("118_1299465710.053")
    .param pmc param_2026
    .param pmc param_2027
.annotate 'line', 880
    .lex "self", param_2026
    .lex "$obj", param_2027
    find_lex $P2028, "self"
    get_global $P2029, "$?CLASS"
    getattribute $P2030, $P2028, $P2029, "@!roles"
    unless_null $P2030, vivify_391
    $P2030 = root_new ['parrot';'ResizablePMCArray']
  vivify_391:
    .return ($P2030)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2091"  :subid("142_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 886
    .const 'Sub' $P2300 = "152_1299465710.053" 
    capture_lex $P2300
    .const 'Sub' $P2164 = "147_1299465710.053" 
    capture_lex $P2164
    .const 'Sub' $P2129 = "145_1299465710.053" 
    capture_lex $P2129
    .const 'Sub' $P2094 = "143_1299465710.053" 
    capture_lex $P2094
    get_global $P2093, "$?CLASS"
.annotate 'line', 888
    .const 'Sub' $P2094 = "143_1299465710.053" 
    newclosure $P2128, $P2094
    .lex "has_method", $P2128
.annotate 'line', 896
    .const 'Sub' $P2129 = "145_1299465710.053" 
    newclosure $P2161, $P2129
    .lex "has_attribute", $P2161
.annotate 'line', 886
    find_lex $P2162, "has_method"
    find_lex $P2163, "has_attribute"
.annotate 'line', 904
    .const 'Sub' $P2164 = "147_1299465710.053" 
    newclosure $P2298, $P2164
.annotate 'line', 886
    .return ($P2298)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "" :load :init :subid("post392") :outer("142_1299465710.053")
.annotate 'line', 886
    get_hll_global $P2092, ["RoleToClassApplier"], "_block2091" 
    .local pmc block
    set block, $P2092
    .const 'Sub' $P2300 = "152_1299465710.053" 
    capture_lex $P2300
    $P2300()
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2299"  :anon :subid("152_1299465710.053") :outer("142_1299465710.053")
.annotate 'line', 886
    get_hll_global $P2301, "KnowHOW"
    $P2302 = $P2301."new_type"("RoleToClassApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2302
    set_hll_global "RoleToClassApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2303, type_obj
    .const 'Sub' $P2304 = "147_1299465710.053" 
    $P2303."add_method"(type_obj, "apply", $P2304)
    get_how $P2305, type_obj
    $P2306 = $P2305."compose"(type_obj)
    .return ($P2306)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_method"  :subid("143_1299465710.053") :outer("142_1299465710.053")
    .param pmc param_2097
    .param pmc param_2098
    .param pmc param_2099
.annotate 'line', 888
    .const 'Sub' $P2111 = "144_1299465710.053" 
    capture_lex $P2111
    new $P2096, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2096, control_2095
    push_eh $P2096
    .lex "$target", param_2097
    .lex "$name", param_2098
    .lex "$local", param_2099
.annotate 'line', 889
    $P2100 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2100
    find_lex $P2101, "$target"
    get_how $P2102, $P2101
    find_lex $P2103, "$target"
    find_lex $P2104, "$local"
    $P2105 = $P2102."methods"($P2103, $P2104 :named("local"))
    store_lex "@methods", $P2105
.annotate 'line', 890
    find_lex $P2107, "@methods"
    defined $I2108, $P2107
    unless $I2108, for_undef_393
    iter $P2106, $P2107
    new $P2123, 'ExceptionHandler'
    set_label $P2123, loop2122_handler
    $P2123."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2123
  loop2122_test:
    unless $P2106, loop2122_done
    shift $P2109, $P2106
  loop2122_redo:
    .const 'Sub' $P2111 = "144_1299465710.053" 
    capture_lex $P2111
    $P2111($P2109)
  loop2122_next:
    goto loop2122_test
  loop2122_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2124, exception, 'type'
    eq $P2124, .CONTROL_LOOP_NEXT, loop2122_next
    eq $P2124, .CONTROL_LOOP_REDO, loop2122_redo
  loop2122_done:
    pop_eh 
  for_undef_393:
.annotate 'line', 893
    new $P2125, "Exception"
    set $P2125['type'], .CONTROL_RETURN
    new $P2126, "Integer"
    assign $P2126, 0
    setattribute $P2125, 'payload', $P2126
    throw $P2125
.annotate 'line', 888
    .return ()
  control_2095:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2127, exception, "payload"
    .return ($P2127)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block2110"  :anon :subid("144_1299465710.053") :outer("143_1299465710.053")
    .param pmc param_2112
.annotate 'line', 890
    .lex "$_", param_2112
.annotate 'line', 891
    find_lex $P2115, "$_"
    set $S2116, $P2115
    find_lex $P2117, "$name"
    set $S2118, $P2117
    iseq $I2119, $S2116, $S2118
    if $I2119, if_2114
    new $P2113, 'Integer'
    set $P2113, $I2119
    goto if_2114_end
  if_2114:
    new $P2120, "Exception"
    set $P2120['type'], .CONTROL_RETURN
    new $P2121, "Integer"
    assign $P2121, 1
    setattribute $P2120, 'payload', $P2121
    throw $P2120
  if_2114_end:
.annotate 'line', 890
    .return ($P2113)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_attribute"  :subid("145_1299465710.053") :outer("142_1299465710.053")
    .param pmc param_2132
    .param pmc param_2133
.annotate 'line', 896
    .const 'Sub' $P2144 = "146_1299465710.053" 
    capture_lex $P2144
    new $P2131, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2131, control_2130
    push_eh $P2131
    .lex "$target", param_2132
    .lex "$name", param_2133
.annotate 'line', 897
    $P2134 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2134
    find_lex $P2135, "$target"
    get_how $P2136, $P2135
    find_lex $P2137, "$target"
    $P2138 = $P2136."attributes"($P2137, 1 :named("local"))
    store_lex "@attributes", $P2138
.annotate 'line', 898
    find_lex $P2140, "@attributes"
    defined $I2141, $P2140
    unless $I2141, for_undef_394
    iter $P2139, $P2140
    new $P2156, 'ExceptionHandler'
    set_label $P2156, loop2155_handler
    $P2156."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2156
  loop2155_test:
    unless $P2139, loop2155_done
    shift $P2142, $P2139
  loop2155_redo:
    .const 'Sub' $P2144 = "146_1299465710.053" 
    capture_lex $P2144
    $P2144($P2142)
  loop2155_next:
    goto loop2155_test
  loop2155_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2157, exception, 'type'
    eq $P2157, .CONTROL_LOOP_NEXT, loop2155_next
    eq $P2157, .CONTROL_LOOP_REDO, loop2155_redo
  loop2155_done:
    pop_eh 
  for_undef_394:
.annotate 'line', 901
    new $P2158, "Exception"
    set $P2158['type'], .CONTROL_RETURN
    new $P2159, "Integer"
    assign $P2159, 0
    setattribute $P2158, 'payload', $P2159
    throw $P2158
.annotate 'line', 896
    .return ()
  control_2130:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2160, exception, "payload"
    .return ($P2160)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block2143"  :anon :subid("146_1299465710.053") :outer("145_1299465710.053")
    .param pmc param_2145
.annotate 'line', 898
    .lex "$_", param_2145
.annotate 'line', 899
    find_lex $P2148, "$_"
    $S2149 = $P2148."name"()
    find_lex $P2150, "$name"
    set $S2151, $P2150
    iseq $I2152, $S2149, $S2151
    if $I2152, if_2147
    new $P2146, 'Integer'
    set $P2146, $I2152
    goto if_2147_end
  if_2147:
    new $P2153, "Exception"
    set $P2153['type'], .CONTROL_RETURN
    new $P2154, "Integer"
    assign $P2154, 1
    setattribute $P2153, 'payload', $P2154
    throw $P2153
  if_2147_end:
.annotate 'line', 898
    .return ($P2146)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("147_1299465710.053") :outer("142_1299465710.053")
    .param pmc param_2165
    .param pmc param_2166
    .param pmc param_2167
.annotate 'line', 904
    .const 'Sub' $P2269 = "151_1299465710.053" 
    capture_lex $P2269
    .const 'Sub' $P2243 = "150_1299465710.053" 
    capture_lex $P2243
    .const 'Sub' $P2214 = "149_1299465710.053" 
    capture_lex $P2214
    .const 'Sub' $P2194 = "148_1299465710.053" 
    capture_lex $P2194
    .lex "self", param_2165
    .lex "$target", param_2166
    .lex "@roles", param_2167
.annotate 'line', 907
    new $P2168, "Undef"
    .lex "$to_compose", $P2168
.annotate 'line', 908
    new $P2169, "Undef"
    .lex "$to_compose_meta", $P2169
.annotate 'line', 923
    $P2170 = root_new ['parrot';'ResizablePMCArray']
    .lex "@collisions", $P2170
.annotate 'line', 932
    $P2171 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2171
.annotate 'line', 940
    $P2172 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2172
.annotate 'line', 952
    $P2173 = root_new ['parrot';'ResizablePMCArray']
    .lex "@done", $P2173
.annotate 'line', 904
    find_lex $P2174, "$to_compose"
    find_lex $P2175, "$to_compose_meta"
.annotate 'line', 909
    find_lex $P2177, "@roles"
    set $N2178, $P2177
    iseq $I2179, $N2178, 1.0
    if $I2179, if_2176
.annotate 'line', 914
    get_hll_global $P2184, "NQPConcreteRoleHOW"
    get_hll_global $P2185, "NQPMu"
    $P2186 = $P2184."new_type"($P2185 :named("instance_of"))
    store_lex "$to_compose", $P2186
.annotate 'line', 915
    find_lex $P2187, "$to_compose"
    get_how $P2188, $P2187
    store_lex "$to_compose_meta", $P2188
.annotate 'line', 916
    find_lex $P2190, "@roles"
    defined $I2191, $P2190
    unless $I2191, for_undef_395
    iter $P2189, $P2190
    new $P2201, 'ExceptionHandler'
    set_label $P2201, loop2200_handler
    $P2201."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2201
  loop2200_test:
    unless $P2189, loop2200_done
    shift $P2192, $P2189
  loop2200_redo:
    .const 'Sub' $P2194 = "148_1299465710.053" 
    capture_lex $P2194
    $P2194($P2192)
  loop2200_next:
    goto loop2200_test
  loop2200_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2202, exception, 'type'
    eq $P2202, .CONTROL_LOOP_NEXT, loop2200_next
    eq $P2202, .CONTROL_LOOP_REDO, loop2200_redo
  loop2200_done:
    pop_eh 
  for_undef_395:
.annotate 'line', 919
    find_lex $P2203, "$to_compose_meta"
    find_lex $P2204, "$to_compose"
    $P2205 = $P2203."compose"($P2204)
    store_lex "$to_compose", $P2205
.annotate 'line', 913
    goto if_2176_end
  if_2176:
.annotate 'line', 910
    find_lex $P2180, "@roles"
    unless_null $P2180, vivify_396
    $P2180 = root_new ['parrot';'ResizablePMCArray']
  vivify_396:
    set $P2181, $P2180[0]
    unless_null $P2181, vivify_397
    new $P2181, "Undef"
  vivify_397:
    store_lex "$to_compose", $P2181
.annotate 'line', 911
    find_lex $P2182, "$to_compose"
    get_how $P2183, $P2182
    store_lex "$to_compose_meta", $P2183
  if_2176_end:
.annotate 'line', 923
    find_lex $P2206, "$to_compose_meta"
    find_lex $P2207, "$to_compose"
    $P2208 = $P2206."collisions"($P2207)
    store_lex "@collisions", $P2208
.annotate 'line', 924
    find_lex $P2210, "@collisions"
    defined $I2211, $P2210
    unless $I2211, for_undef_398
    iter $P2209, $P2210
    new $P2233, 'ExceptionHandler'
    set_label $P2233, loop2232_handler
    $P2233."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2233
  loop2232_test:
    unless $P2209, loop2232_done
    shift $P2212, $P2209
  loop2232_redo:
    .const 'Sub' $P2214 = "149_1299465710.053" 
    capture_lex $P2214
    $P2214($P2212)
  loop2232_next:
    goto loop2232_test
  loop2232_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2234, exception, 'type'
    eq $P2234, .CONTROL_LOOP_NEXT, loop2232_next
    eq $P2234, .CONTROL_LOOP_REDO, loop2232_redo
  loop2232_done:
    pop_eh 
  for_undef_398:
.annotate 'line', 932
    find_lex $P2235, "$to_compose_meta"
    find_lex $P2236, "$to_compose"
    $P2237 = $P2235."methods"($P2236)
    store_lex "@methods", $P2237
.annotate 'line', 933
    find_lex $P2239, "@methods"
    defined $I2240, $P2239
    unless $I2240, for_undef_399
    iter $P2238, $P2239
    new $P2259, 'ExceptionHandler'
    set_label $P2259, loop2258_handler
    $P2259."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2259
  loop2258_test:
    unless $P2238, loop2258_done
    shift $P2241, $P2238
  loop2258_redo:
    .const 'Sub' $P2243 = "150_1299465710.053" 
    capture_lex $P2243
    $P2243($P2241)
  loop2258_next:
    goto loop2258_test
  loop2258_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2260, exception, 'type'
    eq $P2260, .CONTROL_LOOP_NEXT, loop2258_next
    eq $P2260, .CONTROL_LOOP_REDO, loop2258_redo
  loop2258_done:
    pop_eh 
  for_undef_399:
.annotate 'line', 940
    find_lex $P2261, "$to_compose_meta"
    find_lex $P2262, "$to_compose"
    $P2263 = $P2261."attributes"($P2262)
    store_lex "@attributes", $P2263
.annotate 'line', 941
    find_lex $P2265, "@attributes"
    defined $I2266, $P2265
    unless $I2266, for_undef_400
    iter $P2264, $P2265
    new $P2293, 'ExceptionHandler'
    set_label $P2293, loop2292_handler
    $P2293."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2293
  loop2292_test:
    unless $P2264, loop2292_done
    shift $P2267, $P2264
  loop2292_redo:
    .const 'Sub' $P2269 = "151_1299465710.053" 
    capture_lex $P2269
    $P2269($P2267)
  loop2292_next:
    goto loop2292_test
  loop2292_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2294, exception, 'type'
    eq $P2294, .CONTROL_LOOP_NEXT, loop2292_next
    eq $P2294, .CONTROL_LOOP_REDO, loop2292_redo
  loop2292_done:
    pop_eh 
  for_undef_400:
    find_lex $P2295, "@done"
.annotate 'line', 953
    find_lex $P2296, "$to_compose"
    find_lex $P2297, "@done"
    unless_null $P2297, vivify_401
    $P2297 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@done", $P2297
  vivify_401:
    set $P2297[0], $P2296
.annotate 'line', 904
    .return ($P2296)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2193"  :anon :subid("148_1299465710.053") :outer("147_1299465710.053")
    .param pmc param_2195
.annotate 'line', 916
    .lex "$_", param_2195
.annotate 'line', 917
    find_lex $P2196, "$to_compose_meta"
    find_lex $P2197, "$to_compose"
    find_lex $P2198, "$_"
    $P2199 = $P2196."add_role"($P2197, $P2198)
.annotate 'line', 916
    .return ($P2199)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2213"  :anon :subid("149_1299465710.053") :outer("147_1299465710.053")
    .param pmc param_2215
.annotate 'line', 924
    .lex "$_", param_2215
.annotate 'line', 925
    find_lex $P2218, "$target"
    find_lex $P2219, "$_"
    set $S2220, $P2219
    $P2221 = "has_method"($P2218, $S2220, 1)
    unless $P2221, unless_2217
    set $P2216, $P2221
    goto unless_2217_end
  unless_2217:
.annotate 'line', 926
    new $P2222, 'String'
    set $P2222, "Method '"
    find_lex $P2223, "$_"
    concat $P2224, $P2222, $P2223
    concat $P2225, $P2224, "' collides and a resolution must be provided by the class '"
.annotate 'line', 927
    find_lex $P2226, "$target"
    get_how $P2227, $P2226
    find_lex $P2228, "$target"
    $S2229 = $P2227."name"($P2228)
    concat $P2230, $P2225, $S2229
.annotate 'line', 926
    concat $P2231, $P2230, "'"
.annotate 'line', 927
    die $P2231
  unless_2217_end:
.annotate 'line', 924
    .return ($P2216)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2242"  :anon :subid("150_1299465710.053") :outer("147_1299465710.053")
    .param pmc param_2244
.annotate 'line', 933
    .lex "$_", param_2244
.annotate 'line', 934
    find_lex $P2247, "$target"
    find_lex $P2248, "$_"
    set $S2249, $P2248
    $P2250 = "has_method"($P2247, $S2249, 0)
    unless $P2250, unless_2246
    set $P2245, $P2250
    goto unless_2246_end
  unless_2246:
.annotate 'line', 935
    find_lex $P2251, "$target"
    get_how $P2252, $P2251
    find_lex $P2253, "$target"
    find_lex $P2254, "$_"
    set $S2255, $P2254
    find_lex $P2256, "$_"
    $P2257 = $P2252."add_method"($P2253, $S2255, $P2256)
.annotate 'line', 934
    set $P2245, $P2257
  unless_2246_end:
.annotate 'line', 933
    .return ($P2245)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2268"  :anon :subid("151_1299465710.053") :outer("147_1299465710.053")
    .param pmc param_2270
.annotate 'line', 941
    .lex "$_", param_2270
.annotate 'line', 942
    find_lex $P2272, "$target"
    find_lex $P2273, "$_"
    $P2274 = $P2273."name"()
    $P2275 = "has_attribute"($P2272, $P2274)
    unless $P2275, if_2271_end
.annotate 'line', 943
    new $P2276, "String"
    assign $P2276, "Attribute '"
    find_lex $P2277, "$_"
    $S2278 = $P2277."name"()
    concat $P2279, $P2276, $S2278
    concat $P2280, $P2279, "' already exists in the class '"
.annotate 'line', 944
    find_lex $P2281, "$target"
    get_how $P2282, $P2281
    find_lex $P2283, "$target"
    $S2284 = $P2282."name"($P2283)
    concat $P2285, $P2280, $S2284
.annotate 'line', 943
    concat $P2286, $P2285, "', but a role also wishes to compose it"
.annotate 'line', 944
    die $P2286
  if_2271_end:
.annotate 'line', 946
    find_lex $P2287, "$target"
    get_how $P2288, $P2287
    find_lex $P2289, "$target"
    find_lex $P2290, "$_"
    $P2291 = $P2288."add_attribute"($P2289, $P2290)
.annotate 'line', 941
    .return ($P2291)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2307"  :subid("153_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 958
    .const 'Sub' $P2530 = "163_1299465710.053" 
    capture_lex $P2530
    .const 'Sub' $P2310 = "154_1299465710.053" 
    capture_lex $P2310
    get_global $P2309, "$?CLASS"
.annotate 'line', 959
    .const 'Sub' $P2310 = "154_1299465710.053" 
    newclosure $P2528, $P2310
.annotate 'line', 958
    .return ($P2528)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "" :load :init :subid("post402") :outer("153_1299465710.053")
.annotate 'line', 958
    get_hll_global $P2308, ["RoleToRoleApplier"], "_block2307" 
    .local pmc block
    set block, $P2308
    .const 'Sub' $P2530 = "163_1299465710.053" 
    capture_lex $P2530
    $P2530()
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2529"  :anon :subid("163_1299465710.053") :outer("153_1299465710.053")
.annotate 'line', 958
    get_hll_global $P2531, "KnowHOW"
    $P2532 = $P2531."new_type"("RoleToRoleApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2532
    set_hll_global "RoleToRoleApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2533, type_obj
    .const 'Sub' $P2534 = "154_1299465710.053" 
    $P2533."add_method"(type_obj, "apply", $P2534)
    get_how $P2535, type_obj
    $P2536 = $P2535."compose"(type_obj)
    .return ($P2536)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("154_1299465710.053") :outer("153_1299465710.053")
    .param pmc param_2313
    .param pmc param_2314
    .param pmc param_2315
.annotate 'line', 959
    .const 'Sub' $P2455 = "160_1299465710.053" 
    capture_lex $P2455
    .const 'Sub' $P2413 = "159_1299465710.053" 
    capture_lex $P2413
    .const 'Sub' $P2399 = "158_1299465710.053" 
    capture_lex $P2399
    .const 'Sub' $P2326 = "155_1299465710.053" 
    capture_lex $P2326
    new $P2312, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2312, control_2311
    push_eh $P2312
    .lex "self", param_2313
    .lex "$target", param_2314
    .lex "@roles", param_2315
.annotate 'line', 961
    $P2316 = root_new ['parrot';'Hash']
    .lex "%meth_info", $P2316
.annotate 'line', 987
    $P2317 = root_new ['parrot';'Hash']
    .lex "%target_meth_info", $P2317
.annotate 'line', 988
    $P2318 = root_new ['parrot';'ResizablePMCArray']
    .lex "@target_meths", $P2318
.annotate 'line', 1013
    $P2319 = root_new ['parrot';'ResizablePMCArray']
    .lex "@all_roles", $P2319
.annotate 'line', 959
    find_lex $P2320, "%meth_info"
.annotate 'line', 962
    find_lex $P2322, "@roles"
    defined $I2323, $P2322
    unless $I2323, for_undef_403
    iter $P2321, $P2322
    new $P2387, 'ExceptionHandler'
    set_label $P2387, loop2386_handler
    $P2387."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2387
  loop2386_test:
    unless $P2321, loop2386_done
    shift $P2324, $P2321
  loop2386_redo:
    .const 'Sub' $P2326 = "155_1299465710.053" 
    capture_lex $P2326
    $P2326($P2324)
  loop2386_next:
    goto loop2386_test
  loop2386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2388, exception, 'type'
    eq $P2388, .CONTROL_LOOP_NEXT, loop2386_next
    eq $P2388, .CONTROL_LOOP_REDO, loop2386_redo
  loop2386_done:
    pop_eh 
  for_undef_403:
    find_lex $P2389, "%target_meth_info"
.annotate 'line', 988
    find_lex $P2390, "$target"
    get_how $P2391, $P2390
    find_lex $P2392, "$target"
    $P2393 = $P2391."methods"($P2392)
    store_lex "@target_meths", $P2393
.annotate 'line', 989
    find_lex $P2395, "@target_meths"
    defined $I2396, $P2395
    unless $I2396, for_undef_411
    iter $P2394, $P2395
    new $P2406, 'ExceptionHandler'
    set_label $P2406, loop2405_handler
    $P2406."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2406
  loop2405_test:
    unless $P2394, loop2405_done
    shift $P2397, $P2394
  loop2405_redo:
    .const 'Sub' $P2399 = "158_1299465710.053" 
    capture_lex $P2399
    $P2399($P2397)
  loop2405_next:
    goto loop2405_test
  loop2405_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2407, exception, 'type'
    eq $P2407, .CONTROL_LOOP_NEXT, loop2405_next
    eq $P2407, .CONTROL_LOOP_REDO, loop2405_redo
  loop2405_done:
    pop_eh 
  for_undef_411:
.annotate 'line', 994
    find_lex $P2409, "%meth_info"
    defined $I2410, $P2409
    unless $I2410, for_undef_413
    iter $P2408, $P2409
    new $P2447, 'ExceptionHandler'
    set_label $P2447, loop2446_handler
    $P2447."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2447
  loop2446_test:
    unless $P2408, loop2446_done
    shift $P2411, $P2408
  loop2446_redo:
    .const 'Sub' $P2413 = "159_1299465710.053" 
    capture_lex $P2413
    $P2413($P2411)
  loop2446_next:
    goto loop2446_test
  loop2446_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2448, exception, 'type'
    eq $P2448, .CONTROL_LOOP_NEXT, loop2446_next
    eq $P2448, .CONTROL_LOOP_REDO, loop2446_redo
  loop2446_done:
    pop_eh 
  for_undef_413:
    find_lex $P2449, "@all_roles"
.annotate 'line', 1014
    find_lex $P2451, "@roles"
    defined $I2452, $P2451
    unless $I2452, for_undef_420
    iter $P2450, $P2451
    new $P2523, 'ExceptionHandler'
    set_label $P2523, loop2522_handler
    $P2523."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2523
  loop2522_test:
    unless $P2450, loop2522_done
    shift $P2453, $P2450
  loop2522_redo:
    .const 'Sub' $P2455 = "160_1299465710.053" 
    capture_lex $P2455
    $P2455($P2453)
  loop2522_next:
    goto loop2522_test
  loop2522_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2524, exception, 'type'
    eq $P2524, .CONTROL_LOOP_NEXT, loop2522_next
    eq $P2524, .CONTROL_LOOP_REDO, loop2522_redo
  loop2522_done:
    pop_eh 
  for_undef_420:
.annotate 'line', 1043
    new $P2525, "Exception"
    set $P2525['type'], .CONTROL_RETURN
    find_lex $P2526, "@all_roles"
    setattribute $P2525, 'payload', $P2526
    throw $P2525
.annotate 'line', 959
    .return ()
  control_2311:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2527, exception, "payload"
    .return ($P2527)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2325"  :anon :subid("155_1299465710.053") :outer("154_1299465710.053")
    .param pmc param_2328
.annotate 'line', 962
    .const 'Sub' $P2338 = "156_1299465710.053" 
    capture_lex $P2338
.annotate 'line', 963
    $P2327 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2327
    .lex "$_", param_2328
    find_lex $P2329, "$_"
    get_how $P2330, $P2329
    find_lex $P2331, "$_"
    $P2332 = $P2330."methods"($P2331)
    store_lex "@methods", $P2332
.annotate 'line', 964
    find_lex $P2334, "@methods"
    defined $I2335, $P2334
    unless $I2335, for_undef_404
    iter $P2333, $P2334
    new $P2384, 'ExceptionHandler'
    set_label $P2384, loop2383_handler
    $P2384."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2384
  loop2383_test:
    unless $P2333, loop2383_done
    shift $P2336, $P2333
  loop2383_redo:
    .const 'Sub' $P2338 = "156_1299465710.053" 
    capture_lex $P2338
    $P2338($P2336)
  loop2383_next:
    goto loop2383_test
  loop2383_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2385, exception, 'type'
    eq $P2385, .CONTROL_LOOP_NEXT, loop2383_next
    eq $P2385, .CONTROL_LOOP_REDO, loop2383_redo
  loop2383_done:
    pop_eh 
  for_undef_404:
.annotate 'line', 962
    .return ($P2333)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2337"  :anon :subid("156_1299465710.053") :outer("155_1299465710.053")
    .param pmc param_2343
.annotate 'line', 964
    .const 'Sub' $P2366 = "157_1299465710.053" 
    capture_lex $P2366
.annotate 'line', 965
    new $P2339, "Undef"
    .lex "$name", $P2339
.annotate 'line', 966
    new $P2340, "Undef"
    .lex "$meth", $P2340
.annotate 'line', 967
    $P2341 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meth_list", $P2341
.annotate 'line', 974
    new $P2342, "Undef"
    .lex "$found", $P2342
    .lex "$_", param_2343
.annotate 'line', 965
    find_lex $P2344, "$_"
    set $S2345, $P2344
    new $P2346, 'String'
    set $P2346, $S2345
    store_lex "$name", $P2346
.annotate 'line', 966
    find_lex $P2347, "$_"
    store_lex "$meth", $P2347
    find_lex $P2348, "@meth_list"
.annotate 'line', 968
    find_lex $P2350, "$name"
    find_lex $P2351, "%meth_info"
    unless_null $P2351, vivify_405
    $P2351 = root_new ['parrot';'Hash']
  vivify_405:
    set $P2352, $P2351[$P2350]
    unless_null $P2352, vivify_406
    new $P2352, "Undef"
  vivify_406:
    defined $I2353, $P2352
    if $I2353, if_2349
.annotate 'line', 972
    find_lex $P2357, "@meth_list"
    find_lex $P2358, "$name"
    find_lex $P2359, "%meth_info"
    unless_null $P2359, vivify_407
    $P2359 = root_new ['parrot';'Hash']
    store_lex "%meth_info", $P2359
  vivify_407:
    set $P2359[$P2358], $P2357
.annotate 'line', 971
    goto if_2349_end
  if_2349:
.annotate 'line', 969
    find_lex $P2354, "$name"
    find_lex $P2355, "%meth_info"
    unless_null $P2355, vivify_408
    $P2355 = root_new ['parrot';'Hash']
  vivify_408:
    set $P2356, $P2355[$P2354]
    unless_null $P2356, vivify_409
    new $P2356, "Undef"
  vivify_409:
    store_lex "@meth_list", $P2356
  if_2349_end:
.annotate 'line', 974
    new $P2360, "Integer"
    assign $P2360, 0
    store_lex "$found", $P2360
.annotate 'line', 975
    find_lex $P2362, "@meth_list"
    defined $I2363, $P2362
    unless $I2363, for_undef_410
    iter $P2361, $P2362
    new $P2375, 'ExceptionHandler'
    set_label $P2375, loop2374_handler
    $P2375."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2375
  loop2374_test:
    unless $P2361, loop2374_done
    shift $P2364, $P2361
  loop2374_redo:
    .const 'Sub' $P2366 = "157_1299465710.053" 
    capture_lex $P2366
    $P2366($P2364)
  loop2374_next:
    goto loop2374_test
  loop2374_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2376, exception, 'type'
    eq $P2376, .CONTROL_LOOP_NEXT, loop2374_next
    eq $P2376, .CONTROL_LOOP_REDO, loop2374_redo
  loop2374_done:
    pop_eh 
  for_undef_410:
.annotate 'line', 980
    find_lex $P2379, "$found"
    unless $P2379, unless_2378
    set $P2377, $P2379
    goto unless_2378_end
  unless_2378:
.annotate 'line', 981
    find_lex $P2380, "@meth_list"
    find_lex $P2381, "$meth"
    $P2382 = $P2380."push"($P2381)
.annotate 'line', 980
    set $P2377, $P2382
  unless_2378_end:
.annotate 'line', 964
    .return ($P2377)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2365"  :anon :subid("157_1299465710.053") :outer("156_1299465710.053")
    .param pmc param_2367
.annotate 'line', 975
    .lex "$_", param_2367
.annotate 'line', 976
    find_lex $P2370, "$meth"
    find_lex $P2371, "$_"
    issame $I2372, $P2370, $P2371
    if $I2372, if_2369
    new $P2368, 'Integer'
    set $P2368, $I2372
    goto if_2369_end
  if_2369:
.annotate 'line', 977
    new $P2373, "Integer"
    assign $P2373, 1
    store_lex "$found", $P2373
.annotate 'line', 976
    set $P2368, $P2373
  if_2369_end:
.annotate 'line', 975
    .return ($P2368)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2398"  :anon :subid("158_1299465710.053") :outer("154_1299465710.053")
    .param pmc param_2400
.annotate 'line', 989
    .lex "$_", param_2400
.annotate 'line', 990
    find_lex $P2401, "$_"
    find_lex $P2402, "$_"
    set $S2403, $P2402
    find_lex $P2404, "%target_meth_info"
    unless_null $P2404, vivify_412
    $P2404 = root_new ['parrot';'Hash']
    store_lex "%target_meth_info", $P2404
  vivify_412:
    set $P2404[$S2403], $P2401
.annotate 'line', 989
    .return ($P2401)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2412"  :anon :subid("159_1299465710.053") :outer("154_1299465710.053")
    .param pmc param_2416
.annotate 'line', 995
    new $P2414, "Undef"
    .lex "$name", $P2414
.annotate 'line', 996
    $P2415 = root_new ['parrot';'ResizablePMCArray']
    .lex "@add_meths", $P2415
    .lex "$_", param_2416
.annotate 'line', 995
    find_lex $P2417, "$_"
    set $S2418, $P2417
    new $P2419, 'String'
    set $P2419, $S2418
    store_lex "$name", $P2419
.annotate 'line', 996
    find_lex $P2420, "$name"
    find_lex $P2421, "%meth_info"
    unless_null $P2421, vivify_414
    $P2421 = root_new ['parrot';'Hash']
  vivify_414:
    set $P2422, $P2421[$P2420]
    unless_null $P2422, vivify_415
    new $P2422, "Undef"
  vivify_415:
    store_lex "@add_meths", $P2422
.annotate 'line', 1000
    find_lex $P2425, "$name"
    find_lex $P2426, "%target_meth_info"
    unless_null $P2426, vivify_416
    $P2426 = root_new ['parrot';'Hash']
  vivify_416:
    set $P2427, $P2426[$P2425]
    unless_null $P2427, vivify_417
    new $P2427, "Undef"
  vivify_417:
    defined $I2428, $P2427
    unless $I2428, unless_2424
    new $P2423, 'Integer'
    set $P2423, $I2428
    goto unless_2424_end
  unless_2424:
.annotate 'line', 1002
    find_lex $P2431, "@add_meths"
    set $N2432, $P2431
    iseq $I2433, $N2432, 1.0
    if $I2433, if_2430
.annotate 'line', 1007
    find_lex $P2441, "$target"
    get_how $P2442, $P2441
    find_lex $P2443, "$target"
    find_lex $P2444, "$name"
    $P2445 = $P2442."add_collision"($P2443, $P2444)
.annotate 'line', 1005
    set $P2429, $P2445
.annotate 'line', 1002
    goto if_2430_end
  if_2430:
.annotate 'line', 1003
    find_lex $P2434, "$target"
    get_how $P2435, $P2434
    find_lex $P2436, "$target"
    find_lex $P2437, "$name"
    find_lex $P2438, "@add_meths"
    unless_null $P2438, vivify_418
    $P2438 = root_new ['parrot';'ResizablePMCArray']
  vivify_418:
    set $P2439, $P2438[0]
    unless_null $P2439, vivify_419
    new $P2439, "Undef"
  vivify_419:
    $P2440 = $P2435."add_method"($P2436, $P2437, $P2439)
.annotate 'line', 1002
    set $P2429, $P2440
  if_2430_end:
.annotate 'line', 1000
    set $P2423, $P2429
  unless_2424_end:
.annotate 'line', 994
    .return ($P2423)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2454"  :anon :subid("160_1299465710.053") :outer("154_1299465710.053")
    .param pmc param_2458
.annotate 'line', 1014
    .const 'Sub' $P2469 = "161_1299465710.053" 
    capture_lex $P2469
.annotate 'line', 1015
    new $P2456, "Undef"
    .lex "$how", $P2456
.annotate 'line', 1018
    $P2457 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2457
    .lex "$_", param_2458
.annotate 'line', 1015
    find_lex $P2459, "$_"
    get_how $P2460, $P2459
    store_lex "$how", $P2460
.annotate 'line', 1018
    find_lex $P2461, "$how"
    find_lex $P2462, "$_"
    $P2463 = $P2461."attributes"($P2462)
    store_lex "@attributes", $P2463
.annotate 'line', 1019
    find_lex $P2465, "@attributes"
    defined $I2466, $P2465
    unless $I2466, for_undef_421
    iter $P2464, $P2465
    new $P2517, 'ExceptionHandler'
    set_label $P2517, loop2516_handler
    $P2517."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2517
  loop2516_test:
    unless $P2464, loop2516_done
    shift $P2467, $P2464
  loop2516_redo:
    .const 'Sub' $P2469 = "161_1299465710.053" 
    capture_lex $P2469
    $P2469($P2467)
  loop2516_next:
    goto loop2516_test
  loop2516_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2518, exception, 'type'
    eq $P2518, .CONTROL_LOOP_NEXT, loop2516_next
    eq $P2518, .CONTROL_LOOP_REDO, loop2516_redo
  loop2516_done:
    pop_eh 
  for_undef_421:
.annotate 'line', 1040
    find_lex $P2519, "@all_roles"
    find_lex $P2520, "$_"
    $P2521 = $P2519."push"($P2520)
.annotate 'line', 1014
    .return ($P2521)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2468"  :anon :subid("161_1299465710.053") :outer("160_1299465710.053")
    .param pmc param_2473
.annotate 'line', 1019
    .const 'Sub' $P2485 = "162_1299465710.053" 
    capture_lex $P2485
.annotate 'line', 1020
    new $P2470, "Undef"
    .lex "$add_attr", $P2470
.annotate 'line', 1021
    new $P2471, "Undef"
    .lex "$skip", $P2471
.annotate 'line', 1022
    $P2472 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cur_attrs", $P2472
    .lex "$_", param_2473
.annotate 'line', 1020
    find_lex $P2474, "$_"
    store_lex "$add_attr", $P2474
.annotate 'line', 1021
    new $P2475, "Integer"
    assign $P2475, 0
    store_lex "$skip", $P2475
.annotate 'line', 1022
    find_lex $P2476, "$target"
    get_how $P2477, $P2476
    find_lex $P2478, "$target"
    $P2479 = $P2477."attributes"($P2478)
    store_lex "@cur_attrs", $P2479
.annotate 'line', 1023
    find_lex $P2481, "@cur_attrs"
    defined $I2482, $P2481
    unless $I2482, for_undef_422
    iter $P2480, $P2481
    new $P2506, 'ExceptionHandler'
    set_label $P2506, loop2505_handler
    $P2506."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2506
  loop2505_test:
    unless $P2480, loop2505_done
    shift $P2483, $P2480
  loop2505_redo:
    .const 'Sub' $P2485 = "162_1299465710.053" 
    capture_lex $P2485
    $P2485($P2483)
  loop2505_next:
    goto loop2505_test
  loop2505_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2507, exception, 'type'
    eq $P2507, .CONTROL_LOOP_NEXT, loop2505_next
    eq $P2507, .CONTROL_LOOP_REDO, loop2505_redo
  loop2505_done:
    pop_eh 
  for_undef_422:
.annotate 'line', 1033
    find_lex $P2510, "$skip"
    unless $P2510, unless_2509
    set $P2508, $P2510
    goto unless_2509_end
  unless_2509:
.annotate 'line', 1034
    find_lex $P2511, "$target"
    get_how $P2512, $P2511
    find_lex $P2513, "$target"
    find_lex $P2514, "$add_attr"
    $P2515 = $P2512."add_attribute"($P2513, $P2514)
.annotate 'line', 1033
    set $P2508, $P2515
  unless_2509_end:
.annotate 'line', 1019
    .return ($P2508)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2484"  :anon :subid("162_1299465710.053") :outer("161_1299465710.053")
    .param pmc param_2486
.annotate 'line', 1023
    .lex "$_", param_2486
.annotate 'line', 1024
    find_lex $P2489, "$_"
    find_lex $P2490, "$add_attr"
    issame $I2491, $P2489, $P2490
    if $I2491, if_2488
.annotate 'line', 1028
    find_lex $P2495, "$_"
    $S2496 = $P2495."name"()
    find_lex $P2497, "$add_attr"
    $S2498 = $P2497."name"()
    iseq $I2499, $S2496, $S2498
    if $I2499, if_2494
    new $P2493, 'Integer'
    set $P2493, $I2499
    goto if_2494_end
  if_2494:
.annotate 'line', 1029
    new $P2500, "String"
    assign $P2500, "Attribute '"
    find_lex $P2501, "$_"
    $S2502 = $P2501."name"()
    concat $P2503, $P2500, $S2502
    concat $P2504, $P2503, "' conflicts in role composition"
    die $P2504
  if_2494_end:
.annotate 'line', 1027
    set $P2487, $P2493
.annotate 'line', 1024
    goto if_2488_end
  if_2488:
.annotate 'line', 1025
    new $P2492, "Integer"
    assign $P2492, 1
    store_lex "$skip", $P2492
.annotate 'line', 1024
    set $P2487, $P2492
  if_2488_end:
.annotate 'line', 1023
    .return ($P2487)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "_block2537"  :subid("164_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 1048
    .const 'Sub' $P2599 = "173_1299465710.053" 
    capture_lex $P2599
    .const 'Sub' $P2591 = "172_1299465710.053" 
    capture_lex $P2591
    .const 'Sub' $P2585 = "171_1299465710.053" 
    capture_lex $P2585
    .const 'Sub' $P2581 = "170_1299465710.053" 
    capture_lex $P2581
    .const 'Sub' $P2576 = "169_1299465710.053" 
    capture_lex $P2576
    .const 'Sub' $P2571 = "168_1299465710.053" 
    capture_lex $P2571
    .const 'Sub' $P2557 = "167_1299465710.053" 
    capture_lex $P2557
    .const 'Sub' $P2550 = "166_1299465710.053" 
    capture_lex $P2550
    .const 'Sub' $P2540 = "165_1299465710.053" 
    capture_lex $P2540
    get_global $P2539, "$?CLASS"
.annotate 'line', 1087
    .const 'Sub' $P2591 = "172_1299465710.053" 
    newclosure $P2597, $P2591
.annotate 'line', 1048
    .return ($P2597)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "" :load :init :subid("post423") :outer("164_1299465710.053")
.annotate 'line', 1048
    get_hll_global $P2538, ["NQPModuleHOW"], "_block2537" 
    .local pmc block
    set block, $P2538
    .const 'Sub' $P2599 = "173_1299465710.053" 
    capture_lex $P2599
    $P2599()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "_block2598"  :anon :subid("173_1299465710.053") :outer("164_1299465710.053")
.annotate 'line', 1048
    get_hll_global $P2600, "KnowHOW"
    $P2601 = $P2600."new_type"("NQPModuleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2601
    set_hll_global "NQPModuleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2602, type_obj
    get_hll_global $P2603, "KnowHOWAttribute"
    $P2604 = $P2603."new"("$!name" :named("name"))
    $P2602."add_attribute"(type_obj, $P2604)
    get_how $P2605, type_obj
    get_hll_global $P2606, "KnowHOWAttribute"
    $P2607 = $P2606."new"("$!composed" :named("name"))
    $P2605."add_attribute"(type_obj, $P2607)
    get_how $P2608, type_obj
    .const 'Sub' $P2609 = "165_1299465710.053" 
    $P2608."add_method"(type_obj, "new", $P2609)
    get_how $P2610, type_obj
    .const 'Sub' $P2611 = "166_1299465710.053" 
    $P2610."add_method"(type_obj, "BUILD", $P2611)
    get_how $P2612, type_obj
    .const 'Sub' $P2613 = "167_1299465710.053" 
    $P2612."add_method"(type_obj, "new_type", $P2613)
    get_how $P2614, type_obj
    .const 'Sub' $P2615 = "168_1299465710.053" 
    $P2614."add_method"(type_obj, "add_method", $P2615)
    get_how $P2616, type_obj
    .const 'Sub' $P2617 = "169_1299465710.053" 
    $P2616."add_method"(type_obj, "add_multi_method", $P2617)
    get_how $P2618, type_obj
    .const 'Sub' $P2619 = "170_1299465710.053" 
    $P2618."add_method"(type_obj, "add_attribute", $P2619)
    get_how $P2620, type_obj
    .const 'Sub' $P2621 = "171_1299465710.053" 
    $P2620."add_method"(type_obj, "compose", $P2621)
    get_how $P2622, type_obj
    .const 'Sub' $P2623 = "172_1299465710.053" 
    $P2622."add_method"(type_obj, "name", $P2623)
    get_how $P2624, type_obj
    $P2625 = $P2624."compose"(type_obj)
    .return ($P2625)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "new"  :subid("165_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2541
    .param pmc param_2542 :optional :named("name")
    .param int has_param_2542 :opt_flag
.annotate 'line', 1052
    .lex "self", param_2541
    if has_param_2542, optparam_424
    new $P2543, "Undef"
    set param_2542, $P2543
  optparam_424:
    .lex "$name", param_2542
.annotate 'line', 1053
    new $P2544, "Undef"
    .lex "$obj", $P2544
    find_lex $P2545, "self"
    repr_instance_of $P2546, $P2545
    store_lex "$obj", $P2546
.annotate 'line', 1054
    find_lex $P2547, "$obj"
    find_lex $P2548, "$name"
    $P2547."BUILD"($P2548 :named("name"))
    find_lex $P2549, "$obj"
.annotate 'line', 1052
    .return ($P2549)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "BUILD"  :subid("166_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2551
    .param pmc param_2552 :optional :named("name")
    .param int has_param_2552 :opt_flag
.annotate 'line', 1058
    .lex "self", param_2551
    if has_param_2552, optparam_425
    new $P2553, "Undef"
    set param_2552, $P2553
  optparam_425:
    .lex "$name", param_2552
.annotate 'line', 1059
    find_lex $P2554, "$name"
    find_lex $P2555, "self"
    get_global $P2556, "$?CLASS"
    setattribute $P2555, $P2556, "$!name", $P2554
.annotate 'line', 1058
    .return ($P2554)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "new_type"  :subid("167_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2558
    .param pmc param_2559 :optional :named("name")
    .param int has_param_2559 :opt_flag
    .param pmc param_2561 :optional :named("repr")
    .param int has_param_2561 :opt_flag
.annotate 'line', 1064
    .lex "self", param_2558
    if has_param_2559, optparam_426
    new $P2560, "String"
    assign $P2560, "<anon>"
    set param_2559, $P2560
  optparam_426:
    .lex "$name", param_2559
    if has_param_2561, optparam_427
    new $P2562, "String"
    assign $P2562, "P6opaque"
    set param_2561, $P2562
  optparam_427:
    .lex "$repr", param_2561
.annotate 'line', 1065
    new $P2563, "Undef"
    .lex "$metaclass", $P2563
    find_lex $P2564, "self"
    find_lex $P2565, "$name"
    $P2566 = $P2564."new"($P2565 :named("name"))
    store_lex "$metaclass", $P2566
.annotate 'line', 1066
    find_lex $P2567, "$metaclass"
    find_lex $P2568, "$repr"
    set $S2569, $P2568
    repr_type_object_for $P2570, $P2567, $S2569
.annotate 'line', 1064
    .return ($P2570)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "add_method"  :subid("168_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2572
    .param pmc param_2573
    .param pmc param_2574
    .param pmc param_2575
.annotate 'line', 1069
    .lex "self", param_2572
    .lex "$obj", param_2573
    .lex "$name", param_2574
    .lex "$code_obj", param_2575
    .return ()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "add_multi_method"  :subid("169_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2577
    .param pmc param_2578
    .param pmc param_2579
    .param pmc param_2580
.annotate 'line', 1075
    .lex "self", param_2577
    .lex "$obj", param_2578
    .lex "$name", param_2579
    .lex "$code_obj", param_2580
.annotate 'line', 1076
    die "Modules may not have methods"
.annotate 'line', 1075
    .return ()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "add_attribute"  :subid("170_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2582
    .param pmc param_2583
    .param pmc param_2584
.annotate 'line', 1079
    .lex "self", param_2582
    .lex "$obj", param_2583
    .lex "$meta_attr", param_2584
.annotate 'line', 1080
    die "Modules may not have attributes"
.annotate 'line', 1079
    .return ()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "compose"  :subid("171_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2586
    .param pmc param_2587
.annotate 'line', 1083
    .lex "self", param_2586
    .lex "$obj", param_2587
.annotate 'line', 1084
    new $P2588, "Integer"
    assign $P2588, 1
    find_lex $P2589, "self"
    get_global $P2590, "$?CLASS"
    setattribute $P2589, $P2590, "$!composed", $P2588
.annotate 'line', 1083
    .return ($P2588)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "name"  :subid("172_1299465710.053") :outer("164_1299465710.053")
    .param pmc param_2592
    .param pmc param_2593
.annotate 'line', 1087
    .lex "self", param_2592
    .lex "$obj", param_2593
    find_lex $P2594, "self"
    get_global $P2595, "$?CLASS"
    getattribute $P2596, $P2594, $P2595, "$!name"
    unless_null $P2596, vivify_428
    new $P2596, "Undef"
  vivify_428:
    .return ($P2596)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2626"  :subid("174_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 1093
    .const 'Sub' $P2748 = "187_1299465710.053" 
    capture_lex $P2748
    .const 'Sub' $P2738 = "186_1299465710.053" 
    capture_lex $P2738
    .const 'Sub' $P2726 = "185_1299465710.053" 
    capture_lex $P2726
    .const 'Sub' $P2722 = "184_1299465710.053" 
    capture_lex $P2722
    .const 'Sub' $P2711 = "183_1299465710.053" 
    capture_lex $P2711
    .const 'Sub' $P2708 = "182_1299465710.053" 
    capture_lex $P2708
    .const 'Sub' $P2702 = "181_1299465710.053" 
    capture_lex $P2702
    .const 'Sub' $P2664 = "179_1299465710.053" 
    capture_lex $P2664
    .const 'Sub' $P2643 = "177_1299465710.053" 
    capture_lex $P2643
    .const 'Sub' $P2633 = "176_1299465710.053" 
    capture_lex $P2633
    .const 'Sub' $P2629 = "175_1299465710.053" 
    capture_lex $P2629
    get_global $P2628, "$?CLASS"
.annotate 'line', 1135
    .const 'Sub' $P2738 = "186_1299465710.053" 
    newclosure $P2746, $P2738
.annotate 'line', 1093
    .return ($P2746)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "" :load :init :subid("post429") :outer("174_1299465710.053")
.annotate 'line', 1093
    get_hll_global $P2627, ["NQPMu"], "_block2626" 
    .local pmc block
    set block, $P2627
    .const 'Sub' $P2748 = "187_1299465710.053" 
    capture_lex $P2748
    $P2748()
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2747"  :anon :subid("187_1299465710.053") :outer("174_1299465710.053")
.annotate 'line', 1093
    .const 'Sub' $P2765 = "182_1299465710.053" 
    capture_lex $P2765
    get_hll_global $P2749, "NQPClassHOW"
    $P2750 = $P2749."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P2750
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2751, type_obj
    .const 'Sub' $P2752 = "175_1299465710.053" 
    $P2751."add_method"(type_obj, "CREATE", $P2752)
    get_how $P2753, type_obj
    .const 'Sub' $P2754 = "176_1299465710.053" 
    $P2753."add_method"(type_obj, "bless", $P2754)
    get_how $P2755, type_obj
    .const 'Sub' $P2756 = "177_1299465710.053" 
    $P2755."add_method"(type_obj, "BUILDALL", $P2756)
    get_how $P2757, type_obj
    .const 'Sub' $P2758 = "179_1299465710.053" 
    $P2757."add_method"(type_obj, "BUILD_MAGIC", $P2758)
    get_how $P2759, type_obj
    .const 'Sub' $P2760 = "181_1299465710.053" 
    $P2759."add_method"(type_obj, "new", $P2760)
    get_how $P2761, type_obj
    .const 'Sub' $P2762 = "182_1299465710.053" 
    new $P2763, "ResizablePMCArray"
    set_dispatchees $P2762, $P2763
    $P2761."add_method"(type_obj, "Str", $P2762)
    get_how $P2764, type_obj
    .const 'Sub' $P2765 = "182_1299465710.053" 
    newclosure $P2768, $P2765
    $P2764."add_parrot_vtable_mapping"(type_obj, "get_string", $P2768)
    get_how $P2769, type_obj
    .const 'Sub' $P2770 = "183_1299465710.053" 
    $P2769."add_multi_method"(type_obj, "Str", $P2770)
    get_how $P2771, type_obj
    .const 'Sub' $P2772 = "184_1299465710.053" 
    new $P2773, "ResizablePMCArray"
    set_dispatchees $P2772, $P2773
    $P2771."add_method"(type_obj, "ACCEPTS", $P2772)
    get_how $P2774, type_obj
    .const 'Sub' $P2775 = "185_1299465710.053" 
    $P2774."add_multi_method"(type_obj, "ACCEPTS", $P2775)
    get_how $P2776, type_obj
    .const 'Sub' $P2777 = "186_1299465710.053" 
    $P2776."add_method"(type_obj, "isa", $P2777)
    get_how $P2778, type_obj
    $P2779 = $P2778."compose"(type_obj)
    .return ($P2779)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("182_1299465710.053") :outer("187_1299465710.053")
    .param pmc param_2766
.annotate 'line', 1093
    .lex "self", param_2766
    multi_dispatch_over_lexical_candidates $P2767
    .return ($P2767)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "CREATE"  :subid("175_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2630
.annotate 'line', 1094
    .lex "self", param_2630
.annotate 'line', 1095
    find_lex $P2631, "self"
    repr_instance_of $P2632, $P2631
.annotate 'line', 1094
    .return ($P2632)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "bless"  :subid("176_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2634
    .param pmc param_2636 :slurpy :named
.annotate 'line', 1099
    .lex "$self", param_2634
    find_lex $P2635, "$self"
    .lex "self", $P2635
    .lex "%attributes", param_2636
.annotate 'line', 1100
    new $P2637, "Undef"
    .lex "$instance", $P2637
    find_lex $P2638, "self"
    $P2639 = $P2638."CREATE"()
    store_lex "$instance", $P2639
.annotate 'line', 1101
    find_lex $P2640, "$instance"
    find_lex $P2641, "%attributes"
    $P2640."BUILDALL"($P2641 :flat)
    find_lex $P2642, "$instance"
.annotate 'line', 1099
    .return ($P2642)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILDALL"  :subid("177_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2644
    .param pmc param_2646 :slurpy :named
.annotate 'line', 1105
    .const 'Sub' $P2655 = "178_1299465710.053" 
    capture_lex $P2655
    .lex "$self", param_2644
    find_lex $P2645, "$self"
    .lex "self", $P2645
    .lex "%attributes", param_2646
.annotate 'line', 1106
    find_lex $P2648, "$self"
    get_how $P2649, $P2648
    find_lex $P2650, "$self"
    $P2651 = $P2649."parents"($P2650)
    defined $I2652, $P2651
    unless $I2652, for_undef_430
    iter $P2647, $P2651
    new $P2662, 'ExceptionHandler'
    set_label $P2662, loop2661_handler
    $P2662."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2662
  loop2661_test:
    unless $P2647, loop2661_done
    shift $P2653, $P2647
  loop2661_redo:
    .const 'Sub' $P2655 = "178_1299465710.053" 
    capture_lex $P2655
    $P2655($P2653)
  loop2661_next:
    goto loop2661_test
  loop2661_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2663, exception, 'type'
    eq $P2663, .CONTROL_LOOP_NEXT, loop2661_next
    eq $P2663, .CONTROL_LOOP_REDO, loop2661_redo
  loop2661_done:
    pop_eh 
  for_undef_430:
.annotate 'line', 1105
    .return ($P2647)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2654"  :anon :subid("178_1299465710.053") :outer("177_1299465710.053")
    .param pmc param_2656
.annotate 'line', 1106
    .lex "$class", param_2656
.annotate 'line', 1107
    find_lex $P2657, "$self"
    find_lex $P2658, "$class"
    find_lex $P2659, "%attributes"
    $P2660 = $P2657."BUILD_MAGIC"($P2658, $P2659 :flat)
.annotate 'line', 1106
    .return ($P2660)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILD_MAGIC"  :subid("179_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2665
    .param pmc param_2667
    .param pmc param_2668 :slurpy :named
.annotate 'line', 1111
    .const 'Sub' $P2677 = "180_1299465710.053" 
    capture_lex $P2677
    .lex "$self", param_2665
    find_lex $P2666, "$self"
    .lex "self", $P2666
    .lex "$type", param_2667
    .lex "%attributes", param_2668
.annotate 'line', 1112
    find_lex $P2670, "$type"
    get_how $P2671, $P2670
    find_lex $P2672, "$type"
    $P2673 = $P2671."attributes"($P2672, 1 :named("local"))
    defined $I2674, $P2673
    unless $I2674, for_undef_431
    iter $P2669, $P2673
    new $P2700, 'ExceptionHandler'
    set_label $P2700, loop2699_handler
    $P2700."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2700
  loop2699_test:
    unless $P2669, loop2699_done
    shift $P2675, $P2669
  loop2699_redo:
    .const 'Sub' $P2677 = "180_1299465710.053" 
    capture_lex $P2677
    $P2677($P2675)
  loop2699_next:
    goto loop2699_test
  loop2699_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2701, exception, 'type'
    eq $P2701, .CONTROL_LOOP_NEXT, loop2699_next
    eq $P2701, .CONTROL_LOOP_REDO, loop2699_redo
  loop2699_done:
    pop_eh 
  for_undef_431:
.annotate 'line', 1111
    .return ($P2669)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2676"  :anon :subid("180_1299465710.053") :outer("179_1299465710.053")
    .param pmc param_2680
.annotate 'line', 1113
    new $P2678, "Undef"
    .lex "$name", $P2678
.annotate 'line', 1114
    new $P2679, "Undef"
    .lex "$shortname", $P2679
    .lex "$_", param_2680
.annotate 'line', 1113
    find_lex $P2681, "$_"
    $P2682 = $P2681."name"()
    store_lex "$name", $P2682
.annotate 'line', 1114
    find_lex $P2683, "$name"
    set $S2684, $P2683
    substr $S2685, $S2684, 2
    new $P2686, 'String'
    set $P2686, $S2685
    store_lex "$shortname", $P2686
.annotate 'line', 1115
    find_lex $P2690, "$shortname"
    find_lex $P2689, "%attributes"
    exists $I2691, $P2689[$P2690]
    if $I2691, if_2688
    new $P2687, 'Integer'
    set $P2687, $I2691
    goto if_2688_end
  if_2688:
.annotate 'line', 1116
    find_lex $P2692, "$self"
    find_lex $P2693, "$type"
    find_lex $P2694, "$name"
    set $S2695, $P2694
    find_lex $P2696, "$shortname"
    find_lex $P2697, "%attributes"
    unless_null $P2697, vivify_432
    $P2697 = root_new ['parrot';'Hash']
  vivify_432:
    set $P2698, $P2697[$P2696]
    unless_null $P2698, vivify_433
    new $P2698, "Undef"
  vivify_433:
    setattribute $P2692, $P2693, $S2695, $P2698
  if_2688_end:
.annotate 'line', 1112
    .return ($P2687)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "new"  :subid("181_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2703
    .param pmc param_2704 :slurpy :named
.annotate 'line', 1121
    .lex "self", param_2703
    .lex "%attributes", param_2704
.annotate 'line', 1122
    find_lex $P2705, "self"
    find_lex $P2706, "%attributes"
    $P2707 = $P2705."bless"($P2706 :flat)
.annotate 'line', 1121
    .return ($P2707)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("182_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2709
.annotate 'line', 1121
    .lex "self", param_2709
    multi_dispatch_over_lexical_candidates $P2710
    .return ($P2710)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "Str"  :subid("183_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2712
.annotate 'line', 1126
    .lex "$self", param_2712
    find_lex $P2713, "$self"
    .lex "self", $P2713
.annotate 'line', 1127
    find_lex $P2714, "self"
    get_how $P2715, $P2714
    find_lex $P2716, "self"
    $P2717 = $P2715."name"($P2716)
    concat $P2718, $P2717, "()"
.annotate 'line', 1126
    .return ($P2718)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "" :load :init :subid("post434") :outer("183_1299465710.053")
.annotate 'line', 1126
    .const 'Sub' $P2711 = "183_1299465710.053" 
    .local pmc block
    set block, $P2711
    get_hll_global $P2719, "Mu"
    new $P2720, "ResizablePMCArray"
    push $P2720, $P2719
    new $P2721, "ResizablePMCArray"
    push $P2721, 2
    set_sub_multisig block, $P2720, $P2721
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("184_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2723
    .param pmc param_2724
.annotate 'line', 1126
    .lex "self", param_2723
.annotate 'line', 1130
    .lex "$topic", param_2724
.annotate 'line', 1126
    multi_dispatch_over_lexical_candidates $P2725
    .return ($P2725)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("185_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2727
    .param pmc param_2729
.annotate 'line', 1131
    .lex "$self", param_2727
    find_lex $P2728, "$self"
    .lex "self", $P2728
    .lex "$topic", param_2729
.annotate 'line', 1132
    find_lex $P2730, "$topic"
    find_lex $P2731, "self"
    get_what $P2732, $P2731
    type_check $I2733, $P2730, $P2732
.annotate 'line', 1131
    .return ($I2733)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "" :load :init :subid("post435") :outer("185_1299465710.053")
.annotate 'line', 1131
    .const 'Sub' $P2726 = "185_1299465710.053" 
    .local pmc block
    set block, $P2726
    get_hll_global $P2734, "NQPMu"
    null $P2735
    new $P2736, "ResizablePMCArray"
    push $P2736, $P2734
    push $P2736, $P2735
    new $P2737, "ResizablePMCArray"
    push $P2737, 2
    push $P2737, 0
    set_sub_multisig block, $P2736, $P2737
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "isa"  :subid("186_1299465710.053") :outer("174_1299465710.053")
    .param pmc param_2739
    .param pmc param_2740
.annotate 'line', 1135
    .lex "self", param_2739
    .lex "$type", param_2740
.annotate 'line', 1136
    find_lex $P2741, "self"
    get_how $P2742, $P2741
    find_lex $P2743, "self"
    find_lex $P2744, "$type"
    $P2745 = $P2742."isa"($P2743, $P2744)
.annotate 'line', 1135
    .return ($P2745)
.end


.HLL "nqp"

.namespace ["int"]
.sub "_block2780"  :subid("188_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 1142
    .const 'Sub' $P2784 = "189_1299465710.053" 
    capture_lex $P2784
    get_global $P2782, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["int"]
.sub "" :load :init :subid("post436") :outer("188_1299465710.053")
.annotate 'line', 1142
    get_hll_global $P2781, ["int"], "_block2780" 
    .local pmc block
    set block, $P2781
    .const 'Sub' $P2784 = "189_1299465710.053" 
    capture_lex $P2784
    $P2784()
.end


.HLL "nqp"

.namespace ["int"]
.sub "_block2783"  :anon :subid("189_1299465710.053") :outer("188_1299465710.053")
.annotate 'line', 1142
    get_hll_global $P2785, "NQPNativeHOW"
    $P2786 = $P2785."new_type"("int" :named("name"), "P6int" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2786
    set_hll_global "int", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2787, type_obj
    $P2788 = $P2787."compose"(type_obj)
    .return ($P2788)
.end


.HLL "nqp"

.namespace ["num"]
.sub "_block2789"  :subid("190_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 1144
    .const 'Sub' $P2793 = "191_1299465710.053" 
    capture_lex $P2793
    get_global $P2791, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["num"]
.sub "" :load :init :subid("post437") :outer("190_1299465710.053")
.annotate 'line', 1144
    get_hll_global $P2790, ["num"], "_block2789" 
    .local pmc block
    set block, $P2790
    .const 'Sub' $P2793 = "191_1299465710.053" 
    capture_lex $P2793
    $P2793()
.end


.HLL "nqp"

.namespace ["num"]
.sub "_block2792"  :anon :subid("191_1299465710.053") :outer("190_1299465710.053")
.annotate 'line', 1144
    get_hll_global $P2794, "NQPNativeHOW"
    $P2795 = $P2794."new_type"("num" :named("name"), "P6num" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2795
    set_hll_global "num", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2796, type_obj
    $P2797 = $P2796."compose"(type_obj)
    .return ($P2797)
.end


.HLL "nqp"

.namespace ["str"]
.sub "_block2798"  :subid("192_1299465710.053") :outer("10_1299465710.053")
.annotate 'line', 1146
    .const 'Sub' $P2802 = "193_1299465710.053" 
    capture_lex $P2802
    get_global $P2800, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["str"]
.sub "" :load :init :subid("post438") :outer("192_1299465710.053")
.annotate 'line', 1146
    get_hll_global $P2799, ["str"], "_block2798" 
    .local pmc block
    set block, $P2799
    .const 'Sub' $P2802 = "193_1299465710.053" 
    capture_lex $P2802
    $P2802()
.end


.HLL "nqp"

.namespace ["str"]
.sub "_block2801"  :anon :subid("193_1299465710.053") :outer("192_1299465710.053")
.annotate 'line', 1146
    get_hll_global $P2803, "NQPNativeHOW"
    $P2804 = $P2803."new_type"("str" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2804
    set_hll_global "str", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2805, type_obj
    $P2806 = $P2805."compose"(type_obj)
    .return ($P2806)
.end


.HLL "nqp"

.namespace []
.sub "_block2808" :load :anon :subid("194_1299465710.053")
.annotate 'line', 1
    .const 'Sub' $P2810 = "10_1299465710.053" 
    $P2811 = $P2810()
    .return ($P2811)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
    
    ## Bring in PAST and PCT
    .local pmc hllns, parrotns, imports
    hllns = get_hll_namespace
    parrotns = get_root_namespace ['parrot']
    imports = split ' ', 'PAST PCT'
    parrotns.'export_to'(hllns, imports)
.end

### .include 'gen/nqp-grammar.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299465717.405")
.annotate 'line', 0
    get_hll_global $P18, ["NQP";"Grammar"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    nqp_dynop_setup 
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    get_hll_global $P16, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P18, ["NQP";"Grammar"], "_block17" 
    capture_lex $P18
    $P2436 = $P18()
.annotate 'line', 1
    .return ($P2436)
    .const 'Sub' $P2438 = "402_1299465717.405" 
    .return ($P2438)
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block17"  :subid("11_1299465717.405") :outer("10_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P1721 = "401_1299465717.405" 
    capture_lex $P1721
    get_hll_global $P1612, ["NQP";"Regex"], "_block1611" 
    capture_lex $P1612
    .const 'Sub' $P1600 = "377_1299465717.405" 
    capture_lex $P1600
    .const 'Sub' $P1594 = "375_1299465717.405" 
    capture_lex $P1594
    .const 'Sub' $P1588 = "373_1299465717.405" 
    capture_lex $P1588
    .const 'Sub' $P1582 = "371_1299465717.405" 
    capture_lex $P1582
    .const 'Sub' $P1576 = "369_1299465717.405" 
    capture_lex $P1576
    .const 'Sub' $P1564 = "366_1299465717.405" 
    capture_lex $P1564
    .const 'Sub' $P1557 = "364_1299465717.405" 
    capture_lex $P1557
    .const 'Sub' $P1550 = "362_1299465717.405" 
    capture_lex $P1550
    .const 'Sub' $P1543 = "360_1299465717.405" 
    capture_lex $P1543
    .const 'Sub' $P1536 = "358_1299465717.405" 
    capture_lex $P1536
    .const 'Sub' $P1530 = "356_1299465717.405" 
    capture_lex $P1530
    .const 'Sub' $P1523 = "354_1299465717.405" 
    capture_lex $P1523
    .const 'Sub' $P1516 = "352_1299465717.405" 
    capture_lex $P1516
    .const 'Sub' $P1509 = "350_1299465717.405" 
    capture_lex $P1509
    .const 'Sub' $P1502 = "348_1299465717.405" 
    capture_lex $P1502
    .const 'Sub' $P1495 = "346_1299465717.405" 
    capture_lex $P1495
    .const 'Sub' $P1488 = "344_1299465717.405" 
    capture_lex $P1488
    .const 'Sub' $P1481 = "342_1299465717.405" 
    capture_lex $P1481
    .const 'Sub' $P1474 = "340_1299465717.405" 
    capture_lex $P1474
    .const 'Sub' $P1467 = "338_1299465717.405" 
    capture_lex $P1467
    .const 'Sub' $P1460 = "336_1299465717.405" 
    capture_lex $P1460
    .const 'Sub' $P1453 = "334_1299465717.405" 
    capture_lex $P1453
    .const 'Sub' $P1446 = "332_1299465717.405" 
    capture_lex $P1446
    .const 'Sub' $P1439 = "330_1299465717.405" 
    capture_lex $P1439
    .const 'Sub' $P1432 = "328_1299465717.405" 
    capture_lex $P1432
    .const 'Sub' $P1425 = "326_1299465717.405" 
    capture_lex $P1425
    .const 'Sub' $P1418 = "324_1299465717.405" 
    capture_lex $P1418
    .const 'Sub' $P1411 = "322_1299465717.405" 
    capture_lex $P1411
    .const 'Sub' $P1404 = "320_1299465717.405" 
    capture_lex $P1404
    .const 'Sub' $P1397 = "318_1299465717.405" 
    capture_lex $P1397
    .const 'Sub' $P1390 = "316_1299465717.405" 
    capture_lex $P1390
    .const 'Sub' $P1383 = "314_1299465717.405" 
    capture_lex $P1383
    .const 'Sub' $P1376 = "312_1299465717.405" 
    capture_lex $P1376
    .const 'Sub' $P1369 = "310_1299465717.405" 
    capture_lex $P1369
    .const 'Sub' $P1362 = "308_1299465717.405" 
    capture_lex $P1362
    .const 'Sub' $P1355 = "306_1299465717.405" 
    capture_lex $P1355
    .const 'Sub' $P1348 = "304_1299465717.405" 
    capture_lex $P1348
    .const 'Sub' $P1341 = "302_1299465717.405" 
    capture_lex $P1341
    .const 'Sub' $P1334 = "300_1299465717.405" 
    capture_lex $P1334
    .const 'Sub' $P1327 = "298_1299465717.405" 
    capture_lex $P1327
    .const 'Sub' $P1321 = "296_1299465717.405" 
    capture_lex $P1321
    .const 'Sub' $P1314 = "294_1299465717.405" 
    capture_lex $P1314
    .const 'Sub' $P1307 = "292_1299465717.405" 
    capture_lex $P1307
    .const 'Sub' $P1300 = "290_1299465717.405" 
    capture_lex $P1300
    .const 'Sub' $P1293 = "288_1299465717.405" 
    capture_lex $P1293
    .const 'Sub' $P1286 = "286_1299465717.405" 
    capture_lex $P1286
    .const 'Sub' $P1279 = "284_1299465717.405" 
    capture_lex $P1279
    .const 'Sub' $P1272 = "282_1299465717.405" 
    capture_lex $P1272
    .const 'Sub' $P1266 = "280_1299465717.405" 
    capture_lex $P1266
    .const 'Sub' $P1260 = "278_1299465717.405" 
    capture_lex $P1260
    .const 'Sub' $P1255 = "276_1299465717.405" 
    capture_lex $P1255
    .const 'Sub' $P1249 = "274_1299465717.405" 
    capture_lex $P1249
    .const 'Sub' $P1243 = "272_1299465717.405" 
    capture_lex $P1243
    .const 'Sub' $P1238 = "270_1299465717.405" 
    capture_lex $P1238
    .const 'Sub' $P1233 = "268_1299465717.405" 
    capture_lex $P1233
    .const 'Sub' $P1217 = "267_1299465717.405" 
    capture_lex $P1217
    .const 'Sub' $P1208 = "265_1299465717.405" 
    capture_lex $P1208
    .const 'Sub' $P1199 = "263_1299465717.405" 
    capture_lex $P1199
    .const 'Sub' $P1194 = "261_1299465717.405" 
    capture_lex $P1194
    .const 'Sub' $P1189 = "259_1299465717.405" 
    capture_lex $P1189
    .const 'Sub' $P1184 = "257_1299465717.405" 
    capture_lex $P1184
    .const 'Sub' $P1176 = "255_1299465717.405" 
    capture_lex $P1176
    .const 'Sub' $P1168 = "253_1299465717.405" 
    capture_lex $P1168
    .const 'Sub' $P1163 = "251_1299465717.405" 
    capture_lex $P1163
    .const 'Sub' $P1158 = "249_1299465717.405" 
    capture_lex $P1158
    .const 'Sub' $P1153 = "247_1299465717.405" 
    capture_lex $P1153
    .const 'Sub' $P1147 = "245_1299465717.405" 
    capture_lex $P1147
    .const 'Sub' $P1141 = "243_1299465717.405" 
    capture_lex $P1141
    .const 'Sub' $P1135 = "241_1299465717.405" 
    capture_lex $P1135
    .const 'Sub' $P1129 = "239_1299465717.405" 
    capture_lex $P1129
    .const 'Sub' $P1123 = "237_1299465717.405" 
    capture_lex $P1123
    .const 'Sub' $P1118 = "235_1299465717.405" 
    capture_lex $P1118
    .const 'Sub' $P1113 = "233_1299465717.405" 
    capture_lex $P1113
    .const 'Sub' $P1099 = "229_1299465717.405" 
    capture_lex $P1099
    .const 'Sub' $P1091 = "227_1299465717.405" 
    capture_lex $P1091
    .const 'Sub' $P1085 = "225_1299465717.405" 
    capture_lex $P1085
    .const 'Sub' $P1078 = "223_1299465717.405" 
    capture_lex $P1078
    .const 'Sub' $P1072 = "221_1299465717.405" 
    capture_lex $P1072
    .const 'Sub' $P1058 = "218_1299465717.405" 
    capture_lex $P1058
    .const 'Sub' $P1050 = "216_1299465717.405" 
    capture_lex $P1050
    .const 'Sub' $P1042 = "214_1299465717.405" 
    capture_lex $P1042
    .const 'Sub' $P1036 = "212_1299465717.405" 
    capture_lex $P1036
    .const 'Sub' $P1030 = "210_1299465717.405" 
    capture_lex $P1030
    .const 'Sub' $P1014 = "206_1299465717.405" 
    capture_lex $P1014
    .const 'Sub' $P973 = "204_1299465717.405" 
    capture_lex $P973
    .const 'Sub' $P962 = "202_1299465717.405" 
    capture_lex $P962
    .const 'Sub' $P948 = "198_1299465717.405" 
    capture_lex $P948
    .const 'Sub' $P939 = "196_1299465717.405" 
    capture_lex $P939
    .const 'Sub' $P933 = "194_1299465717.405" 
    capture_lex $P933
    .const 'Sub' $P923 = "192_1299465717.405" 
    capture_lex $P923
    .const 'Sub' $P908 = "190_1299465717.405" 
    capture_lex $P908
    .const 'Sub' $P894 = "187_1299465717.405" 
    capture_lex $P894
    .const 'Sub' $P886 = "185_1299465717.405" 
    capture_lex $P886
    .const 'Sub' $P876 = "183_1299465717.405" 
    capture_lex $P876
    .const 'Sub' $P866 = "181_1299465717.405" 
    capture_lex $P866
    .const 'Sub' $P847 = "176_1299465717.405" 
    capture_lex $P847
    .const 'Sub' $P803 = "173_1299465717.405" 
    capture_lex $P803
    .const 'Sub' $P769 = "171_1299465717.405" 
    capture_lex $P769
    .const 'Sub' $P762 = "169_1299465717.405" 
    capture_lex $P762
    .const 'Sub' $P755 = "167_1299465717.405" 
    capture_lex $P755
    .const 'Sub' $P738 = "163_1299465717.405" 
    capture_lex $P738
    .const 'Sub' $P730 = "161_1299465717.405" 
    capture_lex $P730
    .const 'Sub' $P724 = "159_1299465717.405" 
    capture_lex $P724
    .const 'Sub' $P711 = "157_1299465717.405" 
    capture_lex $P711
    .const 'Sub' $P704 = "155_1299465717.405" 
    capture_lex $P704
    .const 'Sub' $P697 = "153_1299465717.405" 
    capture_lex $P697
    .const 'Sub' $P690 = "151_1299465717.405" 
    capture_lex $P690
    .const 'Sub' $P649 = "147_1299465717.405" 
    capture_lex $P649
    .const 'Sub' $P637 = "145_1299465717.405" 
    capture_lex $P637
    .const 'Sub' $P625 = "143_1299465717.405" 
    capture_lex $P625
    .const 'Sub' $P613 = "141_1299465717.405" 
    capture_lex $P613
    .const 'Sub' $P601 = "139_1299465717.405" 
    capture_lex $P601
    .const 'Sub' $P589 = "137_1299465717.405" 
    capture_lex $P589
    .const 'Sub' $P577 = "135_1299465717.405" 
    capture_lex $P577
    .const 'Sub' $P566 = "131_1299465717.405" 
    capture_lex $P566
    .const 'Sub' $P561 = "129_1299465717.405" 
    capture_lex $P561
    .const 'Sub' $P549 = "127_1299465717.405" 
    capture_lex $P549
    .const 'Sub' $P537 = "125_1299465717.405" 
    capture_lex $P537
    .const 'Sub' $P530 = "123_1299465717.405" 
    capture_lex $P530
    .const 'Sub' $P525 = "121_1299465717.405" 
    capture_lex $P525
    .const 'Sub' $P519 = "119_1299465717.405" 
    capture_lex $P519
    .const 'Sub' $P513 = "117_1299465717.405" 
    capture_lex $P513
    .const 'Sub' $P498 = "113_1299465717.405" 
    capture_lex $P498
    .const 'Sub' $P492 = "111_1299465717.405" 
    capture_lex $P492
    .const 'Sub' $P486 = "109_1299465717.405" 
    capture_lex $P486
    .const 'Sub' $P480 = "107_1299465717.405" 
    capture_lex $P480
    .const 'Sub' $P474 = "105_1299465717.405" 
    capture_lex $P474
    .const 'Sub' $P468 = "103_1299465717.405" 
    capture_lex $P468
    .const 'Sub' $P462 = "101_1299465717.405" 
    capture_lex $P462
    .const 'Sub' $P453 = "99_1299465717.405" 
    capture_lex $P453
    .const 'Sub' $P444 = "97_1299465717.405" 
    capture_lex $P444
    .const 'Sub' $P435 = "95_1299465717.405" 
    capture_lex $P435
    .const 'Sub' $P420 = "91_1299465717.405" 
    capture_lex $P420
    .const 'Sub' $P411 = "89_1299465717.405" 
    capture_lex $P411
    .const 'Sub' $P399 = "85_1299465717.405" 
    capture_lex $P399
    .const 'Sub' $P392 = "83_1299465717.405" 
    capture_lex $P392
    .const 'Sub' $P385 = "81_1299465717.405" 
    capture_lex $P385
    .const 'Sub' $P371 = "77_1299465717.405" 
    capture_lex $P371
    .const 'Sub' $P363 = "75_1299465717.405" 
    capture_lex $P363
    .const 'Sub' $P355 = "73_1299465717.405" 
    capture_lex $P355
    .const 'Sub' $P335 = "71_1299465717.405" 
    capture_lex $P335
    .const 'Sub' $P326 = "69_1299465717.405" 
    capture_lex $P326
    .const 'Sub' $P308 = "66_1299465717.405" 
    capture_lex $P308
    .const 'Sub' $P290 = "64_1299465717.405" 
    capture_lex $P290
    .const 'Sub' $P279 = "60_1299465717.405" 
    capture_lex $P279
    .const 'Sub' $P274 = "58_1299465717.405" 
    capture_lex $P274
    .const 'Sub' $P263 = "54_1299465717.405" 
    capture_lex $P263
    .const 'Sub' $P258 = "52_1299465717.405" 
    capture_lex $P258
    .const 'Sub' $P253 = "50_1299465717.405" 
    capture_lex $P253
    .const 'Sub' $P248 = "48_1299465717.405" 
    capture_lex $P248
    .const 'Sub' $P238 = "46_1299465717.405" 
    capture_lex $P238
    .const 'Sub' $P231 = "44_1299465717.405" 
    capture_lex $P231
    .const 'Sub' $P225 = "42_1299465717.405" 
    capture_lex $P225
    .const 'Sub' $P217 = "40_1299465717.405" 
    capture_lex $P217
    .const 'Sub' $P211 = "38_1299465717.405" 
    capture_lex $P211
    .const 'Sub' $P205 = "36_1299465717.405" 
    capture_lex $P205
    .const 'Sub' $P190 = "33_1299465717.405" 
    capture_lex $P190
    .const 'Sub' $P176 = "31_1299465717.405" 
    capture_lex $P176
    .const 'Sub' $P167 = "29_1299465717.405" 
    capture_lex $P167
    .const 'Sub' $P128 = "26_1299465717.405" 
    capture_lex $P128
    .const 'Sub' $P113 = "23_1299465717.405" 
    capture_lex $P113
    .const 'Sub' $P102 = "21_1299465717.405" 
    capture_lex $P102
    .const 'Sub' $P90 = "19_1299465717.405" 
    capture_lex $P90
    .const 'Sub' $P82 = "17_1299465717.405" 
    capture_lex $P82
    .const 'Sub' $P75 = "15_1299465717.405" 
    capture_lex $P75
    .const 'Sub' $P68 = "13_1299465717.405" 
    capture_lex $P68
    .const 'Sub' $P24 = "12_1299465717.405" 
    capture_lex $P24
    get_global $P19, "$?CLASS"
    nqp_dynop_setup 
    getinterp $P20
    get_class $P21, "LexPad"
    get_class $P22, "NQPLexPad"
    $P20."hll_map"($P21, $P22)
    get_hll_global $P23, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1217 = "267_1299465717.405" 
    capture_lex $P1217
    $P1217()
.annotate 'line', 663
    get_hll_global $P1612, ["NQP";"Regex"], "_block1611" 
    capture_lex $P1612
    $P1715 = $P1612()
.annotate 'line', 4
    .return ($P1715)
    .const 'Sub' $P1717 = "400_1299465717.405" 
    .return ($P1717)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post403") :outer("11_1299465717.405")
.annotate 'line', 4
    get_hll_global $P18, ["NQP";"Grammar"], "_block17" 
    .local pmc block
    set block, $P18
    .const 'Sub' $P1721 = "401_1299465717.405" 
    capture_lex $P1721
    $P1721()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1720"  :anon :subid("401_1299465717.405") :outer("11_1299465717.405")
.annotate 'line', 4
    get_hll_global $P1722, "NQPClassHOW"
    $P1723 = $P1722."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1723
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "12_1299465717.405" 
    $P1724."add_method"(type_obj, "TOP", $P1725)
    get_how $P1726, type_obj
    .const 'Sub' $P1727 = "13_1299465717.405" 
    $P1726."add_method"(type_obj, "identifier", $P1727)
    get_how $P1728, type_obj
    get_global $P1729, "!PREFIX__identifier"
    $P1728."add_method"(type_obj, "!PREFIX__identifier", $P1729)
    get_how $P1730, type_obj
    .const 'Sub' $P1731 = "15_1299465717.405" 
    $P1730."add_method"(type_obj, "name", $P1731)
    get_how $P1732, type_obj
    get_global $P1733, "!PREFIX__name"
    $P1732."add_method"(type_obj, "!PREFIX__name", $P1733)
    get_how $P1734, type_obj
    .const 'Sub' $P1735 = "17_1299465717.405" 
    $P1734."add_method"(type_obj, "deflongname", $P1735)
    get_how $P1736, type_obj
    get_global $P1737, "!PREFIX__deflongname"
    $P1736."add_method"(type_obj, "!PREFIX__deflongname", $P1737)
    get_how $P1738, type_obj
    .const 'Sub' $P1739 = "19_1299465717.405" 
    $P1738."add_method"(type_obj, "ENDSTMT", $P1739)
    get_how $P1740, type_obj
    get_global $P1741, "!PREFIX__ENDSTMT"
    $P1740."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1741)
    get_how $P1742, type_obj
    .const 'Sub' $P1743 = "21_1299465717.405" 
    $P1742."add_method"(type_obj, "ws", $P1743)
    get_how $P1744, type_obj
    get_global $P1745, "!PREFIX__ws"
    $P1744."add_method"(type_obj, "!PREFIX__ws", $P1745)
    get_how $P1746, type_obj
    .const 'Sub' $P1747 = "23_1299465717.405" 
    $P1746."add_method"(type_obj, "unv", $P1747)
    get_how $P1748, type_obj
    get_global $P1749, "!PREFIX__unv"
    $P1748."add_method"(type_obj, "!PREFIX__unv", $P1749)
    get_how $P1750, type_obj
    .const 'Sub' $P1751 = "26_1299465717.405" 
    $P1750."add_method"(type_obj, "pod_comment", $P1751)
    get_how $P1752, type_obj
    get_global $P1753, "!PREFIX__pod_comment"
    $P1752."add_method"(type_obj, "!PREFIX__pod_comment", $P1753)
    get_how $P1754, type_obj
    .const 'Sub' $P1755 = "29_1299465717.405" 
    $P1754."add_method"(type_obj, "comp_unit", $P1755)
    get_how $P1756, type_obj
    get_global $P1757, "!PREFIX__comp_unit"
    $P1756."add_method"(type_obj, "!PREFIX__comp_unit", $P1757)
    get_how $P1758, type_obj
    .const 'Sub' $P1759 = "31_1299465717.405" 
    $P1758."add_method"(type_obj, "statementlist", $P1759)
    get_how $P1760, type_obj
    get_global $P1761, "!PREFIX__statementlist"
    $P1760."add_method"(type_obj, "!PREFIX__statementlist", $P1761)
    get_how $P1762, type_obj
    .const 'Sub' $P1763 = "33_1299465717.405" 
    $P1762."add_method"(type_obj, "statement", $P1763)
    get_how $P1764, type_obj
    get_global $P1765, "!PREFIX__statement"
    $P1764."add_method"(type_obj, "!PREFIX__statement", $P1765)
    get_how $P1766, type_obj
    .const 'Sub' $P1767 = "36_1299465717.405" 
    $P1766."add_method"(type_obj, "eat_terminator", $P1767)
    get_how $P1768, type_obj
    get_global $P1769, "!PREFIX__eat_terminator"
    $P1768."add_method"(type_obj, "!PREFIX__eat_terminator", $P1769)
    get_how $P1770, type_obj
    .const 'Sub' $P1771 = "38_1299465717.405" 
    $P1770."add_method"(type_obj, "xblock", $P1771)
    get_how $P1772, type_obj
    get_global $P1773, "!PREFIX__xblock"
    $P1772."add_method"(type_obj, "!PREFIX__xblock", $P1773)
    get_how $P1774, type_obj
    .const 'Sub' $P1775 = "40_1299465717.405" 
    $P1774."add_method"(type_obj, "pblock", $P1775)
    get_how $P1776, type_obj
    get_global $P1777, "!PREFIX__pblock"
    $P1776."add_method"(type_obj, "!PREFIX__pblock", $P1777)
    get_how $P1778, type_obj
    .const 'Sub' $P1779 = "42_1299465717.405" 
    $P1778."add_method"(type_obj, "lambda", $P1779)
    get_how $P1780, type_obj
    get_global $P1781, "!PREFIX__lambda"
    $P1780."add_method"(type_obj, "!PREFIX__lambda", $P1781)
    get_how $P1782, type_obj
    .const 'Sub' $P1783 = "44_1299465717.405" 
    $P1782."add_method"(type_obj, "block", $P1783)
    get_how $P1784, type_obj
    get_global $P1785, "!PREFIX__block"
    $P1784."add_method"(type_obj, "!PREFIX__block", $P1785)
    get_how $P1786, type_obj
    .const 'Sub' $P1787 = "46_1299465717.405" 
    $P1786."add_method"(type_obj, "blockoid", $P1787)
    get_how $P1788, type_obj
    get_global $P1789, "!PREFIX__blockoid"
    $P1788."add_method"(type_obj, "!PREFIX__blockoid", $P1789)
    get_how $P1790, type_obj
    .const 'Sub' $P1791 = "48_1299465717.405" 
    $P1790."add_method"(type_obj, "newpad", $P1791)
    get_how $P1792, type_obj
    get_global $P1793, "!PREFIX__newpad"
    $P1792."add_method"(type_obj, "!PREFIX__newpad", $P1793)
    get_how $P1794, type_obj
    .const 'Sub' $P1795 = "50_1299465717.405" 
    $P1794."add_method"(type_obj, "outerctx", $P1795)
    get_how $P1796, type_obj
    get_global $P1797, "!PREFIX__outerctx"
    $P1796."add_method"(type_obj, "!PREFIX__outerctx", $P1797)
    get_how $P1798, type_obj
    .const 'Sub' $P1799 = "52_1299465717.405" 
    $P1798."add_method"(type_obj, "finishpad", $P1799)
    get_how $P1800, type_obj
    get_global $P1801, "!PREFIX__finishpad"
    $P1800."add_method"(type_obj, "!PREFIX__finishpad", $P1801)
    get_how $P1802, type_obj
    .const 'Sub' $P1803 = "54_1299465717.405" 
    $P1802."add_method"(type_obj, "you_are_here", $P1803)
    get_how $P1804, type_obj
    get_global $P1805, "!PREFIX__you_are_here"
    $P1804."add_method"(type_obj, "!PREFIX__you_are_here", $P1805)
    get_how $P1806, type_obj
    .const 'Sub' $P1807 = "56_1299465717.405" 
    $P1806."add_method"(type_obj, "terminator", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "57_1299465717.405" 
    $P1808."add_method"(type_obj, "!PREFIX__terminator", $P1809)
    get_how $P1810, type_obj
    .const 'Sub' $P1811 = "58_1299465717.405" 
    $P1810."add_method"(type_obj, "terminator:sym<;>", $P1811)
    get_how $P1812, type_obj
    get_global $P1813, "!PREFIX__terminator:sym<;>"
    $P1812."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "60_1299465717.405" 
    $P1814."add_method"(type_obj, "terminator:sym<}>", $P1815)
    get_how $P1816, type_obj
    get_global $P1817, "!PREFIX__terminator:sym<}>"
    $P1816."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1817)
    get_how $P1818, type_obj
    .const 'Sub' $P1819 = "62_1299465717.405" 
    $P1818."add_method"(type_obj, "statement_control", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "63_1299465717.405" 
    $P1820."add_method"(type_obj, "!PREFIX__statement_control", $P1821)
    get_how $P1822, type_obj
    .const 'Sub' $P1823 = "64_1299465717.405" 
    $P1822."add_method"(type_obj, "statement_control:sym<if>", $P1823)
    get_how $P1824, type_obj
    get_global $P1825, "!PREFIX__statement_control:sym<if>"
    $P1824."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1825)
    get_how $P1826, type_obj
    .const 'Sub' $P1827 = "66_1299465717.405" 
    $P1826."add_method"(type_obj, "statement_control:sym<unless>", $P1827)
    get_how $P1828, type_obj
    get_global $P1829, "!PREFIX__statement_control:sym<unless>"
    $P1828."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "69_1299465717.405" 
    $P1830."add_method"(type_obj, "statement_control:sym<while>", $P1831)
    get_how $P1832, type_obj
    get_global $P1833, "!PREFIX__statement_control:sym<while>"
    $P1832."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1833)
    get_how $P1834, type_obj
    .const 'Sub' $P1835 = "71_1299465717.405" 
    $P1834."add_method"(type_obj, "statement_control:sym<repeat>", $P1835)
    get_how $P1836, type_obj
    get_global $P1837, "!PREFIX__statement_control:sym<repeat>"
    $P1836."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1837)
    get_how $P1838, type_obj
    .const 'Sub' $P1839 = "73_1299465717.405" 
    $P1838."add_method"(type_obj, "statement_control:sym<for>", $P1839)
    get_how $P1840, type_obj
    get_global $P1841, "!PREFIX__statement_control:sym<for>"
    $P1840."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1841)
    get_how $P1842, type_obj
    .const 'Sub' $P1843 = "75_1299465717.405" 
    $P1842."add_method"(type_obj, "statement_control:sym<CATCH>", $P1843)
    get_how $P1844, type_obj
    get_global $P1845, "!PREFIX__statement_control:sym<CATCH>"
    $P1844."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "77_1299465717.405" 
    $P1846."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1847)
    get_how $P1848, type_obj
    get_global $P1849, "!PREFIX__statement_control:sym<CONTROL>"
    $P1848."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1849)
    get_how $P1850, type_obj
    .const 'Sub' $P1851 = "79_1299465717.405" 
    $P1850."add_method"(type_obj, "statement_prefix", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "80_1299465717.405" 
    $P1852."add_method"(type_obj, "!PREFIX__statement_prefix", $P1853)
    get_how $P1854, type_obj
    .const 'Sub' $P1855 = "81_1299465717.405" 
    $P1854."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1855)
    get_how $P1856, type_obj
    get_global $P1857, "!PREFIX__statement_prefix:sym<INIT>"
    $P1856."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1857)
    get_how $P1858, type_obj
    .const 'Sub' $P1859 = "83_1299465717.405" 
    $P1858."add_method"(type_obj, "statement_prefix:sym<try>", $P1859)
    get_how $P1860, type_obj
    get_global $P1861, "!PREFIX__statement_prefix:sym<try>"
    $P1860."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "85_1299465717.405" 
    $P1862."add_method"(type_obj, "blorst", $P1863)
    get_how $P1864, type_obj
    get_global $P1865, "!PREFIX__blorst"
    $P1864."add_method"(type_obj, "!PREFIX__blorst", $P1865)
    get_how $P1866, type_obj
    .const 'Sub' $P1867 = "87_1299465717.405" 
    $P1866."add_method"(type_obj, "statement_mod_cond", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "88_1299465717.405" 
    $P1868."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1869)
    get_how $P1870, type_obj
    .const 'Sub' $P1871 = "89_1299465717.405" 
    $P1870."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1871)
    get_how $P1872, type_obj
    get_global $P1873, "!PREFIX__statement_mod_cond:sym<if>"
    $P1872."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "91_1299465717.405" 
    $P1874."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1875)
    get_how $P1876, type_obj
    get_global $P1877, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1876."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1877)
    get_how $P1878, type_obj
    .const 'Sub' $P1879 = "93_1299465717.405" 
    $P1878."add_method"(type_obj, "statement_mod_loop", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "94_1299465717.405" 
    $P1880."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1881)
    get_how $P1882, type_obj
    .const 'Sub' $P1883 = "95_1299465717.405" 
    $P1882."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1883)
    get_how $P1884, type_obj
    get_global $P1885, "!PREFIX__statement_mod_loop:sym<while>"
    $P1884."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1885)
    get_how $P1886, type_obj
    .const 'Sub' $P1887 = "97_1299465717.405" 
    $P1886."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1887)
    get_how $P1888, type_obj
    get_global $P1889, "!PREFIX__statement_mod_loop:sym<until>"
    $P1888."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1889)
    get_how $P1890, type_obj
    .const 'Sub' $P1891 = "99_1299465717.405" 
    $P1890."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1891)
    get_how $P1892, type_obj
    get_global $P1893, "!PREFIX__statement_mod_loop:sym<for>"
    $P1892."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1893)
    get_how $P1894, type_obj
    .const 'Sub' $P1895 = "101_1299465717.405" 
    $P1894."add_method"(type_obj, "term:sym<fatarrow>", $P1895)
    get_how $P1896, type_obj
    get_global $P1897, "!PREFIX__term:sym<fatarrow>"
    $P1896."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1897)
    get_how $P1898, type_obj
    .const 'Sub' $P1899 = "103_1299465717.405" 
    $P1898."add_method"(type_obj, "term:sym<colonpair>", $P1899)
    get_how $P1900, type_obj
    get_global $P1901, "!PREFIX__term:sym<colonpair>"
    $P1900."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1901)
    get_how $P1902, type_obj
    .const 'Sub' $P1903 = "105_1299465717.405" 
    $P1902."add_method"(type_obj, "term:sym<variable>", $P1903)
    get_how $P1904, type_obj
    get_global $P1905, "!PREFIX__term:sym<variable>"
    $P1904."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1905)
    get_how $P1906, type_obj
    .const 'Sub' $P1907 = "107_1299465717.405" 
    $P1906."add_method"(type_obj, "term:sym<package_declarator>", $P1907)
    get_how $P1908, type_obj
    get_global $P1909, "!PREFIX__term:sym<package_declarator>"
    $P1908."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1909)
    get_how $P1910, type_obj
    .const 'Sub' $P1911 = "109_1299465717.405" 
    $P1910."add_method"(type_obj, "term:sym<scope_declarator>", $P1911)
    get_how $P1912, type_obj
    get_global $P1913, "!PREFIX__term:sym<scope_declarator>"
    $P1912."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1913)
    get_how $P1914, type_obj
    .const 'Sub' $P1915 = "111_1299465717.405" 
    $P1914."add_method"(type_obj, "term:sym<routine_declarator>", $P1915)
    get_how $P1916, type_obj
    get_global $P1917, "!PREFIX__term:sym<routine_declarator>"
    $P1916."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "113_1299465717.405" 
    $P1918."add_method"(type_obj, "term:sym<multi_declarator>", $P1919)
    get_how $P1920, type_obj
    get_global $P1921, "!PREFIX__term:sym<multi_declarator>"
    $P1920."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1921)
    get_how $P1922, type_obj
    .const 'Sub' $P1923 = "117_1299465717.405" 
    $P1922."add_method"(type_obj, "term:sym<regex_declarator>", $P1923)
    get_how $P1924, type_obj
    get_global $P1925, "!PREFIX__term:sym<regex_declarator>"
    $P1924."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1925)
    get_how $P1926, type_obj
    .const 'Sub' $P1927 = "119_1299465717.405" 
    $P1926."add_method"(type_obj, "term:sym<statement_prefix>", $P1927)
    get_how $P1928, type_obj
    get_global $P1929, "!PREFIX__term:sym<statement_prefix>"
    $P1928."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1929)
    get_how $P1930, type_obj
    .const 'Sub' $P1931 = "121_1299465717.405" 
    $P1930."add_method"(type_obj, "term:sym<lambda>", $P1931)
    get_how $P1932, type_obj
    get_global $P1933, "!PREFIX__term:sym<lambda>"
    $P1932."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "123_1299465717.405" 
    $P1934."add_method"(type_obj, "fatarrow", $P1935)
    get_how $P1936, type_obj
    get_global $P1937, "!PREFIX__fatarrow"
    $P1936."add_method"(type_obj, "!PREFIX__fatarrow", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "125_1299465717.405" 
    $P1938."add_method"(type_obj, "colonpair", $P1939)
    get_how $P1940, type_obj
    get_global $P1941, "!PREFIX__colonpair"
    $P1940."add_method"(type_obj, "!PREFIX__colonpair", $P1941)
    get_how $P1942, type_obj
    .const 'Sub' $P1943 = "127_1299465717.405" 
    $P1942."add_method"(type_obj, "variable", $P1943)
    get_how $P1944, type_obj
    get_global $P1945, "!PREFIX__variable"
    $P1944."add_method"(type_obj, "!PREFIX__variable", $P1945)
    get_how $P1946, type_obj
    .const 'Sub' $P1947 = "129_1299465717.405" 
    $P1946."add_method"(type_obj, "sigil", $P1947)
    get_how $P1948, type_obj
    get_global $P1949, "!PREFIX__sigil"
    $P1948."add_method"(type_obj, "!PREFIX__sigil", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "131_1299465717.405" 
    $P1950."add_method"(type_obj, "twigil", $P1951)
    get_how $P1952, type_obj
    get_global $P1953, "!PREFIX__twigil"
    $P1952."add_method"(type_obj, "!PREFIX__twigil", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "133_1299465717.405" 
    $P1954."add_method"(type_obj, "package_declarator", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "134_1299465717.405" 
    $P1956."add_method"(type_obj, "!PREFIX__package_declarator", $P1957)
    get_how $P1958, type_obj
    .const 'Sub' $P1959 = "135_1299465717.405" 
    $P1958."add_method"(type_obj, "package_declarator:sym<module>", $P1959)
    get_how $P1960, type_obj
    get_global $P1961, "!PREFIX__package_declarator:sym<module>"
    $P1960."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "137_1299465717.405" 
    $P1962."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1963)
    get_how $P1964, type_obj
    get_global $P1965, "!PREFIX__package_declarator:sym<knowhow>"
    $P1964."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "139_1299465717.405" 
    $P1966."add_method"(type_obj, "package_declarator:sym<class>", $P1967)
    get_how $P1968, type_obj
    get_global $P1969, "!PREFIX__package_declarator:sym<class>"
    $P1968."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "141_1299465717.405" 
    $P1970."add_method"(type_obj, "package_declarator:sym<grammar>", $P1971)
    get_how $P1972, type_obj
    get_global $P1973, "!PREFIX__package_declarator:sym<grammar>"
    $P1972."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1973)
    get_how $P1974, type_obj
    .const 'Sub' $P1975 = "143_1299465717.405" 
    $P1974."add_method"(type_obj, "package_declarator:sym<role>", $P1975)
    get_how $P1976, type_obj
    get_global $P1977, "!PREFIX__package_declarator:sym<role>"
    $P1976."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1977)
    get_how $P1978, type_obj
    .const 'Sub' $P1979 = "145_1299465717.405" 
    $P1978."add_method"(type_obj, "package_declarator:sym<native>", $P1979)
    get_how $P1980, type_obj
    get_global $P1981, "!PREFIX__package_declarator:sym<native>"
    $P1980."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "147_1299465717.405" 
    $P1982."add_method"(type_obj, "package_def", $P1983)
    get_how $P1984, type_obj
    get_global $P1985, "!PREFIX__package_def"
    $P1984."add_method"(type_obj, "!PREFIX__package_def", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "149_1299465717.405" 
    $P1986."add_method"(type_obj, "scope_declarator", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "150_1299465717.405" 
    $P1988."add_method"(type_obj, "!PREFIX__scope_declarator", $P1989)
    get_how $P1990, type_obj
    .const 'Sub' $P1991 = "151_1299465717.405" 
    $P1990."add_method"(type_obj, "scope_declarator:sym<my>", $P1991)
    get_how $P1992, type_obj
    get_global $P1993, "!PREFIX__scope_declarator:sym<my>"
    $P1992."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1993)
    get_how $P1994, type_obj
    .const 'Sub' $P1995 = "153_1299465717.405" 
    $P1994."add_method"(type_obj, "scope_declarator:sym<our>", $P1995)
    get_how $P1996, type_obj
    get_global $P1997, "!PREFIX__scope_declarator:sym<our>"
    $P1996."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "155_1299465717.405" 
    $P1998."add_method"(type_obj, "scope_declarator:sym<has>", $P1999)
    get_how $P2000, type_obj
    get_global $P2001, "!PREFIX__scope_declarator:sym<has>"
    $P2000."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "157_1299465717.405" 
    $P2002."add_method"(type_obj, "scoped", $P2003)
    get_how $P2004, type_obj
    get_global $P2005, "!PREFIX__scoped"
    $P2004."add_method"(type_obj, "!PREFIX__scoped", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "159_1299465717.405" 
    $P2006."add_method"(type_obj, "typename", $P2007)
    get_how $P2008, type_obj
    get_global $P2009, "!PREFIX__typename"
    $P2008."add_method"(type_obj, "!PREFIX__typename", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "161_1299465717.405" 
    $P2010."add_method"(type_obj, "declarator", $P2011)
    get_how $P2012, type_obj
    get_global $P2013, "!PREFIX__declarator"
    $P2012."add_method"(type_obj, "!PREFIX__declarator", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "163_1299465717.405" 
    $P2014."add_method"(type_obj, "variable_declarator", $P2015)
    get_how $P2016, type_obj
    get_global $P2017, "!PREFIX__variable_declarator"
    $P2016."add_method"(type_obj, "!PREFIX__variable_declarator", $P2017)
    get_how $P2018, type_obj
    .const 'Sub' $P2019 = "165_1299465717.405" 
    $P2018."add_method"(type_obj, "routine_declarator", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "166_1299465717.405" 
    $P2020."add_method"(type_obj, "!PREFIX__routine_declarator", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "167_1299465717.405" 
    $P2022."add_method"(type_obj, "routine_declarator:sym<sub>", $P2023)
    get_how $P2024, type_obj
    get_global $P2025, "!PREFIX__routine_declarator:sym<sub>"
    $P2024."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "169_1299465717.405" 
    $P2026."add_method"(type_obj, "routine_declarator:sym<method>", $P2027)
    get_how $P2028, type_obj
    get_global $P2029, "!PREFIX__routine_declarator:sym<method>"
    $P2028."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2029)
    get_how $P2030, type_obj
    .const 'Sub' $P2031 = "171_1299465717.405" 
    $P2030."add_method"(type_obj, "routine_def", $P2031)
    get_how $P2032, type_obj
    get_global $P2033, "!PREFIX__routine_def"
    $P2032."add_method"(type_obj, "!PREFIX__routine_def", $P2033)
    get_how $P2034, type_obj
    .const 'Sub' $P2035 = "173_1299465717.405" 
    $P2034."add_method"(type_obj, "method_def", $P2035)
    get_how $P2036, type_obj
    get_global $P2037, "!PREFIX__method_def"
    $P2036."add_method"(type_obj, "!PREFIX__method_def", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "176_1299465717.405" 
    $P2038."add_method"(type_obj, "onlystar", $P2039)
    get_how $P2040, type_obj
    get_global $P2041, "!PREFIX__onlystar"
    $P2040."add_method"(type_obj, "!PREFIX__onlystar", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "179_1299465717.405" 
    $P2042."add_method"(type_obj, "multi_declarator", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "180_1299465717.405" 
    $P2044."add_method"(type_obj, "!PREFIX__multi_declarator", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "181_1299465717.405" 
    $P2046."add_method"(type_obj, "multi_declarator:sym<multi>", $P2047)
    get_how $P2048, type_obj
    get_global $P2049, "!PREFIX__multi_declarator:sym<multi>"
    $P2048."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "183_1299465717.405" 
    $P2050."add_method"(type_obj, "multi_declarator:sym<proto>", $P2051)
    get_how $P2052, type_obj
    get_global $P2053, "!PREFIX__multi_declarator:sym<proto>"
    $P2052."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "185_1299465717.405" 
    $P2054."add_method"(type_obj, "multi_declarator:sym<null>", $P2055)
    get_how $P2056, type_obj
    get_global $P2057, "!PREFIX__multi_declarator:sym<null>"
    $P2056."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "187_1299465717.405" 
    $P2058."add_method"(type_obj, "signature", $P2059)
    get_how $P2060, type_obj
    get_global $P2061, "!PREFIX__signature"
    $P2060."add_method"(type_obj, "!PREFIX__signature", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "190_1299465717.405" 
    $P2062."add_method"(type_obj, "parameter", $P2063)
    get_how $P2064, type_obj
    get_global $P2065, "!PREFIX__parameter"
    $P2064."add_method"(type_obj, "!PREFIX__parameter", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "192_1299465717.405" 
    $P2066."add_method"(type_obj, "param_var", $P2067)
    get_how $P2068, type_obj
    get_global $P2069, "!PREFIX__param_var"
    $P2068."add_method"(type_obj, "!PREFIX__param_var", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "194_1299465717.405" 
    $P2070."add_method"(type_obj, "named_param", $P2071)
    get_how $P2072, type_obj
    get_global $P2073, "!PREFIX__named_param"
    $P2072."add_method"(type_obj, "!PREFIX__named_param", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "196_1299465717.405" 
    $P2074."add_method"(type_obj, "default_value", $P2075)
    get_how $P2076, type_obj
    get_global $P2077, "!PREFIX__default_value"
    $P2076."add_method"(type_obj, "!PREFIX__default_value", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "198_1299465717.405" 
    $P2078."add_method"(type_obj, "trait", $P2079)
    get_how $P2080, type_obj
    get_global $P2081, "!PREFIX__trait"
    $P2080."add_method"(type_obj, "!PREFIX__trait", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "200_1299465717.405" 
    $P2082."add_method"(type_obj, "trait_mod", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "201_1299465717.405" 
    $P2084."add_method"(type_obj, "!PREFIX__trait_mod", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "202_1299465717.405" 
    $P2086."add_method"(type_obj, "trait_mod:sym<is>", $P2087)
    get_how $P2088, type_obj
    get_global $P2089, "!PREFIX__trait_mod:sym<is>"
    $P2088."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "204_1299465717.405" 
    $P2090."add_method"(type_obj, "regex_declarator", $P2091)
    get_how $P2092, type_obj
    get_global $P2093, "!PREFIX__regex_declarator"
    $P2092."add_method"(type_obj, "!PREFIX__regex_declarator", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "206_1299465717.405" 
    $P2094."add_method"(type_obj, "dotty", $P2095)
    get_how $P2096, type_obj
    get_global $P2097, "!PREFIX__dotty"
    $P2096."add_method"(type_obj, "!PREFIX__dotty", $P2097)
    get_how $P2098, type_obj
    .const 'Sub' $P2099 = "208_1299465717.405" 
    $P2098."add_method"(type_obj, "term", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "209_1299465717.405" 
    $P2100."add_method"(type_obj, "!PREFIX__term", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "210_1299465717.405" 
    $P2102."add_method"(type_obj, "term:sym<self>", $P2103)
    get_how $P2104, type_obj
    get_global $P2105, "!PREFIX__term:sym<self>"
    $P2104."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "212_1299465717.405" 
    $P2106."add_method"(type_obj, "term:sym<identifier>", $P2107)
    get_how $P2108, type_obj
    get_global $P2109, "!PREFIX__term:sym<identifier>"
    $P2108."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "214_1299465717.405" 
    $P2110."add_method"(type_obj, "term:sym<name>", $P2111)
    get_how $P2112, type_obj
    get_global $P2113, "!PREFIX__term:sym<name>"
    $P2112."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2113)
    get_how $P2114, type_obj
    .const 'Sub' $P2115 = "216_1299465717.405" 
    $P2114."add_method"(type_obj, "term:sym<pir::op>", $P2115)
    get_how $P2116, type_obj
    get_global $P2117, "!PREFIX__term:sym<pir::op>"
    $P2116."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2117)
    get_how $P2118, type_obj
    .const 'Sub' $P2119 = "218_1299465717.405" 
    $P2118."add_method"(type_obj, "term:sym<onlystar>", $P2119)
    get_how $P2120, type_obj
    get_global $P2121, "!PREFIX__term:sym<onlystar>"
    $P2120."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "221_1299465717.405" 
    $P2122."add_method"(type_obj, "args", $P2123)
    get_how $P2124, type_obj
    get_global $P2125, "!PREFIX__args"
    $P2124."add_method"(type_obj, "!PREFIX__args", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "223_1299465717.405" 
    $P2126."add_method"(type_obj, "arglist", $P2127)
    get_how $P2128, type_obj
    get_global $P2129, "!PREFIX__arglist"
    $P2128."add_method"(type_obj, "!PREFIX__arglist", $P2129)
    get_how $P2130, type_obj
    .const 'Sub' $P2131 = "225_1299465717.405" 
    $P2130."add_method"(type_obj, "term:sym<value>", $P2131)
    get_how $P2132, type_obj
    get_global $P2133, "!PREFIX__term:sym<value>"
    $P2132."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "227_1299465717.405" 
    $P2134."add_method"(type_obj, "value", $P2135)
    get_how $P2136, type_obj
    get_global $P2137, "!PREFIX__value"
    $P2136."add_method"(type_obj, "!PREFIX__value", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "229_1299465717.405" 
    $P2138."add_method"(type_obj, "number", $P2139)
    get_how $P2140, type_obj
    get_global $P2141, "!PREFIX__number"
    $P2140."add_method"(type_obj, "!PREFIX__number", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "231_1299465717.405" 
    $P2142."add_method"(type_obj, "quote", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "232_1299465717.405" 
    $P2144."add_method"(type_obj, "!PREFIX__quote", $P2145)
    get_how $P2146, type_obj
    .const 'Sub' $P2147 = "233_1299465717.405" 
    $P2146."add_method"(type_obj, "quote:sym<apos>", $P2147)
    get_how $P2148, type_obj
    get_global $P2149, "!PREFIX__quote:sym<apos>"
    $P2148."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "235_1299465717.405" 
    $P2150."add_method"(type_obj, "quote:sym<dblq>", $P2151)
    get_how $P2152, type_obj
    get_global $P2153, "!PREFIX__quote:sym<dblq>"
    $P2152."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2153)
    get_how $P2154, type_obj
    .const 'Sub' $P2155 = "237_1299465717.405" 
    $P2154."add_method"(type_obj, "quote:sym<q>", $P2155)
    get_how $P2156, type_obj
    get_global $P2157, "!PREFIX__quote:sym<q>"
    $P2156."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "239_1299465717.405" 
    $P2158."add_method"(type_obj, "quote:sym<qq>", $P2159)
    get_how $P2160, type_obj
    get_global $P2161, "!PREFIX__quote:sym<qq>"
    $P2160."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2161)
    get_how $P2162, type_obj
    .const 'Sub' $P2163 = "241_1299465717.405" 
    $P2162."add_method"(type_obj, "quote:sym<Q>", $P2163)
    get_how $P2164, type_obj
    get_global $P2165, "!PREFIX__quote:sym<Q>"
    $P2164."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2165)
    get_how $P2166, type_obj
    .const 'Sub' $P2167 = "243_1299465717.405" 
    $P2166."add_method"(type_obj, "quote:sym<Q:PIR>", $P2167)
    get_how $P2168, type_obj
    get_global $P2169, "!PREFIX__quote:sym<Q:PIR>"
    $P2168."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2169)
    get_how $P2170, type_obj
    .const 'Sub' $P2171 = "245_1299465717.405" 
    $P2170."add_method"(type_obj, "quote:sym</ />", $P2171)
    get_how $P2172, type_obj
    get_global $P2173, "!PREFIX__quote:sym</ />"
    $P2172."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2173)
    get_how $P2174, type_obj
    .const 'Sub' $P2175 = "247_1299465717.405" 
    $P2174."add_method"(type_obj, "quote_escape:sym<$>", $P2175)
    get_how $P2176, type_obj
    get_global $P2177, "!PREFIX__quote_escape:sym<$>"
    $P2176."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "249_1299465717.405" 
    $P2178."add_method"(type_obj, "quote_escape:sym<{ }>", $P2179)
    get_how $P2180, type_obj
    get_global $P2181, "!PREFIX__quote_escape:sym<{ }>"
    $P2180."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2181)
    get_how $P2182, type_obj
    .const 'Sub' $P2183 = "251_1299465717.405" 
    $P2182."add_method"(type_obj, "quote_escape:sym<esc>", $P2183)
    get_how $P2184, type_obj
    get_global $P2185, "!PREFIX__quote_escape:sym<esc>"
    $P2184."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2185)
    get_how $P2186, type_obj
    .const 'Sub' $P2187 = "253_1299465717.405" 
    $P2186."add_method"(type_obj, "circumfix:sym<( )>", $P2187)
    get_how $P2188, type_obj
    get_global $P2189, "!PREFIX__circumfix:sym<( )>"
    $P2188."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2189)
    get_how $P2190, type_obj
    .const 'Sub' $P2191 = "255_1299465717.405" 
    $P2190."add_method"(type_obj, "circumfix:sym<[ ]>", $P2191)
    get_how $P2192, type_obj
    get_global $P2193, "!PREFIX__circumfix:sym<[ ]>"
    $P2192."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "257_1299465717.405" 
    $P2194."add_method"(type_obj, "circumfix:sym<ang>", $P2195)
    get_how $P2196, type_obj
    get_global $P2197, "!PREFIX__circumfix:sym<ang>"
    $P2196."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2197)
    get_how $P2198, type_obj
    .const 'Sub' $P2199 = "259_1299465717.405" 
    $P2198."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2199)
    get_how $P2200, type_obj
    get_global $P2201, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2200."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "261_1299465717.405" 
    $P2202."add_method"(type_obj, "circumfix:sym<{ }>", $P2203)
    get_how $P2204, type_obj
    get_global $P2205, "!PREFIX__circumfix:sym<{ }>"
    $P2204."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2205)
    get_how $P2206, type_obj
    .const 'Sub' $P2207 = "263_1299465717.405" 
    $P2206."add_method"(type_obj, "circumfix:sym<sigil>", $P2207)
    get_how $P2208, type_obj
    get_global $P2209, "!PREFIX__circumfix:sym<sigil>"
    $P2208."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "265_1299465717.405" 
    $P2210."add_method"(type_obj, "semilist", $P2211)
    get_how $P2212, type_obj
    get_global $P2213, "!PREFIX__semilist"
    $P2212."add_method"(type_obj, "!PREFIX__semilist", $P2213)
    get_how $P2214, type_obj
    .const 'Sub' $P2215 = "268_1299465717.405" 
    $P2214."add_method"(type_obj, "infixish", $P2215)
    get_how $P2216, type_obj
    get_global $P2217, "!PREFIX__infixish"
    $P2216."add_method"(type_obj, "!PREFIX__infixish", $P2217)
    get_how $P2218, type_obj
    .const 'Sub' $P2219 = "270_1299465717.405" 
    $P2218."add_method"(type_obj, "infixstopper", $P2219)
    get_how $P2220, type_obj
    get_global $P2221, "!PREFIX__infixstopper"
    $P2220."add_method"(type_obj, "!PREFIX__infixstopper", $P2221)
    get_how $P2222, type_obj
    .const 'Sub' $P2223 = "272_1299465717.405" 
    $P2222."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2223)
    get_how $P2224, type_obj
    get_global $P2225, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2224."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2225)
    get_how $P2226, type_obj
    .const 'Sub' $P2227 = "274_1299465717.405" 
    $P2226."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2227)
    get_how $P2228, type_obj
    get_global $P2229, "!PREFIX__postcircumfix:sym<{ }>"
    $P2228."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2229)
    get_how $P2230, type_obj
    .const 'Sub' $P2231 = "276_1299465717.405" 
    $P2230."add_method"(type_obj, "postcircumfix:sym<ang>", $P2231)
    get_how $P2232, type_obj
    get_global $P2233, "!PREFIX__postcircumfix:sym<ang>"
    $P2232."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2233)
    get_how $P2234, type_obj
    .const 'Sub' $P2235 = "278_1299465717.405" 
    $P2234."add_method"(type_obj, "postcircumfix:sym<( )>", $P2235)
    get_how $P2236, type_obj
    get_global $P2237, "!PREFIX__postcircumfix:sym<( )>"
    $P2236."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2237)
    get_how $P2238, type_obj
    .const 'Sub' $P2239 = "280_1299465717.405" 
    $P2238."add_method"(type_obj, "postfix:sym<.>", $P2239)
    get_how $P2240, type_obj
    get_global $P2241, "!PREFIX__postfix:sym<.>"
    $P2240."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "282_1299465717.405" 
    $P2242."add_method"(type_obj, "prefix:sym<++>", $P2243)
    get_how $P2244, type_obj
    get_global $P2245, "!PREFIX__prefix:sym<++>"
    $P2244."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2245)
    get_how $P2246, type_obj
    .const 'Sub' $P2247 = "284_1299465717.405" 
    $P2246."add_method"(type_obj, "prefix:sym<-->", $P2247)
    get_how $P2248, type_obj
    get_global $P2249, "!PREFIX__prefix:sym<-->"
    $P2248."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2249)
    get_how $P2250, type_obj
    .const 'Sub' $P2251 = "286_1299465717.405" 
    $P2250."add_method"(type_obj, "postfix:sym<++>", $P2251)
    get_how $P2252, type_obj
    get_global $P2253, "!PREFIX__postfix:sym<++>"
    $P2252."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2253)
    get_how $P2254, type_obj
    .const 'Sub' $P2255 = "288_1299465717.405" 
    $P2254."add_method"(type_obj, "postfix:sym<-->", $P2255)
    get_how $P2256, type_obj
    get_global $P2257, "!PREFIX__postfix:sym<-->"
    $P2256."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2257)
    get_how $P2258, type_obj
    .const 'Sub' $P2259 = "290_1299465717.405" 
    $P2258."add_method"(type_obj, "infix:sym<**>", $P2259)
    get_how $P2260, type_obj
    get_global $P2261, "!PREFIX__infix:sym<**>"
    $P2260."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2261)
    get_how $P2262, type_obj
    .const 'Sub' $P2263 = "292_1299465717.405" 
    $P2262."add_method"(type_obj, "prefix:sym<+>", $P2263)
    get_how $P2264, type_obj
    get_global $P2265, "!PREFIX__prefix:sym<+>"
    $P2264."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "294_1299465717.405" 
    $P2266."add_method"(type_obj, "prefix:sym<~>", $P2267)
    get_how $P2268, type_obj
    get_global $P2269, "!PREFIX__prefix:sym<~>"
    $P2268."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2269)
    get_how $P2270, type_obj
    .const 'Sub' $P2271 = "296_1299465717.405" 
    $P2270."add_method"(type_obj, "prefix:sym<->", $P2271)
    get_how $P2272, type_obj
    get_global $P2273, "!PREFIX__prefix:sym<->"
    $P2272."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2273)
    get_how $P2274, type_obj
    .const 'Sub' $P2275 = "298_1299465717.405" 
    $P2274."add_method"(type_obj, "prefix:sym<?>", $P2275)
    get_how $P2276, type_obj
    get_global $P2277, "!PREFIX__prefix:sym<?>"
    $P2276."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2277)
    get_how $P2278, type_obj
    .const 'Sub' $P2279 = "300_1299465717.405" 
    $P2278."add_method"(type_obj, "prefix:sym<!>", $P2279)
    get_how $P2280, type_obj
    get_global $P2281, "!PREFIX__prefix:sym<!>"
    $P2280."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2281)
    get_how $P2282, type_obj
    .const 'Sub' $P2283 = "302_1299465717.405" 
    $P2282."add_method"(type_obj, "prefix:sym<|>", $P2283)
    get_how $P2284, type_obj
    get_global $P2285, "!PREFIX__prefix:sym<|>"
    $P2284."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2285)
    get_how $P2286, type_obj
    .const 'Sub' $P2287 = "304_1299465717.405" 
    $P2286."add_method"(type_obj, "infix:sym<*>", $P2287)
    get_how $P2288, type_obj
    get_global $P2289, "!PREFIX__infix:sym<*>"
    $P2288."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2289)
    get_how $P2290, type_obj
    .const 'Sub' $P2291 = "306_1299465717.405" 
    $P2290."add_method"(type_obj, "infix:sym</>", $P2291)
    get_how $P2292, type_obj
    get_global $P2293, "!PREFIX__infix:sym</>"
    $P2292."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2293)
    get_how $P2294, type_obj
    .const 'Sub' $P2295 = "308_1299465717.405" 
    $P2294."add_method"(type_obj, "infix:sym<%>", $P2295)
    get_how $P2296, type_obj
    get_global $P2297, "!PREFIX__infix:sym<%>"
    $P2296."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2297)
    get_how $P2298, type_obj
    .const 'Sub' $P2299 = "310_1299465717.405" 
    $P2298."add_method"(type_obj, "infix:sym<+&>", $P2299)
    get_how $P2300, type_obj
    get_global $P2301, "!PREFIX__infix:sym<+&>"
    $P2300."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2301)
    get_how $P2302, type_obj
    .const 'Sub' $P2303 = "312_1299465717.405" 
    $P2302."add_method"(type_obj, "infix:sym<+>", $P2303)
    get_how $P2304, type_obj
    get_global $P2305, "!PREFIX__infix:sym<+>"
    $P2304."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "314_1299465717.405" 
    $P2306."add_method"(type_obj, "infix:sym<->", $P2307)
    get_how $P2308, type_obj
    get_global $P2309, "!PREFIX__infix:sym<->"
    $P2308."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2309)
    get_how $P2310, type_obj
    .const 'Sub' $P2311 = "316_1299465717.405" 
    $P2310."add_method"(type_obj, "infix:sym<+|>", $P2311)
    get_how $P2312, type_obj
    get_global $P2313, "!PREFIX__infix:sym<+|>"
    $P2312."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2313)
    get_how $P2314, type_obj
    .const 'Sub' $P2315 = "318_1299465717.405" 
    $P2314."add_method"(type_obj, "infix:sym<+^>", $P2315)
    get_how $P2316, type_obj
    get_global $P2317, "!PREFIX__infix:sym<+^>"
    $P2316."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2317)
    get_how $P2318, type_obj
    .const 'Sub' $P2319 = "320_1299465717.405" 
    $P2318."add_method"(type_obj, "infix:sym<~>", $P2319)
    get_how $P2320, type_obj
    get_global $P2321, "!PREFIX__infix:sym<~>"
    $P2320."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "322_1299465717.405" 
    $P2322."add_method"(type_obj, "infix:sym<==>", $P2323)
    get_how $P2324, type_obj
    get_global $P2325, "!PREFIX__infix:sym<==>"
    $P2324."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2325)
    get_how $P2326, type_obj
    .const 'Sub' $P2327 = "324_1299465717.405" 
    $P2326."add_method"(type_obj, "infix:sym<!=>", $P2327)
    get_how $P2328, type_obj
    get_global $P2329, "!PREFIX__infix:sym<!=>"
    $P2328."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2329)
    get_how $P2330, type_obj
    .const 'Sub' $P2331 = "326_1299465717.405" 
    $P2330."add_method"(type_obj, "infix:sym<<=>", $P2331)
    get_how $P2332, type_obj
    get_global $P2333, "!PREFIX__infix:sym<<=>"
    $P2332."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2333)
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "328_1299465717.405" 
    $P2334."add_method"(type_obj, "infix:sym<>=>", $P2335)
    get_how $P2336, type_obj
    get_global $P2337, "!PREFIX__infix:sym<>=>"
    $P2336."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2337)
    get_how $P2338, type_obj
    .const 'Sub' $P2339 = "330_1299465717.405" 
    $P2338."add_method"(type_obj, "infix:sym<<>", $P2339)
    get_how $P2340, type_obj
    get_global $P2341, "!PREFIX__infix:sym<<>"
    $P2340."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2341)
    get_how $P2342, type_obj
    .const 'Sub' $P2343 = "332_1299465717.405" 
    $P2342."add_method"(type_obj, "infix:sym<>>", $P2343)
    get_how $P2344, type_obj
    get_global $P2345, "!PREFIX__infix:sym<>>"
    $P2344."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2345)
    get_how $P2346, type_obj
    .const 'Sub' $P2347 = "334_1299465717.405" 
    $P2346."add_method"(type_obj, "infix:sym<eq>", $P2347)
    get_how $P2348, type_obj
    get_global $P2349, "!PREFIX__infix:sym<eq>"
    $P2348."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2349)
    get_how $P2350, type_obj
    .const 'Sub' $P2351 = "336_1299465717.405" 
    $P2350."add_method"(type_obj, "infix:sym<ne>", $P2351)
    get_how $P2352, type_obj
    get_global $P2353, "!PREFIX__infix:sym<ne>"
    $P2352."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2353)
    get_how $P2354, type_obj
    .const 'Sub' $P2355 = "338_1299465717.405" 
    $P2354."add_method"(type_obj, "infix:sym<le>", $P2355)
    get_how $P2356, type_obj
    get_global $P2357, "!PREFIX__infix:sym<le>"
    $P2356."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2357)
    get_how $P2358, type_obj
    .const 'Sub' $P2359 = "340_1299465717.405" 
    $P2358."add_method"(type_obj, "infix:sym<ge>", $P2359)
    get_how $P2360, type_obj
    get_global $P2361, "!PREFIX__infix:sym<ge>"
    $P2360."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2361)
    get_how $P2362, type_obj
    .const 'Sub' $P2363 = "342_1299465717.405" 
    $P2362."add_method"(type_obj, "infix:sym<lt>", $P2363)
    get_how $P2364, type_obj
    get_global $P2365, "!PREFIX__infix:sym<lt>"
    $P2364."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "344_1299465717.405" 
    $P2366."add_method"(type_obj, "infix:sym<gt>", $P2367)
    get_how $P2368, type_obj
    get_global $P2369, "!PREFIX__infix:sym<gt>"
    $P2368."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2369)
    get_how $P2370, type_obj
    .const 'Sub' $P2371 = "346_1299465717.405" 
    $P2370."add_method"(type_obj, "infix:sym<=:=>", $P2371)
    get_how $P2372, type_obj
    get_global $P2373, "!PREFIX__infix:sym<=:=>"
    $P2372."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2373)
    get_how $P2374, type_obj
    .const 'Sub' $P2375 = "348_1299465717.405" 
    $P2374."add_method"(type_obj, "infix:sym<~~>", $P2375)
    get_how $P2376, type_obj
    get_global $P2377, "!PREFIX__infix:sym<~~>"
    $P2376."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2377)
    get_how $P2378, type_obj
    .const 'Sub' $P2379 = "350_1299465717.405" 
    $P2378."add_method"(type_obj, "infix:sym<&&>", $P2379)
    get_how $P2380, type_obj
    get_global $P2381, "!PREFIX__infix:sym<&&>"
    $P2380."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2381)
    get_how $P2382, type_obj
    .const 'Sub' $P2383 = "352_1299465717.405" 
    $P2382."add_method"(type_obj, "infix:sym<||>", $P2383)
    get_how $P2384, type_obj
    get_global $P2385, "!PREFIX__infix:sym<||>"
    $P2384."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2385)
    get_how $P2386, type_obj
    .const 'Sub' $P2387 = "354_1299465717.405" 
    $P2386."add_method"(type_obj, "infix:sym<//>", $P2387)
    get_how $P2388, type_obj
    get_global $P2389, "!PREFIX__infix:sym<//>"
    $P2388."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2389)
    get_how $P2390, type_obj
    .const 'Sub' $P2391 = "356_1299465717.405" 
    $P2390."add_method"(type_obj, "infix:sym<?? !!>", $P2391)
    get_how $P2392, type_obj
    get_global $P2393, "!PREFIX__infix:sym<?? !!>"
    $P2392."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2393)
    get_how $P2394, type_obj
    .const 'Sub' $P2395 = "358_1299465717.405" 
    $P2394."add_method"(type_obj, "infix:sym<=>", $P2395)
    get_how $P2396, type_obj
    get_global $P2397, "!PREFIX__infix:sym<=>"
    $P2396."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2397)
    get_how $P2398, type_obj
    .const 'Sub' $P2399 = "360_1299465717.405" 
    $P2398."add_method"(type_obj, "infix:sym<:=>", $P2399)
    get_how $P2400, type_obj
    get_global $P2401, "!PREFIX__infix:sym<:=>"
    $P2400."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2401)
    get_how $P2402, type_obj
    .const 'Sub' $P2403 = "362_1299465717.405" 
    $P2402."add_method"(type_obj, "infix:sym<::=>", $P2403)
    get_how $P2404, type_obj
    get_global $P2405, "!PREFIX__infix:sym<::=>"
    $P2404."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2405)
    get_how $P2406, type_obj
    .const 'Sub' $P2407 = "364_1299465717.405" 
    $P2406."add_method"(type_obj, "infix:sym<,>", $P2407)
    get_how $P2408, type_obj
    get_global $P2409, "!PREFIX__infix:sym<,>"
    $P2408."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2409)
    get_how $P2410, type_obj
    .const 'Sub' $P2411 = "366_1299465717.405" 
    $P2410."add_method"(type_obj, "prefix:sym<return>", $P2411)
    get_how $P2412, type_obj
    get_global $P2413, "!PREFIX__prefix:sym<return>"
    $P2412."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2413)
    get_how $P2414, type_obj
    .const 'Sub' $P2415 = "369_1299465717.405" 
    $P2414."add_method"(type_obj, "prefix:sym<make>", $P2415)
    get_how $P2416, type_obj
    get_global $P2417, "!PREFIX__prefix:sym<make>"
    $P2416."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2417)
    get_how $P2418, type_obj
    .const 'Sub' $P2419 = "371_1299465717.405" 
    $P2418."add_method"(type_obj, "term:sym<last>", $P2419)
    get_how $P2420, type_obj
    get_global $P2421, "!PREFIX__term:sym<last>"
    $P2420."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2421)
    get_how $P2422, type_obj
    .const 'Sub' $P2423 = "373_1299465717.405" 
    $P2422."add_method"(type_obj, "term:sym<next>", $P2423)
    get_how $P2424, type_obj
    get_global $P2425, "!PREFIX__term:sym<next>"
    $P2424."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2425)
    get_how $P2426, type_obj
    .const 'Sub' $P2427 = "375_1299465717.405" 
    $P2426."add_method"(type_obj, "term:sym<redo>", $P2427)
    get_how $P2428, type_obj
    get_global $P2429, "!PREFIX__term:sym<redo>"
    $P2428."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2429)
    get_how $P2430, type_obj
    .const 'Sub' $P2431 = "377_1299465717.405" 
    $P2430."add_method"(type_obj, "smartmatch", $P2431)
    get_how $P2432, type_obj
    get_hll_global $P2433, ["HLL"], "Grammar"
    $P2432."add_parent"(type_obj, $P2433)
    get_how $P2434, type_obj
    $P2435 = $P2434."compose"(type_obj)
    .return ($P2435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1299465717.405") :outer("11_1299465717.405")
    .param pmc param_25
.annotate 'line', 4
    .lex "self", param_25
.annotate 'line', 5
    $P26 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P26
.annotate 'line', 12
    $P27 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P27
.annotate 'line', 21
    new $P28, "Undef"
    .lex "$*DEFAULT-METAATTR", $P28
.annotate 'line', 22
    $P29 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P29
.annotate 'line', 25
    new $P30, "Undef"
    .lex "$*SCOPE", $P30
.annotate 'line', 26
    new $P31, "Undef"
    .lex "$*MULTINESS", $P31
.annotate 'line', 27
    new $P32, "Undef"
    .lex "$*INVOCANT_OK", $P32
.annotate 'line', 28
    new $P33, "Undef"
    .lex "$*RETURN_USED", $P33
.annotate 'line', 29
    new $P34, "Undef"
    .lex "$*PACKAGE-SETUP", $P34
.annotate 'line', 4
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_404
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
  vivify_404:
.annotate 'line', 6
    get_hll_global $P36, ["NQP"], "Regex"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_406
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P37
  vivify_406:
    set $P37["Regex"], $P36
.annotate 'line', 7
    get_hll_global $P38, ["NQP"], "RegexActions"
    find_lex $P39, "%*LANG"
    unless_null $P39, vivify_408
    get_hll_global $P39, "%LANG"
    unless_null $P39, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P39
  vivify_408:
    set $P39["Regex-actions"], $P38
.annotate 'line', 8
    get_hll_global $P40, ["NQP"], "Grammar"
    find_lex $P41, "%*LANG"
    unless_null $P41, vivify_410
    get_hll_global $P41, "%LANG"
    unless_null $P41, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P41
  vivify_410:
    set $P41["MAIN"], $P40
.annotate 'line', 9
    get_hll_global $P42, ["NQP"], "Actions"
    find_lex $P43, "%*LANG"
    unless_null $P43, vivify_412
    get_hll_global $P43, "%LANG"
    unless_null $P43, vivify_413
    die "Contextual %*LANG not found"
  vivify_413:
    store_lex "%*LANG", $P43
  vivify_412:
    set $P43["MAIN-actions"], $P42
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_414
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
  vivify_414:
.annotate 'line', 13
    get_hll_global $P45, "KnowHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_416
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P46
  vivify_416:
    set $P46["knowhow"], $P45
.annotate 'line', 14
    get_hll_global $P47, "NQPModuleHOW"
    find_lex $P48, "%*HOW"
    unless_null $P48, vivify_418
    get_hll_global $P48, "%HOW"
    unless_null $P48, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P48
  vivify_418:
    set $P48["module"], $P47
.annotate 'line', 15
    get_hll_global $P49, "NQPClassHOW"
    find_lex $P50, "%*HOW"
    unless_null $P50, vivify_420
    get_hll_global $P50, "%HOW"
    unless_null $P50, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P50
  vivify_420:
    set $P50["class"], $P49
.annotate 'line', 16
    get_hll_global $P51, "NQPClassHOW"
    find_lex $P52, "%*HOW"
    unless_null $P52, vivify_422
    get_hll_global $P52, "%HOW"
    unless_null $P52, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P52
  vivify_422:
    set $P52["grammar"], $P51
.annotate 'line', 17
    get_hll_global $P53, "NQPParametricRoleHOW"
    find_lex $P54, "%*HOW"
    unless_null $P54, vivify_424
    get_hll_global $P54, "%HOW"
    unless_null $P54, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P54
  vivify_424:
    set $P54["role"], $P53
.annotate 'line', 18
    get_hll_global $P55, "NQPNativeHOW"
    find_lex $P56, "%*HOW"
    unless_null $P56, vivify_426
    get_hll_global $P56, "%HOW"
    unless_null $P56, vivify_427
    die "Contextual %*HOW not found"
  vivify_427:
    store_lex "%*HOW", $P56
  vivify_426:
    set $P56["native"], $P55
.annotate 'line', 21
    new $P57, "String"
    assign $P57, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P57
    find_lex $P58, "%*HOW-METAATTR"
    unless_null $P58, vivify_428
    get_hll_global $P58, "%HOW-METAATTR"
    unless_null $P58, vivify_429
    die "Contextual %*HOW-METAATTR not found"
  vivify_429:
  vivify_428:
.annotate 'line', 23
    new $P59, "String"
    assign $P59, "KnowHOWAttribute"
    find_lex $P60, "%*HOW-METAATTR"
    unless_null $P60, vivify_430
    get_hll_global $P60, "%HOW-METAATTR"
    unless_null $P60, vivify_431
    die "Contextual %*HOW-METAATTR not found"
  vivify_431:
    store_lex "%*HOW-METAATTR", $P60
  vivify_430:
    set $P60["knowhow"], $P59
.annotate 'line', 25
    new $P61, "String"
    assign $P61, ""
    store_lex "$*SCOPE", $P61
.annotate 'line', 26
    new $P62, "String"
    assign $P62, ""
    store_lex "$*MULTINESS", $P62
.annotate 'line', 27
    new $P63, "Integer"
    assign $P63, 0
    store_lex "$*INVOCANT_OK", $P63
.annotate 'line', 28
    new $P64, "Integer"
    assign $P64, 0
    store_lex "$*RETURN_USED", $P64
    find_lex $P65, "$*PACKAGE-SETUP"
    unless_null $P65, vivify_432
    get_hll_global $P65, "$PACKAGE-SETUP"
    unless_null $P65, vivify_433
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_433:
  vivify_432:
.annotate 'line', 30
    find_lex $P66, "self"
    $P67 = $P66."comp_unit"()
.annotate 'line', 4
    .return ($P67)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx69_tgt
    .local int rx69_pos
    .local int rx69_off
    .local int rx69_eos
    .local int rx69_rep
    .local pmc rx69_cur
    .local pmc rx69_debug
    (rx69_cur, rx69_pos, rx69_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx69_cur
    .local pmc match
    .lex "$/", match
    length rx69_eos, rx69_tgt
    gt rx69_pos, rx69_eos, rx69_done
    set rx69_off, 0
    lt rx69_pos, 2, rx69_start
    sub rx69_off, rx69_pos, 1
    substr rx69_tgt, rx69_tgt, rx69_off
  rx69_start:
    eq $I10, 1, rx69_restart
    if_null rx69_debug, debug_434
    rx69_cur."!cursor_debug"("START", "identifier")
  debug_434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan73_done
    goto rxscan73_scan
  rxscan73_loop:
    (rx69_pos) = rx69_cur."from"()
    inc rx69_pos
    rx69_cur."!cursor_from"(rx69_pos)
    ge rx69_pos, rx69_eos, rxscan73_done
  rxscan73_scan:
    set_addr $I10, rxscan73_loop
    rx69_cur."!mark_push"(0, rx69_pos, $I10)
  rxscan73_done:
.annotate 'line', 35
  # rx subrule "ident" subtype=method negate=
    rx69_cur."!cursor_pos"(rx69_pos)
    $P10 = rx69_cur."ident"()
    unless $P10, rx69_fail
    rx69_pos = $P10."pos"()
  # rx rxquantr74 ** 0..*
    set_addr $I10, rxquantr74_done
    rx69_cur."!mark_push"(0, rx69_pos, $I10)
  rxquantr74_loop:
  # rx enumcharlist negate=0 
    ge rx69_pos, rx69_eos, rx69_fail
    sub $I10, rx69_pos, rx69_off
    substr $S10, rx69_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx69_fail
    inc rx69_pos
  # rx subrule "ident" subtype=method negate=
    rx69_cur."!cursor_pos"(rx69_pos)
    $P10 = rx69_cur."ident"()
    unless $P10, rx69_fail
    rx69_pos = $P10."pos"()
    set_addr $I10, rxquantr74_done
    (rx69_rep) = rx69_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr74_done
    rx69_cur."!mark_push"(rx69_rep, rx69_pos, $I10)
    goto rxquantr74_loop
  rxquantr74_done:
  # rx pass
    rx69_cur."!cursor_pass"(rx69_pos, "identifier")
    if_null rx69_debug, debug_435
    rx69_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx69_pos)
  debug_435:
    .return (rx69_cur)
  rx69_restart:
.annotate 'line', 4
    if_null rx69_debug, debug_436
    rx69_cur."!cursor_debug"("NEXT", "identifier")
  debug_436:
  rx69_fail:
    (rx69_rep, rx69_pos, $I10, $P10) = rx69_cur."!mark_fail"(0)
    lt rx69_pos, -1, rx69_done
    eq rx69_pos, -1, rx69_fail
    jump $I10
  rx69_done:
    rx69_cur."!cursor_fail"()
    if_null rx69_debug, debug_437
    rx69_cur."!cursor_debug"("FAIL", "identifier")
  debug_437:
    .return (rx69_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1299465717.405") :method
.annotate 'line', 4
    $P71 = self."!PREFIX__!subrule"("ident", "")
    new $P72, "ResizablePMCArray"
    push $P72, $P71
    .return ($P72)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx76_tgt
    .local int rx76_pos
    .local int rx76_off
    .local int rx76_eos
    .local int rx76_rep
    .local pmc rx76_cur
    .local pmc rx76_debug
    (rx76_cur, rx76_pos, rx76_tgt, $I10) = self."!cursor_start"()
    rx76_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx76_cur
    .local pmc match
    .lex "$/", match
    length rx76_eos, rx76_tgt
    gt rx76_pos, rx76_eos, rx76_done
    set rx76_off, 0
    lt rx76_pos, 2, rx76_start
    sub rx76_off, rx76_pos, 1
    substr rx76_tgt, rx76_tgt, rx76_off
  rx76_start:
    eq $I10, 1, rx76_restart
    if_null rx76_debug, debug_438
    rx76_cur."!cursor_debug"("START", "name")
  debug_438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan79_done
    goto rxscan79_scan
  rxscan79_loop:
    (rx76_pos) = rx76_cur."from"()
    inc rx76_pos
    rx76_cur."!cursor_from"(rx76_pos)
    ge rx76_pos, rx76_eos, rxscan79_done
  rxscan79_scan:
    set_addr $I10, rxscan79_loop
    rx76_cur."!mark_push"(0, rx76_pos, $I10)
  rxscan79_done:
.annotate 'line', 37
  # rx rxquantr80 ** 1..*
    set_addr $I10, rxquantr80_done
    rx76_cur."!mark_push"(0, -1, $I10)
  rxquantr80_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx76_cur."!cursor_pos"(rx76_pos)
    $P10 = rx76_cur."identifier"()
    unless $P10, rx76_fail
    goto rxsubrule81_pass
  rxsubrule81_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx76_fail
  rxsubrule81_pass:
    set_addr $I10, rxsubrule81_back
    rx76_cur."!mark_push"(0, rx76_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx76_pos = $P10."pos"()
    set_addr $I10, rxquantr80_done
    (rx76_rep) = rx76_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr80_done
    rx76_cur."!mark_push"(rx76_rep, rx76_pos, $I10)
  # rx literal  "::"
    add $I11, rx76_pos, 2
    gt $I11, rx76_eos, rx76_fail
    sub $I11, rx76_pos, rx76_off
    substr $S10, rx76_tgt, $I11, 2
    ne $S10, "::", rx76_fail
    add rx76_pos, 2
    goto rxquantr80_loop
  rxquantr80_done:
  # rx pass
    rx76_cur."!cursor_pass"(rx76_pos, "name")
    if_null rx76_debug, debug_439
    rx76_cur."!cursor_debug"("PASS", "name", " at pos=", rx76_pos)
  debug_439:
    .return (rx76_cur)
  rx76_restart:
.annotate 'line', 4
    if_null rx76_debug, debug_440
    rx76_cur."!cursor_debug"("NEXT", "name")
  debug_440:
  rx76_fail:
    (rx76_rep, rx76_pos, $I10, $P10) = rx76_cur."!mark_fail"(0)
    lt rx76_pos, -1, rx76_done
    eq rx76_pos, -1, rx76_fail
    jump $I10
  rx76_done:
    rx76_cur."!cursor_fail"()
    if_null rx76_debug, debug_441
    rx76_cur."!cursor_debug"("FAIL", "name")
  debug_441:
    .return (rx76_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1299465717.405") :method
.annotate 'line', 4
    new $P78, "ResizablePMCArray"
    push $P78, ""
    .return ($P78)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx83_tgt
    .local int rx83_pos
    .local int rx83_off
    .local int rx83_eos
    .local int rx83_rep
    .local pmc rx83_cur
    .local pmc rx83_debug
    (rx83_cur, rx83_pos, rx83_tgt, $I10) = self."!cursor_start"()
    rx83_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx83_cur
    .local pmc match
    .lex "$/", match
    length rx83_eos, rx83_tgt
    gt rx83_pos, rx83_eos, rx83_done
    set rx83_off, 0
    lt rx83_pos, 2, rx83_start
    sub rx83_off, rx83_pos, 1
    substr rx83_tgt, rx83_tgt, rx83_off
  rx83_start:
    eq $I10, 1, rx83_restart
    if_null rx83_debug, debug_442
    rx83_cur."!cursor_debug"("START", "deflongname")
  debug_442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan87_done
    goto rxscan87_scan
  rxscan87_loop:
    (rx83_pos) = rx83_cur."from"()
    inc rx83_pos
    rx83_cur."!cursor_from"(rx83_pos)
    ge rx83_pos, rx83_eos, rxscan87_done
  rxscan87_scan:
    set_addr $I10, rxscan87_loop
    rx83_cur."!mark_push"(0, rx83_pos, $I10)
  rxscan87_done:
.annotate 'line', 40
  # rx subrule "identifier" subtype=capture negate=
    rx83_cur."!cursor_pos"(rx83_pos)
    $P10 = rx83_cur."identifier"()
    unless $P10, rx83_fail
    rx83_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx83_pos = $P10."pos"()
  # rx rxquantr88 ** 0..1
    set_addr $I10, rxquantr88_done
    rx83_cur."!mark_push"(0, rx83_pos, $I10)
  rxquantr88_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx83_cur."!cursor_pos"(rx83_pos)
    $P10 = rx83_cur."colonpair"()
    unless $P10, rx83_fail
    goto rxsubrule89_pass
  rxsubrule89_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx83_fail
  rxsubrule89_pass:
    set_addr $I10, rxsubrule89_back
    rx83_cur."!mark_push"(0, rx83_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx83_pos = $P10."pos"()
    set_addr $I10, rxquantr88_done
    (rx83_rep) = rx83_cur."!mark_commit"($I10)
  rxquantr88_done:
.annotate 'line', 39
  # rx pass
    rx83_cur."!cursor_pass"(rx83_pos, "deflongname")
    if_null rx83_debug, debug_443
    rx83_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx83_pos)
  debug_443:
    .return (rx83_cur)
  rx83_restart:
.annotate 'line', 4
    if_null rx83_debug, debug_444
    rx83_cur."!cursor_debug"("NEXT", "deflongname")
  debug_444:
  rx83_fail:
    (rx83_rep, rx83_pos, $I10, $P10) = rx83_cur."!mark_fail"(0)
    lt rx83_pos, -1, rx83_done
    eq rx83_pos, -1, rx83_fail
    jump $I10
  rx83_done:
    rx83_cur."!cursor_fail"()
    if_null rx83_debug, debug_445
    rx83_cur."!cursor_debug"("FAIL", "deflongname")
  debug_445:
    .return (rx83_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1299465717.405") :method
.annotate 'line', 4
    $P85 = self."!PREFIX__!subrule"("identifier", "")
    new $P86, "ResizablePMCArray"
    push $P86, $P85
    .return ($P86)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx91_tgt
    .local int rx91_pos
    .local int rx91_off
    .local int rx91_eos
    .local int rx91_rep
    .local pmc rx91_cur
    .local pmc rx91_debug
    (rx91_cur, rx91_pos, rx91_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx91_cur
    .local pmc match
    .lex "$/", match
    length rx91_eos, rx91_tgt
    gt rx91_pos, rx91_eos, rx91_done
    set rx91_off, 0
    lt rx91_pos, 2, rx91_start
    sub rx91_off, rx91_pos, 1
    substr rx91_tgt, rx91_tgt, rx91_off
  rx91_start:
    eq $I10, 1, rx91_restart
    if_null rx91_debug, debug_446
    rx91_cur."!cursor_debug"("START", "ENDSTMT")
  debug_446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan94_done
    goto rxscan94_scan
  rxscan94_loop:
    (rx91_pos) = rx91_cur."from"()
    inc rx91_pos
    rx91_cur."!cursor_from"(rx91_pos)
    ge rx91_pos, rx91_eos, rxscan94_done
  rxscan94_scan:
    set_addr $I10, rxscan94_loop
    rx91_cur."!mark_push"(0, rx91_pos, $I10)
  rxscan94_done:
.annotate 'line', 47
  # rx rxquantr95 ** 0..1
    set_addr $I10, rxquantr95_done
    rx91_cur."!mark_push"(0, rx91_pos, $I10)
  rxquantr95_loop:
  alt96_0:
.annotate 'line', 44
    set_addr $I10, alt96_1
    rx91_cur."!mark_push"(0, rx91_pos, $I10)
.annotate 'line', 45
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx91_pos, rx91_off
    set rx91_rep, 0
    sub $I12, rx91_eos, rx91_pos
  rxenumcharlistq97_loop:
    le $I12, 0, rxenumcharlistq97_done
    substr $S10, rx91_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq97_done
    inc rx91_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq97_loop
  rxenumcharlistq97_done:
    add rx91_pos, rx91_pos, rx91_rep
  # rxanchor eol
    sub $I10, rx91_pos, rx91_off
    is_cclass $I11, 4096, rx91_tgt, $I10
    if $I11, rxanchor98_done
    ne rx91_pos, rx91_eos, rx91_fail
    eq rx91_pos, 0, rxanchor98_done
    dec $I10
    is_cclass $I11, 4096, rx91_tgt, $I10
    if $I11, rx91_fail
  rxanchor98_done:
  # rx subrule "ws" subtype=method negate=
    rx91_cur."!cursor_pos"(rx91_pos)
    $P10 = rx91_cur."ws"()
    unless $P10, rx91_fail
    rx91_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx91_cur."!cursor_pos"(rx91_pos)
    $P10 = rx91_cur."MARKER"("endstmt")
    unless $P10, rx91_fail
    goto alt96_end
  alt96_1:
.annotate 'line', 46
  # rx rxquantr99 ** 0..1
    set_addr $I10, rxquantr99_done
    rx91_cur."!mark_push"(0, rx91_pos, $I10)
  rxquantr99_loop:
  # rx subrule "unv" subtype=method negate=
    rx91_cur."!cursor_pos"(rx91_pos)
    $P10 = rx91_cur."unv"()
    unless $P10, rx91_fail
    goto rxsubrule100_pass
  rxsubrule100_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx91_fail
  rxsubrule100_pass:
    set_addr $I10, rxsubrule100_back
    rx91_cur."!mark_push"(0, rx91_pos, $I10, $P10)
    rx91_pos = $P10."pos"()
    set_addr $I10, rxquantr99_done
    (rx91_rep) = rx91_cur."!mark_commit"($I10)
  rxquantr99_done:
  # rxanchor eol
    sub $I10, rx91_pos, rx91_off
    is_cclass $I11, 4096, rx91_tgt, $I10
    if $I11, rxanchor101_done
    ne rx91_pos, rx91_eos, rx91_fail
    eq rx91_pos, 0, rxanchor101_done
    dec $I10
    is_cclass $I11, 4096, rx91_tgt, $I10
    if $I11, rx91_fail
  rxanchor101_done:
  # rx subrule "ws" subtype=method negate=
    rx91_cur."!cursor_pos"(rx91_pos)
    $P10 = rx91_cur."ws"()
    unless $P10, rx91_fail
    rx91_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx91_cur."!cursor_pos"(rx91_pos)
    $P10 = rx91_cur."MARKER"("endstmt")
    unless $P10, rx91_fail
  alt96_end:
.annotate 'line', 47
    set_addr $I10, rxquantr95_done
    (rx91_rep) = rx91_cur."!mark_commit"($I10)
  rxquantr95_done:
.annotate 'line', 43
  # rx pass
    rx91_cur."!cursor_pass"(rx91_pos, "ENDSTMT")
    if_null rx91_debug, debug_447
    rx91_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx91_pos)
  debug_447:
    .return (rx91_cur)
  rx91_restart:
.annotate 'line', 4
    if_null rx91_debug, debug_448
    rx91_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_448:
  rx91_fail:
    (rx91_rep, rx91_pos, $I10, $P10) = rx91_cur."!mark_fail"(0)
    lt rx91_pos, -1, rx91_done
    eq rx91_pos, -1, rx91_fail
    jump $I10
  rx91_done:
    rx91_cur."!cursor_fail"()
    if_null rx91_debug, debug_449
    rx91_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_449:
    .return (rx91_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1299465717.405") :method
.annotate 'line', 4
    new $P93, "ResizablePMCArray"
    push $P93, ""
    .return ($P93)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx103_tgt
    .local int rx103_pos
    .local int rx103_off
    .local int rx103_eos
    .local int rx103_rep
    .local pmc rx103_cur
    .local pmc rx103_debug
    (rx103_cur, rx103_pos, rx103_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx103_cur
    .local pmc match
    .lex "$/", match
    length rx103_eos, rx103_tgt
    gt rx103_pos, rx103_eos, rx103_done
    set rx103_off, 0
    lt rx103_pos, 2, rx103_start
    sub rx103_off, rx103_pos, 1
    substr rx103_tgt, rx103_tgt, rx103_off
  rx103_start:
    eq $I10, 1, rx103_restart
    if_null rx103_debug, debug_450
    rx103_cur."!cursor_debug"("START", "ws")
  debug_450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan106_done
    goto rxscan106_scan
  rxscan106_loop:
    (rx103_pos) = rx103_cur."from"()
    inc rx103_pos
    rx103_cur."!cursor_from"(rx103_pos)
    ge rx103_pos, rx103_eos, rxscan106_done
  rxscan106_scan:
    set_addr $I10, rxscan106_loop
    rx103_cur."!mark_push"(0, rx103_pos, $I10)
  rxscan106_done:
  alt107_0:
.annotate 'line', 50
    set_addr $I10, alt107_1
    rx103_cur."!mark_push"(0, rx103_pos, $I10)
.annotate 'line', 51
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx103_cur."!cursor_pos"(rx103_pos)
    $P10 = rx103_cur."MARKED"("ws")
    unless $P10, rx103_fail
    goto alt107_end
  alt107_1:
.annotate 'line', 52
  # rx subrule "ww" subtype=zerowidth negate=1
    rx103_cur."!cursor_pos"(rx103_pos)
    $P10 = rx103_cur."ww"()
    if $P10, rx103_fail
.annotate 'line', 57
  # rx rxquantr108 ** 0..*
    set_addr $I10, rxquantr108_done
    rx103_cur."!mark_push"(0, rx103_pos, $I10)
  rxquantr108_loop:
  alt109_0:
.annotate 'line', 53
    set_addr $I10, alt109_1
    rx103_cur."!mark_push"(0, rx103_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx103_pos, rx103_off
    set rx103_rep, 0
    sub $I12, rx103_eos, rx103_pos
  rxenumcharlistq110_loop:
    le $I12, 0, rxenumcharlistq110_done
    substr $S10, rx103_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq110_done
    inc rx103_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq110_loop
  rxenumcharlistq110_done:
    lt rx103_rep, 1, rx103_fail
    add rx103_pos, rx103_pos, rx103_rep
    goto alt109_end
  alt109_1:
    set_addr $I10, alt109_2
    rx103_cur."!mark_push"(0, rx103_pos, $I10)
.annotate 'line', 54
  # rx literal  "#"
    add $I11, rx103_pos, 1
    gt $I11, rx103_eos, rx103_fail
    sub $I11, rx103_pos, rx103_off
    ord $I11, rx103_tgt, $I11
    ne $I11, 35, rx103_fail
    add rx103_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx103_pos, rx103_off
    find_cclass $I11, 4096, rx103_tgt, $I10, rx103_eos
    add rx103_pos, rx103_off, $I11
    goto alt109_end
  alt109_2:
    set_addr $I10, alt109_3
    rx103_cur."!mark_push"(0, rx103_pos, $I10)
.annotate 'line', 55
  # rxanchor bol
    eq rx103_pos, 0, rxanchor111_done
    ge rx103_pos, rx103_eos, rx103_fail
    sub $I10, rx103_pos, rx103_off
    dec $I10
    is_cclass $I11, 4096, rx103_tgt, $I10
    unless $I11, rx103_fail
  rxanchor111_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx103_cur."!cursor_pos"(rx103_pos)
    $P10 = rx103_cur."pod_comment"()
    unless $P10, rx103_fail
    rx103_pos = $P10."pos"()
    goto alt109_end
  alt109_3:
.annotate 'line', 56
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx103_pos, rx103_off
    set rx103_rep, 0
    sub $I12, rx103_eos, rx103_pos
  rxenumcharlistq112_loop:
    le $I12, 0, rxenumcharlistq112_done
    substr $S10, rx103_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq112_done
    inc rx103_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq112_loop
  rxenumcharlistq112_done:
    lt rx103_rep, 1, rx103_fail
    add rx103_pos, rx103_pos, rx103_rep
  alt109_end:
.annotate 'line', 57
    set_addr $I10, rxquantr108_done
    (rx103_rep) = rx103_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr108_done
    rx103_cur."!mark_push"(rx103_rep, rx103_pos, $I10)
    goto rxquantr108_loop
  rxquantr108_done:
.annotate 'line', 58
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx103_cur."!cursor_pos"(rx103_pos)
    $P10 = rx103_cur."MARKER"("ws")
    unless $P10, rx103_fail
  alt107_end:
.annotate 'line', 50
  # rx pass
    rx103_cur."!cursor_pass"(rx103_pos, "ws")
    if_null rx103_debug, debug_451
    rx103_cur."!cursor_debug"("PASS", "ws", " at pos=", rx103_pos)
  debug_451:
    .return (rx103_cur)
  rx103_restart:
.annotate 'line', 4
    if_null rx103_debug, debug_452
    rx103_cur."!cursor_debug"("NEXT", "ws")
  debug_452:
  rx103_fail:
    (rx103_rep, rx103_pos, $I10, $P10) = rx103_cur."!mark_fail"(0)
    lt rx103_pos, -1, rx103_done
    eq rx103_pos, -1, rx103_fail
    jump $I10
  rx103_done:
    rx103_cur."!cursor_fail"()
    if_null rx103_debug, debug_453
    rx103_cur."!cursor_debug"("FAIL", "ws")
  debug_453:
    .return (rx103_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1299465717.405") :method
.annotate 'line', 4
    new $P105, "ResizablePMCArray"
    push $P105, ""
    push $P105, ""
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P121 = "25_1299465717.405" 
    capture_lex $P121
    .local string rx114_tgt
    .local int rx114_pos
    .local int rx114_off
    .local int rx114_eos
    .local int rx114_rep
    .local pmc rx114_cur
    .local pmc rx114_debug
    (rx114_cur, rx114_pos, rx114_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx114_cur
    .local pmc match
    .lex "$/", match
    length rx114_eos, rx114_tgt
    gt rx114_pos, rx114_eos, rx114_done
    set rx114_off, 0
    lt rx114_pos, 2, rx114_start
    sub rx114_off, rx114_pos, 1
    substr rx114_tgt, rx114_tgt, rx114_off
  rx114_start:
    eq $I10, 1, rx114_restart
    if_null rx114_debug, debug_454
    rx114_cur."!cursor_debug"("START", "unv")
  debug_454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan117_done
    goto rxscan117_scan
  rxscan117_loop:
    (rx114_pos) = rx114_cur."from"()
    inc rx114_pos
    rx114_cur."!cursor_from"(rx114_pos)
    ge rx114_pos, rx114_eos, rxscan117_done
  rxscan117_scan:
    set_addr $I10, rxscan117_loop
    rx114_cur."!mark_push"(0, rx114_pos, $I10)
  rxscan117_done:
  alt118_0:
.annotate 'line', 63
    set_addr $I10, alt118_1
    rx114_cur."!mark_push"(0, rx114_pos, $I10)
.annotate 'line', 64
  # rxanchor bol
    eq rx114_pos, 0, rxanchor119_done
    ge rx114_pos, rx114_eos, rx114_fail
    sub $I10, rx114_pos, rx114_off
    dec $I10
    is_cclass $I11, 4096, rx114_tgt, $I10
    unless $I11, rx114_fail
  rxanchor119_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx114_cur."!cursor_pos"(rx114_pos)
    .const 'Sub' $P121 = "25_1299465717.405" 
    capture_lex $P121
    $P10 = rx114_cur."before"($P121)
    unless $P10, rx114_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx114_cur."!cursor_pos"(rx114_pos)
    $P10 = rx114_cur."pod_comment"()
    unless $P10, rx114_fail
    rx114_pos = $P10."pos"()
    goto alt118_end
  alt118_1:
    set_addr $I10, alt118_2
    rx114_cur."!mark_push"(0, rx114_pos, $I10)
.annotate 'line', 65
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx114_pos, rx114_off
    set rx114_rep, 0
    sub $I12, rx114_eos, rx114_pos
  rxenumcharlistq126_loop:
    le $I12, 0, rxenumcharlistq126_done
    substr $S10, rx114_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq126_done
    inc rx114_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq126_loop
  rxenumcharlistq126_done:
    add rx114_pos, rx114_pos, rx114_rep
  # rx literal  "#"
    add $I11, rx114_pos, 1
    gt $I11, rx114_eos, rx114_fail
    sub $I11, rx114_pos, rx114_off
    ord $I11, rx114_tgt, $I11
    ne $I11, 35, rx114_fail
    add rx114_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx114_pos, rx114_off
    find_cclass $I11, 4096, rx114_tgt, $I10, rx114_eos
    add rx114_pos, rx114_off, $I11
    goto alt118_end
  alt118_2:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx114_pos, rx114_off
    set rx114_rep, 0
    sub $I12, rx114_eos, rx114_pos
  rxenumcharlistq127_loop:
    le $I12, 0, rxenumcharlistq127_done
    substr $S10, rx114_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq127_done
    inc rx114_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq127_loop
  rxenumcharlistq127_done:
    lt rx114_rep, 1, rx114_fail
    add rx114_pos, rx114_pos, rx114_rep
  alt118_end:
.annotate 'line', 61
  # rx pass
    rx114_cur."!cursor_pass"(rx114_pos, "unv")
    if_null rx114_debug, debug_459
    rx114_cur."!cursor_debug"("PASS", "unv", " at pos=", rx114_pos)
  debug_459:
    .return (rx114_cur)
  rx114_restart:
.annotate 'line', 4
    if_null rx114_debug, debug_460
    rx114_cur."!cursor_debug"("NEXT", "unv")
  debug_460:
  rx114_fail:
    (rx114_rep, rx114_pos, $I10, $P10) = rx114_cur."!mark_fail"(0)
    lt rx114_pos, -1, rx114_done
    eq rx114_pos, -1, rx114_fail
    jump $I10
  rx114_done:
    rx114_cur."!cursor_fail"()
    if_null rx114_debug, debug_461
    rx114_cur."!cursor_debug"("FAIL", "unv")
  debug_461:
    .return (rx114_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1299465717.405") :method
.annotate 'line', 4
    new $P116, "ResizablePMCArray"
    push $P116, ""
    push $P116, ""
    push $P116, ""
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block120"  :anon :subid("25_1299465717.405") :method :outer("23_1299465717.405")
.annotate 'line', 64
    .local string rx122_tgt
    .local int rx122_pos
    .local int rx122_off
    .local int rx122_eos
    .local int rx122_rep
    .local pmc rx122_cur
    .local pmc rx122_debug
    (rx122_cur, rx122_pos, rx122_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx122_cur
    .local pmc match
    .lex "$/", match
    length rx122_eos, rx122_tgt
    gt rx122_pos, rx122_eos, rx122_done
    set rx122_off, 0
    lt rx122_pos, 2, rx122_start
    sub rx122_off, rx122_pos, 1
    substr rx122_tgt, rx122_tgt, rx122_off
  rx122_start:
    eq $I10, 1, rx122_restart
    if_null rx122_debug, debug_455
    rx122_cur."!cursor_debug"("START", "")
  debug_455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan123_done
    goto rxscan123_scan
  rxscan123_loop:
    (rx122_pos) = rx122_cur."from"()
    inc rx122_pos
    rx122_cur."!cursor_from"(rx122_pos)
    ge rx122_pos, rx122_eos, rxscan123_done
  rxscan123_scan:
    set_addr $I10, rxscan123_loop
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
  rxscan123_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx122_pos, rx122_off
    set rx122_rep, 0
    sub $I12, rx122_eos, rx122_pos
  rxenumcharlistq124_loop:
    le $I12, 0, rxenumcharlistq124_done
    substr $S10, rx122_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq124_done
    inc rx122_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq124_loop
  rxenumcharlistq124_done:
    add rx122_pos, rx122_pos, rx122_rep
  # rx literal  "="
    add $I11, rx122_pos, 1
    gt $I11, rx122_eos, rx122_fail
    sub $I11, rx122_pos, rx122_off
    ord $I11, rx122_tgt, $I11
    ne $I11, 61, rx122_fail
    add rx122_pos, 1
  alt125_0:
    set_addr $I10, alt125_1
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
  # rx charclass w
    ge rx122_pos, rx122_eos, rx122_fail
    sub $I10, rx122_pos, rx122_off
    is_cclass $I11, 8192, rx122_tgt, $I10
    unless $I11, rx122_fail
    inc rx122_pos
    goto alt125_end
  alt125_1:
  # rx literal  "\\"
    add $I11, rx122_pos, 1
    gt $I11, rx122_eos, rx122_fail
    sub $I11, rx122_pos, rx122_off
    ord $I11, rx122_tgt, $I11
    ne $I11, 92, rx122_fail
    add rx122_pos, 1
  alt125_end:
  # rx pass
    rx122_cur."!cursor_pass"(rx122_pos, "")
    if_null rx122_debug, debug_456
    rx122_cur."!cursor_debug"("PASS", "", " at pos=", rx122_pos)
  debug_456:
    .return (rx122_cur)
  rx122_restart:
    if_null rx122_debug, debug_457
    rx122_cur."!cursor_debug"("NEXT", "")
  debug_457:
  rx122_fail:
    (rx122_rep, rx122_pos, $I10, $P10) = rx122_cur."!mark_fail"(0)
    lt rx122_pos, -1, rx122_done
    eq rx122_pos, -1, rx122_fail
    jump $I10
  rx122_done:
    rx122_cur."!cursor_fail"()
    if_null rx122_debug, debug_458
    rx122_cur."!cursor_debug"("FAIL", "")
  debug_458:
    .return (rx122_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P160 = "28_1299465717.405" 
    capture_lex $P160
    .local string rx129_tgt
    .local int rx129_pos
    .local int rx129_off
    .local int rx129_eos
    .local int rx129_rep
    .local pmc rx129_cur
    .local pmc rx129_debug
    (rx129_cur, rx129_pos, rx129_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx129_cur
    .local pmc match
    .lex "$/", match
    length rx129_eos, rx129_tgt
    gt rx129_pos, rx129_eos, rx129_done
    set rx129_off, 0
    lt rx129_pos, 2, rx129_start
    sub rx129_off, rx129_pos, 1
    substr rx129_tgt, rx129_tgt, rx129_off
  rx129_start:
    eq $I10, 1, rx129_restart
    if_null rx129_debug, debug_462
    rx129_cur."!cursor_debug"("START", "pod_comment")
  debug_462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan132_done
    goto rxscan132_scan
  rxscan132_loop:
    (rx129_pos) = rx129_cur."from"()
    inc rx129_pos
    rx129_cur."!cursor_from"(rx129_pos)
    ge rx129_pos, rx129_eos, rxscan132_done
  rxscan132_scan:
    set_addr $I10, rxscan132_loop
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
  rxscan132_done:
.annotate 'line', 71
  # rxanchor bol
    eq rx129_pos, 0, rxanchor133_done
    ge rx129_pos, rx129_eos, rx129_fail
    sub $I10, rx129_pos, rx129_off
    dec $I10
    is_cclass $I11, 4096, rx129_tgt, $I10
    unless $I11, rx129_fail
  rxanchor133_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    add rx129_pos, rx129_pos, rx129_rep
  # rx literal  "="
    add $I11, rx129_pos, 1
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    ord $I11, rx129_tgt, $I11
    ne $I11, 61, rx129_fail
    add rx129_pos, 1
  alt135_0:
.annotate 'line', 72
    set_addr $I10, alt135_1
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
.annotate 'line', 73
  # rx literal  "begin"
    add $I11, rx129_pos, 5
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 5
    ne $S10, "begin", rx129_fail
    add rx129_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    lt rx129_rep, 1, rx129_fail
    add rx129_pos, rx129_pos, rx129_rep
  # rx literal  "END"
    add $I11, rx129_pos, 3
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 3
    ne $S10, "END", rx129_fail
    add rx129_pos, 3
  # rxanchor rwb
    le rx129_pos, 0, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 8192, rx129_tgt, $I10
    if $I11, rx129_fail
    dec $I10
    is_cclass $I11, 8192, rx129_tgt, $I10
    unless $I11, rx129_fail
  alt137_0:
.annotate 'line', 74
    set_addr $I10, alt137_1
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
  # rx rxquantf138 ** 0..*
    set_addr $I10, rxquantf138_loop
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
    goto rxquantf138_done
  rxquantf138_loop:
  # rx charclass .
    ge rx129_pos, rx129_eos, rx129_fail
    inc rx129_pos
    set_addr $I10, rxquantf138_loop
    rx129_cur."!mark_push"(rx129_rep, rx129_pos, $I10)
  rxquantf138_done:
  # rx charclass nl
    ge rx129_pos, rx129_eos, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 4096, rx129_tgt, $I10
    unless $I11, rx129_fail
    substr $S10, rx129_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx129_pos, $I11
    inc rx129_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq140_loop:
    le $I12, 0, rxenumcharlistq140_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq140_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq140_loop
  rxenumcharlistq140_done:
    add rx129_pos, rx129_pos, rx129_rep
  # rx literal  "=end"
    add $I11, rx129_pos, 4
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 4
    ne $S10, "=end", rx129_fail
    add rx129_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    lt rx129_rep, 1, rx129_fail
    add rx129_pos, rx129_pos, rx129_rep
  # rx literal  "END"
    add $I11, rx129_pos, 3
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 3
    ne $S10, "END", rx129_fail
    add rx129_pos, 3
  # rxanchor rwb
    le rx129_pos, 0, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 8192, rx129_tgt, $I10
    if $I11, rx129_fail
    dec $I10
    is_cclass $I11, 8192, rx129_tgt, $I10
    unless $I11, rx129_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx129_pos, rx129_off
    find_cclass $I11, 4096, rx129_tgt, $I10, rx129_eos
    add rx129_pos, rx129_off, $I11
    goto alt137_end
  alt137_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx129_pos, rx129_off
    find_not_cclass $I11, 65535, rx129_tgt, $I10, rx129_eos
    add rx129_pos, rx129_off, $I11
  alt137_end:
.annotate 'line', 73
    goto alt135_end
  alt135_1:
    set_addr $I10, alt135_2
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
.annotate 'line', 75
  # rx literal  "begin"
    add $I11, rx129_pos, 5
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 5
    ne $S10, "begin", rx129_fail
    add rx129_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq142_loop:
    le $I12, 0, rxenumcharlistq142_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq142_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq142_loop
  rxenumcharlistq142_done:
    lt rx129_rep, 1, rx129_fail
    add rx129_pos, rx129_pos, rx129_rep
  # rx subrule "identifier" subtype=capture negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    $P10 = rx129_cur."identifier"()
    unless $P10, rx129_fail
    rx129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx129_pos = $P10."pos"()
  alt143_0:
.annotate 'line', 76
    set_addr $I10, alt143_1
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
.annotate 'line', 77
  # rx rxquantf144 ** 0..*
    set_addr $I10, rxquantf144_loop
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
    goto rxquantf144_done
  rxquantf144_loop:
  # rx charclass .
    ge rx129_pos, rx129_eos, rx129_fail
    inc rx129_pos
    set_addr $I10, rxquantf144_loop
    rx129_cur."!mark_push"(rx129_rep, rx129_pos, $I10)
  rxquantf144_done:
  # rx charclass nl
    ge rx129_pos, rx129_eos, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 4096, rx129_tgt, $I10
    unless $I11, rx129_fail
    substr $S10, rx129_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx129_pos, $I11
    inc rx129_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq146_loop:
    le $I12, 0, rxenumcharlistq146_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq146_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq146_loop
  rxenumcharlistq146_done:
    add rx129_pos, rx129_pos, rx129_rep
  # rx literal  "=end"
    add $I11, rx129_pos, 4
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 4
    ne $S10, "=end", rx129_fail
    add rx129_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq147_loop:
    le $I12, 0, rxenumcharlistq147_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq147_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq147_loop
  rxenumcharlistq147_done:
    lt rx129_rep, 1, rx129_fail
    add rx129_pos, rx129_pos, rx129_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    $P10 = rx129_cur."!BACKREF"("identifier")
    unless $P10, rx129_fail
    rx129_pos = $P10."pos"()
  # rxanchor rwb
    le rx129_pos, 0, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 8192, rx129_tgt, $I10
    if $I11, rx129_fail
    dec $I10
    is_cclass $I11, 8192, rx129_tgt, $I10
    unless $I11, rx129_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx129_pos, rx129_off
    find_cclass $I11, 4096, rx129_tgt, $I10, rx129_eos
    add rx129_pos, rx129_off, $I11
    goto alt143_end
  alt143_1:
.annotate 'line', 78
  # rx subrule "panic" subtype=method negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    $P10 = rx129_cur."panic"("=begin without matching =end")
    unless $P10, rx129_fail
    rx129_pos = $P10."pos"()
  alt143_end:
.annotate 'line', 75
    goto alt135_end
  alt135_2:
    set_addr $I10, alt135_3
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx129_pos, 5
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 5
    ne $S10, "begin", rx129_fail
    add rx129_pos, 5
  # rxanchor rwb
    le rx129_pos, 0, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 8192, rx129_tgt, $I10
    if $I11, rx129_fail
    dec $I10
    is_cclass $I11, 8192, rx129_tgt, $I10
    unless $I11, rx129_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    add rx129_pos, rx129_pos, rx129_rep
  alt150_0:
.annotate 'line', 81
    set_addr $I10, alt150_1
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
  # rxanchor eol
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 4096, rx129_tgt, $I10
    if $I11, rxanchor151_done
    ne rx129_pos, rx129_eos, rx129_fail
    eq rx129_pos, 0, rxanchor151_done
    dec $I10
    is_cclass $I11, 4096, rx129_tgt, $I10
    if $I11, rx129_fail
  rxanchor151_done:
    goto alt150_end
  alt150_1:
    set_addr $I10, alt150_2
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
  # rx literal  "#"
    add $I11, rx129_pos, 1
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    ord $I11, rx129_tgt, $I11
    ne $I11, 35, rx129_fail
    add rx129_pos, 1
    goto alt150_end
  alt150_2:
  # rx subrule "panic" subtype=method negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    $P10 = rx129_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx129_fail
    rx129_pos = $P10."pos"()
  alt150_end:
  alt152_0:
.annotate 'line', 82
    set_addr $I10, alt152_1
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
.annotate 'line', 83
  # rx rxquantf153 ** 0..*
    set_addr $I10, rxquantf153_loop
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
    goto rxquantf153_done
  rxquantf153_loop:
  # rx charclass .
    ge rx129_pos, rx129_eos, rx129_fail
    inc rx129_pos
    set_addr $I10, rxquantf153_loop
    rx129_cur."!mark_push"(rx129_rep, rx129_pos, $I10)
  rxquantf153_done:
  # rx charclass nl
    ge rx129_pos, rx129_eos, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 4096, rx129_tgt, $I10
    unless $I11, rx129_fail
    substr $S10, rx129_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx129_pos, $I11
    inc rx129_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx129_pos, rx129_off
    set rx129_rep, 0
    sub $I12, rx129_eos, rx129_pos
  rxenumcharlistq155_loop:
    le $I12, 0, rxenumcharlistq155_done
    substr $S10, rx129_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq155_done
    inc rx129_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq155_loop
  rxenumcharlistq155_done:
    add rx129_pos, rx129_pos, rx129_rep
  # rx literal  "=end"
    add $I11, rx129_pos, 4
    gt $I11, rx129_eos, rx129_fail
    sub $I11, rx129_pos, rx129_off
    substr $S10, rx129_tgt, $I11, 4
    ne $S10, "=end", rx129_fail
    add rx129_pos, 4
  # rxanchor rwb
    le rx129_pos, 0, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 8192, rx129_tgt, $I10
    if $I11, rx129_fail
    dec $I10
    is_cclass $I11, 8192, rx129_tgt, $I10
    unless $I11, rx129_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx129_pos, rx129_off
    find_cclass $I11, 4096, rx129_tgt, $I10, rx129_eos
    add rx129_pos, rx129_off, $I11
    goto alt152_end
  alt152_1:
.annotate 'line', 84
  # rx subrule "panic" subtype=method negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    $P10 = rx129_cur."panic"("=begin without matching =end")
    unless $P10, rx129_fail
    rx129_pos = $P10."pos"()
  alt152_end:
.annotate 'line', 80
    goto alt135_end
  alt135_3:
    set_addr $I10, alt135_4
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
.annotate 'line', 86
  # rx subrule "identifier" subtype=capture negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    $P10 = rx129_cur."identifier"()
    unless $P10, rx129_fail
    rx129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx129_pos = $P10."pos"()
.annotate 'line', 87
  # rx rxquantf156 ** 0..*
    set_addr $I10, rxquantf156_loop
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
    goto rxquantf156_done
  rxquantf156_loop:
  # rx charclass .
    ge rx129_pos, rx129_eos, rx129_fail
    inc rx129_pos
    set_addr $I10, rxquantf156_loop
    rx129_cur."!mark_push"(rx129_rep, rx129_pos, $I10)
  rxquantf156_done:
  # rxanchor bol
    eq rx129_pos, 0, rxanchor158_done
    ge rx129_pos, rx129_eos, rx129_fail
    sub $I10, rx129_pos, rx129_off
    dec $I10
    is_cclass $I11, 4096, rx129_tgt, $I10
    unless $I11, rx129_fail
  rxanchor158_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    .const 'Sub' $P160 = "28_1299465717.405" 
    capture_lex $P160
    $P10 = rx129_cur."before"($P160)
    unless $P10, rx129_fail
.annotate 'line', 86
    goto alt135_end
  alt135_4:
  alt166_0:
.annotate 'line', 93
    set_addr $I10, alt166_1
    rx129_cur."!mark_push"(0, rx129_pos, $I10)
  # rx charclass s
    ge rx129_pos, rx129_eos, rx129_fail
    sub $I10, rx129_pos, rx129_off
    is_cclass $I11, 32, rx129_tgt, $I10
    unless $I11, rx129_fail
    inc rx129_pos
    goto alt166_end
  alt166_1:
  # rx subrule "panic" subtype=method negate=
    rx129_cur."!cursor_pos"(rx129_pos)
    $P10 = rx129_cur."panic"("Illegal pod directive")
    unless $P10, rx129_fail
    rx129_pos = $P10."pos"()
  alt166_end:
.annotate 'line', 94
  # rx charclass_q N r 0..-1
    sub $I10, rx129_pos, rx129_off
    find_cclass $I11, 4096, rx129_tgt, $I10, rx129_eos
    add rx129_pos, rx129_off, $I11
  alt135_end:
.annotate 'line', 70
  # rx pass
    rx129_cur."!cursor_pass"(rx129_pos, "pod_comment")
    if_null rx129_debug, debug_467
    rx129_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx129_pos)
  debug_467:
    .return (rx129_cur)
  rx129_restart:
.annotate 'line', 4
    if_null rx129_debug, debug_468
    rx129_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_468:
  rx129_fail:
    (rx129_rep, rx129_pos, $I10, $P10) = rx129_cur."!mark_fail"(0)
    lt rx129_pos, -1, rx129_done
    eq rx129_pos, -1, rx129_fail
    jump $I10
  rx129_done:
    rx129_cur."!cursor_fail"()
    if_null rx129_debug, debug_469
    rx129_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_469:
    .return (rx129_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1299465717.405") :method
.annotate 'line', 4
    new $P131, "ResizablePMCArray"
    push $P131, ""
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block159"  :anon :subid("28_1299465717.405") :method :outer("26_1299465717.405")
.annotate 'line', 87
    .local string rx161_tgt
    .local int rx161_pos
    .local int rx161_off
    .local int rx161_eos
    .local int rx161_rep
    .local pmc rx161_cur
    .local pmc rx161_debug
    (rx161_cur, rx161_pos, rx161_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx161_cur
    .local pmc match
    .lex "$/", match
    length rx161_eos, rx161_tgt
    gt rx161_pos, rx161_eos, rx161_done
    set rx161_off, 0
    lt rx161_pos, 2, rx161_start
    sub rx161_off, rx161_pos, 1
    substr rx161_tgt, rx161_tgt, rx161_off
  rx161_start:
    eq $I10, 1, rx161_restart
    if_null rx161_debug, debug_463
    rx161_cur."!cursor_debug"("START", "")
  debug_463:
    $I10 = self.'from'()
    ne $I10, -1, rxscan162_done
    goto rxscan162_scan
  rxscan162_loop:
    (rx161_pos) = rx161_cur."from"()
    inc rx161_pos
    rx161_cur."!cursor_from"(rx161_pos)
    ge rx161_pos, rx161_eos, rxscan162_done
  rxscan162_scan:
    set_addr $I10, rxscan162_loop
    rx161_cur."!mark_push"(0, rx161_pos, $I10)
  rxscan162_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx161_pos, rx161_off
    set rx161_rep, 0
    sub $I12, rx161_eos, rx161_pos
  rxenumcharlistq163_loop:
    le $I12, 0, rxenumcharlistq163_done
    substr $S10, rx161_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq163_done
    inc rx161_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq163_loop
  rxenumcharlistq163_done:
    add rx161_pos, rx161_pos, rx161_rep
  alt164_0:
    set_addr $I10, alt164_1
    rx161_cur."!mark_push"(0, rx161_pos, $I10)
.annotate 'line', 88
  # rx literal  "="
    add $I11, rx161_pos, 1
    gt $I11, rx161_eos, rx161_fail
    sub $I11, rx161_pos, rx161_off
    ord $I11, rx161_tgt, $I11
    ne $I11, 61, rx161_fail
    add rx161_pos, 1
.annotate 'line', 90
  # rx rxquantr165 ** 0..1
    set_addr $I10, rxquantr165_done
    rx161_cur."!mark_push"(0, rx161_pos, $I10)
  rxquantr165_loop:
.annotate 'line', 89
  # rx literal  "cut"
    add $I11, rx161_pos, 3
    gt $I11, rx161_eos, rx161_fail
    sub $I11, rx161_pos, rx161_off
    substr $S10, rx161_tgt, $I11, 3
    ne $S10, "cut", rx161_fail
    add rx161_pos, 3
  # rxanchor rwb
    le rx161_pos, 0, rx161_fail
    sub $I10, rx161_pos, rx161_off
    is_cclass $I11, 8192, rx161_tgt, $I10
    if $I11, rx161_fail
    dec $I10
    is_cclass $I11, 8192, rx161_tgt, $I10
    unless $I11, rx161_fail
.annotate 'line', 90
  # rx subrule "panic" subtype=method negate=
    rx161_cur."!cursor_pos"(rx161_pos)
    $P10 = rx161_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx161_fail
    rx161_pos = $P10."pos"()
    set_addr $I10, rxquantr165_done
    (rx161_rep) = rx161_cur."!mark_commit"($I10)
  rxquantr165_done:
.annotate 'line', 87
    goto alt164_end
  alt164_1:
.annotate 'line', 91
  # rx charclass nl
    ge rx161_pos, rx161_eos, rx161_fail
    sub $I10, rx161_pos, rx161_off
    is_cclass $I11, 4096, rx161_tgt, $I10
    unless $I11, rx161_fail
    substr $S10, rx161_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx161_pos, $I11
    inc rx161_pos
  alt164_end:
.annotate 'line', 87
  # rx pass
    rx161_cur."!cursor_pass"(rx161_pos, "")
    if_null rx161_debug, debug_464
    rx161_cur."!cursor_debug"("PASS", "", " at pos=", rx161_pos)
  debug_464:
    .return (rx161_cur)
  rx161_restart:
    if_null rx161_debug, debug_465
    rx161_cur."!cursor_debug"("NEXT", "")
  debug_465:
  rx161_fail:
    (rx161_rep, rx161_pos, $I10, $P10) = rx161_cur."!mark_fail"(0)
    lt rx161_pos, -1, rx161_done
    eq rx161_pos, -1, rx161_fail
    jump $I10
  rx161_done:
    rx161_cur."!cursor_fail"()
    if_null rx161_debug, debug_466
    rx161_cur."!cursor_debug"("FAIL", "")
  debug_466:
    .return (rx161_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 102
    new $P168, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P168
.annotate 'line', 4
    .local string rx169_tgt
    .local int rx169_pos
    .local int rx169_off
    .local int rx169_eos
    .local int rx169_rep
    .local pmc rx169_cur
    .local pmc rx169_debug
    (rx169_cur, rx169_pos, rx169_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx169_cur
    .local pmc match
    .lex "$/", match
    length rx169_eos, rx169_tgt
    gt rx169_pos, rx169_eos, rx169_done
    set rx169_off, 0
    lt rx169_pos, 2, rx169_start
    sub rx169_off, rx169_pos, 1
    substr rx169_tgt, rx169_tgt, rx169_off
  rx169_start:
    eq $I10, 1, rx169_restart
    if_null rx169_debug, debug_470
    rx169_cur."!cursor_debug"("START", "comp_unit")
  debug_470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan173_done
    goto rxscan173_scan
  rxscan173_loop:
    (rx169_pos) = rx169_cur."from"()
    inc rx169_pos
    rx169_cur."!cursor_from"(rx169_pos)
    ge rx169_pos, rx169_eos, rxscan173_done
  rxscan173_scan:
    set_addr $I10, rxscan173_loop
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  rxscan173_done:
.annotate 'line', 102
    rx169_cur."!cursor_pos"(rx169_pos)
    new $P174, "Integer"
    assign $P174, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P174
.annotate 'line', 103
  # rx subrule "newpad" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."newpad"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
.annotate 'line', 104
  # rx subrule "outerctx" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."outerctx"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
.annotate 'line', 105
  # rx subrule "statementlist" subtype=capture negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."statementlist"()
    unless $P10, rx169_fail
    rx169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx169_pos = $P10."pos"()
  alt175_0:
.annotate 'line', 106
    set_addr $I10, alt175_1
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  # rxanchor eos
    ne rx169_pos, rx169_eos, rx169_fail
    goto alt175_end
  alt175_1:
  # rx subrule "panic" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."panic"("Confused")
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  alt175_end:
.annotate 'line', 101
  # rx pass
    rx169_cur."!cursor_pass"(rx169_pos, "comp_unit")
    if_null rx169_debug, debug_471
    rx169_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx169_pos)
  debug_471:
    .return (rx169_cur)
  rx169_restart:
.annotate 'line', 4
    if_null rx169_debug, debug_472
    rx169_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_472:
  rx169_fail:
    (rx169_rep, rx169_pos, $I10, $P10) = rx169_cur."!mark_fail"(0)
    lt rx169_pos, -1, rx169_done
    eq rx169_pos, -1, rx169_fail
    jump $I10
  rx169_done:
    rx169_cur."!cursor_fail"()
    if_null rx169_debug, debug_473
    rx169_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_473:
    .return (rx169_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1299465717.405") :method
.annotate 'line', 4
    $P171 = self."!PREFIX__!subrule"("newpad", "")
    new $P172, "ResizablePMCArray"
    push $P172, $P171
    .return ($P172)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx177_tgt
    .local int rx177_pos
    .local int rx177_off
    .local int rx177_eos
    .local int rx177_rep
    .local pmc rx177_cur
    .local pmc rx177_debug
    (rx177_cur, rx177_pos, rx177_tgt, $I10) = self."!cursor_start"()
    rx177_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx177_cur
    .local pmc match
    .lex "$/", match
    length rx177_eos, rx177_tgt
    gt rx177_pos, rx177_eos, rx177_done
    set rx177_off, 0
    lt rx177_pos, 2, rx177_start
    sub rx177_off, rx177_pos, 1
    substr rx177_tgt, rx177_tgt, rx177_off
  rx177_start:
    eq $I10, 1, rx177_restart
    if_null rx177_debug, debug_474
    rx177_cur."!cursor_debug"("START", "statementlist")
  debug_474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan182_done
    goto rxscan182_scan
  rxscan182_loop:
    (rx177_pos) = rx177_cur."from"()
    inc rx177_pos
    rx177_cur."!cursor_from"(rx177_pos)
    ge rx177_pos, rx177_eos, rxscan182_done
  rxscan182_scan:
    set_addr $I10, rxscan182_loop
    rx177_cur."!mark_push"(0, rx177_pos, $I10)
  rxscan182_done:
  alt183_0:
.annotate 'line', 109
    set_addr $I10, alt183_1
    rx177_cur."!mark_push"(0, rx177_pos, $I10)
.annotate 'line', 110
  # rx subrule "ws" subtype=method negate=
    rx177_cur."!cursor_pos"(rx177_pos)
    $P10 = rx177_cur."ws"()
    unless $P10, rx177_fail
    rx177_pos = $P10."pos"()
  # rxanchor eos
    ne rx177_pos, rx177_eos, rx177_fail
  # rx subrule "ws" subtype=method negate=
    rx177_cur."!cursor_pos"(rx177_pos)
    $P10 = rx177_cur."ws"()
    unless $P10, rx177_fail
    rx177_pos = $P10."pos"()
    goto alt183_end
  alt183_1:
.annotate 'line', 111
  # rx subrule "ws" subtype=method negate=
    rx177_cur."!cursor_pos"(rx177_pos)
    $P10 = rx177_cur."ws"()
    unless $P10, rx177_fail
    rx177_pos = $P10."pos"()
  # rx rxquantr187 ** 0..*
    set_addr $I10, rxquantr187_done
    rx177_cur."!mark_push"(0, rx177_pos, $I10)
  rxquantr187_loop:
  # rx subrule "statement" subtype=capture negate=
    rx177_cur."!cursor_pos"(rx177_pos)
    $P10 = rx177_cur."statement"()
    unless $P10, rx177_fail
    rx177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx177_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx177_cur."!cursor_pos"(rx177_pos)
    $P10 = rx177_cur."eat_terminator"()
    unless $P10, rx177_fail
    rx177_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx177_cur."!cursor_pos"(rx177_pos)
    $P10 = rx177_cur."ws"()
    unless $P10, rx177_fail
    rx177_pos = $P10."pos"()
    set_addr $I10, rxquantr187_done
    (rx177_rep) = rx177_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr187_done
    rx177_cur."!mark_push"(rx177_rep, rx177_pos, $I10)
    goto rxquantr187_loop
  rxquantr187_done:
  # rx subrule "ws" subtype=method negate=
    rx177_cur."!cursor_pos"(rx177_pos)
    $P10 = rx177_cur."ws"()
    unless $P10, rx177_fail
    rx177_pos = $P10."pos"()
  alt183_end:
.annotate 'line', 109
  # rx pass
    rx177_cur."!cursor_pass"(rx177_pos, "statementlist")
    if_null rx177_debug, debug_475
    rx177_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx177_pos)
  debug_475:
    .return (rx177_cur)
  rx177_restart:
.annotate 'line', 4
    if_null rx177_debug, debug_476
    rx177_cur."!cursor_debug"("NEXT", "statementlist")
  debug_476:
  rx177_fail:
    (rx177_rep, rx177_pos, $I10, $P10) = rx177_cur."!mark_fail"(0)
    lt rx177_pos, -1, rx177_done
    eq rx177_pos, -1, rx177_fail
    jump $I10
  rx177_done:
    rx177_cur."!cursor_fail"()
    if_null rx177_debug, debug_477
    rx177_cur."!cursor_debug"("FAIL", "statementlist")
  debug_477:
    .return (rx177_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1299465717.405") :method
.annotate 'line', 4
    $P179 = self."!PREFIX__!subrule"("ws", "")
    $P180 = self."!PREFIX__!subrule"("ws", "")
    new $P181, "ResizablePMCArray"
    push $P181, $P179
    push $P181, $P180
    .return ($P181)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P196 = "35_1299465717.405" 
    capture_lex $P196
    .local string rx191_tgt
    .local int rx191_pos
    .local int rx191_off
    .local int rx191_eos
    .local int rx191_rep
    .local pmc rx191_cur
    .local pmc rx191_debug
    (rx191_cur, rx191_pos, rx191_tgt, $I10) = self."!cursor_start"()
    rx191_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx191_cur
    .local pmc match
    .lex "$/", match
    length rx191_eos, rx191_tgt
    gt rx191_pos, rx191_eos, rx191_done
    set rx191_off, 0
    lt rx191_pos, 2, rx191_start
    sub rx191_off, rx191_pos, 1
    substr rx191_tgt, rx191_tgt, rx191_off
  rx191_start:
    eq $I10, 1, rx191_restart
    if_null rx191_debug, debug_478
    rx191_cur."!cursor_debug"("START", "statement")
  debug_478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan194_done
    goto rxscan194_scan
  rxscan194_loop:
    (rx191_pos) = rx191_cur."from"()
    inc rx191_pos
    rx191_cur."!cursor_from"(rx191_pos)
    ge rx191_pos, rx191_eos, rxscan194_done
  rxscan194_scan:
    set_addr $I10, rxscan194_loop
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  rxscan194_done:
.annotate 'line', 115
  # rx subrule "before" subtype=zerowidth negate=1
    rx191_cur."!cursor_pos"(rx191_pos)
    .const 'Sub' $P196 = "35_1299465717.405" 
    capture_lex $P196
    $P10 = rx191_cur."before"($P196)
    if $P10, rx191_fail
  alt200_0:
.annotate 'line', 116
    set_addr $I10, alt200_1
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
.annotate 'line', 117
  # rx subrule "statement_control" subtype=capture negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."statement_control"()
    unless $P10, rx191_fail
    rx191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx191_pos = $P10."pos"()
    goto alt200_end
  alt200_1:
.annotate 'line', 118
  # rx subrule "EXPR" subtype=capture negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."EXPR"()
    unless $P10, rx191_fail
    rx191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx191_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."ws"()
    unless $P10, rx191_fail
    rx191_pos = $P10."pos"()
.annotate 'line', 123
  # rx rxquantr201 ** 0..1
    set_addr $I10, rxquantr201_done
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  rxquantr201_loop:
  alt202_0:
.annotate 'line', 119
    set_addr $I10, alt202_1
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
.annotate 'line', 120
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."MARKED"("endstmt")
    unless $P10, rx191_fail
    goto alt202_end
  alt202_1:
    set_addr $I10, alt202_2
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
.annotate 'line', 121
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."statement_mod_cond"()
    unless $P10, rx191_fail
    rx191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx191_pos = $P10."pos"()
  # rx rxquantr203 ** 0..1
    set_addr $I10, rxquantr203_done
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  rxquantr203_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."statement_mod_loop"()
    unless $P10, rx191_fail
    goto rxsubrule204_pass
  rxsubrule204_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx191_fail
  rxsubrule204_pass:
    set_addr $I10, rxsubrule204_back
    rx191_cur."!mark_push"(0, rx191_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx191_pos = $P10."pos"()
    set_addr $I10, rxquantr203_done
    (rx191_rep) = rx191_cur."!mark_commit"($I10)
  rxquantr203_done:
    goto alt202_end
  alt202_2:
.annotate 'line', 122
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."statement_mod_loop"()
    unless $P10, rx191_fail
    rx191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx191_pos = $P10."pos"()
  alt202_end:
.annotate 'line', 123
    set_addr $I10, rxquantr201_done
    (rx191_rep) = rx191_cur."!mark_commit"($I10)
  rxquantr201_done:
  alt200_end:
.annotate 'line', 114
  # rx pass
    rx191_cur."!cursor_pass"(rx191_pos, "statement")
    if_null rx191_debug, debug_483
    rx191_cur."!cursor_debug"("PASS", "statement", " at pos=", rx191_pos)
  debug_483:
    .return (rx191_cur)
  rx191_restart:
.annotate 'line', 4
    if_null rx191_debug, debug_484
    rx191_cur."!cursor_debug"("NEXT", "statement")
  debug_484:
  rx191_fail:
    (rx191_rep, rx191_pos, $I10, $P10) = rx191_cur."!mark_fail"(0)
    lt rx191_pos, -1, rx191_done
    eq rx191_pos, -1, rx191_fail
    jump $I10
  rx191_done:
    rx191_cur."!cursor_fail"()
    if_null rx191_debug, debug_485
    rx191_cur."!cursor_debug"("FAIL", "statement")
  debug_485:
    .return (rx191_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1299465717.405") :method
.annotate 'line', 4
    new $P193, "ResizablePMCArray"
    push $P193, ""
    .return ($P193)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block195"  :anon :subid("35_1299465717.405") :method :outer("33_1299465717.405")
.annotate 'line', 115
    .local string rx197_tgt
    .local int rx197_pos
    .local int rx197_off
    .local int rx197_eos
    .local int rx197_rep
    .local pmc rx197_cur
    .local pmc rx197_debug
    (rx197_cur, rx197_pos, rx197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx197_cur
    .local pmc match
    .lex "$/", match
    length rx197_eos, rx197_tgt
    gt rx197_pos, rx197_eos, rx197_done
    set rx197_off, 0
    lt rx197_pos, 2, rx197_start
    sub rx197_off, rx197_pos, 1
    substr rx197_tgt, rx197_tgt, rx197_off
  rx197_start:
    eq $I10, 1, rx197_restart
    if_null rx197_debug, debug_479
    rx197_cur."!cursor_debug"("START", "")
  debug_479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan198_done
    goto rxscan198_scan
  rxscan198_loop:
    (rx197_pos) = rx197_cur."from"()
    inc rx197_pos
    rx197_cur."!cursor_from"(rx197_pos)
    ge rx197_pos, rx197_eos, rxscan198_done
  rxscan198_scan:
    set_addr $I10, rxscan198_loop
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
  rxscan198_done:
  alt199_0:
    set_addr $I10, alt199_1
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx197_pos, rx197_eos, rx197_fail
    sub $I10, rx197_pos, rx197_off
    substr $S10, rx197_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx197_fail
    inc rx197_pos
    goto alt199_end
  alt199_1:
  # rxanchor eos
    ne rx197_pos, rx197_eos, rx197_fail
  alt199_end:
  # rx pass
    rx197_cur."!cursor_pass"(rx197_pos, "")
    if_null rx197_debug, debug_480
    rx197_cur."!cursor_debug"("PASS", "", " at pos=", rx197_pos)
  debug_480:
    .return (rx197_cur)
  rx197_restart:
    if_null rx197_debug, debug_481
    rx197_cur."!cursor_debug"("NEXT", "")
  debug_481:
  rx197_fail:
    (rx197_rep, rx197_pos, $I10, $P10) = rx197_cur."!mark_fail"(0)
    lt rx197_pos, -1, rx197_done
    eq rx197_pos, -1, rx197_fail
    jump $I10
  rx197_done:
    rx197_cur."!cursor_fail"()
    if_null rx197_debug, debug_482
    rx197_cur."!cursor_debug"("FAIL", "")
  debug_482:
    .return (rx197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx206_tgt
    .local int rx206_pos
    .local int rx206_off
    .local int rx206_eos
    .local int rx206_rep
    .local pmc rx206_cur
    .local pmc rx206_debug
    (rx206_cur, rx206_pos, rx206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx206_cur
    .local pmc match
    .lex "$/", match
    length rx206_eos, rx206_tgt
    gt rx206_pos, rx206_eos, rx206_done
    set rx206_off, 0
    lt rx206_pos, 2, rx206_start
    sub rx206_off, rx206_pos, 1
    substr rx206_tgt, rx206_tgt, rx206_off
  rx206_start:
    eq $I10, 1, rx206_restart
    if_null rx206_debug, debug_486
    rx206_cur."!cursor_debug"("START", "eat_terminator")
  debug_486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan209_done
    goto rxscan209_scan
  rxscan209_loop:
    (rx206_pos) = rx206_cur."from"()
    inc rx206_pos
    rx206_cur."!cursor_from"(rx206_pos)
    ge rx206_pos, rx206_eos, rxscan209_done
  rxscan209_scan:
    set_addr $I10, rxscan209_loop
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
  rxscan209_done:
  alt210_0:
.annotate 'line', 127
    set_addr $I10, alt210_1
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
.annotate 'line', 128
  # rx literal  ";"
    add $I11, rx206_pos, 1
    gt $I11, rx206_eos, rx206_fail
    sub $I11, rx206_pos, rx206_off
    ord $I11, rx206_tgt, $I11
    ne $I11, 59, rx206_fail
    add rx206_pos, 1
    goto alt210_end
  alt210_1:
    set_addr $I10, alt210_2
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
.annotate 'line', 129
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."MARKED"("endstmt")
    unless $P10, rx206_fail
    goto alt210_end
  alt210_2:
    set_addr $I10, alt210_3
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
.annotate 'line', 130
  # rx subrule "terminator" subtype=zerowidth negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."terminator"()
    unless $P10, rx206_fail
    goto alt210_end
  alt210_3:
.annotate 'line', 131
  # rxanchor eos
    ne rx206_pos, rx206_eos, rx206_fail
  alt210_end:
.annotate 'line', 127
  # rx pass
    rx206_cur."!cursor_pass"(rx206_pos, "eat_terminator")
    if_null rx206_debug, debug_487
    rx206_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx206_pos)
  debug_487:
    .return (rx206_cur)
  rx206_restart:
.annotate 'line', 4
    if_null rx206_debug, debug_488
    rx206_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_488:
  rx206_fail:
    (rx206_rep, rx206_pos, $I10, $P10) = rx206_cur."!mark_fail"(0)
    lt rx206_pos, -1, rx206_done
    eq rx206_pos, -1, rx206_fail
    jump $I10
  rx206_done:
    rx206_cur."!cursor_fail"()
    if_null rx206_debug, debug_489
    rx206_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_489:
    .return (rx206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1299465717.405") :method
.annotate 'line', 4
    new $P208, "ResizablePMCArray"
    push $P208, ""
    push $P208, ""
    push $P208, ""
    push $P208, ";"
    .return ($P208)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx212_tgt
    .local int rx212_pos
    .local int rx212_off
    .local int rx212_eos
    .local int rx212_rep
    .local pmc rx212_cur
    .local pmc rx212_debug
    (rx212_cur, rx212_pos, rx212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx212_cur
    .local pmc match
    .lex "$/", match
    length rx212_eos, rx212_tgt
    gt rx212_pos, rx212_eos, rx212_done
    set rx212_off, 0
    lt rx212_pos, 2, rx212_start
    sub rx212_off, rx212_pos, 1
    substr rx212_tgt, rx212_tgt, rx212_off
  rx212_start:
    eq $I10, 1, rx212_restart
    if_null rx212_debug, debug_490
    rx212_cur."!cursor_debug"("START", "xblock")
  debug_490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan216_done
    goto rxscan216_scan
  rxscan216_loop:
    (rx212_pos) = rx212_cur."from"()
    inc rx212_pos
    rx212_cur."!cursor_from"(rx212_pos)
    ge rx212_pos, rx212_eos, rxscan216_done
  rxscan216_scan:
    set_addr $I10, rxscan216_loop
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  rxscan216_done:
.annotate 'line', 135
  # rx subrule "EXPR" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."EXPR"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx212_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."ws"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."pblock"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx212_pos = $P10."pos"()
.annotate 'line', 134
  # rx pass
    rx212_cur."!cursor_pass"(rx212_pos, "xblock")
    if_null rx212_debug, debug_491
    rx212_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx212_pos)
  debug_491:
    .return (rx212_cur)
  rx212_restart:
.annotate 'line', 4
    if_null rx212_debug, debug_492
    rx212_cur."!cursor_debug"("NEXT", "xblock")
  debug_492:
  rx212_fail:
    (rx212_rep, rx212_pos, $I10, $P10) = rx212_cur."!mark_fail"(0)
    lt rx212_pos, -1, rx212_done
    eq rx212_pos, -1, rx212_fail
    jump $I10
  rx212_done:
    rx212_cur."!cursor_fail"()
    if_null rx212_debug, debug_493
    rx212_cur."!cursor_debug"("FAIL", "xblock")
  debug_493:
    .return (rx212_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1299465717.405") :method
.annotate 'line', 4
    $P214 = self."!PREFIX__!subrule"("EXPR", "")
    new $P215, "ResizablePMCArray"
    push $P215, $P214
    .return ($P215)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx218_tgt
    .local int rx218_pos
    .local int rx218_off
    .local int rx218_eos
    .local int rx218_rep
    .local pmc rx218_cur
    .local pmc rx218_debug
    (rx218_cur, rx218_pos, rx218_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx218_cur
    .local pmc match
    .lex "$/", match
    length rx218_eos, rx218_tgt
    gt rx218_pos, rx218_eos, rx218_done
    set rx218_off, 0
    lt rx218_pos, 2, rx218_start
    sub rx218_off, rx218_pos, 1
    substr rx218_tgt, rx218_tgt, rx218_off
  rx218_start:
    eq $I10, 1, rx218_restart
    if_null rx218_debug, debug_494
    rx218_cur."!cursor_debug"("START", "pblock")
  debug_494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx218_pos) = rx218_cur."from"()
    inc rx218_pos
    rx218_cur."!cursor_from"(rx218_pos)
    ge rx218_pos, rx218_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 138
    set_addr $I10, alt224_1
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
.annotate 'line', 139
  # rx subrule "lambda" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."lambda"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
.annotate 'line', 140
  # rx subrule "newpad" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."newpad"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
.annotate 'line', 141
  # rx subrule "signature" subtype=capture negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."signature"()
    unless $P10, rx218_fail
    rx218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx218_pos = $P10."pos"()
.annotate 'line', 142
  # rx subrule "blockoid" subtype=capture negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."blockoid"()
    unless $P10, rx218_fail
    rx218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx218_pos = $P10."pos"()
.annotate 'line', 139
    goto alt224_end
  alt224_1:
    set_addr $I10, alt224_2
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
.annotate 'line', 143
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx218_pos, rx218_off
    substr $S10, rx218_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx218_fail
.annotate 'line', 144
  # rx subrule "newpad" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."newpad"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
.annotate 'line', 145
  # rx subrule "blockoid" subtype=capture negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."blockoid"()
    unless $P10, rx218_fail
    rx218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx218_pos = $P10."pos"()
.annotate 'line', 143
    goto alt224_end
  alt224_2:
.annotate 'line', 146
  # rx subrule "panic" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."panic"("Missing block")
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  alt224_end:
.annotate 'line', 138
  # rx pass
    rx218_cur."!cursor_pass"(rx218_pos, "pblock")
    if_null rx218_debug, debug_495
    rx218_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx218_pos)
  debug_495:
    .return (rx218_cur)
  rx218_restart:
.annotate 'line', 4
    if_null rx218_debug, debug_496
    rx218_cur."!cursor_debug"("NEXT", "pblock")
  debug_496:
  rx218_fail:
    (rx218_rep, rx218_pos, $I10, $P10) = rx218_cur."!mark_fail"(0)
    lt rx218_pos, -1, rx218_done
    eq rx218_pos, -1, rx218_fail
    jump $I10
  rx218_done:
    rx218_cur."!cursor_fail"()
    if_null rx218_debug, debug_497
    rx218_cur."!cursor_debug"("FAIL", "pblock")
  debug_497:
    .return (rx218_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1299465717.405") :method
.annotate 'line', 4
    $P220 = self."!PREFIX__!subrule"("panic", "")
    $P221 = self."!PREFIX__!subrule"("lambda", "")
    new $P222, "ResizablePMCArray"
    push $P222, $P220
    push $P222, "{"
    push $P222, $P221
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx226_tgt
    .local int rx226_pos
    .local int rx226_off
    .local int rx226_eos
    .local int rx226_rep
    .local pmc rx226_cur
    .local pmc rx226_debug
    (rx226_cur, rx226_pos, rx226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx226_cur
    .local pmc match
    .lex "$/", match
    length rx226_eos, rx226_tgt
    gt rx226_pos, rx226_eos, rx226_done
    set rx226_off, 0
    lt rx226_pos, 2, rx226_start
    sub rx226_off, rx226_pos, 1
    substr rx226_tgt, rx226_tgt, rx226_off
  rx226_start:
    eq $I10, 1, rx226_restart
    if_null rx226_debug, debug_498
    rx226_cur."!cursor_debug"("START", "lambda")
  debug_498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan229_done
    goto rxscan229_scan
  rxscan229_loop:
    (rx226_pos) = rx226_cur."from"()
    inc rx226_pos
    rx226_cur."!cursor_from"(rx226_pos)
    ge rx226_pos, rx226_eos, rxscan229_done
  rxscan229_scan:
    set_addr $I10, rxscan229_loop
    rx226_cur."!mark_push"(0, rx226_pos, $I10)
  rxscan229_done:
  alt230_0:
.annotate 'line', 149
    set_addr $I10, alt230_1
    rx226_cur."!mark_push"(0, rx226_pos, $I10)
  # rx literal  "->"
    add $I11, rx226_pos, 2
    gt $I11, rx226_eos, rx226_fail
    sub $I11, rx226_pos, rx226_off
    substr $S10, rx226_tgt, $I11, 2
    ne $S10, "->", rx226_fail
    add rx226_pos, 2
    goto alt230_end
  alt230_1:
  # rx literal  "<->"
    add $I11, rx226_pos, 3
    gt $I11, rx226_eos, rx226_fail
    sub $I11, rx226_pos, rx226_off
    substr $S10, rx226_tgt, $I11, 3
    ne $S10, "<->", rx226_fail
    add rx226_pos, 3
  alt230_end:
  # rx pass
    rx226_cur."!cursor_pass"(rx226_pos, "lambda")
    if_null rx226_debug, debug_499
    rx226_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx226_pos)
  debug_499:
    .return (rx226_cur)
  rx226_restart:
.annotate 'line', 4
    if_null rx226_debug, debug_500
    rx226_cur."!cursor_debug"("NEXT", "lambda")
  debug_500:
  rx226_fail:
    (rx226_rep, rx226_pos, $I10, $P10) = rx226_cur."!mark_fail"(0)
    lt rx226_pos, -1, rx226_done
    eq rx226_pos, -1, rx226_fail
    jump $I10
  rx226_done:
    rx226_cur."!cursor_fail"()
    if_null rx226_debug, debug_501
    rx226_cur."!cursor_debug"("FAIL", "lambda")
  debug_501:
    .return (rx226_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1299465717.405") :method
.annotate 'line', 4
    new $P228, "ResizablePMCArray"
    push $P228, "<->"
    push $P228, "->"
    .return ($P228)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx232_tgt
    .local int rx232_pos
    .local int rx232_off
    .local int rx232_eos
    .local int rx232_rep
    .local pmc rx232_cur
    .local pmc rx232_debug
    (rx232_cur, rx232_pos, rx232_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx232_cur
    .local pmc match
    .lex "$/", match
    length rx232_eos, rx232_tgt
    gt rx232_pos, rx232_eos, rx232_done
    set rx232_off, 0
    lt rx232_pos, 2, rx232_start
    sub rx232_off, rx232_pos, 1
    substr rx232_tgt, rx232_tgt, rx232_off
  rx232_start:
    eq $I10, 1, rx232_restart
    if_null rx232_debug, debug_502
    rx232_cur."!cursor_debug"("START", "block")
  debug_502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan236_done
    goto rxscan236_scan
  rxscan236_loop:
    (rx232_pos) = rx232_cur."from"()
    inc rx232_pos
    rx232_cur."!cursor_from"(rx232_pos)
    ge rx232_pos, rx232_eos, rxscan236_done
  rxscan236_scan:
    set_addr $I10, rxscan236_loop
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  rxscan236_done:
  alt237_0:
.annotate 'line', 152
    set_addr $I10, alt237_1
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx232_pos, rx232_off
    substr $S10, rx232_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx232_fail
    goto alt237_end
  alt237_1:
  # rx subrule "panic" subtype=method negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."panic"("Missing block")
    unless $P10, rx232_fail
    rx232_pos = $P10."pos"()
  alt237_end:
.annotate 'line', 153
  # rx subrule "newpad" subtype=method negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."newpad"()
    unless $P10, rx232_fail
    rx232_pos = $P10."pos"()
.annotate 'line', 154
  # rx subrule "blockoid" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."blockoid"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx232_pos = $P10."pos"()
.annotate 'line', 151
  # rx pass
    rx232_cur."!cursor_pass"(rx232_pos, "block")
    if_null rx232_debug, debug_503
    rx232_cur."!cursor_debug"("PASS", "block", " at pos=", rx232_pos)
  debug_503:
    .return (rx232_cur)
  rx232_restart:
.annotate 'line', 4
    if_null rx232_debug, debug_504
    rx232_cur."!cursor_debug"("NEXT", "block")
  debug_504:
  rx232_fail:
    (rx232_rep, rx232_pos, $I10, $P10) = rx232_cur."!mark_fail"(0)
    lt rx232_pos, -1, rx232_done
    eq rx232_pos, -1, rx232_fail
    jump $I10
  rx232_done:
    rx232_cur."!cursor_fail"()
    if_null rx232_debug, debug_505
    rx232_cur."!cursor_debug"("FAIL", "block")
  debug_505:
    .return (rx232_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1299465717.405") :method
.annotate 'line', 4
    $P234 = self."!PREFIX__!subrule"("panic", "")
    new $P235, "ResizablePMCArray"
    push $P235, $P234
    push $P235, "{"
    .return ($P235)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx239_tgt
    .local int rx239_pos
    .local int rx239_off
    .local int rx239_eos
    .local int rx239_rep
    .local pmc rx239_cur
    .local pmc rx239_debug
    (rx239_cur, rx239_pos, rx239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx239_cur
    .local pmc match
    .lex "$/", match
    length rx239_eos, rx239_tgt
    gt rx239_pos, rx239_eos, rx239_done
    set rx239_off, 0
    lt rx239_pos, 2, rx239_start
    sub rx239_off, rx239_pos, 1
    substr rx239_tgt, rx239_tgt, rx239_off
  rx239_start:
    eq $I10, 1, rx239_restart
    if_null rx239_debug, debug_506
    rx239_cur."!cursor_debug"("START", "blockoid")
  debug_506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan243_done
    goto rxscan243_scan
  rxscan243_loop:
    (rx239_pos) = rx239_cur."from"()
    inc rx239_pos
    rx239_cur."!cursor_from"(rx239_pos)
    ge rx239_pos, rx239_eos, rxscan243_done
  rxscan243_scan:
    set_addr $I10, rxscan243_loop
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  rxscan243_done:
.annotate 'line', 158
  # rx subrule "finishpad" subtype=method negate=
    rx239_cur."!cursor_pos"(rx239_pos)
    $P10 = rx239_cur."finishpad"()
    unless $P10, rx239_fail
    rx239_pos = $P10."pos"()
  alt244_0:
.annotate 'line', 159
    set_addr $I10, alt244_1
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
.annotate 'line', 160
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx239_pos, 14
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    substr $S10, rx239_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx239_fail
    add rx239_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx239_cur."!cursor_pos"(rx239_pos)
    $P10 = rx239_cur."you_are_here"()
    unless $P10, rx239_fail
    rx239_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx239_pos = $P10."pos"()
    goto alt244_end
  alt244_1:
.annotate 'line', 161
  # rx literal  "{"
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 123, rx239_fail
    add rx239_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx239_cur."!cursor_pos"(rx239_pos)
    $P10 = rx239_cur."statementlist"()
    unless $P10, rx239_fail
    rx239_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx239_pos = $P10."pos"()
  alt245_0:
    set_addr $I10, alt245_1
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  # rx literal  "}"
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 125, rx239_fail
    add rx239_pos, 1
    goto alt245_end
  alt245_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx239_cur."!cursor_pos"(rx239_pos)
    $P10 = rx239_cur."FAILGOAL"("'}'")
    unless $P10, rx239_fail
    goto rxsubrule247_pass
  rxsubrule247_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx239_fail
  rxsubrule247_pass:
    set_addr $I10, rxsubrule247_back
    rx239_cur."!mark_push"(0, rx239_pos, $I10, $P10)
    rx239_pos = $P10."pos"()
  alt245_end:
  alt244_end:
.annotate 'line', 163
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx239_cur."!cursor_pos"(rx239_pos)
    $P10 = rx239_cur."ENDSTMT"()
    unless $P10, rx239_fail
.annotate 'line', 157
  # rx pass
    rx239_cur."!cursor_pass"(rx239_pos, "blockoid")
    if_null rx239_debug, debug_507
    rx239_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx239_pos)
  debug_507:
    .return (rx239_cur)
  rx239_restart:
.annotate 'line', 4
    if_null rx239_debug, debug_508
    rx239_cur."!cursor_debug"("NEXT", "blockoid")
  debug_508:
  rx239_fail:
    (rx239_rep, rx239_pos, $I10, $P10) = rx239_cur."!mark_fail"(0)
    lt rx239_pos, -1, rx239_done
    eq rx239_pos, -1, rx239_fail
    jump $I10
  rx239_done:
    rx239_cur."!cursor_fail"()
    if_null rx239_debug, debug_509
    rx239_cur."!cursor_debug"("FAIL", "blockoid")
  debug_509:
    .return (rx239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1299465717.405") :method
.annotate 'line', 4
    $P241 = self."!PREFIX__!subrule"("finishpad", "")
    new $P242, "ResizablePMCArray"
    push $P242, $P241
    .return ($P242)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx249_tgt
    .local int rx249_pos
    .local int rx249_off
    .local int rx249_eos
    .local int rx249_rep
    .local pmc rx249_cur
    .local pmc rx249_debug
    (rx249_cur, rx249_pos, rx249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx249_cur
    .local pmc match
    .lex "$/", match
    length rx249_eos, rx249_tgt
    gt rx249_pos, rx249_eos, rx249_done
    set rx249_off, 0
    lt rx249_pos, 2, rx249_start
    sub rx249_off, rx249_pos, 1
    substr rx249_tgt, rx249_tgt, rx249_off
  rx249_start:
    eq $I10, 1, rx249_restart
    if_null rx249_debug, debug_510
    rx249_cur."!cursor_debug"("START", "newpad")
  debug_510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan252_done
    goto rxscan252_scan
  rxscan252_loop:
    (rx249_pos) = rx249_cur."from"()
    inc rx249_pos
    rx249_cur."!cursor_from"(rx249_pos)
    ge rx249_pos, rx249_eos, rxscan252_done
  rxscan252_scan:
    set_addr $I10, rxscan252_loop
    rx249_cur."!mark_push"(0, rx249_pos, $I10)
  rxscan252_done:
.annotate 'line', 166
  # rx pass
    rx249_cur."!cursor_pass"(rx249_pos, "newpad")
    if_null rx249_debug, debug_511
    rx249_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx249_pos)
  debug_511:
    .return (rx249_cur)
  rx249_restart:
.annotate 'line', 4
    if_null rx249_debug, debug_512
    rx249_cur."!cursor_debug"("NEXT", "newpad")
  debug_512:
  rx249_fail:
    (rx249_rep, rx249_pos, $I10, $P10) = rx249_cur."!mark_fail"(0)
    lt rx249_pos, -1, rx249_done
    eq rx249_pos, -1, rx249_fail
    jump $I10
  rx249_done:
    rx249_cur."!cursor_fail"()
    if_null rx249_debug, debug_513
    rx249_cur."!cursor_debug"("FAIL", "newpad")
  debug_513:
    .return (rx249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1299465717.405") :method
.annotate 'line', 4
    new $P251, "ResizablePMCArray"
    push $P251, ""
    .return ($P251)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx254_tgt
    .local int rx254_pos
    .local int rx254_off
    .local int rx254_eos
    .local int rx254_rep
    .local pmc rx254_cur
    .local pmc rx254_debug
    (rx254_cur, rx254_pos, rx254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx254_cur
    .local pmc match
    .lex "$/", match
    length rx254_eos, rx254_tgt
    gt rx254_pos, rx254_eos, rx254_done
    set rx254_off, 0
    lt rx254_pos, 2, rx254_start
    sub rx254_off, rx254_pos, 1
    substr rx254_tgt, rx254_tgt, rx254_off
  rx254_start:
    eq $I10, 1, rx254_restart
    if_null rx254_debug, debug_514
    rx254_cur."!cursor_debug"("START", "outerctx")
  debug_514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan257_done
    goto rxscan257_scan
  rxscan257_loop:
    (rx254_pos) = rx254_cur."from"()
    inc rx254_pos
    rx254_cur."!cursor_from"(rx254_pos)
    ge rx254_pos, rx254_eos, rxscan257_done
  rxscan257_scan:
    set_addr $I10, rxscan257_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  rxscan257_done:
.annotate 'line', 167
  # rx pass
    rx254_cur."!cursor_pass"(rx254_pos, "outerctx")
    if_null rx254_debug, debug_515
    rx254_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx254_pos)
  debug_515:
    .return (rx254_cur)
  rx254_restart:
.annotate 'line', 4
    if_null rx254_debug, debug_516
    rx254_cur."!cursor_debug"("NEXT", "outerctx")
  debug_516:
  rx254_fail:
    (rx254_rep, rx254_pos, $I10, $P10) = rx254_cur."!mark_fail"(0)
    lt rx254_pos, -1, rx254_done
    eq rx254_pos, -1, rx254_fail
    jump $I10
  rx254_done:
    rx254_cur."!cursor_fail"()
    if_null rx254_debug, debug_517
    rx254_cur."!cursor_debug"("FAIL", "outerctx")
  debug_517:
    .return (rx254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1299465717.405") :method
.annotate 'line', 4
    new $P256, "ResizablePMCArray"
    push $P256, ""
    .return ($P256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx259_tgt
    .local int rx259_pos
    .local int rx259_off
    .local int rx259_eos
    .local int rx259_rep
    .local pmc rx259_cur
    .local pmc rx259_debug
    (rx259_cur, rx259_pos, rx259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx259_cur
    .local pmc match
    .lex "$/", match
    length rx259_eos, rx259_tgt
    gt rx259_pos, rx259_eos, rx259_done
    set rx259_off, 0
    lt rx259_pos, 2, rx259_start
    sub rx259_off, rx259_pos, 1
    substr rx259_tgt, rx259_tgt, rx259_off
  rx259_start:
    eq $I10, 1, rx259_restart
    if_null rx259_debug, debug_518
    rx259_cur."!cursor_debug"("START", "finishpad")
  debug_518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan262_done
    goto rxscan262_scan
  rxscan262_loop:
    (rx259_pos) = rx259_cur."from"()
    inc rx259_pos
    rx259_cur."!cursor_from"(rx259_pos)
    ge rx259_pos, rx259_eos, rxscan262_done
  rxscan262_scan:
    set_addr $I10, rxscan262_loop
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
  rxscan262_done:
.annotate 'line', 168
  # rx pass
    rx259_cur."!cursor_pass"(rx259_pos, "finishpad")
    if_null rx259_debug, debug_519
    rx259_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx259_pos)
  debug_519:
    .return (rx259_cur)
  rx259_restart:
.annotate 'line', 4
    if_null rx259_debug, debug_520
    rx259_cur."!cursor_debug"("NEXT", "finishpad")
  debug_520:
  rx259_fail:
    (rx259_rep, rx259_pos, $I10, $P10) = rx259_cur."!mark_fail"(0)
    lt rx259_pos, -1, rx259_done
    eq rx259_pos, -1, rx259_fail
    jump $I10
  rx259_done:
    rx259_cur."!cursor_fail"()
    if_null rx259_debug, debug_521
    rx259_cur."!cursor_debug"("FAIL", "finishpad")
  debug_521:
    .return (rx259_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1299465717.405") :method
.annotate 'line', 4
    new $P261, "ResizablePMCArray"
    push $P261, ""
    .return ($P261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("54_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx264_tgt
    .local int rx264_pos
    .local int rx264_off
    .local int rx264_eos
    .local int rx264_rep
    .local pmc rx264_cur
    .local pmc rx264_debug
    (rx264_cur, rx264_pos, rx264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx264_cur
    .local pmc match
    .lex "$/", match
    length rx264_eos, rx264_tgt
    gt rx264_pos, rx264_eos, rx264_done
    set rx264_off, 0
    lt rx264_pos, 2, rx264_start
    sub rx264_off, rx264_pos, 1
    substr rx264_tgt, rx264_tgt, rx264_off
  rx264_start:
    eq $I10, 1, rx264_restart
    if_null rx264_debug, debug_522
    rx264_cur."!cursor_debug"("START", "you_are_here")
  debug_522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan267_done
    goto rxscan267_scan
  rxscan267_loop:
    (rx264_pos) = rx264_cur."from"()
    inc rx264_pos
    rx264_cur."!cursor_from"(rx264_pos)
    ge rx264_pos, rx264_eos, rxscan267_done
  rxscan267_scan:
    set_addr $I10, rxscan267_loop
    rx264_cur."!mark_push"(0, rx264_pos, $I10)
  rxscan267_done:
.annotate 'line', 169
  # rx pass
    rx264_cur."!cursor_pass"(rx264_pos, "you_are_here")
    if_null rx264_debug, debug_523
    rx264_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx264_pos)
  debug_523:
    .return (rx264_cur)
  rx264_restart:
.annotate 'line', 4
    if_null rx264_debug, debug_524
    rx264_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_524:
  rx264_fail:
    (rx264_rep, rx264_pos, $I10, $P10) = rx264_cur."!mark_fail"(0)
    lt rx264_pos, -1, rx264_done
    eq rx264_pos, -1, rx264_fail
    jump $I10
  rx264_done:
    rx264_cur."!cursor_fail"()
    if_null rx264_debug, debug_525
    rx264_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_525:
    .return (rx264_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("55_1299465717.405") :method
.annotate 'line', 4
    new $P266, "ResizablePMCArray"
    push $P266, ""
    .return ($P266)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("56_1299465717.405")
    .param pmc param_269
.annotate 'line', 171
    .lex "self", param_269
    $P270 = param_269."!protoregex"("terminator")
    .return ($P270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("57_1299465717.405")
    .param pmc param_272
.annotate 'line', 171
    .lex "self", param_272
    $P273 = param_272."!PREFIX__!protoregex"("terminator")
    .return ($P273)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("58_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx275_tgt
    .local int rx275_pos
    .local int rx275_off
    .local int rx275_eos
    .local int rx275_rep
    .local pmc rx275_cur
    .local pmc rx275_debug
    (rx275_cur, rx275_pos, rx275_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx275_cur
    .local pmc match
    .lex "$/", match
    length rx275_eos, rx275_tgt
    gt rx275_pos, rx275_eos, rx275_done
    set rx275_off, 0
    lt rx275_pos, 2, rx275_start
    sub rx275_off, rx275_pos, 1
    substr rx275_tgt, rx275_tgt, rx275_off
  rx275_start:
    eq $I10, 1, rx275_restart
    if_null rx275_debug, debug_526
    rx275_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan278_done
    goto rxscan278_scan
  rxscan278_loop:
    (rx275_pos) = rx275_cur."from"()
    inc rx275_pos
    rx275_cur."!cursor_from"(rx275_pos)
    ge rx275_pos, rx275_eos, rxscan278_done
  rxscan278_scan:
    set_addr $I10, rxscan278_loop
    rx275_cur."!mark_push"(0, rx275_pos, $I10)
  rxscan278_done:
.annotate 'line', 173
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx275_pos, rx275_off
    substr $S10, rx275_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx275_fail
  # rx pass
    rx275_cur."!cursor_pass"(rx275_pos, "terminator:sym<;>")
    if_null rx275_debug, debug_527
    rx275_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx275_pos)
  debug_527:
    .return (rx275_cur)
  rx275_restart:
.annotate 'line', 4
    if_null rx275_debug, debug_528
    rx275_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_528:
  rx275_fail:
    (rx275_rep, rx275_pos, $I10, $P10) = rx275_cur."!mark_fail"(0)
    lt rx275_pos, -1, rx275_done
    eq rx275_pos, -1, rx275_fail
    jump $I10
  rx275_done:
    rx275_cur."!cursor_fail"()
    if_null rx275_debug, debug_529
    rx275_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_529:
    .return (rx275_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("59_1299465717.405") :method
.annotate 'line', 4
    new $P277, "ResizablePMCArray"
    push $P277, ";"
    .return ($P277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("60_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx280_tgt
    .local int rx280_pos
    .local int rx280_off
    .local int rx280_eos
    .local int rx280_rep
    .local pmc rx280_cur
    .local pmc rx280_debug
    (rx280_cur, rx280_pos, rx280_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx280_cur
    .local pmc match
    .lex "$/", match
    length rx280_eos, rx280_tgt
    gt rx280_pos, rx280_eos, rx280_done
    set rx280_off, 0
    lt rx280_pos, 2, rx280_start
    sub rx280_off, rx280_pos, 1
    substr rx280_tgt, rx280_tgt, rx280_off
  rx280_start:
    eq $I10, 1, rx280_restart
    if_null rx280_debug, debug_530
    rx280_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan283_done
    goto rxscan283_scan
  rxscan283_loop:
    (rx280_pos) = rx280_cur."from"()
    inc rx280_pos
    rx280_cur."!cursor_from"(rx280_pos)
    ge rx280_pos, rx280_eos, rxscan283_done
  rxscan283_scan:
    set_addr $I10, rxscan283_loop
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
  rxscan283_done:
.annotate 'line', 174
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx280_pos, rx280_off
    substr $S10, rx280_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx280_fail
  # rx pass
    rx280_cur."!cursor_pass"(rx280_pos, "terminator:sym<}>")
    if_null rx280_debug, debug_531
    rx280_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx280_pos)
  debug_531:
    .return (rx280_cur)
  rx280_restart:
.annotate 'line', 4
    if_null rx280_debug, debug_532
    rx280_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_532:
  rx280_fail:
    (rx280_rep, rx280_pos, $I10, $P10) = rx280_cur."!mark_fail"(0)
    lt rx280_pos, -1, rx280_done
    eq rx280_pos, -1, rx280_fail
    jump $I10
  rx280_done:
    rx280_cur."!cursor_fail"()
    if_null rx280_debug, debug_533
    rx280_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_533:
    .return (rx280_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("61_1299465717.405") :method
.annotate 'line', 4
    new $P282, "ResizablePMCArray"
    push $P282, "}"
    .return ($P282)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("62_1299465717.405")
    .param pmc param_285
.annotate 'line', 178
    .lex "self", param_285
    $P286 = param_285."!protoregex"("statement_control")
    .return ($P286)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("63_1299465717.405")
    .param pmc param_288
.annotate 'line', 178
    .lex "self", param_288
    $P289 = param_288."!PREFIX__!protoregex"("statement_control")
    .return ($P289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("64_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx291_tgt
    .local int rx291_pos
    .local int rx291_off
    .local int rx291_eos
    .local int rx291_rep
    .local pmc rx291_cur
    .local pmc rx291_debug
    (rx291_cur, rx291_pos, rx291_tgt, $I10) = self."!cursor_start"()
    rx291_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx291_cur
    .local pmc match
    .lex "$/", match
    length rx291_eos, rx291_tgt
    gt rx291_pos, rx291_eos, rx291_done
    set rx291_off, 0
    lt rx291_pos, 2, rx291_start
    sub rx291_off, rx291_pos, 1
    substr rx291_tgt, rx291_tgt, rx291_off
  rx291_start:
    eq $I10, 1, rx291_restart
    if_null rx291_debug, debug_534
    rx291_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan294_done
    goto rxscan294_scan
  rxscan294_loop:
    (rx291_pos) = rx291_cur."from"()
    inc rx291_pos
    rx291_cur."!cursor_from"(rx291_pos)
    ge rx291_pos, rx291_eos, rxscan294_done
  rxscan294_scan:
    set_addr $I10, rxscan294_loop
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  rxscan294_done:
.annotate 'line', 181
  # rx subcapture "sym"
    set_addr $I10, rxcap_295_fail
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  # rx literal  "if"
    add $I11, rx291_pos, 2
    gt $I11, rx291_eos, rx291_fail
    sub $I11, rx291_pos, rx291_off
    substr $S10, rx291_tgt, $I11, 2
    ne $S10, "if", rx291_fail
    add rx291_pos, 2
    set_addr $I10, rxcap_295_fail
    ($I12, $I11) = rx291_cur."!mark_peek"($I10)
    rx291_cur."!cursor_pos"($I11)
    ($P10) = rx291_cur."!cursor_start"()
    $P10."!cursor_pass"(rx291_pos, "")
    rx291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_295_done
  rxcap_295_fail:
    goto rx291_fail
  rxcap_295_done:
  # rx charclass s
    ge rx291_pos, rx291_eos, rx291_fail
    sub $I10, rx291_pos, rx291_off
    is_cclass $I11, 32, rx291_tgt, $I10
    unless $I11, rx291_fail
    inc rx291_pos
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
.annotate 'line', 182
  # rx subrule "xblock" subtype=capture negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."xblock"()
    unless $P10, rx291_fail
    rx291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx291_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
.annotate 'line', 183
  # rx rxquantr298 ** 0..*
    set_addr $I10, rxquantr298_done
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  rxquantr298_loop:
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx291_pos, 5
    gt $I11, rx291_eos, rx291_fail
    sub $I11, rx291_pos, rx291_off
    substr $S10, rx291_tgt, $I11, 5
    ne $S10, "elsif", rx291_fail
    add rx291_pos, 5
  # rx charclass s
    ge rx291_pos, rx291_eos, rx291_fail
    sub $I10, rx291_pos, rx291_off
    is_cclass $I11, 32, rx291_tgt, $I10
    unless $I11, rx291_fail
    inc rx291_pos
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."xblock"()
    unless $P10, rx291_fail
    rx291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx291_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
    set_addr $I10, rxquantr298_done
    (rx291_rep) = rx291_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr298_done
    rx291_cur."!mark_push"(rx291_rep, rx291_pos, $I10)
    goto rxquantr298_loop
  rxquantr298_done:
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
.annotate 'line', 184
  # rx rxquantr303 ** 0..1
    set_addr $I10, rxquantr303_done
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  rxquantr303_loop:
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx291_pos, 4
    gt $I11, rx291_eos, rx291_fail
    sub $I11, rx291_pos, rx291_off
    substr $S10, rx291_tgt, $I11, 4
    ne $S10, "else", rx291_fail
    add rx291_pos, 4
  # rx charclass s
    ge rx291_pos, rx291_eos, rx291_fail
    sub $I10, rx291_pos, rx291_off
    is_cclass $I11, 32, rx291_tgt, $I10
    unless $I11, rx291_fail
    inc rx291_pos
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."pblock"()
    unless $P10, rx291_fail
    rx291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx291_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
    set_addr $I10, rxquantr303_done
    (rx291_rep) = rx291_cur."!mark_commit"($I10)
  rxquantr303_done:
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
.annotate 'line', 180
  # rx pass
    rx291_cur."!cursor_pass"(rx291_pos, "statement_control:sym<if>")
    if_null rx291_debug, debug_535
    rx291_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx291_pos)
  debug_535:
    .return (rx291_cur)
  rx291_restart:
.annotate 'line', 4
    if_null rx291_debug, debug_536
    rx291_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_536:
  rx291_fail:
    (rx291_rep, rx291_pos, $I10, $P10) = rx291_cur."!mark_fail"(0)
    lt rx291_pos, -1, rx291_done
    eq rx291_pos, -1, rx291_fail
    jump $I10
  rx291_done:
    rx291_cur."!cursor_fail"()
    if_null rx291_debug, debug_537
    rx291_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_537:
    .return (rx291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("65_1299465717.405") :method
.annotate 'line', 4
    new $P293, "ResizablePMCArray"
    push $P293, "if"
    .return ($P293)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("66_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P319 = "68_1299465717.405" 
    capture_lex $P319
    .local string rx309_tgt
    .local int rx309_pos
    .local int rx309_off
    .local int rx309_eos
    .local int rx309_rep
    .local pmc rx309_cur
    .local pmc rx309_debug
    (rx309_cur, rx309_pos, rx309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx309_cur
    .local pmc match
    .lex "$/", match
    length rx309_eos, rx309_tgt
    gt rx309_pos, rx309_eos, rx309_done
    set rx309_off, 0
    lt rx309_pos, 2, rx309_start
    sub rx309_off, rx309_pos, 1
    substr rx309_tgt, rx309_tgt, rx309_off
  rx309_start:
    eq $I10, 1, rx309_restart
    if_null rx309_debug, debug_538
    rx309_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan312_done
    goto rxscan312_scan
  rxscan312_loop:
    (rx309_pos) = rx309_cur."from"()
    inc rx309_pos
    rx309_cur."!cursor_from"(rx309_pos)
    ge rx309_pos, rx309_eos, rxscan312_done
  rxscan312_scan:
    set_addr $I10, rxscan312_loop
    rx309_cur."!mark_push"(0, rx309_pos, $I10)
  rxscan312_done:
.annotate 'line', 188
  # rx subcapture "sym"
    set_addr $I10, rxcap_313_fail
    rx309_cur."!mark_push"(0, rx309_pos, $I10)
  # rx literal  "unless"
    add $I11, rx309_pos, 6
    gt $I11, rx309_eos, rx309_fail
    sub $I11, rx309_pos, rx309_off
    substr $S10, rx309_tgt, $I11, 6
    ne $S10, "unless", rx309_fail
    add rx309_pos, 6
    set_addr $I10, rxcap_313_fail
    ($I12, $I11) = rx309_cur."!mark_peek"($I10)
    rx309_cur."!cursor_pos"($I11)
    ($P10) = rx309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx309_pos, "")
    rx309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_313_done
  rxcap_313_fail:
    goto rx309_fail
  rxcap_313_done:
  # rx charclass s
    ge rx309_pos, rx309_eos, rx309_fail
    sub $I10, rx309_pos, rx309_off
    is_cclass $I11, 32, rx309_tgt, $I10
    unless $I11, rx309_fail
    inc rx309_pos
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
.annotate 'line', 189
  # rx subrule "xblock" subtype=capture negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."xblock"()
    unless $P10, rx309_fail
    rx309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx309_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
  alt316_0:
.annotate 'line', 190
    set_addr $I10, alt316_1
    rx309_cur."!mark_push"(0, rx309_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx309_cur."!cursor_pos"(rx309_pos)
    .const 'Sub' $P319 = "68_1299465717.405" 
    capture_lex $P319
    $P10 = rx309_cur."before"($P319)
    if $P10, rx309_fail
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
    goto alt316_end
  alt316_1:
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
  alt316_end:
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
.annotate 'line', 187
  # rx pass
    rx309_cur."!cursor_pass"(rx309_pos, "statement_control:sym<unless>")
    if_null rx309_debug, debug_543
    rx309_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx309_pos)
  debug_543:
    .return (rx309_cur)
  rx309_restart:
.annotate 'line', 4
    if_null rx309_debug, debug_544
    rx309_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_544:
  rx309_fail:
    (rx309_rep, rx309_pos, $I10, $P10) = rx309_cur."!mark_fail"(0)
    lt rx309_pos, -1, rx309_done
    eq rx309_pos, -1, rx309_fail
    jump $I10
  rx309_done:
    rx309_cur."!cursor_fail"()
    if_null rx309_debug, debug_545
    rx309_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_545:
    .return (rx309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("67_1299465717.405") :method
.annotate 'line', 4
    new $P311, "ResizablePMCArray"
    push $P311, "unless"
    .return ($P311)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block318"  :anon :subid("68_1299465717.405") :method :outer("66_1299465717.405")
.annotate 'line', 190
    .local string rx320_tgt
    .local int rx320_pos
    .local int rx320_off
    .local int rx320_eos
    .local int rx320_rep
    .local pmc rx320_cur
    .local pmc rx320_debug
    (rx320_cur, rx320_pos, rx320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx320_cur
    .local pmc match
    .lex "$/", match
    length rx320_eos, rx320_tgt
    gt rx320_pos, rx320_eos, rx320_done
    set rx320_off, 0
    lt rx320_pos, 2, rx320_start
    sub rx320_off, rx320_pos, 1
    substr rx320_tgt, rx320_tgt, rx320_off
  rx320_start:
    eq $I10, 1, rx320_restart
    if_null rx320_debug, debug_539
    rx320_cur."!cursor_debug"("START", "")
  debug_539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan321_done
    goto rxscan321_scan
  rxscan321_loop:
    (rx320_pos) = rx320_cur."from"()
    inc rx320_pos
    rx320_cur."!cursor_from"(rx320_pos)
    ge rx320_pos, rx320_eos, rxscan321_done
  rxscan321_scan:
    set_addr $I10, rxscan321_loop
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxscan321_done:
  # rx literal  "else"
    add $I11, rx320_pos, 4
    gt $I11, rx320_eos, rx320_fail
    sub $I11, rx320_pos, rx320_off
    substr $S10, rx320_tgt, $I11, 4
    ne $S10, "else", rx320_fail
    add rx320_pos, 4
  # rx pass
    rx320_cur."!cursor_pass"(rx320_pos, "")
    if_null rx320_debug, debug_540
    rx320_cur."!cursor_debug"("PASS", "", " at pos=", rx320_pos)
  debug_540:
    .return (rx320_cur)
  rx320_restart:
    if_null rx320_debug, debug_541
    rx320_cur."!cursor_debug"("NEXT", "")
  debug_541:
  rx320_fail:
    (rx320_rep, rx320_pos, $I10, $P10) = rx320_cur."!mark_fail"(0)
    lt rx320_pos, -1, rx320_done
    eq rx320_pos, -1, rx320_fail
    jump $I10
  rx320_done:
    rx320_cur."!cursor_fail"()
    if_null rx320_debug, debug_542
    rx320_cur."!cursor_debug"("FAIL", "")
  debug_542:
    .return (rx320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("69_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx327_tgt
    .local int rx327_pos
    .local int rx327_off
    .local int rx327_eos
    .local int rx327_rep
    .local pmc rx327_cur
    .local pmc rx327_debug
    (rx327_cur, rx327_pos, rx327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx327_cur
    .local pmc match
    .lex "$/", match
    length rx327_eos, rx327_tgt
    gt rx327_pos, rx327_eos, rx327_done
    set rx327_off, 0
    lt rx327_pos, 2, rx327_start
    sub rx327_off, rx327_pos, 1
    substr rx327_tgt, rx327_tgt, rx327_off
  rx327_start:
    eq $I10, 1, rx327_restart
    if_null rx327_debug, debug_546
    rx327_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan330_done
    goto rxscan330_scan
  rxscan330_loop:
    (rx327_pos) = rx327_cur."from"()
    inc rx327_pos
    rx327_cur."!cursor_from"(rx327_pos)
    ge rx327_pos, rx327_eos, rxscan330_done
  rxscan330_scan:
    set_addr $I10, rxscan330_loop
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  rxscan330_done:
.annotate 'line', 194
  # rx subcapture "sym"
    set_addr $I10, rxcap_332_fail
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  alt331_0:
    set_addr $I10, alt331_1
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  # rx literal  "while"
    add $I11, rx327_pos, 5
    gt $I11, rx327_eos, rx327_fail
    sub $I11, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I11, 5
    ne $S10, "while", rx327_fail
    add rx327_pos, 5
    goto alt331_end
  alt331_1:
  # rx literal  "until"
    add $I11, rx327_pos, 5
    gt $I11, rx327_eos, rx327_fail
    sub $I11, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I11, 5
    ne $S10, "until", rx327_fail
    add rx327_pos, 5
  alt331_end:
    set_addr $I10, rxcap_332_fail
    ($I12, $I11) = rx327_cur."!mark_peek"($I10)
    rx327_cur."!cursor_pos"($I11)
    ($P10) = rx327_cur."!cursor_start"()
    $P10."!cursor_pass"(rx327_pos, "")
    rx327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_332_done
  rxcap_332_fail:
    goto rx327_fail
  rxcap_332_done:
  # rx charclass s
    ge rx327_pos, rx327_eos, rx327_fail
    sub $I10, rx327_pos, rx327_off
    is_cclass $I11, 32, rx327_tgt, $I10
    unless $I11, rx327_fail
    inc rx327_pos
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
.annotate 'line', 195
  # rx subrule "xblock" subtype=capture negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."xblock"()
    unless $P10, rx327_fail
    rx327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx327_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
.annotate 'line', 193
  # rx pass
    rx327_cur."!cursor_pass"(rx327_pos, "statement_control:sym<while>")
    if_null rx327_debug, debug_547
    rx327_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx327_pos)
  debug_547:
    .return (rx327_cur)
  rx327_restart:
.annotate 'line', 4
    if_null rx327_debug, debug_548
    rx327_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_548:
  rx327_fail:
    (rx327_rep, rx327_pos, $I10, $P10) = rx327_cur."!mark_fail"(0)
    lt rx327_pos, -1, rx327_done
    eq rx327_pos, -1, rx327_fail
    jump $I10
  rx327_done:
    rx327_cur."!cursor_fail"()
    if_null rx327_debug, debug_549
    rx327_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_549:
    .return (rx327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("70_1299465717.405") :method
.annotate 'line', 4
    new $P329, "ResizablePMCArray"
    push $P329, "until"
    push $P329, "while"
    .return ($P329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("71_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx336_tgt
    .local int rx336_pos
    .local int rx336_off
    .local int rx336_eos
    .local int rx336_rep
    .local pmc rx336_cur
    .local pmc rx336_debug
    (rx336_cur, rx336_pos, rx336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx336_cur
    .local pmc match
    .lex "$/", match
    length rx336_eos, rx336_tgt
    gt rx336_pos, rx336_eos, rx336_done
    set rx336_off, 0
    lt rx336_pos, 2, rx336_start
    sub rx336_off, rx336_pos, 1
    substr rx336_tgt, rx336_tgt, rx336_off
  rx336_start:
    eq $I10, 1, rx336_restart
    if_null rx336_debug, debug_550
    rx336_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan339_done
    goto rxscan339_scan
  rxscan339_loop:
    (rx336_pos) = rx336_cur."from"()
    inc rx336_pos
    rx336_cur."!cursor_from"(rx336_pos)
    ge rx336_pos, rx336_eos, rxscan339_done
  rxscan339_scan:
    set_addr $I10, rxscan339_loop
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  rxscan339_done:
.annotate 'line', 199
  # rx subcapture "sym"
    set_addr $I10, rxcap_340_fail
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx336_pos, 6
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 6
    ne $S10, "repeat", rx336_fail
    add rx336_pos, 6
    set_addr $I10, rxcap_340_fail
    ($I12, $I11) = rx336_cur."!mark_peek"($I10)
    rx336_cur."!cursor_pos"($I11)
    ($P10) = rx336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx336_pos, "")
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_340_done
  rxcap_340_fail:
    goto rx336_fail
  rxcap_340_done:
  # rx charclass s
    ge rx336_pos, rx336_eos, rx336_fail
    sub $I10, rx336_pos, rx336_off
    is_cclass $I11, 32, rx336_tgt, $I10
    unless $I11, rx336_fail
    inc rx336_pos
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt342_0:
.annotate 'line', 200
    set_addr $I10, alt342_1
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
.annotate 'line', 201
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_345_fail
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  alt344_0:
    set_addr $I10, alt344_1
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx literal  "while"
    add $I11, rx336_pos, 5
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 5
    ne $S10, "while", rx336_fail
    add rx336_pos, 5
    goto alt344_end
  alt344_1:
  # rx literal  "until"
    add $I11, rx336_pos, 5
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 5
    ne $S10, "until", rx336_fail
    add rx336_pos, 5
  alt344_end:
    set_addr $I10, rxcap_345_fail
    ($I12, $I11) = rx336_cur."!mark_peek"($I10)
    rx336_cur."!cursor_pos"($I11)
    ($P10) = rx336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx336_pos, "")
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_345_done
  rxcap_345_fail:
    goto rx336_fail
  rxcap_345_done:
  # rx charclass s
    ge rx336_pos, rx336_eos, rx336_fail
    sub $I10, rx336_pos, rx336_off
    is_cclass $I11, 32, rx336_tgt, $I10
    unless $I11, rx336_fail
    inc rx336_pos
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."xblock"()
    unless $P10, rx336_fail
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
    goto alt342_end
  alt342_1:
.annotate 'line', 202
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."pblock"()
    unless $P10, rx336_fail
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_351_fail
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  alt350_0:
    set_addr $I10, alt350_1
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx literal  "while"
    add $I11, rx336_pos, 5
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 5
    ne $S10, "while", rx336_fail
    add rx336_pos, 5
    goto alt350_end
  alt350_1:
  # rx literal  "until"
    add $I11, rx336_pos, 5
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 5
    ne $S10, "until", rx336_fail
    add rx336_pos, 5
  alt350_end:
    set_addr $I10, rxcap_351_fail
    ($I12, $I11) = rx336_cur."!mark_peek"($I10)
    rx336_cur."!cursor_pos"($I11)
    ($P10) = rx336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx336_pos, "")
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_351_done
  rxcap_351_fail:
    goto rx336_fail
  rxcap_351_done:
  # rx charclass s
    ge rx336_pos, rx336_eos, rx336_fail
    sub $I10, rx336_pos, rx336_off
    is_cclass $I11, 32, rx336_tgt, $I10
    unless $I11, rx336_fail
    inc rx336_pos
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."EXPR"()
    unless $P10, rx336_fail
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt342_end:
.annotate 'line', 203
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
.annotate 'line', 198
  # rx pass
    rx336_cur."!cursor_pass"(rx336_pos, "statement_control:sym<repeat>")
    if_null rx336_debug, debug_551
    rx336_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx336_pos)
  debug_551:
    .return (rx336_cur)
  rx336_restart:
.annotate 'line', 4
    if_null rx336_debug, debug_552
    rx336_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_552:
  rx336_fail:
    (rx336_rep, rx336_pos, $I10, $P10) = rx336_cur."!mark_fail"(0)
    lt rx336_pos, -1, rx336_done
    eq rx336_pos, -1, rx336_fail
    jump $I10
  rx336_done:
    rx336_cur."!cursor_fail"()
    if_null rx336_debug, debug_553
    rx336_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_553:
    .return (rx336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("72_1299465717.405") :method
.annotate 'line', 4
    new $P338, "ResizablePMCArray"
    push $P338, "repeat"
    .return ($P338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("73_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx356_tgt
    .local int rx356_pos
    .local int rx356_off
    .local int rx356_eos
    .local int rx356_rep
    .local pmc rx356_cur
    .local pmc rx356_debug
    (rx356_cur, rx356_pos, rx356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx356_cur
    .local pmc match
    .lex "$/", match
    length rx356_eos, rx356_tgt
    gt rx356_pos, rx356_eos, rx356_done
    set rx356_off, 0
    lt rx356_pos, 2, rx356_start
    sub rx356_off, rx356_pos, 1
    substr rx356_tgt, rx356_tgt, rx356_off
  rx356_start:
    eq $I10, 1, rx356_restart
    if_null rx356_debug, debug_554
    rx356_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan359_done
    goto rxscan359_scan
  rxscan359_loop:
    (rx356_pos) = rx356_cur."from"()
    inc rx356_pos
    rx356_cur."!cursor_from"(rx356_pos)
    ge rx356_pos, rx356_eos, rxscan359_done
  rxscan359_scan:
    set_addr $I10, rxscan359_loop
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  rxscan359_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_360_fail
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  # rx literal  "for"
    add $I11, rx356_pos, 3
    gt $I11, rx356_eos, rx356_fail
    sub $I11, rx356_pos, rx356_off
    substr $S10, rx356_tgt, $I11, 3
    ne $S10, "for", rx356_fail
    add rx356_pos, 3
    set_addr $I10, rxcap_360_fail
    ($I12, $I11) = rx356_cur."!mark_peek"($I10)
    rx356_cur."!cursor_pos"($I11)
    ($P10) = rx356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx356_pos, "")
    rx356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_360_done
  rxcap_360_fail:
    goto rx356_fail
  rxcap_360_done:
  # rx charclass s
    ge rx356_pos, rx356_eos, rx356_fail
    sub $I10, rx356_pos, rx356_off
    is_cclass $I11, 32, rx356_tgt, $I10
    unless $I11, rx356_fail
    inc rx356_pos
  # rx subrule "ws" subtype=method negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."ws"()
    unless $P10, rx356_fail
    rx356_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "xblock" subtype=capture negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."xblock"()
    unless $P10, rx356_fail
    rx356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx356_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."ws"()
    unless $P10, rx356_fail
    rx356_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx356_cur."!cursor_pass"(rx356_pos, "statement_control:sym<for>")
    if_null rx356_debug, debug_555
    rx356_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx356_pos)
  debug_555:
    .return (rx356_cur)
  rx356_restart:
.annotate 'line', 4
    if_null rx356_debug, debug_556
    rx356_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_556:
  rx356_fail:
    (rx356_rep, rx356_pos, $I10, $P10) = rx356_cur."!mark_fail"(0)
    lt rx356_pos, -1, rx356_done
    eq rx356_pos, -1, rx356_fail
    jump $I10
  rx356_done:
    rx356_cur."!cursor_fail"()
    if_null rx356_debug, debug_557
    rx356_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_557:
    .return (rx356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("74_1299465717.405") :method
.annotate 'line', 4
    new $P358, "ResizablePMCArray"
    push $P358, "for"
    .return ($P358)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("75_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx364_tgt
    .local int rx364_pos
    .local int rx364_off
    .local int rx364_eos
    .local int rx364_rep
    .local pmc rx364_cur
    .local pmc rx364_debug
    (rx364_cur, rx364_pos, rx364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx364_cur
    .local pmc match
    .lex "$/", match
    length rx364_eos, rx364_tgt
    gt rx364_pos, rx364_eos, rx364_done
    set rx364_off, 0
    lt rx364_pos, 2, rx364_start
    sub rx364_off, rx364_pos, 1
    substr rx364_tgt, rx364_tgt, rx364_off
  rx364_start:
    eq $I10, 1, rx364_restart
    if_null rx364_debug, debug_558
    rx364_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan367_done
    goto rxscan367_scan
  rxscan367_loop:
    (rx364_pos) = rx364_cur."from"()
    inc rx364_pos
    rx364_cur."!cursor_from"(rx364_pos)
    ge rx364_pos, rx364_eos, rxscan367_done
  rxscan367_scan:
    set_addr $I10, rxscan367_loop
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  rxscan367_done:
.annotate 'line', 212
  # rx subcapture "sym"
    set_addr $I10, rxcap_368_fail
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx364_pos, 5
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    substr $S10, rx364_tgt, $I11, 5
    ne $S10, "CATCH", rx364_fail
    add rx364_pos, 5
    set_addr $I10, rxcap_368_fail
    ($I12, $I11) = rx364_cur."!mark_peek"($I10)
    rx364_cur."!cursor_pos"($I11)
    ($P10) = rx364_cur."!cursor_start"()
    $P10."!cursor_pass"(rx364_pos, "")
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_368_done
  rxcap_368_fail:
    goto rx364_fail
  rxcap_368_done:
  # rx charclass s
    ge rx364_pos, rx364_eos, rx364_fail
    sub $I10, rx364_pos, rx364_off
    is_cclass $I11, 32, rx364_tgt, $I10
    unless $I11, rx364_fail
    inc rx364_pos
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 213
  # rx subrule "block" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."block"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx364_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 211
  # rx pass
    rx364_cur."!cursor_pass"(rx364_pos, "statement_control:sym<CATCH>")
    if_null rx364_debug, debug_559
    rx364_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx364_pos)
  debug_559:
    .return (rx364_cur)
  rx364_restart:
.annotate 'line', 4
    if_null rx364_debug, debug_560
    rx364_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_560:
  rx364_fail:
    (rx364_rep, rx364_pos, $I10, $P10) = rx364_cur."!mark_fail"(0)
    lt rx364_pos, -1, rx364_done
    eq rx364_pos, -1, rx364_fail
    jump $I10
  rx364_done:
    rx364_cur."!cursor_fail"()
    if_null rx364_debug, debug_561
    rx364_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_561:
    .return (rx364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("76_1299465717.405") :method
.annotate 'line', 4
    new $P366, "ResizablePMCArray"
    push $P366, "CATCH"
    .return ($P366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("77_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx372_tgt
    .local int rx372_pos
    .local int rx372_off
    .local int rx372_eos
    .local int rx372_rep
    .local pmc rx372_cur
    .local pmc rx372_debug
    (rx372_cur, rx372_pos, rx372_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx372_cur
    .local pmc match
    .lex "$/", match
    length rx372_eos, rx372_tgt
    gt rx372_pos, rx372_eos, rx372_done
    set rx372_off, 0
    lt rx372_pos, 2, rx372_start
    sub rx372_off, rx372_pos, 1
    substr rx372_tgt, rx372_tgt, rx372_off
  rx372_start:
    eq $I10, 1, rx372_restart
    if_null rx372_debug, debug_562
    rx372_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan375_done
    goto rxscan375_scan
  rxscan375_loop:
    (rx372_pos) = rx372_cur."from"()
    inc rx372_pos
    rx372_cur."!cursor_from"(rx372_pos)
    ge rx372_pos, rx372_eos, rxscan375_done
  rxscan375_scan:
    set_addr $I10, rxscan375_loop
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  rxscan375_done:
.annotate 'line', 217
  # rx subcapture "sym"
    set_addr $I10, rxcap_376_fail
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx372_pos, 7
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 7
    ne $S10, "CONTROL", rx372_fail
    add rx372_pos, 7
    set_addr $I10, rxcap_376_fail
    ($I12, $I11) = rx372_cur."!mark_peek"($I10)
    rx372_cur."!cursor_pos"($I11)
    ($P10) = rx372_cur."!cursor_start"()
    $P10."!cursor_pass"(rx372_pos, "")
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_376_done
  rxcap_376_fail:
    goto rx372_fail
  rxcap_376_done:
  # rx charclass s
    ge rx372_pos, rx372_eos, rx372_fail
    sub $I10, rx372_pos, rx372_off
    is_cclass $I11, 32, rx372_tgt, $I10
    unless $I11, rx372_fail
    inc rx372_pos
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
.annotate 'line', 218
  # rx subrule "block" subtype=capture negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."block"()
    unless $P10, rx372_fail
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx372_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
.annotate 'line', 216
  # rx pass
    rx372_cur."!cursor_pass"(rx372_pos, "statement_control:sym<CONTROL>")
    if_null rx372_debug, debug_563
    rx372_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx372_pos)
  debug_563:
    .return (rx372_cur)
  rx372_restart:
.annotate 'line', 4
    if_null rx372_debug, debug_564
    rx372_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_564:
  rx372_fail:
    (rx372_rep, rx372_pos, $I10, $P10) = rx372_cur."!mark_fail"(0)
    lt rx372_pos, -1, rx372_done
    eq rx372_pos, -1, rx372_fail
    jump $I10
  rx372_done:
    rx372_cur."!cursor_fail"()
    if_null rx372_debug, debug_565
    rx372_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_565:
    .return (rx372_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("78_1299465717.405") :method
.annotate 'line', 4
    new $P374, "ResizablePMCArray"
    push $P374, "CONTROL"
    .return ($P374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("79_1299465717.405")
    .param pmc param_380
.annotate 'line', 221
    .lex "self", param_380
    $P381 = param_380."!protoregex"("statement_prefix")
    .return ($P381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("80_1299465717.405")
    .param pmc param_383
.annotate 'line', 221
    .lex "self", param_383
    $P384 = param_383."!PREFIX__!protoregex"("statement_prefix")
    .return ($P384)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("81_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx386_tgt
    .local int rx386_pos
    .local int rx386_off
    .local int rx386_eos
    .local int rx386_rep
    .local pmc rx386_cur
    .local pmc rx386_debug
    (rx386_cur, rx386_pos, rx386_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx386_cur
    .local pmc match
    .lex "$/", match
    length rx386_eos, rx386_tgt
    gt rx386_pos, rx386_eos, rx386_done
    set rx386_off, 0
    lt rx386_pos, 2, rx386_start
    sub rx386_off, rx386_pos, 1
    substr rx386_tgt, rx386_tgt, rx386_off
  rx386_start:
    eq $I10, 1, rx386_restart
    if_null rx386_debug, debug_566
    rx386_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan390_done
    goto rxscan390_scan
  rxscan390_loop:
    (rx386_pos) = rx386_cur."from"()
    inc rx386_pos
    rx386_cur."!cursor_from"(rx386_pos)
    ge rx386_pos, rx386_eos, rxscan390_done
  rxscan390_scan:
    set_addr $I10, rxscan390_loop
    rx386_cur."!mark_push"(0, rx386_pos, $I10)
  rxscan390_done:
.annotate 'line', 222
  # rx subcapture "sym"
    set_addr $I10, rxcap_391_fail
    rx386_cur."!mark_push"(0, rx386_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx386_pos, 4
    gt $I11, rx386_eos, rx386_fail
    sub $I11, rx386_pos, rx386_off
    substr $S10, rx386_tgt, $I11, 4
    ne $S10, "INIT", rx386_fail
    add rx386_pos, 4
    set_addr $I10, rxcap_391_fail
    ($I12, $I11) = rx386_cur."!mark_peek"($I10)
    rx386_cur."!cursor_pos"($I11)
    ($P10) = rx386_cur."!cursor_start"()
    $P10."!cursor_pass"(rx386_pos, "")
    rx386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_391_done
  rxcap_391_fail:
    goto rx386_fail
  rxcap_391_done:
  # rx subrule "blorst" subtype=capture negate=
    rx386_cur."!cursor_pos"(rx386_pos)
    $P10 = rx386_cur."blorst"()
    unless $P10, rx386_fail
    rx386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx386_pos = $P10."pos"()
  # rx pass
    rx386_cur."!cursor_pass"(rx386_pos, "statement_prefix:sym<INIT>")
    if_null rx386_debug, debug_567
    rx386_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx386_pos)
  debug_567:
    .return (rx386_cur)
  rx386_restart:
.annotate 'line', 4
    if_null rx386_debug, debug_568
    rx386_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_568:
  rx386_fail:
    (rx386_rep, rx386_pos, $I10, $P10) = rx386_cur."!mark_fail"(0)
    lt rx386_pos, -1, rx386_done
    eq rx386_pos, -1, rx386_fail
    jump $I10
  rx386_done:
    rx386_cur."!cursor_fail"()
    if_null rx386_debug, debug_569
    rx386_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_569:
    .return (rx386_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("82_1299465717.405") :method
.annotate 'line', 4
    $P388 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P389, "ResizablePMCArray"
    push $P389, $P388
    .return ($P389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("83_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx393_tgt
    .local int rx393_pos
    .local int rx393_off
    .local int rx393_eos
    .local int rx393_rep
    .local pmc rx393_cur
    .local pmc rx393_debug
    (rx393_cur, rx393_pos, rx393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx393_cur
    .local pmc match
    .lex "$/", match
    length rx393_eos, rx393_tgt
    gt rx393_pos, rx393_eos, rx393_done
    set rx393_off, 0
    lt rx393_pos, 2, rx393_start
    sub rx393_off, rx393_pos, 1
    substr rx393_tgt, rx393_tgt, rx393_off
  rx393_start:
    eq $I10, 1, rx393_restart
    if_null rx393_debug, debug_570
    rx393_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan397_done
    goto rxscan397_scan
  rxscan397_loop:
    (rx393_pos) = rx393_cur."from"()
    inc rx393_pos
    rx393_cur."!cursor_from"(rx393_pos)
    ge rx393_pos, rx393_eos, rxscan397_done
  rxscan397_scan:
    set_addr $I10, rxscan397_loop
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  rxscan397_done:
.annotate 'line', 225
  # rx subcapture "sym"
    set_addr $I10, rxcap_398_fail
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  # rx literal  "try"
    add $I11, rx393_pos, 3
    gt $I11, rx393_eos, rx393_fail
    sub $I11, rx393_pos, rx393_off
    substr $S10, rx393_tgt, $I11, 3
    ne $S10, "try", rx393_fail
    add rx393_pos, 3
    set_addr $I10, rxcap_398_fail
    ($I12, $I11) = rx393_cur."!mark_peek"($I10)
    rx393_cur."!cursor_pos"($I11)
    ($P10) = rx393_cur."!cursor_start"()
    $P10."!cursor_pass"(rx393_pos, "")
    rx393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_398_done
  rxcap_398_fail:
    goto rx393_fail
  rxcap_398_done:
.annotate 'line', 226
  # rx subrule "blorst" subtype=capture negate=
    rx393_cur."!cursor_pos"(rx393_pos)
    $P10 = rx393_cur."blorst"()
    unless $P10, rx393_fail
    rx393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx393_pos = $P10."pos"()
.annotate 'line', 224
  # rx pass
    rx393_cur."!cursor_pass"(rx393_pos, "statement_prefix:sym<try>")
    if_null rx393_debug, debug_571
    rx393_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx393_pos)
  debug_571:
    .return (rx393_cur)
  rx393_restart:
.annotate 'line', 4
    if_null rx393_debug, debug_572
    rx393_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_572:
  rx393_fail:
    (rx393_rep, rx393_pos, $I10, $P10) = rx393_cur."!mark_fail"(0)
    lt rx393_pos, -1, rx393_done
    eq rx393_pos, -1, rx393_fail
    jump $I10
  rx393_done:
    rx393_cur."!cursor_fail"()
    if_null rx393_debug, debug_573
    rx393_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_573:
    .return (rx393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("84_1299465717.405") :method
.annotate 'line', 4
    $P395 = self."!PREFIX__!subrule"("blorst", "try")
    new $P396, "ResizablePMCArray"
    push $P396, $P395
    .return ($P396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("85_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx400_tgt
    .local int rx400_pos
    .local int rx400_off
    .local int rx400_eos
    .local int rx400_rep
    .local pmc rx400_cur
    .local pmc rx400_debug
    (rx400_cur, rx400_pos, rx400_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx400_cur
    .local pmc match
    .lex "$/", match
    length rx400_eos, rx400_tgt
    gt rx400_pos, rx400_eos, rx400_done
    set rx400_off, 0
    lt rx400_pos, 2, rx400_start
    sub rx400_off, rx400_pos, 1
    substr rx400_tgt, rx400_tgt, rx400_off
  rx400_start:
    eq $I10, 1, rx400_restart
    if_null rx400_debug, debug_574
    rx400_cur."!cursor_debug"("START", "blorst")
  debug_574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan403_done
    goto rxscan403_scan
  rxscan403_loop:
    (rx400_pos) = rx400_cur."from"()
    inc rx400_pos
    rx400_cur."!cursor_from"(rx400_pos)
    ge rx400_pos, rx400_eos, rxscan403_done
  rxscan403_scan:
    set_addr $I10, rxscan403_loop
    rx400_cur."!mark_push"(0, rx400_pos, $I10)
  rxscan403_done:
.annotate 'line', 230
  # rx charclass s
    ge rx400_pos, rx400_eos, rx400_fail
    sub $I10, rx400_pos, rx400_off
    is_cclass $I11, 32, rx400_tgt, $I10
    unless $I11, rx400_fail
    inc rx400_pos
  # rx subrule "ws" subtype=method negate=
    rx400_cur."!cursor_pos"(rx400_pos)
    $P10 = rx400_cur."ws"()
    unless $P10, rx400_fail
    rx400_pos = $P10."pos"()
  alt404_0:
    set_addr $I10, alt404_1
    rx400_cur."!mark_push"(0, rx400_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx400_pos, rx400_off
    substr $S10, rx400_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx400_fail
  # rx subrule "block" subtype=capture negate=
    rx400_cur."!cursor_pos"(rx400_pos)
    $P10 = rx400_cur."block"()
    unless $P10, rx400_fail
    rx400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx400_pos = $P10."pos"()
    goto alt404_end
  alt404_1:
  # rx subrule "statement" subtype=capture negate=
    rx400_cur."!cursor_pos"(rx400_pos)
    $P10 = rx400_cur."statement"()
    unless $P10, rx400_fail
    rx400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx400_pos = $P10."pos"()
  alt404_end:
.annotate 'line', 229
  # rx pass
    rx400_cur."!cursor_pass"(rx400_pos, "blorst")
    if_null rx400_debug, debug_575
    rx400_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx400_pos)
  debug_575:
    .return (rx400_cur)
  rx400_restart:
.annotate 'line', 4
    if_null rx400_debug, debug_576
    rx400_cur."!cursor_debug"("NEXT", "blorst")
  debug_576:
  rx400_fail:
    (rx400_rep, rx400_pos, $I10, $P10) = rx400_cur."!mark_fail"(0)
    lt rx400_pos, -1, rx400_done
    eq rx400_pos, -1, rx400_fail
    jump $I10
  rx400_done:
    rx400_cur."!cursor_fail"()
    if_null rx400_debug, debug_577
    rx400_cur."!cursor_debug"("FAIL", "blorst")
  debug_577:
    .return (rx400_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("86_1299465717.405") :method
.annotate 'line', 4
    new $P402, "ResizablePMCArray"
    push $P402, ""
    .return ($P402)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("87_1299465717.405")
    .param pmc param_406
.annotate 'line', 235
    .lex "self", param_406
    $P407 = param_406."!protoregex"("statement_mod_cond")
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("88_1299465717.405")
    .param pmc param_409
.annotate 'line', 235
    .lex "self", param_409
    $P410 = param_409."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P410)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("89_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx412_tgt
    .local int rx412_pos
    .local int rx412_off
    .local int rx412_eos
    .local int rx412_rep
    .local pmc rx412_cur
    .local pmc rx412_debug
    (rx412_cur, rx412_pos, rx412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx412_cur
    .local pmc match
    .lex "$/", match
    length rx412_eos, rx412_tgt
    gt rx412_pos, rx412_eos, rx412_done
    set rx412_off, 0
    lt rx412_pos, 2, rx412_start
    sub rx412_off, rx412_pos, 1
    substr rx412_tgt, rx412_tgt, rx412_off
  rx412_start:
    eq $I10, 1, rx412_restart
    if_null rx412_debug, debug_578
    rx412_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan416_done
    goto rxscan416_scan
  rxscan416_loop:
    (rx412_pos) = rx412_cur."from"()
    inc rx412_pos
    rx412_cur."!cursor_from"(rx412_pos)
    ge rx412_pos, rx412_eos, rxscan416_done
  rxscan416_scan:
    set_addr $I10, rxscan416_loop
    rx412_cur."!mark_push"(0, rx412_pos, $I10)
  rxscan416_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_417_fail
    rx412_cur."!mark_push"(0, rx412_pos, $I10)
  # rx literal  "if"
    add $I11, rx412_pos, 2
    gt $I11, rx412_eos, rx412_fail
    sub $I11, rx412_pos, rx412_off
    substr $S10, rx412_tgt, $I11, 2
    ne $S10, "if", rx412_fail
    add rx412_pos, 2
    set_addr $I10, rxcap_417_fail
    ($I12, $I11) = rx412_cur."!mark_peek"($I10)
    rx412_cur."!cursor_pos"($I11)
    ($P10) = rx412_cur."!cursor_start"()
    $P10."!cursor_pass"(rx412_pos, "")
    rx412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_417_done
  rxcap_417_fail:
    goto rx412_fail
  rxcap_417_done:
  # rx subrule "ws" subtype=method negate=
    rx412_cur."!cursor_pos"(rx412_pos)
    $P10 = rx412_cur."ws"()
    unless $P10, rx412_fail
    rx412_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx412_cur."!cursor_pos"(rx412_pos)
    $P10 = rx412_cur."EXPR"()
    unless $P10, rx412_fail
    rx412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx412_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx412_cur."!cursor_pos"(rx412_pos)
    $P10 = rx412_cur."ws"()
    unless $P10, rx412_fail
    rx412_pos = $P10."pos"()
  # rx pass
    rx412_cur."!cursor_pass"(rx412_pos, "statement_mod_cond:sym<if>")
    if_null rx412_debug, debug_579
    rx412_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx412_pos)
  debug_579:
    .return (rx412_cur)
  rx412_restart:
.annotate 'line', 4
    if_null rx412_debug, debug_580
    rx412_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_580:
  rx412_fail:
    (rx412_rep, rx412_pos, $I10, $P10) = rx412_cur."!mark_fail"(0)
    lt rx412_pos, -1, rx412_done
    eq rx412_pos, -1, rx412_fail
    jump $I10
  rx412_done:
    rx412_cur."!cursor_fail"()
    if_null rx412_debug, debug_581
    rx412_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_581:
    .return (rx412_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("90_1299465717.405") :method
.annotate 'line', 4
    $P414 = self."!PREFIX__!subrule"("ws", "if")
    new $P415, "ResizablePMCArray"
    push $P415, $P414
    .return ($P415)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("91_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx421_tgt
    .local int rx421_pos
    .local int rx421_off
    .local int rx421_eos
    .local int rx421_rep
    .local pmc rx421_cur
    .local pmc rx421_debug
    (rx421_cur, rx421_pos, rx421_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx421_cur
    .local pmc match
    .lex "$/", match
    length rx421_eos, rx421_tgt
    gt rx421_pos, rx421_eos, rx421_done
    set rx421_off, 0
    lt rx421_pos, 2, rx421_start
    sub rx421_off, rx421_pos, 1
    substr rx421_tgt, rx421_tgt, rx421_off
  rx421_start:
    eq $I10, 1, rx421_restart
    if_null rx421_debug, debug_582
    rx421_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan425_done
    goto rxscan425_scan
  rxscan425_loop:
    (rx421_pos) = rx421_cur."from"()
    inc rx421_pos
    rx421_cur."!cursor_from"(rx421_pos)
    ge rx421_pos, rx421_eos, rxscan425_done
  rxscan425_scan:
    set_addr $I10, rxscan425_loop
    rx421_cur."!mark_push"(0, rx421_pos, $I10)
  rxscan425_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_426_fail
    rx421_cur."!mark_push"(0, rx421_pos, $I10)
  # rx literal  "unless"
    add $I11, rx421_pos, 6
    gt $I11, rx421_eos, rx421_fail
    sub $I11, rx421_pos, rx421_off
    substr $S10, rx421_tgt, $I11, 6
    ne $S10, "unless", rx421_fail
    add rx421_pos, 6
    set_addr $I10, rxcap_426_fail
    ($I12, $I11) = rx421_cur."!mark_peek"($I10)
    rx421_cur."!cursor_pos"($I11)
    ($P10) = rx421_cur."!cursor_start"()
    $P10."!cursor_pass"(rx421_pos, "")
    rx421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_426_done
  rxcap_426_fail:
    goto rx421_fail
  rxcap_426_done:
  # rx subrule "ws" subtype=method negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."ws"()
    unless $P10, rx421_fail
    rx421_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."EXPR"()
    unless $P10, rx421_fail
    rx421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx421_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."ws"()
    unless $P10, rx421_fail
    rx421_pos = $P10."pos"()
  # rx pass
    rx421_cur."!cursor_pass"(rx421_pos, "statement_mod_cond:sym<unless>")
    if_null rx421_debug, debug_583
    rx421_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx421_pos)
  debug_583:
    .return (rx421_cur)
  rx421_restart:
.annotate 'line', 4
    if_null rx421_debug, debug_584
    rx421_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_584:
  rx421_fail:
    (rx421_rep, rx421_pos, $I10, $P10) = rx421_cur."!mark_fail"(0)
    lt rx421_pos, -1, rx421_done
    eq rx421_pos, -1, rx421_fail
    jump $I10
  rx421_done:
    rx421_cur."!cursor_fail"()
    if_null rx421_debug, debug_585
    rx421_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_585:
    .return (rx421_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("92_1299465717.405") :method
.annotate 'line', 4
    $P423 = self."!PREFIX__!subrule"("ws", "unless")
    new $P424, "ResizablePMCArray"
    push $P424, $P423
    .return ($P424)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("93_1299465717.405")
    .param pmc param_430
.annotate 'line', 240
    .lex "self", param_430
    $P431 = param_430."!protoregex"("statement_mod_loop")
    .return ($P431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("94_1299465717.405")
    .param pmc param_433
.annotate 'line', 240
    .lex "self", param_433
    $P434 = param_433."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("95_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx436_tgt
    .local int rx436_pos
    .local int rx436_off
    .local int rx436_eos
    .local int rx436_rep
    .local pmc rx436_cur
    .local pmc rx436_debug
    (rx436_cur, rx436_pos, rx436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx436_cur
    .local pmc match
    .lex "$/", match
    length rx436_eos, rx436_tgt
    gt rx436_pos, rx436_eos, rx436_done
    set rx436_off, 0
    lt rx436_pos, 2, rx436_start
    sub rx436_off, rx436_pos, 1
    substr rx436_tgt, rx436_tgt, rx436_off
  rx436_start:
    eq $I10, 1, rx436_restart
    if_null rx436_debug, debug_586
    rx436_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan440_done
    goto rxscan440_scan
  rxscan440_loop:
    (rx436_pos) = rx436_cur."from"()
    inc rx436_pos
    rx436_cur."!cursor_from"(rx436_pos)
    ge rx436_pos, rx436_eos, rxscan440_done
  rxscan440_scan:
    set_addr $I10, rxscan440_loop
    rx436_cur."!mark_push"(0, rx436_pos, $I10)
  rxscan440_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_441_fail
    rx436_cur."!mark_push"(0, rx436_pos, $I10)
  # rx literal  "while"
    add $I11, rx436_pos, 5
    gt $I11, rx436_eos, rx436_fail
    sub $I11, rx436_pos, rx436_off
    substr $S10, rx436_tgt, $I11, 5
    ne $S10, "while", rx436_fail
    add rx436_pos, 5
    set_addr $I10, rxcap_441_fail
    ($I12, $I11) = rx436_cur."!mark_peek"($I10)
    rx436_cur."!cursor_pos"($I11)
    ($P10) = rx436_cur."!cursor_start"()
    $P10."!cursor_pass"(rx436_pos, "")
    rx436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_441_done
  rxcap_441_fail:
    goto rx436_fail
  rxcap_441_done:
  # rx subrule "ws" subtype=method negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."ws"()
    unless $P10, rx436_fail
    rx436_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."EXPR"()
    unless $P10, rx436_fail
    rx436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx436_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."ws"()
    unless $P10, rx436_fail
    rx436_pos = $P10."pos"()
  # rx pass
    rx436_cur."!cursor_pass"(rx436_pos, "statement_mod_loop:sym<while>")
    if_null rx436_debug, debug_587
    rx436_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx436_pos)
  debug_587:
    .return (rx436_cur)
  rx436_restart:
.annotate 'line', 4
    if_null rx436_debug, debug_588
    rx436_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_588:
  rx436_fail:
    (rx436_rep, rx436_pos, $I10, $P10) = rx436_cur."!mark_fail"(0)
    lt rx436_pos, -1, rx436_done
    eq rx436_pos, -1, rx436_fail
    jump $I10
  rx436_done:
    rx436_cur."!cursor_fail"()
    if_null rx436_debug, debug_589
    rx436_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_589:
    .return (rx436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("96_1299465717.405") :method
.annotate 'line', 4
    $P438 = self."!PREFIX__!subrule"("ws", "while")
    new $P439, "ResizablePMCArray"
    push $P439, $P438
    .return ($P439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("97_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx445_tgt
    .local int rx445_pos
    .local int rx445_off
    .local int rx445_eos
    .local int rx445_rep
    .local pmc rx445_cur
    .local pmc rx445_debug
    (rx445_cur, rx445_pos, rx445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx445_cur
    .local pmc match
    .lex "$/", match
    length rx445_eos, rx445_tgt
    gt rx445_pos, rx445_eos, rx445_done
    set rx445_off, 0
    lt rx445_pos, 2, rx445_start
    sub rx445_off, rx445_pos, 1
    substr rx445_tgt, rx445_tgt, rx445_off
  rx445_start:
    eq $I10, 1, rx445_restart
    if_null rx445_debug, debug_590
    rx445_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan449_done
    goto rxscan449_scan
  rxscan449_loop:
    (rx445_pos) = rx445_cur."from"()
    inc rx445_pos
    rx445_cur."!cursor_from"(rx445_pos)
    ge rx445_pos, rx445_eos, rxscan449_done
  rxscan449_scan:
    set_addr $I10, rxscan449_loop
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  rxscan449_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_450_fail
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  # rx literal  "until"
    add $I11, rx445_pos, 5
    gt $I11, rx445_eos, rx445_fail
    sub $I11, rx445_pos, rx445_off
    substr $S10, rx445_tgt, $I11, 5
    ne $S10, "until", rx445_fail
    add rx445_pos, 5
    set_addr $I10, rxcap_450_fail
    ($I12, $I11) = rx445_cur."!mark_peek"($I10)
    rx445_cur."!cursor_pos"($I11)
    ($P10) = rx445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx445_pos, "")
    rx445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_450_done
  rxcap_450_fail:
    goto rx445_fail
  rxcap_450_done:
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."EXPR"()
    unless $P10, rx445_fail
    rx445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx445_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx pass
    rx445_cur."!cursor_pass"(rx445_pos, "statement_mod_loop:sym<until>")
    if_null rx445_debug, debug_591
    rx445_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx445_pos)
  debug_591:
    .return (rx445_cur)
  rx445_restart:
.annotate 'line', 4
    if_null rx445_debug, debug_592
    rx445_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_592:
  rx445_fail:
    (rx445_rep, rx445_pos, $I10, $P10) = rx445_cur."!mark_fail"(0)
    lt rx445_pos, -1, rx445_done
    eq rx445_pos, -1, rx445_fail
    jump $I10
  rx445_done:
    rx445_cur."!cursor_fail"()
    if_null rx445_debug, debug_593
    rx445_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_593:
    .return (rx445_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("98_1299465717.405") :method
.annotate 'line', 4
    $P447 = self."!PREFIX__!subrule"("ws", "until")
    new $P448, "ResizablePMCArray"
    push $P448, $P447
    .return ($P448)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("99_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx454_tgt
    .local int rx454_pos
    .local int rx454_off
    .local int rx454_eos
    .local int rx454_rep
    .local pmc rx454_cur
    .local pmc rx454_debug
    (rx454_cur, rx454_pos, rx454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx454_cur
    .local pmc match
    .lex "$/", match
    length rx454_eos, rx454_tgt
    gt rx454_pos, rx454_eos, rx454_done
    set rx454_off, 0
    lt rx454_pos, 2, rx454_start
    sub rx454_off, rx454_pos, 1
    substr rx454_tgt, rx454_tgt, rx454_off
  rx454_start:
    eq $I10, 1, rx454_restart
    if_null rx454_debug, debug_594
    rx454_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan458_done
    goto rxscan458_scan
  rxscan458_loop:
    (rx454_pos) = rx454_cur."from"()
    inc rx454_pos
    rx454_cur."!cursor_from"(rx454_pos)
    ge rx454_pos, rx454_eos, rxscan458_done
  rxscan458_scan:
    set_addr $I10, rxscan458_loop
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  rxscan458_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_459_fail
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  # rx literal  "for"
    add $I11, rx454_pos, 3
    gt $I11, rx454_eos, rx454_fail
    sub $I11, rx454_pos, rx454_off
    substr $S10, rx454_tgt, $I11, 3
    ne $S10, "for", rx454_fail
    add rx454_pos, 3
    set_addr $I10, rxcap_459_fail
    ($I12, $I11) = rx454_cur."!mark_peek"($I10)
    rx454_cur."!cursor_pos"($I11)
    ($P10) = rx454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx454_pos, "")
    rx454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_459_done
  rxcap_459_fail:
    goto rx454_fail
  rxcap_459_done:
  # rx subrule "ws" subtype=method negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."ws"()
    unless $P10, rx454_fail
    rx454_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."EXPR"()
    unless $P10, rx454_fail
    rx454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx454_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."ws"()
    unless $P10, rx454_fail
    rx454_pos = $P10."pos"()
  # rx pass
    rx454_cur."!cursor_pass"(rx454_pos, "statement_mod_loop:sym<for>")
    if_null rx454_debug, debug_595
    rx454_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx454_pos)
  debug_595:
    .return (rx454_cur)
  rx454_restart:
.annotate 'line', 4
    if_null rx454_debug, debug_596
    rx454_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_596:
  rx454_fail:
    (rx454_rep, rx454_pos, $I10, $P10) = rx454_cur."!mark_fail"(0)
    lt rx454_pos, -1, rx454_done
    eq rx454_pos, -1, rx454_fail
    jump $I10
  rx454_done:
    rx454_cur."!cursor_fail"()
    if_null rx454_debug, debug_597
    rx454_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_597:
    .return (rx454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("100_1299465717.405") :method
.annotate 'line', 4
    $P456 = self."!PREFIX__!subrule"("ws", "for")
    new $P457, "ResizablePMCArray"
    push $P457, $P456
    .return ($P457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("101_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_598
    rx463_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan467_done:
.annotate 'line', 248
  # rx subrule "fatarrow" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."fatarrow"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx463_pos = $P10."pos"()
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "term:sym<fatarrow>")
    if_null rx463_debug, debug_599
    rx463_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx463_pos)
  debug_599:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 4
    if_null rx463_debug, debug_600
    rx463_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_600:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_601
    rx463_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_601:
    .return (rx463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("102_1299465717.405") :method
.annotate 'line', 4
    $P465 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P466, "ResizablePMCArray"
    push $P466, $P465
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("103_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx469_tgt
    .local int rx469_pos
    .local int rx469_off
    .local int rx469_eos
    .local int rx469_rep
    .local pmc rx469_cur
    .local pmc rx469_debug
    (rx469_cur, rx469_pos, rx469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx469_cur
    .local pmc match
    .lex "$/", match
    length rx469_eos, rx469_tgt
    gt rx469_pos, rx469_eos, rx469_done
    set rx469_off, 0
    lt rx469_pos, 2, rx469_start
    sub rx469_off, rx469_pos, 1
    substr rx469_tgt, rx469_tgt, rx469_off
  rx469_start:
    eq $I10, 1, rx469_restart
    if_null rx469_debug, debug_602
    rx469_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan473_done
    goto rxscan473_scan
  rxscan473_loop:
    (rx469_pos) = rx469_cur."from"()
    inc rx469_pos
    rx469_cur."!cursor_from"(rx469_pos)
    ge rx469_pos, rx469_eos, rxscan473_done
  rxscan473_scan:
    set_addr $I10, rxscan473_loop
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  rxscan473_done:
.annotate 'line', 249
  # rx subrule "colonpair" subtype=capture negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."colonpair"()
    unless $P10, rx469_fail
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx469_pos = $P10."pos"()
  # rx pass
    rx469_cur."!cursor_pass"(rx469_pos, "term:sym<colonpair>")
    if_null rx469_debug, debug_603
    rx469_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx469_pos)
  debug_603:
    .return (rx469_cur)
  rx469_restart:
.annotate 'line', 4
    if_null rx469_debug, debug_604
    rx469_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_604:
  rx469_fail:
    (rx469_rep, rx469_pos, $I10, $P10) = rx469_cur."!mark_fail"(0)
    lt rx469_pos, -1, rx469_done
    eq rx469_pos, -1, rx469_fail
    jump $I10
  rx469_done:
    rx469_cur."!cursor_fail"()
    if_null rx469_debug, debug_605
    rx469_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_605:
    .return (rx469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("104_1299465717.405") :method
.annotate 'line', 4
    $P471 = self."!PREFIX__!subrule"("colonpair", "")
    new $P472, "ResizablePMCArray"
    push $P472, $P471
    .return ($P472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("105_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx475_tgt
    .local int rx475_pos
    .local int rx475_off
    .local int rx475_eos
    .local int rx475_rep
    .local pmc rx475_cur
    .local pmc rx475_debug
    (rx475_cur, rx475_pos, rx475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx475_cur
    .local pmc match
    .lex "$/", match
    length rx475_eos, rx475_tgt
    gt rx475_pos, rx475_eos, rx475_done
    set rx475_off, 0
    lt rx475_pos, 2, rx475_start
    sub rx475_off, rx475_pos, 1
    substr rx475_tgt, rx475_tgt, rx475_off
  rx475_start:
    eq $I10, 1, rx475_restart
    if_null rx475_debug, debug_606
    rx475_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan479_done
    goto rxscan479_scan
  rxscan479_loop:
    (rx475_pos) = rx475_cur."from"()
    inc rx475_pos
    rx475_cur."!cursor_from"(rx475_pos)
    ge rx475_pos, rx475_eos, rxscan479_done
  rxscan479_scan:
    set_addr $I10, rxscan479_loop
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  rxscan479_done:
.annotate 'line', 250
  # rx subrule "variable" subtype=capture negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."variable"()
    unless $P10, rx475_fail
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx475_pos = $P10."pos"()
  # rx pass
    rx475_cur."!cursor_pass"(rx475_pos, "term:sym<variable>")
    if_null rx475_debug, debug_607
    rx475_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx475_pos)
  debug_607:
    .return (rx475_cur)
  rx475_restart:
.annotate 'line', 4
    if_null rx475_debug, debug_608
    rx475_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_608:
  rx475_fail:
    (rx475_rep, rx475_pos, $I10, $P10) = rx475_cur."!mark_fail"(0)
    lt rx475_pos, -1, rx475_done
    eq rx475_pos, -1, rx475_fail
    jump $I10
  rx475_done:
    rx475_cur."!cursor_fail"()
    if_null rx475_debug, debug_609
    rx475_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_609:
    .return (rx475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("106_1299465717.405") :method
.annotate 'line', 4
    $P477 = self."!PREFIX__!subrule"("variable", "")
    new $P478, "ResizablePMCArray"
    push $P478, $P477
    .return ($P478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("107_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_610
    rx481_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan485_done
    goto rxscan485_scan
  rxscan485_loop:
    (rx481_pos) = rx481_cur."from"()
    inc rx481_pos
    rx481_cur."!cursor_from"(rx481_pos)
    ge rx481_pos, rx481_eos, rxscan485_done
  rxscan485_scan:
    set_addr $I10, rxscan485_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan485_done:
.annotate 'line', 251
  # rx subrule "package_declarator" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."package_declarator"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx481_pos = $P10."pos"()
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "term:sym<package_declarator>")
    if_null rx481_debug, debug_611
    rx481_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx481_pos)
  debug_611:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 4
    if_null rx481_debug, debug_612
    rx481_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_612:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_613
    rx481_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_613:
    .return (rx481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("108_1299465717.405") :method
.annotate 'line', 4
    $P483 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P484, "ResizablePMCArray"
    push $P484, $P483
    .return ($P484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("109_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx487_tgt
    .local int rx487_pos
    .local int rx487_off
    .local int rx487_eos
    .local int rx487_rep
    .local pmc rx487_cur
    .local pmc rx487_debug
    (rx487_cur, rx487_pos, rx487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx487_cur
    .local pmc match
    .lex "$/", match
    length rx487_eos, rx487_tgt
    gt rx487_pos, rx487_eos, rx487_done
    set rx487_off, 0
    lt rx487_pos, 2, rx487_start
    sub rx487_off, rx487_pos, 1
    substr rx487_tgt, rx487_tgt, rx487_off
  rx487_start:
    eq $I10, 1, rx487_restart
    if_null rx487_debug, debug_614
    rx487_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan491_done
    goto rxscan491_scan
  rxscan491_loop:
    (rx487_pos) = rx487_cur."from"()
    inc rx487_pos
    rx487_cur."!cursor_from"(rx487_pos)
    ge rx487_pos, rx487_eos, rxscan491_done
  rxscan491_scan:
    set_addr $I10, rxscan491_loop
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  rxscan491_done:
.annotate 'line', 252
  # rx subrule "scope_declarator" subtype=capture negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."scope_declarator"()
    unless $P10, rx487_fail
    rx487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx487_pos = $P10."pos"()
  # rx pass
    rx487_cur."!cursor_pass"(rx487_pos, "term:sym<scope_declarator>")
    if_null rx487_debug, debug_615
    rx487_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx487_pos)
  debug_615:
    .return (rx487_cur)
  rx487_restart:
.annotate 'line', 4
    if_null rx487_debug, debug_616
    rx487_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_616:
  rx487_fail:
    (rx487_rep, rx487_pos, $I10, $P10) = rx487_cur."!mark_fail"(0)
    lt rx487_pos, -1, rx487_done
    eq rx487_pos, -1, rx487_fail
    jump $I10
  rx487_done:
    rx487_cur."!cursor_fail"()
    if_null rx487_debug, debug_617
    rx487_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_617:
    .return (rx487_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("110_1299465717.405") :method
.annotate 'line', 4
    $P489 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P490, "ResizablePMCArray"
    push $P490, $P489
    .return ($P490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("111_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx493_tgt
    .local int rx493_pos
    .local int rx493_off
    .local int rx493_eos
    .local int rx493_rep
    .local pmc rx493_cur
    .local pmc rx493_debug
    (rx493_cur, rx493_pos, rx493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx493_cur
    .local pmc match
    .lex "$/", match
    length rx493_eos, rx493_tgt
    gt rx493_pos, rx493_eos, rx493_done
    set rx493_off, 0
    lt rx493_pos, 2, rx493_start
    sub rx493_off, rx493_pos, 1
    substr rx493_tgt, rx493_tgt, rx493_off
  rx493_start:
    eq $I10, 1, rx493_restart
    if_null rx493_debug, debug_618
    rx493_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan497_done
    goto rxscan497_scan
  rxscan497_loop:
    (rx493_pos) = rx493_cur."from"()
    inc rx493_pos
    rx493_cur."!cursor_from"(rx493_pos)
    ge rx493_pos, rx493_eos, rxscan497_done
  rxscan497_scan:
    set_addr $I10, rxscan497_loop
    rx493_cur."!mark_push"(0, rx493_pos, $I10)
  rxscan497_done:
.annotate 'line', 253
  # rx subrule "routine_declarator" subtype=capture negate=
    rx493_cur."!cursor_pos"(rx493_pos)
    $P10 = rx493_cur."routine_declarator"()
    unless $P10, rx493_fail
    rx493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx493_pos = $P10."pos"()
  # rx pass
    rx493_cur."!cursor_pass"(rx493_pos, "term:sym<routine_declarator>")
    if_null rx493_debug, debug_619
    rx493_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx493_pos)
  debug_619:
    .return (rx493_cur)
  rx493_restart:
.annotate 'line', 4
    if_null rx493_debug, debug_620
    rx493_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_620:
  rx493_fail:
    (rx493_rep, rx493_pos, $I10, $P10) = rx493_cur."!mark_fail"(0)
    lt rx493_pos, -1, rx493_done
    eq rx493_pos, -1, rx493_fail
    jump $I10
  rx493_done:
    rx493_cur."!cursor_fail"()
    if_null rx493_debug, debug_621
    rx493_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_621:
    .return (rx493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("112_1299465717.405") :method
.annotate 'line', 4
    $P495 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P496, "ResizablePMCArray"
    push $P496, $P495
    .return ($P496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("113_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P509 = "116_1299465717.405" 
    capture_lex $P509
    .const 'Sub' $P504 = "115_1299465717.405" 
    capture_lex $P504
    .local string rx499_tgt
    .local int rx499_pos
    .local int rx499_off
    .local int rx499_eos
    .local int rx499_rep
    .local pmc rx499_cur
    .local pmc rx499_debug
    (rx499_cur, rx499_pos, rx499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx499_cur
    .local pmc match
    .lex "$/", match
    length rx499_eos, rx499_tgt
    gt rx499_pos, rx499_eos, rx499_done
    set rx499_off, 0
    lt rx499_pos, 2, rx499_start
    sub rx499_off, rx499_pos, 1
    substr rx499_tgt, rx499_tgt, rx499_off
  rx499_start:
    eq $I10, 1, rx499_restart
    if_null rx499_debug, debug_622
    rx499_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan502_done
    goto rxscan502_scan
  rxscan502_loop:
    (rx499_pos) = rx499_cur."from"()
    inc rx499_pos
    rx499_cur."!cursor_from"(rx499_pos)
    ge rx499_pos, rx499_eos, rxscan502_done
  rxscan502_scan:
    set_addr $I10, rxscan502_loop
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  rxscan502_done:
.annotate 'line', 255
  # rx subrule "before" subtype=zerowidth negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    .const 'Sub' $P504 = "115_1299465717.405" 
    capture_lex $P504
    $P10 = rx499_cur."before"($P504)
    unless $P10, rx499_fail
.annotate 'line', 256
  # rx subrule "before" subtype=zerowidth negate=1
    rx499_cur."!cursor_pos"(rx499_pos)
    .const 'Sub' $P509 = "116_1299465717.405" 
    capture_lex $P509
    $P10 = rx499_cur."before"($P509)
    if $P10, rx499_fail
.annotate 'line', 257
  # rx subrule "multi_declarator" subtype=capture negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."multi_declarator"()
    unless $P10, rx499_fail
    rx499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx499_pos = $P10."pos"()
.annotate 'line', 254
  # rx pass
    rx499_cur."!cursor_pass"(rx499_pos, "term:sym<multi_declarator>")
    if_null rx499_debug, debug_631
    rx499_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx499_pos)
  debug_631:
    .return (rx499_cur)
  rx499_restart:
.annotate 'line', 4
    if_null rx499_debug, debug_632
    rx499_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_632:
  rx499_fail:
    (rx499_rep, rx499_pos, $I10, $P10) = rx499_cur."!mark_fail"(0)
    lt rx499_pos, -1, rx499_done
    eq rx499_pos, -1, rx499_fail
    jump $I10
  rx499_done:
    rx499_cur."!cursor_fail"()
    if_null rx499_debug, debug_633
    rx499_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_633:
    .return (rx499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("114_1299465717.405") :method
.annotate 'line', 4
    new $P501, "ResizablePMCArray"
    push $P501, ""
    .return ($P501)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block503"  :anon :subid("115_1299465717.405") :method :outer("113_1299465717.405")
.annotate 'line', 255
    .local string rx505_tgt
    .local int rx505_pos
    .local int rx505_off
    .local int rx505_eos
    .local int rx505_rep
    .local pmc rx505_cur
    .local pmc rx505_debug
    (rx505_cur, rx505_pos, rx505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx505_cur
    .local pmc match
    .lex "$/", match
    length rx505_eos, rx505_tgt
    gt rx505_pos, rx505_eos, rx505_done
    set rx505_off, 0
    lt rx505_pos, 2, rx505_start
    sub rx505_off, rx505_pos, 1
    substr rx505_tgt, rx505_tgt, rx505_off
  rx505_start:
    eq $I10, 1, rx505_restart
    if_null rx505_debug, debug_623
    rx505_cur."!cursor_debug"("START", "")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan506_done
    goto rxscan506_scan
  rxscan506_loop:
    (rx505_pos) = rx505_cur."from"()
    inc rx505_pos
    rx505_cur."!cursor_from"(rx505_pos)
    ge rx505_pos, rx505_eos, rxscan506_done
  rxscan506_scan:
    set_addr $I10, rxscan506_loop
    rx505_cur."!mark_push"(0, rx505_pos, $I10)
  rxscan506_done:
  alt507_0:
    set_addr $I10, alt507_1
    rx505_cur."!mark_push"(0, rx505_pos, $I10)
  # rx literal  "multi"
    add $I11, rx505_pos, 5
    gt $I11, rx505_eos, rx505_fail
    sub $I11, rx505_pos, rx505_off
    substr $S10, rx505_tgt, $I11, 5
    ne $S10, "multi", rx505_fail
    add rx505_pos, 5
    goto alt507_end
  alt507_1:
    set_addr $I10, alt507_2
    rx505_cur."!mark_push"(0, rx505_pos, $I10)
  # rx literal  "proto"
    add $I11, rx505_pos, 5
    gt $I11, rx505_eos, rx505_fail
    sub $I11, rx505_pos, rx505_off
    substr $S10, rx505_tgt, $I11, 5
    ne $S10, "proto", rx505_fail
    add rx505_pos, 5
    goto alt507_end
  alt507_2:
  # rx literal  "only"
    add $I11, rx505_pos, 4
    gt $I11, rx505_eos, rx505_fail
    sub $I11, rx505_pos, rx505_off
    substr $S10, rx505_tgt, $I11, 4
    ne $S10, "only", rx505_fail
    add rx505_pos, 4
  alt507_end:
  # rx pass
    rx505_cur."!cursor_pass"(rx505_pos, "")
    if_null rx505_debug, debug_624
    rx505_cur."!cursor_debug"("PASS", "", " at pos=", rx505_pos)
  debug_624:
    .return (rx505_cur)
  rx505_restart:
    if_null rx505_debug, debug_625
    rx505_cur."!cursor_debug"("NEXT", "")
  debug_625:
  rx505_fail:
    (rx505_rep, rx505_pos, $I10, $P10) = rx505_cur."!mark_fail"(0)
    lt rx505_pos, -1, rx505_done
    eq rx505_pos, -1, rx505_fail
    jump $I10
  rx505_done:
    rx505_cur."!cursor_fail"()
    if_null rx505_debug, debug_626
    rx505_cur."!cursor_debug"("FAIL", "")
  debug_626:
    .return (rx505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block508"  :anon :subid("116_1299465717.405") :method :outer("113_1299465717.405")
.annotate 'line', 256
    .local string rx510_tgt
    .local int rx510_pos
    .local int rx510_off
    .local int rx510_eos
    .local int rx510_rep
    .local pmc rx510_cur
    .local pmc rx510_debug
    (rx510_cur, rx510_pos, rx510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx510_cur
    .local pmc match
    .lex "$/", match
    length rx510_eos, rx510_tgt
    gt rx510_pos, rx510_eos, rx510_done
    set rx510_off, 0
    lt rx510_pos, 2, rx510_start
    sub rx510_off, rx510_pos, 1
    substr rx510_tgt, rx510_tgt, rx510_off
  rx510_start:
    eq $I10, 1, rx510_restart
    if_null rx510_debug, debug_627
    rx510_cur."!cursor_debug"("START", "")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan511_done
    goto rxscan511_scan
  rxscan511_loop:
    (rx510_pos) = rx510_cur."from"()
    inc rx510_pos
    rx510_cur."!cursor_from"(rx510_pos)
    ge rx510_pos, rx510_eos, rxscan511_done
  rxscan511_scan:
    set_addr $I10, rxscan511_loop
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  rxscan511_done:
  # rx literal  "proto"
    add $I11, rx510_pos, 5
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 5
    ne $S10, "proto", rx510_fail
    add rx510_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."ws"()
    unless $P10, rx510_fail
    rx510_pos = $P10."pos"()
  alt512_0:
    set_addr $I10, alt512_1
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  # rx literal  "regex"
    add $I11, rx510_pos, 5
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 5
    ne $S10, "regex", rx510_fail
    add rx510_pos, 5
    goto alt512_end
  alt512_1:
    set_addr $I10, alt512_2
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  # rx literal  "token"
    add $I11, rx510_pos, 5
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 5
    ne $S10, "token", rx510_fail
    add rx510_pos, 5
    goto alt512_end
  alt512_2:
  # rx literal  "rule"
    add $I11, rx510_pos, 4
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 4
    ne $S10, "rule", rx510_fail
    add rx510_pos, 4
  alt512_end:
  # rx pass
    rx510_cur."!cursor_pass"(rx510_pos, "")
    if_null rx510_debug, debug_628
    rx510_cur."!cursor_debug"("PASS", "", " at pos=", rx510_pos)
  debug_628:
    .return (rx510_cur)
  rx510_restart:
    if_null rx510_debug, debug_629
    rx510_cur."!cursor_debug"("NEXT", "")
  debug_629:
  rx510_fail:
    (rx510_rep, rx510_pos, $I10, $P10) = rx510_cur."!mark_fail"(0)
    lt rx510_pos, -1, rx510_done
    eq rx510_pos, -1, rx510_fail
    jump $I10
  rx510_done:
    rx510_cur."!cursor_fail"()
    if_null rx510_debug, debug_630
    rx510_cur."!cursor_debug"("FAIL", "")
  debug_630:
    .return (rx510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("117_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_634
    rx514_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan518_done
    goto rxscan518_scan
  rxscan518_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan518_done
  rxscan518_scan:
    set_addr $I10, rxscan518_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan518_done:
.annotate 'line', 259
  # rx subrule "regex_declarator" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."regex_declarator"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx514_pos = $P10."pos"()
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "term:sym<regex_declarator>")
    if_null rx514_debug, debug_635
    rx514_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx514_pos)
  debug_635:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 4
    if_null rx514_debug, debug_636
    rx514_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_636:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_637
    rx514_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_637:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("118_1299465717.405") :method
.annotate 'line', 4
    $P516 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P517, "ResizablePMCArray"
    push $P517, $P516
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("119_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx520_tgt
    .local int rx520_pos
    .local int rx520_off
    .local int rx520_eos
    .local int rx520_rep
    .local pmc rx520_cur
    .local pmc rx520_debug
    (rx520_cur, rx520_pos, rx520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx520_cur
    .local pmc match
    .lex "$/", match
    length rx520_eos, rx520_tgt
    gt rx520_pos, rx520_eos, rx520_done
    set rx520_off, 0
    lt rx520_pos, 2, rx520_start
    sub rx520_off, rx520_pos, 1
    substr rx520_tgt, rx520_tgt, rx520_off
  rx520_start:
    eq $I10, 1, rx520_restart
    if_null rx520_debug, debug_638
    rx520_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan524_done
    goto rxscan524_scan
  rxscan524_loop:
    (rx520_pos) = rx520_cur."from"()
    inc rx520_pos
    rx520_cur."!cursor_from"(rx520_pos)
    ge rx520_pos, rx520_eos, rxscan524_done
  rxscan524_scan:
    set_addr $I10, rxscan524_loop
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxscan524_done:
.annotate 'line', 260
  # rx subrule "statement_prefix" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."statement_prefix"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx520_pos = $P10."pos"()
  # rx pass
    rx520_cur."!cursor_pass"(rx520_pos, "term:sym<statement_prefix>")
    if_null rx520_debug, debug_639
    rx520_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx520_pos)
  debug_639:
    .return (rx520_cur)
  rx520_restart:
.annotate 'line', 4
    if_null rx520_debug, debug_640
    rx520_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_640:
  rx520_fail:
    (rx520_rep, rx520_pos, $I10, $P10) = rx520_cur."!mark_fail"(0)
    lt rx520_pos, -1, rx520_done
    eq rx520_pos, -1, rx520_fail
    jump $I10
  rx520_done:
    rx520_cur."!cursor_fail"()
    if_null rx520_debug, debug_641
    rx520_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_641:
    .return (rx520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("120_1299465717.405") :method
.annotate 'line', 4
    $P522 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P523, "ResizablePMCArray"
    push $P523, $P522
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("121_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx526_tgt
    .local int rx526_pos
    .local int rx526_off
    .local int rx526_eos
    .local int rx526_rep
    .local pmc rx526_cur
    .local pmc rx526_debug
    (rx526_cur, rx526_pos, rx526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx526_cur
    .local pmc match
    .lex "$/", match
    length rx526_eos, rx526_tgt
    gt rx526_pos, rx526_eos, rx526_done
    set rx526_off, 0
    lt rx526_pos, 2, rx526_start
    sub rx526_off, rx526_pos, 1
    substr rx526_tgt, rx526_tgt, rx526_off
  rx526_start:
    eq $I10, 1, rx526_restart
    if_null rx526_debug, debug_642
    rx526_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx526_pos) = rx526_cur."from"()
    inc rx526_pos
    rx526_cur."!cursor_from"(rx526_pos)
    ge rx526_pos, rx526_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx526_cur."!mark_push"(0, rx526_pos, $I10)
  rxscan529_done:
.annotate 'line', 261
  # rx subrule "lambda" subtype=zerowidth negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    $P10 = rx526_cur."lambda"()
    unless $P10, rx526_fail
  # rx subrule "pblock" subtype=capture negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    $P10 = rx526_cur."pblock"()
    unless $P10, rx526_fail
    rx526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx526_pos = $P10."pos"()
  # rx pass
    rx526_cur."!cursor_pass"(rx526_pos, "term:sym<lambda>")
    if_null rx526_debug, debug_643
    rx526_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx526_pos)
  debug_643:
    .return (rx526_cur)
  rx526_restart:
.annotate 'line', 4
    if_null rx526_debug, debug_644
    rx526_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_644:
  rx526_fail:
    (rx526_rep, rx526_pos, $I10, $P10) = rx526_cur."!mark_fail"(0)
    lt rx526_pos, -1, rx526_done
    eq rx526_pos, -1, rx526_fail
    jump $I10
  rx526_done:
    rx526_cur."!cursor_fail"()
    if_null rx526_debug, debug_645
    rx526_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_645:
    .return (rx526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("122_1299465717.405") :method
.annotate 'line', 4
    new $P528, "ResizablePMCArray"
    push $P528, ""
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("123_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx531_tgt
    .local int rx531_pos
    .local int rx531_off
    .local int rx531_eos
    .local int rx531_rep
    .local pmc rx531_cur
    .local pmc rx531_debug
    (rx531_cur, rx531_pos, rx531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx531_cur
    .local pmc match
    .lex "$/", match
    length rx531_eos, rx531_tgt
    gt rx531_pos, rx531_eos, rx531_done
    set rx531_off, 0
    lt rx531_pos, 2, rx531_start
    sub rx531_off, rx531_pos, 1
    substr rx531_tgt, rx531_tgt, rx531_off
  rx531_start:
    eq $I10, 1, rx531_restart
    if_null rx531_debug, debug_646
    rx531_cur."!cursor_debug"("START", "fatarrow")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan535_done
    goto rxscan535_scan
  rxscan535_loop:
    (rx531_pos) = rx531_cur."from"()
    inc rx531_pos
    rx531_cur."!cursor_from"(rx531_pos)
    ge rx531_pos, rx531_eos, rxscan535_done
  rxscan535_scan:
    set_addr $I10, rxscan535_loop
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  rxscan535_done:
.annotate 'line', 264
  # rx subrule "identifier" subtype=capture negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."identifier"()
    unless $P10, rx531_fail
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx531_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx531_pos, rx531_off
    set rx531_rep, 0
    sub $I12, rx531_eos, rx531_pos
  rxenumcharlistq536_loop:
    le $I12, 0, rxenumcharlistq536_done
    substr $S10, rx531_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq536_done
    inc rx531_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq536_loop
  rxenumcharlistq536_done:
    add rx531_pos, rx531_pos, rx531_rep
  # rx literal  "=>"
    add $I11, rx531_pos, 2
    gt $I11, rx531_eos, rx531_fail
    sub $I11, rx531_pos, rx531_off
    substr $S10, rx531_tgt, $I11, 2
    ne $S10, "=>", rx531_fail
    add rx531_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."ws"()
    unless $P10, rx531_fail
    rx531_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."EXPR"("i=")
    unless $P10, rx531_fail
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx531_pos = $P10."pos"()
.annotate 'line', 263
  # rx pass
    rx531_cur."!cursor_pass"(rx531_pos, "fatarrow")
    if_null rx531_debug, debug_647
    rx531_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx531_pos)
  debug_647:
    .return (rx531_cur)
  rx531_restart:
.annotate 'line', 4
    if_null rx531_debug, debug_648
    rx531_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_648:
  rx531_fail:
    (rx531_rep, rx531_pos, $I10, $P10) = rx531_cur."!mark_fail"(0)
    lt rx531_pos, -1, rx531_done
    eq rx531_pos, -1, rx531_fail
    jump $I10
  rx531_done:
    rx531_cur."!cursor_fail"()
    if_null rx531_debug, debug_649
    rx531_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_649:
    .return (rx531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("124_1299465717.405") :method
.annotate 'line', 4
    $P533 = self."!PREFIX__!subrule"("identifier", "")
    new $P534, "ResizablePMCArray"
    push $P534, $P533
    .return ($P534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("125_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx538_tgt
    .local int rx538_pos
    .local int rx538_off
    .local int rx538_eos
    .local int rx538_rep
    .local pmc rx538_cur
    .local pmc rx538_debug
    (rx538_cur, rx538_pos, rx538_tgt, $I10) = self."!cursor_start"()
    rx538_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx538_cur
    .local pmc match
    .lex "$/", match
    length rx538_eos, rx538_tgt
    gt rx538_pos, rx538_eos, rx538_done
    set rx538_off, 0
    lt rx538_pos, 2, rx538_start
    sub rx538_off, rx538_pos, 1
    substr rx538_tgt, rx538_tgt, rx538_off
  rx538_start:
    eq $I10, 1, rx538_restart
    if_null rx538_debug, debug_650
    rx538_cur."!cursor_debug"("START", "colonpair")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan544_done
    goto rxscan544_scan
  rxscan544_loop:
    (rx538_pos) = rx538_cur."from"()
    inc rx538_pos
    rx538_cur."!cursor_from"(rx538_pos)
    ge rx538_pos, rx538_eos, rxscan544_done
  rxscan544_scan:
    set_addr $I10, rxscan544_loop
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  rxscan544_done:
.annotate 'line', 268
  # rx literal  ":"
    add $I11, rx538_pos, 1
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    ord $I11, rx538_tgt, $I11
    ne $I11, 58, rx538_fail
    add rx538_pos, 1
  alt545_0:
.annotate 'line', 269
    set_addr $I10, alt545_1
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
.annotate 'line', 270
  # rx subcapture "not"
    set_addr $I10, rxcap_546_fail
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  # rx literal  "!"
    add $I11, rx538_pos, 1
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    ord $I11, rx538_tgt, $I11
    ne $I11, 33, rx538_fail
    add rx538_pos, 1
    set_addr $I10, rxcap_546_fail
    ($I12, $I11) = rx538_cur."!mark_peek"($I10)
    rx538_cur."!cursor_pos"($I11)
    ($P10) = rx538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx538_pos, "")
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_546_done
  rxcap_546_fail:
    goto rx538_fail
  rxcap_546_done:
  # rx subrule "identifier" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."identifier"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx538_pos = $P10."pos"()
    goto alt545_end
  alt545_1:
    set_addr $I10, alt545_2
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
.annotate 'line', 271
  # rx subrule "identifier" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."identifier"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx538_pos = $P10."pos"()
  # rx rxquantr547 ** 0..1
    set_addr $I10, rxquantr547_done
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  rxquantr547_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."circumfix"()
    unless $P10, rx538_fail
    goto rxsubrule548_pass
  rxsubrule548_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx538_fail
  rxsubrule548_pass:
    set_addr $I10, rxsubrule548_back
    rx538_cur."!mark_push"(0, rx538_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx538_pos = $P10."pos"()
    set_addr $I10, rxquantr547_done
    (rx538_rep) = rx538_cur."!mark_commit"($I10)
  rxquantr547_done:
    goto alt545_end
  alt545_2:
.annotate 'line', 272
  # rx subrule "circumfix" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."circumfix"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx538_pos = $P10."pos"()
  alt545_end:
.annotate 'line', 267
  # rx pass
    rx538_cur."!cursor_pass"(rx538_pos, "colonpair")
    if_null rx538_debug, debug_651
    rx538_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx538_pos)
  debug_651:
    .return (rx538_cur)
  rx538_restart:
.annotate 'line', 4
    if_null rx538_debug, debug_652
    rx538_cur."!cursor_debug"("NEXT", "colonpair")
  debug_652:
  rx538_fail:
    (rx538_rep, rx538_pos, $I10, $P10) = rx538_cur."!mark_fail"(0)
    lt rx538_pos, -1, rx538_done
    eq rx538_pos, -1, rx538_fail
    jump $I10
  rx538_done:
    rx538_cur."!cursor_fail"()
    if_null rx538_debug, debug_653
    rx538_cur."!cursor_debug"("FAIL", "colonpair")
  debug_653:
    .return (rx538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("126_1299465717.405") :method
.annotate 'line', 4
    $P540 = self."!PREFIX__!subrule"("circumfix", ":")
    $P541 = self."!PREFIX__!subrule"("identifier", ":")
    $P542 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P543, "ResizablePMCArray"
    push $P543, $P540
    push $P543, $P541
    push $P543, $P542
    .return ($P543)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("127_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx550_tgt
    .local int rx550_pos
    .local int rx550_off
    .local int rx550_eos
    .local int rx550_rep
    .local pmc rx550_cur
    .local pmc rx550_debug
    (rx550_cur, rx550_pos, rx550_tgt, $I10) = self."!cursor_start"()
    rx550_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx550_cur
    .local pmc match
    .lex "$/", match
    length rx550_eos, rx550_tgt
    gt rx550_pos, rx550_eos, rx550_done
    set rx550_off, 0
    lt rx550_pos, 2, rx550_start
    sub rx550_off, rx550_pos, 1
    substr rx550_tgt, rx550_tgt, rx550_off
  rx550_start:
    eq $I10, 1, rx550_restart
    if_null rx550_debug, debug_654
    rx550_cur."!cursor_debug"("START", "variable")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan555_done
    goto rxscan555_scan
  rxscan555_loop:
    (rx550_pos) = rx550_cur."from"()
    inc rx550_pos
    rx550_cur."!cursor_from"(rx550_pos)
    ge rx550_pos, rx550_eos, rxscan555_done
  rxscan555_scan:
    set_addr $I10, rxscan555_loop
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  rxscan555_done:
  alt556_0:
.annotate 'line', 276
    set_addr $I10, alt556_1
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
.annotate 'line', 277
  # rx subrule "sigil" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."sigil"()
    unless $P10, rx550_fail
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx550_pos = $P10."pos"()
  # rx rxquantr557 ** 0..1
    set_addr $I10, rxquantr557_done
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  rxquantr557_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."twigil"()
    unless $P10, rx550_fail
    goto rxsubrule558_pass
  rxsubrule558_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx550_fail
  rxsubrule558_pass:
    set_addr $I10, rxsubrule558_back
    rx550_cur."!mark_push"(0, rx550_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx550_pos = $P10."pos"()
    set_addr $I10, rxquantr557_done
    (rx550_rep) = rx550_cur."!mark_commit"($I10)
  rxquantr557_done:
  # rx subrule "name" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."name"()
    unless $P10, rx550_fail
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx550_pos = $P10."pos"()
    goto alt556_end
  alt556_1:
    set_addr $I10, alt556_2
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
.annotate 'line', 278
  # rx subrule "sigil" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."sigil"()
    unless $P10, rx550_fail
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx550_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx550_pos, rx550_off
    substr $S10, rx550_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx550_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."postcircumfix"()
    unless $P10, rx550_fail
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx550_pos = $P10."pos"()
    goto alt556_end
  alt556_2:
.annotate 'line', 279
  # rx subcapture "sigil"
    set_addr $I10, rxcap_559_fail
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  # rx literal  "$"
    add $I11, rx550_pos, 1
    gt $I11, rx550_eos, rx550_fail
    sub $I11, rx550_pos, rx550_off
    ord $I11, rx550_tgt, $I11
    ne $I11, 36, rx550_fail
    add rx550_pos, 1
    set_addr $I10, rxcap_559_fail
    ($I12, $I11) = rx550_cur."!mark_peek"($I10)
    rx550_cur."!cursor_pos"($I11)
    ($P10) = rx550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx550_pos, "")
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_559_done
  rxcap_559_fail:
    goto rx550_fail
  rxcap_559_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_560_fail
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx550_pos, rx550_eos, rx550_fail
    sub $I10, rx550_pos, rx550_off
    substr $S10, rx550_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx550_fail
    inc rx550_pos
    set_addr $I10, rxcap_560_fail
    ($I12, $I11) = rx550_cur."!mark_peek"($I10)
    rx550_cur."!cursor_pos"($I11)
    ($P10) = rx550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx550_pos, "")
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_560_done
  rxcap_560_fail:
    goto rx550_fail
  rxcap_560_done:
  alt556_end:
.annotate 'line', 276
  # rx pass
    rx550_cur."!cursor_pass"(rx550_pos, "variable")
    if_null rx550_debug, debug_655
    rx550_cur."!cursor_debug"("PASS", "variable", " at pos=", rx550_pos)
  debug_655:
    .return (rx550_cur)
  rx550_restart:
.annotate 'line', 4
    if_null rx550_debug, debug_656
    rx550_cur."!cursor_debug"("NEXT", "variable")
  debug_656:
  rx550_fail:
    (rx550_rep, rx550_pos, $I10, $P10) = rx550_cur."!mark_fail"(0)
    lt rx550_pos, -1, rx550_done
    eq rx550_pos, -1, rx550_fail
    jump $I10
  rx550_done:
    rx550_cur."!cursor_fail"()
    if_null rx550_debug, debug_657
    rx550_cur."!cursor_debug"("FAIL", "variable")
  debug_657:
    .return (rx550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("128_1299465717.405") :method
.annotate 'line', 4
    $P552 = self."!PREFIX__!subrule"("sigil", "")
    $P553 = self."!PREFIX__!subrule"("sigil", "")
    new $P554, "ResizablePMCArray"
    push $P554, "$!"
    push $P554, "$_"
    push $P554, "$/"
    push $P554, $P552
    push $P554, $P553
    .return ($P554)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("129_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx562_tgt
    .local int rx562_pos
    .local int rx562_off
    .local int rx562_eos
    .local int rx562_rep
    .local pmc rx562_cur
    .local pmc rx562_debug
    (rx562_cur, rx562_pos, rx562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx562_cur
    .local pmc match
    .lex "$/", match
    length rx562_eos, rx562_tgt
    gt rx562_pos, rx562_eos, rx562_done
    set rx562_off, 0
    lt rx562_pos, 2, rx562_start
    sub rx562_off, rx562_pos, 1
    substr rx562_tgt, rx562_tgt, rx562_off
  rx562_start:
    eq $I10, 1, rx562_restart
    if_null rx562_debug, debug_658
    rx562_cur."!cursor_debug"("START", "sigil")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan565_done
    goto rxscan565_scan
  rxscan565_loop:
    (rx562_pos) = rx562_cur."from"()
    inc rx562_pos
    rx562_cur."!cursor_from"(rx562_pos)
    ge rx562_pos, rx562_eos, rxscan565_done
  rxscan565_scan:
    set_addr $I10, rxscan565_loop
    rx562_cur."!mark_push"(0, rx562_pos, $I10)
  rxscan565_done:
.annotate 'line', 282
  # rx enumcharlist negate=0 
    ge rx562_pos, rx562_eos, rx562_fail
    sub $I10, rx562_pos, rx562_off
    substr $S10, rx562_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx562_fail
    inc rx562_pos
  # rx pass
    rx562_cur."!cursor_pass"(rx562_pos, "sigil")
    if_null rx562_debug, debug_659
    rx562_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx562_pos)
  debug_659:
    .return (rx562_cur)
  rx562_restart:
.annotate 'line', 4
    if_null rx562_debug, debug_660
    rx562_cur."!cursor_debug"("NEXT", "sigil")
  debug_660:
  rx562_fail:
    (rx562_rep, rx562_pos, $I10, $P10) = rx562_cur."!mark_fail"(0)
    lt rx562_pos, -1, rx562_done
    eq rx562_pos, -1, rx562_fail
    jump $I10
  rx562_done:
    rx562_cur."!cursor_fail"()
    if_null rx562_debug, debug_661
    rx562_cur."!cursor_debug"("FAIL", "sigil")
  debug_661:
    .return (rx562_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("130_1299465717.405") :method
.annotate 'line', 4
    new $P564, "ResizablePMCArray"
    push $P564, "&"
    push $P564, "%"
    push $P564, "@"
    push $P564, "$"
    .return ($P564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("131_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx567_tgt
    .local int rx567_pos
    .local int rx567_off
    .local int rx567_eos
    .local int rx567_rep
    .local pmc rx567_cur
    .local pmc rx567_debug
    (rx567_cur, rx567_pos, rx567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx567_cur
    .local pmc match
    .lex "$/", match
    length rx567_eos, rx567_tgt
    gt rx567_pos, rx567_eos, rx567_done
    set rx567_off, 0
    lt rx567_pos, 2, rx567_start
    sub rx567_off, rx567_pos, 1
    substr rx567_tgt, rx567_tgt, rx567_off
  rx567_start:
    eq $I10, 1, rx567_restart
    if_null rx567_debug, debug_662
    rx567_cur."!cursor_debug"("START", "twigil")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan570_done
    goto rxscan570_scan
  rxscan570_loop:
    (rx567_pos) = rx567_cur."from"()
    inc rx567_pos
    rx567_cur."!cursor_from"(rx567_pos)
    ge rx567_pos, rx567_eos, rxscan570_done
  rxscan570_scan:
    set_addr $I10, rxscan570_loop
    rx567_cur."!mark_push"(0, rx567_pos, $I10)
  rxscan570_done:
.annotate 'line', 284
  # rx enumcharlist negate=0 
    ge rx567_pos, rx567_eos, rx567_fail
    sub $I10, rx567_pos, rx567_off
    substr $S10, rx567_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx567_fail
    inc rx567_pos
  # rx pass
    rx567_cur."!cursor_pass"(rx567_pos, "twigil")
    if_null rx567_debug, debug_663
    rx567_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx567_pos)
  debug_663:
    .return (rx567_cur)
  rx567_restart:
.annotate 'line', 4
    if_null rx567_debug, debug_664
    rx567_cur."!cursor_debug"("NEXT", "twigil")
  debug_664:
  rx567_fail:
    (rx567_rep, rx567_pos, $I10, $P10) = rx567_cur."!mark_fail"(0)
    lt rx567_pos, -1, rx567_done
    eq rx567_pos, -1, rx567_fail
    jump $I10
  rx567_done:
    rx567_cur."!cursor_fail"()
    if_null rx567_debug, debug_665
    rx567_cur."!cursor_debug"("FAIL", "twigil")
  debug_665:
    .return (rx567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("132_1299465717.405") :method
.annotate 'line', 4
    new $P569, "ResizablePMCArray"
    push $P569, "?"
    push $P569, "!"
    push $P569, "*"
    .return ($P569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("133_1299465717.405")
    .param pmc param_572
.annotate 'line', 286
    .lex "self", param_572
    $P573 = param_572."!protoregex"("package_declarator")
    .return ($P573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("134_1299465717.405")
    .param pmc param_575
.annotate 'line', 286
    .lex "self", param_575
    $P576 = param_575."!PREFIX__!protoregex"("package_declarator")
    .return ($P576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("135_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 288
    new $P578, "Undef"
    .lex "$*PACKAGE-SETUP", $P578
.annotate 'line', 289
    new $P579, "Undef"
    .lex "$*PKGDECL", $P579
.annotate 'line', 4
    .local string rx580_tgt
    .local int rx580_pos
    .local int rx580_off
    .local int rx580_eos
    .local int rx580_rep
    .local pmc rx580_cur
    .local pmc rx580_debug
    (rx580_cur, rx580_pos, rx580_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx580_cur
    .local pmc match
    .lex "$/", match
    length rx580_eos, rx580_tgt
    gt rx580_pos, rx580_eos, rx580_done
    set rx580_off, 0
    lt rx580_pos, 2, rx580_start
    sub rx580_off, rx580_pos, 1
    substr rx580_tgt, rx580_tgt, rx580_off
  rx580_start:
    eq $I10, 1, rx580_restart
    if_null rx580_debug, debug_666
    rx580_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan584_done
    goto rxscan584_scan
  rxscan584_loop:
    (rx580_pos) = rx580_cur."from"()
    inc rx580_pos
    rx580_cur."!cursor_from"(rx580_pos)
    ge rx580_pos, rx580_eos, rxscan584_done
  rxscan584_scan:
    set_addr $I10, rxscan584_loop
    rx580_cur."!mark_push"(0, rx580_pos, $I10)
  rxscan584_done:
.annotate 'line', 288
    rx580_cur."!cursor_pos"(rx580_pos)
    get_hll_global $P585, ["PAST"], "Stmts"
    $P586 = $P585."new"()
    store_lex "$*PACKAGE-SETUP", $P586
.annotate 'line', 289
    rx580_cur."!cursor_pos"(rx580_pos)
    new $P587, "String"
    assign $P587, "module"
    store_lex "$*PKGDECL", $P587
.annotate 'line', 290
  # rx subcapture "sym"
    set_addr $I10, rxcap_588_fail
    rx580_cur."!mark_push"(0, rx580_pos, $I10)
  # rx literal  "module"
    add $I11, rx580_pos, 6
    gt $I11, rx580_eos, rx580_fail
    sub $I11, rx580_pos, rx580_off
    substr $S10, rx580_tgt, $I11, 6
    ne $S10, "module", rx580_fail
    add rx580_pos, 6
    set_addr $I10, rxcap_588_fail
    ($I12, $I11) = rx580_cur."!mark_peek"($I10)
    rx580_cur."!cursor_pos"($I11)
    ($P10) = rx580_cur."!cursor_start"()
    $P10."!cursor_pass"(rx580_pos, "")
    rx580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_588_done
  rxcap_588_fail:
    goto rx580_fail
  rxcap_588_done:
  # rx subrule "package_def" subtype=capture negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."package_def"()
    unless $P10, rx580_fail
    rx580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx580_pos = $P10."pos"()
.annotate 'line', 287
  # rx pass
    rx580_cur."!cursor_pass"(rx580_pos, "package_declarator:sym<module>")
    if_null rx580_debug, debug_667
    rx580_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx580_pos)
  debug_667:
    .return (rx580_cur)
  rx580_restart:
.annotate 'line', 4
    if_null rx580_debug, debug_668
    rx580_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_668:
  rx580_fail:
    (rx580_rep, rx580_pos, $I10, $P10) = rx580_cur."!mark_fail"(0)
    lt rx580_pos, -1, rx580_done
    eq rx580_pos, -1, rx580_fail
    jump $I10
  rx580_done:
    rx580_cur."!cursor_fail"()
    if_null rx580_debug, debug_669
    rx580_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_669:
    .return (rx580_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("136_1299465717.405") :method
.annotate 'line', 4
    $P582 = self."!PREFIX__!subrule"("package_def", "module")
    new $P583, "ResizablePMCArray"
    push $P583, $P582
    .return ($P583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("137_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 293
    new $P590, "Undef"
    .lex "$*PACKAGE-SETUP", $P590
.annotate 'line', 294
    new $P591, "Undef"
    .lex "$*PKGDECL", $P591
.annotate 'line', 4
    .local string rx592_tgt
    .local int rx592_pos
    .local int rx592_off
    .local int rx592_eos
    .local int rx592_rep
    .local pmc rx592_cur
    .local pmc rx592_debug
    (rx592_cur, rx592_pos, rx592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx592_cur
    .local pmc match
    .lex "$/", match
    length rx592_eos, rx592_tgt
    gt rx592_pos, rx592_eos, rx592_done
    set rx592_off, 0
    lt rx592_pos, 2, rx592_start
    sub rx592_off, rx592_pos, 1
    substr rx592_tgt, rx592_tgt, rx592_off
  rx592_start:
    eq $I10, 1, rx592_restart
    if_null rx592_debug, debug_670
    rx592_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan596_done
    goto rxscan596_scan
  rxscan596_loop:
    (rx592_pos) = rx592_cur."from"()
    inc rx592_pos
    rx592_cur."!cursor_from"(rx592_pos)
    ge rx592_pos, rx592_eos, rxscan596_done
  rxscan596_scan:
    set_addr $I10, rxscan596_loop
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  rxscan596_done:
.annotate 'line', 293
    rx592_cur."!cursor_pos"(rx592_pos)
    get_hll_global $P597, ["PAST"], "Stmts"
    $P598 = $P597."new"()
    store_lex "$*PACKAGE-SETUP", $P598
.annotate 'line', 294
    rx592_cur."!cursor_pos"(rx592_pos)
    new $P599, "String"
    assign $P599, "knowhow"
    store_lex "$*PKGDECL", $P599
.annotate 'line', 295
  # rx subcapture "sym"
    set_addr $I10, rxcap_600_fail
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx592_pos, 7
    gt $I11, rx592_eos, rx592_fail
    sub $I11, rx592_pos, rx592_off
    substr $S10, rx592_tgt, $I11, 7
    ne $S10, "knowhow", rx592_fail
    add rx592_pos, 7
    set_addr $I10, rxcap_600_fail
    ($I12, $I11) = rx592_cur."!mark_peek"($I10)
    rx592_cur."!cursor_pos"($I11)
    ($P10) = rx592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx592_pos, "")
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_600_done
  rxcap_600_fail:
    goto rx592_fail
  rxcap_600_done:
  # rx subrule "package_def" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."package_def"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx592_pos = $P10."pos"()
.annotate 'line', 292
  # rx pass
    rx592_cur."!cursor_pass"(rx592_pos, "package_declarator:sym<knowhow>")
    if_null rx592_debug, debug_671
    rx592_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx592_pos)
  debug_671:
    .return (rx592_cur)
  rx592_restart:
.annotate 'line', 4
    if_null rx592_debug, debug_672
    rx592_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_672:
  rx592_fail:
    (rx592_rep, rx592_pos, $I10, $P10) = rx592_cur."!mark_fail"(0)
    lt rx592_pos, -1, rx592_done
    eq rx592_pos, -1, rx592_fail
    jump $I10
  rx592_done:
    rx592_cur."!cursor_fail"()
    if_null rx592_debug, debug_673
    rx592_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_673:
    .return (rx592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("138_1299465717.405") :method
.annotate 'line', 4
    $P594 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P595, "ResizablePMCArray"
    push $P595, $P594
    .return ($P595)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("139_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 298
    new $P602, "Undef"
    .lex "$*PACKAGE-SETUP", $P602
.annotate 'line', 299
    new $P603, "Undef"
    .lex "$*PKGDECL", $P603
.annotate 'line', 4
    .local string rx604_tgt
    .local int rx604_pos
    .local int rx604_off
    .local int rx604_eos
    .local int rx604_rep
    .local pmc rx604_cur
    .local pmc rx604_debug
    (rx604_cur, rx604_pos, rx604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx604_cur
    .local pmc match
    .lex "$/", match
    length rx604_eos, rx604_tgt
    gt rx604_pos, rx604_eos, rx604_done
    set rx604_off, 0
    lt rx604_pos, 2, rx604_start
    sub rx604_off, rx604_pos, 1
    substr rx604_tgt, rx604_tgt, rx604_off
  rx604_start:
    eq $I10, 1, rx604_restart
    if_null rx604_debug, debug_674
    rx604_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan608_done
    goto rxscan608_scan
  rxscan608_loop:
    (rx604_pos) = rx604_cur."from"()
    inc rx604_pos
    rx604_cur."!cursor_from"(rx604_pos)
    ge rx604_pos, rx604_eos, rxscan608_done
  rxscan608_scan:
    set_addr $I10, rxscan608_loop
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  rxscan608_done:
.annotate 'line', 298
    rx604_cur."!cursor_pos"(rx604_pos)
    get_hll_global $P609, ["PAST"], "Stmts"
    $P610 = $P609."new"()
    store_lex "$*PACKAGE-SETUP", $P610
.annotate 'line', 299
    rx604_cur."!cursor_pos"(rx604_pos)
    new $P611, "String"
    assign $P611, "class"
    store_lex "$*PKGDECL", $P611
.annotate 'line', 300
  # rx subcapture "sym"
    set_addr $I10, rxcap_612_fail
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  # rx literal  "class"
    add $I11, rx604_pos, 5
    gt $I11, rx604_eos, rx604_fail
    sub $I11, rx604_pos, rx604_off
    substr $S10, rx604_tgt, $I11, 5
    ne $S10, "class", rx604_fail
    add rx604_pos, 5
    set_addr $I10, rxcap_612_fail
    ($I12, $I11) = rx604_cur."!mark_peek"($I10)
    rx604_cur."!cursor_pos"($I11)
    ($P10) = rx604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx604_pos, "")
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_612_done
  rxcap_612_fail:
    goto rx604_fail
  rxcap_612_done:
  # rx subrule "package_def" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."package_def"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx604_pos = $P10."pos"()
.annotate 'line', 297
  # rx pass
    rx604_cur."!cursor_pass"(rx604_pos, "package_declarator:sym<class>")
    if_null rx604_debug, debug_675
    rx604_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx604_pos)
  debug_675:
    .return (rx604_cur)
  rx604_restart:
.annotate 'line', 4
    if_null rx604_debug, debug_676
    rx604_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_676:
  rx604_fail:
    (rx604_rep, rx604_pos, $I10, $P10) = rx604_cur."!mark_fail"(0)
    lt rx604_pos, -1, rx604_done
    eq rx604_pos, -1, rx604_fail
    jump $I10
  rx604_done:
    rx604_cur."!cursor_fail"()
    if_null rx604_debug, debug_677
    rx604_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_677:
    .return (rx604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("140_1299465717.405") :method
.annotate 'line', 4
    $P606 = self."!PREFIX__!subrule"("package_def", "class")
    new $P607, "ResizablePMCArray"
    push $P607, $P606
    .return ($P607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("141_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 303
    new $P614, "Undef"
    .lex "$*PACKAGE-SETUP", $P614
.annotate 'line', 304
    new $P615, "Undef"
    .lex "$*PKGDECL", $P615
.annotate 'line', 4
    .local string rx616_tgt
    .local int rx616_pos
    .local int rx616_off
    .local int rx616_eos
    .local int rx616_rep
    .local pmc rx616_cur
    .local pmc rx616_debug
    (rx616_cur, rx616_pos, rx616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx616_cur
    .local pmc match
    .lex "$/", match
    length rx616_eos, rx616_tgt
    gt rx616_pos, rx616_eos, rx616_done
    set rx616_off, 0
    lt rx616_pos, 2, rx616_start
    sub rx616_off, rx616_pos, 1
    substr rx616_tgt, rx616_tgt, rx616_off
  rx616_start:
    eq $I10, 1, rx616_restart
    if_null rx616_debug, debug_678
    rx616_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan620_done
    goto rxscan620_scan
  rxscan620_loop:
    (rx616_pos) = rx616_cur."from"()
    inc rx616_pos
    rx616_cur."!cursor_from"(rx616_pos)
    ge rx616_pos, rx616_eos, rxscan620_done
  rxscan620_scan:
    set_addr $I10, rxscan620_loop
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  rxscan620_done:
.annotate 'line', 303
    rx616_cur."!cursor_pos"(rx616_pos)
    get_hll_global $P621, ["PAST"], "Stmts"
    $P622 = $P621."new"()
    store_lex "$*PACKAGE-SETUP", $P622
.annotate 'line', 304
    rx616_cur."!cursor_pos"(rx616_pos)
    new $P623, "String"
    assign $P623, "grammar"
    store_lex "$*PKGDECL", $P623
.annotate 'line', 305
  # rx subcapture "sym"
    set_addr $I10, rxcap_624_fail
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx616_pos, 7
    gt $I11, rx616_eos, rx616_fail
    sub $I11, rx616_pos, rx616_off
    substr $S10, rx616_tgt, $I11, 7
    ne $S10, "grammar", rx616_fail
    add rx616_pos, 7
    set_addr $I10, rxcap_624_fail
    ($I12, $I11) = rx616_cur."!mark_peek"($I10)
    rx616_cur."!cursor_pos"($I11)
    ($P10) = rx616_cur."!cursor_start"()
    $P10."!cursor_pass"(rx616_pos, "")
    rx616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_624_done
  rxcap_624_fail:
    goto rx616_fail
  rxcap_624_done:
  # rx subrule "package_def" subtype=capture negate=
    rx616_cur."!cursor_pos"(rx616_pos)
    $P10 = rx616_cur."package_def"()
    unless $P10, rx616_fail
    rx616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx616_pos = $P10."pos"()
.annotate 'line', 302
  # rx pass
    rx616_cur."!cursor_pass"(rx616_pos, "package_declarator:sym<grammar>")
    if_null rx616_debug, debug_679
    rx616_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx616_pos)
  debug_679:
    .return (rx616_cur)
  rx616_restart:
.annotate 'line', 4
    if_null rx616_debug, debug_680
    rx616_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_680:
  rx616_fail:
    (rx616_rep, rx616_pos, $I10, $P10) = rx616_cur."!mark_fail"(0)
    lt rx616_pos, -1, rx616_done
    eq rx616_pos, -1, rx616_fail
    jump $I10
  rx616_done:
    rx616_cur."!cursor_fail"()
    if_null rx616_debug, debug_681
    rx616_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_681:
    .return (rx616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("142_1299465717.405") :method
.annotate 'line', 4
    $P618 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P619, "ResizablePMCArray"
    push $P619, $P618
    .return ($P619)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("143_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 308
    new $P626, "Undef"
    .lex "$*PACKAGE-SETUP", $P626
.annotate 'line', 309
    new $P627, "Undef"
    .lex "$*PKGDECL", $P627
.annotate 'line', 4
    .local string rx628_tgt
    .local int rx628_pos
    .local int rx628_off
    .local int rx628_eos
    .local int rx628_rep
    .local pmc rx628_cur
    .local pmc rx628_debug
    (rx628_cur, rx628_pos, rx628_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx628_cur
    .local pmc match
    .lex "$/", match
    length rx628_eos, rx628_tgt
    gt rx628_pos, rx628_eos, rx628_done
    set rx628_off, 0
    lt rx628_pos, 2, rx628_start
    sub rx628_off, rx628_pos, 1
    substr rx628_tgt, rx628_tgt, rx628_off
  rx628_start:
    eq $I10, 1, rx628_restart
    if_null rx628_debug, debug_682
    rx628_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan632_done
    goto rxscan632_scan
  rxscan632_loop:
    (rx628_pos) = rx628_cur."from"()
    inc rx628_pos
    rx628_cur."!cursor_from"(rx628_pos)
    ge rx628_pos, rx628_eos, rxscan632_done
  rxscan632_scan:
    set_addr $I10, rxscan632_loop
    rx628_cur."!mark_push"(0, rx628_pos, $I10)
  rxscan632_done:
.annotate 'line', 308
    rx628_cur."!cursor_pos"(rx628_pos)
    get_hll_global $P633, ["PAST"], "Stmts"
    $P634 = $P633."new"()
    store_lex "$*PACKAGE-SETUP", $P634
.annotate 'line', 309
    rx628_cur."!cursor_pos"(rx628_pos)
    new $P635, "String"
    assign $P635, "role"
    store_lex "$*PKGDECL", $P635
.annotate 'line', 310
  # rx subcapture "sym"
    set_addr $I10, rxcap_636_fail
    rx628_cur."!mark_push"(0, rx628_pos, $I10)
  # rx literal  "role"
    add $I11, rx628_pos, 4
    gt $I11, rx628_eos, rx628_fail
    sub $I11, rx628_pos, rx628_off
    substr $S10, rx628_tgt, $I11, 4
    ne $S10, "role", rx628_fail
    add rx628_pos, 4
    set_addr $I10, rxcap_636_fail
    ($I12, $I11) = rx628_cur."!mark_peek"($I10)
    rx628_cur."!cursor_pos"($I11)
    ($P10) = rx628_cur."!cursor_start"()
    $P10."!cursor_pass"(rx628_pos, "")
    rx628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_636_done
  rxcap_636_fail:
    goto rx628_fail
  rxcap_636_done:
  # rx subrule "package_def" subtype=capture negate=
    rx628_cur."!cursor_pos"(rx628_pos)
    $P10 = rx628_cur."package_def"()
    unless $P10, rx628_fail
    rx628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx628_pos = $P10."pos"()
.annotate 'line', 307
  # rx pass
    rx628_cur."!cursor_pass"(rx628_pos, "package_declarator:sym<role>")
    if_null rx628_debug, debug_683
    rx628_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx628_pos)
  debug_683:
    .return (rx628_cur)
  rx628_restart:
.annotate 'line', 4
    if_null rx628_debug, debug_684
    rx628_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_684:
  rx628_fail:
    (rx628_rep, rx628_pos, $I10, $P10) = rx628_cur."!mark_fail"(0)
    lt rx628_pos, -1, rx628_done
    eq rx628_pos, -1, rx628_fail
    jump $I10
  rx628_done:
    rx628_cur."!cursor_fail"()
    if_null rx628_debug, debug_685
    rx628_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_685:
    .return (rx628_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("144_1299465717.405") :method
.annotate 'line', 4
    $P630 = self."!PREFIX__!subrule"("package_def", "role")
    new $P631, "ResizablePMCArray"
    push $P631, $P630
    .return ($P631)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("145_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 313
    new $P638, "Undef"
    .lex "$*PACKAGE-SETUP", $P638
.annotate 'line', 314
    new $P639, "Undef"
    .lex "$*PKGDECL", $P639
.annotate 'line', 4
    .local string rx640_tgt
    .local int rx640_pos
    .local int rx640_off
    .local int rx640_eos
    .local int rx640_rep
    .local pmc rx640_cur
    .local pmc rx640_debug
    (rx640_cur, rx640_pos, rx640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx640_cur
    .local pmc match
    .lex "$/", match
    length rx640_eos, rx640_tgt
    gt rx640_pos, rx640_eos, rx640_done
    set rx640_off, 0
    lt rx640_pos, 2, rx640_start
    sub rx640_off, rx640_pos, 1
    substr rx640_tgt, rx640_tgt, rx640_off
  rx640_start:
    eq $I10, 1, rx640_restart
    if_null rx640_debug, debug_686
    rx640_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan644_done
    goto rxscan644_scan
  rxscan644_loop:
    (rx640_pos) = rx640_cur."from"()
    inc rx640_pos
    rx640_cur."!cursor_from"(rx640_pos)
    ge rx640_pos, rx640_eos, rxscan644_done
  rxscan644_scan:
    set_addr $I10, rxscan644_loop
    rx640_cur."!mark_push"(0, rx640_pos, $I10)
  rxscan644_done:
.annotate 'line', 313
    rx640_cur."!cursor_pos"(rx640_pos)
    get_hll_global $P645, ["PAST"], "Stmts"
    $P646 = $P645."new"()
    store_lex "$*PACKAGE-SETUP", $P646
.annotate 'line', 314
    rx640_cur."!cursor_pos"(rx640_pos)
    new $P647, "String"
    assign $P647, "native"
    store_lex "$*PKGDECL", $P647
.annotate 'line', 315
  # rx subcapture "sym"
    set_addr $I10, rxcap_648_fail
    rx640_cur."!mark_push"(0, rx640_pos, $I10)
  # rx literal  "native"
    add $I11, rx640_pos, 6
    gt $I11, rx640_eos, rx640_fail
    sub $I11, rx640_pos, rx640_off
    substr $S10, rx640_tgt, $I11, 6
    ne $S10, "native", rx640_fail
    add rx640_pos, 6
    set_addr $I10, rxcap_648_fail
    ($I12, $I11) = rx640_cur."!mark_peek"($I10)
    rx640_cur."!cursor_pos"($I11)
    ($P10) = rx640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx640_pos, "")
    rx640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_648_done
  rxcap_648_fail:
    goto rx640_fail
  rxcap_648_done:
  # rx subrule "package_def" subtype=capture negate=
    rx640_cur."!cursor_pos"(rx640_pos)
    $P10 = rx640_cur."package_def"()
    unless $P10, rx640_fail
    rx640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx640_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx640_cur."!cursor_pass"(rx640_pos, "package_declarator:sym<native>")
    if_null rx640_debug, debug_687
    rx640_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx640_pos)
  debug_687:
    .return (rx640_cur)
  rx640_restart:
.annotate 'line', 4
    if_null rx640_debug, debug_688
    rx640_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_688:
  rx640_fail:
    (rx640_rep, rx640_pos, $I10, $P10) = rx640_cur."!mark_fail"(0)
    lt rx640_pos, -1, rx640_done
    eq rx640_pos, -1, rx640_fail
    jump $I10
  rx640_done:
    rx640_cur."!cursor_fail"()
    if_null rx640_debug, debug_689
    rx640_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_689:
    .return (rx640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("146_1299465717.405") :method
.annotate 'line', 4
    $P642 = self."!PREFIX__!subrule"("package_def", "native")
    new $P643, "ResizablePMCArray"
    push $P643, $P642
    .return ($P643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("147_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx650_tgt
    .local int rx650_pos
    .local int rx650_off
    .local int rx650_eos
    .local int rx650_rep
    .local pmc rx650_cur
    .local pmc rx650_debug
    (rx650_cur, rx650_pos, rx650_tgt, $I10) = self."!cursor_start"()
    rx650_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx650_cur
    .local pmc match
    .lex "$/", match
    length rx650_eos, rx650_tgt
    gt rx650_pos, rx650_eos, rx650_done
    set rx650_off, 0
    lt rx650_pos, 2, rx650_start
    sub rx650_off, rx650_pos, 1
    substr rx650_tgt, rx650_tgt, rx650_off
  rx650_start:
    eq $I10, 1, rx650_restart
    if_null rx650_debug, debug_690
    rx650_cur."!cursor_debug"("START", "package_def")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan654_done
    goto rxscan654_scan
  rxscan654_loop:
    (rx650_pos) = rx650_cur."from"()
    inc rx650_pos
    rx650_cur."!cursor_from"(rx650_pos)
    ge rx650_pos, rx650_eos, rxscan654_done
  rxscan654_scan:
    set_addr $I10, rxscan654_loop
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxscan654_done:
.annotate 'line', 318
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
.annotate 'line', 319
  # rx subrule "name" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."name"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx650_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
.annotate 'line', 320
  # rx rxquantr657 ** 0..1
    set_addr $I10, rxquantr657_done
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxquantr657_loop:
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx650_pos, 2
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    substr $S10, rx650_tgt, $I11, 2
    ne $S10, "is", rx650_fail
    add rx650_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx650_pos, 5
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    substr $S10, rx650_tgt, $I11, 5
    ne $S10, "repr(", rx650_fail
    add rx650_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."quote_EXPR"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx650_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx650_pos, 1
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    ord $I11, rx650_tgt, $I11
    ne $I11, 41, rx650_fail
    add rx650_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
    set_addr $I10, rxquantr657_done
    (rx650_rep) = rx650_cur."!mark_commit"($I10)
  rxquantr657_done:
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
.annotate 'line', 321
  # rx rxquantr664 ** 0..1
    set_addr $I10, rxquantr664_done
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxquantr664_loop:
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx650_pos, 2
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    substr $S10, rx650_tgt, $I11, 2
    ne $S10, "is", rx650_fail
    add rx650_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."name"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx650_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
    set_addr $I10, rxquantr664_done
    (rx650_rep) = rx650_cur."!mark_commit"($I10)
  rxquantr664_done:
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
.annotate 'line', 322
  # rx rxquantr669 ** 0..*
    set_addr $I10, rxquantr669_done
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxquantr669_loop:
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx650_pos, 4
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    substr $S10, rx650_tgt, $I11, 4
    ne $S10, "does", rx650_fail
    add rx650_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."name"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx650_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
    set_addr $I10, rxquantr669_done
    (rx650_rep) = rx650_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr669_done
    rx650_cur."!mark_push"(rx650_rep, rx650_pos, $I10)
    goto rxquantr669_loop
  rxquantr669_done:
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  alt674_0:
.annotate 'line', 323
    set_addr $I10, alt674_1
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
.annotate 'line', 324
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx650_pos, 1
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    ord $I11, rx650_tgt, $I11
    ne $I11, 59, rx650_fail
    add rx650_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."comp_unit"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx650_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
    goto alt674_end
  alt674_1:
    set_addr $I10, alt674_2
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
.annotate 'line', 325
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx650_pos, rx650_off
    substr $S10, rx650_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx650_fail
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."block"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx650_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
    goto alt674_end
  alt674_2:
.annotate 'line', 326
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."panic"("Malformed package declaration")
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
  alt674_end:
.annotate 'line', 327
  # rx subrule "ws" subtype=method negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."ws"()
    unless $P10, rx650_fail
    rx650_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx650_cur."!cursor_pass"(rx650_pos, "package_def")
    if_null rx650_debug, debug_691
    rx650_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx650_pos)
  debug_691:
    .return (rx650_cur)
  rx650_restart:
.annotate 'line', 4
    if_null rx650_debug, debug_692
    rx650_cur."!cursor_debug"("NEXT", "package_def")
  debug_692:
  rx650_fail:
    (rx650_rep, rx650_pos, $I10, $P10) = rx650_cur."!mark_fail"(0)
    lt rx650_pos, -1, rx650_done
    eq rx650_pos, -1, rx650_fail
    jump $I10
  rx650_done:
    rx650_cur."!cursor_fail"()
    if_null rx650_debug, debug_693
    rx650_cur."!cursor_debug"("FAIL", "package_def")
  debug_693:
    .return (rx650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("148_1299465717.405") :method
.annotate 'line', 4
    $P652 = self."!PREFIX__!subrule"("ws", "")
    new $P653, "ResizablePMCArray"
    push $P653, $P652
    .return ($P653)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("149_1299465717.405")
    .param pmc param_685
.annotate 'line', 330
    .lex "self", param_685
    $P686 = param_685."!protoregex"("scope_declarator")
    .return ($P686)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("150_1299465717.405")
    .param pmc param_688
.annotate 'line', 330
    .lex "self", param_688
    $P689 = param_688."!PREFIX__!protoregex"("scope_declarator")
    .return ($P689)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("151_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx691_tgt
    .local int rx691_pos
    .local int rx691_off
    .local int rx691_eos
    .local int rx691_rep
    .local pmc rx691_cur
    .local pmc rx691_debug
    (rx691_cur, rx691_pos, rx691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx691_cur
    .local pmc match
    .lex "$/", match
    length rx691_eos, rx691_tgt
    gt rx691_pos, rx691_eos, rx691_done
    set rx691_off, 0
    lt rx691_pos, 2, rx691_start
    sub rx691_off, rx691_pos, 1
    substr rx691_tgt, rx691_tgt, rx691_off
  rx691_start:
    eq $I10, 1, rx691_restart
    if_null rx691_debug, debug_694
    rx691_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan695_done
    goto rxscan695_scan
  rxscan695_loop:
    (rx691_pos) = rx691_cur."from"()
    inc rx691_pos
    rx691_cur."!cursor_from"(rx691_pos)
    ge rx691_pos, rx691_eos, rxscan695_done
  rxscan695_scan:
    set_addr $I10, rxscan695_loop
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  rxscan695_done:
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_696_fail
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  # rx literal  "my"
    add $I11, rx691_pos, 2
    gt $I11, rx691_eos, rx691_fail
    sub $I11, rx691_pos, rx691_off
    substr $S10, rx691_tgt, $I11, 2
    ne $S10, "my", rx691_fail
    add rx691_pos, 2
    set_addr $I10, rxcap_696_fail
    ($I12, $I11) = rx691_cur."!mark_peek"($I10)
    rx691_cur."!cursor_pos"($I11)
    ($P10) = rx691_cur."!cursor_start"()
    $P10."!cursor_pass"(rx691_pos, "")
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_696_done
  rxcap_696_fail:
    goto rx691_fail
  rxcap_696_done:
  # rx subrule "scoped" subtype=capture negate=
    rx691_cur."!cursor_pos"(rx691_pos)
    $P10 = rx691_cur."scoped"("my")
    unless $P10, rx691_fail
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx691_pos = $P10."pos"()
  # rx pass
    rx691_cur."!cursor_pass"(rx691_pos, "scope_declarator:sym<my>")
    if_null rx691_debug, debug_695
    rx691_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx691_pos)
  debug_695:
    .return (rx691_cur)
  rx691_restart:
.annotate 'line', 4
    if_null rx691_debug, debug_696
    rx691_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_696:
  rx691_fail:
    (rx691_rep, rx691_pos, $I10, $P10) = rx691_cur."!mark_fail"(0)
    lt rx691_pos, -1, rx691_done
    eq rx691_pos, -1, rx691_fail
    jump $I10
  rx691_done:
    rx691_cur."!cursor_fail"()
    if_null rx691_debug, debug_697
    rx691_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_697:
    .return (rx691_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("152_1299465717.405") :method
.annotate 'line', 4
    $P693 = self."!PREFIX__!subrule"("scoped", "my")
    new $P694, "ResizablePMCArray"
    push $P694, $P693
    .return ($P694)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("153_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx698_tgt
    .local int rx698_pos
    .local int rx698_off
    .local int rx698_eos
    .local int rx698_rep
    .local pmc rx698_cur
    .local pmc rx698_debug
    (rx698_cur, rx698_pos, rx698_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx698_cur
    .local pmc match
    .lex "$/", match
    length rx698_eos, rx698_tgt
    gt rx698_pos, rx698_eos, rx698_done
    set rx698_off, 0
    lt rx698_pos, 2, rx698_start
    sub rx698_off, rx698_pos, 1
    substr rx698_tgt, rx698_tgt, rx698_off
  rx698_start:
    eq $I10, 1, rx698_restart
    if_null rx698_debug, debug_698
    rx698_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan702_done
    goto rxscan702_scan
  rxscan702_loop:
    (rx698_pos) = rx698_cur."from"()
    inc rx698_pos
    rx698_cur."!cursor_from"(rx698_pos)
    ge rx698_pos, rx698_eos, rxscan702_done
  rxscan702_scan:
    set_addr $I10, rxscan702_loop
    rx698_cur."!mark_push"(0, rx698_pos, $I10)
  rxscan702_done:
.annotate 'line', 332
  # rx subcapture "sym"
    set_addr $I10, rxcap_703_fail
    rx698_cur."!mark_push"(0, rx698_pos, $I10)
  # rx literal  "our"
    add $I11, rx698_pos, 3
    gt $I11, rx698_eos, rx698_fail
    sub $I11, rx698_pos, rx698_off
    substr $S10, rx698_tgt, $I11, 3
    ne $S10, "our", rx698_fail
    add rx698_pos, 3
    set_addr $I10, rxcap_703_fail
    ($I12, $I11) = rx698_cur."!mark_peek"($I10)
    rx698_cur."!cursor_pos"($I11)
    ($P10) = rx698_cur."!cursor_start"()
    $P10."!cursor_pass"(rx698_pos, "")
    rx698_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_703_done
  rxcap_703_fail:
    goto rx698_fail
  rxcap_703_done:
  # rx subrule "scoped" subtype=capture negate=
    rx698_cur."!cursor_pos"(rx698_pos)
    $P10 = rx698_cur."scoped"("our")
    unless $P10, rx698_fail
    rx698_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx698_pos = $P10."pos"()
  # rx pass
    rx698_cur."!cursor_pass"(rx698_pos, "scope_declarator:sym<our>")
    if_null rx698_debug, debug_699
    rx698_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx698_pos)
  debug_699:
    .return (rx698_cur)
  rx698_restart:
.annotate 'line', 4
    if_null rx698_debug, debug_700
    rx698_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_700:
  rx698_fail:
    (rx698_rep, rx698_pos, $I10, $P10) = rx698_cur."!mark_fail"(0)
    lt rx698_pos, -1, rx698_done
    eq rx698_pos, -1, rx698_fail
    jump $I10
  rx698_done:
    rx698_cur."!cursor_fail"()
    if_null rx698_debug, debug_701
    rx698_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_701:
    .return (rx698_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("154_1299465717.405") :method
.annotate 'line', 4
    $P700 = self."!PREFIX__!subrule"("scoped", "our")
    new $P701, "ResizablePMCArray"
    push $P701, $P700
    .return ($P701)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("155_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_702
    rx705_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan709_done
    goto rxscan709_scan
  rxscan709_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan709_done
  rxscan709_scan:
    set_addr $I10, rxscan709_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan709_done:
.annotate 'line', 333
  # rx subcapture "sym"
    set_addr $I10, rxcap_710_fail
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  # rx literal  "has"
    add $I11, rx705_pos, 3
    gt $I11, rx705_eos, rx705_fail
    sub $I11, rx705_pos, rx705_off
    substr $S10, rx705_tgt, $I11, 3
    ne $S10, "has", rx705_fail
    add rx705_pos, 3
    set_addr $I10, rxcap_710_fail
    ($I12, $I11) = rx705_cur."!mark_peek"($I10)
    rx705_cur."!cursor_pos"($I11)
    ($P10) = rx705_cur."!cursor_start"()
    $P10."!cursor_pass"(rx705_pos, "")
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_710_done
  rxcap_710_fail:
    goto rx705_fail
  rxcap_710_done:
  # rx subrule "scoped" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."scoped"("has")
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx705_pos = $P10."pos"()
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "scope_declarator:sym<has>")
    if_null rx705_debug, debug_703
    rx705_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx705_pos)
  debug_703:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 4
    if_null rx705_debug, debug_704
    rx705_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_704:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_705
    rx705_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_705:
    .return (rx705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("156_1299465717.405") :method
.annotate 'line', 4
    $P707 = self."!PREFIX__!subrule"("scoped", "has")
    new $P708, "ResizablePMCArray"
    push $P708, $P707
    .return ($P708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("157_1299465717.405") :method :outer("11_1299465717.405")
    .param pmc param_712
.annotate 'line', 335
    .lex "$*SCOPE", param_712
.annotate 'line', 4
    .local string rx713_tgt
    .local int rx713_pos
    .local int rx713_off
    .local int rx713_eos
    .local int rx713_rep
    .local pmc rx713_cur
    .local pmc rx713_debug
    (rx713_cur, rx713_pos, rx713_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx713_cur
    .local pmc match
    .lex "$/", match
    length rx713_eos, rx713_tgt
    gt rx713_pos, rx713_eos, rx713_done
    set rx713_off, 0
    lt rx713_pos, 2, rx713_start
    sub rx713_off, rx713_pos, 1
    substr rx713_tgt, rx713_tgt, rx713_off
  rx713_start:
    eq $I10, 1, rx713_restart
    if_null rx713_debug, debug_706
    rx713_cur."!cursor_debug"("START", "scoped")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan718_done
    goto rxscan718_scan
  rxscan718_loop:
    (rx713_pos) = rx713_cur."from"()
    inc rx713_pos
    rx713_cur."!cursor_from"(rx713_pos)
    ge rx713_pos, rx713_eos, rxscan718_done
  rxscan718_scan:
    set_addr $I10, rxscan718_loop
    rx713_cur."!mark_push"(0, rx713_pos, $I10)
  rxscan718_done:
  alt719_0:
.annotate 'line', 335
    set_addr $I10, alt719_1
    rx713_cur."!mark_push"(0, rx713_pos, $I10)
.annotate 'line', 336
  # rx subrule "ws" subtype=method negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."ws"()
    unless $P10, rx713_fail
    rx713_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."declarator"()
    unless $P10, rx713_fail
    rx713_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx713_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."ws"()
    unless $P10, rx713_fail
    rx713_pos = $P10."pos"()
    goto alt719_end
  alt719_1:
.annotate 'line', 337
  # rx subrule "ws" subtype=method negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."ws"()
    unless $P10, rx713_fail
    rx713_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."multi_declarator"()
    unless $P10, rx713_fail
    rx713_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx713_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."ws"()
    unless $P10, rx713_fail
    rx713_pos = $P10."pos"()
  alt719_end:
.annotate 'line', 335
  # rx pass
    rx713_cur."!cursor_pass"(rx713_pos, "scoped")
    if_null rx713_debug, debug_707
    rx713_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx713_pos)
  debug_707:
    .return (rx713_cur)
  rx713_restart:
.annotate 'line', 4
    if_null rx713_debug, debug_708
    rx713_cur."!cursor_debug"("NEXT", "scoped")
  debug_708:
  rx713_fail:
    (rx713_rep, rx713_pos, $I10, $P10) = rx713_cur."!mark_fail"(0)
    lt rx713_pos, -1, rx713_done
    eq rx713_pos, -1, rx713_fail
    jump $I10
  rx713_done:
    rx713_cur."!cursor_fail"()
    if_null rx713_debug, debug_709
    rx713_cur."!cursor_debug"("FAIL", "scoped")
  debug_709:
    .return (rx713_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("158_1299465717.405") :method
.annotate 'line', 4
    $P715 = self."!PREFIX__!subrule"("ws", "")
    $P716 = self."!PREFIX__!subrule"("ws", "")
    new $P717, "ResizablePMCArray"
    push $P717, $P715
    push $P717, $P716
    .return ($P717)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("159_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx725_tgt
    .local int rx725_pos
    .local int rx725_off
    .local int rx725_eos
    .local int rx725_rep
    .local pmc rx725_cur
    .local pmc rx725_debug
    (rx725_cur, rx725_pos, rx725_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx725_cur
    .local pmc match
    .lex "$/", match
    length rx725_eos, rx725_tgt
    gt rx725_pos, rx725_eos, rx725_done
    set rx725_off, 0
    lt rx725_pos, 2, rx725_start
    sub rx725_off, rx725_pos, 1
    substr rx725_tgt, rx725_tgt, rx725_off
  rx725_start:
    eq $I10, 1, rx725_restart
    if_null rx725_debug, debug_710
    rx725_cur."!cursor_debug"("START", "typename")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan729_done
    goto rxscan729_scan
  rxscan729_loop:
    (rx725_pos) = rx725_cur."from"()
    inc rx725_pos
    rx725_cur."!cursor_from"(rx725_pos)
    ge rx725_pos, rx725_eos, rxscan729_done
  rxscan729_scan:
    set_addr $I10, rxscan729_loop
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
  rxscan729_done:
.annotate 'line', 340
  # rx subrule "name" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."name"()
    unless $P10, rx725_fail
    rx725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx725_pos = $P10."pos"()
  # rx pass
    rx725_cur."!cursor_pass"(rx725_pos, "typename")
    if_null rx725_debug, debug_711
    rx725_cur."!cursor_debug"("PASS", "typename", " at pos=", rx725_pos)
  debug_711:
    .return (rx725_cur)
  rx725_restart:
.annotate 'line', 4
    if_null rx725_debug, debug_712
    rx725_cur."!cursor_debug"("NEXT", "typename")
  debug_712:
  rx725_fail:
    (rx725_rep, rx725_pos, $I10, $P10) = rx725_cur."!mark_fail"(0)
    lt rx725_pos, -1, rx725_done
    eq rx725_pos, -1, rx725_fail
    jump $I10
  rx725_done:
    rx725_cur."!cursor_fail"()
    if_null rx725_debug, debug_713
    rx725_cur."!cursor_debug"("FAIL", "typename")
  debug_713:
    .return (rx725_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("160_1299465717.405") :method
.annotate 'line', 4
    $P727 = self."!PREFIX__!subrule"("name", "")
    new $P728, "ResizablePMCArray"
    push $P728, $P727
    .return ($P728)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("161_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx731_tgt
    .local int rx731_pos
    .local int rx731_off
    .local int rx731_eos
    .local int rx731_rep
    .local pmc rx731_cur
    .local pmc rx731_debug
    (rx731_cur, rx731_pos, rx731_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx731_cur
    .local pmc match
    .lex "$/", match
    length rx731_eos, rx731_tgt
    gt rx731_pos, rx731_eos, rx731_done
    set rx731_off, 0
    lt rx731_pos, 2, rx731_start
    sub rx731_off, rx731_pos, 1
    substr rx731_tgt, rx731_tgt, rx731_off
  rx731_start:
    eq $I10, 1, rx731_restart
    if_null rx731_debug, debug_714
    rx731_cur."!cursor_debug"("START", "declarator")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan736_done
    goto rxscan736_scan
  rxscan736_loop:
    (rx731_pos) = rx731_cur."from"()
    inc rx731_pos
    rx731_cur."!cursor_from"(rx731_pos)
    ge rx731_pos, rx731_eos, rxscan736_done
  rxscan736_scan:
    set_addr $I10, rxscan736_loop
    rx731_cur."!mark_push"(0, rx731_pos, $I10)
  rxscan736_done:
  alt737_0:
.annotate 'line', 342
    set_addr $I10, alt737_1
    rx731_cur."!mark_push"(0, rx731_pos, $I10)
.annotate 'line', 343
  # rx subrule "variable_declarator" subtype=capture negate=
    rx731_cur."!cursor_pos"(rx731_pos)
    $P10 = rx731_cur."variable_declarator"()
    unless $P10, rx731_fail
    rx731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx731_pos = $P10."pos"()
    goto alt737_end
  alt737_1:
.annotate 'line', 344
  # rx subrule "routine_declarator" subtype=capture negate=
    rx731_cur."!cursor_pos"(rx731_pos)
    $P10 = rx731_cur."routine_declarator"()
    unless $P10, rx731_fail
    rx731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx731_pos = $P10."pos"()
  alt737_end:
.annotate 'line', 342
  # rx pass
    rx731_cur."!cursor_pass"(rx731_pos, "declarator")
    if_null rx731_debug, debug_715
    rx731_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx731_pos)
  debug_715:
    .return (rx731_cur)
  rx731_restart:
.annotate 'line', 4
    if_null rx731_debug, debug_716
    rx731_cur."!cursor_debug"("NEXT", "declarator")
  debug_716:
  rx731_fail:
    (rx731_rep, rx731_pos, $I10, $P10) = rx731_cur."!mark_fail"(0)
    lt rx731_pos, -1, rx731_done
    eq rx731_pos, -1, rx731_fail
    jump $I10
  rx731_done:
    rx731_cur."!cursor_fail"()
    if_null rx731_debug, debug_717
    rx731_cur."!cursor_debug"("FAIL", "declarator")
  debug_717:
    .return (rx731_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("162_1299465717.405") :method
.annotate 'line', 4
    $P733 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P734 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P735, "ResizablePMCArray"
    push $P735, $P733
    push $P735, $P734
    .return ($P735)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("163_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx739_tgt
    .local int rx739_pos
    .local int rx739_off
    .local int rx739_eos
    .local int rx739_rep
    .local pmc rx739_cur
    .local pmc rx739_debug
    (rx739_cur, rx739_pos, rx739_tgt, $I10) = self."!cursor_start"()
    rx739_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx739_cur
    .local pmc match
    .lex "$/", match
    length rx739_eos, rx739_tgt
    gt rx739_pos, rx739_eos, rx739_done
    set rx739_off, 0
    lt rx739_pos, 2, rx739_start
    sub rx739_off, rx739_pos, 1
    substr rx739_tgt, rx739_tgt, rx739_off
  rx739_start:
    eq $I10, 1, rx739_restart
    if_null rx739_debug, debug_718
    rx739_cur."!cursor_debug"("START", "variable_declarator")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan743_done
    goto rxscan743_scan
  rxscan743_loop:
    (rx739_pos) = rx739_cur."from"()
    inc rx739_pos
    rx739_cur."!cursor_from"(rx739_pos)
    ge rx739_pos, rx739_eos, rxscan743_done
  rxscan743_scan:
    set_addr $I10, rxscan743_loop
    rx739_cur."!mark_push"(0, rx739_pos, $I10)
  rxscan743_done:
.annotate 'line', 347
  # rx subrule "ws" subtype=method negate=
    rx739_cur."!cursor_pos"(rx739_pos)
    $P10 = rx739_cur."ws"()
    unless $P10, rx739_fail
    rx739_pos = $P10."pos"()
  # rx rxquantr745 ** 0..1
    set_addr $I10, rxquantr745_done
    rx739_cur."!mark_push"(0, rx739_pos, $I10)
  rxquantr745_loop:
  # rx subrule "typename" subtype=capture negate=
    rx739_cur."!cursor_pos"(rx739_pos)
    $P10 = rx739_cur."typename"()
    unless $P10, rx739_fail
    goto rxsubrule746_pass
  rxsubrule746_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx739_fail
  rxsubrule746_pass:
    set_addr $I10, rxsubrule746_back
    rx739_cur."!mark_push"(0, rx739_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx739_pos = $P10."pos"()
    set_addr $I10, rxquantr745_done
    (rx739_rep) = rx739_cur."!mark_commit"($I10)
  rxquantr745_done:
  # rx subrule "ws" subtype=method negate=
    rx739_cur."!cursor_pos"(rx739_pos)
    $P10 = rx739_cur."ws"()
    unless $P10, rx739_fail
    rx739_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx739_cur."!cursor_pos"(rx739_pos)
    $P10 = rx739_cur."variable"()
    unless $P10, rx739_fail
    rx739_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx739_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx739_cur."!cursor_pos"(rx739_pos)
    $P10 = rx739_cur."ws"()
    unless $P10, rx739_fail
    rx739_pos = $P10."pos"()
  # rx pass
    rx739_cur."!cursor_pass"(rx739_pos, "variable_declarator")
    if_null rx739_debug, debug_719
    rx739_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx739_pos)
  debug_719:
    .return (rx739_cur)
  rx739_restart:
.annotate 'line', 4
    if_null rx739_debug, debug_720
    rx739_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_720:
  rx739_fail:
    (rx739_rep, rx739_pos, $I10, $P10) = rx739_cur."!mark_fail"(0)
    lt rx739_pos, -1, rx739_done
    eq rx739_pos, -1, rx739_fail
    jump $I10
  rx739_done:
    rx739_cur."!cursor_fail"()
    if_null rx739_debug, debug_721
    rx739_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_721:
    .return (rx739_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("164_1299465717.405") :method
.annotate 'line', 4
    $P741 = self."!PREFIX__!subrule"("ws", "")
    new $P742, "ResizablePMCArray"
    push $P742, $P741
    .return ($P742)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("165_1299465717.405")
    .param pmc param_750
.annotate 'line', 349
    .lex "self", param_750
    $P751 = param_750."!protoregex"("routine_declarator")
    .return ($P751)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("166_1299465717.405")
    .param pmc param_753
.annotate 'line', 349
    .lex "self", param_753
    $P754 = param_753."!PREFIX__!protoregex"("routine_declarator")
    .return ($P754)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("167_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx756_tgt
    .local int rx756_pos
    .local int rx756_off
    .local int rx756_eos
    .local int rx756_rep
    .local pmc rx756_cur
    .local pmc rx756_debug
    (rx756_cur, rx756_pos, rx756_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx756_cur
    .local pmc match
    .lex "$/", match
    length rx756_eos, rx756_tgt
    gt rx756_pos, rx756_eos, rx756_done
    set rx756_off, 0
    lt rx756_pos, 2, rx756_start
    sub rx756_off, rx756_pos, 1
    substr rx756_tgt, rx756_tgt, rx756_off
  rx756_start:
    eq $I10, 1, rx756_restart
    if_null rx756_debug, debug_722
    rx756_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan760_done
    goto rxscan760_scan
  rxscan760_loop:
    (rx756_pos) = rx756_cur."from"()
    inc rx756_pos
    rx756_cur."!cursor_from"(rx756_pos)
    ge rx756_pos, rx756_eos, rxscan760_done
  rxscan760_scan:
    set_addr $I10, rxscan760_loop
    rx756_cur."!mark_push"(0, rx756_pos, $I10)
  rxscan760_done:
.annotate 'line', 350
  # rx subcapture "sym"
    set_addr $I10, rxcap_761_fail
    rx756_cur."!mark_push"(0, rx756_pos, $I10)
  # rx literal  "sub"
    add $I11, rx756_pos, 3
    gt $I11, rx756_eos, rx756_fail
    sub $I11, rx756_pos, rx756_off
    substr $S10, rx756_tgt, $I11, 3
    ne $S10, "sub", rx756_fail
    add rx756_pos, 3
    set_addr $I10, rxcap_761_fail
    ($I12, $I11) = rx756_cur."!mark_peek"($I10)
    rx756_cur."!cursor_pos"($I11)
    ($P10) = rx756_cur."!cursor_start"()
    $P10."!cursor_pass"(rx756_pos, "")
    rx756_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_761_done
  rxcap_761_fail:
    goto rx756_fail
  rxcap_761_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx756_cur."!cursor_pos"(rx756_pos)
    $P10 = rx756_cur."routine_def"()
    unless $P10, rx756_fail
    rx756_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx756_pos = $P10."pos"()
  # rx pass
    rx756_cur."!cursor_pass"(rx756_pos, "routine_declarator:sym<sub>")
    if_null rx756_debug, debug_723
    rx756_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx756_pos)
  debug_723:
    .return (rx756_cur)
  rx756_restart:
.annotate 'line', 4
    if_null rx756_debug, debug_724
    rx756_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_724:
  rx756_fail:
    (rx756_rep, rx756_pos, $I10, $P10) = rx756_cur."!mark_fail"(0)
    lt rx756_pos, -1, rx756_done
    eq rx756_pos, -1, rx756_fail
    jump $I10
  rx756_done:
    rx756_cur."!cursor_fail"()
    if_null rx756_debug, debug_725
    rx756_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_725:
    .return (rx756_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("168_1299465717.405") :method
.annotate 'line', 4
    $P758 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P759, "ResizablePMCArray"
    push $P759, $P758
    .return ($P759)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("169_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx763_tgt
    .local int rx763_pos
    .local int rx763_off
    .local int rx763_eos
    .local int rx763_rep
    .local pmc rx763_cur
    .local pmc rx763_debug
    (rx763_cur, rx763_pos, rx763_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx763_cur
    .local pmc match
    .lex "$/", match
    length rx763_eos, rx763_tgt
    gt rx763_pos, rx763_eos, rx763_done
    set rx763_off, 0
    lt rx763_pos, 2, rx763_start
    sub rx763_off, rx763_pos, 1
    substr rx763_tgt, rx763_tgt, rx763_off
  rx763_start:
    eq $I10, 1, rx763_restart
    if_null rx763_debug, debug_726
    rx763_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan767_done
    goto rxscan767_scan
  rxscan767_loop:
    (rx763_pos) = rx763_cur."from"()
    inc rx763_pos
    rx763_cur."!cursor_from"(rx763_pos)
    ge rx763_pos, rx763_eos, rxscan767_done
  rxscan767_scan:
    set_addr $I10, rxscan767_loop
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  rxscan767_done:
.annotate 'line', 351
  # rx subcapture "sym"
    set_addr $I10, rxcap_768_fail
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  # rx literal  "method"
    add $I11, rx763_pos, 6
    gt $I11, rx763_eos, rx763_fail
    sub $I11, rx763_pos, rx763_off
    substr $S10, rx763_tgt, $I11, 6
    ne $S10, "method", rx763_fail
    add rx763_pos, 6
    set_addr $I10, rxcap_768_fail
    ($I12, $I11) = rx763_cur."!mark_peek"($I10)
    rx763_cur."!cursor_pos"($I11)
    ($P10) = rx763_cur."!cursor_start"()
    $P10."!cursor_pass"(rx763_pos, "")
    rx763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_768_done
  rxcap_768_fail:
    goto rx763_fail
  rxcap_768_done:
  # rx subrule "method_def" subtype=capture negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."method_def"()
    unless $P10, rx763_fail
    rx763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx763_pos = $P10."pos"()
  # rx pass
    rx763_cur."!cursor_pass"(rx763_pos, "routine_declarator:sym<method>")
    if_null rx763_debug, debug_727
    rx763_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx763_pos)
  debug_727:
    .return (rx763_cur)
  rx763_restart:
.annotate 'line', 4
    if_null rx763_debug, debug_728
    rx763_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_728:
  rx763_fail:
    (rx763_rep, rx763_pos, $I10, $P10) = rx763_cur."!mark_fail"(0)
    lt rx763_pos, -1, rx763_done
    eq rx763_pos, -1, rx763_fail
    jump $I10
  rx763_done:
    rx763_cur."!cursor_fail"()
    if_null rx763_debug, debug_729
    rx763_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_729:
    .return (rx763_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("170_1299465717.405") :method
.annotate 'line', 4
    $P765 = self."!PREFIX__!subrule"("method_def", "method")
    new $P766, "ResizablePMCArray"
    push $P766, $P765
    .return ($P766)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("171_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 354
    new $P770, "Undef"
    .lex "$*RETURN_USED", $P770
.annotate 'line', 4
    .local string rx771_tgt
    .local int rx771_pos
    .local int rx771_off
    .local int rx771_eos
    .local int rx771_rep
    .local pmc rx771_cur
    .local pmc rx771_debug
    (rx771_cur, rx771_pos, rx771_tgt, $I10) = self."!cursor_start"()
    rx771_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx771_cur
    .local pmc match
    .lex "$/", match
    length rx771_eos, rx771_tgt
    gt rx771_pos, rx771_eos, rx771_done
    set rx771_off, 0
    lt rx771_pos, 2, rx771_start
    sub rx771_off, rx771_pos, 1
    substr rx771_tgt, rx771_tgt, rx771_off
  rx771_start:
    eq $I10, 1, rx771_restart
    if_null rx771_debug, debug_730
    rx771_cur."!cursor_debug"("START", "routine_def")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan775_done
    goto rxscan775_scan
  rxscan775_loop:
    (rx771_pos) = rx771_cur."from"()
    inc rx771_pos
    rx771_cur."!cursor_from"(rx771_pos)
    ge rx771_pos, rx771_eos, rxscan775_done
  rxscan775_scan:
    set_addr $I10, rxscan775_loop
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  rxscan775_done:
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
.annotate 'line', 354
    rx771_cur."!cursor_pos"(rx771_pos)
    new $P777, "Integer"
    assign $P777, 0
    store_lex "$*RETURN_USED", $P777
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
.annotate 'line', 355
  # rx rxquantr779 ** 0..1
    set_addr $I10, rxquantr779_done
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  rxquantr779_loop:
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_782_fail
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  # rx rxquantr781 ** 0..1
    set_addr $I10, rxquantr781_done
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  rxquantr781_loop:
  # rx literal  "&"
    add $I11, rx771_pos, 1
    gt $I11, rx771_eos, rx771_fail
    sub $I11, rx771_pos, rx771_off
    ord $I11, rx771_tgt, $I11
    ne $I11, 38, rx771_fail
    add rx771_pos, 1
    set_addr $I10, rxquantr781_done
    (rx771_rep) = rx771_cur."!mark_commit"($I10)
  rxquantr781_done:
    set_addr $I10, rxcap_782_fail
    ($I12, $I11) = rx771_cur."!mark_peek"($I10)
    rx771_cur."!cursor_pos"($I11)
    ($P10) = rx771_cur."!cursor_start"()
    $P10."!cursor_pass"(rx771_pos, "")
    rx771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_782_done
  rxcap_782_fail:
    goto rx771_fail
  rxcap_782_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."deflongname"()
    unless $P10, rx771_fail
    rx771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx771_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
    set_addr $I10, rxquantr779_done
    (rx771_rep) = rx771_cur."!mark_commit"($I10)
  rxquantr779_done:
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
.annotate 'line', 356
  # rx subrule "newpad" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."newpad"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  alt786_0:
.annotate 'line', 357
    set_addr $I10, alt786_1
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx771_pos, 1
    gt $I11, rx771_eos, rx771_fail
    sub $I11, rx771_pos, rx771_off
    ord $I11, rx771_tgt, $I11
    ne $I11, 40, rx771_fail
    add rx771_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."signature"()
    unless $P10, rx771_fail
    rx771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx771_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx771_pos, 1
    gt $I11, rx771_eos, rx771_fail
    sub $I11, rx771_pos, rx771_off
    ord $I11, rx771_tgt, $I11
    ne $I11, 41, rx771_fail
    add rx771_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
    goto alt786_end
  alt786_1:
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  alt786_end:
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
.annotate 'line', 359
  # rx rxquantr794 ** 0..*
    set_addr $I10, rxquantr794_done
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  rxquantr794_loop:
  # rx subrule "trait" subtype=capture negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."trait"()
    unless $P10, rx771_fail
    goto rxsubrule795_pass
  rxsubrule795_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx771_fail
  rxsubrule795_pass:
    set_addr $I10, rxsubrule795_back
    rx771_cur."!mark_push"(0, rx771_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx771_pos = $P10."pos"()
    set_addr $I10, rxquantr794_done
    (rx771_rep) = rx771_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr794_done
    rx771_cur."!mark_push"(rx771_rep, rx771_pos, $I10)
    goto rxquantr794_loop
  rxquantr794_done:
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  alt797_0:
.annotate 'line', 360
    set_addr $I10, alt797_1
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."onlystar"()
    unless $P10, rx771_fail
    rx771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx771_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
    goto alt797_end
  alt797_1:
.annotate 'line', 362
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."blockoid"()
    unless $P10, rx771_fail
    rx771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx771_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
  alt797_end:
.annotate 'line', 363
  # rx subrule "ws" subtype=method negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."ws"()
    unless $P10, rx771_fail
    rx771_pos = $P10."pos"()
.annotate 'line', 353
  # rx pass
    rx771_cur."!cursor_pass"(rx771_pos, "routine_def")
    if_null rx771_debug, debug_731
    rx771_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx771_pos)
  debug_731:
    .return (rx771_cur)
  rx771_restart:
.annotate 'line', 4
    if_null rx771_debug, debug_732
    rx771_cur."!cursor_debug"("NEXT", "routine_def")
  debug_732:
  rx771_fail:
    (rx771_rep, rx771_pos, $I10, $P10) = rx771_cur."!mark_fail"(0)
    lt rx771_pos, -1, rx771_done
    eq rx771_pos, -1, rx771_fail
    jump $I10
  rx771_done:
    rx771_cur."!cursor_fail"()
    if_null rx771_debug, debug_733
    rx771_cur."!cursor_debug"("FAIL", "routine_def")
  debug_733:
    .return (rx771_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("172_1299465717.405") :method
.annotate 'line', 4
    $P773 = self."!PREFIX__!subrule"("ws", "")
    new $P774, "ResizablePMCArray"
    push $P774, $P773
    .return ($P774)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("173_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P834 = "175_1299465717.405" 
    capture_lex $P834
.annotate 'line', 367
    new $P804, "Undef"
    .lex "$*RETURN_USED", $P804
.annotate 'line', 368
    new $P805, "Undef"
    .lex "$*INVOCANT_OK", $P805
.annotate 'line', 4
    .local string rx806_tgt
    .local int rx806_pos
    .local int rx806_off
    .local int rx806_eos
    .local int rx806_rep
    .local pmc rx806_cur
    .local pmc rx806_debug
    (rx806_cur, rx806_pos, rx806_tgt, $I10) = self."!cursor_start"()
    rx806_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx806_cur
    .local pmc match
    .lex "$/", match
    length rx806_eos, rx806_tgt
    gt rx806_pos, rx806_eos, rx806_done
    set rx806_off, 0
    lt rx806_pos, 2, rx806_start
    sub rx806_off, rx806_pos, 1
    substr rx806_tgt, rx806_tgt, rx806_off
  rx806_start:
    eq $I10, 1, rx806_restart
    if_null rx806_debug, debug_734
    rx806_cur."!cursor_debug"("START", "method_def")
  debug_734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan810_done
    goto rxscan810_scan
  rxscan810_loop:
    (rx806_pos) = rx806_cur."from"()
    inc rx806_pos
    rx806_cur."!cursor_from"(rx806_pos)
    ge rx806_pos, rx806_eos, rxscan810_done
  rxscan810_scan:
    set_addr $I10, rxscan810_loop
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxscan810_done:
.annotate 'line', 366
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 367
    rx806_cur."!cursor_pos"(rx806_pos)
    new $P812, "Integer"
    assign $P812, 0
    store_lex "$*RETURN_USED", $P812
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 368
    rx806_cur."!cursor_pos"(rx806_pos)
    new $P814, "Integer"
    assign $P814, 1
    store_lex "$*INVOCANT_OK", $P814
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 369
  # rx subcapture "private"
    set_addr $I10, rxcap_817_fail
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  # rx rxquantr816 ** 0..1
    set_addr $I10, rxquantr816_done
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxquantr816_loop:
  # rx literal  "!"
    add $I11, rx806_pos, 1
    gt $I11, rx806_eos, rx806_fail
    sub $I11, rx806_pos, rx806_off
    ord $I11, rx806_tgt, $I11
    ne $I11, 33, rx806_fail
    add rx806_pos, 1
    set_addr $I10, rxquantr816_done
    (rx806_rep) = rx806_cur."!mark_commit"($I10)
  rxquantr816_done:
    set_addr $I10, rxcap_817_fail
    ($I12, $I11) = rx806_cur."!mark_peek"($I10)
    rx806_cur."!cursor_pos"($I11)
    ($P10) = rx806_cur."!cursor_start"()
    $P10."!cursor_pass"(rx806_pos, "")
    rx806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_817_done
  rxcap_817_fail:
    goto rx806_fail
  rxcap_817_done:
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 370
  # rx rxquantr819 ** 0..1
    set_addr $I10, rxquantr819_done
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxquantr819_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."deflongname"()
    unless $P10, rx806_fail
    goto rxsubrule820_pass
  rxsubrule820_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx806_fail
  rxsubrule820_pass:
    set_addr $I10, rxsubrule820_back
    rx806_cur."!mark_push"(0, rx806_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx806_pos = $P10."pos"()
    set_addr $I10, rxquantr819_done
    (rx806_rep) = rx806_cur."!mark_commit"($I10)
  rxquantr819_done:
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 371
  # rx subrule "newpad" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."newpad"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  alt823_0:
.annotate 'line', 372
    set_addr $I10, alt823_1
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx806_pos, 1
    gt $I11, rx806_eos, rx806_fail
    sub $I11, rx806_pos, rx806_off
    ord $I11, rx806_tgt, $I11
    ne $I11, 40, rx806_fail
    add rx806_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."signature"()
    unless $P10, rx806_fail
    rx806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx806_pos, 1
    gt $I11, rx806_eos, rx806_fail
    sub $I11, rx806_pos, rx806_off
    ord $I11, rx806_tgt, $I11
    ne $I11, 41, rx806_fail
    add rx806_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
    goto alt823_end
  alt823_1:
.annotate 'line', 373
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  alt823_end:
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 374
    rx806_cur."!cursor_pos"(rx806_pos)
    find_lex $P831, unicode:"$\x{a2}"
    $P832 = $P831."MATCH"()
    store_lex "$/", $P832
    .const 'Sub' $P834 = "175_1299465717.405" 
    capture_lex $P834
    $P836 = $P834()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 375
  # rx rxquantr838 ** 0..*
    set_addr $I10, rxquantr838_done
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxquantr838_loop:
  # rx subrule "trait" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."trait"()
    unless $P10, rx806_fail
    goto rxsubrule839_pass
  rxsubrule839_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx806_fail
  rxsubrule839_pass:
    set_addr $I10, rxsubrule839_back
    rx806_cur."!mark_push"(0, rx806_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx806_pos = $P10."pos"()
    set_addr $I10, rxquantr838_done
    (rx806_rep) = rx806_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr838_done
    rx806_cur."!mark_push"(rx806_rep, rx806_pos, $I10)
    goto rxquantr838_loop
  rxquantr838_done:
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  alt841_0:
.annotate 'line', 376
    set_addr $I10, alt841_1
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
.annotate 'line', 377
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."onlystar"()
    unless $P10, rx806_fail
    rx806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
    goto alt841_end
  alt841_1:
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."blockoid"()
    unless $P10, rx806_fail
    rx806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  alt841_end:
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
.annotate 'line', 366
  # rx pass
    rx806_cur."!cursor_pass"(rx806_pos, "method_def")
    if_null rx806_debug, debug_735
    rx806_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx806_pos)
  debug_735:
    .return (rx806_cur)
  rx806_restart:
.annotate 'line', 4
    if_null rx806_debug, debug_736
    rx806_cur."!cursor_debug"("NEXT", "method_def")
  debug_736:
  rx806_fail:
    (rx806_rep, rx806_pos, $I10, $P10) = rx806_cur."!mark_fail"(0)
    lt rx806_pos, -1, rx806_done
    eq rx806_pos, -1, rx806_fail
    jump $I10
  rx806_done:
    rx806_cur."!cursor_fail"()
    if_null rx806_debug, debug_737
    rx806_cur."!cursor_debug"("FAIL", "method_def")
  debug_737:
    .return (rx806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("174_1299465717.405") :method
.annotate 'line', 4
    $P808 = self."!PREFIX__!subrule"("ws", "")
    new $P809, "ResizablePMCArray"
    push $P809, $P808
    .return ($P809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block833"  :anon :subid("175_1299465717.405") :outer("173_1299465717.405")
.annotate 'line', 374
    new $P835, "Integer"
    assign $P835, 0
    store_dynamic_lex "$*INVOCANT_OK", $P835
    .return ($P835)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("176_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P855 = "178_1299465717.405" 
    capture_lex $P855
    .local string rx848_tgt
    .local int rx848_pos
    .local int rx848_off
    .local int rx848_eos
    .local int rx848_rep
    .local pmc rx848_cur
    .local pmc rx848_debug
    (rx848_cur, rx848_pos, rx848_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx848_cur
    .local pmc match
    .lex "$/", match
    length rx848_eos, rx848_tgt
    gt rx848_pos, rx848_eos, rx848_done
    set rx848_off, 0
    lt rx848_pos, 2, rx848_start
    sub rx848_off, rx848_pos, 1
    substr rx848_tgt, rx848_tgt, rx848_off
  rx848_start:
    eq $I10, 1, rx848_restart
    if_null rx848_debug, debug_738
    rx848_cur."!cursor_debug"("START", "onlystar")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan851_done
    goto rxscan851_scan
  rxscan851_loop:
    (rx848_pos) = rx848_cur."from"()
    inc rx848_pos
    rx848_cur."!cursor_from"(rx848_pos)
    ge rx848_pos, rx848_eos, rxscan851_done
  rxscan851_scan:
    set_addr $I10, rxscan851_loop
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
  rxscan851_done:
.annotate 'line', 383
    rx848_cur."!cursor_pos"(rx848_pos)
    find_lex $P852, unicode:"$\x{a2}"
    $P853 = $P852."MATCH"()
    store_lex "$/", $P853
    .const 'Sub' $P855 = "178_1299465717.405" 
    capture_lex $P855
    $P859 = $P855()
    unless $P859, rx848_fail
.annotate 'line', 384
  # rx literal  "{"
    add $I11, rx848_pos, 1
    gt $I11, rx848_eos, rx848_fail
    sub $I11, rx848_pos, rx848_off
    ord $I11, rx848_tgt, $I11
    ne $I11, 123, rx848_fail
    add rx848_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx848_pos, 1
    gt $I11, rx848_eos, rx848_fail
    sub $I11, rx848_pos, rx848_off
    ord $I11, rx848_tgt, $I11
    ne $I11, 42, rx848_fail
    add rx848_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx848_pos, 1
    gt $I11, rx848_eos, rx848_fail
    sub $I11, rx848_pos, rx848_off
    ord $I11, rx848_tgt, $I11
    ne $I11, 125, rx848_fail
    add rx848_pos, 1
.annotate 'line', 385
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ENDSTMT"()
    unless $P10, rx848_fail
.annotate 'line', 386
  # rx subrule "finishpad" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."finishpad"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 382
  # rx pass
    rx848_cur."!cursor_pass"(rx848_pos, "onlystar")
    if_null rx848_debug, debug_741
    rx848_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx848_pos)
  debug_741:
    .return (rx848_cur)
  rx848_restart:
.annotate 'line', 4
    if_null rx848_debug, debug_742
    rx848_cur."!cursor_debug"("NEXT", "onlystar")
  debug_742:
  rx848_fail:
    (rx848_rep, rx848_pos, $I10, $P10) = rx848_cur."!mark_fail"(0)
    lt rx848_pos, -1, rx848_done
    eq rx848_pos, -1, rx848_fail
    jump $I10
  rx848_done:
    rx848_cur."!cursor_fail"()
    if_null rx848_debug, debug_743
    rx848_cur."!cursor_debug"("FAIL", "onlystar")
  debug_743:
    .return (rx848_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("177_1299465717.405") :method
.annotate 'line', 4
    new $P850, "ResizablePMCArray"
    push $P850, ""
    .return ($P850)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block854"  :anon :subid("178_1299465717.405") :outer("176_1299465717.405")
.annotate 'line', 383
    find_dynamic_lex $P856, "$*MULTINESS"
    unless_null $P856, vivify_739
    get_hll_global $P856, "$MULTINESS"
    unless_null $P856, vivify_740
    die "Contextual $*MULTINESS not found"
  vivify_740:
  vivify_739:
    set $S857, $P856
    iseq $I858, $S857, "proto"
    .return ($I858)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("179_1299465717.405")
    .param pmc param_861
.annotate 'line', 389
    .lex "self", param_861
    $P862 = param_861."!protoregex"("multi_declarator")
    .return ($P862)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("180_1299465717.405")
    .param pmc param_864
.annotate 'line', 389
    .lex "self", param_864
    $P865 = param_864."!PREFIX__!protoregex"("multi_declarator")
    .return ($P865)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("181_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 391
    new $P867, "Undef"
    .lex "$*MULTINESS", $P867
.annotate 'line', 4
    .local string rx868_tgt
    .local int rx868_pos
    .local int rx868_off
    .local int rx868_eos
    .local int rx868_rep
    .local pmc rx868_cur
    .local pmc rx868_debug
    (rx868_cur, rx868_pos, rx868_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx868_cur
    .local pmc match
    .lex "$/", match
    length rx868_eos, rx868_tgt
    gt rx868_pos, rx868_eos, rx868_done
    set rx868_off, 0
    lt rx868_pos, 2, rx868_start
    sub rx868_off, rx868_pos, 1
    substr rx868_tgt, rx868_tgt, rx868_off
  rx868_start:
    eq $I10, 1, rx868_restart
    if_null rx868_debug, debug_744
    rx868_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan872_done
    goto rxscan872_scan
  rxscan872_loop:
    (rx868_pos) = rx868_cur."from"()
    inc rx868_pos
    rx868_cur."!cursor_from"(rx868_pos)
    ge rx868_pos, rx868_eos, rxscan872_done
  rxscan872_scan:
    set_addr $I10, rxscan872_loop
    rx868_cur."!mark_push"(0, rx868_pos, $I10)
  rxscan872_done:
.annotate 'line', 391
    rx868_cur."!cursor_pos"(rx868_pos)
    new $P873, "String"
    assign $P873, "multi"
    store_lex "$*MULTINESS", $P873
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_874_fail
    rx868_cur."!mark_push"(0, rx868_pos, $I10)
  # rx literal  "multi"
    add $I11, rx868_pos, 5
    gt $I11, rx868_eos, rx868_fail
    sub $I11, rx868_pos, rx868_off
    substr $S10, rx868_tgt, $I11, 5
    ne $S10, "multi", rx868_fail
    add rx868_pos, 5
    set_addr $I10, rxcap_874_fail
    ($I12, $I11) = rx868_cur."!mark_peek"($I10)
    rx868_cur."!cursor_pos"($I11)
    ($P10) = rx868_cur."!cursor_start"()
    $P10."!cursor_pass"(rx868_pos, "")
    rx868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_874_done
  rxcap_874_fail:
    goto rx868_fail
  rxcap_874_done:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx868_cur."!cursor_pos"(rx868_pos)
    $P10 = rx868_cur."ws"()
    unless $P10, rx868_fail
    rx868_pos = $P10."pos"()
  alt875_0:
    set_addr $I10, alt875_1
    rx868_cur."!mark_push"(0, rx868_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx868_cur."!cursor_pos"(rx868_pos)
    $P10 = rx868_cur."declarator"()
    unless $P10, rx868_fail
    rx868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx868_pos = $P10."pos"()
    goto alt875_end
  alt875_1:
    set_addr $I10, alt875_2
    rx868_cur."!mark_push"(0, rx868_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx868_cur."!cursor_pos"(rx868_pos)
    $P10 = rx868_cur."routine_def"()
    unless $P10, rx868_fail
    rx868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx868_pos = $P10."pos"()
    goto alt875_end
  alt875_2:
  # rx subrule "panic" subtype=method negate=
    rx868_cur."!cursor_pos"(rx868_pos)
    $P10 = rx868_cur."panic"("Malformed multi")
    unless $P10, rx868_fail
    rx868_pos = $P10."pos"()
  alt875_end:
.annotate 'line', 390
  # rx pass
    rx868_cur."!cursor_pass"(rx868_pos, "multi_declarator:sym<multi>")
    if_null rx868_debug, debug_745
    rx868_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx868_pos)
  debug_745:
    .return (rx868_cur)
  rx868_restart:
.annotate 'line', 4
    if_null rx868_debug, debug_746
    rx868_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_746:
  rx868_fail:
    (rx868_rep, rx868_pos, $I10, $P10) = rx868_cur."!mark_fail"(0)
    lt rx868_pos, -1, rx868_done
    eq rx868_pos, -1, rx868_fail
    jump $I10
  rx868_done:
    rx868_cur."!cursor_fail"()
    if_null rx868_debug, debug_747
    rx868_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_747:
    .return (rx868_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("182_1299465717.405") :method
.annotate 'line', 4
    $P870 = self."!PREFIX__!subrule"("ws", "multi")
    new $P871, "ResizablePMCArray"
    push $P871, $P870
    .return ($P871)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("183_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 396
    new $P877, "Undef"
    .lex "$*MULTINESS", $P877
.annotate 'line', 4
    .local string rx878_tgt
    .local int rx878_pos
    .local int rx878_off
    .local int rx878_eos
    .local int rx878_rep
    .local pmc rx878_cur
    .local pmc rx878_debug
    (rx878_cur, rx878_pos, rx878_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx878_cur
    .local pmc match
    .lex "$/", match
    length rx878_eos, rx878_tgt
    gt rx878_pos, rx878_eos, rx878_done
    set rx878_off, 0
    lt rx878_pos, 2, rx878_start
    sub rx878_off, rx878_pos, 1
    substr rx878_tgt, rx878_tgt, rx878_off
  rx878_start:
    eq $I10, 1, rx878_restart
    if_null rx878_debug, debug_748
    rx878_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan882_done
    goto rxscan882_scan
  rxscan882_loop:
    (rx878_pos) = rx878_cur."from"()
    inc rx878_pos
    rx878_cur."!cursor_from"(rx878_pos)
    ge rx878_pos, rx878_eos, rxscan882_done
  rxscan882_scan:
    set_addr $I10, rxscan882_loop
    rx878_cur."!mark_push"(0, rx878_pos, $I10)
  rxscan882_done:
.annotate 'line', 396
    rx878_cur."!cursor_pos"(rx878_pos)
    new $P883, "String"
    assign $P883, "proto"
    store_lex "$*MULTINESS", $P883
.annotate 'line', 397
  # rx subcapture "sym"
    set_addr $I10, rxcap_884_fail
    rx878_cur."!mark_push"(0, rx878_pos, $I10)
  # rx literal  "proto"
    add $I11, rx878_pos, 5
    gt $I11, rx878_eos, rx878_fail
    sub $I11, rx878_pos, rx878_off
    substr $S10, rx878_tgt, $I11, 5
    ne $S10, "proto", rx878_fail
    add rx878_pos, 5
    set_addr $I10, rxcap_884_fail
    ($I12, $I11) = rx878_cur."!mark_peek"($I10)
    rx878_cur."!cursor_pos"($I11)
    ($P10) = rx878_cur."!cursor_start"()
    $P10."!cursor_pass"(rx878_pos, "")
    rx878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_884_done
  rxcap_884_fail:
    goto rx878_fail
  rxcap_884_done:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx878_cur."!cursor_pos"(rx878_pos)
    $P10 = rx878_cur."ws"()
    unless $P10, rx878_fail
    rx878_pos = $P10."pos"()
  alt885_0:
    set_addr $I10, alt885_1
    rx878_cur."!mark_push"(0, rx878_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx878_cur."!cursor_pos"(rx878_pos)
    $P10 = rx878_cur."declarator"()
    unless $P10, rx878_fail
    rx878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx878_pos = $P10."pos"()
    goto alt885_end
  alt885_1:
    set_addr $I10, alt885_2
    rx878_cur."!mark_push"(0, rx878_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx878_cur."!cursor_pos"(rx878_pos)
    $P10 = rx878_cur."routine_def"()
    unless $P10, rx878_fail
    rx878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx878_pos = $P10."pos"()
    goto alt885_end
  alt885_2:
  # rx subrule "panic" subtype=method negate=
    rx878_cur."!cursor_pos"(rx878_pos)
    $P10 = rx878_cur."panic"("Malformed proto")
    unless $P10, rx878_fail
    rx878_pos = $P10."pos"()
  alt885_end:
.annotate 'line', 395
  # rx pass
    rx878_cur."!cursor_pass"(rx878_pos, "multi_declarator:sym<proto>")
    if_null rx878_debug, debug_749
    rx878_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx878_pos)
  debug_749:
    .return (rx878_cur)
  rx878_restart:
.annotate 'line', 4
    if_null rx878_debug, debug_750
    rx878_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_750:
  rx878_fail:
    (rx878_rep, rx878_pos, $I10, $P10) = rx878_cur."!mark_fail"(0)
    lt rx878_pos, -1, rx878_done
    eq rx878_pos, -1, rx878_fail
    jump $I10
  rx878_done:
    rx878_cur."!cursor_fail"()
    if_null rx878_debug, debug_751
    rx878_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_751:
    .return (rx878_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("184_1299465717.405") :method
.annotate 'line', 4
    $P880 = self."!PREFIX__!subrule"("ws", "proto")
    new $P881, "ResizablePMCArray"
    push $P881, $P880
    .return ($P881)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("185_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 401
    new $P887, "Undef"
    .lex "$*MULTINESS", $P887
.annotate 'line', 4
    .local string rx888_tgt
    .local int rx888_pos
    .local int rx888_off
    .local int rx888_eos
    .local int rx888_rep
    .local pmc rx888_cur
    .local pmc rx888_debug
    (rx888_cur, rx888_pos, rx888_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx888_cur
    .local pmc match
    .lex "$/", match
    length rx888_eos, rx888_tgt
    gt rx888_pos, rx888_eos, rx888_done
    set rx888_off, 0
    lt rx888_pos, 2, rx888_start
    sub rx888_off, rx888_pos, 1
    substr rx888_tgt, rx888_tgt, rx888_off
  rx888_start:
    eq $I10, 1, rx888_restart
    if_null rx888_debug, debug_752
    rx888_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan892_done
    goto rxscan892_scan
  rxscan892_loop:
    (rx888_pos) = rx888_cur."from"()
    inc rx888_pos
    rx888_cur."!cursor_from"(rx888_pos)
    ge rx888_pos, rx888_eos, rxscan892_done
  rxscan892_scan:
    set_addr $I10, rxscan892_loop
    rx888_cur."!mark_push"(0, rx888_pos, $I10)
  rxscan892_done:
.annotate 'line', 401
    rx888_cur."!cursor_pos"(rx888_pos)
    new $P893, "String"
    assign $P893, ""
    store_lex "$*MULTINESS", $P893
.annotate 'line', 402
  # rx subrule "declarator" subtype=capture negate=
    rx888_cur."!cursor_pos"(rx888_pos)
    $P10 = rx888_cur."declarator"()
    unless $P10, rx888_fail
    rx888_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx888_pos = $P10."pos"()
.annotate 'line', 400
  # rx pass
    rx888_cur."!cursor_pass"(rx888_pos, "multi_declarator:sym<null>")
    if_null rx888_debug, debug_753
    rx888_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx888_pos)
  debug_753:
    .return (rx888_cur)
  rx888_restart:
.annotate 'line', 4
    if_null rx888_debug, debug_754
    rx888_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_754:
  rx888_fail:
    (rx888_rep, rx888_pos, $I10, $P10) = rx888_cur."!mark_fail"(0)
    lt rx888_pos, -1, rx888_done
    eq rx888_pos, -1, rx888_fail
    jump $I10
  rx888_done:
    rx888_cur."!cursor_fail"()
    if_null rx888_debug, debug_755
    rx888_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_755:
    .return (rx888_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("186_1299465717.405") :method
.annotate 'line', 4
    $P890 = self."!PREFIX__!subrule"("declarator", "")
    new $P891, "ResizablePMCArray"
    push $P891, $P890
    .return ($P891)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("187_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P903 = "189_1299465717.405" 
    capture_lex $P903
    .local string rx895_tgt
    .local int rx895_pos
    .local int rx895_off
    .local int rx895_eos
    .local int rx895_rep
    .local pmc rx895_cur
    .local pmc rx895_debug
    (rx895_cur, rx895_pos, rx895_tgt, $I10) = self."!cursor_start"()
    rx895_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx895_cur
    .local pmc match
    .lex "$/", match
    length rx895_eos, rx895_tgt
    gt rx895_pos, rx895_eos, rx895_done
    set rx895_off, 0
    lt rx895_pos, 2, rx895_start
    sub rx895_off, rx895_pos, 1
    substr rx895_tgt, rx895_tgt, rx895_off
  rx895_start:
    eq $I10, 1, rx895_restart
    if_null rx895_debug, debug_756
    rx895_cur."!cursor_debug"("START", "signature")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan898_done
    goto rxscan898_scan
  rxscan898_loop:
    (rx895_pos) = rx895_cur."from"()
    inc rx895_pos
    rx895_cur."!cursor_from"(rx895_pos)
    ge rx895_pos, rx895_eos, rxscan898_done
  rxscan898_scan:
    set_addr $I10, rxscan898_loop
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxscan898_done:
.annotate 'line', 406
  # rx rxquantr899 ** 0..1
    set_addr $I10, rxquantr899_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr899_loop:
    rx895_cur."!cursor_pos"(rx895_pos)
    find_lex $P900, unicode:"$\x{a2}"
    $P901 = $P900."MATCH"()
    store_lex "$/", $P901
    .const 'Sub' $P903 = "189_1299465717.405" 
    capture_lex $P903
    $P905 = $P903()
    unless $P905, rx895_fail
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."parameter"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx895_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 58, rx895_fail
    add rx895_pos, 1
    set_addr $I10, rxquantr899_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
  rxquantr899_done:
.annotate 'line', 407
  # rx rxquantr906 ** 0..1
    set_addr $I10, rxquantr906_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr906_loop:
  # rx rxquantr907 ** 1..*
    set_addr $I10, rxquantr907_done
    rx895_cur."!mark_push"(0, -1, $I10)
  rxquantr907_loop:
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."parameter"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx895_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
    set_addr $I10, rxquantr907_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr907_done
    rx895_cur."!mark_push"(rx895_rep, rx895_pos, $I10)
  # rx literal  ","
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 44, rx895_fail
    add rx895_pos, 1
    goto rxquantr907_loop
  rxquantr907_done:
    set_addr $I10, rxquantr906_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
  rxquantr906_done:
.annotate 'line', 405
  # rx pass
    rx895_cur."!cursor_pass"(rx895_pos, "signature")
    if_null rx895_debug, debug_759
    rx895_cur."!cursor_debug"("PASS", "signature", " at pos=", rx895_pos)
  debug_759:
    .return (rx895_cur)
  rx895_restart:
.annotate 'line', 4
    if_null rx895_debug, debug_760
    rx895_cur."!cursor_debug"("NEXT", "signature")
  debug_760:
  rx895_fail:
    (rx895_rep, rx895_pos, $I10, $P10) = rx895_cur."!mark_fail"(0)
    lt rx895_pos, -1, rx895_done
    eq rx895_pos, -1, rx895_fail
    jump $I10
  rx895_done:
    rx895_cur."!cursor_fail"()
    if_null rx895_debug, debug_761
    rx895_cur."!cursor_debug"("FAIL", "signature")
  debug_761:
    .return (rx895_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("188_1299465717.405") :method
.annotate 'line', 4
    new $P897, "ResizablePMCArray"
    push $P897, ""
    .return ($P897)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block902"  :anon :subid("189_1299465717.405") :outer("187_1299465717.405")
.annotate 'line', 406
    find_dynamic_lex $P904, "$*INVOCANT_OK"
    unless_null $P904, vivify_757
    get_hll_global $P904, "$INVOCANT_OK"
    unless_null $P904, vivify_758
    die "Contextual $*INVOCANT_OK not found"
  vivify_758:
  vivify_757:
    .return ($P904)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("190_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx909_tgt
    .local int rx909_pos
    .local int rx909_off
    .local int rx909_eos
    .local int rx909_rep
    .local pmc rx909_cur
    .local pmc rx909_debug
    (rx909_cur, rx909_pos, rx909_tgt, $I10) = self."!cursor_start"()
    rx909_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx909_cur
    .local pmc match
    .lex "$/", match
    length rx909_eos, rx909_tgt
    gt rx909_pos, rx909_eos, rx909_done
    set rx909_off, 0
    lt rx909_pos, 2, rx909_start
    sub rx909_off, rx909_pos, 1
    substr rx909_tgt, rx909_tgt, rx909_off
  rx909_start:
    eq $I10, 1, rx909_restart
    if_null rx909_debug, debug_762
    rx909_cur."!cursor_debug"("START", "parameter")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan912_done
    goto rxscan912_scan
  rxscan912_loop:
    (rx909_pos) = rx909_cur."from"()
    inc rx909_pos
    rx909_cur."!cursor_from"(rx909_pos)
    ge rx909_pos, rx909_eos, rxscan912_done
  rxscan912_scan:
    set_addr $I10, rxscan912_loop
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  rxscan912_done:
.annotate 'line', 411
  # rx rxquantr913 ** 0..*
    set_addr $I10, rxquantr913_done
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  rxquantr913_loop:
  # rx subrule "typename" subtype=capture negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."typename"()
    unless $P10, rx909_fail
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx909_pos = $P10."pos"()
  # rx rxquantr914 ** 0..1
    set_addr $I10, rxquantr914_done
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  rxquantr914_loop:
  # rx literal  ":"
    add $I11, rx909_pos, 1
    gt $I11, rx909_eos, rx909_fail
    sub $I11, rx909_pos, rx909_off
    ord $I11, rx909_tgt, $I11
    ne $I11, 58, rx909_fail
    add rx909_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_915_fail
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx909_pos, rx909_eos, rx909_fail
    sub $I10, rx909_pos, rx909_off
    substr $S10, rx909_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx909_fail
    inc rx909_pos
    set_addr $I10, rxcap_915_fail
    ($I12, $I11) = rx909_cur."!mark_peek"($I10)
    rx909_cur."!cursor_pos"($I11)
    ($P10) = rx909_cur."!cursor_start"()
    $P10."!cursor_pass"(rx909_pos, "")
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_915_done
  rxcap_915_fail:
    goto rx909_fail
  rxcap_915_done:
    set_addr $I10, rxquantr914_done
    (rx909_rep) = rx909_cur."!mark_commit"($I10)
  rxquantr914_done:
  # rx subrule "ws" subtype=method negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."ws"()
    unless $P10, rx909_fail
    rx909_pos = $P10."pos"()
    set_addr $I10, rxquantr913_done
    (rx909_rep) = rx909_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr913_done
    rx909_cur."!mark_push"(rx909_rep, rx909_pos, $I10)
    goto rxquantr913_loop
  rxquantr913_done:
  alt916_0:
.annotate 'line', 412
    set_addr $I10, alt916_1
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
.annotate 'line', 413
  # rx subcapture "quant"
    set_addr $I10, rxcap_917_fail
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  # rx literal  "*"
    add $I11, rx909_pos, 1
    gt $I11, rx909_eos, rx909_fail
    sub $I11, rx909_pos, rx909_off
    ord $I11, rx909_tgt, $I11
    ne $I11, 42, rx909_fail
    add rx909_pos, 1
    set_addr $I10, rxcap_917_fail
    ($I12, $I11) = rx909_cur."!mark_peek"($I10)
    rx909_cur."!cursor_pos"($I11)
    ($P10) = rx909_cur."!cursor_start"()
    $P10."!cursor_pass"(rx909_pos, "")
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_917_done
  rxcap_917_fail:
    goto rx909_fail
  rxcap_917_done:
  # rx subrule "param_var" subtype=capture negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."param_var"()
    unless $P10, rx909_fail
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx909_pos = $P10."pos"()
    goto alt916_end
  alt916_1:
  alt918_0:
.annotate 'line', 414
    set_addr $I10, alt918_1
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."param_var"()
    unless $P10, rx909_fail
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx909_pos = $P10."pos"()
    goto alt918_end
  alt918_1:
  # rx subrule "named_param" subtype=capture negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."named_param"()
    unless $P10, rx909_fail
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx909_pos = $P10."pos"()
  alt918_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_920_fail
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  alt919_0:
    set_addr $I10, alt919_1
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  # rx literal  "?"
    add $I11, rx909_pos, 1
    gt $I11, rx909_eos, rx909_fail
    sub $I11, rx909_pos, rx909_off
    ord $I11, rx909_tgt, $I11
    ne $I11, 63, rx909_fail
    add rx909_pos, 1
    goto alt919_end
  alt919_1:
    set_addr $I10, alt919_2
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  # rx literal  "!"
    add $I11, rx909_pos, 1
    gt $I11, rx909_eos, rx909_fail
    sub $I11, rx909_pos, rx909_off
    ord $I11, rx909_tgt, $I11
    ne $I11, 33, rx909_fail
    add rx909_pos, 1
    goto alt919_end
  alt919_2:
  alt919_end:
    set_addr $I10, rxcap_920_fail
    ($I12, $I11) = rx909_cur."!mark_peek"($I10)
    rx909_cur."!cursor_pos"($I11)
    ($P10) = rx909_cur."!cursor_start"()
    $P10."!cursor_pass"(rx909_pos, "")
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_920_done
  rxcap_920_fail:
    goto rx909_fail
  rxcap_920_done:
  alt916_end:
.annotate 'line', 416
  # rx rxquantr921 ** 0..1
    set_addr $I10, rxquantr921_done
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  rxquantr921_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."default_value"()
    unless $P10, rx909_fail
    goto rxsubrule922_pass
  rxsubrule922_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx909_fail
  rxsubrule922_pass:
    set_addr $I10, rxsubrule922_back
    rx909_cur."!mark_push"(0, rx909_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx909_pos = $P10."pos"()
    set_addr $I10, rxquantr921_done
    (rx909_rep) = rx909_cur."!mark_commit"($I10)
  rxquantr921_done:
.annotate 'line', 410
  # rx pass
    rx909_cur."!cursor_pass"(rx909_pos, "parameter")
    if_null rx909_debug, debug_763
    rx909_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx909_pos)
  debug_763:
    .return (rx909_cur)
  rx909_restart:
.annotate 'line', 4
    if_null rx909_debug, debug_764
    rx909_cur."!cursor_debug"("NEXT", "parameter")
  debug_764:
  rx909_fail:
    (rx909_rep, rx909_pos, $I10, $P10) = rx909_cur."!mark_fail"(0)
    lt rx909_pos, -1, rx909_done
    eq rx909_pos, -1, rx909_fail
    jump $I10
  rx909_done:
    rx909_cur."!cursor_fail"()
    if_null rx909_debug, debug_765
    rx909_cur."!cursor_debug"("FAIL", "parameter")
  debug_765:
    .return (rx909_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("191_1299465717.405") :method
.annotate 'line', 4
    new $P911, "ResizablePMCArray"
    push $P911, ""
    .return ($P911)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("192_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx924_tgt
    .local int rx924_pos
    .local int rx924_off
    .local int rx924_eos
    .local int rx924_rep
    .local pmc rx924_cur
    .local pmc rx924_debug
    (rx924_cur, rx924_pos, rx924_tgt, $I10) = self."!cursor_start"()
    rx924_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx924_cur
    .local pmc match
    .lex "$/", match
    length rx924_eos, rx924_tgt
    gt rx924_pos, rx924_eos, rx924_done
    set rx924_off, 0
    lt rx924_pos, 2, rx924_start
    sub rx924_off, rx924_pos, 1
    substr rx924_tgt, rx924_tgt, rx924_off
  rx924_start:
    eq $I10, 1, rx924_restart
    if_null rx924_debug, debug_766
    rx924_cur."!cursor_debug"("START", "param_var")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan928_done
    goto rxscan928_scan
  rxscan928_loop:
    (rx924_pos) = rx924_cur."from"()
    inc rx924_pos
    rx924_cur."!cursor_from"(rx924_pos)
    ge rx924_pos, rx924_eos, rxscan928_done
  rxscan928_scan:
    set_addr $I10, rxscan928_loop
    rx924_cur."!mark_push"(0, rx924_pos, $I10)
  rxscan928_done:
.annotate 'line', 420
  # rx subrule "sigil" subtype=capture negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."sigil"()
    unless $P10, rx924_fail
    rx924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx924_pos = $P10."pos"()
  # rx rxquantr929 ** 0..1
    set_addr $I10, rxquantr929_done
    rx924_cur."!mark_push"(0, rx924_pos, $I10)
  rxquantr929_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."twigil"()
    unless $P10, rx924_fail
    goto rxsubrule930_pass
  rxsubrule930_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx924_fail
  rxsubrule930_pass:
    set_addr $I10, rxsubrule930_back
    rx924_cur."!mark_push"(0, rx924_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx924_pos = $P10."pos"()
    set_addr $I10, rxquantr929_done
    (rx924_rep) = rx924_cur."!mark_commit"($I10)
  rxquantr929_done:
  alt931_0:
.annotate 'line', 421
    set_addr $I10, alt931_1
    rx924_cur."!mark_push"(0, rx924_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."ident"()
    unless $P10, rx924_fail
    rx924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx924_pos = $P10."pos"()
    goto alt931_end
  alt931_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_932_fail
    rx924_cur."!mark_push"(0, rx924_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx924_pos, rx924_eos, rx924_fail
    sub $I10, rx924_pos, rx924_off
    substr $S10, rx924_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx924_fail
    inc rx924_pos
    set_addr $I10, rxcap_932_fail
    ($I12, $I11) = rx924_cur."!mark_peek"($I10)
    rx924_cur."!cursor_pos"($I11)
    ($P10) = rx924_cur."!cursor_start"()
    $P10."!cursor_pass"(rx924_pos, "")
    rx924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_932_done
  rxcap_932_fail:
    goto rx924_fail
  rxcap_932_done:
  alt931_end:
.annotate 'line', 419
  # rx pass
    rx924_cur."!cursor_pass"(rx924_pos, "param_var")
    if_null rx924_debug, debug_767
    rx924_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx924_pos)
  debug_767:
    .return (rx924_cur)
  rx924_restart:
.annotate 'line', 4
    if_null rx924_debug, debug_768
    rx924_cur."!cursor_debug"("NEXT", "param_var")
  debug_768:
  rx924_fail:
    (rx924_rep, rx924_pos, $I10, $P10) = rx924_cur."!mark_fail"(0)
    lt rx924_pos, -1, rx924_done
    eq rx924_pos, -1, rx924_fail
    jump $I10
  rx924_done:
    rx924_cur."!cursor_fail"()
    if_null rx924_debug, debug_769
    rx924_cur."!cursor_debug"("FAIL", "param_var")
  debug_769:
    .return (rx924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("193_1299465717.405") :method
.annotate 'line', 4
    $P926 = self."!PREFIX__!subrule"("sigil", "")
    new $P927, "ResizablePMCArray"
    push $P927, $P926
    .return ($P927)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("194_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx934_tgt
    .local int rx934_pos
    .local int rx934_off
    .local int rx934_eos
    .local int rx934_rep
    .local pmc rx934_cur
    .local pmc rx934_debug
    (rx934_cur, rx934_pos, rx934_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx934_cur
    .local pmc match
    .lex "$/", match
    length rx934_eos, rx934_tgt
    gt rx934_pos, rx934_eos, rx934_done
    set rx934_off, 0
    lt rx934_pos, 2, rx934_start
    sub rx934_off, rx934_pos, 1
    substr rx934_tgt, rx934_tgt, rx934_off
  rx934_start:
    eq $I10, 1, rx934_restart
    if_null rx934_debug, debug_770
    rx934_cur."!cursor_debug"("START", "named_param")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan938_done
    goto rxscan938_scan
  rxscan938_loop:
    (rx934_pos) = rx934_cur."from"()
    inc rx934_pos
    rx934_cur."!cursor_from"(rx934_pos)
    ge rx934_pos, rx934_eos, rxscan938_done
  rxscan938_scan:
    set_addr $I10, rxscan938_loop
    rx934_cur."!mark_push"(0, rx934_pos, $I10)
  rxscan938_done:
.annotate 'line', 425
  # rx literal  ":"
    add $I11, rx934_pos, 1
    gt $I11, rx934_eos, rx934_fail
    sub $I11, rx934_pos, rx934_off
    ord $I11, rx934_tgt, $I11
    ne $I11, 58, rx934_fail
    add rx934_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."param_var"()
    unless $P10, rx934_fail
    rx934_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx934_pos = $P10."pos"()
.annotate 'line', 424
  # rx pass
    rx934_cur."!cursor_pass"(rx934_pos, "named_param")
    if_null rx934_debug, debug_771
    rx934_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx934_pos)
  debug_771:
    .return (rx934_cur)
  rx934_restart:
.annotate 'line', 4
    if_null rx934_debug, debug_772
    rx934_cur."!cursor_debug"("NEXT", "named_param")
  debug_772:
  rx934_fail:
    (rx934_rep, rx934_pos, $I10, $P10) = rx934_cur."!mark_fail"(0)
    lt rx934_pos, -1, rx934_done
    eq rx934_pos, -1, rx934_fail
    jump $I10
  rx934_done:
    rx934_cur."!cursor_fail"()
    if_null rx934_debug, debug_773
    rx934_cur."!cursor_debug"("FAIL", "named_param")
  debug_773:
    .return (rx934_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("195_1299465717.405") :method
.annotate 'line', 4
    $P936 = self."!PREFIX__!subrule"("param_var", ":")
    new $P937, "ResizablePMCArray"
    push $P937, $P936
    .return ($P937)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("196_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx940_tgt
    .local int rx940_pos
    .local int rx940_off
    .local int rx940_eos
    .local int rx940_rep
    .local pmc rx940_cur
    .local pmc rx940_debug
    (rx940_cur, rx940_pos, rx940_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx940_cur
    .local pmc match
    .lex "$/", match
    length rx940_eos, rx940_tgt
    gt rx940_pos, rx940_eos, rx940_done
    set rx940_off, 0
    lt rx940_pos, 2, rx940_start
    sub rx940_off, rx940_pos, 1
    substr rx940_tgt, rx940_tgt, rx940_off
  rx940_start:
    eq $I10, 1, rx940_restart
    if_null rx940_debug, debug_774
    rx940_cur."!cursor_debug"("START", "default_value")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan944_done
    goto rxscan944_scan
  rxscan944_loop:
    (rx940_pos) = rx940_cur."from"()
    inc rx940_pos
    rx940_cur."!cursor_from"(rx940_pos)
    ge rx940_pos, rx940_eos, rxscan944_done
  rxscan944_scan:
    set_addr $I10, rxscan944_loop
    rx940_cur."!mark_push"(0, rx940_pos, $I10)
  rxscan944_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx940_cur."!cursor_pos"(rx940_pos)
    $P10 = rx940_cur."ws"()
    unless $P10, rx940_fail
    rx940_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx940_pos, 1
    gt $I11, rx940_eos, rx940_fail
    sub $I11, rx940_pos, rx940_off
    ord $I11, rx940_tgt, $I11
    ne $I11, 61, rx940_fail
    add rx940_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx940_cur."!cursor_pos"(rx940_pos)
    $P10 = rx940_cur."ws"()
    unless $P10, rx940_fail
    rx940_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx940_cur."!cursor_pos"(rx940_pos)
    $P10 = rx940_cur."EXPR"("i=")
    unless $P10, rx940_fail
    rx940_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx940_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx940_cur."!cursor_pos"(rx940_pos)
    $P10 = rx940_cur."ws"()
    unless $P10, rx940_fail
    rx940_pos = $P10."pos"()
  # rx pass
    rx940_cur."!cursor_pass"(rx940_pos, "default_value")
    if_null rx940_debug, debug_775
    rx940_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx940_pos)
  debug_775:
    .return (rx940_cur)
  rx940_restart:
.annotate 'line', 4
    if_null rx940_debug, debug_776
    rx940_cur."!cursor_debug"("NEXT", "default_value")
  debug_776:
  rx940_fail:
    (rx940_rep, rx940_pos, $I10, $P10) = rx940_cur."!mark_fail"(0)
    lt rx940_pos, -1, rx940_done
    eq rx940_pos, -1, rx940_fail
    jump $I10
  rx940_done:
    rx940_cur."!cursor_fail"()
    if_null rx940_debug, debug_777
    rx940_cur."!cursor_debug"("FAIL", "default_value")
  debug_777:
    .return (rx940_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("197_1299465717.405") :method
.annotate 'line', 4
    $P942 = self."!PREFIX__!subrule"("ws", "")
    new $P943, "ResizablePMCArray"
    push $P943, $P942
    .return ($P943)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("198_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx949_tgt
    .local int rx949_pos
    .local int rx949_off
    .local int rx949_eos
    .local int rx949_rep
    .local pmc rx949_cur
    .local pmc rx949_debug
    (rx949_cur, rx949_pos, rx949_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx949_cur
    .local pmc match
    .lex "$/", match
    length rx949_eos, rx949_tgt
    gt rx949_pos, rx949_eos, rx949_done
    set rx949_off, 0
    lt rx949_pos, 2, rx949_start
    sub rx949_off, rx949_pos, 1
    substr rx949_tgt, rx949_tgt, rx949_off
  rx949_start:
    eq $I10, 1, rx949_restart
    if_null rx949_debug, debug_778
    rx949_cur."!cursor_debug"("START", "trait")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan953_done
    goto rxscan953_scan
  rxscan953_loop:
    (rx949_pos) = rx949_cur."from"()
    inc rx949_pos
    rx949_cur."!cursor_from"(rx949_pos)
    ge rx949_pos, rx949_eos, rxscan953_done
  rxscan953_scan:
    set_addr $I10, rxscan953_loop
    rx949_cur."!mark_push"(0, rx949_pos, $I10)
  rxscan953_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."ws"()
    unless $P10, rx949_fail
    rx949_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."trait_mod"()
    unless $P10, rx949_fail
    rx949_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx949_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."ws"()
    unless $P10, rx949_fail
    rx949_pos = $P10."pos"()
  # rx pass
    rx949_cur."!cursor_pass"(rx949_pos, "trait")
    if_null rx949_debug, debug_779
    rx949_cur."!cursor_debug"("PASS", "trait", " at pos=", rx949_pos)
  debug_779:
    .return (rx949_cur)
  rx949_restart:
.annotate 'line', 4
    if_null rx949_debug, debug_780
    rx949_cur."!cursor_debug"("NEXT", "trait")
  debug_780:
  rx949_fail:
    (rx949_rep, rx949_pos, $I10, $P10) = rx949_cur."!mark_fail"(0)
    lt rx949_pos, -1, rx949_done
    eq rx949_pos, -1, rx949_fail
    jump $I10
  rx949_done:
    rx949_cur."!cursor_fail"()
    if_null rx949_debug, debug_781
    rx949_cur."!cursor_debug"("FAIL", "trait")
  debug_781:
    .return (rx949_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("199_1299465717.405") :method
.annotate 'line', 4
    $P951 = self."!PREFIX__!subrule"("ws", "")
    new $P952, "ResizablePMCArray"
    push $P952, $P951
    .return ($P952)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("200_1299465717.405")
    .param pmc param_957
.annotate 'line', 432
    .lex "self", param_957
    $P958 = param_957."!protoregex"("trait_mod")
    .return ($P958)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("201_1299465717.405")
    .param pmc param_960
.annotate 'line', 432
    .lex "self", param_960
    $P961 = param_960."!PREFIX__!protoregex"("trait_mod")
    .return ($P961)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("202_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx963_tgt
    .local int rx963_pos
    .local int rx963_off
    .local int rx963_eos
    .local int rx963_rep
    .local pmc rx963_cur
    .local pmc rx963_debug
    (rx963_cur, rx963_pos, rx963_tgt, $I10) = self."!cursor_start"()
    rx963_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx963_cur
    .local pmc match
    .lex "$/", match
    length rx963_eos, rx963_tgt
    gt rx963_pos, rx963_eos, rx963_done
    set rx963_off, 0
    lt rx963_pos, 2, rx963_start
    sub rx963_off, rx963_pos, 1
    substr rx963_tgt, rx963_tgt, rx963_off
  rx963_start:
    eq $I10, 1, rx963_restart
    if_null rx963_debug, debug_782
    rx963_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan967_done
    goto rxscan967_scan
  rxscan967_loop:
    (rx963_pos) = rx963_cur."from"()
    inc rx963_pos
    rx963_cur."!cursor_from"(rx963_pos)
    ge rx963_pos, rx963_eos, rxscan967_done
  rxscan967_scan:
    set_addr $I10, rxscan967_loop
    rx963_cur."!mark_push"(0, rx963_pos, $I10)
  rxscan967_done:
.annotate 'line', 433
  # rx subcapture "sym"
    set_addr $I10, rxcap_968_fail
    rx963_cur."!mark_push"(0, rx963_pos, $I10)
  # rx literal  "is"
    add $I11, rx963_pos, 2
    gt $I11, rx963_eos, rx963_fail
    sub $I11, rx963_pos, rx963_off
    substr $S10, rx963_tgt, $I11, 2
    ne $S10, "is", rx963_fail
    add rx963_pos, 2
    set_addr $I10, rxcap_968_fail
    ($I12, $I11) = rx963_cur."!mark_peek"($I10)
    rx963_cur."!cursor_pos"($I11)
    ($P10) = rx963_cur."!cursor_start"()
    $P10."!cursor_pass"(rx963_pos, "")
    rx963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_968_done
  rxcap_968_fail:
    goto rx963_fail
  rxcap_968_done:
  # rx subrule "ws" subtype=method negate=
    rx963_cur."!cursor_pos"(rx963_pos)
    $P10 = rx963_cur."ws"()
    unless $P10, rx963_fail
    rx963_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx963_cur."!cursor_pos"(rx963_pos)
    $P10 = rx963_cur."deflongname"()
    unless $P10, rx963_fail
    rx963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx963_pos = $P10."pos"()
  # rx rxquantr970 ** 0..1
    set_addr $I10, rxquantr970_done
    rx963_cur."!mark_push"(0, rx963_pos, $I10)
  rxquantr970_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx963_cur."!cursor_pos"(rx963_pos)
    $P10 = rx963_cur."circumfix"()
    unless $P10, rx963_fail
    goto rxsubrule971_pass
  rxsubrule971_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx963_fail
  rxsubrule971_pass:
    set_addr $I10, rxsubrule971_back
    rx963_cur."!mark_push"(0, rx963_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx963_pos = $P10."pos"()
    set_addr $I10, rxquantr970_done
    (rx963_rep) = rx963_cur."!mark_commit"($I10)
  rxquantr970_done:
  # rx subrule "ws" subtype=method negate=
    rx963_cur."!cursor_pos"(rx963_pos)
    $P10 = rx963_cur."ws"()
    unless $P10, rx963_fail
    rx963_pos = $P10."pos"()
  # rx pass
    rx963_cur."!cursor_pass"(rx963_pos, "trait_mod:sym<is>")
    if_null rx963_debug, debug_783
    rx963_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx963_pos)
  debug_783:
    .return (rx963_cur)
  rx963_restart:
.annotate 'line', 4
    if_null rx963_debug, debug_784
    rx963_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_784:
  rx963_fail:
    (rx963_rep, rx963_pos, $I10, $P10) = rx963_cur."!mark_fail"(0)
    lt rx963_pos, -1, rx963_done
    eq rx963_pos, -1, rx963_fail
    jump $I10
  rx963_done:
    rx963_cur."!cursor_fail"()
    if_null rx963_debug, debug_785
    rx963_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_785:
    .return (rx963_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("203_1299465717.405") :method
.annotate 'line', 4
    $P965 = self."!PREFIX__!subrule"("ws", "is")
    new $P966, "ResizablePMCArray"
    push $P966, $P965
    .return ($P966)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("204_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx974_tgt
    .local int rx974_pos
    .local int rx974_off
    .local int rx974_eos
    .local int rx974_rep
    .local pmc rx974_cur
    .local pmc rx974_debug
    (rx974_cur, rx974_pos, rx974_tgt, $I10) = self."!cursor_start"()
    rx974_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx974_cur
    .local pmc match
    .lex "$/", match
    length rx974_eos, rx974_tgt
    gt rx974_pos, rx974_eos, rx974_done
    set rx974_off, 0
    lt rx974_pos, 2, rx974_start
    sub rx974_off, rx974_pos, 1
    substr rx974_tgt, rx974_tgt, rx974_off
  rx974_start:
    eq $I10, 1, rx974_restart
    if_null rx974_debug, debug_786
    rx974_cur."!cursor_debug"("START", "regex_declarator")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan978_done
    goto rxscan978_scan
  rxscan978_loop:
    (rx974_pos) = rx974_cur."from"()
    inc rx974_pos
    rx974_cur."!cursor_from"(rx974_pos)
    ge rx974_pos, rx974_eos, rxscan978_done
  rxscan978_scan:
    set_addr $I10, rxscan978_loop
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  rxscan978_done:
.annotate 'line', 435
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  alt980_0:
.annotate 'line', 436
    set_addr $I10, alt980_1
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_982_fail
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx literal  "proto"
    add $I11, rx974_pos, 5
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 5
    ne $S10, "proto", rx974_fail
    add rx974_pos, 5
    set_addr $I10, rxcap_982_fail
    ($I12, $I11) = rx974_cur."!mark_peek"($I10)
    rx974_cur."!cursor_pos"($I11)
    ($P10) = rx974_cur."!cursor_start"()
    $P10."!cursor_pass"(rx974_pos, "")
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_982_done
  rxcap_982_fail:
    goto rx974_fail
  rxcap_982_done:
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  alt984_0:
    set_addr $I10, alt984_1
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx literal  "regex"
    add $I11, rx974_pos, 5
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 5
    ne $S10, "regex", rx974_fail
    add rx974_pos, 5
    goto alt984_end
  alt984_1:
    set_addr $I10, alt984_2
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx literal  "token"
    add $I11, rx974_pos, 5
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 5
    ne $S10, "token", rx974_fail
    add rx974_pos, 5
    goto alt984_end
  alt984_2:
  # rx literal  "rule"
    add $I11, rx974_pos, 4
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 4
    ne $S10, "rule", rx974_fail
    add rx974_pos, 4
  alt984_end:
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 438
  # rx subrule "deflongname" subtype=capture negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."deflongname"()
    unless $P10, rx974_fail
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx974_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  alt987_0:
.annotate 'line', 439
    set_addr $I10, alt987_1
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 123, rx974_fail
    add rx974_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx974_pos, 5
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 5
    ne $S10, "<...>", rx974_fail
    add rx974_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 125, rx974_fail
    add rx974_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ENDSTMT"()
    unless $P10, rx974_fail
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
    goto alt987_end
  alt987_1:
    set_addr $I10, alt987_2
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 123, rx974_fail
    add rx974_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx974_pos, 3
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 3
    ne $S10, "<*>", rx974_fail
    add rx974_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 125, rx974_fail
    add rx974_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ENDSTMT"()
    unless $P10, rx974_fail
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
    goto alt987_end
  alt987_2:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  alt987_end:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 437
    goto alt980_end
  alt980_1:
.annotate 'line', 444
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1001_fail
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  alt1000_0:
    set_addr $I10, alt1000_1
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx literal  "regex"
    add $I11, rx974_pos, 5
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 5
    ne $S10, "regex", rx974_fail
    add rx974_pos, 5
    goto alt1000_end
  alt1000_1:
    set_addr $I10, alt1000_2
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx literal  "token"
    add $I11, rx974_pos, 5
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 5
    ne $S10, "token", rx974_fail
    add rx974_pos, 5
    goto alt1000_end
  alt1000_2:
  # rx literal  "rule"
    add $I11, rx974_pos, 4
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 4
    ne $S10, "rule", rx974_fail
    add rx974_pos, 4
  alt1000_end:
    set_addr $I10, rxcap_1001_fail
    ($I12, $I11) = rx974_cur."!mark_peek"($I10)
    rx974_cur."!cursor_pos"($I11)
    ($P10) = rx974_cur."!cursor_start"()
    $P10."!cursor_pass"(rx974_pos, "")
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1001_done
  rxcap_1001_fail:
    goto rx974_fail
  rxcap_1001_done:
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 445
  # rx subrule "deflongname" subtype=capture negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."deflongname"()
    unless $P10, rx974_fail
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx974_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 446
  # rx subrule "newpad" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."newpad"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 447
  # rx rxquantr1005 ** 0..1
    set_addr $I10, rxquantr1005_done
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  rxquantr1005_loop:
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 40, rx974_fail
    add rx974_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."signature"()
    unless $P10, rx974_fail
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx974_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 41, rx974_fail
    add rx974_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
    set_addr $I10, rxquantr1005_done
    (rx974_rep) = rx974_cur."!mark_commit"($I10)
  rxquantr1005_done:
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 448
  # rx reduce name="regex_declarator" key="open"
    rx974_cur."!cursor_pos"(rx974_pos)
    rx974_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 449
  # rx literal  "{"
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 123, rx974_fail
    add rx974_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."LANG"("Regex", "nibbler")
    unless $P10, rx974_fail
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx974_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx974_pos, 1
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    ord $I11, rx974_tgt, $I11
    ne $I11, 125, rx974_fail
    add rx974_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ENDSTMT"()
    unless $P10, rx974_fail
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  alt980_end:
.annotate 'line', 450
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
.annotate 'line', 435
  # rx pass
    rx974_cur."!cursor_pass"(rx974_pos, "regex_declarator")
    if_null rx974_debug, debug_787
    rx974_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx974_pos)
  debug_787:
    .return (rx974_cur)
  rx974_restart:
.annotate 'line', 4
    if_null rx974_debug, debug_788
    rx974_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_788:
  rx974_fail:
    (rx974_rep, rx974_pos, $I10, $P10) = rx974_cur."!mark_fail"(0)
    lt rx974_pos, -1, rx974_done
    eq rx974_pos, -1, rx974_fail
    jump $I10
  rx974_done:
    rx974_cur."!cursor_fail"()
    if_null rx974_debug, debug_789
    rx974_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_789:
    .return (rx974_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("205_1299465717.405") :method
.annotate 'line', 4
    $P976 = self."!PREFIX__!subrule"("ws", "")
    new $P977, "ResizablePMCArray"
    push $P977, $P976
    .return ($P977)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("206_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1015_tgt
    .local int rx1015_pos
    .local int rx1015_off
    .local int rx1015_eos
    .local int rx1015_rep
    .local pmc rx1015_cur
    .local pmc rx1015_debug
    (rx1015_cur, rx1015_pos, rx1015_tgt, $I10) = self."!cursor_start"()
    rx1015_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1015_cur
    .local pmc match
    .lex "$/", match
    length rx1015_eos, rx1015_tgt
    gt rx1015_pos, rx1015_eos, rx1015_done
    set rx1015_off, 0
    lt rx1015_pos, 2, rx1015_start
    sub rx1015_off, rx1015_pos, 1
    substr rx1015_tgt, rx1015_tgt, rx1015_off
  rx1015_start:
    eq $I10, 1, rx1015_restart
    if_null rx1015_debug, debug_790
    rx1015_cur."!cursor_debug"("START", "dotty")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1019_done
    goto rxscan1019_scan
  rxscan1019_loop:
    (rx1015_pos) = rx1015_cur."from"()
    inc rx1015_pos
    rx1015_cur."!cursor_from"(rx1015_pos)
    ge rx1015_pos, rx1015_eos, rxscan1019_done
  rxscan1019_scan:
    set_addr $I10, rxscan1019_loop
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxscan1019_done:
.annotate 'line', 454
  # rx literal  "."
    add $I11, rx1015_pos, 1
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    ord $I11, rx1015_tgt, $I11
    ne $I11, 46, rx1015_fail
    add rx1015_pos, 1
  alt1020_0:
.annotate 'line', 455
    set_addr $I10, alt1020_1
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."deflongname"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1015_pos = $P10."pos"()
    goto alt1020_end
  alt1020_1:
.annotate 'line', 456
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1015_pos, rx1015_off
    substr $S10, rx1015_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1015_fail
  # rx subrule "quote" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."quote"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1015_pos = $P10."pos"()
  alt1021_0:
.annotate 'line', 457
    set_addr $I10, alt1021_1
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1015_pos, rx1015_off
    substr $S10, rx1015_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1015_fail
    goto alt1021_end
  alt1021_1:
  # rx subrule "panic" subtype=method negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1015_fail
    rx1015_pos = $P10."pos"()
  alt1021_end:
  alt1020_end:
.annotate 'line', 463
  # rx rxquantr1022 ** 0..1
    set_addr $I10, rxquantr1022_done
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxquantr1022_loop:
  alt1023_0:
.annotate 'line', 460
    set_addr $I10, alt1023_1
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
.annotate 'line', 461
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1015_pos, rx1015_off
    substr $S10, rx1015_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1015_fail
  # rx subrule "args" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."args"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1015_pos = $P10."pos"()
    goto alt1023_end
  alt1023_1:
.annotate 'line', 462
  # rx literal  ":"
    add $I11, rx1015_pos, 1
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    ord $I11, rx1015_tgt, $I11
    ne $I11, 58, rx1015_fail
    add rx1015_pos, 1
  # rx charclass s
    ge rx1015_pos, rx1015_eos, rx1015_fail
    sub $I10, rx1015_pos, rx1015_off
    is_cclass $I11, 32, rx1015_tgt, $I10
    unless $I11, rx1015_fail
    inc rx1015_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."arglist"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1015_pos = $P10."pos"()
  alt1023_end:
.annotate 'line', 463
    set_addr $I10, rxquantr1022_done
    (rx1015_rep) = rx1015_cur."!mark_commit"($I10)
  rxquantr1022_done:
.annotate 'line', 453
  # rx pass
    rx1015_cur."!cursor_pass"(rx1015_pos, "dotty")
    if_null rx1015_debug, debug_791
    rx1015_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1015_pos)
  debug_791:
    .return (rx1015_cur)
  rx1015_restart:
.annotate 'line', 4
    if_null rx1015_debug, debug_792
    rx1015_cur."!cursor_debug"("NEXT", "dotty")
  debug_792:
  rx1015_fail:
    (rx1015_rep, rx1015_pos, $I10, $P10) = rx1015_cur."!mark_fail"(0)
    lt rx1015_pos, -1, rx1015_done
    eq rx1015_pos, -1, rx1015_fail
    jump $I10
  rx1015_done:
    rx1015_cur."!cursor_fail"()
    if_null rx1015_debug, debug_793
    rx1015_cur."!cursor_debug"("FAIL", "dotty")
  debug_793:
    .return (rx1015_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("207_1299465717.405") :method
.annotate 'line', 4
    $P1017 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1018, "ResizablePMCArray"
    push $P1018, "'"
    push $P1018, "\""
    push $P1018, $P1017
    .return ($P1018)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("208_1299465717.405")
    .param pmc param_1025
.annotate 'line', 467
    .lex "self", param_1025
    $P1026 = param_1025."!protoregex"("term")
    .return ($P1026)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("209_1299465717.405")
    .param pmc param_1028
.annotate 'line', 467
    .lex "self", param_1028
    $P1029 = param_1028."!PREFIX__!protoregex"("term")
    .return ($P1029)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("210_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1031_tgt
    .local int rx1031_pos
    .local int rx1031_off
    .local int rx1031_eos
    .local int rx1031_rep
    .local pmc rx1031_cur
    .local pmc rx1031_debug
    (rx1031_cur, rx1031_pos, rx1031_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1031_cur
    .local pmc match
    .lex "$/", match
    length rx1031_eos, rx1031_tgt
    gt rx1031_pos, rx1031_eos, rx1031_done
    set rx1031_off, 0
    lt rx1031_pos, 2, rx1031_start
    sub rx1031_off, rx1031_pos, 1
    substr rx1031_tgt, rx1031_tgt, rx1031_off
  rx1031_start:
    eq $I10, 1, rx1031_restart
    if_null rx1031_debug, debug_794
    rx1031_cur."!cursor_debug"("START", "term:sym<self>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1034_done
    goto rxscan1034_scan
  rxscan1034_loop:
    (rx1031_pos) = rx1031_cur."from"()
    inc rx1031_pos
    rx1031_cur."!cursor_from"(rx1031_pos)
    ge rx1031_pos, rx1031_eos, rxscan1034_done
  rxscan1034_scan:
    set_addr $I10, rxscan1034_loop
    rx1031_cur."!mark_push"(0, rx1031_pos, $I10)
  rxscan1034_done:
.annotate 'line', 469
  # rx subcapture "sym"
    set_addr $I10, rxcap_1035_fail
    rx1031_cur."!mark_push"(0, rx1031_pos, $I10)
  # rx literal  "self"
    add $I11, rx1031_pos, 4
    gt $I11, rx1031_eos, rx1031_fail
    sub $I11, rx1031_pos, rx1031_off
    substr $S10, rx1031_tgt, $I11, 4
    ne $S10, "self", rx1031_fail
    add rx1031_pos, 4
    set_addr $I10, rxcap_1035_fail
    ($I12, $I11) = rx1031_cur."!mark_peek"($I10)
    rx1031_cur."!cursor_pos"($I11)
    ($P10) = rx1031_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1031_pos, "")
    rx1031_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1035_done
  rxcap_1035_fail:
    goto rx1031_fail
  rxcap_1035_done:
  # rxanchor rwb
    le rx1031_pos, 0, rx1031_fail
    sub $I10, rx1031_pos, rx1031_off
    is_cclass $I11, 8192, rx1031_tgt, $I10
    if $I11, rx1031_fail
    dec $I10
    is_cclass $I11, 8192, rx1031_tgt, $I10
    unless $I11, rx1031_fail
  # rx pass
    rx1031_cur."!cursor_pass"(rx1031_pos, "term:sym<self>")
    if_null rx1031_debug, debug_795
    rx1031_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1031_pos)
  debug_795:
    .return (rx1031_cur)
  rx1031_restart:
.annotate 'line', 4
    if_null rx1031_debug, debug_796
    rx1031_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_796:
  rx1031_fail:
    (rx1031_rep, rx1031_pos, $I10, $P10) = rx1031_cur."!mark_fail"(0)
    lt rx1031_pos, -1, rx1031_done
    eq rx1031_pos, -1, rx1031_fail
    jump $I10
  rx1031_done:
    rx1031_cur."!cursor_fail"()
    if_null rx1031_debug, debug_797
    rx1031_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_797:
    .return (rx1031_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("211_1299465717.405") :method
.annotate 'line', 4
    new $P1033, "ResizablePMCArray"
    push $P1033, "self"
    .return ($P1033)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("212_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1037_tgt
    .local int rx1037_pos
    .local int rx1037_off
    .local int rx1037_eos
    .local int rx1037_rep
    .local pmc rx1037_cur
    .local pmc rx1037_debug
    (rx1037_cur, rx1037_pos, rx1037_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1037_cur
    .local pmc match
    .lex "$/", match
    length rx1037_eos, rx1037_tgt
    gt rx1037_pos, rx1037_eos, rx1037_done
    set rx1037_off, 0
    lt rx1037_pos, 2, rx1037_start
    sub rx1037_off, rx1037_pos, 1
    substr rx1037_tgt, rx1037_tgt, rx1037_off
  rx1037_start:
    eq $I10, 1, rx1037_restart
    if_null rx1037_debug, debug_798
    rx1037_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1041_done
    goto rxscan1041_scan
  rxscan1041_loop:
    (rx1037_pos) = rx1037_cur."from"()
    inc rx1037_pos
    rx1037_cur."!cursor_from"(rx1037_pos)
    ge rx1037_pos, rx1037_eos, rxscan1041_done
  rxscan1041_scan:
    set_addr $I10, rxscan1041_loop
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxscan1041_done:
.annotate 'line', 472
  # rx subrule "deflongname" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."deflongname"()
    unless $P10, rx1037_fail
    rx1037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1037_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1037_pos, rx1037_off
    substr $S10, rx1037_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1037_fail
  # rx subrule "args" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."args"()
    unless $P10, rx1037_fail
    rx1037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1037_pos = $P10."pos"()
.annotate 'line', 471
  # rx pass
    rx1037_cur."!cursor_pass"(rx1037_pos, "term:sym<identifier>")
    if_null rx1037_debug, debug_799
    rx1037_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1037_pos)
  debug_799:
    .return (rx1037_cur)
  rx1037_restart:
.annotate 'line', 4
    if_null rx1037_debug, debug_800
    rx1037_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_800:
  rx1037_fail:
    (rx1037_rep, rx1037_pos, $I10, $P10) = rx1037_cur."!mark_fail"(0)
    lt rx1037_pos, -1, rx1037_done
    eq rx1037_pos, -1, rx1037_fail
    jump $I10
  rx1037_done:
    rx1037_cur."!cursor_fail"()
    if_null rx1037_debug, debug_801
    rx1037_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_801:
    .return (rx1037_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("213_1299465717.405") :method
.annotate 'line', 4
    $P1039 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1040, "ResizablePMCArray"
    push $P1040, $P1039
    .return ($P1040)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("214_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1043_tgt
    .local int rx1043_pos
    .local int rx1043_off
    .local int rx1043_eos
    .local int rx1043_rep
    .local pmc rx1043_cur
    .local pmc rx1043_debug
    (rx1043_cur, rx1043_pos, rx1043_tgt, $I10) = self."!cursor_start"()
    rx1043_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1043_cur
    .local pmc match
    .lex "$/", match
    length rx1043_eos, rx1043_tgt
    gt rx1043_pos, rx1043_eos, rx1043_done
    set rx1043_off, 0
    lt rx1043_pos, 2, rx1043_start
    sub rx1043_off, rx1043_pos, 1
    substr rx1043_tgt, rx1043_tgt, rx1043_off
  rx1043_start:
    eq $I10, 1, rx1043_restart
    if_null rx1043_debug, debug_802
    rx1043_cur."!cursor_debug"("START", "term:sym<name>")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1047_done
    goto rxscan1047_scan
  rxscan1047_loop:
    (rx1043_pos) = rx1043_cur."from"()
    inc rx1043_pos
    rx1043_cur."!cursor_from"(rx1043_pos)
    ge rx1043_pos, rx1043_eos, rxscan1047_done
  rxscan1047_scan:
    set_addr $I10, rxscan1047_loop
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
  rxscan1047_done:
.annotate 'line', 476
  # rx subrule "name" subtype=capture negate=
    rx1043_cur."!cursor_pos"(rx1043_pos)
    $P10 = rx1043_cur."name"()
    unless $P10, rx1043_fail
    rx1043_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1043_pos = $P10."pos"()
  # rx rxquantr1048 ** 0..1
    set_addr $I10, rxquantr1048_done
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
  rxquantr1048_loop:
  # rx subrule "args" subtype=capture negate=
    rx1043_cur."!cursor_pos"(rx1043_pos)
    $P10 = rx1043_cur."args"()
    unless $P10, rx1043_fail
    goto rxsubrule1049_pass
  rxsubrule1049_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1043_fail
  rxsubrule1049_pass:
    set_addr $I10, rxsubrule1049_back
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1043_pos = $P10."pos"()
    set_addr $I10, rxquantr1048_done
    (rx1043_rep) = rx1043_cur."!mark_commit"($I10)
  rxquantr1048_done:
.annotate 'line', 475
  # rx pass
    rx1043_cur."!cursor_pass"(rx1043_pos, "term:sym<name>")
    if_null rx1043_debug, debug_803
    rx1043_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1043_pos)
  debug_803:
    .return (rx1043_cur)
  rx1043_restart:
.annotate 'line', 4
    if_null rx1043_debug, debug_804
    rx1043_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_804:
  rx1043_fail:
    (rx1043_rep, rx1043_pos, $I10, $P10) = rx1043_cur."!mark_fail"(0)
    lt rx1043_pos, -1, rx1043_done
    eq rx1043_pos, -1, rx1043_fail
    jump $I10
  rx1043_done:
    rx1043_cur."!cursor_fail"()
    if_null rx1043_debug, debug_805
    rx1043_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_805:
    .return (rx1043_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("215_1299465717.405") :method
.annotate 'line', 4
    $P1045 = self."!PREFIX__!subrule"("name", "")
    new $P1046, "ResizablePMCArray"
    push $P1046, $P1045
    .return ($P1046)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("216_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1051_tgt
    .local int rx1051_pos
    .local int rx1051_off
    .local int rx1051_eos
    .local int rx1051_rep
    .local pmc rx1051_cur
    .local pmc rx1051_debug
    (rx1051_cur, rx1051_pos, rx1051_tgt, $I10) = self."!cursor_start"()
    rx1051_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1051_cur
    .local pmc match
    .lex "$/", match
    length rx1051_eos, rx1051_tgt
    gt rx1051_pos, rx1051_eos, rx1051_done
    set rx1051_off, 0
    lt rx1051_pos, 2, rx1051_start
    sub rx1051_off, rx1051_pos, 1
    substr rx1051_tgt, rx1051_tgt, rx1051_off
  rx1051_start:
    eq $I10, 1, rx1051_restart
    if_null rx1051_debug, debug_806
    rx1051_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_806:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1054_done
    goto rxscan1054_scan
  rxscan1054_loop:
    (rx1051_pos) = rx1051_cur."from"()
    inc rx1051_pos
    rx1051_cur."!cursor_from"(rx1051_pos)
    ge rx1051_pos, rx1051_eos, rxscan1054_done
  rxscan1054_scan:
    set_addr $I10, rxscan1054_loop
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  rxscan1054_done:
.annotate 'line', 480
  # rx literal  "pir::"
    add $I11, rx1051_pos, 5
    gt $I11, rx1051_eos, rx1051_fail
    sub $I11, rx1051_pos, rx1051_off
    substr $S10, rx1051_tgt, $I11, 5
    ne $S10, "pir::", rx1051_fail
    add rx1051_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1055_fail
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1051_pos, rx1051_off
    find_not_cclass $I11, 8192, rx1051_tgt, $I10, rx1051_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1051_fail
    add rx1051_pos, rx1051_off, $I11
    set_addr $I10, rxcap_1055_fail
    ($I12, $I11) = rx1051_cur."!mark_peek"($I10)
    rx1051_cur."!cursor_pos"($I11)
    ($P10) = rx1051_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1051_pos, "")
    rx1051_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1055_done
  rxcap_1055_fail:
    goto rx1051_fail
  rxcap_1055_done:
  # rx rxquantr1056 ** 0..1
    set_addr $I10, rxquantr1056_done
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  rxquantr1056_loop:
  # rx subrule "args" subtype=capture negate=
    rx1051_cur."!cursor_pos"(rx1051_pos)
    $P10 = rx1051_cur."args"()
    unless $P10, rx1051_fail
    goto rxsubrule1057_pass
  rxsubrule1057_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1051_fail
  rxsubrule1057_pass:
    set_addr $I10, rxsubrule1057_back
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1051_pos = $P10."pos"()
    set_addr $I10, rxquantr1056_done
    (rx1051_rep) = rx1051_cur."!mark_commit"($I10)
  rxquantr1056_done:
.annotate 'line', 479
  # rx pass
    rx1051_cur."!cursor_pass"(rx1051_pos, "term:sym<pir::op>")
    if_null rx1051_debug, debug_807
    rx1051_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1051_pos)
  debug_807:
    .return (rx1051_cur)
  rx1051_restart:
.annotate 'line', 4
    if_null rx1051_debug, debug_808
    rx1051_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_808:
  rx1051_fail:
    (rx1051_rep, rx1051_pos, $I10, $P10) = rx1051_cur."!mark_fail"(0)
    lt rx1051_pos, -1, rx1051_done
    eq rx1051_pos, -1, rx1051_fail
    jump $I10
  rx1051_done:
    rx1051_cur."!cursor_fail"()
    if_null rx1051_debug, debug_809
    rx1051_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_809:
    .return (rx1051_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("217_1299465717.405") :method
.annotate 'line', 4
    new $P1053, "ResizablePMCArray"
    push $P1053, "pir::"
    .return ($P1053)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("218_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P1067 = "220_1299465717.405" 
    capture_lex $P1067
    .local string rx1059_tgt
    .local int rx1059_pos
    .local int rx1059_off
    .local int rx1059_eos
    .local int rx1059_rep
    .local pmc rx1059_cur
    .local pmc rx1059_debug
    (rx1059_cur, rx1059_pos, rx1059_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1059_cur
    .local pmc match
    .lex "$/", match
    length rx1059_eos, rx1059_tgt
    gt rx1059_pos, rx1059_eos, rx1059_done
    set rx1059_off, 0
    lt rx1059_pos, 2, rx1059_start
    sub rx1059_off, rx1059_pos, 1
    substr rx1059_tgt, rx1059_tgt, rx1059_off
  rx1059_start:
    eq $I10, 1, rx1059_restart
    if_null rx1059_debug, debug_810
    rx1059_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1062_done
    goto rxscan1062_scan
  rxscan1062_loop:
    (rx1059_pos) = rx1059_cur."from"()
    inc rx1059_pos
    rx1059_cur."!cursor_from"(rx1059_pos)
    ge rx1059_pos, rx1059_eos, rxscan1062_done
  rxscan1062_scan:
    set_addr $I10, rxscan1062_loop
    rx1059_cur."!mark_push"(0, rx1059_pos, $I10)
  rxscan1062_done:
.annotate 'line', 484
  # rx literal  "{*}"
    add $I11, rx1059_pos, 3
    gt $I11, rx1059_eos, rx1059_fail
    sub $I11, rx1059_pos, rx1059_off
    substr $S10, rx1059_tgt, $I11, 3
    ne $S10, "{*}", rx1059_fail
    add rx1059_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1059_cur."!cursor_pos"(rx1059_pos)
    $P10 = rx1059_cur."ENDSTMT"()
    unless $P10, rx1059_fail
  alt1063_0:
.annotate 'line', 485
    set_addr $I10, alt1063_1
    rx1059_cur."!mark_push"(0, rx1059_pos, $I10)
    rx1059_cur."!cursor_pos"(rx1059_pos)
    find_lex $P1064, unicode:"$\x{a2}"
    $P1065 = $P1064."MATCH"()
    store_lex "$/", $P1065
    .const 'Sub' $P1067 = "220_1299465717.405" 
    capture_lex $P1067
    $P1071 = $P1067()
    unless $P1071, rx1059_fail
    goto alt1063_end
  alt1063_1:
  # rx subrule "panic" subtype=method negate=
    rx1059_cur."!cursor_pos"(rx1059_pos)
    $P10 = rx1059_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1059_fail
    rx1059_pos = $P10."pos"()
  alt1063_end:
.annotate 'line', 483
  # rx pass
    rx1059_cur."!cursor_pass"(rx1059_pos, "term:sym<onlystar>")
    if_null rx1059_debug, debug_813
    rx1059_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1059_pos)
  debug_813:
    .return (rx1059_cur)
  rx1059_restart:
.annotate 'line', 4
    if_null rx1059_debug, debug_814
    rx1059_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_814:
  rx1059_fail:
    (rx1059_rep, rx1059_pos, $I10, $P10) = rx1059_cur."!mark_fail"(0)
    lt rx1059_pos, -1, rx1059_done
    eq rx1059_pos, -1, rx1059_fail
    jump $I10
  rx1059_done:
    rx1059_cur."!cursor_fail"()
    if_null rx1059_debug, debug_815
    rx1059_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_815:
    .return (rx1059_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("219_1299465717.405") :method
.annotate 'line', 4
    new $P1061, "ResizablePMCArray"
    push $P1061, "{*}"
    .return ($P1061)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1066"  :anon :subid("220_1299465717.405") :outer("218_1299465717.405")
.annotate 'line', 485
    find_dynamic_lex $P1068, "$*MULTINESS"
    unless_null $P1068, vivify_811
    get_hll_global $P1068, "$MULTINESS"
    unless_null $P1068, vivify_812
    die "Contextual $*MULTINESS not found"
  vivify_812:
  vivify_811:
    set $S1069, $P1068
    iseq $I1070, $S1069, "proto"
    .return ($I1070)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("221_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1073_tgt
    .local int rx1073_pos
    .local int rx1073_off
    .local int rx1073_eos
    .local int rx1073_rep
    .local pmc rx1073_cur
    .local pmc rx1073_debug
    (rx1073_cur, rx1073_pos, rx1073_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1073_cur
    .local pmc match
    .lex "$/", match
    length rx1073_eos, rx1073_tgt
    gt rx1073_pos, rx1073_eos, rx1073_done
    set rx1073_off, 0
    lt rx1073_pos, 2, rx1073_start
    sub rx1073_off, rx1073_pos, 1
    substr rx1073_tgt, rx1073_tgt, rx1073_off
  rx1073_start:
    eq $I10, 1, rx1073_restart
    if_null rx1073_debug, debug_816
    rx1073_cur."!cursor_debug"("START", "args")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1077_done
    goto rxscan1077_scan
  rxscan1077_loop:
    (rx1073_pos) = rx1073_cur."from"()
    inc rx1073_pos
    rx1073_cur."!cursor_from"(rx1073_pos)
    ge rx1073_pos, rx1073_eos, rxscan1077_done
  rxscan1077_scan:
    set_addr $I10, rxscan1077_loop
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
  rxscan1077_done:
.annotate 'line', 489
  # rx literal  "("
    add $I11, rx1073_pos, 1
    gt $I11, rx1073_eos, rx1073_fail
    sub $I11, rx1073_pos, rx1073_off
    ord $I11, rx1073_tgt, $I11
    ne $I11, 40, rx1073_fail
    add rx1073_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."arglist"()
    unless $P10, rx1073_fail
    rx1073_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1073_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1073_pos, 1
    gt $I11, rx1073_eos, rx1073_fail
    sub $I11, rx1073_pos, rx1073_off
    ord $I11, rx1073_tgt, $I11
    ne $I11, 41, rx1073_fail
    add rx1073_pos, 1
  # rx pass
    rx1073_cur."!cursor_pass"(rx1073_pos, "args")
    if_null rx1073_debug, debug_817
    rx1073_cur."!cursor_debug"("PASS", "args", " at pos=", rx1073_pos)
  debug_817:
    .return (rx1073_cur)
  rx1073_restart:
.annotate 'line', 4
    if_null rx1073_debug, debug_818
    rx1073_cur."!cursor_debug"("NEXT", "args")
  debug_818:
  rx1073_fail:
    (rx1073_rep, rx1073_pos, $I10, $P10) = rx1073_cur."!mark_fail"(0)
    lt rx1073_pos, -1, rx1073_done
    eq rx1073_pos, -1, rx1073_fail
    jump $I10
  rx1073_done:
    rx1073_cur."!cursor_fail"()
    if_null rx1073_debug, debug_819
    rx1073_cur."!cursor_debug"("FAIL", "args")
  debug_819:
    .return (rx1073_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("222_1299465717.405") :method
.annotate 'line', 4
    $P1075 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1076, "ResizablePMCArray"
    push $P1076, $P1075
    .return ($P1076)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("223_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1079_tgt
    .local int rx1079_pos
    .local int rx1079_off
    .local int rx1079_eos
    .local int rx1079_rep
    .local pmc rx1079_cur
    .local pmc rx1079_debug
    (rx1079_cur, rx1079_pos, rx1079_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1079_cur
    .local pmc match
    .lex "$/", match
    length rx1079_eos, rx1079_tgt
    gt rx1079_pos, rx1079_eos, rx1079_done
    set rx1079_off, 0
    lt rx1079_pos, 2, rx1079_start
    sub rx1079_off, rx1079_pos, 1
    substr rx1079_tgt, rx1079_tgt, rx1079_off
  rx1079_start:
    eq $I10, 1, rx1079_restart
    if_null rx1079_debug, debug_820
    rx1079_cur."!cursor_debug"("START", "arglist")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1083_done
    goto rxscan1083_scan
  rxscan1083_loop:
    (rx1079_pos) = rx1079_cur."from"()
    inc rx1079_pos
    rx1079_cur."!cursor_from"(rx1079_pos)
    ge rx1079_pos, rx1079_eos, rxscan1083_done
  rxscan1083_scan:
    set_addr $I10, rxscan1083_loop
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxscan1083_done:
.annotate 'line', 493
  # rx subrule "ws" subtype=method negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."ws"()
    unless $P10, rx1079_fail
    rx1079_pos = $P10."pos"()
  alt1084_0:
.annotate 'line', 494
    set_addr $I10, alt1084_1
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
.annotate 'line', 495
  # rx subrule "EXPR" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."EXPR"("f=")
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1079_pos = $P10."pos"()
    goto alt1084_end
  alt1084_1:
  alt1084_end:
.annotate 'line', 492
  # rx pass
    rx1079_cur."!cursor_pass"(rx1079_pos, "arglist")
    if_null rx1079_debug, debug_821
    rx1079_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1079_pos)
  debug_821:
    .return (rx1079_cur)
  rx1079_restart:
.annotate 'line', 4
    if_null rx1079_debug, debug_822
    rx1079_cur."!cursor_debug"("NEXT", "arglist")
  debug_822:
  rx1079_fail:
    (rx1079_rep, rx1079_pos, $I10, $P10) = rx1079_cur."!mark_fail"(0)
    lt rx1079_pos, -1, rx1079_done
    eq rx1079_pos, -1, rx1079_fail
    jump $I10
  rx1079_done:
    rx1079_cur."!cursor_fail"()
    if_null rx1079_debug, debug_823
    rx1079_cur."!cursor_debug"("FAIL", "arglist")
  debug_823:
    .return (rx1079_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("224_1299465717.405") :method
.annotate 'line', 4
    $P1081 = self."!PREFIX__!subrule"("ws", "")
    new $P1082, "ResizablePMCArray"
    push $P1082, $P1081
    .return ($P1082)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("225_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1086_tgt
    .local int rx1086_pos
    .local int rx1086_off
    .local int rx1086_eos
    .local int rx1086_rep
    .local pmc rx1086_cur
    .local pmc rx1086_debug
    (rx1086_cur, rx1086_pos, rx1086_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1086_cur
    .local pmc match
    .lex "$/", match
    length rx1086_eos, rx1086_tgt
    gt rx1086_pos, rx1086_eos, rx1086_done
    set rx1086_off, 0
    lt rx1086_pos, 2, rx1086_start
    sub rx1086_off, rx1086_pos, 1
    substr rx1086_tgt, rx1086_tgt, rx1086_off
  rx1086_start:
    eq $I10, 1, rx1086_restart
    if_null rx1086_debug, debug_824
    rx1086_cur."!cursor_debug"("START", "term:sym<value>")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1090_done
    goto rxscan1090_scan
  rxscan1090_loop:
    (rx1086_pos) = rx1086_cur."from"()
    inc rx1086_pos
    rx1086_cur."!cursor_from"(rx1086_pos)
    ge rx1086_pos, rx1086_eos, rxscan1090_done
  rxscan1090_scan:
    set_addr $I10, rxscan1090_loop
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  rxscan1090_done:
.annotate 'line', 501
  # rx subrule "value" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."value"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1086_pos = $P10."pos"()
  # rx pass
    rx1086_cur."!cursor_pass"(rx1086_pos, "term:sym<value>")
    if_null rx1086_debug, debug_825
    rx1086_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1086_pos)
  debug_825:
    .return (rx1086_cur)
  rx1086_restart:
.annotate 'line', 4
    if_null rx1086_debug, debug_826
    rx1086_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_826:
  rx1086_fail:
    (rx1086_rep, rx1086_pos, $I10, $P10) = rx1086_cur."!mark_fail"(0)
    lt rx1086_pos, -1, rx1086_done
    eq rx1086_pos, -1, rx1086_fail
    jump $I10
  rx1086_done:
    rx1086_cur."!cursor_fail"()
    if_null rx1086_debug, debug_827
    rx1086_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_827:
    .return (rx1086_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("226_1299465717.405") :method
.annotate 'line', 4
    $P1088 = self."!PREFIX__!subrule"("value", "")
    new $P1089, "ResizablePMCArray"
    push $P1089, $P1088
    .return ($P1089)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("227_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1092_tgt
    .local int rx1092_pos
    .local int rx1092_off
    .local int rx1092_eos
    .local int rx1092_rep
    .local pmc rx1092_cur
    .local pmc rx1092_debug
    (rx1092_cur, rx1092_pos, rx1092_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1092_cur
    .local pmc match
    .lex "$/", match
    length rx1092_eos, rx1092_tgt
    gt rx1092_pos, rx1092_eos, rx1092_done
    set rx1092_off, 0
    lt rx1092_pos, 2, rx1092_start
    sub rx1092_off, rx1092_pos, 1
    substr rx1092_tgt, rx1092_tgt, rx1092_off
  rx1092_start:
    eq $I10, 1, rx1092_restart
    if_null rx1092_debug, debug_828
    rx1092_cur."!cursor_debug"("START", "value")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1097_done
    goto rxscan1097_scan
  rxscan1097_loop:
    (rx1092_pos) = rx1092_cur."from"()
    inc rx1092_pos
    rx1092_cur."!cursor_from"(rx1092_pos)
    ge rx1092_pos, rx1092_eos, rxscan1097_done
  rxscan1097_scan:
    set_addr $I10, rxscan1097_loop
    rx1092_cur."!mark_push"(0, rx1092_pos, $I10)
  rxscan1097_done:
  alt1098_0:
.annotate 'line', 503
    set_addr $I10, alt1098_1
    rx1092_cur."!mark_push"(0, rx1092_pos, $I10)
.annotate 'line', 504
  # rx subrule "quote" subtype=capture negate=
    rx1092_cur."!cursor_pos"(rx1092_pos)
    $P10 = rx1092_cur."quote"()
    unless $P10, rx1092_fail
    rx1092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1092_pos = $P10."pos"()
    goto alt1098_end
  alt1098_1:
.annotate 'line', 505
  # rx subrule "number" subtype=capture negate=
    rx1092_cur."!cursor_pos"(rx1092_pos)
    $P10 = rx1092_cur."number"()
    unless $P10, rx1092_fail
    rx1092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1092_pos = $P10."pos"()
  alt1098_end:
.annotate 'line', 503
  # rx pass
    rx1092_cur."!cursor_pass"(rx1092_pos, "value")
    if_null rx1092_debug, debug_829
    rx1092_cur."!cursor_debug"("PASS", "value", " at pos=", rx1092_pos)
  debug_829:
    .return (rx1092_cur)
  rx1092_restart:
.annotate 'line', 4
    if_null rx1092_debug, debug_830
    rx1092_cur."!cursor_debug"("NEXT", "value")
  debug_830:
  rx1092_fail:
    (rx1092_rep, rx1092_pos, $I10, $P10) = rx1092_cur."!mark_fail"(0)
    lt rx1092_pos, -1, rx1092_done
    eq rx1092_pos, -1, rx1092_fail
    jump $I10
  rx1092_done:
    rx1092_cur."!cursor_fail"()
    if_null rx1092_debug, debug_831
    rx1092_cur."!cursor_debug"("FAIL", "value")
  debug_831:
    .return (rx1092_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("228_1299465717.405") :method
.annotate 'line', 4
    $P1094 = self."!PREFIX__!subrule"("number", "")
    $P1095 = self."!PREFIX__!subrule"("quote", "")
    new $P1096, "ResizablePMCArray"
    push $P1096, $P1094
    push $P1096, $P1095
    .return ($P1096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("229_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1100_tgt
    .local int rx1100_pos
    .local int rx1100_off
    .local int rx1100_eos
    .local int rx1100_rep
    .local pmc rx1100_cur
    .local pmc rx1100_debug
    (rx1100_cur, rx1100_pos, rx1100_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1100_cur
    .local pmc match
    .lex "$/", match
    length rx1100_eos, rx1100_tgt
    gt rx1100_pos, rx1100_eos, rx1100_done
    set rx1100_off, 0
    lt rx1100_pos, 2, rx1100_start
    sub rx1100_off, rx1100_pos, 1
    substr rx1100_tgt, rx1100_tgt, rx1100_off
  rx1100_start:
    eq $I10, 1, rx1100_restart
    if_null rx1100_debug, debug_832
    rx1100_cur."!cursor_debug"("START", "number")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1103_done
    goto rxscan1103_scan
  rxscan1103_loop:
    (rx1100_pos) = rx1100_cur."from"()
    inc rx1100_pos
    rx1100_cur."!cursor_from"(rx1100_pos)
    ge rx1100_pos, rx1100_eos, rxscan1103_done
  rxscan1103_scan:
    set_addr $I10, rxscan1103_loop
    rx1100_cur."!mark_push"(0, rx1100_pos, $I10)
  rxscan1103_done:
.annotate 'line', 509
  # rx subcapture "sign"
    set_addr $I10, rxcap_1105_fail
    rx1100_cur."!mark_push"(0, rx1100_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1100_pos, rx1100_off
    set rx1100_rep, 0
    sub $I12, rx1100_eos, rx1100_pos
    le $I12, 1, rxenumcharlistq1104_loop
    set $I12, 1
  rxenumcharlistq1104_loop:
    le $I12, 0, rxenumcharlistq1104_done
    substr $S10, rx1100_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1104_done
    inc rx1100_rep
  rxenumcharlistq1104_done:
    add rx1100_pos, rx1100_pos, rx1100_rep
    set_addr $I10, rxcap_1105_fail
    ($I12, $I11) = rx1100_cur."!mark_peek"($I10)
    rx1100_cur."!cursor_pos"($I11)
    ($P10) = rx1100_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1100_pos, "")
    rx1100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1105_done
  rxcap_1105_fail:
    goto rx1100_fail
  rxcap_1105_done:
  alt1106_0:
.annotate 'line', 510
    set_addr $I10, alt1106_1
    rx1100_cur."!mark_push"(0, rx1100_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1100_cur."!cursor_pos"(rx1100_pos)
    $P10 = rx1100_cur."dec_number"()
    unless $P10, rx1100_fail
    rx1100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1100_pos = $P10."pos"()
    goto alt1106_end
  alt1106_1:
  # rx subrule "integer" subtype=capture negate=
    rx1100_cur."!cursor_pos"(rx1100_pos)
    $P10 = rx1100_cur."integer"()
    unless $P10, rx1100_fail
    rx1100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1100_pos = $P10."pos"()
  alt1106_end:
.annotate 'line', 508
  # rx pass
    rx1100_cur."!cursor_pass"(rx1100_pos, "number")
    if_null rx1100_debug, debug_833
    rx1100_cur."!cursor_debug"("PASS", "number", " at pos=", rx1100_pos)
  debug_833:
    .return (rx1100_cur)
  rx1100_restart:
.annotate 'line', 4
    if_null rx1100_debug, debug_834
    rx1100_cur."!cursor_debug"("NEXT", "number")
  debug_834:
  rx1100_fail:
    (rx1100_rep, rx1100_pos, $I10, $P10) = rx1100_cur."!mark_fail"(0)
    lt rx1100_pos, -1, rx1100_done
    eq rx1100_pos, -1, rx1100_fail
    jump $I10
  rx1100_done:
    rx1100_cur."!cursor_fail"()
    if_null rx1100_debug, debug_835
    rx1100_cur."!cursor_debug"("FAIL", "number")
  debug_835:
    .return (rx1100_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("230_1299465717.405") :method
.annotate 'line', 4
    new $P1102, "ResizablePMCArray"
    push $P1102, ""
    .return ($P1102)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("231_1299465717.405")
    .param pmc param_1108
.annotate 'line', 513
    .lex "self", param_1108
    $P1109 = param_1108."!protoregex"("quote")
    .return ($P1109)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("232_1299465717.405")
    .param pmc param_1111
.annotate 'line', 513
    .lex "self", param_1111
    $P1112 = param_1111."!PREFIX__!protoregex"("quote")
    .return ($P1112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("233_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1114_tgt
    .local int rx1114_pos
    .local int rx1114_off
    .local int rx1114_eos
    .local int rx1114_rep
    .local pmc rx1114_cur
    .local pmc rx1114_debug
    (rx1114_cur, rx1114_pos, rx1114_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1114_cur
    .local pmc match
    .lex "$/", match
    length rx1114_eos, rx1114_tgt
    gt rx1114_pos, rx1114_eos, rx1114_done
    set rx1114_off, 0
    lt rx1114_pos, 2, rx1114_start
    sub rx1114_off, rx1114_pos, 1
    substr rx1114_tgt, rx1114_tgt, rx1114_off
  rx1114_start:
    eq $I10, 1, rx1114_restart
    if_null rx1114_debug, debug_836
    rx1114_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1117_done
    goto rxscan1117_scan
  rxscan1117_loop:
    (rx1114_pos) = rx1114_cur."from"()
    inc rx1114_pos
    rx1114_cur."!cursor_from"(rx1114_pos)
    ge rx1114_pos, rx1114_eos, rxscan1117_done
  rxscan1117_scan:
    set_addr $I10, rxscan1117_loop
    rx1114_cur."!mark_push"(0, rx1114_pos, $I10)
  rxscan1117_done:
.annotate 'line', 514
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1114_pos, rx1114_off
    substr $S10, rx1114_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1114_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1114_cur."!cursor_pos"(rx1114_pos)
    $P10 = rx1114_cur."quote_EXPR"(":q")
    unless $P10, rx1114_fail
    rx1114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1114_pos = $P10."pos"()
  # rx pass
    rx1114_cur."!cursor_pass"(rx1114_pos, "quote:sym<apos>")
    if_null rx1114_debug, debug_837
    rx1114_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1114_pos)
  debug_837:
    .return (rx1114_cur)
  rx1114_restart:
.annotate 'line', 4
    if_null rx1114_debug, debug_838
    rx1114_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_838:
  rx1114_fail:
    (rx1114_rep, rx1114_pos, $I10, $P10) = rx1114_cur."!mark_fail"(0)
    lt rx1114_pos, -1, rx1114_done
    eq rx1114_pos, -1, rx1114_fail
    jump $I10
  rx1114_done:
    rx1114_cur."!cursor_fail"()
    if_null rx1114_debug, debug_839
    rx1114_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_839:
    .return (rx1114_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("234_1299465717.405") :method
.annotate 'line', 4
    new $P1116, "ResizablePMCArray"
    push $P1116, "'"
    .return ($P1116)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("235_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1119_tgt
    .local int rx1119_pos
    .local int rx1119_off
    .local int rx1119_eos
    .local int rx1119_rep
    .local pmc rx1119_cur
    .local pmc rx1119_debug
    (rx1119_cur, rx1119_pos, rx1119_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1119_cur
    .local pmc match
    .lex "$/", match
    length rx1119_eos, rx1119_tgt
    gt rx1119_pos, rx1119_eos, rx1119_done
    set rx1119_off, 0
    lt rx1119_pos, 2, rx1119_start
    sub rx1119_off, rx1119_pos, 1
    substr rx1119_tgt, rx1119_tgt, rx1119_off
  rx1119_start:
    eq $I10, 1, rx1119_restart
    if_null rx1119_debug, debug_840
    rx1119_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1122_done
    goto rxscan1122_scan
  rxscan1122_loop:
    (rx1119_pos) = rx1119_cur."from"()
    inc rx1119_pos
    rx1119_cur."!cursor_from"(rx1119_pos)
    ge rx1119_pos, rx1119_eos, rxscan1122_done
  rxscan1122_scan:
    set_addr $I10, rxscan1122_loop
    rx1119_cur."!mark_push"(0, rx1119_pos, $I10)
  rxscan1122_done:
.annotate 'line', 515
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1119_pos, rx1119_off
    substr $S10, rx1119_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1119_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1119_cur."!cursor_pos"(rx1119_pos)
    $P10 = rx1119_cur."quote_EXPR"(":qq")
    unless $P10, rx1119_fail
    rx1119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1119_pos = $P10."pos"()
  # rx pass
    rx1119_cur."!cursor_pass"(rx1119_pos, "quote:sym<dblq>")
    if_null rx1119_debug, debug_841
    rx1119_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1119_pos)
  debug_841:
    .return (rx1119_cur)
  rx1119_restart:
.annotate 'line', 4
    if_null rx1119_debug, debug_842
    rx1119_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_842:
  rx1119_fail:
    (rx1119_rep, rx1119_pos, $I10, $P10) = rx1119_cur."!mark_fail"(0)
    lt rx1119_pos, -1, rx1119_done
    eq rx1119_pos, -1, rx1119_fail
    jump $I10
  rx1119_done:
    rx1119_cur."!cursor_fail"()
    if_null rx1119_debug, debug_843
    rx1119_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_843:
    .return (rx1119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("236_1299465717.405") :method
.annotate 'line', 4
    new $P1121, "ResizablePMCArray"
    push $P1121, "\""
    .return ($P1121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("237_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1124_tgt
    .local int rx1124_pos
    .local int rx1124_off
    .local int rx1124_eos
    .local int rx1124_rep
    .local pmc rx1124_cur
    .local pmc rx1124_debug
    (rx1124_cur, rx1124_pos, rx1124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1124_cur
    .local pmc match
    .lex "$/", match
    length rx1124_eos, rx1124_tgt
    gt rx1124_pos, rx1124_eos, rx1124_done
    set rx1124_off, 0
    lt rx1124_pos, 2, rx1124_start
    sub rx1124_off, rx1124_pos, 1
    substr rx1124_tgt, rx1124_tgt, rx1124_off
  rx1124_start:
    eq $I10, 1, rx1124_restart
    if_null rx1124_debug, debug_844
    rx1124_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1128_done
    goto rxscan1128_scan
  rxscan1128_loop:
    (rx1124_pos) = rx1124_cur."from"()
    inc rx1124_pos
    rx1124_cur."!cursor_from"(rx1124_pos)
    ge rx1124_pos, rx1124_eos, rxscan1128_done
  rxscan1128_scan:
    set_addr $I10, rxscan1128_loop
    rx1124_cur."!mark_push"(0, rx1124_pos, $I10)
  rxscan1128_done:
.annotate 'line', 516
  # rx literal  "q"
    add $I11, rx1124_pos, 1
    gt $I11, rx1124_eos, rx1124_fail
    sub $I11, rx1124_pos, rx1124_off
    ord $I11, rx1124_tgt, $I11
    ne $I11, 113, rx1124_fail
    add rx1124_pos, 1
  # rxanchor rwb
    le rx1124_pos, 0, rx1124_fail
    sub $I10, rx1124_pos, rx1124_off
    is_cclass $I11, 8192, rx1124_tgt, $I10
    if $I11, rx1124_fail
    dec $I10
    is_cclass $I11, 8192, rx1124_tgt, $I10
    unless $I11, rx1124_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1124_pos, rx1124_off
    substr $S10, rx1124_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1124_fail
  # rx subrule "ws" subtype=method negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."ws"()
    unless $P10, rx1124_fail
    rx1124_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."quote_EXPR"(":q")
    unless $P10, rx1124_fail
    rx1124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1124_pos = $P10."pos"()
  # rx pass
    rx1124_cur."!cursor_pass"(rx1124_pos, "quote:sym<q>")
    if_null rx1124_debug, debug_845
    rx1124_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1124_pos)
  debug_845:
    .return (rx1124_cur)
  rx1124_restart:
.annotate 'line', 4
    if_null rx1124_debug, debug_846
    rx1124_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_846:
  rx1124_fail:
    (rx1124_rep, rx1124_pos, $I10, $P10) = rx1124_cur."!mark_fail"(0)
    lt rx1124_pos, -1, rx1124_done
    eq rx1124_pos, -1, rx1124_fail
    jump $I10
  rx1124_done:
    rx1124_cur."!cursor_fail"()
    if_null rx1124_debug, debug_847
    rx1124_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_847:
    .return (rx1124_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("238_1299465717.405") :method
.annotate 'line', 4
    $P1126 = self."!PREFIX__!subrule"("ws", "q")
    new $P1127, "ResizablePMCArray"
    push $P1127, $P1126
    .return ($P1127)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("239_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_848
    rx1130_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 517
  # rx literal  "qq"
    add $I11, rx1130_pos, 2
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    substr $S10, rx1130_tgt, $I11, 2
    ne $S10, "qq", rx1130_fail
    add rx1130_pos, 2
  # rxanchor rwb
    le rx1130_pos, 0, rx1130_fail
    sub $I10, rx1130_pos, rx1130_off
    is_cclass $I11, 8192, rx1130_tgt, $I10
    if $I11, rx1130_fail
    dec $I10
    is_cclass $I11, 8192, rx1130_tgt, $I10
    unless $I11, rx1130_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1130_pos, rx1130_off
    substr $S10, rx1130_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1130_fail
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."quote_EXPR"(":qq")
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1130_pos = $P10."pos"()
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "quote:sym<qq>")
    if_null rx1130_debug, debug_849
    rx1130_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1130_pos)
  debug_849:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 4
    if_null rx1130_debug, debug_850
    rx1130_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_850:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_851
    rx1130_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_851:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("240_1299465717.405") :method
.annotate 'line', 4
    $P1132 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("241_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1136_tgt
    .local int rx1136_pos
    .local int rx1136_off
    .local int rx1136_eos
    .local int rx1136_rep
    .local pmc rx1136_cur
    .local pmc rx1136_debug
    (rx1136_cur, rx1136_pos, rx1136_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1136_cur
    .local pmc match
    .lex "$/", match
    length rx1136_eos, rx1136_tgt
    gt rx1136_pos, rx1136_eos, rx1136_done
    set rx1136_off, 0
    lt rx1136_pos, 2, rx1136_start
    sub rx1136_off, rx1136_pos, 1
    substr rx1136_tgt, rx1136_tgt, rx1136_off
  rx1136_start:
    eq $I10, 1, rx1136_restart
    if_null rx1136_debug, debug_852
    rx1136_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1140_done
    goto rxscan1140_scan
  rxscan1140_loop:
    (rx1136_pos) = rx1136_cur."from"()
    inc rx1136_pos
    rx1136_cur."!cursor_from"(rx1136_pos)
    ge rx1136_pos, rx1136_eos, rxscan1140_done
  rxscan1140_scan:
    set_addr $I10, rxscan1140_loop
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxscan1140_done:
.annotate 'line', 518
  # rx literal  "Q"
    add $I11, rx1136_pos, 1
    gt $I11, rx1136_eos, rx1136_fail
    sub $I11, rx1136_pos, rx1136_off
    ord $I11, rx1136_tgt, $I11
    ne $I11, 81, rx1136_fail
    add rx1136_pos, 1
  # rxanchor rwb
    le rx1136_pos, 0, rx1136_fail
    sub $I10, rx1136_pos, rx1136_off
    is_cclass $I11, 8192, rx1136_tgt, $I10
    if $I11, rx1136_fail
    dec $I10
    is_cclass $I11, 8192, rx1136_tgt, $I10
    unless $I11, rx1136_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1136_pos, rx1136_off
    substr $S10, rx1136_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1136_fail
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."quote_EXPR"()
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1136_pos = $P10."pos"()
  # rx pass
    rx1136_cur."!cursor_pass"(rx1136_pos, "quote:sym<Q>")
    if_null rx1136_debug, debug_853
    rx1136_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1136_pos)
  debug_853:
    .return (rx1136_cur)
  rx1136_restart:
.annotate 'line', 4
    if_null rx1136_debug, debug_854
    rx1136_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_854:
  rx1136_fail:
    (rx1136_rep, rx1136_pos, $I10, $P10) = rx1136_cur."!mark_fail"(0)
    lt rx1136_pos, -1, rx1136_done
    eq rx1136_pos, -1, rx1136_fail
    jump $I10
  rx1136_done:
    rx1136_cur."!cursor_fail"()
    if_null rx1136_debug, debug_855
    rx1136_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_855:
    .return (rx1136_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("242_1299465717.405") :method
.annotate 'line', 4
    $P1138 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1139, "ResizablePMCArray"
    push $P1139, $P1138
    .return ($P1139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("243_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1142_tgt
    .local int rx1142_pos
    .local int rx1142_off
    .local int rx1142_eos
    .local int rx1142_rep
    .local pmc rx1142_cur
    .local pmc rx1142_debug
    (rx1142_cur, rx1142_pos, rx1142_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1142_cur
    .local pmc match
    .lex "$/", match
    length rx1142_eos, rx1142_tgt
    gt rx1142_pos, rx1142_eos, rx1142_done
    set rx1142_off, 0
    lt rx1142_pos, 2, rx1142_start
    sub rx1142_off, rx1142_pos, 1
    substr rx1142_tgt, rx1142_tgt, rx1142_off
  rx1142_start:
    eq $I10, 1, rx1142_restart
    if_null rx1142_debug, debug_856
    rx1142_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1146_done
    goto rxscan1146_scan
  rxscan1146_loop:
    (rx1142_pos) = rx1142_cur."from"()
    inc rx1142_pos
    rx1142_cur."!cursor_from"(rx1142_pos)
    ge rx1142_pos, rx1142_eos, rxscan1146_done
  rxscan1146_scan:
    set_addr $I10, rxscan1146_loop
    rx1142_cur."!mark_push"(0, rx1142_pos, $I10)
  rxscan1146_done:
.annotate 'line', 519
  # rx literal  "Q:PIR"
    add $I11, rx1142_pos, 5
    gt $I11, rx1142_eos, rx1142_fail
    sub $I11, rx1142_pos, rx1142_off
    substr $S10, rx1142_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1142_fail
    add rx1142_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."ws"()
    unless $P10, rx1142_fail
    rx1142_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."quote_EXPR"()
    unless $P10, rx1142_fail
    rx1142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1142_pos = $P10."pos"()
  # rx pass
    rx1142_cur."!cursor_pass"(rx1142_pos, "quote:sym<Q:PIR>")
    if_null rx1142_debug, debug_857
    rx1142_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1142_pos)
  debug_857:
    .return (rx1142_cur)
  rx1142_restart:
.annotate 'line', 4
    if_null rx1142_debug, debug_858
    rx1142_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_858:
  rx1142_fail:
    (rx1142_rep, rx1142_pos, $I10, $P10) = rx1142_cur."!mark_fail"(0)
    lt rx1142_pos, -1, rx1142_done
    eq rx1142_pos, -1, rx1142_fail
    jump $I10
  rx1142_done:
    rx1142_cur."!cursor_fail"()
    if_null rx1142_debug, debug_859
    rx1142_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_859:
    .return (rx1142_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("244_1299465717.405") :method
.annotate 'line', 4
    $P1144 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1145, "ResizablePMCArray"
    push $P1145, $P1144
    .return ($P1145)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("245_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1148_tgt
    .local int rx1148_pos
    .local int rx1148_off
    .local int rx1148_eos
    .local int rx1148_rep
    .local pmc rx1148_cur
    .local pmc rx1148_debug
    (rx1148_cur, rx1148_pos, rx1148_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1148_cur
    .local pmc match
    .lex "$/", match
    length rx1148_eos, rx1148_tgt
    gt rx1148_pos, rx1148_eos, rx1148_done
    set rx1148_off, 0
    lt rx1148_pos, 2, rx1148_start
    sub rx1148_off, rx1148_pos, 1
    substr rx1148_tgt, rx1148_tgt, rx1148_off
  rx1148_start:
    eq $I10, 1, rx1148_restart
    if_null rx1148_debug, debug_860
    rx1148_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1152_done
    goto rxscan1152_scan
  rxscan1152_loop:
    (rx1148_pos) = rx1148_cur."from"()
    inc rx1148_pos
    rx1148_cur."!cursor_from"(rx1148_pos)
    ge rx1148_pos, rx1148_eos, rxscan1152_done
  rxscan1152_scan:
    set_addr $I10, rxscan1152_loop
    rx1148_cur."!mark_push"(0, rx1148_pos, $I10)
  rxscan1152_done:
.annotate 'line', 521
  # rx literal  "/"
    add $I11, rx1148_pos, 1
    gt $I11, rx1148_eos, rx1148_fail
    sub $I11, rx1148_pos, rx1148_off
    ord $I11, rx1148_tgt, $I11
    ne $I11, 47, rx1148_fail
    add rx1148_pos, 1
.annotate 'line', 522
  # rx subrule "newpad" subtype=method negate=
    rx1148_cur."!cursor_pos"(rx1148_pos)
    $P10 = rx1148_cur."newpad"()
    unless $P10, rx1148_fail
    rx1148_pos = $P10."pos"()
.annotate 'line', 523
  # rx reduce name="quote:sym</ />" key="open"
    rx1148_cur."!cursor_pos"(rx1148_pos)
    rx1148_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 524
  # rx subrule "LANG" subtype=capture negate=
    rx1148_cur."!cursor_pos"(rx1148_pos)
    $P10 = rx1148_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1148_fail
    rx1148_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1148_pos = $P10."pos"()
.annotate 'line', 525
  # rx literal  "/"
    add $I11, rx1148_pos, 1
    gt $I11, rx1148_eos, rx1148_fail
    sub $I11, rx1148_pos, rx1148_off
    ord $I11, rx1148_tgt, $I11
    ne $I11, 47, rx1148_fail
    add rx1148_pos, 1
.annotate 'line', 520
  # rx pass
    rx1148_cur."!cursor_pass"(rx1148_pos, "quote:sym</ />")
    if_null rx1148_debug, debug_861
    rx1148_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1148_pos)
  debug_861:
    .return (rx1148_cur)
  rx1148_restart:
.annotate 'line', 4
    if_null rx1148_debug, debug_862
    rx1148_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_862:
  rx1148_fail:
    (rx1148_rep, rx1148_pos, $I10, $P10) = rx1148_cur."!mark_fail"(0)
    lt rx1148_pos, -1, rx1148_done
    eq rx1148_pos, -1, rx1148_fail
    jump $I10
  rx1148_done:
    rx1148_cur."!cursor_fail"()
    if_null rx1148_debug, debug_863
    rx1148_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_863:
    .return (rx1148_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("246_1299465717.405") :method
.annotate 'line', 4
    $P1150 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1151, "ResizablePMCArray"
    push $P1151, $P1150
    .return ($P1151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("247_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1154_tgt
    .local int rx1154_pos
    .local int rx1154_off
    .local int rx1154_eos
    .local int rx1154_rep
    .local pmc rx1154_cur
    .local pmc rx1154_debug
    (rx1154_cur, rx1154_pos, rx1154_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1154_cur
    .local pmc match
    .lex "$/", match
    length rx1154_eos, rx1154_tgt
    gt rx1154_pos, rx1154_eos, rx1154_done
    set rx1154_off, 0
    lt rx1154_pos, 2, rx1154_start
    sub rx1154_off, rx1154_pos, 1
    substr rx1154_tgt, rx1154_tgt, rx1154_off
  rx1154_start:
    eq $I10, 1, rx1154_restart
    if_null rx1154_debug, debug_864
    rx1154_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1157_done
    goto rxscan1157_scan
  rxscan1157_loop:
    (rx1154_pos) = rx1154_cur."from"()
    inc rx1154_pos
    rx1154_cur."!cursor_from"(rx1154_pos)
    ge rx1154_pos, rx1154_eos, rxscan1157_done
  rxscan1157_scan:
    set_addr $I10, rxscan1157_loop
    rx1154_cur."!mark_push"(0, rx1154_pos, $I10)
  rxscan1157_done:
.annotate 'line', 528
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1154_pos, rx1154_off
    substr $S10, rx1154_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1154_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1154_cur."!cursor_pos"(rx1154_pos)
    $P10 = rx1154_cur."quotemod_check"("s")
    unless $P10, rx1154_fail
  # rx subrule "variable" subtype=capture negate=
    rx1154_cur."!cursor_pos"(rx1154_pos)
    $P10 = rx1154_cur."variable"()
    unless $P10, rx1154_fail
    rx1154_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1154_pos = $P10."pos"()
  # rx pass
    rx1154_cur."!cursor_pass"(rx1154_pos, "quote_escape:sym<$>")
    if_null rx1154_debug, debug_865
    rx1154_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1154_pos)
  debug_865:
    .return (rx1154_cur)
  rx1154_restart:
.annotate 'line', 4
    if_null rx1154_debug, debug_866
    rx1154_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_866:
  rx1154_fail:
    (rx1154_rep, rx1154_pos, $I10, $P10) = rx1154_cur."!mark_fail"(0)
    lt rx1154_pos, -1, rx1154_done
    eq rx1154_pos, -1, rx1154_fail
    jump $I10
  rx1154_done:
    rx1154_cur."!cursor_fail"()
    if_null rx1154_debug, debug_867
    rx1154_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_867:
    .return (rx1154_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("248_1299465717.405") :method
.annotate 'line', 4
    new $P1156, "ResizablePMCArray"
    push $P1156, "$"
    .return ($P1156)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("249_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1159_tgt
    .local int rx1159_pos
    .local int rx1159_off
    .local int rx1159_eos
    .local int rx1159_rep
    .local pmc rx1159_cur
    .local pmc rx1159_debug
    (rx1159_cur, rx1159_pos, rx1159_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1159_cur
    .local pmc match
    .lex "$/", match
    length rx1159_eos, rx1159_tgt
    gt rx1159_pos, rx1159_eos, rx1159_done
    set rx1159_off, 0
    lt rx1159_pos, 2, rx1159_start
    sub rx1159_off, rx1159_pos, 1
    substr rx1159_tgt, rx1159_tgt, rx1159_off
  rx1159_start:
    eq $I10, 1, rx1159_restart
    if_null rx1159_debug, debug_868
    rx1159_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1162_done
    goto rxscan1162_scan
  rxscan1162_loop:
    (rx1159_pos) = rx1159_cur."from"()
    inc rx1159_pos
    rx1159_cur."!cursor_from"(rx1159_pos)
    ge rx1159_pos, rx1159_eos, rxscan1162_done
  rxscan1162_scan:
    set_addr $I10, rxscan1162_loop
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
  rxscan1162_done:
.annotate 'line', 529
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1159_pos, rx1159_off
    substr $S10, rx1159_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1159_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."quotemod_check"("c")
    unless $P10, rx1159_fail
  # rx subrule "block" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."block"()
    unless $P10, rx1159_fail
    rx1159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1159_pos = $P10."pos"()
  # rx pass
    rx1159_cur."!cursor_pass"(rx1159_pos, "quote_escape:sym<{ }>")
    if_null rx1159_debug, debug_869
    rx1159_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1159_pos)
  debug_869:
    .return (rx1159_cur)
  rx1159_restart:
.annotate 'line', 4
    if_null rx1159_debug, debug_870
    rx1159_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_870:
  rx1159_fail:
    (rx1159_rep, rx1159_pos, $I10, $P10) = rx1159_cur."!mark_fail"(0)
    lt rx1159_pos, -1, rx1159_done
    eq rx1159_pos, -1, rx1159_fail
    jump $I10
  rx1159_done:
    rx1159_cur."!cursor_fail"()
    if_null rx1159_debug, debug_871
    rx1159_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_871:
    .return (rx1159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("250_1299465717.405") :method
.annotate 'line', 4
    new $P1161, "ResizablePMCArray"
    push $P1161, "{"
    .return ($P1161)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("251_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1164_tgt
    .local int rx1164_pos
    .local int rx1164_off
    .local int rx1164_eos
    .local int rx1164_rep
    .local pmc rx1164_cur
    .local pmc rx1164_debug
    (rx1164_cur, rx1164_pos, rx1164_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1164_cur
    .local pmc match
    .lex "$/", match
    length rx1164_eos, rx1164_tgt
    gt rx1164_pos, rx1164_eos, rx1164_done
    set rx1164_off, 0
    lt rx1164_pos, 2, rx1164_start
    sub rx1164_off, rx1164_pos, 1
    substr rx1164_tgt, rx1164_tgt, rx1164_off
  rx1164_start:
    eq $I10, 1, rx1164_restart
    if_null rx1164_debug, debug_872
    rx1164_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1167_done
    goto rxscan1167_scan
  rxscan1167_loop:
    (rx1164_pos) = rx1164_cur."from"()
    inc rx1164_pos
    rx1164_cur."!cursor_from"(rx1164_pos)
    ge rx1164_pos, rx1164_eos, rxscan1167_done
  rxscan1167_scan:
    set_addr $I10, rxscan1167_loop
    rx1164_cur."!mark_push"(0, rx1164_pos, $I10)
  rxscan1167_done:
.annotate 'line', 530
  # rx literal  "\\e"
    add $I11, rx1164_pos, 2
    gt $I11, rx1164_eos, rx1164_fail
    sub $I11, rx1164_pos, rx1164_off
    substr $S10, rx1164_tgt, $I11, 2
    ne $S10, "\\e", rx1164_fail
    add rx1164_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1164_cur."!cursor_pos"(rx1164_pos)
    $P10 = rx1164_cur."quotemod_check"("b")
    unless $P10, rx1164_fail
  # rx pass
    rx1164_cur."!cursor_pass"(rx1164_pos, "quote_escape:sym<esc>")
    if_null rx1164_debug, debug_873
    rx1164_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1164_pos)
  debug_873:
    .return (rx1164_cur)
  rx1164_restart:
.annotate 'line', 4
    if_null rx1164_debug, debug_874
    rx1164_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_874:
  rx1164_fail:
    (rx1164_rep, rx1164_pos, $I10, $P10) = rx1164_cur."!mark_fail"(0)
    lt rx1164_pos, -1, rx1164_done
    eq rx1164_pos, -1, rx1164_fail
    jump $I10
  rx1164_done:
    rx1164_cur."!cursor_fail"()
    if_null rx1164_debug, debug_875
    rx1164_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_875:
    .return (rx1164_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("252_1299465717.405") :method
.annotate 'line', 4
    new $P1166, "ResizablePMCArray"
    push $P1166, "\\e"
    .return ($P1166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("253_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1169_tgt
    .local int rx1169_pos
    .local int rx1169_off
    .local int rx1169_eos
    .local int rx1169_rep
    .local pmc rx1169_cur
    .local pmc rx1169_debug
    (rx1169_cur, rx1169_pos, rx1169_tgt, $I10) = self."!cursor_start"()
    rx1169_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1169_cur
    .local pmc match
    .lex "$/", match
    length rx1169_eos, rx1169_tgt
    gt rx1169_pos, rx1169_eos, rx1169_done
    set rx1169_off, 0
    lt rx1169_pos, 2, rx1169_start
    sub rx1169_off, rx1169_pos, 1
    substr rx1169_tgt, rx1169_tgt, rx1169_off
  rx1169_start:
    eq $I10, 1, rx1169_restart
    if_null rx1169_debug, debug_876
    rx1169_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1173_done
    goto rxscan1173_scan
  rxscan1173_loop:
    (rx1169_pos) = rx1169_cur."from"()
    inc rx1169_pos
    rx1169_cur."!cursor_from"(rx1169_pos)
    ge rx1169_pos, rx1169_eos, rxscan1173_done
  rxscan1173_scan:
    set_addr $I10, rxscan1173_loop
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10)
  rxscan1173_done:
.annotate 'line', 532
  # rx literal  "("
    add $I11, rx1169_pos, 1
    gt $I11, rx1169_eos, rx1169_fail
    sub $I11, rx1169_pos, rx1169_off
    ord $I11, rx1169_tgt, $I11
    ne $I11, 40, rx1169_fail
    add rx1169_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."ws"()
    unless $P10, rx1169_fail
    rx1169_pos = $P10."pos"()
  # rx rxquantr1174 ** 0..1
    set_addr $I10, rxquantr1174_done
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10)
  rxquantr1174_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."EXPR"()
    unless $P10, rx1169_fail
    goto rxsubrule1175_pass
  rxsubrule1175_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1169_fail
  rxsubrule1175_pass:
    set_addr $I10, rxsubrule1175_back
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1169_pos = $P10."pos"()
    set_addr $I10, rxquantr1174_done
    (rx1169_rep) = rx1169_cur."!mark_commit"($I10)
  rxquantr1174_done:
  # rx literal  ")"
    add $I11, rx1169_pos, 1
    gt $I11, rx1169_eos, rx1169_fail
    sub $I11, rx1169_pos, rx1169_off
    ord $I11, rx1169_tgt, $I11
    ne $I11, 41, rx1169_fail
    add rx1169_pos, 1
  # rx pass
    rx1169_cur."!cursor_pass"(rx1169_pos, "circumfix:sym<( )>")
    if_null rx1169_debug, debug_877
    rx1169_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1169_pos)
  debug_877:
    .return (rx1169_cur)
  rx1169_restart:
.annotate 'line', 4
    if_null rx1169_debug, debug_878
    rx1169_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_878:
  rx1169_fail:
    (rx1169_rep, rx1169_pos, $I10, $P10) = rx1169_cur."!mark_fail"(0)
    lt rx1169_pos, -1, rx1169_done
    eq rx1169_pos, -1, rx1169_fail
    jump $I10
  rx1169_done:
    rx1169_cur."!cursor_fail"()
    if_null rx1169_debug, debug_879
    rx1169_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_879:
    .return (rx1169_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("254_1299465717.405") :method
.annotate 'line', 4
    $P1171 = self."!PREFIX__!subrule"("ws", "(")
    new $P1172, "ResizablePMCArray"
    push $P1172, $P1171
    .return ($P1172)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("255_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1177_tgt
    .local int rx1177_pos
    .local int rx1177_off
    .local int rx1177_eos
    .local int rx1177_rep
    .local pmc rx1177_cur
    .local pmc rx1177_debug
    (rx1177_cur, rx1177_pos, rx1177_tgt, $I10) = self."!cursor_start"()
    rx1177_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1177_cur
    .local pmc match
    .lex "$/", match
    length rx1177_eos, rx1177_tgt
    gt rx1177_pos, rx1177_eos, rx1177_done
    set rx1177_off, 0
    lt rx1177_pos, 2, rx1177_start
    sub rx1177_off, rx1177_pos, 1
    substr rx1177_tgt, rx1177_tgt, rx1177_off
  rx1177_start:
    eq $I10, 1, rx1177_restart
    if_null rx1177_debug, debug_880
    rx1177_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1181_done
    goto rxscan1181_scan
  rxscan1181_loop:
    (rx1177_pos) = rx1177_cur."from"()
    inc rx1177_pos
    rx1177_cur."!cursor_from"(rx1177_pos)
    ge rx1177_pos, rx1177_eos, rxscan1181_done
  rxscan1181_scan:
    set_addr $I10, rxscan1181_loop
    rx1177_cur."!mark_push"(0, rx1177_pos, $I10)
  rxscan1181_done:
.annotate 'line', 533
  # rx literal  "["
    add $I11, rx1177_pos, 1
    gt $I11, rx1177_eos, rx1177_fail
    sub $I11, rx1177_pos, rx1177_off
    ord $I11, rx1177_tgt, $I11
    ne $I11, 91, rx1177_fail
    add rx1177_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1177_cur."!cursor_pos"(rx1177_pos)
    $P10 = rx1177_cur."ws"()
    unless $P10, rx1177_fail
    rx1177_pos = $P10."pos"()
  # rx rxquantr1182 ** 0..1
    set_addr $I10, rxquantr1182_done
    rx1177_cur."!mark_push"(0, rx1177_pos, $I10)
  rxquantr1182_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1177_cur."!cursor_pos"(rx1177_pos)
    $P10 = rx1177_cur."EXPR"()
    unless $P10, rx1177_fail
    goto rxsubrule1183_pass
  rxsubrule1183_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1177_fail
  rxsubrule1183_pass:
    set_addr $I10, rxsubrule1183_back
    rx1177_cur."!mark_push"(0, rx1177_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1177_pos = $P10."pos"()
    set_addr $I10, rxquantr1182_done
    (rx1177_rep) = rx1177_cur."!mark_commit"($I10)
  rxquantr1182_done:
  # rx literal  "]"
    add $I11, rx1177_pos, 1
    gt $I11, rx1177_eos, rx1177_fail
    sub $I11, rx1177_pos, rx1177_off
    ord $I11, rx1177_tgt, $I11
    ne $I11, 93, rx1177_fail
    add rx1177_pos, 1
  # rx pass
    rx1177_cur."!cursor_pass"(rx1177_pos, "circumfix:sym<[ ]>")
    if_null rx1177_debug, debug_881
    rx1177_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1177_pos)
  debug_881:
    .return (rx1177_cur)
  rx1177_restart:
.annotate 'line', 4
    if_null rx1177_debug, debug_882
    rx1177_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_882:
  rx1177_fail:
    (rx1177_rep, rx1177_pos, $I10, $P10) = rx1177_cur."!mark_fail"(0)
    lt rx1177_pos, -1, rx1177_done
    eq rx1177_pos, -1, rx1177_fail
    jump $I10
  rx1177_done:
    rx1177_cur."!cursor_fail"()
    if_null rx1177_debug, debug_883
    rx1177_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_883:
    .return (rx1177_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("256_1299465717.405") :method
.annotate 'line', 4
    $P1179 = self."!PREFIX__!subrule"("ws", "[")
    new $P1180, "ResizablePMCArray"
    push $P1180, $P1179
    .return ($P1180)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("257_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1185_tgt
    .local int rx1185_pos
    .local int rx1185_off
    .local int rx1185_eos
    .local int rx1185_rep
    .local pmc rx1185_cur
    .local pmc rx1185_debug
    (rx1185_cur, rx1185_pos, rx1185_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1185_cur
    .local pmc match
    .lex "$/", match
    length rx1185_eos, rx1185_tgt
    gt rx1185_pos, rx1185_eos, rx1185_done
    set rx1185_off, 0
    lt rx1185_pos, 2, rx1185_start
    sub rx1185_off, rx1185_pos, 1
    substr rx1185_tgt, rx1185_tgt, rx1185_off
  rx1185_start:
    eq $I10, 1, rx1185_restart
    if_null rx1185_debug, debug_884
    rx1185_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1188_done
    goto rxscan1188_scan
  rxscan1188_loop:
    (rx1185_pos) = rx1185_cur."from"()
    inc rx1185_pos
    rx1185_cur."!cursor_from"(rx1185_pos)
    ge rx1185_pos, rx1185_eos, rxscan1188_done
  rxscan1188_scan:
    set_addr $I10, rxscan1188_loop
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  rxscan1188_done:
.annotate 'line', 534
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1185_pos, rx1185_off
    substr $S10, rx1185_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1185_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1185_pos = $P10."pos"()
  # rx pass
    rx1185_cur."!cursor_pass"(rx1185_pos, "circumfix:sym<ang>")
    if_null rx1185_debug, debug_885
    rx1185_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1185_pos)
  debug_885:
    .return (rx1185_cur)
  rx1185_restart:
.annotate 'line', 4
    if_null rx1185_debug, debug_886
    rx1185_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_886:
  rx1185_fail:
    (rx1185_rep, rx1185_pos, $I10, $P10) = rx1185_cur."!mark_fail"(0)
    lt rx1185_pos, -1, rx1185_done
    eq rx1185_pos, -1, rx1185_fail
    jump $I10
  rx1185_done:
    rx1185_cur."!cursor_fail"()
    if_null rx1185_debug, debug_887
    rx1185_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_887:
    .return (rx1185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("258_1299465717.405") :method
.annotate 'line', 4
    new $P1187, "ResizablePMCArray"
    push $P1187, "<"
    .return ($P1187)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("259_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1190_tgt
    .local int rx1190_pos
    .local int rx1190_off
    .local int rx1190_eos
    .local int rx1190_rep
    .local pmc rx1190_cur
    .local pmc rx1190_debug
    (rx1190_cur, rx1190_pos, rx1190_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1190_cur
    .local pmc match
    .lex "$/", match
    length rx1190_eos, rx1190_tgt
    gt rx1190_pos, rx1190_eos, rx1190_done
    set rx1190_off, 0
    lt rx1190_pos, 2, rx1190_start
    sub rx1190_off, rx1190_pos, 1
    substr rx1190_tgt, rx1190_tgt, rx1190_off
  rx1190_start:
    eq $I10, 1, rx1190_restart
    if_null rx1190_debug, debug_888
    rx1190_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1193_done
    goto rxscan1193_scan
  rxscan1193_loop:
    (rx1190_pos) = rx1190_cur."from"()
    inc rx1190_pos
    rx1190_cur."!cursor_from"(rx1190_pos)
    ge rx1190_pos, rx1190_eos, rxscan1193_done
  rxscan1193_scan:
    set_addr $I10, rxscan1193_loop
    rx1190_cur."!mark_push"(0, rx1190_pos, $I10)
  rxscan1193_done:
.annotate 'line', 535
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1190_pos, rx1190_off
    substr $S10, rx1190_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1190_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1190_cur."!cursor_pos"(rx1190_pos)
    $P10 = rx1190_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1190_fail
    rx1190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1190_pos = $P10."pos"()
  # rx pass
    rx1190_cur."!cursor_pass"(rx1190_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1190_debug, debug_889
    rx1190_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1190_pos)
  debug_889:
    .return (rx1190_cur)
  rx1190_restart:
.annotate 'line', 4
    if_null rx1190_debug, debug_890
    rx1190_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_890:
  rx1190_fail:
    (rx1190_rep, rx1190_pos, $I10, $P10) = rx1190_cur."!mark_fail"(0)
    lt rx1190_pos, -1, rx1190_done
    eq rx1190_pos, -1, rx1190_fail
    jump $I10
  rx1190_done:
    rx1190_cur."!cursor_fail"()
    if_null rx1190_debug, debug_891
    rx1190_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_891:
    .return (rx1190_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("260_1299465717.405") :method
.annotate 'line', 4
    new $P1192, "ResizablePMCArray"
    push $P1192, unicode:"\x{ab}"
    .return ($P1192)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("261_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1195_tgt
    .local int rx1195_pos
    .local int rx1195_off
    .local int rx1195_eos
    .local int rx1195_rep
    .local pmc rx1195_cur
    .local pmc rx1195_debug
    (rx1195_cur, rx1195_pos, rx1195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1195_cur
    .local pmc match
    .lex "$/", match
    length rx1195_eos, rx1195_tgt
    gt rx1195_pos, rx1195_eos, rx1195_done
    set rx1195_off, 0
    lt rx1195_pos, 2, rx1195_start
    sub rx1195_off, rx1195_pos, 1
    substr rx1195_tgt, rx1195_tgt, rx1195_off
  rx1195_start:
    eq $I10, 1, rx1195_restart
    if_null rx1195_debug, debug_892
    rx1195_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1198_done
    goto rxscan1198_scan
  rxscan1198_loop:
    (rx1195_pos) = rx1195_cur."from"()
    inc rx1195_pos
    rx1195_cur."!cursor_from"(rx1195_pos)
    ge rx1195_pos, rx1195_eos, rxscan1198_done
  rxscan1198_scan:
    set_addr $I10, rxscan1198_loop
    rx1195_cur."!mark_push"(0, rx1195_pos, $I10)
  rxscan1198_done:
.annotate 'line', 536
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1195_pos, rx1195_off
    substr $S10, rx1195_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1195_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."pblock"()
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1195_pos = $P10."pos"()
  # rx pass
    rx1195_cur."!cursor_pass"(rx1195_pos, "circumfix:sym<{ }>")
    if_null rx1195_debug, debug_893
    rx1195_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1195_pos)
  debug_893:
    .return (rx1195_cur)
  rx1195_restart:
.annotate 'line', 4
    if_null rx1195_debug, debug_894
    rx1195_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_894:
  rx1195_fail:
    (rx1195_rep, rx1195_pos, $I10, $P10) = rx1195_cur."!mark_fail"(0)
    lt rx1195_pos, -1, rx1195_done
    eq rx1195_pos, -1, rx1195_fail
    jump $I10
  rx1195_done:
    rx1195_cur."!cursor_fail"()
    if_null rx1195_debug, debug_895
    rx1195_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_895:
    .return (rx1195_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("262_1299465717.405") :method
.annotate 'line', 4
    new $P1197, "ResizablePMCArray"
    push $P1197, "{"
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("263_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1200_tgt
    .local int rx1200_pos
    .local int rx1200_off
    .local int rx1200_eos
    .local int rx1200_rep
    .local pmc rx1200_cur
    .local pmc rx1200_debug
    (rx1200_cur, rx1200_pos, rx1200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1200_cur
    .local pmc match
    .lex "$/", match
    length rx1200_eos, rx1200_tgt
    gt rx1200_pos, rx1200_eos, rx1200_done
    set rx1200_off, 0
    lt rx1200_pos, 2, rx1200_start
    sub rx1200_off, rx1200_pos, 1
    substr rx1200_tgt, rx1200_tgt, rx1200_off
  rx1200_start:
    eq $I10, 1, rx1200_restart
    if_null rx1200_debug, debug_896
    rx1200_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1204_done
    goto rxscan1204_scan
  rxscan1204_loop:
    (rx1200_pos) = rx1200_cur."from"()
    inc rx1200_pos
    rx1200_cur."!cursor_from"(rx1200_pos)
    ge rx1200_pos, rx1200_eos, rxscan1204_done
  rxscan1204_scan:
    set_addr $I10, rxscan1204_loop
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10)
  rxscan1204_done:
.annotate 'line', 537
  # rx subrule "sigil" subtype=capture negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."sigil"()
    unless $P10, rx1200_fail
    rx1200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1200_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1200_pos, 1
    gt $I11, rx1200_eos, rx1200_fail
    sub $I11, rx1200_pos, rx1200_off
    ord $I11, rx1200_tgt, $I11
    ne $I11, 40, rx1200_fail
    add rx1200_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."semilist"()
    unless $P10, rx1200_fail
    rx1200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1200_pos = $P10."pos"()
  alt1205_0:
    set_addr $I10, alt1205_1
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10)
  # rx literal  ")"
    add $I11, rx1200_pos, 1
    gt $I11, rx1200_eos, rx1200_fail
    sub $I11, rx1200_pos, rx1200_off
    ord $I11, rx1200_tgt, $I11
    ne $I11, 41, rx1200_fail
    add rx1200_pos, 1
    goto alt1205_end
  alt1205_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."FAILGOAL"("')'")
    unless $P10, rx1200_fail
    goto rxsubrule1207_pass
  rxsubrule1207_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1200_fail
  rxsubrule1207_pass:
    set_addr $I10, rxsubrule1207_back
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10, $P10)
    rx1200_pos = $P10."pos"()
  alt1205_end:
  # rx pass
    rx1200_cur."!cursor_pass"(rx1200_pos, "circumfix:sym<sigil>")
    if_null rx1200_debug, debug_897
    rx1200_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1200_pos)
  debug_897:
    .return (rx1200_cur)
  rx1200_restart:
.annotate 'line', 4
    if_null rx1200_debug, debug_898
    rx1200_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_898:
  rx1200_fail:
    (rx1200_rep, rx1200_pos, $I10, $P10) = rx1200_cur."!mark_fail"(0)
    lt rx1200_pos, -1, rx1200_done
    eq rx1200_pos, -1, rx1200_fail
    jump $I10
  rx1200_done:
    rx1200_cur."!cursor_fail"()
    if_null rx1200_debug, debug_899
    rx1200_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_899:
    .return (rx1200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("264_1299465717.405") :method
.annotate 'line', 4
    $P1202 = self."!PREFIX__!subrule"("sigil", "")
    new $P1203, "ResizablePMCArray"
    push $P1203, $P1202
    .return ($P1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("265_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1209_tgt
    .local int rx1209_pos
    .local int rx1209_off
    .local int rx1209_eos
    .local int rx1209_rep
    .local pmc rx1209_cur
    .local pmc rx1209_debug
    (rx1209_cur, rx1209_pos, rx1209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1209_cur
    .local pmc match
    .lex "$/", match
    length rx1209_eos, rx1209_tgt
    gt rx1209_pos, rx1209_eos, rx1209_done
    set rx1209_off, 0
    lt rx1209_pos, 2, rx1209_start
    sub rx1209_off, rx1209_pos, 1
    substr rx1209_tgt, rx1209_tgt, rx1209_off
  rx1209_start:
    eq $I10, 1, rx1209_restart
    if_null rx1209_debug, debug_900
    rx1209_cur."!cursor_debug"("START", "semilist")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1213_done
    goto rxscan1213_scan
  rxscan1213_loop:
    (rx1209_pos) = rx1209_cur."from"()
    inc rx1209_pos
    rx1209_cur."!cursor_from"(rx1209_pos)
    ge rx1209_pos, rx1209_eos, rxscan1213_done
  rxscan1213_scan:
    set_addr $I10, rxscan1213_loop
    rx1209_cur."!mark_push"(0, rx1209_pos, $I10)
  rxscan1213_done:
.annotate 'line', 539
  # rx subrule "ws" subtype=method negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."ws"()
    unless $P10, rx1209_fail
    rx1209_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."statement"()
    unless $P10, rx1209_fail
    rx1209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1209_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."ws"()
    unless $P10, rx1209_fail
    rx1209_pos = $P10."pos"()
  # rx pass
    rx1209_cur."!cursor_pass"(rx1209_pos, "semilist")
    if_null rx1209_debug, debug_901
    rx1209_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1209_pos)
  debug_901:
    .return (rx1209_cur)
  rx1209_restart:
.annotate 'line', 4
    if_null rx1209_debug, debug_902
    rx1209_cur."!cursor_debug"("NEXT", "semilist")
  debug_902:
  rx1209_fail:
    (rx1209_rep, rx1209_pos, $I10, $P10) = rx1209_cur."!mark_fail"(0)
    lt rx1209_pos, -1, rx1209_done
    eq rx1209_pos, -1, rx1209_fail
    jump $I10
  rx1209_done:
    rx1209_cur."!cursor_fail"()
    if_null rx1209_debug, debug_903
    rx1209_cur."!cursor_debug"("FAIL", "semilist")
  debug_903:
    .return (rx1209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("266_1299465717.405") :method
.annotate 'line', 4
    $P1211 = self."!PREFIX__!subrule"("ws", "")
    new $P1212, "ResizablePMCArray"
    push $P1212, $P1211
    .return ($P1212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1216"  :anon :subid("267_1299465717.405") :outer("11_1299465717.405")
.annotate 'line', 4
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post904") :outer("267_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P1217 = "267_1299465717.405" 
    .local pmc block
    set block, $P1217
.annotate 'line', 544
    get_hll_global $P1218, ["NQP"], "Grammar"
    $P1218."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 545
    get_hll_global $P1219, ["NQP"], "Grammar"
    $P1219."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 546
    get_hll_global $P1220, ["NQP"], "Grammar"
    $P1220."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 547
    get_hll_global $P1221, ["NQP"], "Grammar"
    $P1221."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 548
    get_hll_global $P1222, ["NQP"], "Grammar"
    $P1222."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 549
    get_hll_global $P1223, ["NQP"], "Grammar"
    $P1223."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 550
    get_hll_global $P1224, ["NQP"], "Grammar"
    $P1224."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 551
    get_hll_global $P1225, ["NQP"], "Grammar"
    $P1225."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 552
    get_hll_global $P1226, ["NQP"], "Grammar"
    $P1226."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 553
    get_hll_global $P1227, ["NQP"], "Grammar"
    $P1227."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 554
    get_hll_global $P1228, ["NQP"], "Grammar"
    $P1228."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 555
    get_hll_global $P1229, ["NQP"], "Grammar"
    $P1229."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 556
    get_hll_global $P1230, ["NQP"], "Grammar"
    $P1230."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 557
    get_hll_global $P1231, ["NQP"], "Grammar"
    $P1231."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 558
    get_hll_global $P1232, ["NQP"], "Grammar"
    $P1232."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("268_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1234_tgt
    .local int rx1234_pos
    .local int rx1234_off
    .local int rx1234_eos
    .local int rx1234_rep
    .local pmc rx1234_cur
    .local pmc rx1234_debug
    (rx1234_cur, rx1234_pos, rx1234_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1234_cur
    .local pmc match
    .lex "$/", match
    length rx1234_eos, rx1234_tgt
    gt rx1234_pos, rx1234_eos, rx1234_done
    set rx1234_off, 0
    lt rx1234_pos, 2, rx1234_start
    sub rx1234_off, rx1234_pos, 1
    substr rx1234_tgt, rx1234_tgt, rx1234_off
  rx1234_start:
    eq $I10, 1, rx1234_restart
    if_null rx1234_debug, debug_905
    rx1234_cur."!cursor_debug"("START", "infixish")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1237_done
    goto rxscan1237_scan
  rxscan1237_loop:
    (rx1234_pos) = rx1234_cur."from"()
    inc rx1234_pos
    rx1234_cur."!cursor_from"(rx1234_pos)
    ge rx1234_pos, rx1234_eos, rxscan1237_done
  rxscan1237_scan:
    set_addr $I10, rxscan1237_loop
    rx1234_cur."!mark_push"(0, rx1234_pos, $I10)
  rxscan1237_done:
.annotate 'line', 562
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1234_cur."!cursor_pos"(rx1234_pos)
    $P10 = rx1234_cur."infixstopper"()
    if $P10, rx1234_fail
  # rx subrule "infix" subtype=capture negate=
    rx1234_cur."!cursor_pos"(rx1234_pos)
    $P10 = rx1234_cur."infix"()
    unless $P10, rx1234_fail
    rx1234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1234_pos = $P10."pos"()
  # rx pass
    rx1234_cur."!cursor_pass"(rx1234_pos, "infixish")
    if_null rx1234_debug, debug_906
    rx1234_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1234_pos)
  debug_906:
    .return (rx1234_cur)
  rx1234_restart:
.annotate 'line', 4
    if_null rx1234_debug, debug_907
    rx1234_cur."!cursor_debug"("NEXT", "infixish")
  debug_907:
  rx1234_fail:
    (rx1234_rep, rx1234_pos, $I10, $P10) = rx1234_cur."!mark_fail"(0)
    lt rx1234_pos, -1, rx1234_done
    eq rx1234_pos, -1, rx1234_fail
    jump $I10
  rx1234_done:
    rx1234_cur."!cursor_fail"()
    if_null rx1234_debug, debug_908
    rx1234_cur."!cursor_debug"("FAIL", "infixish")
  debug_908:
    .return (rx1234_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("269_1299465717.405") :method
.annotate 'line', 4
    new $P1236, "ResizablePMCArray"
    push $P1236, ""
    .return ($P1236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("270_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1239_tgt
    .local int rx1239_pos
    .local int rx1239_off
    .local int rx1239_eos
    .local int rx1239_rep
    .local pmc rx1239_cur
    .local pmc rx1239_debug
    (rx1239_cur, rx1239_pos, rx1239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1239_cur
    .local pmc match
    .lex "$/", match
    length rx1239_eos, rx1239_tgt
    gt rx1239_pos, rx1239_eos, rx1239_done
    set rx1239_off, 0
    lt rx1239_pos, 2, rx1239_start
    sub rx1239_off, rx1239_pos, 1
    substr rx1239_tgt, rx1239_tgt, rx1239_off
  rx1239_start:
    eq $I10, 1, rx1239_restart
    if_null rx1239_debug, debug_909
    rx1239_cur."!cursor_debug"("START", "infixstopper")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1242_done
    goto rxscan1242_scan
  rxscan1242_loop:
    (rx1239_pos) = rx1239_cur."from"()
    inc rx1239_pos
    rx1239_cur."!cursor_from"(rx1239_pos)
    ge rx1239_pos, rx1239_eos, rxscan1242_done
  rxscan1242_scan:
    set_addr $I10, rxscan1242_loop
    rx1239_cur."!mark_push"(0, rx1239_pos, $I10)
  rxscan1242_done:
.annotate 'line', 563
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1239_cur."!cursor_pos"(rx1239_pos)
    $P10 = rx1239_cur."lambda"()
    unless $P10, rx1239_fail
  # rx pass
    rx1239_cur."!cursor_pass"(rx1239_pos, "infixstopper")
    if_null rx1239_debug, debug_910
    rx1239_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1239_pos)
  debug_910:
    .return (rx1239_cur)
  rx1239_restart:
.annotate 'line', 4
    if_null rx1239_debug, debug_911
    rx1239_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_911:
  rx1239_fail:
    (rx1239_rep, rx1239_pos, $I10, $P10) = rx1239_cur."!mark_fail"(0)
    lt rx1239_pos, -1, rx1239_done
    eq rx1239_pos, -1, rx1239_fail
    jump $I10
  rx1239_done:
    rx1239_cur."!cursor_fail"()
    if_null rx1239_debug, debug_912
    rx1239_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_912:
    .return (rx1239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("271_1299465717.405") :method
.annotate 'line', 4
    new $P1241, "ResizablePMCArray"
    push $P1241, ""
    .return ($P1241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("272_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_913
    rx1244_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 566
  # rx literal  "["
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 91, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."ws"()
    unless $P10, rx1244_fail
    rx1244_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."EXPR"()
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1244_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 93, rx1244_fail
    add rx1244_pos, 1
.annotate 'line', 567
  # rx subrule "O" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."O"("%methodop")
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1244_pos = $P10."pos"()
.annotate 'line', 565
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "postcircumfix:sym<[ ]>")
    if_null rx1244_debug, debug_914
    rx1244_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1244_pos)
  debug_914:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 4
    if_null rx1244_debug, debug_915
    rx1244_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_915:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_916
    rx1244_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_916:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("273_1299465717.405") :method
.annotate 'line', 4
    $P1246 = self."!PREFIX__!subrule"("ws", "[")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("274_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1250_tgt
    .local int rx1250_pos
    .local int rx1250_off
    .local int rx1250_eos
    .local int rx1250_rep
    .local pmc rx1250_cur
    .local pmc rx1250_debug
    (rx1250_cur, rx1250_pos, rx1250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1250_cur
    .local pmc match
    .lex "$/", match
    length rx1250_eos, rx1250_tgt
    gt rx1250_pos, rx1250_eos, rx1250_done
    set rx1250_off, 0
    lt rx1250_pos, 2, rx1250_start
    sub rx1250_off, rx1250_pos, 1
    substr rx1250_tgt, rx1250_tgt, rx1250_off
  rx1250_start:
    eq $I10, 1, rx1250_restart
    if_null rx1250_debug, debug_917
    rx1250_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1254_done
    goto rxscan1254_scan
  rxscan1254_loop:
    (rx1250_pos) = rx1250_cur."from"()
    inc rx1250_pos
    rx1250_cur."!cursor_from"(rx1250_pos)
    ge rx1250_pos, rx1250_eos, rxscan1254_done
  rxscan1254_scan:
    set_addr $I10, rxscan1254_loop
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
  rxscan1254_done:
.annotate 'line', 571
  # rx literal  "{"
    add $I11, rx1250_pos, 1
    gt $I11, rx1250_eos, rx1250_fail
    sub $I11, rx1250_pos, rx1250_off
    ord $I11, rx1250_tgt, $I11
    ne $I11, 123, rx1250_fail
    add rx1250_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."ws"()
    unless $P10, rx1250_fail
    rx1250_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."EXPR"()
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1250_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1250_pos, 1
    gt $I11, rx1250_eos, rx1250_fail
    sub $I11, rx1250_pos, rx1250_off
    ord $I11, rx1250_tgt, $I11
    ne $I11, 125, rx1250_fail
    add rx1250_pos, 1
.annotate 'line', 572
  # rx subrule "O" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."O"("%methodop")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1250_pos = $P10."pos"()
.annotate 'line', 570
  # rx pass
    rx1250_cur."!cursor_pass"(rx1250_pos, "postcircumfix:sym<{ }>")
    if_null rx1250_debug, debug_918
    rx1250_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1250_pos)
  debug_918:
    .return (rx1250_cur)
  rx1250_restart:
.annotate 'line', 4
    if_null rx1250_debug, debug_919
    rx1250_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_919:
  rx1250_fail:
    (rx1250_rep, rx1250_pos, $I10, $P10) = rx1250_cur."!mark_fail"(0)
    lt rx1250_pos, -1, rx1250_done
    eq rx1250_pos, -1, rx1250_fail
    jump $I10
  rx1250_done:
    rx1250_cur."!cursor_fail"()
    if_null rx1250_debug, debug_920
    rx1250_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_920:
    .return (rx1250_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("275_1299465717.405") :method
.annotate 'line', 4
    $P1252 = self."!PREFIX__!subrule"("ws", "{")
    new $P1253, "ResizablePMCArray"
    push $P1253, $P1252
    .return ($P1253)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("276_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1256_tgt
    .local int rx1256_pos
    .local int rx1256_off
    .local int rx1256_eos
    .local int rx1256_rep
    .local pmc rx1256_cur
    .local pmc rx1256_debug
    (rx1256_cur, rx1256_pos, rx1256_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1256_cur
    .local pmc match
    .lex "$/", match
    length rx1256_eos, rx1256_tgt
    gt rx1256_pos, rx1256_eos, rx1256_done
    set rx1256_off, 0
    lt rx1256_pos, 2, rx1256_start
    sub rx1256_off, rx1256_pos, 1
    substr rx1256_tgt, rx1256_tgt, rx1256_off
  rx1256_start:
    eq $I10, 1, rx1256_restart
    if_null rx1256_debug, debug_921
    rx1256_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1256_pos) = rx1256_cur."from"()
    inc rx1256_pos
    rx1256_cur."!cursor_from"(rx1256_pos)
    ge rx1256_pos, rx1256_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxscan1259_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1256_pos, rx1256_off
    substr $S10, rx1256_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1256_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."quote_EXPR"(":q")
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1256_pos = $P10."pos"()
.annotate 'line', 577
  # rx subrule "O" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."O"("%methodop")
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1256_pos = $P10."pos"()
.annotate 'line', 575
  # rx pass
    rx1256_cur."!cursor_pass"(rx1256_pos, "postcircumfix:sym<ang>")
    if_null rx1256_debug, debug_922
    rx1256_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1256_pos)
  debug_922:
    .return (rx1256_cur)
  rx1256_restart:
.annotate 'line', 4
    if_null rx1256_debug, debug_923
    rx1256_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_923:
  rx1256_fail:
    (rx1256_rep, rx1256_pos, $I10, $P10) = rx1256_cur."!mark_fail"(0)
    lt rx1256_pos, -1, rx1256_done
    eq rx1256_pos, -1, rx1256_fail
    jump $I10
  rx1256_done:
    rx1256_cur."!cursor_fail"()
    if_null rx1256_debug, debug_924
    rx1256_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_924:
    .return (rx1256_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("277_1299465717.405") :method
.annotate 'line', 4
    new $P1258, "ResizablePMCArray"
    push $P1258, "<"
    .return ($P1258)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("278_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1261_tgt
    .local int rx1261_pos
    .local int rx1261_off
    .local int rx1261_eos
    .local int rx1261_rep
    .local pmc rx1261_cur
    .local pmc rx1261_debug
    (rx1261_cur, rx1261_pos, rx1261_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1261_cur
    .local pmc match
    .lex "$/", match
    length rx1261_eos, rx1261_tgt
    gt rx1261_pos, rx1261_eos, rx1261_done
    set rx1261_off, 0
    lt rx1261_pos, 2, rx1261_start
    sub rx1261_off, rx1261_pos, 1
    substr rx1261_tgt, rx1261_tgt, rx1261_off
  rx1261_start:
    eq $I10, 1, rx1261_restart
    if_null rx1261_debug, debug_925
    rx1261_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1265_done
    goto rxscan1265_scan
  rxscan1265_loop:
    (rx1261_pos) = rx1261_cur."from"()
    inc rx1261_pos
    rx1261_cur."!cursor_from"(rx1261_pos)
    ge rx1261_pos, rx1261_eos, rxscan1265_done
  rxscan1265_scan:
    set_addr $I10, rxscan1265_loop
    rx1261_cur."!mark_push"(0, rx1261_pos, $I10)
  rxscan1265_done:
.annotate 'line', 581
  # rx literal  "("
    add $I11, rx1261_pos, 1
    gt $I11, rx1261_eos, rx1261_fail
    sub $I11, rx1261_pos, rx1261_off
    ord $I11, rx1261_tgt, $I11
    ne $I11, 40, rx1261_fail
    add rx1261_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."ws"()
    unless $P10, rx1261_fail
    rx1261_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."arglist"()
    unless $P10, rx1261_fail
    rx1261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1261_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1261_pos, 1
    gt $I11, rx1261_eos, rx1261_fail
    sub $I11, rx1261_pos, rx1261_off
    ord $I11, rx1261_tgt, $I11
    ne $I11, 41, rx1261_fail
    add rx1261_pos, 1
.annotate 'line', 582
  # rx subrule "O" subtype=capture negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."O"("%methodop")
    unless $P10, rx1261_fail
    rx1261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1261_pos = $P10."pos"()
.annotate 'line', 580
  # rx pass
    rx1261_cur."!cursor_pass"(rx1261_pos, "postcircumfix:sym<( )>")
    if_null rx1261_debug, debug_926
    rx1261_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1261_pos)
  debug_926:
    .return (rx1261_cur)
  rx1261_restart:
.annotate 'line', 4
    if_null rx1261_debug, debug_927
    rx1261_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_927:
  rx1261_fail:
    (rx1261_rep, rx1261_pos, $I10, $P10) = rx1261_cur."!mark_fail"(0)
    lt rx1261_pos, -1, rx1261_done
    eq rx1261_pos, -1, rx1261_fail
    jump $I10
  rx1261_done:
    rx1261_cur."!cursor_fail"()
    if_null rx1261_debug, debug_928
    rx1261_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_928:
    .return (rx1261_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("279_1299465717.405") :method
.annotate 'line', 4
    $P1263 = self."!PREFIX__!subrule"("ws", "(")
    new $P1264, "ResizablePMCArray"
    push $P1264, $P1263
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("280_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_929
    rx1267_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1271_done
    goto rxscan1271_scan
  rxscan1271_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1271_done
  rxscan1271_scan:
    set_addr $I10, rxscan1271_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1271_done:
.annotate 'line', 585
  # rx subrule "dotty" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."dotty"()
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1267_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."O"("%methodop")
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1267_pos = $P10."pos"()
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "postfix:sym<.>")
    if_null rx1267_debug, debug_930
    rx1267_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1267_pos)
  debug_930:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 4
    if_null rx1267_debug, debug_931
    rx1267_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_931:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_932
    rx1267_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_932:
    .return (rx1267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("281_1299465717.405") :method
.annotate 'line', 4
    $P1269 = self."!PREFIX__!subrule"("dotty", "")
    new $P1270, "ResizablePMCArray"
    push $P1270, $P1269
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("282_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1273_tgt
    .local int rx1273_pos
    .local int rx1273_off
    .local int rx1273_eos
    .local int rx1273_rep
    .local pmc rx1273_cur
    .local pmc rx1273_debug
    (rx1273_cur, rx1273_pos, rx1273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1273_cur
    .local pmc match
    .lex "$/", match
    length rx1273_eos, rx1273_tgt
    gt rx1273_pos, rx1273_eos, rx1273_done
    set rx1273_off, 0
    lt rx1273_pos, 2, rx1273_start
    sub rx1273_off, rx1273_pos, 1
    substr rx1273_tgt, rx1273_tgt, rx1273_off
  rx1273_start:
    eq $I10, 1, rx1273_restart
    if_null rx1273_debug, debug_933
    rx1273_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1277_done
    goto rxscan1277_scan
  rxscan1277_loop:
    (rx1273_pos) = rx1273_cur."from"()
    inc rx1273_pos
    rx1273_cur."!cursor_from"(rx1273_pos)
    ge rx1273_pos, rx1273_eos, rxscan1277_done
  rxscan1277_scan:
    set_addr $I10, rxscan1277_loop
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  rxscan1277_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1278_fail
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  # rx literal  "++"
    add $I11, rx1273_pos, 2
    gt $I11, rx1273_eos, rx1273_fail
    sub $I11, rx1273_pos, rx1273_off
    substr $S10, rx1273_tgt, $I11, 2
    ne $S10, "++", rx1273_fail
    add rx1273_pos, 2
    set_addr $I10, rxcap_1278_fail
    ($I12, $I11) = rx1273_cur."!mark_peek"($I10)
    rx1273_cur."!cursor_pos"($I11)
    ($P10) = rx1273_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1273_pos, "")
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1278_done
  rxcap_1278_fail:
    goto rx1273_fail
  rxcap_1278_done:
  # rx subrule "O" subtype=capture negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1273_fail
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1273_pos = $P10."pos"()
  # rx pass
    rx1273_cur."!cursor_pass"(rx1273_pos, "prefix:sym<++>")
    if_null rx1273_debug, debug_934
    rx1273_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1273_pos)
  debug_934:
    .return (rx1273_cur)
  rx1273_restart:
.annotate 'line', 4
    if_null rx1273_debug, debug_935
    rx1273_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_935:
  rx1273_fail:
    (rx1273_rep, rx1273_pos, $I10, $P10) = rx1273_cur."!mark_fail"(0)
    lt rx1273_pos, -1, rx1273_done
    eq rx1273_pos, -1, rx1273_fail
    jump $I10
  rx1273_done:
    rx1273_cur."!cursor_fail"()
    if_null rx1273_debug, debug_936
    rx1273_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_936:
    .return (rx1273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("283_1299465717.405") :method
.annotate 'line', 4
    $P1275 = self."!PREFIX__!subrule"("O", "++")
    new $P1276, "ResizablePMCArray"
    push $P1276, $P1275
    .return ($P1276)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("284_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1280_tgt
    .local int rx1280_pos
    .local int rx1280_off
    .local int rx1280_eos
    .local int rx1280_rep
    .local pmc rx1280_cur
    .local pmc rx1280_debug
    (rx1280_cur, rx1280_pos, rx1280_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1280_cur
    .local pmc match
    .lex "$/", match
    length rx1280_eos, rx1280_tgt
    gt rx1280_pos, rx1280_eos, rx1280_done
    set rx1280_off, 0
    lt rx1280_pos, 2, rx1280_start
    sub rx1280_off, rx1280_pos, 1
    substr rx1280_tgt, rx1280_tgt, rx1280_off
  rx1280_start:
    eq $I10, 1, rx1280_restart
    if_null rx1280_debug, debug_937
    rx1280_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1284_done
    goto rxscan1284_scan
  rxscan1284_loop:
    (rx1280_pos) = rx1280_cur."from"()
    inc rx1280_pos
    rx1280_cur."!cursor_from"(rx1280_pos)
    ge rx1280_pos, rx1280_eos, rxscan1284_done
  rxscan1284_scan:
    set_addr $I10, rxscan1284_loop
    rx1280_cur."!mark_push"(0, rx1280_pos, $I10)
  rxscan1284_done:
.annotate 'line', 588
  # rx subcapture "sym"
    set_addr $I10, rxcap_1285_fail
    rx1280_cur."!mark_push"(0, rx1280_pos, $I10)
  # rx literal  "--"
    add $I11, rx1280_pos, 2
    gt $I11, rx1280_eos, rx1280_fail
    sub $I11, rx1280_pos, rx1280_off
    substr $S10, rx1280_tgt, $I11, 2
    ne $S10, "--", rx1280_fail
    add rx1280_pos, 2
    set_addr $I10, rxcap_1285_fail
    ($I12, $I11) = rx1280_cur."!mark_peek"($I10)
    rx1280_cur."!cursor_pos"($I11)
    ($P10) = rx1280_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1280_pos, "")
    rx1280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1285_done
  rxcap_1285_fail:
    goto rx1280_fail
  rxcap_1285_done:
  # rx subrule "O" subtype=capture negate=
    rx1280_cur."!cursor_pos"(rx1280_pos)
    $P10 = rx1280_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1280_fail
    rx1280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1280_pos = $P10."pos"()
  # rx pass
    rx1280_cur."!cursor_pass"(rx1280_pos, "prefix:sym<-->")
    if_null rx1280_debug, debug_938
    rx1280_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1280_pos)
  debug_938:
    .return (rx1280_cur)
  rx1280_restart:
.annotate 'line', 4
    if_null rx1280_debug, debug_939
    rx1280_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_939:
  rx1280_fail:
    (rx1280_rep, rx1280_pos, $I10, $P10) = rx1280_cur."!mark_fail"(0)
    lt rx1280_pos, -1, rx1280_done
    eq rx1280_pos, -1, rx1280_fail
    jump $I10
  rx1280_done:
    rx1280_cur."!cursor_fail"()
    if_null rx1280_debug, debug_940
    rx1280_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_940:
    .return (rx1280_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("285_1299465717.405") :method
.annotate 'line', 4
    $P1282 = self."!PREFIX__!subrule"("O", "--")
    new $P1283, "ResizablePMCArray"
    push $P1283, $P1282
    .return ($P1283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("286_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1287_tgt
    .local int rx1287_pos
    .local int rx1287_off
    .local int rx1287_eos
    .local int rx1287_rep
    .local pmc rx1287_cur
    .local pmc rx1287_debug
    (rx1287_cur, rx1287_pos, rx1287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1287_cur
    .local pmc match
    .lex "$/", match
    length rx1287_eos, rx1287_tgt
    gt rx1287_pos, rx1287_eos, rx1287_done
    set rx1287_off, 0
    lt rx1287_pos, 2, rx1287_start
    sub rx1287_off, rx1287_pos, 1
    substr rx1287_tgt, rx1287_tgt, rx1287_off
  rx1287_start:
    eq $I10, 1, rx1287_restart
    if_null rx1287_debug, debug_941
    rx1287_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1291_done
    goto rxscan1291_scan
  rxscan1291_loop:
    (rx1287_pos) = rx1287_cur."from"()
    inc rx1287_pos
    rx1287_cur."!cursor_from"(rx1287_pos)
    ge rx1287_pos, rx1287_eos, rxscan1291_done
  rxscan1291_scan:
    set_addr $I10, rxscan1291_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxscan1291_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1292_fail
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rx literal  "++"
    add $I11, rx1287_pos, 2
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 2
    ne $S10, "++", rx1287_fail
    add rx1287_pos, 2
    set_addr $I10, rxcap_1292_fail
    ($I12, $I11) = rx1287_cur."!mark_peek"($I10)
    rx1287_cur."!cursor_pos"($I11)
    ($P10) = rx1287_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1287_pos, "")
    rx1287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1292_done
  rxcap_1292_fail:
    goto rx1287_fail
  rxcap_1292_done:
  # rx subrule "O" subtype=capture negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."O"("%autoincrement")
    unless $P10, rx1287_fail
    rx1287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1287_pos = $P10."pos"()
  # rx pass
    rx1287_cur."!cursor_pass"(rx1287_pos, "postfix:sym<++>")
    if_null rx1287_debug, debug_942
    rx1287_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1287_pos)
  debug_942:
    .return (rx1287_cur)
  rx1287_restart:
.annotate 'line', 4
    if_null rx1287_debug, debug_943
    rx1287_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_943:
  rx1287_fail:
    (rx1287_rep, rx1287_pos, $I10, $P10) = rx1287_cur."!mark_fail"(0)
    lt rx1287_pos, -1, rx1287_done
    eq rx1287_pos, -1, rx1287_fail
    jump $I10
  rx1287_done:
    rx1287_cur."!cursor_fail"()
    if_null rx1287_debug, debug_944
    rx1287_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_944:
    .return (rx1287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("287_1299465717.405") :method
.annotate 'line', 4
    $P1289 = self."!PREFIX__!subrule"("O", "++")
    new $P1290, "ResizablePMCArray"
    push $P1290, $P1289
    .return ($P1290)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("288_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1294_tgt
    .local int rx1294_pos
    .local int rx1294_off
    .local int rx1294_eos
    .local int rx1294_rep
    .local pmc rx1294_cur
    .local pmc rx1294_debug
    (rx1294_cur, rx1294_pos, rx1294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1294_cur
    .local pmc match
    .lex "$/", match
    length rx1294_eos, rx1294_tgt
    gt rx1294_pos, rx1294_eos, rx1294_done
    set rx1294_off, 0
    lt rx1294_pos, 2, rx1294_start
    sub rx1294_off, rx1294_pos, 1
    substr rx1294_tgt, rx1294_tgt, rx1294_off
  rx1294_start:
    eq $I10, 1, rx1294_restart
    if_null rx1294_debug, debug_945
    rx1294_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1298_done
    goto rxscan1298_scan
  rxscan1298_loop:
    (rx1294_pos) = rx1294_cur."from"()
    inc rx1294_pos
    rx1294_cur."!cursor_from"(rx1294_pos)
    ge rx1294_pos, rx1294_eos, rxscan1298_done
  rxscan1298_scan:
    set_addr $I10, rxscan1298_loop
    rx1294_cur."!mark_push"(0, rx1294_pos, $I10)
  rxscan1298_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1299_fail
    rx1294_cur."!mark_push"(0, rx1294_pos, $I10)
  # rx literal  "--"
    add $I11, rx1294_pos, 2
    gt $I11, rx1294_eos, rx1294_fail
    sub $I11, rx1294_pos, rx1294_off
    substr $S10, rx1294_tgt, $I11, 2
    ne $S10, "--", rx1294_fail
    add rx1294_pos, 2
    set_addr $I10, rxcap_1299_fail
    ($I12, $I11) = rx1294_cur."!mark_peek"($I10)
    rx1294_cur."!cursor_pos"($I11)
    ($P10) = rx1294_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1294_pos, "")
    rx1294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1299_done
  rxcap_1299_fail:
    goto rx1294_fail
  rxcap_1299_done:
  # rx subrule "O" subtype=capture negate=
    rx1294_cur."!cursor_pos"(rx1294_pos)
    $P10 = rx1294_cur."O"("%autoincrement")
    unless $P10, rx1294_fail
    rx1294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1294_pos = $P10."pos"()
  # rx pass
    rx1294_cur."!cursor_pass"(rx1294_pos, "postfix:sym<-->")
    if_null rx1294_debug, debug_946
    rx1294_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1294_pos)
  debug_946:
    .return (rx1294_cur)
  rx1294_restart:
.annotate 'line', 4
    if_null rx1294_debug, debug_947
    rx1294_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_947:
  rx1294_fail:
    (rx1294_rep, rx1294_pos, $I10, $P10) = rx1294_cur."!mark_fail"(0)
    lt rx1294_pos, -1, rx1294_done
    eq rx1294_pos, -1, rx1294_fail
    jump $I10
  rx1294_done:
    rx1294_cur."!cursor_fail"()
    if_null rx1294_debug, debug_948
    rx1294_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_948:
    .return (rx1294_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("289_1299465717.405") :method
.annotate 'line', 4
    $P1296 = self."!PREFIX__!subrule"("O", "--")
    new $P1297, "ResizablePMCArray"
    push $P1297, $P1296
    .return ($P1297)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("290_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_949
    rx1301_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1305_done
    goto rxscan1305_scan
  rxscan1305_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1305_done
  rxscan1305_scan:
    set_addr $I10, rxscan1305_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1305_done:
.annotate 'line', 594
  # rx subcapture "sym"
    set_addr $I10, rxcap_1306_fail
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  # rx literal  "**"
    add $I11, rx1301_pos, 2
    gt $I11, rx1301_eos, rx1301_fail
    sub $I11, rx1301_pos, rx1301_off
    substr $S10, rx1301_tgt, $I11, 2
    ne $S10, "**", rx1301_fail
    add rx1301_pos, 2
    set_addr $I10, rxcap_1306_fail
    ($I12, $I11) = rx1301_cur."!mark_peek"($I10)
    rx1301_cur."!cursor_pos"($I11)
    ($P10) = rx1301_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1301_pos, "")
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1306_done
  rxcap_1306_fail:
    goto rx1301_fail
  rxcap_1306_done:
  # rx subrule "O" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1301_pos = $P10."pos"()
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "infix:sym<**>")
    if_null rx1301_debug, debug_950
    rx1301_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1301_pos)
  debug_950:
    .return (rx1301_cur)
  rx1301_restart:
.annotate 'line', 4
    if_null rx1301_debug, debug_951
    rx1301_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_951:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_952
    rx1301_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_952:
    .return (rx1301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("291_1299465717.405") :method
.annotate 'line', 4
    $P1303 = self."!PREFIX__!subrule"("O", "**")
    new $P1304, "ResizablePMCArray"
    push $P1304, $P1303
    .return ($P1304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("292_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1308_tgt
    .local int rx1308_pos
    .local int rx1308_off
    .local int rx1308_eos
    .local int rx1308_rep
    .local pmc rx1308_cur
    .local pmc rx1308_debug
    (rx1308_cur, rx1308_pos, rx1308_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1308_cur
    .local pmc match
    .lex "$/", match
    length rx1308_eos, rx1308_tgt
    gt rx1308_pos, rx1308_eos, rx1308_done
    set rx1308_off, 0
    lt rx1308_pos, 2, rx1308_start
    sub rx1308_off, rx1308_pos, 1
    substr rx1308_tgt, rx1308_tgt, rx1308_off
  rx1308_start:
    eq $I10, 1, rx1308_restart
    if_null rx1308_debug, debug_953
    rx1308_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1312_done
    goto rxscan1312_scan
  rxscan1312_loop:
    (rx1308_pos) = rx1308_cur."from"()
    inc rx1308_pos
    rx1308_cur."!cursor_from"(rx1308_pos)
    ge rx1308_pos, rx1308_eos, rxscan1312_done
  rxscan1312_scan:
    set_addr $I10, rxscan1312_loop
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  rxscan1312_done:
.annotate 'line', 596
  # rx subcapture "sym"
    set_addr $I10, rxcap_1313_fail
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "+"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 43, rx1308_fail
    add rx1308_pos, 1
    set_addr $I10, rxcap_1313_fail
    ($I12, $I11) = rx1308_cur."!mark_peek"($I10)
    rx1308_cur."!cursor_pos"($I11)
    ($P10) = rx1308_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1308_pos, "")
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1313_done
  rxcap_1313_fail:
    goto rx1308_fail
  rxcap_1313_done:
  # rx subrule "O" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1308_pos = $P10."pos"()
  # rx pass
    rx1308_cur."!cursor_pass"(rx1308_pos, "prefix:sym<+>")
    if_null rx1308_debug, debug_954
    rx1308_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1308_pos)
  debug_954:
    .return (rx1308_cur)
  rx1308_restart:
.annotate 'line', 4
    if_null rx1308_debug, debug_955
    rx1308_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_955:
  rx1308_fail:
    (rx1308_rep, rx1308_pos, $I10, $P10) = rx1308_cur."!mark_fail"(0)
    lt rx1308_pos, -1, rx1308_done
    eq rx1308_pos, -1, rx1308_fail
    jump $I10
  rx1308_done:
    rx1308_cur."!cursor_fail"()
    if_null rx1308_debug, debug_956
    rx1308_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_956:
    .return (rx1308_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("293_1299465717.405") :method
.annotate 'line', 4
    $P1310 = self."!PREFIX__!subrule"("O", "+")
    new $P1311, "ResizablePMCArray"
    push $P1311, $P1310
    .return ($P1311)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("294_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1315_tgt
    .local int rx1315_pos
    .local int rx1315_off
    .local int rx1315_eos
    .local int rx1315_rep
    .local pmc rx1315_cur
    .local pmc rx1315_debug
    (rx1315_cur, rx1315_pos, rx1315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1315_cur
    .local pmc match
    .lex "$/", match
    length rx1315_eos, rx1315_tgt
    gt rx1315_pos, rx1315_eos, rx1315_done
    set rx1315_off, 0
    lt rx1315_pos, 2, rx1315_start
    sub rx1315_off, rx1315_pos, 1
    substr rx1315_tgt, rx1315_tgt, rx1315_off
  rx1315_start:
    eq $I10, 1, rx1315_restart
    if_null rx1315_debug, debug_957
    rx1315_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1319_done
    goto rxscan1319_scan
  rxscan1319_loop:
    (rx1315_pos) = rx1315_cur."from"()
    inc rx1315_pos
    rx1315_cur."!cursor_from"(rx1315_pos)
    ge rx1315_pos, rx1315_eos, rxscan1319_done
  rxscan1319_scan:
    set_addr $I10, rxscan1319_loop
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  rxscan1319_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1320_fail
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  # rx literal  "~"
    add $I11, rx1315_pos, 1
    gt $I11, rx1315_eos, rx1315_fail
    sub $I11, rx1315_pos, rx1315_off
    ord $I11, rx1315_tgt, $I11
    ne $I11, 126, rx1315_fail
    add rx1315_pos, 1
    set_addr $I10, rxcap_1320_fail
    ($I12, $I11) = rx1315_cur."!mark_peek"($I10)
    rx1315_cur."!cursor_pos"($I11)
    ($P10) = rx1315_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1315_pos, "")
    rx1315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1320_done
  rxcap_1320_fail:
    goto rx1315_fail
  rxcap_1320_done:
  # rx subrule "O" subtype=capture negate=
    rx1315_cur."!cursor_pos"(rx1315_pos)
    $P10 = rx1315_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1315_fail
    rx1315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1315_pos = $P10."pos"()
  # rx pass
    rx1315_cur."!cursor_pass"(rx1315_pos, "prefix:sym<~>")
    if_null rx1315_debug, debug_958
    rx1315_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1315_pos)
  debug_958:
    .return (rx1315_cur)
  rx1315_restart:
.annotate 'line', 4
    if_null rx1315_debug, debug_959
    rx1315_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_959:
  rx1315_fail:
    (rx1315_rep, rx1315_pos, $I10, $P10) = rx1315_cur."!mark_fail"(0)
    lt rx1315_pos, -1, rx1315_done
    eq rx1315_pos, -1, rx1315_fail
    jump $I10
  rx1315_done:
    rx1315_cur."!cursor_fail"()
    if_null rx1315_debug, debug_960
    rx1315_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_960:
    .return (rx1315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("295_1299465717.405") :method
.annotate 'line', 4
    $P1317 = self."!PREFIX__!subrule"("O", "~")
    new $P1318, "ResizablePMCArray"
    push $P1318, $P1317
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("296_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1322_tgt
    .local int rx1322_pos
    .local int rx1322_off
    .local int rx1322_eos
    .local int rx1322_rep
    .local pmc rx1322_cur
    .local pmc rx1322_debug
    (rx1322_cur, rx1322_pos, rx1322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1322_cur
    .local pmc match
    .lex "$/", match
    length rx1322_eos, rx1322_tgt
    gt rx1322_pos, rx1322_eos, rx1322_done
    set rx1322_off, 0
    lt rx1322_pos, 2, rx1322_start
    sub rx1322_off, rx1322_pos, 1
    substr rx1322_tgt, rx1322_tgt, rx1322_off
  rx1322_start:
    eq $I10, 1, rx1322_restart
    if_null rx1322_debug, debug_961
    rx1322_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1325_done
    goto rxscan1325_scan
  rxscan1325_loop:
    (rx1322_pos) = rx1322_cur."from"()
    inc rx1322_pos
    rx1322_cur."!cursor_from"(rx1322_pos)
    ge rx1322_pos, rx1322_eos, rxscan1325_done
  rxscan1325_scan:
    set_addr $I10, rxscan1325_loop
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  rxscan1325_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1326_fail
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  # rx literal  "-"
    add $I11, rx1322_pos, 1
    gt $I11, rx1322_eos, rx1322_fail
    sub $I11, rx1322_pos, rx1322_off
    ord $I11, rx1322_tgt, $I11
    ne $I11, 45, rx1322_fail
    add rx1322_pos, 1
    set_addr $I10, rxcap_1326_fail
    ($I12, $I11) = rx1322_cur."!mark_peek"($I10)
    rx1322_cur."!cursor_pos"($I11)
    ($P10) = rx1322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1322_pos, "")
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1326_done
  rxcap_1326_fail:
    goto rx1322_fail
  rxcap_1326_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1322_pos, rx1322_off
    substr $S10, rx1322_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1322_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1322_cur."!cursor_pos"(rx1322_pos)
    $P10 = rx1322_cur."number"()
    if $P10, rx1322_fail
  # rx subrule "O" subtype=capture negate=
    rx1322_cur."!cursor_pos"(rx1322_pos)
    $P10 = rx1322_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1322_fail
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1322_pos = $P10."pos"()
  # rx pass
    rx1322_cur."!cursor_pass"(rx1322_pos, "prefix:sym<->")
    if_null rx1322_debug, debug_962
    rx1322_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1322_pos)
  debug_962:
    .return (rx1322_cur)
  rx1322_restart:
.annotate 'line', 4
    if_null rx1322_debug, debug_963
    rx1322_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_963:
  rx1322_fail:
    (rx1322_rep, rx1322_pos, $I10, $P10) = rx1322_cur."!mark_fail"(0)
    lt rx1322_pos, -1, rx1322_done
    eq rx1322_pos, -1, rx1322_fail
    jump $I10
  rx1322_done:
    rx1322_cur."!cursor_fail"()
    if_null rx1322_debug, debug_964
    rx1322_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_964:
    .return (rx1322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("297_1299465717.405") :method
.annotate 'line', 4
    new $P1324, "ResizablePMCArray"
    push $P1324, "-"
    .return ($P1324)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("298_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_965
    rx1328_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1328_pos) = rx1328_cur."from"()
    inc rx1328_pos
    rx1328_cur."!cursor_from"(rx1328_pos)
    ge rx1328_pos, rx1328_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1332_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1333_fail
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  # rx literal  "?"
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 63, rx1328_fail
    add rx1328_pos, 1
    set_addr $I10, rxcap_1333_fail
    ($I12, $I11) = rx1328_cur."!mark_peek"($I10)
    rx1328_cur."!cursor_pos"($I11)
    ($P10) = rx1328_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1328_pos, "")
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1333_done
  rxcap_1333_fail:
    goto rx1328_fail
  rxcap_1333_done:
  # rx subrule "O" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1328_pos = $P10."pos"()
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "prefix:sym<?>")
    if_null rx1328_debug, debug_966
    rx1328_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1328_pos)
  debug_966:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 4
    if_null rx1328_debug, debug_967
    rx1328_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_967:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_968
    rx1328_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_968:
    .return (rx1328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("299_1299465717.405") :method
.annotate 'line', 4
    $P1330 = self."!PREFIX__!subrule"("O", "?")
    new $P1331, "ResizablePMCArray"
    push $P1331, $P1330
    .return ($P1331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("300_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1335_tgt
    .local int rx1335_pos
    .local int rx1335_off
    .local int rx1335_eos
    .local int rx1335_rep
    .local pmc rx1335_cur
    .local pmc rx1335_debug
    (rx1335_cur, rx1335_pos, rx1335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1335_cur
    .local pmc match
    .lex "$/", match
    length rx1335_eos, rx1335_tgt
    gt rx1335_pos, rx1335_eos, rx1335_done
    set rx1335_off, 0
    lt rx1335_pos, 2, rx1335_start
    sub rx1335_off, rx1335_pos, 1
    substr rx1335_tgt, rx1335_tgt, rx1335_off
  rx1335_start:
    eq $I10, 1, rx1335_restart
    if_null rx1335_debug, debug_969
    rx1335_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1339_done
    goto rxscan1339_scan
  rxscan1339_loop:
    (rx1335_pos) = rx1335_cur."from"()
    inc rx1335_pos
    rx1335_cur."!cursor_from"(rx1335_pos)
    ge rx1335_pos, rx1335_eos, rxscan1339_done
  rxscan1339_scan:
    set_addr $I10, rxscan1339_loop
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  rxscan1339_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1340_fail
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  # rx literal  "!"
    add $I11, rx1335_pos, 1
    gt $I11, rx1335_eos, rx1335_fail
    sub $I11, rx1335_pos, rx1335_off
    ord $I11, rx1335_tgt, $I11
    ne $I11, 33, rx1335_fail
    add rx1335_pos, 1
    set_addr $I10, rxcap_1340_fail
    ($I12, $I11) = rx1335_cur."!mark_peek"($I10)
    rx1335_cur."!cursor_pos"($I11)
    ($P10) = rx1335_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1335_pos, "")
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1340_done
  rxcap_1340_fail:
    goto rx1335_fail
  rxcap_1340_done:
  # rx subrule "O" subtype=capture negate=
    rx1335_cur."!cursor_pos"(rx1335_pos)
    $P10 = rx1335_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1335_fail
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1335_pos = $P10."pos"()
  # rx pass
    rx1335_cur."!cursor_pass"(rx1335_pos, "prefix:sym<!>")
    if_null rx1335_debug, debug_970
    rx1335_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1335_pos)
  debug_970:
    .return (rx1335_cur)
  rx1335_restart:
.annotate 'line', 4
    if_null rx1335_debug, debug_971
    rx1335_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_971:
  rx1335_fail:
    (rx1335_rep, rx1335_pos, $I10, $P10) = rx1335_cur."!mark_fail"(0)
    lt rx1335_pos, -1, rx1335_done
    eq rx1335_pos, -1, rx1335_fail
    jump $I10
  rx1335_done:
    rx1335_cur."!cursor_fail"()
    if_null rx1335_debug, debug_972
    rx1335_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_972:
    .return (rx1335_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("301_1299465717.405") :method
.annotate 'line', 4
    $P1337 = self."!PREFIX__!subrule"("O", "!")
    new $P1338, "ResizablePMCArray"
    push $P1338, $P1337
    .return ($P1338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("302_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1342_tgt
    .local int rx1342_pos
    .local int rx1342_off
    .local int rx1342_eos
    .local int rx1342_rep
    .local pmc rx1342_cur
    .local pmc rx1342_debug
    (rx1342_cur, rx1342_pos, rx1342_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1342_cur
    .local pmc match
    .lex "$/", match
    length rx1342_eos, rx1342_tgt
    gt rx1342_pos, rx1342_eos, rx1342_done
    set rx1342_off, 0
    lt rx1342_pos, 2, rx1342_start
    sub rx1342_off, rx1342_pos, 1
    substr rx1342_tgt, rx1342_tgt, rx1342_off
  rx1342_start:
    eq $I10, 1, rx1342_restart
    if_null rx1342_debug, debug_973
    rx1342_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1346_done
    goto rxscan1346_scan
  rxscan1346_loop:
    (rx1342_pos) = rx1342_cur."from"()
    inc rx1342_pos
    rx1342_cur."!cursor_from"(rx1342_pos)
    ge rx1342_pos, rx1342_eos, rxscan1346_done
  rxscan1346_scan:
    set_addr $I10, rxscan1346_loop
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxscan1346_done:
.annotate 'line', 601
  # rx subcapture "sym"
    set_addr $I10, rxcap_1347_fail
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  # rx literal  "|"
    add $I11, rx1342_pos, 1
    gt $I11, rx1342_eos, rx1342_fail
    sub $I11, rx1342_pos, rx1342_off
    ord $I11, rx1342_tgt, $I11
    ne $I11, 124, rx1342_fail
    add rx1342_pos, 1
    set_addr $I10, rxcap_1347_fail
    ($I12, $I11) = rx1342_cur."!mark_peek"($I10)
    rx1342_cur."!cursor_pos"($I11)
    ($P10) = rx1342_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1342_pos, "")
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1347_done
  rxcap_1347_fail:
    goto rx1342_fail
  rxcap_1347_done:
  # rx subrule "O" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."O"("%symbolic_unary")
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1342_pos = $P10."pos"()
  # rx pass
    rx1342_cur."!cursor_pass"(rx1342_pos, "prefix:sym<|>")
    if_null rx1342_debug, debug_974
    rx1342_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1342_pos)
  debug_974:
    .return (rx1342_cur)
  rx1342_restart:
.annotate 'line', 4
    if_null rx1342_debug, debug_975
    rx1342_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_975:
  rx1342_fail:
    (rx1342_rep, rx1342_pos, $I10, $P10) = rx1342_cur."!mark_fail"(0)
    lt rx1342_pos, -1, rx1342_done
    eq rx1342_pos, -1, rx1342_fail
    jump $I10
  rx1342_done:
    rx1342_cur."!cursor_fail"()
    if_null rx1342_debug, debug_976
    rx1342_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_976:
    .return (rx1342_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("303_1299465717.405") :method
.annotate 'line', 4
    $P1344 = self."!PREFIX__!subrule"("O", "|")
    new $P1345, "ResizablePMCArray"
    push $P1345, $P1344
    .return ($P1345)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("304_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1349_tgt
    .local int rx1349_pos
    .local int rx1349_off
    .local int rx1349_eos
    .local int rx1349_rep
    .local pmc rx1349_cur
    .local pmc rx1349_debug
    (rx1349_cur, rx1349_pos, rx1349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1349_cur
    .local pmc match
    .lex "$/", match
    length rx1349_eos, rx1349_tgt
    gt rx1349_pos, rx1349_eos, rx1349_done
    set rx1349_off, 0
    lt rx1349_pos, 2, rx1349_start
    sub rx1349_off, rx1349_pos, 1
    substr rx1349_tgt, rx1349_tgt, rx1349_off
  rx1349_start:
    eq $I10, 1, rx1349_restart
    if_null rx1349_debug, debug_977
    rx1349_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    (rx1349_pos) = rx1349_cur."from"()
    inc rx1349_pos
    rx1349_cur."!cursor_from"(rx1349_pos)
    ge rx1349_pos, rx1349_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxscan1353_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1354_fail
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  # rx literal  "*"
    add $I11, rx1349_pos, 1
    gt $I11, rx1349_eos, rx1349_fail
    sub $I11, rx1349_pos, rx1349_off
    ord $I11, rx1349_tgt, $I11
    ne $I11, 42, rx1349_fail
    add rx1349_pos, 1
    set_addr $I10, rxcap_1354_fail
    ($I12, $I11) = rx1349_cur."!mark_peek"($I10)
    rx1349_cur."!cursor_pos"($I11)
    ($P10) = rx1349_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1349_pos, "")
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1354_done
  rxcap_1354_fail:
    goto rx1349_fail
  rxcap_1354_done:
  # rx subrule "O" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1349_pos = $P10."pos"()
  # rx pass
    rx1349_cur."!cursor_pass"(rx1349_pos, "infix:sym<*>")
    if_null rx1349_debug, debug_978
    rx1349_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1349_pos)
  debug_978:
    .return (rx1349_cur)
  rx1349_restart:
.annotate 'line', 4
    if_null rx1349_debug, debug_979
    rx1349_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_979:
  rx1349_fail:
    (rx1349_rep, rx1349_pos, $I10, $P10) = rx1349_cur."!mark_fail"(0)
    lt rx1349_pos, -1, rx1349_done
    eq rx1349_pos, -1, rx1349_fail
    jump $I10
  rx1349_done:
    rx1349_cur."!cursor_fail"()
    if_null rx1349_debug, debug_980
    rx1349_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_980:
    .return (rx1349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("305_1299465717.405") :method
.annotate 'line', 4
    $P1351 = self."!PREFIX__!subrule"("O", "*")
    new $P1352, "ResizablePMCArray"
    push $P1352, $P1351
    .return ($P1352)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("306_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1356_tgt
    .local int rx1356_pos
    .local int rx1356_off
    .local int rx1356_eos
    .local int rx1356_rep
    .local pmc rx1356_cur
    .local pmc rx1356_debug
    (rx1356_cur, rx1356_pos, rx1356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1356_cur
    .local pmc match
    .lex "$/", match
    length rx1356_eos, rx1356_tgt
    gt rx1356_pos, rx1356_eos, rx1356_done
    set rx1356_off, 0
    lt rx1356_pos, 2, rx1356_start
    sub rx1356_off, rx1356_pos, 1
    substr rx1356_tgt, rx1356_tgt, rx1356_off
  rx1356_start:
    eq $I10, 1, rx1356_restart
    if_null rx1356_debug, debug_981
    rx1356_cur."!cursor_debug"("START", "infix:sym</>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1360_done
    goto rxscan1360_scan
  rxscan1360_loop:
    (rx1356_pos) = rx1356_cur."from"()
    inc rx1356_pos
    rx1356_cur."!cursor_from"(rx1356_pos)
    ge rx1356_pos, rx1356_eos, rxscan1360_done
  rxscan1360_scan:
    set_addr $I10, rxscan1360_loop
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxscan1360_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1361_fail
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  # rx literal  "/"
    add $I11, rx1356_pos, 1
    gt $I11, rx1356_eos, rx1356_fail
    sub $I11, rx1356_pos, rx1356_off
    ord $I11, rx1356_tgt, $I11
    ne $I11, 47, rx1356_fail
    add rx1356_pos, 1
    set_addr $I10, rxcap_1361_fail
    ($I12, $I11) = rx1356_cur."!mark_peek"($I10)
    rx1356_cur."!cursor_pos"($I11)
    ($P10) = rx1356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1356_pos, "")
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1361_done
  rxcap_1361_fail:
    goto rx1356_fail
  rxcap_1361_done:
  # rx subrule "O" subtype=capture negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1356_fail
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1356_pos = $P10."pos"()
  # rx pass
    rx1356_cur."!cursor_pass"(rx1356_pos, "infix:sym</>")
    if_null rx1356_debug, debug_982
    rx1356_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1356_pos)
  debug_982:
    .return (rx1356_cur)
  rx1356_restart:
.annotate 'line', 4
    if_null rx1356_debug, debug_983
    rx1356_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_983:
  rx1356_fail:
    (rx1356_rep, rx1356_pos, $I10, $P10) = rx1356_cur."!mark_fail"(0)
    lt rx1356_pos, -1, rx1356_done
    eq rx1356_pos, -1, rx1356_fail
    jump $I10
  rx1356_done:
    rx1356_cur."!cursor_fail"()
    if_null rx1356_debug, debug_984
    rx1356_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_984:
    .return (rx1356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("307_1299465717.405") :method
.annotate 'line', 4
    $P1358 = self."!PREFIX__!subrule"("O", "/")
    new $P1359, "ResizablePMCArray"
    push $P1359, $P1358
    .return ($P1359)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("308_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1363_tgt
    .local int rx1363_pos
    .local int rx1363_off
    .local int rx1363_eos
    .local int rx1363_rep
    .local pmc rx1363_cur
    .local pmc rx1363_debug
    (rx1363_cur, rx1363_pos, rx1363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1363_cur
    .local pmc match
    .lex "$/", match
    length rx1363_eos, rx1363_tgt
    gt rx1363_pos, rx1363_eos, rx1363_done
    set rx1363_off, 0
    lt rx1363_pos, 2, rx1363_start
    sub rx1363_off, rx1363_pos, 1
    substr rx1363_tgt, rx1363_tgt, rx1363_off
  rx1363_start:
    eq $I10, 1, rx1363_restart
    if_null rx1363_debug, debug_985
    rx1363_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    (rx1363_pos) = rx1363_cur."from"()
    inc rx1363_pos
    rx1363_cur."!cursor_from"(rx1363_pos)
    ge rx1363_pos, rx1363_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxscan1367_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1368_fail
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  # rx literal  "%"
    add $I11, rx1363_pos, 1
    gt $I11, rx1363_eos, rx1363_fail
    sub $I11, rx1363_pos, rx1363_off
    ord $I11, rx1363_tgt, $I11
    ne $I11, 37, rx1363_fail
    add rx1363_pos, 1
    set_addr $I10, rxcap_1368_fail
    ($I12, $I11) = rx1363_cur."!mark_peek"($I10)
    rx1363_cur."!cursor_pos"($I11)
    ($P10) = rx1363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1363_pos, "")
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1368_done
  rxcap_1368_fail:
    goto rx1363_fail
  rxcap_1368_done:
  # rx subrule "O" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1363_pos = $P10."pos"()
  # rx pass
    rx1363_cur."!cursor_pass"(rx1363_pos, "infix:sym<%>")
    if_null rx1363_debug, debug_986
    rx1363_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1363_pos)
  debug_986:
    .return (rx1363_cur)
  rx1363_restart:
.annotate 'line', 4
    if_null rx1363_debug, debug_987
    rx1363_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_987:
  rx1363_fail:
    (rx1363_rep, rx1363_pos, $I10, $P10) = rx1363_cur."!mark_fail"(0)
    lt rx1363_pos, -1, rx1363_done
    eq rx1363_pos, -1, rx1363_fail
    jump $I10
  rx1363_done:
    rx1363_cur."!cursor_fail"()
    if_null rx1363_debug, debug_988
    rx1363_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_988:
    .return (rx1363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("309_1299465717.405") :method
.annotate 'line', 4
    $P1365 = self."!PREFIX__!subrule"("O", "%")
    new $P1366, "ResizablePMCArray"
    push $P1366, $P1365
    .return ($P1366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("310_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_989
    rx1370_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    (rx1370_pos) = rx1370_cur."from"()
    inc rx1370_pos
    rx1370_cur."!cursor_from"(rx1370_pos)
    ge rx1370_pos, rx1370_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1374_done:
.annotate 'line', 606
  # rx subcapture "sym"
    set_addr $I10, rxcap_1375_fail
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1370_pos, 2
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I11, 2
    ne $S10, "+&", rx1370_fail
    add rx1370_pos, 2
    set_addr $I10, rxcap_1375_fail
    ($I12, $I11) = rx1370_cur."!mark_peek"($I10)
    rx1370_cur."!cursor_pos"($I11)
    ($P10) = rx1370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1370_pos, "")
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1375_done
  rxcap_1375_fail:
    goto rx1370_fail
  rxcap_1375_done:
  # rx subrule "O" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "infix:sym<+&>")
    if_null rx1370_debug, debug_990
    rx1370_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1370_pos)
  debug_990:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 4
    if_null rx1370_debug, debug_991
    rx1370_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_991:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_992
    rx1370_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_992:
    .return (rx1370_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("311_1299465717.405") :method
.annotate 'line', 4
    $P1372 = self."!PREFIX__!subrule"("O", "+&")
    new $P1373, "ResizablePMCArray"
    push $P1373, $P1372
    .return ($P1373)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("312_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_993
    rx1377_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    (rx1377_pos) = rx1377_cur."from"()
    inc rx1377_pos
    rx1377_cur."!cursor_from"(rx1377_pos)
    ge rx1377_pos, rx1377_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1381_done:
.annotate 'line', 608
  # rx subcapture "sym"
    set_addr $I10, rxcap_1382_fail
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  # rx literal  "+"
    add $I11, rx1377_pos, 1
    gt $I11, rx1377_eos, rx1377_fail
    sub $I11, rx1377_pos, rx1377_off
    ord $I11, rx1377_tgt, $I11
    ne $I11, 43, rx1377_fail
    add rx1377_pos, 1
    set_addr $I10, rxcap_1382_fail
    ($I12, $I11) = rx1377_cur."!mark_peek"($I10)
    rx1377_cur."!cursor_pos"($I11)
    ($P10) = rx1377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1377_pos, "")
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1382_done
  rxcap_1382_fail:
    goto rx1377_fail
  rxcap_1382_done:
  # rx subrule "O" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1377_fail
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1377_pos = $P10."pos"()
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "infix:sym<+>")
    if_null rx1377_debug, debug_994
    rx1377_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1377_pos)
  debug_994:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 4
    if_null rx1377_debug, debug_995
    rx1377_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_995:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_996
    rx1377_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_996:
    .return (rx1377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("313_1299465717.405") :method
.annotate 'line', 4
    $P1379 = self."!PREFIX__!subrule"("O", "+")
    new $P1380, "ResizablePMCArray"
    push $P1380, $P1379
    .return ($P1380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("314_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_997
    rx1384_cur."!cursor_debug"("START", "infix:sym<->")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1389_fail
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  # rx literal  "-"
    add $I11, rx1384_pos, 1
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    ord $I11, rx1384_tgt, $I11
    ne $I11, 45, rx1384_fail
    add rx1384_pos, 1
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1384_cur."!mark_peek"($I10)
    rx1384_cur."!cursor_pos"($I11)
    ($P10) = rx1384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1384_pos, "")
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1384_fail
  rxcap_1389_done:
  # rx subrule "O" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "infix:sym<->")
    if_null rx1384_debug, debug_998
    rx1384_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1384_pos)
  debug_998:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 4
    if_null rx1384_debug, debug_999
    rx1384_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_999:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1000
    rx1384_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1000:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("315_1299465717.405") :method
.annotate 'line', 4
    $P1386 = self."!PREFIX__!subrule"("O", "-")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("316_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_1001
    rx1391_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1395_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1396_fail
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1391_pos, 2
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    substr $S10, rx1391_tgt, $I11, 2
    ne $S10, "+|", rx1391_fail
    add rx1391_pos, 2
    set_addr $I10, rxcap_1396_fail
    ($I12, $I11) = rx1391_cur."!mark_peek"($I10)
    rx1391_cur."!cursor_pos"($I11)
    ($P10) = rx1391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1391_pos, "")
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1396_done
  rxcap_1396_fail:
    goto rx1391_fail
  rxcap_1396_done:
  # rx subrule "O" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1391_pos = $P10."pos"()
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "infix:sym<+|>")
    if_null rx1391_debug, debug_1002
    rx1391_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1391_pos)
  debug_1002:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 4
    if_null rx1391_debug, debug_1003
    rx1391_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1003:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_1004
    rx1391_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1004:
    .return (rx1391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("317_1299465717.405") :method
.annotate 'line', 4
    $P1393 = self."!PREFIX__!subrule"("O", "+|")
    new $P1394, "ResizablePMCArray"
    push $P1394, $P1393
    .return ($P1394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("318_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1005
    rx1398_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    (rx1398_pos) = rx1398_cur."from"()
    inc rx1398_pos
    rx1398_cur."!cursor_from"(rx1398_pos)
    ge rx1398_pos, rx1398_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1402_done:
.annotate 'line', 611
  # rx subcapture "sym"
    set_addr $I10, rxcap_1403_fail
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1398_pos, 2
    gt $I11, rx1398_eos, rx1398_fail
    sub $I11, rx1398_pos, rx1398_off
    substr $S10, rx1398_tgt, $I11, 2
    ne $S10, "+^", rx1398_fail
    add rx1398_pos, 2
    set_addr $I10, rxcap_1403_fail
    ($I12, $I11) = rx1398_cur."!mark_peek"($I10)
    rx1398_cur."!cursor_pos"($I11)
    ($P10) = rx1398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1398_pos, "")
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1403_done
  rxcap_1403_fail:
    goto rx1398_fail
  rxcap_1403_done:
  # rx subrule "O" subtype=capture negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1398_fail
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1398_pos = $P10."pos"()
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "infix:sym<+^>")
    if_null rx1398_debug, debug_1006
    rx1398_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1398_pos)
  debug_1006:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 4
    if_null rx1398_debug, debug_1007
    rx1398_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1007:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1008
    rx1398_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1008:
    .return (rx1398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("319_1299465717.405") :method
.annotate 'line', 4
    $P1400 = self."!PREFIX__!subrule"("O", "+^")
    new $P1401, "ResizablePMCArray"
    push $P1401, $P1400
    .return ($P1401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("320_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1405_tgt
    .local int rx1405_pos
    .local int rx1405_off
    .local int rx1405_eos
    .local int rx1405_rep
    .local pmc rx1405_cur
    .local pmc rx1405_debug
    (rx1405_cur, rx1405_pos, rx1405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1405_cur
    .local pmc match
    .lex "$/", match
    length rx1405_eos, rx1405_tgt
    gt rx1405_pos, rx1405_eos, rx1405_done
    set rx1405_off, 0
    lt rx1405_pos, 2, rx1405_start
    sub rx1405_off, rx1405_pos, 1
    substr rx1405_tgt, rx1405_tgt, rx1405_off
  rx1405_start:
    eq $I10, 1, rx1405_restart
    if_null rx1405_debug, debug_1009
    rx1405_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1409_done
    goto rxscan1409_scan
  rxscan1409_loop:
    (rx1405_pos) = rx1405_cur."from"()
    inc rx1405_pos
    rx1405_cur."!cursor_from"(rx1405_pos)
    ge rx1405_pos, rx1405_eos, rxscan1409_done
  rxscan1409_scan:
    set_addr $I10, rxscan1409_loop
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  rxscan1409_done:
.annotate 'line', 613
  # rx subcapture "sym"
    set_addr $I10, rxcap_1410_fail
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  # rx literal  "~"
    add $I11, rx1405_pos, 1
    gt $I11, rx1405_eos, rx1405_fail
    sub $I11, rx1405_pos, rx1405_off
    ord $I11, rx1405_tgt, $I11
    ne $I11, 126, rx1405_fail
    add rx1405_pos, 1
    set_addr $I10, rxcap_1410_fail
    ($I12, $I11) = rx1405_cur."!mark_peek"($I10)
    rx1405_cur."!cursor_pos"($I11)
    ($P10) = rx1405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1405_pos, "")
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1410_done
  rxcap_1410_fail:
    goto rx1405_fail
  rxcap_1410_done:
  # rx subrule "O" subtype=capture negate=
    rx1405_cur."!cursor_pos"(rx1405_pos)
    $P10 = rx1405_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1405_fail
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1405_pos = $P10."pos"()
  # rx pass
    rx1405_cur."!cursor_pass"(rx1405_pos, "infix:sym<~>")
    if_null rx1405_debug, debug_1010
    rx1405_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1405_pos)
  debug_1010:
    .return (rx1405_cur)
  rx1405_restart:
.annotate 'line', 4
    if_null rx1405_debug, debug_1011
    rx1405_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1011:
  rx1405_fail:
    (rx1405_rep, rx1405_pos, $I10, $P10) = rx1405_cur."!mark_fail"(0)
    lt rx1405_pos, -1, rx1405_done
    eq rx1405_pos, -1, rx1405_fail
    jump $I10
  rx1405_done:
    rx1405_cur."!cursor_fail"()
    if_null rx1405_debug, debug_1012
    rx1405_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1012:
    .return (rx1405_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("321_1299465717.405") :method
.annotate 'line', 4
    $P1407 = self."!PREFIX__!subrule"("O", "~")
    new $P1408, "ResizablePMCArray"
    push $P1408, $P1407
    .return ($P1408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("322_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1412_tgt
    .local int rx1412_pos
    .local int rx1412_off
    .local int rx1412_eos
    .local int rx1412_rep
    .local pmc rx1412_cur
    .local pmc rx1412_debug
    (rx1412_cur, rx1412_pos, rx1412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1412_cur
    .local pmc match
    .lex "$/", match
    length rx1412_eos, rx1412_tgt
    gt rx1412_pos, rx1412_eos, rx1412_done
    set rx1412_off, 0
    lt rx1412_pos, 2, rx1412_start
    sub rx1412_off, rx1412_pos, 1
    substr rx1412_tgt, rx1412_tgt, rx1412_off
  rx1412_start:
    eq $I10, 1, rx1412_restart
    if_null rx1412_debug, debug_1013
    rx1412_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    (rx1412_pos) = rx1412_cur."from"()
    inc rx1412_pos
    rx1412_cur."!cursor_from"(rx1412_pos)
    ge rx1412_pos, rx1412_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  rxscan1416_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1417_fail
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  # rx literal  "=="
    add $I11, rx1412_pos, 2
    gt $I11, rx1412_eos, rx1412_fail
    sub $I11, rx1412_pos, rx1412_off
    substr $S10, rx1412_tgt, $I11, 2
    ne $S10, "==", rx1412_fail
    add rx1412_pos, 2
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1412_cur."!mark_peek"($I10)
    rx1412_cur."!cursor_pos"($I11)
    ($P10) = rx1412_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1412_pos, "")
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1412_fail
  rxcap_1417_done:
  # rx subrule "O" subtype=capture negate=
    rx1412_cur."!cursor_pos"(rx1412_pos)
    $P10 = rx1412_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1412_fail
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1412_pos = $P10."pos"()
  # rx pass
    rx1412_cur."!cursor_pass"(rx1412_pos, "infix:sym<==>")
    if_null rx1412_debug, debug_1014
    rx1412_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1412_pos)
  debug_1014:
    .return (rx1412_cur)
  rx1412_restart:
.annotate 'line', 4
    if_null rx1412_debug, debug_1015
    rx1412_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1015:
  rx1412_fail:
    (rx1412_rep, rx1412_pos, $I10, $P10) = rx1412_cur."!mark_fail"(0)
    lt rx1412_pos, -1, rx1412_done
    eq rx1412_pos, -1, rx1412_fail
    jump $I10
  rx1412_done:
    rx1412_cur."!cursor_fail"()
    if_null rx1412_debug, debug_1016
    rx1412_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1016:
    .return (rx1412_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("323_1299465717.405") :method
.annotate 'line', 4
    $P1414 = self."!PREFIX__!subrule"("O", "==")
    new $P1415, "ResizablePMCArray"
    push $P1415, $P1414
    .return ($P1415)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("324_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_1017
    rx1419_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1423_done
    goto rxscan1423_scan
  rxscan1423_loop:
    (rx1419_pos) = rx1419_cur."from"()
    inc rx1419_pos
    rx1419_cur."!cursor_from"(rx1419_pos)
    ge rx1419_pos, rx1419_eos, rxscan1423_done
  rxscan1423_scan:
    set_addr $I10, rxscan1423_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1423_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1424_fail
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  # rx literal  "!="
    add $I11, rx1419_pos, 2
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    substr $S10, rx1419_tgt, $I11, 2
    ne $S10, "!=", rx1419_fail
    add rx1419_pos, 2
    set_addr $I10, rxcap_1424_fail
    ($I12, $I11) = rx1419_cur."!mark_peek"($I10)
    rx1419_cur."!cursor_pos"($I11)
    ($P10) = rx1419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1419_pos, "")
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1424_done
  rxcap_1424_fail:
    goto rx1419_fail
  rxcap_1424_done:
  # rx subrule "O" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1419_pos = $P10."pos"()
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "infix:sym<!=>")
    if_null rx1419_debug, debug_1018
    rx1419_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1419_pos)
  debug_1018:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 4
    if_null rx1419_debug, debug_1019
    rx1419_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1019:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_1020
    rx1419_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1020:
    .return (rx1419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("325_1299465717.405") :method
.annotate 'line', 4
    $P1421 = self."!PREFIX__!subrule"("O", "!=")
    new $P1422, "ResizablePMCArray"
    push $P1422, $P1421
    .return ($P1422)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("326_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1426_tgt
    .local int rx1426_pos
    .local int rx1426_off
    .local int rx1426_eos
    .local int rx1426_rep
    .local pmc rx1426_cur
    .local pmc rx1426_debug
    (rx1426_cur, rx1426_pos, rx1426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1426_cur
    .local pmc match
    .lex "$/", match
    length rx1426_eos, rx1426_tgt
    gt rx1426_pos, rx1426_eos, rx1426_done
    set rx1426_off, 0
    lt rx1426_pos, 2, rx1426_start
    sub rx1426_off, rx1426_pos, 1
    substr rx1426_tgt, rx1426_tgt, rx1426_off
  rx1426_start:
    eq $I10, 1, rx1426_restart
    if_null rx1426_debug, debug_1021
    rx1426_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1430_done
    goto rxscan1430_scan
  rxscan1430_loop:
    (rx1426_pos) = rx1426_cur."from"()
    inc rx1426_pos
    rx1426_cur."!cursor_from"(rx1426_pos)
    ge rx1426_pos, rx1426_eos, rxscan1430_done
  rxscan1430_scan:
    set_addr $I10, rxscan1430_loop
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxscan1430_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1431_fail
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  # rx literal  "<="
    add $I11, rx1426_pos, 2
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    substr $S10, rx1426_tgt, $I11, 2
    ne $S10, "<=", rx1426_fail
    add rx1426_pos, 2
    set_addr $I10, rxcap_1431_fail
    ($I12, $I11) = rx1426_cur."!mark_peek"($I10)
    rx1426_cur."!cursor_pos"($I11)
    ($P10) = rx1426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1426_pos, "")
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1431_done
  rxcap_1431_fail:
    goto rx1426_fail
  rxcap_1431_done:
  # rx subrule "O" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1426_pos = $P10."pos"()
  # rx pass
    rx1426_cur."!cursor_pass"(rx1426_pos, "infix:sym<<=>")
    if_null rx1426_debug, debug_1022
    rx1426_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1426_pos)
  debug_1022:
    .return (rx1426_cur)
  rx1426_restart:
.annotate 'line', 4
    if_null rx1426_debug, debug_1023
    rx1426_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1023:
  rx1426_fail:
    (rx1426_rep, rx1426_pos, $I10, $P10) = rx1426_cur."!mark_fail"(0)
    lt rx1426_pos, -1, rx1426_done
    eq rx1426_pos, -1, rx1426_fail
    jump $I10
  rx1426_done:
    rx1426_cur."!cursor_fail"()
    if_null rx1426_debug, debug_1024
    rx1426_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1024:
    .return (rx1426_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("327_1299465717.405") :method
.annotate 'line', 4
    $P1428 = self."!PREFIX__!subrule"("O", "<=")
    new $P1429, "ResizablePMCArray"
    push $P1429, $P1428
    .return ($P1429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("328_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1433_tgt
    .local int rx1433_pos
    .local int rx1433_off
    .local int rx1433_eos
    .local int rx1433_rep
    .local pmc rx1433_cur
    .local pmc rx1433_debug
    (rx1433_cur, rx1433_pos, rx1433_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1433_cur
    .local pmc match
    .lex "$/", match
    length rx1433_eos, rx1433_tgt
    gt rx1433_pos, rx1433_eos, rx1433_done
    set rx1433_off, 0
    lt rx1433_pos, 2, rx1433_start
    sub rx1433_off, rx1433_pos, 1
    substr rx1433_tgt, rx1433_tgt, rx1433_off
  rx1433_start:
    eq $I10, 1, rx1433_restart
    if_null rx1433_debug, debug_1025
    rx1433_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1437_done
    goto rxscan1437_scan
  rxscan1437_loop:
    (rx1433_pos) = rx1433_cur."from"()
    inc rx1433_pos
    rx1433_cur."!cursor_from"(rx1433_pos)
    ge rx1433_pos, rx1433_eos, rxscan1437_done
  rxscan1437_scan:
    set_addr $I10, rxscan1437_loop
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  rxscan1437_done:
.annotate 'line', 618
  # rx subcapture "sym"
    set_addr $I10, rxcap_1438_fail
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  # rx literal  ">="
    add $I11, rx1433_pos, 2
    gt $I11, rx1433_eos, rx1433_fail
    sub $I11, rx1433_pos, rx1433_off
    substr $S10, rx1433_tgt, $I11, 2
    ne $S10, ">=", rx1433_fail
    add rx1433_pos, 2
    set_addr $I10, rxcap_1438_fail
    ($I12, $I11) = rx1433_cur."!mark_peek"($I10)
    rx1433_cur."!cursor_pos"($I11)
    ($P10) = rx1433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1433_pos, "")
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1438_done
  rxcap_1438_fail:
    goto rx1433_fail
  rxcap_1438_done:
  # rx subrule "O" subtype=capture negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1433_fail
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1433_pos = $P10."pos"()
  # rx pass
    rx1433_cur."!cursor_pass"(rx1433_pos, "infix:sym<>=>")
    if_null rx1433_debug, debug_1026
    rx1433_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1433_pos)
  debug_1026:
    .return (rx1433_cur)
  rx1433_restart:
.annotate 'line', 4
    if_null rx1433_debug, debug_1027
    rx1433_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1027:
  rx1433_fail:
    (rx1433_rep, rx1433_pos, $I10, $P10) = rx1433_cur."!mark_fail"(0)
    lt rx1433_pos, -1, rx1433_done
    eq rx1433_pos, -1, rx1433_fail
    jump $I10
  rx1433_done:
    rx1433_cur."!cursor_fail"()
    if_null rx1433_debug, debug_1028
    rx1433_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1028:
    .return (rx1433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("329_1299465717.405") :method
.annotate 'line', 4
    $P1435 = self."!PREFIX__!subrule"("O", ">=")
    new $P1436, "ResizablePMCArray"
    push $P1436, $P1435
    .return ($P1436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("330_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1440_tgt
    .local int rx1440_pos
    .local int rx1440_off
    .local int rx1440_eos
    .local int rx1440_rep
    .local pmc rx1440_cur
    .local pmc rx1440_debug
    (rx1440_cur, rx1440_pos, rx1440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1440_cur
    .local pmc match
    .lex "$/", match
    length rx1440_eos, rx1440_tgt
    gt rx1440_pos, rx1440_eos, rx1440_done
    set rx1440_off, 0
    lt rx1440_pos, 2, rx1440_start
    sub rx1440_off, rx1440_pos, 1
    substr rx1440_tgt, rx1440_tgt, rx1440_off
  rx1440_start:
    eq $I10, 1, rx1440_restart
    if_null rx1440_debug, debug_1029
    rx1440_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1444_done
    goto rxscan1444_scan
  rxscan1444_loop:
    (rx1440_pos) = rx1440_cur."from"()
    inc rx1440_pos
    rx1440_cur."!cursor_from"(rx1440_pos)
    ge rx1440_pos, rx1440_eos, rxscan1444_done
  rxscan1444_scan:
    set_addr $I10, rxscan1444_loop
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  rxscan1444_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1445_fail
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  # rx literal  "<"
    add $I11, rx1440_pos, 1
    gt $I11, rx1440_eos, rx1440_fail
    sub $I11, rx1440_pos, rx1440_off
    ord $I11, rx1440_tgt, $I11
    ne $I11, 60, rx1440_fail
    add rx1440_pos, 1
    set_addr $I10, rxcap_1445_fail
    ($I12, $I11) = rx1440_cur."!mark_peek"($I10)
    rx1440_cur."!cursor_pos"($I11)
    ($P10) = rx1440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1440_pos, "")
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1445_done
  rxcap_1445_fail:
    goto rx1440_fail
  rxcap_1445_done:
  # rx subrule "O" subtype=capture negate=
    rx1440_cur."!cursor_pos"(rx1440_pos)
    $P10 = rx1440_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1440_fail
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1440_pos = $P10."pos"()
  # rx pass
    rx1440_cur."!cursor_pass"(rx1440_pos, "infix:sym<<>")
    if_null rx1440_debug, debug_1030
    rx1440_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1440_pos)
  debug_1030:
    .return (rx1440_cur)
  rx1440_restart:
.annotate 'line', 4
    if_null rx1440_debug, debug_1031
    rx1440_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1031:
  rx1440_fail:
    (rx1440_rep, rx1440_pos, $I10, $P10) = rx1440_cur."!mark_fail"(0)
    lt rx1440_pos, -1, rx1440_done
    eq rx1440_pos, -1, rx1440_fail
    jump $I10
  rx1440_done:
    rx1440_cur."!cursor_fail"()
    if_null rx1440_debug, debug_1032
    rx1440_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1032:
    .return (rx1440_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("331_1299465717.405") :method
.annotate 'line', 4
    $P1442 = self."!PREFIX__!subrule"("O", "<")
    new $P1443, "ResizablePMCArray"
    push $P1443, $P1442
    .return ($P1443)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("332_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1447_tgt
    .local int rx1447_pos
    .local int rx1447_off
    .local int rx1447_eos
    .local int rx1447_rep
    .local pmc rx1447_cur
    .local pmc rx1447_debug
    (rx1447_cur, rx1447_pos, rx1447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1447_cur
    .local pmc match
    .lex "$/", match
    length rx1447_eos, rx1447_tgt
    gt rx1447_pos, rx1447_eos, rx1447_done
    set rx1447_off, 0
    lt rx1447_pos, 2, rx1447_start
    sub rx1447_off, rx1447_pos, 1
    substr rx1447_tgt, rx1447_tgt, rx1447_off
  rx1447_start:
    eq $I10, 1, rx1447_restart
    if_null rx1447_debug, debug_1033
    rx1447_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1451_done
    goto rxscan1451_scan
  rxscan1451_loop:
    (rx1447_pos) = rx1447_cur."from"()
    inc rx1447_pos
    rx1447_cur."!cursor_from"(rx1447_pos)
    ge rx1447_pos, rx1447_eos, rxscan1451_done
  rxscan1451_scan:
    set_addr $I10, rxscan1451_loop
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  rxscan1451_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1452_fail
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  # rx literal  ">"
    add $I11, rx1447_pos, 1
    gt $I11, rx1447_eos, rx1447_fail
    sub $I11, rx1447_pos, rx1447_off
    ord $I11, rx1447_tgt, $I11
    ne $I11, 62, rx1447_fail
    add rx1447_pos, 1
    set_addr $I10, rxcap_1452_fail
    ($I12, $I11) = rx1447_cur."!mark_peek"($I10)
    rx1447_cur."!cursor_pos"($I11)
    ($P10) = rx1447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1447_pos, "")
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1452_done
  rxcap_1452_fail:
    goto rx1447_fail
  rxcap_1452_done:
  # rx subrule "O" subtype=capture negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1447_fail
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1447_pos = $P10."pos"()
  # rx pass
    rx1447_cur."!cursor_pass"(rx1447_pos, "infix:sym<>>")
    if_null rx1447_debug, debug_1034
    rx1447_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1447_pos)
  debug_1034:
    .return (rx1447_cur)
  rx1447_restart:
.annotate 'line', 4
    if_null rx1447_debug, debug_1035
    rx1447_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1035:
  rx1447_fail:
    (rx1447_rep, rx1447_pos, $I10, $P10) = rx1447_cur."!mark_fail"(0)
    lt rx1447_pos, -1, rx1447_done
    eq rx1447_pos, -1, rx1447_fail
    jump $I10
  rx1447_done:
    rx1447_cur."!cursor_fail"()
    if_null rx1447_debug, debug_1036
    rx1447_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1036:
    .return (rx1447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("333_1299465717.405") :method
.annotate 'line', 4
    $P1449 = self."!PREFIX__!subrule"("O", ">")
    new $P1450, "ResizablePMCArray"
    push $P1450, $P1449
    .return ($P1450)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("334_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1454_tgt
    .local int rx1454_pos
    .local int rx1454_off
    .local int rx1454_eos
    .local int rx1454_rep
    .local pmc rx1454_cur
    .local pmc rx1454_debug
    (rx1454_cur, rx1454_pos, rx1454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1454_cur
    .local pmc match
    .lex "$/", match
    length rx1454_eos, rx1454_tgt
    gt rx1454_pos, rx1454_eos, rx1454_done
    set rx1454_off, 0
    lt rx1454_pos, 2, rx1454_start
    sub rx1454_off, rx1454_pos, 1
    substr rx1454_tgt, rx1454_tgt, rx1454_off
  rx1454_start:
    eq $I10, 1, rx1454_restart
    if_null rx1454_debug, debug_1037
    rx1454_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1454_pos) = rx1454_cur."from"()
    inc rx1454_pos
    rx1454_cur."!cursor_from"(rx1454_pos)
    ge rx1454_pos, rx1454_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  rxscan1458_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1454_pos, 2
    gt $I11, rx1454_eos, rx1454_fail
    sub $I11, rx1454_pos, rx1454_off
    substr $S10, rx1454_tgt, $I11, 2
    ne $S10, "eq", rx1454_fail
    add rx1454_pos, 2
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1454_cur."!mark_peek"($I10)
    rx1454_cur."!cursor_pos"($I11)
    ($P10) = rx1454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1454_pos, "")
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1454_fail
  rxcap_1459_done:
  # rx subrule "O" subtype=capture negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1454_fail
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1454_pos = $P10."pos"()
  # rx pass
    rx1454_cur."!cursor_pass"(rx1454_pos, "infix:sym<eq>")
    if_null rx1454_debug, debug_1038
    rx1454_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1454_pos)
  debug_1038:
    .return (rx1454_cur)
  rx1454_restart:
.annotate 'line', 4
    if_null rx1454_debug, debug_1039
    rx1454_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1039:
  rx1454_fail:
    (rx1454_rep, rx1454_pos, $I10, $P10) = rx1454_cur."!mark_fail"(0)
    lt rx1454_pos, -1, rx1454_done
    eq rx1454_pos, -1, rx1454_fail
    jump $I10
  rx1454_done:
    rx1454_cur."!cursor_fail"()
    if_null rx1454_debug, debug_1040
    rx1454_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1040:
    .return (rx1454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("335_1299465717.405") :method
.annotate 'line', 4
    $P1456 = self."!PREFIX__!subrule"("O", "eq")
    new $P1457, "ResizablePMCArray"
    push $P1457, $P1456
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("336_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1041
    rx1461_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1465_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1461_pos, 2
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 2
    ne $S10, "ne", rx1461_fail
    add rx1461_pos, 2
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1461_fail
  rxcap_1466_done:
  # rx subrule "O" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1461_pos = $P10."pos"()
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "infix:sym<ne>")
    if_null rx1461_debug, debug_1042
    rx1461_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1461_pos)
  debug_1042:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 4
    if_null rx1461_debug, debug_1043
    rx1461_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1043:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1044
    rx1461_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1044:
    .return (rx1461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("337_1299465717.405") :method
.annotate 'line', 4
    $P1463 = self."!PREFIX__!subrule"("O", "ne")
    new $P1464, "ResizablePMCArray"
    push $P1464, $P1463
    .return ($P1464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("338_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1045
    rx1468_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1472_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "le"
    add $I11, rx1468_pos, 2
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I11, 2
    ne $S10, "le", rx1468_fail
    add rx1468_pos, 2
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1468_fail
  rxcap_1473_done:
  # rx subrule "O" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "infix:sym<le>")
    if_null rx1468_debug, debug_1046
    rx1468_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1468_pos)
  debug_1046:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 4
    if_null rx1468_debug, debug_1047
    rx1468_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1047:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1048
    rx1468_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1048:
    .return (rx1468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("339_1299465717.405") :method
.annotate 'line', 4
    $P1470 = self."!PREFIX__!subrule"("O", "le")
    new $P1471, "ResizablePMCArray"
    push $P1471, $P1470
    .return ($P1471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("340_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1475_tgt
    .local int rx1475_pos
    .local int rx1475_off
    .local int rx1475_eos
    .local int rx1475_rep
    .local pmc rx1475_cur
    .local pmc rx1475_debug
    (rx1475_cur, rx1475_pos, rx1475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1475_cur
    .local pmc match
    .lex "$/", match
    length rx1475_eos, rx1475_tgt
    gt rx1475_pos, rx1475_eos, rx1475_done
    set rx1475_off, 0
    lt rx1475_pos, 2, rx1475_start
    sub rx1475_off, rx1475_pos, 1
    substr rx1475_tgt, rx1475_tgt, rx1475_off
  rx1475_start:
    eq $I10, 1, rx1475_restart
    if_null rx1475_debug, debug_1049
    rx1475_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    (rx1475_pos) = rx1475_cur."from"()
    inc rx1475_pos
    rx1475_cur."!cursor_from"(rx1475_pos)
    ge rx1475_pos, rx1475_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  rxscan1479_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1475_pos, 2
    gt $I11, rx1475_eos, rx1475_fail
    sub $I11, rx1475_pos, rx1475_off
    substr $S10, rx1475_tgt, $I11, 2
    ne $S10, "ge", rx1475_fail
    add rx1475_pos, 2
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1475_cur."!mark_peek"($I10)
    rx1475_cur."!cursor_pos"($I11)
    ($P10) = rx1475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1475_pos, "")
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1475_fail
  rxcap_1480_done:
  # rx subrule "O" subtype=capture negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1475_fail
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1475_pos = $P10."pos"()
  # rx pass
    rx1475_cur."!cursor_pass"(rx1475_pos, "infix:sym<ge>")
    if_null rx1475_debug, debug_1050
    rx1475_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1475_pos)
  debug_1050:
    .return (rx1475_cur)
  rx1475_restart:
.annotate 'line', 4
    if_null rx1475_debug, debug_1051
    rx1475_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1051:
  rx1475_fail:
    (rx1475_rep, rx1475_pos, $I10, $P10) = rx1475_cur."!mark_fail"(0)
    lt rx1475_pos, -1, rx1475_done
    eq rx1475_pos, -1, rx1475_fail
    jump $I10
  rx1475_done:
    rx1475_cur."!cursor_fail"()
    if_null rx1475_debug, debug_1052
    rx1475_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1052:
    .return (rx1475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("341_1299465717.405") :method
.annotate 'line', 4
    $P1477 = self."!PREFIX__!subrule"("O", "ge")
    new $P1478, "ResizablePMCArray"
    push $P1478, $P1477
    .return ($P1478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("342_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1053
    rx1482_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 625
  # rx subcapture "sym"
    set_addr $I10, rxcap_1487_fail
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1482_pos, 2
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    substr $S10, rx1482_tgt, $I11, 2
    ne $S10, "lt", rx1482_fail
    add rx1482_pos, 2
    set_addr $I10, rxcap_1487_fail
    ($I12, $I11) = rx1482_cur."!mark_peek"($I10)
    rx1482_cur."!cursor_pos"($I11)
    ($P10) = rx1482_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1482_pos, "")
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1487_done
  rxcap_1487_fail:
    goto rx1482_fail
  rxcap_1487_done:
  # rx subrule "O" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1482_pos = $P10."pos"()
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "infix:sym<lt>")
    if_null rx1482_debug, debug_1054
    rx1482_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1482_pos)
  debug_1054:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 4
    if_null rx1482_debug, debug_1055
    rx1482_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1055:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1056
    rx1482_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1056:
    .return (rx1482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("343_1299465717.405") :method
.annotate 'line', 4
    $P1484 = self."!PREFIX__!subrule"("O", "lt")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("344_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1489_tgt
    .local int rx1489_pos
    .local int rx1489_off
    .local int rx1489_eos
    .local int rx1489_rep
    .local pmc rx1489_cur
    .local pmc rx1489_debug
    (rx1489_cur, rx1489_pos, rx1489_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1489_cur
    .local pmc match
    .lex "$/", match
    length rx1489_eos, rx1489_tgt
    gt rx1489_pos, rx1489_eos, rx1489_done
    set rx1489_off, 0
    lt rx1489_pos, 2, rx1489_start
    sub rx1489_off, rx1489_pos, 1
    substr rx1489_tgt, rx1489_tgt, rx1489_off
  rx1489_start:
    eq $I10, 1, rx1489_restart
    if_null rx1489_debug, debug_1057
    rx1489_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1493_done
    goto rxscan1493_scan
  rxscan1493_loop:
    (rx1489_pos) = rx1489_cur."from"()
    inc rx1489_pos
    rx1489_cur."!cursor_from"(rx1489_pos)
    ge rx1489_pos, rx1489_eos, rxscan1493_done
  rxscan1493_scan:
    set_addr $I10, rxscan1493_loop
    rx1489_cur."!mark_push"(0, rx1489_pos, $I10)
  rxscan1493_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1494_fail
    rx1489_cur."!mark_push"(0, rx1489_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1489_pos, 2
    gt $I11, rx1489_eos, rx1489_fail
    sub $I11, rx1489_pos, rx1489_off
    substr $S10, rx1489_tgt, $I11, 2
    ne $S10, "gt", rx1489_fail
    add rx1489_pos, 2
    set_addr $I10, rxcap_1494_fail
    ($I12, $I11) = rx1489_cur."!mark_peek"($I10)
    rx1489_cur."!cursor_pos"($I11)
    ($P10) = rx1489_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1489_pos, "")
    rx1489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1494_done
  rxcap_1494_fail:
    goto rx1489_fail
  rxcap_1494_done:
  # rx subrule "O" subtype=capture negate=
    rx1489_cur."!cursor_pos"(rx1489_pos)
    $P10 = rx1489_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1489_fail
    rx1489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1489_pos = $P10."pos"()
  # rx pass
    rx1489_cur."!cursor_pass"(rx1489_pos, "infix:sym<gt>")
    if_null rx1489_debug, debug_1058
    rx1489_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1489_pos)
  debug_1058:
    .return (rx1489_cur)
  rx1489_restart:
.annotate 'line', 4
    if_null rx1489_debug, debug_1059
    rx1489_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1059:
  rx1489_fail:
    (rx1489_rep, rx1489_pos, $I10, $P10) = rx1489_cur."!mark_fail"(0)
    lt rx1489_pos, -1, rx1489_done
    eq rx1489_pos, -1, rx1489_fail
    jump $I10
  rx1489_done:
    rx1489_cur."!cursor_fail"()
    if_null rx1489_debug, debug_1060
    rx1489_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1060:
    .return (rx1489_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("345_1299465717.405") :method
.annotate 'line', 4
    $P1491 = self."!PREFIX__!subrule"("O", "gt")
    new $P1492, "ResizablePMCArray"
    push $P1492, $P1491
    .return ($P1492)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("346_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1496_tgt
    .local int rx1496_pos
    .local int rx1496_off
    .local int rx1496_eos
    .local int rx1496_rep
    .local pmc rx1496_cur
    .local pmc rx1496_debug
    (rx1496_cur, rx1496_pos, rx1496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1496_cur
    .local pmc match
    .lex "$/", match
    length rx1496_eos, rx1496_tgt
    gt rx1496_pos, rx1496_eos, rx1496_done
    set rx1496_off, 0
    lt rx1496_pos, 2, rx1496_start
    sub rx1496_off, rx1496_pos, 1
    substr rx1496_tgt, rx1496_tgt, rx1496_off
  rx1496_start:
    eq $I10, 1, rx1496_restart
    if_null rx1496_debug, debug_1061
    rx1496_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1500_done
    goto rxscan1500_scan
  rxscan1500_loop:
    (rx1496_pos) = rx1496_cur."from"()
    inc rx1496_pos
    rx1496_cur."!cursor_from"(rx1496_pos)
    ge rx1496_pos, rx1496_eos, rxscan1500_done
  rxscan1500_scan:
    set_addr $I10, rxscan1500_loop
    rx1496_cur."!mark_push"(0, rx1496_pos, $I10)
  rxscan1500_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1501_fail
    rx1496_cur."!mark_push"(0, rx1496_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1496_pos, 3
    gt $I11, rx1496_eos, rx1496_fail
    sub $I11, rx1496_pos, rx1496_off
    substr $S10, rx1496_tgt, $I11, 3
    ne $S10, "=:=", rx1496_fail
    add rx1496_pos, 3
    set_addr $I10, rxcap_1501_fail
    ($I12, $I11) = rx1496_cur."!mark_peek"($I10)
    rx1496_cur."!cursor_pos"($I11)
    ($P10) = rx1496_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1496_pos, "")
    rx1496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1501_done
  rxcap_1501_fail:
    goto rx1496_fail
  rxcap_1501_done:
  # rx subrule "O" subtype=capture negate=
    rx1496_cur."!cursor_pos"(rx1496_pos)
    $P10 = rx1496_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1496_fail
    rx1496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1496_pos = $P10."pos"()
  # rx pass
    rx1496_cur."!cursor_pass"(rx1496_pos, "infix:sym<=:=>")
    if_null rx1496_debug, debug_1062
    rx1496_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1496_pos)
  debug_1062:
    .return (rx1496_cur)
  rx1496_restart:
.annotate 'line', 4
    if_null rx1496_debug, debug_1063
    rx1496_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1063:
  rx1496_fail:
    (rx1496_rep, rx1496_pos, $I10, $P10) = rx1496_cur."!mark_fail"(0)
    lt rx1496_pos, -1, rx1496_done
    eq rx1496_pos, -1, rx1496_fail
    jump $I10
  rx1496_done:
    rx1496_cur."!cursor_fail"()
    if_null rx1496_debug, debug_1064
    rx1496_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1064:
    .return (rx1496_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("347_1299465717.405") :method
.annotate 'line', 4
    $P1498 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1499, "ResizablePMCArray"
    push $P1499, $P1498
    .return ($P1499)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("348_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1503_tgt
    .local int rx1503_pos
    .local int rx1503_off
    .local int rx1503_eos
    .local int rx1503_rep
    .local pmc rx1503_cur
    .local pmc rx1503_debug
    (rx1503_cur, rx1503_pos, rx1503_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1503_cur
    .local pmc match
    .lex "$/", match
    length rx1503_eos, rx1503_tgt
    gt rx1503_pos, rx1503_eos, rx1503_done
    set rx1503_off, 0
    lt rx1503_pos, 2, rx1503_start
    sub rx1503_off, rx1503_pos, 1
    substr rx1503_tgt, rx1503_tgt, rx1503_off
  rx1503_start:
    eq $I10, 1, rx1503_restart
    if_null rx1503_debug, debug_1065
    rx1503_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1503_pos) = rx1503_cur."from"()
    inc rx1503_pos
    rx1503_cur."!cursor_from"(rx1503_pos)
    ge rx1503_pos, rx1503_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxscan1507_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1508_fail
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1503_pos, 2
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    substr $S10, rx1503_tgt, $I11, 2
    ne $S10, "~~", rx1503_fail
    add rx1503_pos, 2
    set_addr $I10, rxcap_1508_fail
    ($I12, $I11) = rx1503_cur."!mark_peek"($I10)
    rx1503_cur."!cursor_pos"($I11)
    ($P10) = rx1503_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1503_pos, "")
    rx1503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1508_done
  rxcap_1508_fail:
    goto rx1503_fail
  rxcap_1508_done:
  # rx subrule "O" subtype=capture negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1503_fail
    rx1503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1503_pos = $P10."pos"()
  # rx pass
    rx1503_cur."!cursor_pass"(rx1503_pos, "infix:sym<~~>")
    if_null rx1503_debug, debug_1066
    rx1503_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1503_pos)
  debug_1066:
    .return (rx1503_cur)
  rx1503_restart:
.annotate 'line', 4
    if_null rx1503_debug, debug_1067
    rx1503_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1067:
  rx1503_fail:
    (rx1503_rep, rx1503_pos, $I10, $P10) = rx1503_cur."!mark_fail"(0)
    lt rx1503_pos, -1, rx1503_done
    eq rx1503_pos, -1, rx1503_fail
    jump $I10
  rx1503_done:
    rx1503_cur."!cursor_fail"()
    if_null rx1503_debug, debug_1068
    rx1503_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1068:
    .return (rx1503_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("349_1299465717.405") :method
.annotate 'line', 4
    $P1505 = self."!PREFIX__!subrule"("O", "~~")
    new $P1506, "ResizablePMCArray"
    push $P1506, $P1505
    .return ($P1506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("350_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1069
    rx1510_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1514_done
    goto rxscan1514_scan
  rxscan1514_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1514_done
  rxscan1514_scan:
    set_addr $I10, rxscan1514_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1514_done:
.annotate 'line', 630
  # rx subcapture "sym"
    set_addr $I10, rxcap_1515_fail
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1510_pos, 2
    gt $I11, rx1510_eos, rx1510_fail
    sub $I11, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I11, 2
    ne $S10, "&&", rx1510_fail
    add rx1510_pos, 2
    set_addr $I10, rxcap_1515_fail
    ($I12, $I11) = rx1510_cur."!mark_peek"($I10)
    rx1510_cur."!cursor_pos"($I11)
    ($P10) = rx1510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1510_pos, "")
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1515_done
  rxcap_1515_fail:
    goto rx1510_fail
  rxcap_1515_done:
  # rx subrule "O" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "infix:sym<&&>")
    if_null rx1510_debug, debug_1070
    rx1510_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1510_pos)
  debug_1070:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 4
    if_null rx1510_debug, debug_1071
    rx1510_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1071:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1072
    rx1510_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1072:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("351_1299465717.405") :method
.annotate 'line', 4
    $P1512 = self."!PREFIX__!subrule"("O", "&&")
    new $P1513, "ResizablePMCArray"
    push $P1513, $P1512
    .return ($P1513)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("352_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1517_tgt
    .local int rx1517_pos
    .local int rx1517_off
    .local int rx1517_eos
    .local int rx1517_rep
    .local pmc rx1517_cur
    .local pmc rx1517_debug
    (rx1517_cur, rx1517_pos, rx1517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1517_cur
    .local pmc match
    .lex "$/", match
    length rx1517_eos, rx1517_tgt
    gt rx1517_pos, rx1517_eos, rx1517_done
    set rx1517_off, 0
    lt rx1517_pos, 2, rx1517_start
    sub rx1517_off, rx1517_pos, 1
    substr rx1517_tgt, rx1517_tgt, rx1517_off
  rx1517_start:
    eq $I10, 1, rx1517_restart
    if_null rx1517_debug, debug_1073
    rx1517_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1521_done
    goto rxscan1521_scan
  rxscan1521_loop:
    (rx1517_pos) = rx1517_cur."from"()
    inc rx1517_pos
    rx1517_cur."!cursor_from"(rx1517_pos)
    ge rx1517_pos, rx1517_eos, rxscan1521_done
  rxscan1521_scan:
    set_addr $I10, rxscan1521_loop
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  rxscan1521_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1522_fail
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  # rx literal  "||"
    add $I11, rx1517_pos, 2
    gt $I11, rx1517_eos, rx1517_fail
    sub $I11, rx1517_pos, rx1517_off
    substr $S10, rx1517_tgt, $I11, 2
    ne $S10, "||", rx1517_fail
    add rx1517_pos, 2
    set_addr $I10, rxcap_1522_fail
    ($I12, $I11) = rx1517_cur."!mark_peek"($I10)
    rx1517_cur."!cursor_pos"($I11)
    ($P10) = rx1517_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1517_pos, "")
    rx1517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1522_done
  rxcap_1522_fail:
    goto rx1517_fail
  rxcap_1522_done:
  # rx subrule "O" subtype=capture negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1517_fail
    rx1517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1517_pos = $P10."pos"()
  # rx pass
    rx1517_cur."!cursor_pass"(rx1517_pos, "infix:sym<||>")
    if_null rx1517_debug, debug_1074
    rx1517_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1517_pos)
  debug_1074:
    .return (rx1517_cur)
  rx1517_restart:
.annotate 'line', 4
    if_null rx1517_debug, debug_1075
    rx1517_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1075:
  rx1517_fail:
    (rx1517_rep, rx1517_pos, $I10, $P10) = rx1517_cur."!mark_fail"(0)
    lt rx1517_pos, -1, rx1517_done
    eq rx1517_pos, -1, rx1517_fail
    jump $I10
  rx1517_done:
    rx1517_cur."!cursor_fail"()
    if_null rx1517_debug, debug_1076
    rx1517_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1076:
    .return (rx1517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("353_1299465717.405") :method
.annotate 'line', 4
    $P1519 = self."!PREFIX__!subrule"("O", "||")
    new $P1520, "ResizablePMCArray"
    push $P1520, $P1519
    .return ($P1520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("354_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1077
    rx1524_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1528_done
    goto rxscan1528_scan
  rxscan1528_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1528_done
  rxscan1528_scan:
    set_addr $I10, rxscan1528_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1528_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1529_fail
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  # rx literal  "//"
    add $I11, rx1524_pos, 2
    gt $I11, rx1524_eos, rx1524_fail
    sub $I11, rx1524_pos, rx1524_off
    substr $S10, rx1524_tgt, $I11, 2
    ne $S10, "//", rx1524_fail
    add rx1524_pos, 2
    set_addr $I10, rxcap_1529_fail
    ($I12, $I11) = rx1524_cur."!mark_peek"($I10)
    rx1524_cur."!cursor_pos"($I11)
    ($P10) = rx1524_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1524_pos, "")
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1529_done
  rxcap_1529_fail:
    goto rx1524_fail
  rxcap_1529_done:
  # rx subrule "O" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, "infix:sym<//>")
    if_null rx1524_debug, debug_1078
    rx1524_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1524_pos)
  debug_1078:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 4
    if_null rx1524_debug, debug_1079
    rx1524_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1079:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1080
    rx1524_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1080:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("355_1299465717.405") :method
.annotate 'line', 4
    $P1526 = self."!PREFIX__!subrule"("O", "//")
    new $P1527, "ResizablePMCArray"
    push $P1527, $P1526
    .return ($P1527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("356_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1531_tgt
    .local int rx1531_pos
    .local int rx1531_off
    .local int rx1531_eos
    .local int rx1531_rep
    .local pmc rx1531_cur
    .local pmc rx1531_debug
    (rx1531_cur, rx1531_pos, rx1531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1531_cur
    .local pmc match
    .lex "$/", match
    length rx1531_eos, rx1531_tgt
    gt rx1531_pos, rx1531_eos, rx1531_done
    set rx1531_off, 0
    lt rx1531_pos, 2, rx1531_start
    sub rx1531_off, rx1531_pos, 1
    substr rx1531_tgt, rx1531_tgt, rx1531_off
  rx1531_start:
    eq $I10, 1, rx1531_restart
    if_null rx1531_debug, debug_1081
    rx1531_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1535_done
    goto rxscan1535_scan
  rxscan1535_loop:
    (rx1531_pos) = rx1531_cur."from"()
    inc rx1531_pos
    rx1531_cur."!cursor_from"(rx1531_pos)
    ge rx1531_pos, rx1531_eos, rxscan1535_done
  rxscan1535_scan:
    set_addr $I10, rxscan1535_loop
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  rxscan1535_done:
.annotate 'line', 636
  # rx literal  "??"
    add $I11, rx1531_pos, 2
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    substr $S10, rx1531_tgt, $I11, 2
    ne $S10, "??", rx1531_fail
    add rx1531_pos, 2
.annotate 'line', 637
  # rx subrule "ws" subtype=method negate=
    rx1531_cur."!cursor_pos"(rx1531_pos)
    $P10 = rx1531_cur."ws"()
    unless $P10, rx1531_fail
    rx1531_pos = $P10."pos"()
.annotate 'line', 638
  # rx subrule "EXPR" subtype=capture negate=
    rx1531_cur."!cursor_pos"(rx1531_pos)
    $P10 = rx1531_cur."EXPR"("i=")
    unless $P10, rx1531_fail
    rx1531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1531_pos = $P10."pos"()
.annotate 'line', 639
  # rx literal  "!!"
    add $I11, rx1531_pos, 2
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    substr $S10, rx1531_tgt, $I11, 2
    ne $S10, "!!", rx1531_fail
    add rx1531_pos, 2
.annotate 'line', 640
  # rx subrule "O" subtype=capture negate=
    rx1531_cur."!cursor_pos"(rx1531_pos)
    $P10 = rx1531_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1531_fail
    rx1531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1531_pos = $P10."pos"()
.annotate 'line', 635
  # rx pass
    rx1531_cur."!cursor_pass"(rx1531_pos, "infix:sym<?? !!>")
    if_null rx1531_debug, debug_1082
    rx1531_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1531_pos)
  debug_1082:
    .return (rx1531_cur)
  rx1531_restart:
.annotate 'line', 4
    if_null rx1531_debug, debug_1083
    rx1531_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1083:
  rx1531_fail:
    (rx1531_rep, rx1531_pos, $I10, $P10) = rx1531_cur."!mark_fail"(0)
    lt rx1531_pos, -1, rx1531_done
    eq rx1531_pos, -1, rx1531_fail
    jump $I10
  rx1531_done:
    rx1531_cur."!cursor_fail"()
    if_null rx1531_debug, debug_1084
    rx1531_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1084:
    .return (rx1531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("357_1299465717.405") :method
.annotate 'line', 4
    $P1533 = self."!PREFIX__!subrule"("ws", "??")
    new $P1534, "ResizablePMCArray"
    push $P1534, $P1533
    .return ($P1534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("358_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1085
    rx1537_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1541_done
    goto rxscan1541_scan
  rxscan1541_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1541_done
  rxscan1541_scan:
    set_addr $I10, rxscan1541_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1541_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1542_fail
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  # rx literal  "="
    add $I11, rx1537_pos, 1
    gt $I11, rx1537_eos, rx1537_fail
    sub $I11, rx1537_pos, rx1537_off
    ord $I11, rx1537_tgt, $I11
    ne $I11, 61, rx1537_fail
    add rx1537_pos, 1
    set_addr $I10, rxcap_1542_fail
    ($I12, $I11) = rx1537_cur."!mark_peek"($I10)
    rx1537_cur."!cursor_pos"($I11)
    ($P10) = rx1537_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1537_pos, "")
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1542_done
  rxcap_1542_fail:
    goto rx1537_fail
  rxcap_1542_done:
  # rx subrule "panic" subtype=method negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1537_fail
    rx1537_pos = $P10."pos"()
.annotate 'line', 643
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "infix:sym<=>")
    if_null rx1537_debug, debug_1086
    rx1537_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1537_pos)
  debug_1086:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 4
    if_null rx1537_debug, debug_1087
    rx1537_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1087:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1088
    rx1537_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1088:
    .return (rx1537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("359_1299465717.405") :method
.annotate 'line', 4
    $P1539 = self."!PREFIX__!subrule"("panic", "=")
    new $P1540, "ResizablePMCArray"
    push $P1540, $P1539
    .return ($P1540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("360_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1544_tgt
    .local int rx1544_pos
    .local int rx1544_off
    .local int rx1544_eos
    .local int rx1544_rep
    .local pmc rx1544_cur
    .local pmc rx1544_debug
    (rx1544_cur, rx1544_pos, rx1544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1544_cur
    .local pmc match
    .lex "$/", match
    length rx1544_eos, rx1544_tgt
    gt rx1544_pos, rx1544_eos, rx1544_done
    set rx1544_off, 0
    lt rx1544_pos, 2, rx1544_start
    sub rx1544_off, rx1544_pos, 1
    substr rx1544_tgt, rx1544_tgt, rx1544_off
  rx1544_start:
    eq $I10, 1, rx1544_restart
    if_null rx1544_debug, debug_1089
    rx1544_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1548_done
    goto rxscan1548_scan
  rxscan1548_loop:
    (rx1544_pos) = rx1544_cur."from"()
    inc rx1544_pos
    rx1544_cur."!cursor_from"(rx1544_pos)
    ge rx1544_pos, rx1544_eos, rxscan1548_done
  rxscan1548_scan:
    set_addr $I10, rxscan1548_loop
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  rxscan1548_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1549_fail
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  # rx literal  ":="
    add $I11, rx1544_pos, 2
    gt $I11, rx1544_eos, rx1544_fail
    sub $I11, rx1544_pos, rx1544_off
    substr $S10, rx1544_tgt, $I11, 2
    ne $S10, ":=", rx1544_fail
    add rx1544_pos, 2
    set_addr $I10, rxcap_1549_fail
    ($I12, $I11) = rx1544_cur."!mark_peek"($I10)
    rx1544_cur."!cursor_pos"($I11)
    ($P10) = rx1544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1544_pos, "")
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1549_done
  rxcap_1549_fail:
    goto rx1544_fail
  rxcap_1549_done:
  # rx subrule "O" subtype=capture negate=
    rx1544_cur."!cursor_pos"(rx1544_pos)
    $P10 = rx1544_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1544_fail
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1544_pos = $P10."pos"()
  # rx pass
    rx1544_cur."!cursor_pass"(rx1544_pos, "infix:sym<:=>")
    if_null rx1544_debug, debug_1090
    rx1544_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1544_pos)
  debug_1090:
    .return (rx1544_cur)
  rx1544_restart:
.annotate 'line', 4
    if_null rx1544_debug, debug_1091
    rx1544_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1091:
  rx1544_fail:
    (rx1544_rep, rx1544_pos, $I10, $P10) = rx1544_cur."!mark_fail"(0)
    lt rx1544_pos, -1, rx1544_done
    eq rx1544_pos, -1, rx1544_fail
    jump $I10
  rx1544_done:
    rx1544_cur."!cursor_fail"()
    if_null rx1544_debug, debug_1092
    rx1544_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1092:
    .return (rx1544_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("361_1299465717.405") :method
.annotate 'line', 4
    $P1546 = self."!PREFIX__!subrule"("O", ":=")
    new $P1547, "ResizablePMCArray"
    push $P1547, $P1546
    .return ($P1547)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("362_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1551_tgt
    .local int rx1551_pos
    .local int rx1551_off
    .local int rx1551_eos
    .local int rx1551_rep
    .local pmc rx1551_cur
    .local pmc rx1551_debug
    (rx1551_cur, rx1551_pos, rx1551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1551_cur
    .local pmc match
    .lex "$/", match
    length rx1551_eos, rx1551_tgt
    gt rx1551_pos, rx1551_eos, rx1551_done
    set rx1551_off, 0
    lt rx1551_pos, 2, rx1551_start
    sub rx1551_off, rx1551_pos, 1
    substr rx1551_tgt, rx1551_tgt, rx1551_off
  rx1551_start:
    eq $I10, 1, rx1551_restart
    if_null rx1551_debug, debug_1093
    rx1551_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1555_done
    goto rxscan1555_scan
  rxscan1555_loop:
    (rx1551_pos) = rx1551_cur."from"()
    inc rx1551_pos
    rx1551_cur."!cursor_from"(rx1551_pos)
    ge rx1551_pos, rx1551_eos, rxscan1555_done
  rxscan1555_scan:
    set_addr $I10, rxscan1555_loop
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  rxscan1555_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1556_fail
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  # rx literal  "::="
    add $I11, rx1551_pos, 3
    gt $I11, rx1551_eos, rx1551_fail
    sub $I11, rx1551_pos, rx1551_off
    substr $S10, rx1551_tgt, $I11, 3
    ne $S10, "::=", rx1551_fail
    add rx1551_pos, 3
    set_addr $I10, rxcap_1556_fail
    ($I12, $I11) = rx1551_cur."!mark_peek"($I10)
    rx1551_cur."!cursor_pos"($I11)
    ($P10) = rx1551_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1551_pos, "")
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1556_done
  rxcap_1556_fail:
    goto rx1551_fail
  rxcap_1556_done:
  # rx subrule "O" subtype=capture negate=
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1551_fail
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1551_pos = $P10."pos"()
  # rx pass
    rx1551_cur."!cursor_pass"(rx1551_pos, "infix:sym<::=>")
    if_null rx1551_debug, debug_1094
    rx1551_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1551_pos)
  debug_1094:
    .return (rx1551_cur)
  rx1551_restart:
.annotate 'line', 4
    if_null rx1551_debug, debug_1095
    rx1551_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1095:
  rx1551_fail:
    (rx1551_rep, rx1551_pos, $I10, $P10) = rx1551_cur."!mark_fail"(0)
    lt rx1551_pos, -1, rx1551_done
    eq rx1551_pos, -1, rx1551_fail
    jump $I10
  rx1551_done:
    rx1551_cur."!cursor_fail"()
    if_null rx1551_debug, debug_1096
    rx1551_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1096:
    .return (rx1551_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("363_1299465717.405") :method
.annotate 'line', 4
    $P1553 = self."!PREFIX__!subrule"("O", "::=")
    new $P1554, "ResizablePMCArray"
    push $P1554, $P1553
    .return ($P1554)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("364_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1558_tgt
    .local int rx1558_pos
    .local int rx1558_off
    .local int rx1558_eos
    .local int rx1558_rep
    .local pmc rx1558_cur
    .local pmc rx1558_debug
    (rx1558_cur, rx1558_pos, rx1558_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1558_cur
    .local pmc match
    .lex "$/", match
    length rx1558_eos, rx1558_tgt
    gt rx1558_pos, rx1558_eos, rx1558_done
    set rx1558_off, 0
    lt rx1558_pos, 2, rx1558_start
    sub rx1558_off, rx1558_pos, 1
    substr rx1558_tgt, rx1558_tgt, rx1558_off
  rx1558_start:
    eq $I10, 1, rx1558_restart
    if_null rx1558_debug, debug_1097
    rx1558_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1558_pos) = rx1558_cur."from"()
    inc rx1558_pos
    rx1558_cur."!cursor_from"(rx1558_pos)
    ge rx1558_pos, rx1558_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1558_cur."!mark_push"(0, rx1558_pos, $I10)
  rxscan1562_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1563_fail
    rx1558_cur."!mark_push"(0, rx1558_pos, $I10)
  # rx literal  ","
    add $I11, rx1558_pos, 1
    gt $I11, rx1558_eos, rx1558_fail
    sub $I11, rx1558_pos, rx1558_off
    ord $I11, rx1558_tgt, $I11
    ne $I11, 44, rx1558_fail
    add rx1558_pos, 1
    set_addr $I10, rxcap_1563_fail
    ($I12, $I11) = rx1558_cur."!mark_peek"($I10)
    rx1558_cur."!cursor_pos"($I11)
    ($P10) = rx1558_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1558_pos, "")
    rx1558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1563_done
  rxcap_1563_fail:
    goto rx1558_fail
  rxcap_1563_done:
  # rx subrule "O" subtype=capture negate=
    rx1558_cur."!cursor_pos"(rx1558_pos)
    $P10 = rx1558_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1558_fail
    rx1558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1558_pos = $P10."pos"()
  # rx pass
    rx1558_cur."!cursor_pass"(rx1558_pos, "infix:sym<,>")
    if_null rx1558_debug, debug_1098
    rx1558_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1558_pos)
  debug_1098:
    .return (rx1558_cur)
  rx1558_restart:
.annotate 'line', 4
    if_null rx1558_debug, debug_1099
    rx1558_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1099:
  rx1558_fail:
    (rx1558_rep, rx1558_pos, $I10, $P10) = rx1558_cur."!mark_fail"(0)
    lt rx1558_pos, -1, rx1558_done
    eq rx1558_pos, -1, rx1558_fail
    jump $I10
  rx1558_done:
    rx1558_cur."!cursor_fail"()
    if_null rx1558_debug, debug_1100
    rx1558_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1100:
    .return (rx1558_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("365_1299465717.405") :method
.annotate 'line', 4
    $P1560 = self."!PREFIX__!subrule"("O", ",")
    new $P1561, "ResizablePMCArray"
    push $P1561, $P1560
    .return ($P1561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("366_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P1573 = "368_1299465717.405" 
    capture_lex $P1573
    .local string rx1565_tgt
    .local int rx1565_pos
    .local int rx1565_off
    .local int rx1565_eos
    .local int rx1565_rep
    .local pmc rx1565_cur
    .local pmc rx1565_debug
    (rx1565_cur, rx1565_pos, rx1565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1565_cur
    .local pmc match
    .lex "$/", match
    length rx1565_eos, rx1565_tgt
    gt rx1565_pos, rx1565_eos, rx1565_done
    set rx1565_off, 0
    lt rx1565_pos, 2, rx1565_start
    sub rx1565_off, rx1565_pos, 1
    substr rx1565_tgt, rx1565_tgt, rx1565_off
  rx1565_start:
    eq $I10, 1, rx1565_restart
    if_null rx1565_debug, debug_1101
    rx1565_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1565_pos) = rx1565_cur."from"()
    inc rx1565_pos
    rx1565_cur."!cursor_from"(rx1565_pos)
    ge rx1565_pos, rx1565_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  rxscan1568_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1569_fail
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  # rx literal  "return"
    add $I11, rx1565_pos, 6
    gt $I11, rx1565_eos, rx1565_fail
    sub $I11, rx1565_pos, rx1565_off
    substr $S10, rx1565_tgt, $I11, 6
    ne $S10, "return", rx1565_fail
    add rx1565_pos, 6
    set_addr $I10, rxcap_1569_fail
    ($I12, $I11) = rx1565_cur."!mark_peek"($I10)
    rx1565_cur."!cursor_pos"($I11)
    ($P10) = rx1565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1565_pos, "")
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1569_done
  rxcap_1569_fail:
    goto rx1565_fail
  rxcap_1569_done:
  # rx charclass s
    ge rx1565_pos, rx1565_eos, rx1565_fail
    sub $I10, rx1565_pos, rx1565_off
    is_cclass $I11, 32, rx1565_tgt, $I10
    unless $I11, rx1565_fail
    inc rx1565_pos
  # rx subrule "O" subtype=capture negate=
    rx1565_cur."!cursor_pos"(rx1565_pos)
    $P10 = rx1565_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1565_fail
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1565_pos = $P10."pos"()
    rx1565_cur."!cursor_pos"(rx1565_pos)
    find_lex $P1570, unicode:"$\x{a2}"
    $P1571 = $P1570."MATCH"()
    store_lex "$/", $P1571
    .const 'Sub' $P1573 = "368_1299465717.405" 
    capture_lex $P1573
    $P1575 = $P1573()
  # rx pass
    rx1565_cur."!cursor_pass"(rx1565_pos, "prefix:sym<return>")
    if_null rx1565_debug, debug_1102
    rx1565_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1565_pos)
  debug_1102:
    .return (rx1565_cur)
  rx1565_restart:
.annotate 'line', 4
    if_null rx1565_debug, debug_1103
    rx1565_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1103:
  rx1565_fail:
    (rx1565_rep, rx1565_pos, $I10, $P10) = rx1565_cur."!mark_fail"(0)
    lt rx1565_pos, -1, rx1565_done
    eq rx1565_pos, -1, rx1565_fail
    jump $I10
  rx1565_done:
    rx1565_cur."!cursor_fail"()
    if_null rx1565_debug, debug_1104
    rx1565_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1104:
    .return (rx1565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("367_1299465717.405") :method
.annotate 'line', 4
    new $P1567, "ResizablePMCArray"
    push $P1567, "return"
    .return ($P1567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1572"  :anon :subid("368_1299465717.405") :outer("366_1299465717.405")
.annotate 'line', 651
    new $P1574, "Integer"
    assign $P1574, 1
    store_dynamic_lex "$*RETURN_USED", $P1574
    .return ($P1574)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("369_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1105
    rx1577_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1580_done
    goto rxscan1580_scan
  rxscan1580_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1580_done
  rxscan1580_scan:
    set_addr $I10, rxscan1580_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1580_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1581_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "make"
    add $I11, rx1577_pos, 4
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 4
    ne $S10, "make", rx1577_fail
    add rx1577_pos, 4
    set_addr $I10, rxcap_1581_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1581_done
  rxcap_1581_fail:
    goto rx1577_fail
  rxcap_1581_done:
  # rx charclass s
    ge rx1577_pos, rx1577_eos, rx1577_fail
    sub $I10, rx1577_pos, rx1577_off
    is_cclass $I11, 32, rx1577_tgt, $I10
    unless $I11, rx1577_fail
    inc rx1577_pos
  # rx subrule "O" subtype=capture negate=
    rx1577_cur."!cursor_pos"(rx1577_pos)
    $P10 = rx1577_cur."O"("%list_prefix")
    unless $P10, rx1577_fail
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1577_pos = $P10."pos"()
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "prefix:sym<make>")
    if_null rx1577_debug, debug_1106
    rx1577_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1577_pos)
  debug_1106:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 4
    if_null rx1577_debug, debug_1107
    rx1577_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1107:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1108
    rx1577_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1108:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("370_1299465717.405") :method
.annotate 'line', 4
    new $P1579, "ResizablePMCArray"
    push $P1579, "make"
    .return ($P1579)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("371_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1583_tgt
    .local int rx1583_pos
    .local int rx1583_off
    .local int rx1583_eos
    .local int rx1583_rep
    .local pmc rx1583_cur
    .local pmc rx1583_debug
    (rx1583_cur, rx1583_pos, rx1583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1583_cur
    .local pmc match
    .lex "$/", match
    length rx1583_eos, rx1583_tgt
    gt rx1583_pos, rx1583_eos, rx1583_done
    set rx1583_off, 0
    lt rx1583_pos, 2, rx1583_start
    sub rx1583_off, rx1583_pos, 1
    substr rx1583_tgt, rx1583_tgt, rx1583_off
  rx1583_start:
    eq $I10, 1, rx1583_restart
    if_null rx1583_debug, debug_1109
    rx1583_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1583_pos) = rx1583_cur."from"()
    inc rx1583_pos
    rx1583_cur."!cursor_from"(rx1583_pos)
    ge rx1583_pos, rx1583_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  rxscan1586_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1587_fail
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  # rx literal  "last"
    add $I11, rx1583_pos, 4
    gt $I11, rx1583_eos, rx1583_fail
    sub $I11, rx1583_pos, rx1583_off
    substr $S10, rx1583_tgt, $I11, 4
    ne $S10, "last", rx1583_fail
    add rx1583_pos, 4
    set_addr $I10, rxcap_1587_fail
    ($I12, $I11) = rx1583_cur."!mark_peek"($I10)
    rx1583_cur."!cursor_pos"($I11)
    ($P10) = rx1583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1583_pos, "")
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1587_done
  rxcap_1587_fail:
    goto rx1583_fail
  rxcap_1587_done:
  # rx pass
    rx1583_cur."!cursor_pass"(rx1583_pos, "term:sym<last>")
    if_null rx1583_debug, debug_1110
    rx1583_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1583_pos)
  debug_1110:
    .return (rx1583_cur)
  rx1583_restart:
.annotate 'line', 4
    if_null rx1583_debug, debug_1111
    rx1583_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1111:
  rx1583_fail:
    (rx1583_rep, rx1583_pos, $I10, $P10) = rx1583_cur."!mark_fail"(0)
    lt rx1583_pos, -1, rx1583_done
    eq rx1583_pos, -1, rx1583_fail
    jump $I10
  rx1583_done:
    rx1583_cur."!cursor_fail"()
    if_null rx1583_debug, debug_1112
    rx1583_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1112:
    .return (rx1583_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("372_1299465717.405") :method
.annotate 'line', 4
    new $P1585, "ResizablePMCArray"
    push $P1585, "last"
    .return ($P1585)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("373_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1589_tgt
    .local int rx1589_pos
    .local int rx1589_off
    .local int rx1589_eos
    .local int rx1589_rep
    .local pmc rx1589_cur
    .local pmc rx1589_debug
    (rx1589_cur, rx1589_pos, rx1589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1589_cur
    .local pmc match
    .lex "$/", match
    length rx1589_eos, rx1589_tgt
    gt rx1589_pos, rx1589_eos, rx1589_done
    set rx1589_off, 0
    lt rx1589_pos, 2, rx1589_start
    sub rx1589_off, rx1589_pos, 1
    substr rx1589_tgt, rx1589_tgt, rx1589_off
  rx1589_start:
    eq $I10, 1, rx1589_restart
    if_null rx1589_debug, debug_1113
    rx1589_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    (rx1589_pos) = rx1589_cur."from"()
    inc rx1589_pos
    rx1589_cur."!cursor_from"(rx1589_pos)
    ge rx1589_pos, rx1589_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  rxscan1592_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1593_fail
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  # rx literal  "next"
    add $I11, rx1589_pos, 4
    gt $I11, rx1589_eos, rx1589_fail
    sub $I11, rx1589_pos, rx1589_off
    substr $S10, rx1589_tgt, $I11, 4
    ne $S10, "next", rx1589_fail
    add rx1589_pos, 4
    set_addr $I10, rxcap_1593_fail
    ($I12, $I11) = rx1589_cur."!mark_peek"($I10)
    rx1589_cur."!cursor_pos"($I11)
    ($P10) = rx1589_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1589_pos, "")
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1593_done
  rxcap_1593_fail:
    goto rx1589_fail
  rxcap_1593_done:
  # rx pass
    rx1589_cur."!cursor_pass"(rx1589_pos, "term:sym<next>")
    if_null rx1589_debug, debug_1114
    rx1589_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1589_pos)
  debug_1114:
    .return (rx1589_cur)
  rx1589_restart:
.annotate 'line', 4
    if_null rx1589_debug, debug_1115
    rx1589_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1115:
  rx1589_fail:
    (rx1589_rep, rx1589_pos, $I10, $P10) = rx1589_cur."!mark_fail"(0)
    lt rx1589_pos, -1, rx1589_done
    eq rx1589_pos, -1, rx1589_fail
    jump $I10
  rx1589_done:
    rx1589_cur."!cursor_fail"()
    if_null rx1589_debug, debug_1116
    rx1589_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1116:
    .return (rx1589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("374_1299465717.405") :method
.annotate 'line', 4
    new $P1591, "ResizablePMCArray"
    push $P1591, "next"
    .return ($P1591)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("375_1299465717.405") :method :outer("11_1299465717.405")
.annotate 'line', 4
    .local string rx1595_tgt
    .local int rx1595_pos
    .local int rx1595_off
    .local int rx1595_eos
    .local int rx1595_rep
    .local pmc rx1595_cur
    .local pmc rx1595_debug
    (rx1595_cur, rx1595_pos, rx1595_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1595_cur
    .local pmc match
    .lex "$/", match
    length rx1595_eos, rx1595_tgt
    gt rx1595_pos, rx1595_eos, rx1595_done
    set rx1595_off, 0
    lt rx1595_pos, 2, rx1595_start
    sub rx1595_off, rx1595_pos, 1
    substr rx1595_tgt, rx1595_tgt, rx1595_off
  rx1595_start:
    eq $I10, 1, rx1595_restart
    if_null rx1595_debug, debug_1117
    rx1595_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1598_done
    goto rxscan1598_scan
  rxscan1598_loop:
    (rx1595_pos) = rx1595_cur."from"()
    inc rx1595_pos
    rx1595_cur."!cursor_from"(rx1595_pos)
    ge rx1595_pos, rx1595_eos, rxscan1598_done
  rxscan1598_scan:
    set_addr $I10, rxscan1598_loop
    rx1595_cur."!mark_push"(0, rx1595_pos, $I10)
  rxscan1598_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1599_fail
    rx1595_cur."!mark_push"(0, rx1595_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1595_pos, 4
    gt $I11, rx1595_eos, rx1595_fail
    sub $I11, rx1595_pos, rx1595_off
    substr $S10, rx1595_tgt, $I11, 4
    ne $S10, "redo", rx1595_fail
    add rx1595_pos, 4
    set_addr $I10, rxcap_1599_fail
    ($I12, $I11) = rx1595_cur."!mark_peek"($I10)
    rx1595_cur."!cursor_pos"($I11)
    ($P10) = rx1595_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1595_pos, "")
    rx1595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1599_done
  rxcap_1599_fail:
    goto rx1595_fail
  rxcap_1599_done:
  # rx pass
    rx1595_cur."!cursor_pass"(rx1595_pos, "term:sym<redo>")
    if_null rx1595_debug, debug_1118
    rx1595_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1595_pos)
  debug_1118:
    .return (rx1595_cur)
  rx1595_restart:
.annotate 'line', 4
    if_null rx1595_debug, debug_1119
    rx1595_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1119:
  rx1595_fail:
    (rx1595_rep, rx1595_pos, $I10, $P10) = rx1595_cur."!mark_fail"(0)
    lt rx1595_pos, -1, rx1595_done
    eq rx1595_pos, -1, rx1595_fail
    jump $I10
  rx1595_done:
    rx1595_cur."!cursor_fail"()
    if_null rx1595_debug, debug_1120
    rx1595_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1120:
    .return (rx1595_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("376_1299465717.405") :method
.annotate 'line', 4
    new $P1597, "ResizablePMCArray"
    push $P1597, "redo"
    .return ($P1597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("377_1299465717.405") :outer("11_1299465717.405")
    .param pmc param_1601
    .param pmc param_1602
.annotate 'line', 657
    .lex "self", param_1601
    .lex "$/", param_1602
.annotate 'line', 659
    new $P1603, "Undef"
    .lex "$t", $P1603
    find_lex $P1604, "$/"
    unless_null $P1604, vivify_1121
    $P1604 = root_new ['parrot';'ResizablePMCArray']
  vivify_1121:
    set $P1605, $P1604[0]
    unless_null $P1605, vivify_1122
    new $P1605, "Undef"
  vivify_1122:
    store_lex "$t", $P1605
    find_lex $P1606, "$/"
    unless_null $P1606, vivify_1123
    $P1606 = root_new ['parrot';'ResizablePMCArray']
  vivify_1123:
    set $P1607, $P1606[1]
    unless_null $P1607, vivify_1124
    new $P1607, "Undef"
  vivify_1124:
    find_lex $P1608, "$/"
    unless_null $P1608, vivify_1125
    $P1608 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1608
  vivify_1125:
    set $P1608[0], $P1607
    find_lex $P1609, "$t"
    find_lex $P1610, "$/"
    unless_null $P1610, vivify_1126
    $P1610 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1610
  vivify_1126:
    set $P1610[1], $P1609
.annotate 'line', 657
    .return ($P1609)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1611"  :subid("378_1299465717.405") :outer("11_1299465717.405")
.annotate 'line', 663
    .const 'Sub' $P1676 = "399_1299465717.405" 
    capture_lex $P1676
    .const 'Sub' $P1669 = "397_1299465717.405" 
    capture_lex $P1669
    .const 'Sub' $P1664 = "395_1299465717.405" 
    capture_lex $P1664
    .const 'Sub' $P1652 = "392_1299465717.405" 
    capture_lex $P1652
    .const 'Sub' $P1642 = "389_1299465717.405" 
    capture_lex $P1642
    .const 'Sub' $P1637 = "387_1299465717.405" 
    capture_lex $P1637
    .const 'Sub' $P1628 = "384_1299465717.405" 
    capture_lex $P1628
    .const 'Sub' $P1623 = "382_1299465717.405" 
    capture_lex $P1623
    .const 'Sub' $P1614 = "379_1299465717.405" 
    capture_lex $P1614
    get_global $P1613, "$?CLASS"
    .const 'Sub' $P1669 = "397_1299465717.405" 
    capture_lex $P1669
    .return ($P1669)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1127") :outer("378_1299465717.405")
.annotate 'line', 663
    get_hll_global $P1612, ["NQP";"Regex"], "_block1611" 
    .local pmc block
    set block, $P1612
    .const 'Sub' $P1676 = "399_1299465717.405" 
    capture_lex $P1676
    $P1676()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1675"  :anon :subid("399_1299465717.405") :outer("378_1299465717.405")
.annotate 'line', 663
    get_hll_global $P1677, "NQPClassHOW"
    $P1678 = $P1677."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1678
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1679, type_obj
    .const 'Sub' $P1680 = "379_1299465717.405" 
    $P1679."add_method"(type_obj, "metachar:sym<:my>", $P1680)
    get_how $P1681, type_obj
    get_global $P1682, "!PREFIX__metachar:sym<:my>"
    $P1681."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1682)
    get_how $P1683, type_obj
    .const 'Sub' $P1684 = "382_1299465717.405" 
    $P1683."add_method"(type_obj, "metachar:sym<{ }>", $P1684)
    get_how $P1685, type_obj
    get_global $P1686, "!PREFIX__metachar:sym<{ }>"
    $P1685."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1686)
    get_how $P1687, type_obj
    .const 'Sub' $P1688 = "384_1299465717.405" 
    $P1687."add_method"(type_obj, "metachar:sym<nqpvar>", $P1688)
    get_how $P1689, type_obj
    get_global $P1690, "!PREFIX__metachar:sym<nqpvar>"
    $P1689."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1690)
    get_how $P1691, type_obj
    .const 'Sub' $P1692 = "387_1299465717.405" 
    $P1691."add_method"(type_obj, "assertion:sym<{ }>", $P1692)
    get_how $P1693, type_obj
    get_global $P1694, "!PREFIX__assertion:sym<{ }>"
    $P1693."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1694)
    get_how $P1695, type_obj
    .const 'Sub' $P1696 = "389_1299465717.405" 
    $P1695."add_method"(type_obj, "assertion:sym<?{ }>", $P1696)
    get_how $P1697, type_obj
    get_global $P1698, "!PREFIX__assertion:sym<?{ }>"
    $P1697."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1698)
    get_how $P1699, type_obj
    .const 'Sub' $P1700 = "392_1299465717.405" 
    $P1699."add_method"(type_obj, "assertion:sym<name>", $P1700)
    get_how $P1701, type_obj
    get_global $P1702, "!PREFIX__assertion:sym<name>"
    $P1701."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1702)
    get_how $P1703, type_obj
    .const 'Sub' $P1704 = "395_1299465717.405" 
    $P1703."add_method"(type_obj, "assertion:sym<var>", $P1704)
    get_how $P1705, type_obj
    get_global $P1706, "!PREFIX__assertion:sym<var>"
    $P1705."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1706)
    get_how $P1707, type_obj
    .const 'Sub' $P1708 = "397_1299465717.405" 
    $P1707."add_method"(type_obj, "codeblock", $P1708)
    get_how $P1709, type_obj
    get_global $P1710, "!PREFIX__codeblock"
    $P1709."add_method"(type_obj, "!PREFIX__codeblock", $P1710)
    get_how $P1711, type_obj
    get_hll_global $P1712, ["Regex";"P6Regex"], "Grammar"
    $P1711."add_parent"(type_obj, $P1712)
    get_how $P1713, type_obj
    $P1714 = $P1713."compose"(type_obj)
    .return ($P1714)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("379_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .const 'Sub' $P1620 = "381_1299465717.405" 
    capture_lex $P1620
    .local string rx1615_tgt
    .local int rx1615_pos
    .local int rx1615_off
    .local int rx1615_eos
    .local int rx1615_rep
    .local pmc rx1615_cur
    .local pmc rx1615_debug
    (rx1615_cur, rx1615_pos, rx1615_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1615_cur
    .local pmc match
    .lex "$/", match
    length rx1615_eos, rx1615_tgt
    gt rx1615_pos, rx1615_eos, rx1615_done
    set rx1615_off, 0
    lt rx1615_pos, 2, rx1615_start
    sub rx1615_off, rx1615_pos, 1
    substr rx1615_tgt, rx1615_tgt, rx1615_off
  rx1615_start:
    eq $I10, 1, rx1615_restart
    if_null rx1615_debug, debug_1128
    rx1615_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1618_done
    goto rxscan1618_scan
  rxscan1618_loop:
    (rx1615_pos) = rx1615_cur."from"()
    inc rx1615_pos
    rx1615_cur."!cursor_from"(rx1615_pos)
    ge rx1615_pos, rx1615_eos, rxscan1618_done
  rxscan1618_scan:
    set_addr $I10, rxscan1618_loop
    rx1615_cur."!mark_push"(0, rx1615_pos, $I10)
  rxscan1618_done:
.annotate 'line', 665
  # rx literal  ":"
    add $I11, rx1615_pos, 1
    gt $I11, rx1615_eos, rx1615_fail
    sub $I11, rx1615_pos, rx1615_off
    ord $I11, rx1615_tgt, $I11
    ne $I11, 58, rx1615_fail
    add rx1615_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1615_cur."!cursor_pos"(rx1615_pos)
    .const 'Sub' $P1620 = "381_1299465717.405" 
    capture_lex $P1620
    $P10 = rx1615_cur."before"($P1620)
    unless $P10, rx1615_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1615_cur."!cursor_pos"(rx1615_pos)
    $P10 = rx1615_cur."LANG"("MAIN", "statement")
    unless $P10, rx1615_fail
    rx1615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1615_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1615_cur."!cursor_pos"(rx1615_pos)
    $P10 = rx1615_cur."ws"()
    unless $P10, rx1615_fail
    rx1615_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1615_pos, 1
    gt $I11, rx1615_eos, rx1615_fail
    sub $I11, rx1615_pos, rx1615_off
    ord $I11, rx1615_tgt, $I11
    ne $I11, 59, rx1615_fail
    add rx1615_pos, 1
.annotate 'line', 664
  # rx pass
    rx1615_cur."!cursor_pass"(rx1615_pos, "metachar:sym<:my>")
    if_null rx1615_debug, debug_1133
    rx1615_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1615_pos)
  debug_1133:
    .return (rx1615_cur)
  rx1615_restart:
.annotate 'line', 663
    if_null rx1615_debug, debug_1134
    rx1615_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1134:
  rx1615_fail:
    (rx1615_rep, rx1615_pos, $I10, $P10) = rx1615_cur."!mark_fail"(0)
    lt rx1615_pos, -1, rx1615_done
    eq rx1615_pos, -1, rx1615_fail
    jump $I10
  rx1615_done:
    rx1615_cur."!cursor_fail"()
    if_null rx1615_debug, debug_1135
    rx1615_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1135:
    .return (rx1615_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("380_1299465717.405") :method
.annotate 'line', 663
    new $P1617, "ResizablePMCArray"
    push $P1617, ":"
    .return ($P1617)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1619"  :anon :subid("381_1299465717.405") :method :outer("379_1299465717.405")
.annotate 'line', 665
    .local string rx1621_tgt
    .local int rx1621_pos
    .local int rx1621_off
    .local int rx1621_eos
    .local int rx1621_rep
    .local pmc rx1621_cur
    .local pmc rx1621_debug
    (rx1621_cur, rx1621_pos, rx1621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1621_cur
    .local pmc match
    .lex "$/", match
    length rx1621_eos, rx1621_tgt
    gt rx1621_pos, rx1621_eos, rx1621_done
    set rx1621_off, 0
    lt rx1621_pos, 2, rx1621_start
    sub rx1621_off, rx1621_pos, 1
    substr rx1621_tgt, rx1621_tgt, rx1621_off
  rx1621_start:
    eq $I10, 1, rx1621_restart
    if_null rx1621_debug, debug_1129
    rx1621_cur."!cursor_debug"("START", "")
  debug_1129:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1621_pos) = rx1621_cur."from"()
    inc rx1621_pos
    rx1621_cur."!cursor_from"(rx1621_pos)
    ge rx1621_pos, rx1621_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1621_cur."!mark_push"(0, rx1621_pos, $I10)
  rxscan1622_done:
  # rx literal  "my"
    add $I11, rx1621_pos, 2
    gt $I11, rx1621_eos, rx1621_fail
    sub $I11, rx1621_pos, rx1621_off
    substr $S10, rx1621_tgt, $I11, 2
    ne $S10, "my", rx1621_fail
    add rx1621_pos, 2
  # rx pass
    rx1621_cur."!cursor_pass"(rx1621_pos, "")
    if_null rx1621_debug, debug_1130
    rx1621_cur."!cursor_debug"("PASS", "", " at pos=", rx1621_pos)
  debug_1130:
    .return (rx1621_cur)
  rx1621_restart:
    if_null rx1621_debug, debug_1131
    rx1621_cur."!cursor_debug"("NEXT", "")
  debug_1131:
  rx1621_fail:
    (rx1621_rep, rx1621_pos, $I10, $P10) = rx1621_cur."!mark_fail"(0)
    lt rx1621_pos, -1, rx1621_done
    eq rx1621_pos, -1, rx1621_fail
    jump $I10
  rx1621_done:
    rx1621_cur."!cursor_fail"()
    if_null rx1621_debug, debug_1132
    rx1621_cur."!cursor_debug"("FAIL", "")
  debug_1132:
    .return (rx1621_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("382_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1136
    rx1624_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1627_done:
.annotate 'line', 669
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1624_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."codeblock"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1624_pos = $P10."pos"()
.annotate 'line', 668
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "metachar:sym<{ }>")
    if_null rx1624_debug, debug_1137
    rx1624_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1624_pos)
  debug_1137:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 663
    if_null rx1624_debug, debug_1138
    rx1624_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1138:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1139
    rx1624_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1139:
    .return (rx1624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("383_1299465717.405") :method
.annotate 'line', 663
    new $P1626, "ResizablePMCArray"
    push $P1626, "{"
    .return ($P1626)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("384_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .const 'Sub' $P1634 = "386_1299465717.405" 
    capture_lex $P1634
    .local string rx1629_tgt
    .local int rx1629_pos
    .local int rx1629_off
    .local int rx1629_eos
    .local int rx1629_rep
    .local pmc rx1629_cur
    .local pmc rx1629_debug
    (rx1629_cur, rx1629_pos, rx1629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1629_cur
    .local pmc match
    .lex "$/", match
    length rx1629_eos, rx1629_tgt
    gt rx1629_pos, rx1629_eos, rx1629_done
    set rx1629_off, 0
    lt rx1629_pos, 2, rx1629_start
    sub rx1629_off, rx1629_pos, 1
    substr rx1629_tgt, rx1629_tgt, rx1629_off
  rx1629_start:
    eq $I10, 1, rx1629_restart
    if_null rx1629_debug, debug_1140
    rx1629_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1632_done
    goto rxscan1632_scan
  rxscan1632_loop:
    (rx1629_pos) = rx1629_cur."from"()
    inc rx1629_pos
    rx1629_cur."!cursor_from"(rx1629_pos)
    ge rx1629_pos, rx1629_eos, rxscan1632_done
  rxscan1632_scan:
    set_addr $I10, rxscan1632_loop
    rx1629_cur."!mark_push"(0, rx1629_pos, $I10)
  rxscan1632_done:
.annotate 'line', 673
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1629_pos, rx1629_off
    substr $S10, rx1629_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1629_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1629_cur."!cursor_pos"(rx1629_pos)
    .const 'Sub' $P1634 = "386_1299465717.405" 
    capture_lex $P1634
    $P10 = rx1629_cur."before"($P1634)
    unless $P10, rx1629_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1629_cur."!cursor_pos"(rx1629_pos)
    $P10 = rx1629_cur."LANG"("MAIN", "variable")
    unless $P10, rx1629_fail
    rx1629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1629_pos = $P10."pos"()
.annotate 'line', 672
  # rx pass
    rx1629_cur."!cursor_pass"(rx1629_pos, "metachar:sym<nqpvar>")
    if_null rx1629_debug, debug_1145
    rx1629_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1629_pos)
  debug_1145:
    .return (rx1629_cur)
  rx1629_restart:
.annotate 'line', 663
    if_null rx1629_debug, debug_1146
    rx1629_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1146:
  rx1629_fail:
    (rx1629_rep, rx1629_pos, $I10, $P10) = rx1629_cur."!mark_fail"(0)
    lt rx1629_pos, -1, rx1629_done
    eq rx1629_pos, -1, rx1629_fail
    jump $I10
  rx1629_done:
    rx1629_cur."!cursor_fail"()
    if_null rx1629_debug, debug_1147
    rx1629_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1147:
    .return (rx1629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("385_1299465717.405") :method
.annotate 'line', 663
    new $P1631, "ResizablePMCArray"
    push $P1631, "$"
    push $P1631, "@"
    .return ($P1631)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1633"  :anon :subid("386_1299465717.405") :method :outer("384_1299465717.405")
.annotate 'line', 673
    .local string rx1635_tgt
    .local int rx1635_pos
    .local int rx1635_off
    .local int rx1635_eos
    .local int rx1635_rep
    .local pmc rx1635_cur
    .local pmc rx1635_debug
    (rx1635_cur, rx1635_pos, rx1635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1635_cur
    .local pmc match
    .lex "$/", match
    length rx1635_eos, rx1635_tgt
    gt rx1635_pos, rx1635_eos, rx1635_done
    set rx1635_off, 0
    lt rx1635_pos, 2, rx1635_start
    sub rx1635_off, rx1635_pos, 1
    substr rx1635_tgt, rx1635_tgt, rx1635_off
  rx1635_start:
    eq $I10, 1, rx1635_restart
    if_null rx1635_debug, debug_1141
    rx1635_cur."!cursor_debug"("START", "")
  debug_1141:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1635_pos) = rx1635_cur."from"()
    inc rx1635_pos
    rx1635_cur."!cursor_from"(rx1635_pos)
    ge rx1635_pos, rx1635_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxscan1636_done:
  # rx charclass .
    ge rx1635_pos, rx1635_eos, rx1635_fail
    inc rx1635_pos
  # rx charclass w
    ge rx1635_pos, rx1635_eos, rx1635_fail
    sub $I10, rx1635_pos, rx1635_off
    is_cclass $I11, 8192, rx1635_tgt, $I10
    unless $I11, rx1635_fail
    inc rx1635_pos
  # rx pass
    rx1635_cur."!cursor_pass"(rx1635_pos, "")
    if_null rx1635_debug, debug_1142
    rx1635_cur."!cursor_debug"("PASS", "", " at pos=", rx1635_pos)
  debug_1142:
    .return (rx1635_cur)
  rx1635_restart:
    if_null rx1635_debug, debug_1143
    rx1635_cur."!cursor_debug"("NEXT", "")
  debug_1143:
  rx1635_fail:
    (rx1635_rep, rx1635_pos, $I10, $P10) = rx1635_cur."!mark_fail"(0)
    lt rx1635_pos, -1, rx1635_done
    eq rx1635_pos, -1, rx1635_fail
    jump $I10
  rx1635_done:
    rx1635_cur."!cursor_fail"()
    if_null rx1635_debug, debug_1144
    rx1635_cur."!cursor_debug"("FAIL", "")
  debug_1144:
    .return (rx1635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("387_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .local string rx1638_tgt
    .local int rx1638_pos
    .local int rx1638_off
    .local int rx1638_eos
    .local int rx1638_rep
    .local pmc rx1638_cur
    .local pmc rx1638_debug
    (rx1638_cur, rx1638_pos, rx1638_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1638_cur
    .local pmc match
    .lex "$/", match
    length rx1638_eos, rx1638_tgt
    gt rx1638_pos, rx1638_eos, rx1638_done
    set rx1638_off, 0
    lt rx1638_pos, 2, rx1638_start
    sub rx1638_off, rx1638_pos, 1
    substr rx1638_tgt, rx1638_tgt, rx1638_off
  rx1638_start:
    eq $I10, 1, rx1638_restart
    if_null rx1638_debug, debug_1148
    rx1638_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1641_done
    goto rxscan1641_scan
  rxscan1641_loop:
    (rx1638_pos) = rx1638_cur."from"()
    inc rx1638_pos
    rx1638_cur."!cursor_from"(rx1638_pos)
    ge rx1638_pos, rx1638_eos, rxscan1641_done
  rxscan1641_scan:
    set_addr $I10, rxscan1641_loop
    rx1638_cur."!mark_push"(0, rx1638_pos, $I10)
  rxscan1641_done:
.annotate 'line', 677
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1638_pos, rx1638_off
    substr $S10, rx1638_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1638_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1638_cur."!cursor_pos"(rx1638_pos)
    $P10 = rx1638_cur."codeblock"()
    unless $P10, rx1638_fail
    rx1638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1638_pos = $P10."pos"()
.annotate 'line', 676
  # rx pass
    rx1638_cur."!cursor_pass"(rx1638_pos, "assertion:sym<{ }>")
    if_null rx1638_debug, debug_1149
    rx1638_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1638_pos)
  debug_1149:
    .return (rx1638_cur)
  rx1638_restart:
.annotate 'line', 663
    if_null rx1638_debug, debug_1150
    rx1638_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1150:
  rx1638_fail:
    (rx1638_rep, rx1638_pos, $I10, $P10) = rx1638_cur."!mark_fail"(0)
    lt rx1638_pos, -1, rx1638_done
    eq rx1638_pos, -1, rx1638_fail
    jump $I10
  rx1638_done:
    rx1638_cur."!cursor_fail"()
    if_null rx1638_debug, debug_1151
    rx1638_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1151:
    .return (rx1638_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("388_1299465717.405") :method
.annotate 'line', 663
    new $P1640, "ResizablePMCArray"
    push $P1640, "{"
    .return ($P1640)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("389_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .const 'Sub' $P1648 = "391_1299465717.405" 
    capture_lex $P1648
    .local string rx1643_tgt
    .local int rx1643_pos
    .local int rx1643_off
    .local int rx1643_eos
    .local int rx1643_rep
    .local pmc rx1643_cur
    .local pmc rx1643_debug
    (rx1643_cur, rx1643_pos, rx1643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1643_cur
    .local pmc match
    .lex "$/", match
    length rx1643_eos, rx1643_tgt
    gt rx1643_pos, rx1643_eos, rx1643_done
    set rx1643_off, 0
    lt rx1643_pos, 2, rx1643_start
    sub rx1643_off, rx1643_pos, 1
    substr rx1643_tgt, rx1643_tgt, rx1643_off
  rx1643_start:
    eq $I10, 1, rx1643_restart
    if_null rx1643_debug, debug_1152
    rx1643_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1646_done
    goto rxscan1646_scan
  rxscan1646_loop:
    (rx1643_pos) = rx1643_cur."from"()
    inc rx1643_pos
    rx1643_cur."!cursor_from"(rx1643_pos)
    ge rx1643_pos, rx1643_eos, rxscan1646_done
  rxscan1646_scan:
    set_addr $I10, rxscan1646_loop
    rx1643_cur."!mark_push"(0, rx1643_pos, $I10)
  rxscan1646_done:
.annotate 'line', 681
  # rx subcapture "zw"
    set_addr $I10, rxcap_1651_fail
    rx1643_cur."!mark_push"(0, rx1643_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1643_pos, rx1643_eos, rx1643_fail
    sub $I10, rx1643_pos, rx1643_off
    substr $S10, rx1643_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1643_fail
    inc rx1643_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1643_cur."!cursor_pos"(rx1643_pos)
    .const 'Sub' $P1648 = "391_1299465717.405" 
    capture_lex $P1648
    $P10 = rx1643_cur."before"($P1648)
    unless $P10, rx1643_fail
    set_addr $I10, rxcap_1651_fail
    ($I12, $I11) = rx1643_cur."!mark_peek"($I10)
    rx1643_cur."!cursor_pos"($I11)
    ($P10) = rx1643_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1643_pos, "")
    rx1643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1651_done
  rxcap_1651_fail:
    goto rx1643_fail
  rxcap_1651_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1643_cur."!cursor_pos"(rx1643_pos)
    $P10 = rx1643_cur."codeblock"()
    unless $P10, rx1643_fail
    rx1643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1643_pos = $P10."pos"()
.annotate 'line', 680
  # rx pass
    rx1643_cur."!cursor_pass"(rx1643_pos, "assertion:sym<?{ }>")
    if_null rx1643_debug, debug_1157
    rx1643_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1643_pos)
  debug_1157:
    .return (rx1643_cur)
  rx1643_restart:
.annotate 'line', 663
    if_null rx1643_debug, debug_1158
    rx1643_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1158:
  rx1643_fail:
    (rx1643_rep, rx1643_pos, $I10, $P10) = rx1643_cur."!mark_fail"(0)
    lt rx1643_pos, -1, rx1643_done
    eq rx1643_pos, -1, rx1643_fail
    jump $I10
  rx1643_done:
    rx1643_cur."!cursor_fail"()
    if_null rx1643_debug, debug_1159
    rx1643_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1159:
    .return (rx1643_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("390_1299465717.405") :method
.annotate 'line', 663
    new $P1645, "ResizablePMCArray"
    push $P1645, "!"
    push $P1645, "?"
    .return ($P1645)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1647"  :anon :subid("391_1299465717.405") :method :outer("389_1299465717.405")
.annotate 'line', 681
    .local string rx1649_tgt
    .local int rx1649_pos
    .local int rx1649_off
    .local int rx1649_eos
    .local int rx1649_rep
    .local pmc rx1649_cur
    .local pmc rx1649_debug
    (rx1649_cur, rx1649_pos, rx1649_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1649_cur
    .local pmc match
    .lex "$/", match
    length rx1649_eos, rx1649_tgt
    gt rx1649_pos, rx1649_eos, rx1649_done
    set rx1649_off, 0
    lt rx1649_pos, 2, rx1649_start
    sub rx1649_off, rx1649_pos, 1
    substr rx1649_tgt, rx1649_tgt, rx1649_off
  rx1649_start:
    eq $I10, 1, rx1649_restart
    if_null rx1649_debug, debug_1153
    rx1649_cur."!cursor_debug"("START", "")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1650_done
    goto rxscan1650_scan
  rxscan1650_loop:
    (rx1649_pos) = rx1649_cur."from"()
    inc rx1649_pos
    rx1649_cur."!cursor_from"(rx1649_pos)
    ge rx1649_pos, rx1649_eos, rxscan1650_done
  rxscan1650_scan:
    set_addr $I10, rxscan1650_loop
    rx1649_cur."!mark_push"(0, rx1649_pos, $I10)
  rxscan1650_done:
  # rx literal  "{"
    add $I11, rx1649_pos, 1
    gt $I11, rx1649_eos, rx1649_fail
    sub $I11, rx1649_pos, rx1649_off
    ord $I11, rx1649_tgt, $I11
    ne $I11, 123, rx1649_fail
    add rx1649_pos, 1
  # rx pass
    rx1649_cur."!cursor_pass"(rx1649_pos, "")
    if_null rx1649_debug, debug_1154
    rx1649_cur."!cursor_debug"("PASS", "", " at pos=", rx1649_pos)
  debug_1154:
    .return (rx1649_cur)
  rx1649_restart:
    if_null rx1649_debug, debug_1155
    rx1649_cur."!cursor_debug"("NEXT", "")
  debug_1155:
  rx1649_fail:
    (rx1649_rep, rx1649_pos, $I10, $P10) = rx1649_cur."!mark_fail"(0)
    lt rx1649_pos, -1, rx1649_done
    eq rx1649_pos, -1, rx1649_fail
    jump $I10
  rx1649_done:
    rx1649_cur."!cursor_fail"()
    if_null rx1649_debug, debug_1156
    rx1649_cur."!cursor_debug"("FAIL", "")
  debug_1156:
    .return (rx1649_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("392_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .const 'Sub' $P1661 = "394_1299465717.405" 
    capture_lex $P1661
    .local string rx1653_tgt
    .local int rx1653_pos
    .local int rx1653_off
    .local int rx1653_eos
    .local int rx1653_rep
    .local pmc rx1653_cur
    .local pmc rx1653_debug
    (rx1653_cur, rx1653_pos, rx1653_tgt, $I10) = self."!cursor_start"()
    rx1653_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1653_cur
    .local pmc match
    .lex "$/", match
    length rx1653_eos, rx1653_tgt
    gt rx1653_pos, rx1653_eos, rx1653_done
    set rx1653_off, 0
    lt rx1653_pos, 2, rx1653_start
    sub rx1653_off, rx1653_pos, 1
    substr rx1653_tgt, rx1653_tgt, rx1653_off
  rx1653_start:
    eq $I10, 1, rx1653_restart
    if_null rx1653_debug, debug_1160
    rx1653_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1657_done
    goto rxscan1657_scan
  rxscan1657_loop:
    (rx1653_pos) = rx1653_cur."from"()
    inc rx1653_pos
    rx1653_cur."!cursor_from"(rx1653_pos)
    ge rx1653_pos, rx1653_eos, rxscan1657_done
  rxscan1657_scan:
    set_addr $I10, rxscan1657_loop
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
  rxscan1657_done:
.annotate 'line', 685
  # rx subrule "identifier" subtype=capture negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."identifier"()
    unless $P10, rx1653_fail
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1653_pos = $P10."pos"()
.annotate 'line', 692
  # rx rxquantr1658 ** 0..1
    set_addr $I10, rxquantr1658_done
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
  rxquantr1658_loop:
  alt1659_0:
.annotate 'line', 686
    set_addr $I10, alt1659_1
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
.annotate 'line', 687
  # rx subrule "before" subtype=zerowidth negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    .const 'Sub' $P1661 = "394_1299465717.405" 
    capture_lex $P1661
    $P10 = rx1653_cur."before"($P1661)
    unless $P10, rx1653_fail
    goto alt1659_end
  alt1659_1:
    set_addr $I10, alt1659_2
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
.annotate 'line', 688
  # rx literal  "="
    add $I11, rx1653_pos, 1
    gt $I11, rx1653_eos, rx1653_fail
    sub $I11, rx1653_pos, rx1653_off
    ord $I11, rx1653_tgt, $I11
    ne $I11, 61, rx1653_fail
    add rx1653_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."assertion"()
    unless $P10, rx1653_fail
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1653_pos = $P10."pos"()
    goto alt1659_end
  alt1659_2:
    set_addr $I10, alt1659_3
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
.annotate 'line', 689
  # rx literal  ":"
    add $I11, rx1653_pos, 1
    gt $I11, rx1653_eos, rx1653_fail
    sub $I11, rx1653_pos, rx1653_off
    ord $I11, rx1653_tgt, $I11
    ne $I11, 58, rx1653_fail
    add rx1653_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."arglist"()
    unless $P10, rx1653_fail
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1653_pos = $P10."pos"()
    goto alt1659_end
  alt1659_3:
    set_addr $I10, alt1659_4
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
.annotate 'line', 690
  # rx literal  "("
    add $I11, rx1653_pos, 1
    gt $I11, rx1653_eos, rx1653_fail
    sub $I11, rx1653_pos, rx1653_off
    ord $I11, rx1653_tgt, $I11
    ne $I11, 40, rx1653_fail
    add rx1653_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1653_fail
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1653_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1653_pos, 1
    gt $I11, rx1653_eos, rx1653_fail
    sub $I11, rx1653_pos, rx1653_off
    ord $I11, rx1653_tgt, $I11
    ne $I11, 41, rx1653_fail
    add rx1653_pos, 1
    goto alt1659_end
  alt1659_4:
.annotate 'line', 691
  # rx subrule "normspace" subtype=method negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."normspace"()
    unless $P10, rx1653_fail
    rx1653_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."nibbler"()
    unless $P10, rx1653_fail
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1653_pos = $P10."pos"()
  alt1659_end:
.annotate 'line', 692
    set_addr $I10, rxquantr1658_done
    (rx1653_rep) = rx1653_cur."!mark_commit"($I10)
  rxquantr1658_done:
.annotate 'line', 684
  # rx pass
    rx1653_cur."!cursor_pass"(rx1653_pos, "assertion:sym<name>")
    if_null rx1653_debug, debug_1165
    rx1653_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1653_pos)
  debug_1165:
    .return (rx1653_cur)
  rx1653_restart:
.annotate 'line', 663
    if_null rx1653_debug, debug_1166
    rx1653_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1166:
  rx1653_fail:
    (rx1653_rep, rx1653_pos, $I10, $P10) = rx1653_cur."!mark_fail"(0)
    lt rx1653_pos, -1, rx1653_done
    eq rx1653_pos, -1, rx1653_fail
    jump $I10
  rx1653_done:
    rx1653_cur."!cursor_fail"()
    if_null rx1653_debug, debug_1167
    rx1653_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1167:
    .return (rx1653_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("393_1299465717.405") :method
.annotate 'line', 663
    $P1655 = self."!PREFIX__!subrule"("identifier", "")
    new $P1656, "ResizablePMCArray"
    push $P1656, $P1655
    .return ($P1656)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1660"  :anon :subid("394_1299465717.405") :method :outer("392_1299465717.405")
.annotate 'line', 687
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1161
    rx1662_cur."!cursor_debug"("START", "")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1663_done
    goto rxscan1663_scan
  rxscan1663_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1663_done
  rxscan1663_scan:
    set_addr $I10, rxscan1663_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1663_done:
  # rx literal  ">"
    add $I11, rx1662_pos, 1
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    ord $I11, rx1662_tgt, $I11
    ne $I11, 62, rx1662_fail
    add rx1662_pos, 1
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "")
    if_null rx1662_debug, debug_1162
    rx1662_cur."!cursor_debug"("PASS", "", " at pos=", rx1662_pos)
  debug_1162:
    .return (rx1662_cur)
  rx1662_restart:
    if_null rx1662_debug, debug_1163
    rx1662_cur."!cursor_debug"("NEXT", "")
  debug_1163:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1164
    rx1662_cur."!cursor_debug"("FAIL", "")
  debug_1164:
    .return (rx1662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("395_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .local string rx1665_tgt
    .local int rx1665_pos
    .local int rx1665_off
    .local int rx1665_eos
    .local int rx1665_rep
    .local pmc rx1665_cur
    .local pmc rx1665_debug
    (rx1665_cur, rx1665_pos, rx1665_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1665_cur
    .local pmc match
    .lex "$/", match
    length rx1665_eos, rx1665_tgt
    gt rx1665_pos, rx1665_eos, rx1665_done
    set rx1665_off, 0
    lt rx1665_pos, 2, rx1665_start
    sub rx1665_off, rx1665_pos, 1
    substr rx1665_tgt, rx1665_tgt, rx1665_off
  rx1665_start:
    eq $I10, 1, rx1665_restart
    if_null rx1665_debug, debug_1168
    rx1665_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1668_done
    goto rxscan1668_scan
  rxscan1668_loop:
    (rx1665_pos) = rx1665_cur."from"()
    inc rx1665_pos
    rx1665_cur."!cursor_from"(rx1665_pos)
    ge rx1665_pos, rx1665_eos, rxscan1668_done
  rxscan1668_scan:
    set_addr $I10, rxscan1668_loop
    rx1665_cur."!mark_push"(0, rx1665_pos, $I10)
  rxscan1668_done:
.annotate 'line', 696
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1665_pos, rx1665_off
    substr $S10, rx1665_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1665_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1665_cur."!cursor_pos"(rx1665_pos)
    $P10 = rx1665_cur."LANG"("MAIN", "variable")
    unless $P10, rx1665_fail
    rx1665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1665_pos = $P10."pos"()
.annotate 'line', 695
  # rx pass
    rx1665_cur."!cursor_pass"(rx1665_pos, "assertion:sym<var>")
    if_null rx1665_debug, debug_1169
    rx1665_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1665_pos)
  debug_1169:
    .return (rx1665_cur)
  rx1665_restart:
.annotate 'line', 663
    if_null rx1665_debug, debug_1170
    rx1665_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1170:
  rx1665_fail:
    (rx1665_rep, rx1665_pos, $I10, $P10) = rx1665_cur."!mark_fail"(0)
    lt rx1665_pos, -1, rx1665_done
    eq rx1665_pos, -1, rx1665_fail
    jump $I10
  rx1665_done:
    rx1665_cur."!cursor_fail"()
    if_null rx1665_debug, debug_1171
    rx1665_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1171:
    .return (rx1665_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("396_1299465717.405") :method
.annotate 'line', 663
    new $P1667, "ResizablePMCArray"
    push $P1667, "$"
    push $P1667, "@"
    .return ($P1667)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("397_1299465717.405") :method :outer("378_1299465717.405")
.annotate 'line', 663
    .local string rx1670_tgt
    .local int rx1670_pos
    .local int rx1670_off
    .local int rx1670_eos
    .local int rx1670_rep
    .local pmc rx1670_cur
    .local pmc rx1670_debug
    (rx1670_cur, rx1670_pos, rx1670_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1670_cur
    .local pmc match
    .lex "$/", match
    length rx1670_eos, rx1670_tgt
    gt rx1670_pos, rx1670_eos, rx1670_done
    set rx1670_off, 0
    lt rx1670_pos, 2, rx1670_start
    sub rx1670_off, rx1670_pos, 1
    substr rx1670_tgt, rx1670_tgt, rx1670_off
  rx1670_start:
    eq $I10, 1, rx1670_restart
    if_null rx1670_debug, debug_1172
    rx1670_cur."!cursor_debug"("START", "codeblock")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1674_done
    goto rxscan1674_scan
  rxscan1674_loop:
    (rx1670_pos) = rx1670_cur."from"()
    inc rx1670_pos
    rx1670_cur."!cursor_from"(rx1670_pos)
    ge rx1670_pos, rx1670_eos, rxscan1674_done
  rxscan1674_scan:
    set_addr $I10, rxscan1674_loop
    rx1670_cur."!mark_push"(0, rx1670_pos, $I10)
  rxscan1674_done:
.annotate 'line', 700
  # rx subrule "LANG" subtype=capture negate=
    rx1670_cur."!cursor_pos"(rx1670_pos)
    $P10 = rx1670_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1670_fail
    rx1670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1670_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1670_cur."!cursor_pass"(rx1670_pos, "codeblock")
    if_null rx1670_debug, debug_1173
    rx1670_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1670_pos)
  debug_1173:
    .return (rx1670_cur)
  rx1670_restart:
.annotate 'line', 663
    if_null rx1670_debug, debug_1174
    rx1670_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1174:
  rx1670_fail:
    (rx1670_rep, rx1670_pos, $I10, $P10) = rx1670_cur."!mark_fail"(0)
    lt rx1670_pos, -1, rx1670_done
    eq rx1670_pos, -1, rx1670_fail
    jump $I10
  rx1670_done:
    rx1670_cur."!cursor_fail"()
    if_null rx1670_debug, debug_1175
    rx1670_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1175:
    .return (rx1670_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("398_1299465717.405") :method
.annotate 'line', 663
    $P1672 = self."!PREFIX__!subrule"("LANG", "")
    new $P1673, "ResizablePMCArray"
    push $P1673, $P1672
    .return ($P1673)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1716" :load :anon :subid("400_1299465717.405")
.annotate 'line', 4
    .const 'Sub' $P1718 = "11_1299465717.405" 
    $P1719 = $P1718()
    .return ($P1719)
.end


.HLL "nqp"

.namespace []
.sub "_block2437" :load :anon :subid("402_1299465717.405")
.annotate 'line', 1
    .const 'Sub' $P2439 = "10_1299465717.405" 
    $P2440 = $P2439()
    .return ($P2440)
.end

### .include 'gen/nqp-actions.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299465732.713")
.annotate 'line', 0
    get_hll_global $P18, ["NQP";"Actions"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    nqp_dynop_setup 
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    get_hll_global $P16, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P18, ["NQP";"Actions"], "_block17" 
    capture_lex $P18
    $P3285 = $P18()
.annotate 'line', 1
    .return ($P3285)
    .const 'Sub' $P3287 = "171_1299465732.713" 
    .return ($P3287)
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block17"  :subid("11_1299465732.713") :outer("10_1299465732.713")
.annotate 'line', 3
    .const 'Sub' $P3064 = "170_1299465732.713" 
    capture_lex $P3064
    get_hll_global $P2938, ["NQP";"RegexActions"], "_block2937" 
    capture_lex $P2938
    .const 'Sub' $P2929 = "159_1299465732.713" 
    capture_lex $P2929
    .const 'Sub' $P2924 = "158_1299465732.713" 
    capture_lex $P2924
    .const 'Sub' $P2919 = "157_1299465732.713" 
    capture_lex $P2919
    .const 'Sub' $P2914 = "156_1299465732.713" 
    capture_lex $P2914
    .const 'Sub' $P2903 = "155_1299465732.713" 
    capture_lex $P2903
    .const 'Sub' $P2895 = "154_1299465732.713" 
    capture_lex $P2895
    .const 'Sub' $P2887 = "153_1299465732.713" 
    capture_lex $P2887
    .const 'Sub' $P2879 = "152_1299465732.713" 
    capture_lex $P2879
    .const 'Sub' $P2874 = "151_1299465732.713" 
    capture_lex $P2874
    .const 'Sub' $P2862 = "150_1299465732.713" 
    capture_lex $P2862
    .const 'Sub' $P2854 = "149_1299465732.713" 
    capture_lex $P2854
    .const 'Sub' $P2816 = "148_1299465732.713" 
    capture_lex $P2816
    .const 'Sub' $P2804 = "147_1299465732.713" 
    capture_lex $P2804
    .const 'Sub' $P2796 = "146_1299465732.713" 
    capture_lex $P2796
    .const 'Sub' $P2788 = "145_1299465732.713" 
    capture_lex $P2788
    .const 'Sub' $P2780 = "144_1299465732.713" 
    capture_lex $P2780
    .const 'Sub' $P2772 = "143_1299465732.713" 
    capture_lex $P2772
    .const 'Sub' $P2764 = "142_1299465732.713" 
    capture_lex $P2764
    .const 'Sub' $P2738 = "141_1299465732.713" 
    capture_lex $P2738
    .const 'Sub' $P2723 = "140_1299465732.713" 
    capture_lex $P2723
    .const 'Sub' $P2715 = "139_1299465732.713" 
    capture_lex $P2715
    .const 'Sub' $P2704 = "138_1299465732.713" 
    capture_lex $P2704
    .const 'Sub' $P2693 = "137_1299465732.713" 
    capture_lex $P2693
    .const 'Sub' $P2682 = "136_1299465732.713" 
    capture_lex $P2682
    .const 'Sub' $P2674 = "135_1299465732.713" 
    capture_lex $P2674
    .const 'Sub' $P2647 = "134_1299465732.713" 
    capture_lex $P2647
    .const 'Sub' $P2609 = "132_1299465732.713" 
    capture_lex $P2609
    .const 'Sub' $P2601 = "131_1299465732.713" 
    capture_lex $P2601
    .const 'Sub' $P2593 = "130_1299465732.713" 
    capture_lex $P2593
    .const 'Sub' $P2568 = "129_1299465732.713" 
    capture_lex $P2568
    .const 'Sub' $P2552 = "128_1299465732.713" 
    capture_lex $P2552
    .const 'Sub' $P2544 = "127_1299465732.713" 
    capture_lex $P2544
    .const 'Sub' $P2536 = "126_1299465732.713" 
    capture_lex $P2536
    .const 'Sub' $P2434 = "123_1299465732.713" 
    capture_lex $P2434
    .const 'Sub' $P2426 = "122_1299465732.713" 
    capture_lex $P2426
    .const 'Sub' $P2419 = "121_1299465732.713" 
    capture_lex $P2419
    .const 'Sub' $P2392 = "120_1299465732.713" 
    capture_lex $P2392
    .const 'Sub' $P2352 = "119_1299465732.713" 
    capture_lex $P2352
    .const 'Sub' $P2338 = "118_1299465732.713" 
    capture_lex $P2338
    .const 'Sub' $P2331 = "117_1299465732.713" 
    capture_lex $P2331
    .const 'Sub' $P2287 = "116_1299465732.713" 
    capture_lex $P2287
    .const 'Sub' $P2122 = "112_1299465732.713" 
    capture_lex $P2122
    .const 'Sub' $P2059 = "110_1299465732.713" 
    capture_lex $P2059
    .const 'Sub' $P2051 = "109_1299465732.713" 
    capture_lex $P2051
    .const 'Sub' $P2036 = "108_1299465732.713" 
    capture_lex $P2036
    .const 'Sub' $P2021 = "107_1299465732.713" 
    capture_lex $P2021
    .const 'Sub' $P2003 = "106_1299465732.713" 
    capture_lex $P2003
    .const 'Sub' $P1904 = "105_1299465732.713" 
    capture_lex $P1904
    .const 'Sub' $P1860 = "102_1299465732.713" 
    capture_lex $P1860
    .const 'Sub' $P1735 = "99_1299465732.713" 
    capture_lex $P1735
    .const 'Sub' $P1493 = "92_1299465732.713" 
    capture_lex $P1493
    .const 'Sub' $P1485 = "91_1299465732.713" 
    capture_lex $P1485
    .const 'Sub' $P1477 = "90_1299465732.713" 
    capture_lex $P1477
    .const 'Sub' $P1376 = "86_1299465732.713" 
    capture_lex $P1376
    .const 'Sub' $P1368 = "85_1299465732.713" 
    capture_lex $P1368
    .const 'Sub' $P1353 = "84_1299465732.713" 
    capture_lex $P1353
    .const 'Sub' $P1338 = "83_1299465732.713" 
    capture_lex $P1338
    .const 'Sub' $P1323 = "82_1299465732.713" 
    capture_lex $P1323
    .const 'Sub' $P1308 = "81_1299465732.713" 
    capture_lex $P1308
    .const 'Sub' $P1300 = "80_1299465732.713" 
    capture_lex $P1300
    .const 'Sub' $P1292 = "79_1299465732.713" 
    capture_lex $P1292
    .const 'Sub' $P1284 = "78_1299465732.713" 
    capture_lex $P1284
    .const 'Sub' $P1070 = "74_1299465732.713" 
    capture_lex $P1070
    .const 'Sub' $P1062 = "73_1299465732.713" 
    capture_lex $P1062
    .const 'Sub' $P1054 = "72_1299465732.713" 
    capture_lex $P1054
    .const 'Sub' $P1046 = "71_1299465732.713" 
    capture_lex $P1046
    .const 'Sub' $P1038 = "70_1299465732.713" 
    capture_lex $P1038
    .const 'Sub' $P1030 = "69_1299465732.713" 
    capture_lex $P1030
    .const 'Sub' $P1022 = "68_1299465732.713" 
    capture_lex $P1022
    .const 'Sub' $P932 = "66_1299465732.713" 
    capture_lex $P932
    .const 'Sub' $P908 = "65_1299465732.713" 
    capture_lex $P908
    .const 'Sub' $P894 = "64_1299465732.713" 
    capture_lex $P894
    .const 'Sub' $P886 = "63_1299465732.713" 
    capture_lex $P886
    .const 'Sub' $P878 = "62_1299465732.713" 
    capture_lex $P878
    .const 'Sub' $P870 = "61_1299465732.713" 
    capture_lex $P870
    .const 'Sub' $P862 = "60_1299465732.713" 
    capture_lex $P862
    .const 'Sub' $P854 = "59_1299465732.713" 
    capture_lex $P854
    .const 'Sub' $P846 = "58_1299465732.713" 
    capture_lex $P846
    .const 'Sub' $P838 = "57_1299465732.713" 
    capture_lex $P838
    .const 'Sub' $P830 = "56_1299465732.713" 
    capture_lex $P830
    .const 'Sub' $P822 = "55_1299465732.713" 
    capture_lex $P822
    .const 'Sub' $P814 = "54_1299465732.713" 
    capture_lex $P814
    .const 'Sub' $P806 = "53_1299465732.713" 
    capture_lex $P806
    .const 'Sub' $P798 = "52_1299465732.713" 
    capture_lex $P798
    .const 'Sub' $P790 = "51_1299465732.713" 
    capture_lex $P790
    .const 'Sub' $P774 = "50_1299465732.713" 
    capture_lex $P774
    .const 'Sub' $P741 = "49_1299465732.713" 
    capture_lex $P741
    .const 'Sub' $P727 = "48_1299465732.713" 
    capture_lex $P727
    .const 'Sub' $P708 = "47_1299465732.713" 
    capture_lex $P708
    .const 'Sub' $P690 = "46_1299465732.713" 
    capture_lex $P690
    .const 'Sub' $P666 = "45_1299465732.713" 
    capture_lex $P666
    .const 'Sub' $P632 = "44_1299465732.713" 
    capture_lex $P632
    .const 'Sub' $P617 = "43_1299465732.713" 
    capture_lex $P617
    .const 'Sub' $P605 = "42_1299465732.713" 
    capture_lex $P605
    .const 'Sub' $P554 = "40_1299465732.713" 
    capture_lex $P554
    .const 'Sub' $P547 = "39_1299465732.713" 
    capture_lex $P547
    .const 'Sub' $P525 = "38_1299465732.713" 
    capture_lex $P525
    .const 'Sub' $P514 = "37_1299465732.713" 
    capture_lex $P514
    .const 'Sub' $P479 = "35_1299465732.713" 
    capture_lex $P479
    .const 'Sub' $P471 = "34_1299465732.713" 
    capture_lex $P471
    .const 'Sub' $P463 = "33_1299465732.713" 
    capture_lex $P463
    .const 'Sub' $P449 = "32_1299465732.713" 
    capture_lex $P449
    .const 'Sub' $P368 = "30_1299465732.713" 
    capture_lex $P368
    .const 'Sub' $P327 = "28_1299465732.713" 
    capture_lex $P327
    .const 'Sub' $P281 = "27_1299465732.713" 
    capture_lex $P281
    .const 'Sub' $P250 = "26_1299465732.713" 
    capture_lex $P250
    .const 'Sub' $P242 = "25_1299465732.713" 
    capture_lex $P242
    .const 'Sub' $P234 = "23_1299465732.713" 
    capture_lex $P234
    .const 'Sub' $P220 = "22_1299465732.713" 
    capture_lex $P220
    .const 'Sub' $P155 = "20_1299465732.713" 
    capture_lex $P155
    .const 'Sub' $P145 = "19_1299465732.713" 
    capture_lex $P145
    .const 'Sub' $P97 = "18_1299465732.713" 
    capture_lex $P97
    .const 'Sub' $P84 = "17_1299465732.713" 
    capture_lex $P84
    .const 'Sub' $P66 = "16_1299465732.713" 
    capture_lex $P66
    .const 'Sub' $P33 = "13_1299465732.713" 
    capture_lex $P33
    .const 'Sub' $P25 = "12_1299465732.713" 
    capture_lex $P25
    get_global $P19, "$?CLASS"
    nqp_dynop_setup 
    getinterp $P20
    get_class $P21, "LexPad"
    get_class $P22, "NQPLexPad"
    $P20."hll_map"($P21, $P22)
    get_hll_global $P23, ["NQP"], "RegexActions"
    get_global $P24, "@BLOCK"
    unless_null $P24, vivify_173
    $P24 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P24
  vivify_173:
.annotate 'line', 9
    .const 'Sub' $P25 = "12_1299465732.713" 
    newclosure $P32, $P25
    .lex "xblock_immediate", $P32
.annotate 'line', 14
    .const 'Sub' $P33 = "13_1299465732.713" 
    newclosure $P65, $P33
    .lex "block_immediate", $P65
.annotate 'line', 24
    .const 'Sub' $P66 = "16_1299465732.713" 
    newclosure $P83, $P66
    .lex "vivitype", $P83
.annotate 'line', 43
    .const 'Sub' $P84 = "17_1299465732.713" 
    newclosure $P96, $P84
    .lex "colonpair_str", $P96
.annotate 'line', 254
    .const 'Sub' $P97 = "18_1299465732.713" 
    newclosure $P144, $P97
    .lex "push_block_handler", $P144
.annotate 'line', 793
    .const 'Sub' $P145 = "19_1299465732.713" 
    newclosure $P154, $P145
    .lex "only_star_block", $P154
.annotate 'line', 802
    .const 'Sub' $P155 = "20_1299465732.713" 
    newclosure $P219, $P155
    .lex "attach_multi_signature", $P219
.annotate 'line', 1278
    .const 'Sub' $P220 = "22_1299465732.713" 
    newclosure $P231, $P220
    .lex "control", $P231
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P232, "@BLOCK"
    .const 'Sub' $P234 = "23_1299465732.713" 
    capture_lex $P234
    $P234()
    find_lex $P239, "xblock_immediate"
    find_lex $P240, "block_immediate"
    find_lex $P241, "vivitype"
.annotate 'line', 35
    find_lex $P280, "colonpair_str"
.annotate 'line', 247
    find_lex $P726, "push_block_handler"
.annotate 'line', 721
    find_lex $P1858, "only_star_block"
    find_lex $P1859, "attach_multi_signature"
.annotate 'line', 1269
    find_lex $P2913, "control"
.annotate 'line', 1296
    get_hll_global $P2938, ["NQP";"RegexActions"], "_block2937" 
    capture_lex $P2938
    $P3058 = $P2938()
.annotate 'line', 3
    .return ($P3058)
    .const 'Sub' $P3060 = "169_1299465732.713" 
    .return ($P3060)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post172") :outer("11_1299465732.713")
.annotate 'line', 3
    get_hll_global $P18, ["NQP";"Actions"], "_block17" 
    .local pmc block
    set block, $P18
    .const 'Sub' $P3064 = "170_1299465732.713" 
    capture_lex $P3064
    $P3064()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3063"  :anon :subid("170_1299465732.713") :outer("11_1299465732.713")
.annotate 'line', 3
    get_hll_global $P3065, "NQPClassHOW"
    $P3066 = $P3065."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3066
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3067, type_obj
    .const 'Sub' $P3068 = "25_1299465732.713" 
    $P3067."add_method"(type_obj, "TOP", $P3068)
    get_how $P3069, type_obj
    .const 'Sub' $P3070 = "26_1299465732.713" 
    $P3069."add_method"(type_obj, "deflongname", $P3070)
    get_how $P3071, type_obj
    .const 'Sub' $P3072 = "27_1299465732.713" 
    $P3071."add_method"(type_obj, "comp_unit", $P3072)
    get_how $P3073, type_obj
    .const 'Sub' $P3074 = "28_1299465732.713" 
    $P3073."add_method"(type_obj, "statementlist", $P3074)
    get_how $P3075, type_obj
    .const 'Sub' $P3076 = "30_1299465732.713" 
    $P3075."add_method"(type_obj, "statement", $P3076)
    get_how $P3077, type_obj
    .const 'Sub' $P3078 = "32_1299465732.713" 
    $P3077."add_method"(type_obj, "xblock", $P3078)
    get_how $P3079, type_obj
    .const 'Sub' $P3080 = "33_1299465732.713" 
    $P3079."add_method"(type_obj, "pblock", $P3080)
    get_how $P3081, type_obj
    .const 'Sub' $P3082 = "34_1299465732.713" 
    $P3081."add_method"(type_obj, "block", $P3082)
    get_how $P3083, type_obj
    .const 'Sub' $P3084 = "35_1299465732.713" 
    $P3083."add_method"(type_obj, "blockoid", $P3084)
    get_how $P3085, type_obj
    .const 'Sub' $P3086 = "37_1299465732.713" 
    $P3085."add_method"(type_obj, "newpad", $P3086)
    get_how $P3087, type_obj
    .const 'Sub' $P3088 = "38_1299465732.713" 
    $P3087."add_method"(type_obj, "outerctx", $P3088)
    get_how $P3089, type_obj
    .const 'Sub' $P3090 = "39_1299465732.713" 
    $P3089."add_method"(type_obj, "you_are_here", $P3090)
    get_how $P3091, type_obj
    .const 'Sub' $P3092 = "40_1299465732.713" 
    $P3091."add_method"(type_obj, "statement_control:sym<if>", $P3092)
    get_how $P3093, type_obj
    .const 'Sub' $P3094 = "42_1299465732.713" 
    $P3093."add_method"(type_obj, "statement_control:sym<unless>", $P3094)
    get_how $P3095, type_obj
    .const 'Sub' $P3096 = "43_1299465732.713" 
    $P3095."add_method"(type_obj, "statement_control:sym<while>", $P3096)
    get_how $P3097, type_obj
    .const 'Sub' $P3098 = "44_1299465732.713" 
    $P3097."add_method"(type_obj, "statement_control:sym<repeat>", $P3098)
    get_how $P3099, type_obj
    .const 'Sub' $P3100 = "45_1299465732.713" 
    $P3099."add_method"(type_obj, "statement_control:sym<for>", $P3100)
    get_how $P3101, type_obj
    .const 'Sub' $P3102 = "46_1299465732.713" 
    $P3101."add_method"(type_obj, "statement_control:sym<CATCH>", $P3102)
    get_how $P3103, type_obj
    .const 'Sub' $P3104 = "47_1299465732.713" 
    $P3103."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3104)
    get_how $P3105, type_obj
    .const 'Sub' $P3106 = "48_1299465732.713" 
    $P3105."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3106)
    get_how $P3107, type_obj
    .const 'Sub' $P3108 = "49_1299465732.713" 
    $P3107."add_method"(type_obj, "statement_prefix:sym<try>", $P3108)
    get_how $P3109, type_obj
    .const 'Sub' $P3110 = "50_1299465732.713" 
    $P3109."add_method"(type_obj, "blorst", $P3110)
    get_how $P3111, type_obj
    .const 'Sub' $P3112 = "51_1299465732.713" 
    $P3111."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3112)
    get_how $P3113, type_obj
    .const 'Sub' $P3114 = "52_1299465732.713" 
    $P3113."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3114)
    get_how $P3115, type_obj
    .const 'Sub' $P3116 = "53_1299465732.713" 
    $P3115."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3116)
    get_how $P3117, type_obj
    .const 'Sub' $P3118 = "54_1299465732.713" 
    $P3117."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3118)
    get_how $P3119, type_obj
    .const 'Sub' $P3120 = "55_1299465732.713" 
    $P3119."add_method"(type_obj, "term:sym<fatarrow>", $P3120)
    get_how $P3121, type_obj
    .const 'Sub' $P3122 = "56_1299465732.713" 
    $P3121."add_method"(type_obj, "term:sym<colonpair>", $P3122)
    get_how $P3123, type_obj
    .const 'Sub' $P3124 = "57_1299465732.713" 
    $P3123."add_method"(type_obj, "term:sym<variable>", $P3124)
    get_how $P3125, type_obj
    .const 'Sub' $P3126 = "58_1299465732.713" 
    $P3125."add_method"(type_obj, "term:sym<package_declarator>", $P3126)
    get_how $P3127, type_obj
    .const 'Sub' $P3128 = "59_1299465732.713" 
    $P3127."add_method"(type_obj, "term:sym<scope_declarator>", $P3128)
    get_how $P3129, type_obj
    .const 'Sub' $P3130 = "60_1299465732.713" 
    $P3129."add_method"(type_obj, "term:sym<routine_declarator>", $P3130)
    get_how $P3131, type_obj
    .const 'Sub' $P3132 = "61_1299465732.713" 
    $P3131."add_method"(type_obj, "term:sym<regex_declarator>", $P3132)
    get_how $P3133, type_obj
    .const 'Sub' $P3134 = "62_1299465732.713" 
    $P3133."add_method"(type_obj, "term:sym<statement_prefix>", $P3134)
    get_how $P3135, type_obj
    .const 'Sub' $P3136 = "63_1299465732.713" 
    $P3135."add_method"(type_obj, "term:sym<lambda>", $P3136)
    get_how $P3137, type_obj
    .const 'Sub' $P3138 = "64_1299465732.713" 
    $P3137."add_method"(type_obj, "fatarrow", $P3138)
    get_how $P3139, type_obj
    .const 'Sub' $P3140 = "65_1299465732.713" 
    $P3139."add_method"(type_obj, "colonpair", $P3140)
    get_how $P3141, type_obj
    .const 'Sub' $P3142 = "66_1299465732.713" 
    $P3141."add_method"(type_obj, "variable", $P3142)
    get_how $P3143, type_obj
    .const 'Sub' $P3144 = "68_1299465732.713" 
    $P3143."add_method"(type_obj, "package_declarator:sym<module>", $P3144)
    get_how $P3145, type_obj
    .const 'Sub' $P3146 = "69_1299465732.713" 
    $P3145."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3146)
    get_how $P3147, type_obj
    .const 'Sub' $P3148 = "70_1299465732.713" 
    $P3147."add_method"(type_obj, "package_declarator:sym<class>", $P3148)
    get_how $P3149, type_obj
    .const 'Sub' $P3150 = "71_1299465732.713" 
    $P3149."add_method"(type_obj, "package_declarator:sym<grammar>", $P3150)
    get_how $P3151, type_obj
    .const 'Sub' $P3152 = "72_1299465732.713" 
    $P3151."add_method"(type_obj, "package_declarator:sym<role>", $P3152)
    get_how $P3153, type_obj
    .const 'Sub' $P3154 = "73_1299465732.713" 
    $P3153."add_method"(type_obj, "package_declarator:sym<native>", $P3154)
    get_how $P3155, type_obj
    .const 'Sub' $P3156 = "74_1299465732.713" 
    $P3155."add_method"(type_obj, "package_def", $P3156)
    get_how $P3157, type_obj
    .const 'Sub' $P3158 = "78_1299465732.713" 
    $P3157."add_method"(type_obj, "scope_declarator:sym<my>", $P3158)
    get_how $P3159, type_obj
    .const 'Sub' $P3160 = "79_1299465732.713" 
    $P3159."add_method"(type_obj, "scope_declarator:sym<our>", $P3160)
    get_how $P3161, type_obj
    .const 'Sub' $P3162 = "80_1299465732.713" 
    $P3161."add_method"(type_obj, "scope_declarator:sym<has>", $P3162)
    get_how $P3163, type_obj
    .const 'Sub' $P3164 = "81_1299465732.713" 
    $P3163."add_method"(type_obj, "scoped", $P3164)
    get_how $P3165, type_obj
    .const 'Sub' $P3166 = "82_1299465732.713" 
    $P3165."add_method"(type_obj, "declarator", $P3166)
    get_how $P3167, type_obj
    .const 'Sub' $P3168 = "83_1299465732.713" 
    $P3167."add_method"(type_obj, "multi_declarator:sym<multi>", $P3168)
    get_how $P3169, type_obj
    .const 'Sub' $P3170 = "84_1299465732.713" 
    $P3169."add_method"(type_obj, "multi_declarator:sym<proto>", $P3170)
    get_how $P3171, type_obj
    .const 'Sub' $P3172 = "85_1299465732.713" 
    $P3171."add_method"(type_obj, "multi_declarator:sym<null>", $P3172)
    get_how $P3173, type_obj
    .const 'Sub' $P3174 = "86_1299465732.713" 
    $P3173."add_method"(type_obj, "variable_declarator", $P3174)
    get_how $P3175, type_obj
    .const 'Sub' $P3176 = "90_1299465732.713" 
    $P3175."add_method"(type_obj, "routine_declarator:sym<sub>", $P3176)
    get_how $P3177, type_obj
    .const 'Sub' $P3178 = "91_1299465732.713" 
    $P3177."add_method"(type_obj, "routine_declarator:sym<method>", $P3178)
    get_how $P3179, type_obj
    .const 'Sub' $P3180 = "92_1299465732.713" 
    $P3179."add_method"(type_obj, "routine_def", $P3180)
    get_how $P3181, type_obj
    .const 'Sub' $P3182 = "99_1299465732.713" 
    $P3181."add_method"(type_obj, "method_def", $P3182)
    get_how $P3183, type_obj
    .const 'Sub' $P3184 = "102_1299465732.713" 
    $P3183."add_method"(type_obj, "signature", $P3184)
    get_how $P3185, type_obj
    .const 'Sub' $P3186 = "105_1299465732.713" 
    $P3185."add_method"(type_obj, "parameter", $P3186)
    get_how $P3187, type_obj
    .const 'Sub' $P3188 = "106_1299465732.713" 
    $P3187."add_method"(type_obj, "param_var", $P3188)
    get_how $P3189, type_obj
    .const 'Sub' $P3190 = "107_1299465732.713" 
    $P3189."add_method"(type_obj, "named_param", $P3190)
    get_how $P3191, type_obj
    .const 'Sub' $P3192 = "108_1299465732.713" 
    $P3191."add_method"(type_obj, "typename", $P3192)
    get_how $P3193, type_obj
    .const 'Sub' $P3194 = "109_1299465732.713" 
    $P3193."add_method"(type_obj, "trait", $P3194)
    get_how $P3195, type_obj
    .const 'Sub' $P3196 = "110_1299465732.713" 
    $P3195."add_method"(type_obj, "trait_mod:sym<is>", $P3196)
    get_how $P3197, type_obj
    .const 'Sub' $P3198 = "112_1299465732.713" 
    $P3197."add_method"(type_obj, "regex_declarator", $P3198)
    get_how $P3199, type_obj
    .const 'Sub' $P3200 = "116_1299465732.713" 
    $P3199."add_method"(type_obj, "dotty", $P3200)
    get_how $P3201, type_obj
    .const 'Sub' $P3202 = "117_1299465732.713" 
    $P3201."add_method"(type_obj, "term:sym<self>", $P3202)
    get_how $P3203, type_obj
    .const 'Sub' $P3204 = "118_1299465732.713" 
    $P3203."add_method"(type_obj, "term:sym<identifier>", $P3204)
    get_how $P3205, type_obj
    .const 'Sub' $P3206 = "119_1299465732.713" 
    $P3205."add_method"(type_obj, "term:sym<name>", $P3206)
    get_how $P3207, type_obj
    .const 'Sub' $P3208 = "120_1299465732.713" 
    $P3207."add_method"(type_obj, "term:sym<pir::op>", $P3208)
    get_how $P3209, type_obj
    .const 'Sub' $P3210 = "121_1299465732.713" 
    $P3209."add_method"(type_obj, "term:sym<onlystar>", $P3210)
    get_how $P3211, type_obj
    .const 'Sub' $P3212 = "122_1299465732.713" 
    $P3211."add_method"(type_obj, "args", $P3212)
    get_how $P3213, type_obj
    .const 'Sub' $P3214 = "123_1299465732.713" 
    $P3213."add_method"(type_obj, "arglist", $P3214)
    get_how $P3215, type_obj
    .const 'Sub' $P3216 = "126_1299465732.713" 
    $P3215."add_method"(type_obj, "term:sym<multi_declarator>", $P3216)
    get_how $P3217, type_obj
    .const 'Sub' $P3218 = "127_1299465732.713" 
    $P3217."add_method"(type_obj, "term:sym<value>", $P3218)
    get_how $P3219, type_obj
    .const 'Sub' $P3220 = "128_1299465732.713" 
    $P3219."add_method"(type_obj, "circumfix:sym<( )>", $P3220)
    get_how $P3221, type_obj
    .const 'Sub' $P3222 = "129_1299465732.713" 
    $P3221."add_method"(type_obj, "circumfix:sym<[ ]>", $P3222)
    get_how $P3223, type_obj
    .const 'Sub' $P3224 = "130_1299465732.713" 
    $P3223."add_method"(type_obj, "circumfix:sym<ang>", $P3224)
    get_how $P3225, type_obj
    .const 'Sub' $P3226 = "131_1299465732.713" 
    $P3225."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3226)
    get_how $P3227, type_obj
    .const 'Sub' $P3228 = "132_1299465732.713" 
    $P3227."add_method"(type_obj, "circumfix:sym<{ }>", $P3228)
    get_how $P3229, type_obj
    .const 'Sub' $P3230 = "134_1299465732.713" 
    $P3229."add_method"(type_obj, "circumfix:sym<sigil>", $P3230)
    get_how $P3231, type_obj
    .const 'Sub' $P3232 = "135_1299465732.713" 
    $P3231."add_method"(type_obj, "semilist", $P3232)
    get_how $P3233, type_obj
    .const 'Sub' $P3234 = "136_1299465732.713" 
    $P3233."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3234)
    get_how $P3235, type_obj
    .const 'Sub' $P3236 = "137_1299465732.713" 
    $P3235."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3236)
    get_how $P3237, type_obj
    .const 'Sub' $P3238 = "138_1299465732.713" 
    $P3237."add_method"(type_obj, "postcircumfix:sym<ang>", $P3238)
    get_how $P3239, type_obj
    .const 'Sub' $P3240 = "139_1299465732.713" 
    $P3239."add_method"(type_obj, "postcircumfix:sym<( )>", $P3240)
    get_how $P3241, type_obj
    .const 'Sub' $P3242 = "140_1299465732.713" 
    $P3241."add_method"(type_obj, "value", $P3242)
    get_how $P3243, type_obj
    .const 'Sub' $P3244 = "141_1299465732.713" 
    $P3243."add_method"(type_obj, "number", $P3244)
    get_how $P3245, type_obj
    .const 'Sub' $P3246 = "142_1299465732.713" 
    $P3245."add_method"(type_obj, "quote:sym<apos>", $P3246)
    get_how $P3247, type_obj
    .const 'Sub' $P3248 = "143_1299465732.713" 
    $P3247."add_method"(type_obj, "quote:sym<dblq>", $P3248)
    get_how $P3249, type_obj
    .const 'Sub' $P3250 = "144_1299465732.713" 
    $P3249."add_method"(type_obj, "quote:sym<qq>", $P3250)
    get_how $P3251, type_obj
    .const 'Sub' $P3252 = "145_1299465732.713" 
    $P3251."add_method"(type_obj, "quote:sym<q>", $P3252)
    get_how $P3253, type_obj
    .const 'Sub' $P3254 = "146_1299465732.713" 
    $P3253."add_method"(type_obj, "quote:sym<Q>", $P3254)
    get_how $P3255, type_obj
    .const 'Sub' $P3256 = "147_1299465732.713" 
    $P3255."add_method"(type_obj, "quote:sym<Q:PIR>", $P3256)
    get_how $P3257, type_obj
    .const 'Sub' $P3258 = "148_1299465732.713" 
    $P3257."add_method"(type_obj, "quote:sym</ />", $P3258)
    get_how $P3259, type_obj
    .const 'Sub' $P3260 = "149_1299465732.713" 
    $P3259."add_method"(type_obj, "quote_escape:sym<$>", $P3260)
    get_how $P3261, type_obj
    .const 'Sub' $P3262 = "150_1299465732.713" 
    $P3261."add_method"(type_obj, "quote_escape:sym<{ }>", $P3262)
    get_how $P3263, type_obj
    .const 'Sub' $P3264 = "151_1299465732.713" 
    $P3263."add_method"(type_obj, "quote_escape:sym<esc>", $P3264)
    get_how $P3265, type_obj
    .const 'Sub' $P3266 = "152_1299465732.713" 
    $P3265."add_method"(type_obj, "postfix:sym<.>", $P3266)
    get_how $P3267, type_obj
    .const 'Sub' $P3268 = "153_1299465732.713" 
    $P3267."add_method"(type_obj, "postfix:sym<++>", $P3268)
    get_how $P3269, type_obj
    .const 'Sub' $P3270 = "154_1299465732.713" 
    $P3269."add_method"(type_obj, "postfix:sym<-->", $P3270)
    get_how $P3271, type_obj
    .const 'Sub' $P3272 = "155_1299465732.713" 
    $P3271."add_method"(type_obj, "prefix:sym<make>", $P3272)
    get_how $P3273, type_obj
    .const 'Sub' $P3274 = "156_1299465732.713" 
    $P3273."add_method"(type_obj, "term:sym<next>", $P3274)
    get_how $P3275, type_obj
    .const 'Sub' $P3276 = "157_1299465732.713" 
    $P3275."add_method"(type_obj, "term:sym<last>", $P3276)
    get_how $P3277, type_obj
    .const 'Sub' $P3278 = "158_1299465732.713" 
    $P3277."add_method"(type_obj, "term:sym<redo>", $P3278)
    get_how $P3279, type_obj
    .const 'Sub' $P3280 = "159_1299465732.713" 
    $P3279."add_method"(type_obj, "infix:sym<~~>", $P3280)
    get_how $P3281, type_obj
    get_hll_global $P3282, ["HLL"], "Actions"
    $P3281."add_parent"(type_obj, $P3282)
    get_how $P3283, type_obj
    $P3284 = $P3283."compose"(type_obj)
    .return ($P3284)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_26
.annotate 'line', 9
    .lex "$xblock", param_26
.annotate 'line', 10
    find_lex $P27, "$xblock"
    unless_null $P27, vivify_174
    $P27 = root_new ['parrot';'ResizablePMCArray']
  vivify_174:
    set $P28, $P27[1]
    unless_null $P28, vivify_175
    new $P28, "Undef"
  vivify_175:
    $P29 = "block_immediate"($P28)
    find_lex $P30, "$xblock"
    unless_null $P30, vivify_176
    $P30 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P30
  vivify_176:
    set $P30[1], $P29
    find_lex $P31, "$xblock"
.annotate 'line', 9
    .return ($P31)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_34
.annotate 'line', 14
    .const 'Sub' $P44 = "14_1299465732.713" 
    capture_lex $P44
    .lex "$block", param_34
.annotate 'line', 15
    find_lex $P35, "$block"
    $P35."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P39, "$block"
    $P40 = $P39."symtable"()
    unless $P40, unless_38
    set $P37, $P40
    goto unless_38_end
  unless_38:
    find_lex $P41, "$block"
    $P42 = $P41."handlers"()
    set $P37, $P42
  unless_38_end:
    if $P37, unless_36_end
    .const 'Sub' $P44 = "14_1299465732.713" 
    capture_lex $P44
    $P44()
  unless_36_end:
    find_lex $P64, "$block"
.annotate 'line', 14
    .return ($P64)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block43"  :anon :subid("14_1299465732.713") :outer("13_1299465732.713")
.annotate 'line', 16
    .const 'Sub' $P55 = "15_1299465732.713" 
    capture_lex $P55
.annotate 'line', 17
    new $P45, "Undef"
    .lex "$stmts", $P45
    get_hll_global $P46, ["PAST"], "Stmts"
    find_lex $P47, "$block"
    $P48 = $P46."new"($P47 :named("node"))
    store_lex "$stmts", $P48
.annotate 'line', 18
    find_lex $P50, "$block"
    $P51 = $P50."list"()
    defined $I52, $P51
    unless $I52, for_undef_177
    iter $P49, $P51
    new $P61, 'ExceptionHandler'
    set_label $P61, loop60_handler
    $P61."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P61
  loop60_test:
    unless $P49, loop60_done
    shift $P53, $P49
  loop60_redo:
    .const 'Sub' $P55 = "15_1299465732.713" 
    capture_lex $P55
    $P55($P53)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, .CONTROL_LOOP_NEXT, loop60_next
    eq $P62, .CONTROL_LOOP_REDO, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_177:
.annotate 'line', 19
    find_lex $P63, "$stmts"
    store_lex "$block", $P63
.annotate 'line', 16
    .return ($P63)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block54"  :anon :subid("15_1299465732.713") :outer("14_1299465732.713")
    .param pmc param_56
.annotate 'line', 18
    .lex "$_", param_56
    find_lex $P57, "$stmts"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    .return ($P59)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_67
.annotate 'line', 24
    .lex "$sigil", param_67
.annotate 'line', 25
    find_lex $P70, "$sigil"
    set $S71, $P70
    iseq $I72, $S71, "%"
    if $I72, if_69
.annotate 'line', 27
    find_lex $P77, "$sigil"
    set $S78, $P77
    iseq $I79, $S78, "@"
    if $I79, if_76
    new $P82, "String"
    assign $P82, "Undef"
    set $P75, $P82
    goto if_76_end
  if_76:
.annotate 'line', 28
    get_hll_global $P80, ["PAST"], "Op"
    $P81 = $P80."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P75, $P81
  if_76_end:
    set $P68, $P75
.annotate 'line', 25
    goto if_69_end
  if_69:
.annotate 'line', 26
    get_hll_global $P73, ["PAST"], "Op"
    $P74 = $P73."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P68, $P74
  if_69_end:
.annotate 'line', 24
    .return ($P68)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_85
.annotate 'line', 43
    .lex "$ast", param_85
.annotate 'line', 44
    get_hll_global $P88, ["PAST"], "Op"
    find_lex $P89, "$ast"
    $P90 = $P88."ACCEPTS"($P89)
    if $P90, if_87
.annotate 'line', 46
    find_lex $P94, "$ast"
    $P95 = $P94."value"()
    set $P86, $P95
.annotate 'line', 44
    goto if_87_end
  if_87:
.annotate 'line', 45
    find_lex $P91, "$ast"
    $P92 = $P91."list"()
    join $S93, " ", $P92
    new $P86, 'String'
    set $P86, $S93
  if_87_end:
.annotate 'line', 43
    .return ($P86)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_98
    .param pmc param_99
.annotate 'line', 254
    .lex "$/", param_98
    .lex "$block", param_99
.annotate 'line', 255
    get_global $P101, "@BLOCK"
    unless_null $P101, vivify_178
    $P101 = root_new ['parrot';'ResizablePMCArray']
  vivify_178:
    set $P102, $P101[0]
    unless_null $P102, vivify_179
    new $P102, "Undef"
  vivify_179:
    $P103 = $P102."handlers"()
    if $P103, unless_100_end
.annotate 'line', 256
    get_global $P104, "@BLOCK"
    unless_null $P104, vivify_180
    $P104 = root_new ['parrot';'ResizablePMCArray']
  vivify_180:
    set $P105, $P104[0]
    unless_null $P105, vivify_181
    new $P105, "Undef"
  vivify_181:
    new $P106, "ResizablePMCArray"
    $P105."handlers"($P106)
  unless_100_end:
.annotate 'line', 258
    find_lex $P108, "$block"
    $P109 = $P108."arity"()
    if $P109, unless_107_end
.annotate 'line', 259
    find_lex $P110, "$block"
.annotate 'line', 260
    get_hll_global $P111, ["PAST"], "Op"
.annotate 'line', 261
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 262
    get_hll_global $P114, ["PAST"], "Var"
    $P115 = $P114."new"("lexical" :named("scope"), "$_" :named("name"))
    $P116 = $P111."new"($P113, $P115, "bind" :named("pasttype"))
.annotate 'line', 260
    $P110."unshift"($P116)
.annotate 'line', 265
    find_lex $P117, "$block"
    get_hll_global $P118, ["PAST"], "Var"
    $P119 = $P118."new"("$_" :named("name"), "parameter" :named("scope"))
    $P117."unshift"($P119)
.annotate 'line', 266
    find_lex $P120, "$block"
    $P120."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 267
    find_lex $P121, "$block"
    $P121."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 268
    find_lex $P122, "$block"
    $P122."arity"(1)
  unless_107_end:
.annotate 'line', 270
    find_lex $P123, "$block"
    $P123."blocktype"("declaration")
.annotate 'line', 271
    get_global $P124, "@BLOCK"
    unless_null $P124, vivify_182
    $P124 = root_new ['parrot';'ResizablePMCArray']
  vivify_182:
    set $P125, $P124[0]
    unless_null $P125, vivify_183
    new $P125, "Undef"
  vivify_183:
    $P126 = $P125."handlers"()
.annotate 'line', 272
    get_hll_global $P127, ["PAST"], "Control"
    find_lex $P128, "$/"
.annotate 'line', 274
    get_hll_global $P129, ["PAST"], "Stmts"
.annotate 'line', 275
    get_hll_global $P130, ["PAST"], "Op"
    find_lex $P131, "$block"
.annotate 'line', 277
    get_hll_global $P132, ["PAST"], "Var"
    $P133 = $P132."new"("register" :named("scope"), "exception" :named("name"))
    $P134 = $P130."new"($P131, $P133, "call" :named("pasttype"))
.annotate 'line', 279
    get_hll_global $P135, ["PAST"], "Op"
.annotate 'line', 280
    get_hll_global $P136, ["PAST"], "Var"
.annotate 'line', 281
    get_hll_global $P137, ["PAST"], "Var"
    $P138 = $P137."new"("register" :named("scope"), "exception" :named("name"))
    $P139 = $P136."new"($P138, "handled", "keyed" :named("scope"))
.annotate 'line', 280
    $P140 = $P135."new"($P139, 1, "bind" :named("pasttype"))
.annotate 'line', 279
    $P141 = $P129."new"($P134, $P140)
.annotate 'line', 274
    $P142 = $P127."new"($P141, $P128 :named("node"))
.annotate 'line', 272
    $P143 = $P126."unshift"($P142)
.annotate 'line', 254
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1299465732.713") :outer("11_1299465732.713")
.annotate 'line', 794
    new $P146, "Undef"
    .lex "$past", $P146
    get_global $P147, "@BLOCK"
    $P148 = $P147."shift"()
    store_lex "$past", $P148
.annotate 'line', 795
    find_lex $P149, "$past"
    $P149."closure"(1)
.annotate 'line', 796
    find_lex $P150, "$past"
    get_hll_global $P151, ["PAST"], "Op"
    $P152 = $P151."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P150."push"($P152)
    find_lex $P153, "$past"
.annotate 'line', 793
    .return ($P153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_156
.annotate 'line', 802
    .const 'Sub' $P170 = "21_1299465732.713" 
    capture_lex $P170
    .lex "$routine", param_156
.annotate 'line', 806
    new $P157, "Undef"
    .lex "$types", $P157
.annotate 'line', 807
    new $P158, "Undef"
    .lex "$definednesses", $P158
.annotate 'line', 806
    get_hll_global $P159, ["PAST"], "Op"
    $P160 = $P159."new"("list" :named("pasttype"))
    store_lex "$types", $P160
.annotate 'line', 807
    get_hll_global $P161, ["PAST"], "Op"
    $P162 = $P161."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P162
.annotate 'line', 808
    find_lex $P164, "$routine"
    unless_null $P164, vivify_184
    $P164 = root_new ['parrot';'ResizablePMCArray']
  vivify_184:
    set $P165, $P164[0]
    unless_null $P165, vivify_185
    new $P165, "Undef"
  vivify_185:
    $P166 = $P165."list"()
    defined $I167, $P166
    unless $I167, for_undef_186
    iter $P163, $P166
    new $P208, 'ExceptionHandler'
    set_label $P208, loop207_handler
    $P208."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P208
  loop207_test:
    unless $P163, loop207_done
    shift $P168, $P163
  loop207_redo:
    .const 'Sub' $P170 = "21_1299465732.713" 
    capture_lex $P170
    $P170($P168)
  loop207_next:
    goto loop207_test
  loop207_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P209, exception, 'type'
    eq $P209, .CONTROL_LOOP_NEXT, loop207_next
    eq $P209, .CONTROL_LOOP_REDO, loop207_redo
  loop207_done:
    pop_eh 
  for_undef_186:
.annotate 'line', 815
    find_lex $P210, "$routine"
    $P211 = $P210."loadinit"()
    get_hll_global $P212, ["PAST"], "Op"
.annotate 'line', 816
    get_hll_global $P213, ["PAST"], "Var"
    $P214 = $P213."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P215, "$types"
    find_lex $P216, "$definednesses"
    $P217 = $P212."new"($P214, $P215, $P216, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 815
    $P218 = $P211."push"($P217)
.annotate 'line', 802
    .return ($P218)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block169"  :anon :subid("21_1299465732.713") :outer("20_1299465732.713")
    .param pmc param_171
.annotate 'line', 808
    .lex "$_", param_171
.annotate 'line', 809
    get_hll_global $P176, ["PAST"], "Var"
    find_lex $P177, "$_"
    $P178 = $P176."ACCEPTS"($P177)
    if $P178, if_175
    set $P174, $P178
    goto if_175_end
  if_175:
    find_lex $P179, "$_"
    $S180 = $P179."scope"()
    iseq $I181, $S180, "parameter"
    new $P174, 'Integer'
    set $P174, $I181
  if_175_end:
    if $P174, if_173
    set $P172, $P174
    goto if_173_end
  if_173:
.annotate 'line', 810
    find_lex $P182, "$types"
    find_lex $P184, "$_"
    $P185 = $P184."multitype"()
    set $P183, $P185
    defined $I187, $P183
    if $I187, default_186
    get_hll_global $P188, ["PAST"], "Op"
    $P189 = $P188."new"("null P" :named("pirop"))
    set $P183, $P189
  default_186:
    $P182."push"($P183)
.annotate 'line', 811
    find_lex $P190, "$definednesses"
    find_lex $P193, "$_"
    unless_null $P193, vivify_187
    $P193 = root_new ['parrot';'Hash']
  vivify_187:
    set $P194, $P193["definedness"]
    unless_null $P194, vivify_188
    new $P194, "Undef"
  vivify_188:
    set $S195, $P194
    iseq $I196, $S195, "D"
    if $I196, if_192
.annotate 'line', 812
    find_lex $P200, "$_"
    unless_null $P200, vivify_189
    $P200 = root_new ['parrot';'Hash']
  vivify_189:
    set $P201, $P200["definedness"]
    unless_null $P201, vivify_190
    new $P201, "Undef"
  vivify_190:
    set $S202, $P201
    iseq $I203, $S202, "U"
    if $I203, if_199
    new $P205, "Integer"
    assign $P205, 0
    set $P198, $P205
    goto if_199_end
  if_199:
    new $P204, "Integer"
    assign $P204, 2
    set $P198, $P204
  if_199_end:
    set $P191, $P198
.annotate 'line', 811
    goto if_192_end
  if_192:
    new $P197, "Integer"
    assign $P197, 1
    set $P191, $P197
  if_192_end:
    $P206 = $P190."push"($P191)
.annotate 'line', 809
    set $P172, $P206
  if_173_end:
.annotate 'line', 808
    .return ($P172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("22_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_221
    .param pmc param_222
.annotate 'line', 1278
    .lex "$/", param_221
    .lex "$type", param_222
.annotate 'line', 1279
    find_lex $P223, "$/"
    get_hll_global $P224, ["PAST"], "Op"
    find_lex $P225, "$/"
.annotate 'line', 1283
    get_hll_global $P226, ["PAST"], "Val"
    find_lex $P227, "$type"
    $P228 = $P226."new"($P227 :named("value"), "!except_types" :named("returns"))
    $P229 = $P224."new"(0, $P228, $P225 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1279
    $P230 = $P223."!make"($P229)
.annotate 'line', 1278
    .return ($P230)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block233"  :anon :subid("23_1299465732.713") :outer("11_1299465732.713")
.annotate 'line', 3
    .const 'Sub' $P236 = "24_1299465732.713" 
    capture_lex $P236
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post191") :outer("23_1299465732.713")
.annotate 'line', 3
    .const 'Sub' $P234 = "23_1299465732.713" 
    .local pmc block
    set block, $P234
.annotate 'line', 5
    .const 'Sub' $P236 = "24_1299465732.713" 
    capture_lex $P236
    $P236()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block235"  :anon :subid("24_1299465732.713") :outer("23_1299465732.713")
.annotate 'line', 6
    get_global $P237, "@BLOCK"
    unless_null $P237, vivify_192
    $P237 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P237
  vivify_192:
 $P238 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P238
.annotate 'line', 5
    .return ($P238)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("25_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_243
    .param pmc param_244
.annotate 'line', 33
    .lex "self", param_243
    .lex "$/", param_244
    find_lex $P245, "$/"
    find_lex $P246, "$/"
    unless_null $P246, vivify_193
    $P246 = root_new ['parrot';'Hash']
  vivify_193:
    set $P247, $P246["comp_unit"]
    unless_null $P247, vivify_194
    new $P247, "Undef"
  vivify_194:
    $P248 = $P247."ast"()
    $P249 = $P245."!make"($P248)
    .return ($P249)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("26_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_251
    .param pmc param_252
.annotate 'line', 35
    .lex "self", param_251
    .lex "$/", param_252
.annotate 'line', 36
    find_lex $P253, "$/"
.annotate 'line', 37
    find_lex $P256, "$/"
    unless_null $P256, vivify_195
    $P256 = root_new ['parrot';'Hash']
  vivify_195:
    set $P257, $P256["colonpair"]
    unless_null $P257, vivify_196
    new $P257, "Undef"
  vivify_196:
    if $P257, if_255
.annotate 'line', 39
    find_lex $P277, "$/"
    set $S278, $P277
    new $P254, 'String'
    set $P254, $S278
.annotate 'line', 37
    goto if_255_end
  if_255:
    find_lex $P258, "$/"
    unless_null $P258, vivify_197
    $P258 = root_new ['parrot';'Hash']
  vivify_197:
    set $P259, $P258["identifier"]
    unless_null $P259, vivify_198
    new $P259, "Undef"
  vivify_198:
    set $S260, $P259
    new $P261, 'String'
    set $P261, $S260
    concat $P262, $P261, ":"
    find_lex $P263, "$/"
    unless_null $P263, vivify_199
    $P263 = root_new ['parrot';'Hash']
  vivify_199:
    set $P264, $P263["colonpair"]
    unless_null $P264, vivify_200
    $P264 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P265, $P264[0]
    unless_null $P265, vivify_201
    new $P265, "Undef"
  vivify_201:
    $P266 = $P265."ast"()
    $S267 = $P266."named"()
    concat $P268, $P262, $S267
    concat $P269, $P268, "<"
.annotate 'line', 38
    find_lex $P270, "$/"
    unless_null $P270, vivify_202
    $P270 = root_new ['parrot';'Hash']
  vivify_202:
    set $P271, $P270["colonpair"]
    unless_null $P271, vivify_203
    $P271 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P272, $P271[0]
    unless_null $P272, vivify_204
    new $P272, "Undef"
  vivify_204:
    $P273 = $P272."ast"()
    $S274 = "colonpair_str"($P273)
    concat $P275, $P269, $S274
    concat $P276, $P275, ">"
    set $P254, $P276
  if_255_end:
.annotate 'line', 37
    $P279 = $P253."!make"($P254)
.annotate 'line', 35
    .return ($P279)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("27_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_282
    .param pmc param_283
.annotate 'line', 49
    .lex "self", param_282
    .lex "$/", param_283
.annotate 'line', 50
    new $P284, "Undef"
    .lex "$mainline", $P284
.annotate 'line', 51
    new $P285, "Undef"
    .lex "$unit", $P285
.annotate 'line', 50
    find_lex $P286, "$/"
    unless_null $P286, vivify_205
    $P286 = root_new ['parrot';'Hash']
  vivify_205:
    set $P287, $P286["statementlist"]
    unless_null $P287, vivify_206
    new $P287, "Undef"
  vivify_206:
    $P288 = $P287."ast"()
    store_lex "$mainline", $P288
.annotate 'line', 51
    get_global $P289, "@BLOCK"
    $P290 = $P289."shift"()
    store_lex "$unit", $P290
.annotate 'line', 56
    find_dynamic_lex $P292, "$*HAS_YOU_ARE_HERE"
    unless_null $P292, vivify_207
    get_hll_global $P292, "$HAS_YOU_ARE_HERE"
    unless_null $P292, vivify_208
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_208:
  vivify_207:
    if $P292, unless_291_end
.annotate 'line', 57
    find_lex $P293, "$unit"
    find_lex $P294, "self"
    $P295 = $P294."CTXSAVE"()
    $P293."push"($P295)
  unless_291_end:
.annotate 'line', 61
    find_lex $P296, "$unit"
    $P296."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 62
    find_lex $P297, "$unit"
    get_hll_global $P298, ["PAST"], "Op"
.annotate 'line', 64
    get_hll_global $P299, ["PAST"], "Op"
    $P300 = $P299."new"("getinterp P" :named("pirop"))
.annotate 'line', 65
    get_hll_global $P301, ["PAST"], "Op"
    $P302 = $P301."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 66
    get_hll_global $P303, ["PAST"], "Op"
    $P304 = $P303."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P305 = $P298."new"($P300, $P302, $P304, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 62
    $P297."unshift"($P305)
.annotate 'line', 68
    find_lex $P306, "$unit"
    get_hll_global $P307, ["PAST"], "Op"
    $P308 = $P307."new"("nqp_dynop_setup v" :named("pirop"))
    $P306."unshift"($P308)
.annotate 'line', 73
    find_lex $P309, "$unit"
.annotate 'line', 74
    get_hll_global $P310, ["PAST"], "Op"
    find_lex $P311, "$mainline"
    $P312 = $P310."new"($P311, "return" :named("pirop"))
    $P309."push"($P312)
.annotate 'line', 79
    find_lex $P313, "$unit"
.annotate 'line', 80
    get_hll_global $P314, ["PAST"], "Block"
.annotate 'line', 82
    get_hll_global $P315, ["PAST"], "Op"
    get_hll_global $P316, ["PAST"], "Val"
    find_lex $P317, "$unit"
    $P318 = $P316."new"($P317 :named("value"))
    $P319 = $P315."new"($P318, "call" :named("pasttype"))
    $P320 = $P314."new"($P319, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 80
    $P313."push"($P320)
.annotate 'line', 85
    find_lex $P321, "$unit"
    find_lex $P322, "$/"
    $P321."node"($P322)
.annotate 'line', 88
    find_lex $P323, "$unit"
    $P323."hll"("nqp")
.annotate 'line', 90
    find_lex $P324, "$/"
    find_lex $P325, "$unit"
    $P326 = $P324."!make"($P325)
.annotate 'line', 49
    .return ($P326)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("28_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_328
    .param pmc param_329
.annotate 'line', 93
    .const 'Sub' $P343 = "29_1299465732.713" 
    capture_lex $P343
    .lex "self", param_328
    .lex "$/", param_329
.annotate 'line', 94
    new $P330, "Undef"
    .lex "$past", $P330
    get_hll_global $P331, ["PAST"], "Stmts"
    find_lex $P332, "$/"
    $P333 = $P331."new"($P332 :named("node"))
    store_lex "$past", $P333
.annotate 'line', 95
    find_lex $P335, "$/"
    unless_null $P335, vivify_209
    $P335 = root_new ['parrot';'Hash']
  vivify_209:
    set $P336, $P335["statement"]
    unless_null $P336, vivify_210
    new $P336, "Undef"
  vivify_210:
    unless $P336, if_334_end
.annotate 'line', 96
    find_lex $P338, "$/"
    unless_null $P338, vivify_211
    $P338 = root_new ['parrot';'Hash']
  vivify_211:
    set $P339, $P338["statement"]
    unless_null $P339, vivify_212
    new $P339, "Undef"
  vivify_212:
    defined $I340, $P339
    unless $I340, for_undef_213
    iter $P337, $P339
    new $P363, 'ExceptionHandler'
    set_label $P363, loop362_handler
    $P363."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P363
  loop362_test:
    unless $P337, loop362_done
    shift $P341, $P337
  loop362_redo:
    .const 'Sub' $P343 = "29_1299465732.713" 
    capture_lex $P343
    $P343($P341)
  loop362_next:
    goto loop362_test
  loop362_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P364, exception, 'type'
    eq $P364, .CONTROL_LOOP_NEXT, loop362_next
    eq $P364, .CONTROL_LOOP_REDO, loop362_redo
  loop362_done:
    pop_eh 
  for_undef_213:
  if_334_end:
.annotate 'line', 103
    find_lex $P365, "$/"
    find_lex $P366, "$past"
    $P367 = $P365."!make"($P366)
.annotate 'line', 93
    .return ($P367)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block342"  :anon :subid("29_1299465732.713") :outer("28_1299465732.713")
    .param pmc param_345
.annotate 'line', 97
    new $P344, "Undef"
    .lex "$ast", $P344
    .lex "$_", param_345
    find_lex $P346, "$_"
    $P347 = $P346."ast"()
    store_lex "$ast", $P347
.annotate 'line', 98
    find_lex $P349, "$ast"
    unless_null $P349, vivify_214
    $P349 = root_new ['parrot';'Hash']
  vivify_214:
    set $P350, $P349["sink"]
    unless_null $P350, vivify_215
    new $P350, "Undef"
  vivify_215:
    defined $I351, $P350
    unless $I351, if_348_end
    find_lex $P352, "$ast"
    unless_null $P352, vivify_216
    $P352 = root_new ['parrot';'Hash']
  vivify_216:
    set $P353, $P352["sink"]
    unless_null $P353, vivify_217
    new $P353, "Undef"
  vivify_217:
    store_lex "$ast", $P353
  if_348_end:
.annotate 'line', 99
    find_lex $P355, "$ast"
    unless_null $P355, vivify_218
    $P355 = root_new ['parrot';'Hash']
  vivify_218:
    set $P356, $P355["bareblock"]
    unless_null $P356, vivify_219
    new $P356, "Undef"
  vivify_219:
    unless $P356, if_354_end
    find_lex $P357, "$ast"
    $P358 = "block_immediate"($P357)
    store_lex "$ast", $P358
  if_354_end:
.annotate 'line', 100
    find_lex $P359, "$past"
    find_lex $P360, "$ast"
    $P361 = $P359."push"($P360)
.annotate 'line', 96
    .return ($P361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("30_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_369
    .param pmc param_370
    .param pmc param_371 :optional
    .param int has_param_371 :opt_flag
.annotate 'line', 106
    .const 'Sub' $P379 = "31_1299465732.713" 
    capture_lex $P379
    .lex "self", param_369
    .lex "$/", param_370
    if has_param_371, optparam_220
    new $P372, "Undef"
    set param_371, $P372
  optparam_220:
    .lex "$key", param_371
.annotate 'line', 107
    new $P373, "Undef"
    .lex "$past", $P373
.annotate 'line', 106
    find_lex $P374, "$past"
.annotate 'line', 108
    find_lex $P376, "$/"
    unless_null $P376, vivify_221
    $P376 = root_new ['parrot';'Hash']
  vivify_221:
    set $P377, $P376["EXPR"]
    unless_null $P377, vivify_222
    new $P377, "Undef"
  vivify_222:
    if $P377, if_375
.annotate 'line', 129
    find_lex $P440, "$/"
    unless_null $P440, vivify_223
    $P440 = root_new ['parrot';'Hash']
  vivify_223:
    set $P441, $P440["statement_control"]
    unless_null $P441, vivify_224
    new $P441, "Undef"
  vivify_224:
    if $P441, if_439
.annotate 'line', 130
    new $P445, "Integer"
    assign $P445, 0
    store_lex "$past", $P445
    goto if_439_end
  if_439:
.annotate 'line', 129
    find_lex $P442, "$/"
    unless_null $P442, vivify_225
    $P442 = root_new ['parrot';'Hash']
  vivify_225:
    set $P443, $P442["statement_control"]
    unless_null $P443, vivify_226
    new $P443, "Undef"
  vivify_226:
    $P444 = $P443."ast"()
    store_lex "$past", $P444
  if_439_end:
    goto if_375_end
  if_375:
.annotate 'line', 108
    .const 'Sub' $P379 = "31_1299465732.713" 
    capture_lex $P379
    $P379()
  if_375_end:
.annotate 'line', 131
    find_lex $P446, "$/"
    find_lex $P447, "$past"
    $P448 = $P446."!make"($P447)
.annotate 'line', 106
    .return ($P448)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block378"  :anon :subid("31_1299465732.713") :outer("30_1299465732.713")
.annotate 'line', 109
    new $P380, "Undef"
    .lex "$mc", $P380
.annotate 'line', 110
    new $P381, "Undef"
    .lex "$ml", $P381
.annotate 'line', 109
    find_lex $P382, "$/"
    unless_null $P382, vivify_227
    $P382 = root_new ['parrot';'Hash']
  vivify_227:
    set $P383, $P382["statement_mod_cond"]
    unless_null $P383, vivify_228
    $P383 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    set $P384, $P383[0]
    unless_null $P384, vivify_229
    new $P384, "Undef"
  vivify_229:
    store_lex "$mc", $P384
.annotate 'line', 110
    find_lex $P385, "$/"
    unless_null $P385, vivify_230
    $P385 = root_new ['parrot';'Hash']
  vivify_230:
    set $P386, $P385["statement_mod_loop"]
    unless_null $P386, vivify_231
    $P386 = root_new ['parrot';'ResizablePMCArray']
  vivify_231:
    set $P387, $P386[0]
    unless_null $P387, vivify_232
    new $P387, "Undef"
  vivify_232:
    store_lex "$ml", $P387
.annotate 'line', 111
    find_lex $P388, "$/"
    unless_null $P388, vivify_233
    $P388 = root_new ['parrot';'Hash']
  vivify_233:
    set $P389, $P388["EXPR"]
    unless_null $P389, vivify_234
    new $P389, "Undef"
  vivify_234:
    $P390 = $P389."ast"()
    store_lex "$past", $P390
.annotate 'line', 112
    find_lex $P392, "$mc"
    unless $P392, if_391_end
.annotate 'line', 113
    get_hll_global $P393, ["PAST"], "Op"
    find_lex $P394, "$mc"
    unless_null $P394, vivify_235
    $P394 = root_new ['parrot';'Hash']
  vivify_235:
    set $P395, $P394["cond"]
    unless_null $P395, vivify_236
    new $P395, "Undef"
  vivify_236:
    $P396 = $P395."ast"()
    find_lex $P397, "$past"
    find_lex $P398, "$mc"
    unless_null $P398, vivify_237
    $P398 = root_new ['parrot';'Hash']
  vivify_237:
    set $P399, $P398["sym"]
    unless_null $P399, vivify_238
    new $P399, "Undef"
  vivify_238:
    set $S400, $P399
    find_lex $P401, "$/"
    $P402 = $P393."new"($P396, $P397, $S400 :named("pasttype"), $P401 :named("node"))
    store_lex "$past", $P402
  if_391_end:
.annotate 'line', 115
    find_lex $P405, "$ml"
    if $P405, if_404
    set $P403, $P405
    goto if_404_end
  if_404:
.annotate 'line', 116
    find_lex $P408, "$ml"
    unless_null $P408, vivify_239
    $P408 = root_new ['parrot';'Hash']
  vivify_239:
    set $P409, $P408["sym"]
    unless_null $P409, vivify_240
    new $P409, "Undef"
  vivify_240:
    set $S410, $P409
    iseq $I411, $S410, "for"
    if $I411, if_407
.annotate 'line', 125
    get_hll_global $P429, ["PAST"], "Op"
    find_lex $P430, "$ml"
    unless_null $P430, vivify_241
    $P430 = root_new ['parrot';'Hash']
  vivify_241:
    set $P431, $P430["cond"]
    unless_null $P431, vivify_242
    new $P431, "Undef"
  vivify_242:
    $P432 = $P431."ast"()
    find_lex $P433, "$past"
    find_lex $P434, "$ml"
    unless_null $P434, vivify_243
    $P434 = root_new ['parrot';'Hash']
  vivify_243:
    set $P435, $P434["sym"]
    unless_null $P435, vivify_244
    new $P435, "Undef"
  vivify_244:
    set $S436, $P435
    find_lex $P437, "$/"
    $P438 = $P429."new"($P432, $P433, $S436 :named("pasttype"), $P437 :named("node"))
    store_lex "$past", $P438
.annotate 'line', 124
    set $P406, $P438
.annotate 'line', 116
    goto if_407_end
  if_407:
.annotate 'line', 117
    get_hll_global $P412, ["PAST"], "Block"
.annotate 'line', 118
    get_hll_global $P413, ["PAST"], "Var"
    $P414 = $P413."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P415, "$past"
    $P416 = $P412."new"($P414, $P415, "immediate" :named("blocktype"))
.annotate 'line', 117
    store_lex "$past", $P416
.annotate 'line', 120
    find_lex $P417, "$past"
    $P417."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 121
    find_lex $P418, "$past"
    $P418."arity"(1)
.annotate 'line', 122
    get_hll_global $P419, ["PAST"], "Op"
    find_lex $P420, "$ml"
    unless_null $P420, vivify_245
    $P420 = root_new ['parrot';'Hash']
  vivify_245:
    set $P421, $P420["cond"]
    unless_null $P421, vivify_246
    new $P421, "Undef"
  vivify_246:
    $P422 = $P421."ast"()
    find_lex $P423, "$past"
    find_lex $P424, "$ml"
    unless_null $P424, vivify_247
    $P424 = root_new ['parrot';'Hash']
  vivify_247:
    set $P425, $P424["sym"]
    unless_null $P425, vivify_248
    new $P425, "Undef"
  vivify_248:
    set $S426, $P425
    find_lex $P427, "$/"
    $P428 = $P419."new"($P422, $P423, $S426 :named("pasttype"), $P427 :named("node"))
    store_lex "$past", $P428
.annotate 'line', 116
    set $P406, $P428
  if_407_end:
.annotate 'line', 115
    set $P403, $P406
  if_404_end:
.annotate 'line', 108
    .return ($P403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("32_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_450
    .param pmc param_451
.annotate 'line', 134
    .lex "self", param_450
    .lex "$/", param_451
.annotate 'line', 135
    find_lex $P452, "$/"
    get_hll_global $P453, ["PAST"], "Op"
    find_lex $P454, "$/"
    unless_null $P454, vivify_249
    $P454 = root_new ['parrot';'Hash']
  vivify_249:
    set $P455, $P454["EXPR"]
    unless_null $P455, vivify_250
    new $P455, "Undef"
  vivify_250:
    $P456 = $P455."ast"()
    find_lex $P457, "$/"
    unless_null $P457, vivify_251
    $P457 = root_new ['parrot';'Hash']
  vivify_251:
    set $P458, $P457["pblock"]
    unless_null $P458, vivify_252
    new $P458, "Undef"
  vivify_252:
    $P459 = $P458."ast"()
    find_lex $P460, "$/"
    $P461 = $P453."new"($P456, $P459, "if" :named("pasttype"), $P460 :named("node"))
    $P462 = $P452."!make"($P461)
.annotate 'line', 134
    .return ($P462)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("33_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_464
    .param pmc param_465
.annotate 'line', 138
    .lex "self", param_464
    .lex "$/", param_465
.annotate 'line', 139
    find_lex $P466, "$/"
    find_lex $P467, "$/"
    unless_null $P467, vivify_253
    $P467 = root_new ['parrot';'Hash']
  vivify_253:
    set $P468, $P467["blockoid"]
    unless_null $P468, vivify_254
    new $P468, "Undef"
  vivify_254:
    $P469 = $P468."ast"()
    $P470 = $P466."!make"($P469)
.annotate 'line', 138
    .return ($P470)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("34_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_472
    .param pmc param_473
.annotate 'line', 142
    .lex "self", param_472
    .lex "$/", param_473
.annotate 'line', 143
    find_lex $P474, "$/"
    find_lex $P475, "$/"
    unless_null $P475, vivify_255
    $P475 = root_new ['parrot';'Hash']
  vivify_255:
    set $P476, $P475["blockoid"]
    unless_null $P476, vivify_256
    new $P476, "Undef"
  vivify_256:
    $P477 = $P476."ast"()
    $P478 = $P474."!make"($P477)
.annotate 'line', 142
    .return ($P478)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("35_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_480
    .param pmc param_481
.annotate 'line', 146
    .const 'Sub' $P490 = "36_1299465732.713" 
    capture_lex $P490
    .lex "self", param_480
    .lex "$/", param_481
.annotate 'line', 147
    new $P482, "Undef"
    .lex "$BLOCK", $P482
    get_global $P483, "@BLOCK"
    $P484 = $P483."shift"()
    store_lex "$BLOCK", $P484
.annotate 'line', 148
    find_lex $P487, "$/"
    unless_null $P487, vivify_257
    $P487 = root_new ['parrot';'Hash']
  vivify_257:
    set $P488, $P487["statementlist"]
    unless_null $P488, vivify_258
    new $P488, "Undef"
  vivify_258:
    if $P488, if_486
.annotate 'line', 156
    find_dynamic_lex $P505, "$*HAS_YOU_ARE_HERE"
    unless_null $P505, vivify_259
    get_hll_global $P505, "$HAS_YOU_ARE_HERE"
    unless_null $P505, vivify_260
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_260:
  vivify_259:
    unless $P505, if_504_end
.annotate 'line', 157
    find_lex $P506, "$/"
    $P507 = $P506."CURSOR"()
    $P507."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_504_end:
.annotate 'line', 159
    new $P508, "Integer"
    assign $P508, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P508
.annotate 'line', 160
    find_lex $P509, "$/"
    find_lex $P510, "$/"
    unless_null $P510, vivify_261
    $P510 = root_new ['parrot';'Hash']
  vivify_261:
    set $P511, $P510["you_are_here"]
    unless_null $P511, vivify_262
    new $P511, "Undef"
  vivify_262:
    $P512 = $P511."ast"()
    $P513 = $P509."!make"($P512)
.annotate 'line', 155
    set $P485, $P513
.annotate 'line', 148
    goto if_486_end
  if_486:
    .const 'Sub' $P490 = "36_1299465732.713" 
    capture_lex $P490
    $P503 = $P490()
    set $P485, $P503
  if_486_end:
.annotate 'line', 146
    .return ($P485)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block489"  :anon :subid("36_1299465732.713") :outer("35_1299465732.713")
.annotate 'line', 149
    new $P491, "Undef"
    .lex "$past", $P491
    find_lex $P492, "$/"
    unless_null $P492, vivify_263
    $P492 = root_new ['parrot';'Hash']
  vivify_263:
    set $P493, $P492["statementlist"]
    unless_null $P493, vivify_264
    new $P493, "Undef"
  vivify_264:
    $P494 = $P493."ast"()
    store_lex "$past", $P494
.annotate 'line', 150
    find_lex $P495, "$BLOCK"
    find_lex $P496, "$past"
    $P495."push"($P496)
.annotate 'line', 151
    find_lex $P497, "$BLOCK"
    find_lex $P498, "$/"
    $P497."node"($P498)
.annotate 'line', 152
    find_lex $P499, "$BLOCK"
    $P499."closure"(1)
.annotate 'line', 153
    find_dynamic_lex $P500, "$/"
    find_lex $P501, "$BLOCK"
    $P502 = $P500."!make"($P501)
.annotate 'line', 148
    .return ($P502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("37_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_515
    .param pmc param_516
.annotate 'line', 164
    .lex "self", param_515
    .lex "$/", param_516
.annotate 'line', 165
    get_global $P517, "@BLOCK"
    unless_null $P517, vivify_265
    $P517 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P517
  vivify_265:
.annotate 'line', 164
    get_global $P518, "@BLOCK"
.annotate 'line', 166
    get_global $P519, "@BLOCK"
    get_hll_global $P520, ["PAST"], "Block"
    get_hll_global $P521, ["PAST"], "Stmts"
    $P522 = $P521."new"()
    $P523 = $P520."new"($P522)
    $P524 = $P519."unshift"($P523)
.annotate 'line', 164
    .return ($P524)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("38_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_526
    .param pmc param_527
.annotate 'line', 169
    .lex "self", param_526
    .lex "$/", param_527
.annotate 'line', 170
    get_global $P528, "@BLOCK"
    unless_null $P528, vivify_266
    $P528 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P528
  vivify_266:
.annotate 'line', 169
    get_global $P529, "@BLOCK"
.annotate 'line', 171
    find_dynamic_lex $P531, "%*COMPILING"
    unless_null $P531, vivify_267
    get_hll_global $P531, "%COMPILING"
    unless_null $P531, vivify_268
    die "Contextual %*COMPILING not found"
  vivify_268:
  vivify_267:
    set $P532, $P531["%?OPTIONS"]
    unless_null $P532, vivify_269
    $P532 = root_new ['parrot';'Hash']
  vivify_269:
    set $P533, $P532["outer_ctx"]
    unless_null $P533, vivify_270
    new $P533, "Undef"
  vivify_270:
    defined $I534, $P533
    if $I534, unless_530_end
.annotate 'line', 174
    compreg $P535, "nqp"
    find_dynamic_lex $P537, "%*COMPILING"
    unless_null $P537, vivify_271
    get_hll_global $P537, "%COMPILING"
    unless_null $P537, vivify_272
    die "Contextual %*COMPILING not found"
  vivify_272:
  vivify_271:
    set $P538, $P537["%?OPTIONS"]
    unless_null $P538, vivify_273
    $P538 = root_new ['parrot';'Hash']
  vivify_273:
    set $P539, $P538["setting"]
    unless_null $P539, vivify_274
    new $P539, "Undef"
  vivify_274:
    set $P536, $P539
    defined $I541, $P536
    if $I541, default_540
    new $P542, "String"
    assign $P542, "NQPCORE"
    set $P536, $P542
  default_540:
    $P535."load_setting"($P536)
  unless_530_end:
.annotate 'line', 176
    find_lex $P543, "self"
    get_global $P544, "@BLOCK"
    unless_null $P544, vivify_275
    $P544 = root_new ['parrot';'ResizablePMCArray']
  vivify_275:
    set $P545, $P544[0]
    unless_null $P545, vivify_276
    new $P545, "Undef"
  vivify_276:
    $P546 = $P543."SET_BLOCK_OUTER_CTX"($P545)
.annotate 'line', 169
    .return ($P546)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("39_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_548
    .param pmc param_549
.annotate 'line', 179
    .lex "self", param_548
    .lex "$/", param_549
.annotate 'line', 180
    find_lex $P550, "$/"
    find_lex $P551, "self"
    $P552 = $P551."CTXSAVE"()
    $P553 = $P550."!make"($P552)
.annotate 'line', 179
    .return ($P553)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("40_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_555
    .param pmc param_556
.annotate 'line', 185
    .const 'Sub' $P584 = "41_1299465732.713" 
    capture_lex $P584
    .lex "self", param_555
    .lex "$/", param_556
.annotate 'line', 186
    new $P557, "Undef"
    .lex "$count", $P557
.annotate 'line', 187
    new $P558, "Undef"
    .lex "$past", $P558
.annotate 'line', 186
    find_lex $P559, "$/"
    unless_null $P559, vivify_277
    $P559 = root_new ['parrot';'Hash']
  vivify_277:
    set $P560, $P559["xblock"]
    unless_null $P560, vivify_278
    new $P560, "Undef"
  vivify_278:
    set $N561, $P560
    new $P562, 'Float'
    set $P562, $N561
    sub $P563, $P562, 1
    store_lex "$count", $P563
.annotate 'line', 187
    find_lex $P564, "$count"
    set $I565, $P564
    find_lex $P566, "$/"
    unless_null $P566, vivify_279
    $P566 = root_new ['parrot';'Hash']
  vivify_279:
    set $P567, $P566["xblock"]
    unless_null $P567, vivify_280
    $P567 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $P568, $P567[$I565]
    unless_null $P568, vivify_281
    new $P568, "Undef"
  vivify_281:
    $P569 = $P568."ast"()
    $P570 = "xblock_immediate"($P569)
    store_lex "$past", $P570
.annotate 'line', 188
    find_lex $P572, "$/"
    unless_null $P572, vivify_282
    $P572 = root_new ['parrot';'Hash']
  vivify_282:
    set $P573, $P572["else"]
    unless_null $P573, vivify_283
    new $P573, "Undef"
  vivify_283:
    unless $P573, if_571_end
.annotate 'line', 189
    find_lex $P574, "$past"
    find_lex $P575, "$/"
    unless_null $P575, vivify_284
    $P575 = root_new ['parrot';'Hash']
  vivify_284:
    set $P576, $P575["else"]
    unless_null $P576, vivify_285
    $P576 = root_new ['parrot';'ResizablePMCArray']
  vivify_285:
    set $P577, $P576[0]
    unless_null $P577, vivify_286
    new $P577, "Undef"
  vivify_286:
    $P578 = $P577."ast"()
    $P579 = "block_immediate"($P578)
    $P574."push"($P579)
  if_571_end:
.annotate 'line', 192
    new $P600, 'ExceptionHandler'
    set_label $P600, loop599_handler
    $P600."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P600
  loop599_test:
    find_lex $P580, "$count"
    set $N581, $P580
    isgt $I582, $N581, 0.0
    unless $I582, loop599_done
  loop599_redo:
    .const 'Sub' $P584 = "41_1299465732.713" 
    capture_lex $P584
    $P584()
  loop599_next:
    goto loop599_test
  loop599_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P601, exception, 'type'
    eq $P601, .CONTROL_LOOP_NEXT, loop599_next
    eq $P601, .CONTROL_LOOP_REDO, loop599_redo
  loop599_done:
    pop_eh 
.annotate 'line', 198
    find_lex $P602, "$/"
    find_lex $P603, "$past"
    $P604 = $P602."!make"($P603)
.annotate 'line', 185
    .return ($P604)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block583"  :anon :subid("41_1299465732.713") :outer("40_1299465732.713")
.annotate 'line', 194
    new $P585, "Undef"
    .lex "$else", $P585
.annotate 'line', 192
    find_lex $P586, "$count"
    clone $P587, $P586
    dec $P586
.annotate 'line', 194
    find_lex $P588, "$past"
    store_lex "$else", $P588
.annotate 'line', 195
    find_lex $P589, "$count"
    set $I590, $P589
    find_lex $P591, "$/"
    unless_null $P591, vivify_287
    $P591 = root_new ['parrot';'Hash']
  vivify_287:
    set $P592, $P591["xblock"]
    unless_null $P592, vivify_288
    $P592 = root_new ['parrot';'ResizablePMCArray']
  vivify_288:
    set $P593, $P592[$I590]
    unless_null $P593, vivify_289
    new $P593, "Undef"
  vivify_289:
    $P594 = $P593."ast"()
    $P595 = "xblock_immediate"($P594)
    store_lex "$past", $P595
.annotate 'line', 196
    find_lex $P596, "$past"
    find_lex $P597, "$else"
    $P598 = $P596."push"($P597)
.annotate 'line', 192
    .return ($P598)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("42_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_606
    .param pmc param_607
.annotate 'line', 201
    .lex "self", param_606
    .lex "$/", param_607
.annotate 'line', 202
    new $P608, "Undef"
    .lex "$past", $P608
    find_lex $P609, "$/"
    unless_null $P609, vivify_290
    $P609 = root_new ['parrot';'Hash']
  vivify_290:
    set $P610, $P609["xblock"]
    unless_null $P610, vivify_291
    new $P610, "Undef"
  vivify_291:
    $P611 = $P610."ast"()
    $P612 = "xblock_immediate"($P611)
    store_lex "$past", $P612
.annotate 'line', 203
    find_lex $P613, "$past"
    $P613."pasttype"("unless")
.annotate 'line', 204
    find_lex $P614, "$/"
    find_lex $P615, "$past"
    $P616 = $P614."!make"($P615)
.annotate 'line', 201
    .return ($P616)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("43_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_618
    .param pmc param_619
.annotate 'line', 207
    .lex "self", param_618
    .lex "$/", param_619
.annotate 'line', 208
    new $P620, "Undef"
    .lex "$past", $P620
    find_lex $P621, "$/"
    unless_null $P621, vivify_292
    $P621 = root_new ['parrot';'Hash']
  vivify_292:
    set $P622, $P621["xblock"]
    unless_null $P622, vivify_293
    new $P622, "Undef"
  vivify_293:
    $P623 = $P622."ast"()
    $P624 = "xblock_immediate"($P623)
    store_lex "$past", $P624
.annotate 'line', 209
    find_lex $P625, "$past"
    find_lex $P626, "$/"
    unless_null $P626, vivify_294
    $P626 = root_new ['parrot';'Hash']
  vivify_294:
    set $P627, $P626["sym"]
    unless_null $P627, vivify_295
    new $P627, "Undef"
  vivify_295:
    set $S628, $P627
    $P625."pasttype"($S628)
.annotate 'line', 210
    find_lex $P629, "$/"
    find_lex $P630, "$past"
    $P631 = $P629."!make"($P630)
.annotate 'line', 207
    .return ($P631)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("44_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_633
    .param pmc param_634
.annotate 'line', 213
    .lex "self", param_633
    .lex "$/", param_634
.annotate 'line', 214
    new $P635, "Undef"
    .lex "$pasttype", $P635
.annotate 'line', 215
    new $P636, "Undef"
    .lex "$past", $P636
.annotate 'line', 214
    new $P637, "String"
    assign $P637, "repeat_"
    find_lex $P638, "$/"
    unless_null $P638, vivify_296
    $P638 = root_new ['parrot';'Hash']
  vivify_296:
    set $P639, $P638["wu"]
    unless_null $P639, vivify_297
    new $P639, "Undef"
  vivify_297:
    set $S640, $P639
    concat $P641, $P637, $S640
    store_lex "$pasttype", $P641
    find_lex $P642, "$past"
.annotate 'line', 216
    find_lex $P644, "$/"
    unless_null $P644, vivify_298
    $P644 = root_new ['parrot';'Hash']
  vivify_298:
    set $P645, $P644["xblock"]
    unless_null $P645, vivify_299
    new $P645, "Undef"
  vivify_299:
    if $P645, if_643
.annotate 'line', 221
    get_hll_global $P652, ["PAST"], "Op"
    find_lex $P653, "$/"
    unless_null $P653, vivify_300
    $P653 = root_new ['parrot';'Hash']
  vivify_300:
    set $P654, $P653["EXPR"]
    unless_null $P654, vivify_301
    new $P654, "Undef"
  vivify_301:
    $P655 = $P654."ast"()
    find_lex $P656, "$/"
    unless_null $P656, vivify_302
    $P656 = root_new ['parrot';'Hash']
  vivify_302:
    set $P657, $P656["pblock"]
    unless_null $P657, vivify_303
    new $P657, "Undef"
  vivify_303:
    $P658 = $P657."ast"()
    $P659 = "block_immediate"($P658)
    find_lex $P660, "$pasttype"
    find_lex $P661, "$/"
    $P662 = $P652."new"($P655, $P659, $P660 :named("pasttype"), $P661 :named("node"))
    store_lex "$past", $P662
.annotate 'line', 220
    goto if_643_end
  if_643:
.annotate 'line', 217
    find_lex $P646, "$/"
    unless_null $P646, vivify_304
    $P646 = root_new ['parrot';'Hash']
  vivify_304:
    set $P647, $P646["xblock"]
    unless_null $P647, vivify_305
    new $P647, "Undef"
  vivify_305:
    $P648 = $P647."ast"()
    $P649 = "xblock_immediate"($P648)
    store_lex "$past", $P649
.annotate 'line', 218
    find_lex $P650, "$past"
    find_lex $P651, "$pasttype"
    $P650."pasttype"($P651)
  if_643_end:
.annotate 'line', 224
    find_lex $P663, "$/"
    find_lex $P664, "$past"
    $P665 = $P663."!make"($P664)
.annotate 'line', 213
    .return ($P665)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("45_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_667
    .param pmc param_668
.annotate 'line', 227
    .lex "self", param_667
    .lex "$/", param_668
.annotate 'line', 228
    new $P669, "Undef"
    .lex "$past", $P669
.annotate 'line', 230
    new $P670, "Undef"
    .lex "$block", $P670
.annotate 'line', 228
    find_lex $P671, "$/"
    unless_null $P671, vivify_306
    $P671 = root_new ['parrot';'Hash']
  vivify_306:
    set $P672, $P671["xblock"]
    unless_null $P672, vivify_307
    new $P672, "Undef"
  vivify_307:
    $P673 = $P672."ast"()
    store_lex "$past", $P673
.annotate 'line', 229
    find_lex $P674, "$past"
    $P674."pasttype"("for")
.annotate 'line', 230
    find_lex $P675, "$past"
    unless_null $P675, vivify_308
    $P675 = root_new ['parrot';'ResizablePMCArray']
  vivify_308:
    set $P676, $P675[1]
    unless_null $P676, vivify_309
    new $P676, "Undef"
  vivify_309:
    store_lex "$block", $P676
.annotate 'line', 231
    find_lex $P678, "$block"
    $P679 = $P678."arity"()
    if $P679, unless_677_end
.annotate 'line', 232
    find_lex $P680, "$block"
    unless_null $P680, vivify_310
    $P680 = root_new ['parrot';'ResizablePMCArray']
  vivify_310:
    set $P681, $P680[0]
    unless_null $P681, vivify_311
    new $P681, "Undef"
  vivify_311:
    get_hll_global $P682, ["PAST"], "Var"
    $P683 = $P682."new"("$_" :named("name"), "parameter" :named("scope"))
    $P681."push"($P683)
.annotate 'line', 233
    find_lex $P684, "$block"
    $P684."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 234
    find_lex $P685, "$block"
    $P685."arity"(1)
  unless_677_end:
.annotate 'line', 236
    find_lex $P686, "$block"
    $P686."blocktype"("immediate")
.annotate 'line', 237
    find_lex $P687, "$/"
    find_lex $P688, "$past"
    $P689 = $P687."!make"($P688)
.annotate 'line', 227
    .return ($P689)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("46_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_691
    .param pmc param_692
.annotate 'line', 240
    .lex "self", param_691
    .lex "$/", param_692
.annotate 'line', 241
    new $P693, "Undef"
    .lex "$block", $P693
    find_lex $P694, "$/"
    unless_null $P694, vivify_312
    $P694 = root_new ['parrot';'Hash']
  vivify_312:
    set $P695, $P694["block"]
    unless_null $P695, vivify_313
    new $P695, "Undef"
  vivify_313:
    $P696 = $P695."ast"()
    store_lex "$block", $P696
.annotate 'line', 242
    find_lex $P697, "$/"
    find_lex $P698, "$block"
    "push_block_handler"($P697, $P698)
.annotate 'line', 243
    get_global $P699, "@BLOCK"
    unless_null $P699, vivify_314
    $P699 = root_new ['parrot';'ResizablePMCArray']
  vivify_314:
    set $P700, $P699[0]
    unless_null $P700, vivify_315
    new $P700, "Undef"
  vivify_315:
    $P701 = $P700."handlers"()
    set $P702, $P701[0]
    unless_null $P702, vivify_316
    new $P702, "Undef"
  vivify_316:
    $P702."handle_types_except"("CONTROL")
.annotate 'line', 244
    find_lex $P703, "$/"
    get_hll_global $P704, ["PAST"], "Stmts"
    find_lex $P705, "$/"
    $P706 = $P704."new"($P705 :named("node"))
    $P707 = $P703."!make"($P706)
.annotate 'line', 240
    .return ($P707)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("47_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_709
    .param pmc param_710
.annotate 'line', 247
    .lex "self", param_709
    .lex "$/", param_710
.annotate 'line', 248
    new $P711, "Undef"
    .lex "$block", $P711
    find_lex $P712, "$/"
    unless_null $P712, vivify_317
    $P712 = root_new ['parrot';'Hash']
  vivify_317:
    set $P713, $P712["block"]
    unless_null $P713, vivify_318
    new $P713, "Undef"
  vivify_318:
    $P714 = $P713."ast"()
    store_lex "$block", $P714
.annotate 'line', 249
    find_lex $P715, "$/"
    find_lex $P716, "$block"
    "push_block_handler"($P715, $P716)
.annotate 'line', 250
    get_global $P717, "@BLOCK"
    unless_null $P717, vivify_319
    $P717 = root_new ['parrot';'ResizablePMCArray']
  vivify_319:
    set $P718, $P717[0]
    unless_null $P718, vivify_320
    new $P718, "Undef"
  vivify_320:
    $P719 = $P718."handlers"()
    set $P720, $P719[0]
    unless_null $P720, vivify_321
    new $P720, "Undef"
  vivify_321:
    $P720."handle_types"("CONTROL")
.annotate 'line', 251
    find_lex $P721, "$/"
    get_hll_global $P722, ["PAST"], "Stmts"
    find_lex $P723, "$/"
    $P724 = $P722."new"($P723 :named("node"))
    $P725 = $P721."!make"($P724)
.annotate 'line', 247
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("48_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_728
    .param pmc param_729
.annotate 'line', 291
    .lex "self", param_728
    .lex "$/", param_729
.annotate 'line', 292
    new $P730, "Undef"
    .lex "$init_block", $P730
    get_hll_global $P731, ["PAST"], "Block"
    $P732 = $P731."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P732
.annotate 'line', 293
    find_lex $P733, "$init_block"
    $P734 = $P733."loadinit"()
    find_lex $P735, "$/"
    unless_null $P735, vivify_322
    $P735 = root_new ['parrot';'Hash']
  vivify_322:
    set $P736, $P735["blorst"]
    unless_null $P736, vivify_323
    new $P736, "Undef"
  vivify_323:
    $P737 = $P736."ast"()
    $P734."push"($P737)
.annotate 'line', 294
    find_lex $P738, "$/"
    find_lex $P739, "$init_block"
    $P740 = $P738."!make"($P739)
.annotate 'line', 291
    .return ($P740)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("49_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_742
    .param pmc param_743
.annotate 'line', 297
    .lex "self", param_742
    .lex "$/", param_743
.annotate 'line', 298
    new $P744, "Undef"
    .lex "$past", $P744
    find_lex $P745, "$/"
    unless_null $P745, vivify_324
    $P745 = root_new ['parrot';'Hash']
  vivify_324:
    set $P746, $P745["blorst"]
    unless_null $P746, vivify_325
    new $P746, "Undef"
  vivify_325:
    $P747 = $P746."ast"()
    store_lex "$past", $P747
.annotate 'line', 299
    get_hll_global $P749, ["PAST"], "Block"
    find_lex $P750, "$past"
    $P751 = $P749."ACCEPTS"($P750)
    if $P751, unless_748_end
.annotate 'line', 300
    get_hll_global $P752, ["PAST"], "Block"
    find_lex $P753, "$past"
    find_lex $P754, "$/"
    $P755 = $P752."new"($P753, "immediate" :named("blocktype"), $P754 :named("node"))
    store_lex "$past", $P755
  unless_748_end:
.annotate 'line', 302
    find_lex $P757, "$past"
    $P758 = $P757."handlers"()
    if $P758, unless_756_end
.annotate 'line', 303
    find_lex $P759, "$past"
    get_hll_global $P760, ["PAST"], "Control"
.annotate 'line', 305
    get_hll_global $P761, ["PAST"], "Stmts"
.annotate 'line', 306
    get_hll_global $P762, ["PAST"], "Op"
.annotate 'line', 307
    get_hll_global $P763, ["PAST"], "Var"
.annotate 'line', 308
    get_hll_global $P764, ["PAST"], "Var"
    $P765 = $P764."new"("register" :named("scope"), "exception" :named("name"))
    $P766 = $P763."new"($P765, "handled", "keyed" :named("scope"))
.annotate 'line', 307
    $P767 = $P762."new"($P766, 1, "bind" :named("pasttype"))
.annotate 'line', 306
    $P768 = $P761."new"($P767)
.annotate 'line', 305
    $P769 = $P760."new"($P768, "CONTROL" :named("handle_types_except"))
.annotate 'line', 303
    new $P770, "ResizablePMCArray"
    push $P770, $P769
    $P759."handlers"($P770)
  unless_756_end:
.annotate 'line', 317
    find_lex $P771, "$/"
    find_lex $P772, "$past"
    $P773 = $P771."!make"($P772)
.annotate 'line', 297
    .return ($P773)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("50_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_775
    .param pmc param_776
.annotate 'line', 320
    .lex "self", param_775
    .lex "$/", param_776
.annotate 'line', 321
    find_lex $P777, "$/"
.annotate 'line', 322
    find_lex $P780, "$/"
    unless_null $P780, vivify_326
    $P780 = root_new ['parrot';'Hash']
  vivify_326:
    set $P781, $P780["block"]
    unless_null $P781, vivify_327
    new $P781, "Undef"
  vivify_327:
    if $P781, if_779
.annotate 'line', 323
    find_lex $P786, "$/"
    unless_null $P786, vivify_328
    $P786 = root_new ['parrot';'Hash']
  vivify_328:
    set $P787, $P786["statement"]
    unless_null $P787, vivify_329
    new $P787, "Undef"
  vivify_329:
    $P788 = $P787."ast"()
    set $P778, $P788
.annotate 'line', 322
    goto if_779_end
  if_779:
    find_lex $P782, "$/"
    unless_null $P782, vivify_330
    $P782 = root_new ['parrot';'Hash']
  vivify_330:
    set $P783, $P782["block"]
    unless_null $P783, vivify_331
    new $P783, "Undef"
  vivify_331:
    $P784 = $P783."ast"()
    $P785 = "block_immediate"($P784)
    set $P778, $P785
  if_779_end:
    $P789 = $P777."!make"($P778)
.annotate 'line', 320
    .return ($P789)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("51_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_791
    .param pmc param_792
.annotate 'line', 328
    .lex "self", param_791
    .lex "$/", param_792
    find_lex $P793, "$/"
    find_lex $P794, "$/"
    unless_null $P794, vivify_332
    $P794 = root_new ['parrot';'Hash']
  vivify_332:
    set $P795, $P794["cond"]
    unless_null $P795, vivify_333
    new $P795, "Undef"
  vivify_333:
    $P796 = $P795."ast"()
    $P797 = $P793."!make"($P796)
    .return ($P797)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("52_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_799
    .param pmc param_800
.annotate 'line', 329
    .lex "self", param_799
    .lex "$/", param_800
    find_lex $P801, "$/"
    find_lex $P802, "$/"
    unless_null $P802, vivify_334
    $P802 = root_new ['parrot';'Hash']
  vivify_334:
    set $P803, $P802["cond"]
    unless_null $P803, vivify_335
    new $P803, "Undef"
  vivify_335:
    $P804 = $P803."ast"()
    $P805 = $P801."!make"($P804)
    .return ($P805)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("53_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_807
    .param pmc param_808
.annotate 'line', 331
    .lex "self", param_807
    .lex "$/", param_808
    find_lex $P809, "$/"
    find_lex $P810, "$/"
    unless_null $P810, vivify_336
    $P810 = root_new ['parrot';'Hash']
  vivify_336:
    set $P811, $P810["cond"]
    unless_null $P811, vivify_337
    new $P811, "Undef"
  vivify_337:
    $P812 = $P811."ast"()
    $P813 = $P809."!make"($P812)
    .return ($P813)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("54_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_815
    .param pmc param_816
.annotate 'line', 332
    .lex "self", param_815
    .lex "$/", param_816
    find_lex $P817, "$/"
    find_lex $P818, "$/"
    unless_null $P818, vivify_338
    $P818 = root_new ['parrot';'Hash']
  vivify_338:
    set $P819, $P818["cond"]
    unless_null $P819, vivify_339
    new $P819, "Undef"
  vivify_339:
    $P820 = $P819."ast"()
    $P821 = $P817."!make"($P820)
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("55_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_823
    .param pmc param_824
.annotate 'line', 336
    .lex "self", param_823
    .lex "$/", param_824
    find_lex $P825, "$/"
    find_lex $P826, "$/"
    unless_null $P826, vivify_340
    $P826 = root_new ['parrot';'Hash']
  vivify_340:
    set $P827, $P826["fatarrow"]
    unless_null $P827, vivify_341
    new $P827, "Undef"
  vivify_341:
    $P828 = $P827."ast"()
    $P829 = $P825."!make"($P828)
    .return ($P829)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("56_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_831
    .param pmc param_832
.annotate 'line', 337
    .lex "self", param_831
    .lex "$/", param_832
    find_lex $P833, "$/"
    find_lex $P834, "$/"
    unless_null $P834, vivify_342
    $P834 = root_new ['parrot';'Hash']
  vivify_342:
    set $P835, $P834["colonpair"]
    unless_null $P835, vivify_343
    new $P835, "Undef"
  vivify_343:
    $P836 = $P835."ast"()
    $P837 = $P833."!make"($P836)
    .return ($P837)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("57_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_839
    .param pmc param_840
.annotate 'line', 338
    .lex "self", param_839
    .lex "$/", param_840
    find_lex $P841, "$/"
    find_lex $P842, "$/"
    unless_null $P842, vivify_344
    $P842 = root_new ['parrot';'Hash']
  vivify_344:
    set $P843, $P842["variable"]
    unless_null $P843, vivify_345
    new $P843, "Undef"
  vivify_345:
    $P844 = $P843."ast"()
    $P845 = $P841."!make"($P844)
    .return ($P845)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("58_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_847
    .param pmc param_848
.annotate 'line', 339
    .lex "self", param_847
    .lex "$/", param_848
    find_lex $P849, "$/"
    find_lex $P850, "$/"
    unless_null $P850, vivify_346
    $P850 = root_new ['parrot';'Hash']
  vivify_346:
    set $P851, $P850["package_declarator"]
    unless_null $P851, vivify_347
    new $P851, "Undef"
  vivify_347:
    $P852 = $P851."ast"()
    $P853 = $P849."!make"($P852)
    .return ($P853)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("59_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_855
    .param pmc param_856
.annotate 'line', 340
    .lex "self", param_855
    .lex "$/", param_856
    find_lex $P857, "$/"
    find_lex $P858, "$/"
    unless_null $P858, vivify_348
    $P858 = root_new ['parrot';'Hash']
  vivify_348:
    set $P859, $P858["scope_declarator"]
    unless_null $P859, vivify_349
    new $P859, "Undef"
  vivify_349:
    $P860 = $P859."ast"()
    $P861 = $P857."!make"($P860)
    .return ($P861)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("60_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_863
    .param pmc param_864
.annotate 'line', 341
    .lex "self", param_863
    .lex "$/", param_864
    find_lex $P865, "$/"
    find_lex $P866, "$/"
    unless_null $P866, vivify_350
    $P866 = root_new ['parrot';'Hash']
  vivify_350:
    set $P867, $P866["routine_declarator"]
    unless_null $P867, vivify_351
    new $P867, "Undef"
  vivify_351:
    $P868 = $P867."ast"()
    $P869 = $P865."!make"($P868)
    .return ($P869)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("61_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_871
    .param pmc param_872
.annotate 'line', 342
    .lex "self", param_871
    .lex "$/", param_872
    find_lex $P873, "$/"
    find_lex $P874, "$/"
    unless_null $P874, vivify_352
    $P874 = root_new ['parrot';'Hash']
  vivify_352:
    set $P875, $P874["regex_declarator"]
    unless_null $P875, vivify_353
    new $P875, "Undef"
  vivify_353:
    $P876 = $P875."ast"()
    $P877 = $P873."!make"($P876)
    .return ($P877)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("62_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_879
    .param pmc param_880
.annotate 'line', 343
    .lex "self", param_879
    .lex "$/", param_880
    find_lex $P881, "$/"
    find_lex $P882, "$/"
    unless_null $P882, vivify_354
    $P882 = root_new ['parrot';'Hash']
  vivify_354:
    set $P883, $P882["statement_prefix"]
    unless_null $P883, vivify_355
    new $P883, "Undef"
  vivify_355:
    $P884 = $P883."ast"()
    $P885 = $P881."!make"($P884)
    .return ($P885)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("63_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_887
    .param pmc param_888
.annotate 'line', 344
    .lex "self", param_887
    .lex "$/", param_888
    find_lex $P889, "$/"
    find_lex $P890, "$/"
    unless_null $P890, vivify_356
    $P890 = root_new ['parrot';'Hash']
  vivify_356:
    set $P891, $P890["pblock"]
    unless_null $P891, vivify_357
    new $P891, "Undef"
  vivify_357:
    $P892 = $P891."ast"()
    $P893 = $P889."!make"($P892)
    .return ($P893)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("64_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_895
    .param pmc param_896
.annotate 'line', 346
    .lex "self", param_895
    .lex "$/", param_896
.annotate 'line', 347
    new $P897, "Undef"
    .lex "$past", $P897
    find_lex $P898, "$/"
    unless_null $P898, vivify_358
    $P898 = root_new ['parrot';'Hash']
  vivify_358:
    set $P899, $P898["val"]
    unless_null $P899, vivify_359
    new $P899, "Undef"
  vivify_359:
    $P900 = $P899."ast"()
    store_lex "$past", $P900
.annotate 'line', 348
    find_lex $P901, "$past"
    find_lex $P902, "$/"
    unless_null $P902, vivify_360
    $P902 = root_new ['parrot';'Hash']
  vivify_360:
    set $P903, $P902["key"]
    unless_null $P903, vivify_361
    new $P903, "Undef"
  vivify_361:
    $P904 = $P903."Str"()
    $P901."named"($P904)
.annotate 'line', 349
    find_lex $P905, "$/"
    find_lex $P906, "$past"
    $P907 = $P905."!make"($P906)
.annotate 'line', 346
    .return ($P907)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("65_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_909
    .param pmc param_910
.annotate 'line', 352
    .lex "self", param_909
    .lex "$/", param_910
.annotate 'line', 353
    new $P911, "Undef"
    .lex "$past", $P911
.annotate 'line', 354
    find_lex $P914, "$/"
    unless_null $P914, vivify_362
    $P914 = root_new ['parrot';'Hash']
  vivify_362:
    set $P915, $P914["circumfix"]
    unless_null $P915, vivify_363
    new $P915, "Undef"
  vivify_363:
    if $P915, if_913
.annotate 'line', 355
    get_hll_global $P920, ["PAST"], "Val"
    find_lex $P921, "$/"
    unless_null $P921, vivify_364
    $P921 = root_new ['parrot';'Hash']
  vivify_364:
    set $P922, $P921["not"]
    unless_null $P922, vivify_365
    new $P922, "Undef"
  vivify_365:
    isfalse $I923, $P922
    $P924 = $P920."new"($I923 :named("value"))
    set $P912, $P924
.annotate 'line', 354
    goto if_913_end
  if_913:
    find_lex $P916, "$/"
    unless_null $P916, vivify_366
    $P916 = root_new ['parrot';'Hash']
  vivify_366:
    set $P917, $P916["circumfix"]
    unless_null $P917, vivify_367
    $P917 = root_new ['parrot';'ResizablePMCArray']
  vivify_367:
    set $P918, $P917[0]
    unless_null $P918, vivify_368
    new $P918, "Undef"
  vivify_368:
    $P919 = $P918."ast"()
    set $P912, $P919
  if_913_end:
    store_lex "$past", $P912
.annotate 'line', 356
    find_lex $P925, "$past"
    find_lex $P926, "$/"
    unless_null $P926, vivify_369
    $P926 = root_new ['parrot';'Hash']
  vivify_369:
    set $P927, $P926["identifier"]
    unless_null $P927, vivify_370
    new $P927, "Undef"
  vivify_370:
    set $S928, $P927
    $P925."named"($S928)
.annotate 'line', 357
    find_lex $P929, "$/"
    find_lex $P930, "$past"
    $P931 = $P929."!make"($P930)
.annotate 'line', 352
    .return ($P931)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("66_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_933
    .param pmc param_934
.annotate 'line', 360
    .const 'Sub' $P947 = "67_1299465732.713" 
    capture_lex $P947
    .lex "self", param_933
    .lex "$/", param_934
.annotate 'line', 361
    new $P935, "Undef"
    .lex "$past", $P935
.annotate 'line', 360
    find_lex $P936, "$past"
.annotate 'line', 362
    find_lex $P938, "$/"
    unless_null $P938, vivify_371
    $P938 = root_new ['parrot';'Hash']
  vivify_371:
    set $P939, $P938["postcircumfix"]
    unless_null $P939, vivify_372
    new $P939, "Undef"
  vivify_372:
    if $P939, if_937
.annotate 'line', 366
    .const 'Sub' $P947 = "67_1299465732.713" 
    capture_lex $P947
    $P947()
    goto if_937_end
  if_937:
.annotate 'line', 363
    find_lex $P940, "$/"
    unless_null $P940, vivify_389
    $P940 = root_new ['parrot';'Hash']
  vivify_389:
    set $P941, $P940["postcircumfix"]
    unless_null $P941, vivify_390
    new $P941, "Undef"
  vivify_390:
    $P942 = $P941."ast"()
    store_lex "$past", $P942
.annotate 'line', 364
    find_lex $P943, "$past"
    get_hll_global $P944, ["PAST"], "Var"
    $P945 = $P944."new"("$/" :named("name"))
    $P943."unshift"($P945)
  if_937_end:
.annotate 'line', 396
    find_lex $P1019, "$/"
    find_lex $P1020, "$past"
    $P1021 = $P1019."!make"($P1020)
.annotate 'line', 360
    .return ($P1021)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block946"  :anon :subid("67_1299465732.713") :outer("66_1299465732.713")
.annotate 'line', 367
    $P948 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P948
    get_hll_global $P949, ["NQP"], "Compiler"
    find_lex $P950, "$/"
    set $S951, $P950
    $P952 = $P949."parse_name"($S951)
    store_lex "@name", $P952
.annotate 'line', 368
    get_hll_global $P953, ["PAST"], "Var"
    find_lex $P954, "@name"
    $P955 = $P954."pop"()
    set $S956, $P955
    $P957 = $P953."new"($S956 :named("name"))
    store_lex "$past", $P957
.annotate 'line', 369
    find_lex $P959, "@name"
    unless $P959, if_958_end
.annotate 'line', 370
    find_lex $P961, "@name"
    unless_null $P961, vivify_373
    $P961 = root_new ['parrot';'ResizablePMCArray']
  vivify_373:
    set $P962, $P961[0]
    unless_null $P962, vivify_374
    new $P962, "Undef"
  vivify_374:
    set $S963, $P962
    iseq $I964, $S963, "GLOBAL"
    unless $I964, if_960_end
    find_lex $P965, "@name"
    $P965."shift"()
  if_960_end:
.annotate 'line', 371
    find_lex $P966, "$past"
    find_lex $P967, "@name"
    $P966."namespace"($P967)
.annotate 'line', 372
    find_lex $P968, "$past"
    $P968."scope"("package")
.annotate 'line', 373
    find_lex $P969, "$past"
    find_lex $P970, "$/"
    unless_null $P970, vivify_375
    $P970 = root_new ['parrot';'Hash']
  vivify_375:
    set $P971, $P970["sigil"]
    unless_null $P971, vivify_376
    new $P971, "Undef"
  vivify_376:
    $P972 = "vivitype"($P971)
    $P969."viviself"($P972)
.annotate 'line', 374
    find_lex $P973, "$past"
    $P973."lvalue"(1)
  if_958_end:
.annotate 'line', 376
    find_lex $P976, "$/"
    unless_null $P976, vivify_377
    $P976 = root_new ['parrot';'Hash']
  vivify_377:
    set $P977, $P976["twigil"]
    unless_null $P977, vivify_378
    $P977 = root_new ['parrot';'ResizablePMCArray']
  vivify_378:
    set $P978, $P977[0]
    unless_null $P978, vivify_379
    new $P978, "Undef"
  vivify_379:
    set $S979, $P978
    iseq $I980, $S979, "*"
    if $I980, if_975
.annotate 'line', 389
    find_lex $P1002, "$/"
    unless_null $P1002, vivify_380
    $P1002 = root_new ['parrot';'Hash']
  vivify_380:
    set $P1003, $P1002["twigil"]
    unless_null $P1003, vivify_381
    $P1003 = root_new ['parrot';'ResizablePMCArray']
  vivify_381:
    set $P1004, $P1003[0]
    unless_null $P1004, vivify_382
    new $P1004, "Undef"
  vivify_382:
    set $S1005, $P1004
    iseq $I1006, $S1005, "!"
    if $I1006, if_1001
    new $P1000, 'Integer'
    set $P1000, $I1006
    goto if_1001_end
  if_1001:
.annotate 'line', 390
    find_lex $P1007, "$past"
    get_hll_global $P1008, ["PAST"], "Var"
    $P1009 = $P1008."new"("self" :named("name"))
    $P1007."push"($P1009)
.annotate 'line', 391
    find_lex $P1010, "$past"
    $P1010."scope"("attribute")
.annotate 'line', 392
    find_lex $P1011, "$past"
    find_lex $P1012, "$/"
    unless_null $P1012, vivify_383
    $P1012 = root_new ['parrot';'Hash']
  vivify_383:
    set $P1013, $P1012["sigil"]
    unless_null $P1013, vivify_384
    new $P1013, "Undef"
  vivify_384:
    $P1014 = "vivitype"($P1013)
    $P1011."viviself"($P1014)
.annotate 'line', 393
    find_lex $P1015, "$past"
    get_hll_global $P1016, ["PAST"], "Var"
    $P1017 = $P1016."new"("$?CLASS" :named("name"))
    $P1018 = $P1015."push"($P1017)
.annotate 'line', 389
    set $P1000, $P1018
  if_1001_end:
    set $P974, $P1000
.annotate 'line', 376
    goto if_975_end
  if_975:
.annotate 'line', 377
    find_lex $P981, "$past"
    $P981."scope"("contextual")
.annotate 'line', 378
    find_lex $P982, "$past"
.annotate 'line', 379
    get_hll_global $P983, ["PAST"], "Var"
.annotate 'line', 381
    find_lex $P984, "$/"
    unless_null $P984, vivify_385
    $P984 = root_new ['parrot';'Hash']
  vivify_385:
    set $P985, $P984["sigil"]
    unless_null $P985, vivify_386
    new $P985, "Undef"
  vivify_386:
    set $S986, $P985
    new $P987, 'String'
    set $P987, $S986
    find_lex $P988, "$/"
    unless_null $P988, vivify_387
    $P988 = root_new ['parrot';'Hash']
  vivify_387:
    set $P989, $P988["desigilname"]
    unless_null $P989, vivify_388
    new $P989, "Undef"
  vivify_388:
    concat $P990, $P987, $P989
.annotate 'line', 383
    get_hll_global $P991, ["PAST"], "Op"
    new $P992, "String"
    assign $P992, "Contextual "
    find_lex $P993, "$/"
    set $S994, $P993
    concat $P995, $P992, $S994
    concat $P996, $P995, " not found"
    $P997 = $P991."new"($P996, "die" :named("pirop"))
    $P998 = $P983."new"("package" :named("scope"), "" :named("namespace"), $P990 :named("name"), $P997 :named("viviself"))
.annotate 'line', 379
    $P999 = $P982."viviself"($P998)
.annotate 'line', 376
    set $P974, $P999
  if_975_end:
.annotate 'line', 366
    .return ($P974)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("68_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1023
    .param pmc param_1024
.annotate 'line', 399
    .lex "self", param_1023
    .lex "$/", param_1024
    find_lex $P1025, "$/"
    find_lex $P1026, "$/"
    unless_null $P1026, vivify_391
    $P1026 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1027, $P1026["package_def"]
    unless_null $P1027, vivify_392
    new $P1027, "Undef"
  vivify_392:
    $P1028 = $P1027."ast"()
    $P1029 = $P1025."!make"($P1028)
    .return ($P1029)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("69_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1031
    .param pmc param_1032
.annotate 'line', 400
    .lex "self", param_1031
    .lex "$/", param_1032
    find_lex $P1033, "$/"
    find_lex $P1034, "$/"
    unless_null $P1034, vivify_393
    $P1034 = root_new ['parrot';'Hash']
  vivify_393:
    set $P1035, $P1034["package_def"]
    unless_null $P1035, vivify_394
    new $P1035, "Undef"
  vivify_394:
    $P1036 = $P1035."ast"()
    $P1037 = $P1033."!make"($P1036)
    .return ($P1037)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("70_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1039
    .param pmc param_1040
.annotate 'line', 401
    .lex "self", param_1039
    .lex "$/", param_1040
    find_lex $P1041, "$/"
    find_lex $P1042, "$/"
    unless_null $P1042, vivify_395
    $P1042 = root_new ['parrot';'Hash']
  vivify_395:
    set $P1043, $P1042["package_def"]
    unless_null $P1043, vivify_396
    new $P1043, "Undef"
  vivify_396:
    $P1044 = $P1043."ast"()
    $P1045 = $P1041."!make"($P1044)
    .return ($P1045)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("71_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1047
    .param pmc param_1048
.annotate 'line', 402
    .lex "self", param_1047
    .lex "$/", param_1048
    find_lex $P1049, "$/"
    find_lex $P1050, "$/"
    unless_null $P1050, vivify_397
    $P1050 = root_new ['parrot';'Hash']
  vivify_397:
    set $P1051, $P1050["package_def"]
    unless_null $P1051, vivify_398
    new $P1051, "Undef"
  vivify_398:
    $P1052 = $P1051."ast"()
    $P1053 = $P1049."!make"($P1052)
    .return ($P1053)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("72_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1055
    .param pmc param_1056
.annotate 'line', 403
    .lex "self", param_1055
    .lex "$/", param_1056
    find_lex $P1057, "$/"
    find_lex $P1058, "$/"
    unless_null $P1058, vivify_399
    $P1058 = root_new ['parrot';'Hash']
  vivify_399:
    set $P1059, $P1058["package_def"]
    unless_null $P1059, vivify_400
    new $P1059, "Undef"
  vivify_400:
    $P1060 = $P1059."ast"()
    $P1061 = $P1057."!make"($P1060)
    .return ($P1061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("73_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1063
    .param pmc param_1064
.annotate 'line', 404
    .lex "self", param_1063
    .lex "$/", param_1064
    find_lex $P1065, "$/"
    find_lex $P1066, "$/"
    unless_null $P1066, vivify_401
    $P1066 = root_new ['parrot';'Hash']
  vivify_401:
    set $P1067, $P1066["package_def"]
    unless_null $P1067, vivify_402
    new $P1067, "Undef"
  vivify_402:
    $P1068 = $P1067."ast"()
    $P1069 = $P1065."!make"($P1068)
    .return ($P1069)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("74_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1071
    .param pmc param_1072
.annotate 'line', 406
    .const 'Sub' $P1231 = "77_1299465732.713" 
    capture_lex $P1231
    .const 'Sub' $P1180 = "76_1299465732.713" 
    capture_lex $P1180
    .const 'Sub' $P1138 = "75_1299465732.713" 
    capture_lex $P1138
    .lex "self", param_1071
    .lex "$/", param_1072
.annotate 'line', 408
    $P1073 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1073
.annotate 'line', 409
    new $P1074, "Undef"
    .lex "$name", $P1074
.annotate 'line', 410
    new $P1075, "Undef"
    .lex "$how", $P1075
.annotate 'line', 413
    new $P1076, "Undef"
    .lex "$past", $P1076
.annotate 'line', 408
    find_lex $P1077, "$/"
    unless_null $P1077, vivify_403
    $P1077 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1078, $P1077["name"]
    unless_null $P1078, vivify_404
    $P1078 = root_new ['parrot';'Hash']
  vivify_404:
    set $P1079, $P1078["identifier"]
    unless_null $P1079, vivify_405
    new $P1079, "Undef"
  vivify_405:
    clone $P1080, $P1079
    store_lex "@ns", $P1080
.annotate 'line', 409
    find_lex $P1081, "@ns"
    $P1082 = $P1081."pop"()
    set $S1083, $P1082
    new $P1084, 'String'
    set $P1084, $S1083
    store_lex "$name", $P1084
.annotate 'line', 410
    find_dynamic_lex $P1085, "$*PKGDECL"
    unless_null $P1085, vivify_406
    get_hll_global $P1085, "$PKGDECL"
    unless_null $P1085, vivify_407
    die "Contextual $*PKGDECL not found"
  vivify_407:
  vivify_406:
    find_dynamic_lex $P1086, "%*HOW"
    unless_null $P1086, vivify_408
    get_hll_global $P1086, "%HOW"
    unless_null $P1086, vivify_409
    die "Contextual %*HOW not found"
  vivify_409:
  vivify_408:
    set $P1087, $P1086[$P1085]
    unless_null $P1087, vivify_410
    new $P1087, "Undef"
  vivify_410:
    store_lex "$how", $P1087
.annotate 'line', 413
    find_lex $P1090, "$/"
    unless_null $P1090, vivify_411
    $P1090 = root_new ['parrot';'Hash']
  vivify_411:
    set $P1091, $P1090["block"]
    unless_null $P1091, vivify_412
    new $P1091, "Undef"
  vivify_412:
    if $P1091, if_1089
    find_lex $P1095, "$/"
    unless_null $P1095, vivify_413
    $P1095 = root_new ['parrot';'Hash']
  vivify_413:
    set $P1096, $P1095["comp_unit"]
    unless_null $P1096, vivify_414
    new $P1096, "Undef"
  vivify_414:
    $P1097 = $P1096."ast"()
    set $P1088, $P1097
    goto if_1089_end
  if_1089:
    find_lex $P1092, "$/"
    unless_null $P1092, vivify_415
    $P1092 = root_new ['parrot';'Hash']
  vivify_415:
    set $P1093, $P1092["block"]
    unless_null $P1093, vivify_416
    new $P1093, "Undef"
  vivify_416:
    $P1094 = $P1093."ast"()
    set $P1088, $P1094
  if_1089_end:
    store_lex "$past", $P1088
.annotate 'line', 414
    find_lex $P1098, "$past"
    find_lex $P1099, "$/"
    unless_null $P1099, vivify_417
    $P1099 = root_new ['parrot';'Hash']
  vivify_417:
    set $P1100, $P1099["name"]
    unless_null $P1100, vivify_418
    $P1100 = root_new ['parrot';'Hash']
  vivify_418:
    set $P1101, $P1100["identifier"]
    unless_null $P1101, vivify_419
    new $P1101, "Undef"
  vivify_419:
    $P1098."namespace"($P1101)
.annotate 'line', 418
    find_dynamic_lex $P1102, "$*PACKAGE-SETUP"
    unless_null $P1102, vivify_420
    get_hll_global $P1102, "$PACKAGE-SETUP"
    unless_null $P1102, vivify_421
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_421:
  vivify_420:
    get_hll_global $P1103, ["PAST"], "Stmts"
.annotate 'line', 419
    get_hll_global $P1104, ["PAST"], "Op"
.annotate 'line', 420
    get_hll_global $P1105, ["PAST"], "Var"
    $P1106 = $P1105."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 421
    get_hll_global $P1107, ["PAST"], "Op"
.annotate 'line', 423
    get_hll_global $P1108, ["PAST"], "Var"
    find_lex $P1109, "$how"
    get_how $P1110, $P1109
    find_lex $P1111, "$how"
    $P1112 = $P1110."name"($P1111)
    $P1113 = $P1108."new"($P1112 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 424
    get_hll_global $P1114, ["PAST"], "Val"
    find_lex $P1115, "$name"
    $P1116 = $P1114."new"($P1115 :named("value"), "name" :named("named"))
    $P1117 = $P1107."new"($P1113, $P1116, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 421
    $P1118 = $P1104."new"($P1106, $P1117, "bind" :named("pasttype"))
.annotate 'line', 427
    get_hll_global $P1119, ["PAST"], "Op"
.annotate 'line', 428
    get_hll_global $P1120, ["PAST"], "Var"
    find_lex $P1121, "$name"
    find_lex $P1122, "@ns"
    $P1123 = $P1120."new"($P1121 :named("name"), $P1122 :named("namespace"), "package" :named("scope"))
.annotate 'line', 429
    get_hll_global $P1124, ["PAST"], "Var"
    $P1125 = $P1124."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1126 = $P1119."new"($P1123, $P1125, "bind" :named("pasttype"))
.annotate 'line', 431
    get_hll_global $P1127, ["PAST"], "Op"
.annotate 'line', 432
    get_hll_global $P1128, ["PAST"], "Var"
    $P1129 = $P1128."new"("$?CLASS" :named("name"))
.annotate 'line', 433
    get_hll_global $P1130, ["PAST"], "Var"
    $P1131 = $P1130."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1132 = $P1127."new"($P1129, $P1131, "bind" :named("pasttype"))
.annotate 'line', 431
    $P1133 = $P1103."new"($P1118, $P1126, $P1132)
.annotate 'line', 418
    $P1102."unshift"($P1133)
.annotate 'line', 438
    find_lex $P1135, "$/"
    unless_null $P1135, vivify_422
    $P1135 = root_new ['parrot';'Hash']
  vivify_422:
    set $P1136, $P1135["repr"]
    unless_null $P1136, vivify_423
    new $P1136, "Undef"
  vivify_423:
    unless $P1136, if_1134_end
    .const 'Sub' $P1138 = "75_1299465732.713" 
    capture_lex $P1138
    $P1138()
  if_1134_end:
.annotate 'line', 449
    find_lex $P1154, "$how"
    can $I1155, $P1154, "parametric"
    if $I1155, if_1153
    new $P1152, 'Integer'
    set $P1152, $I1155
    goto if_1153_end
  if_1153:
    find_lex $P1156, "$how"
    find_lex $P1157, "$how"
    $P1158 = $P1156."parametric"($P1157)
    set $P1152, $P1158
  if_1153_end:
    if $P1152, if_1151
.annotate 'line', 456
    find_lex $P1171, "$past"
    $P1171."blocktype"("immediate")
.annotate 'line', 457
    find_lex $P1172, "$past"
    get_hll_global $P1173, ["PAST"], "Var"
    $P1174 = $P1173."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1172."unshift"($P1174)
.annotate 'line', 458
    find_lex $P1175, "$past"
    $P1175."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 455
    goto if_1151_end
  if_1151:
.annotate 'line', 450
    find_lex $P1159, "$past"
    $P1159."blocktype"("declaration")
.annotate 'line', 451
    find_lex $P1160, "$past"
    get_hll_global $P1161, ["PAST"], "Var"
    $P1162 = $P1161."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1160."unshift"($P1162)
.annotate 'line', 452
    find_lex $P1163, "$past"
    $P1163."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 453
    find_dynamic_lex $P1164, "$*PACKAGE-SETUP"
    unless_null $P1164, vivify_432
    get_hll_global $P1164, "$PACKAGE-SETUP"
    unless_null $P1164, vivify_433
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_433:
  vivify_432:
    set $P1165, $P1164[0]
    unless_null $P1165, vivify_434
    $P1165 = root_new ['parrot';'ResizablePMCArray']
  vivify_434:
    set $P1166, $P1165[0]
    unless_null $P1166, vivify_435
    $P1166 = root_new ['parrot';'ResizablePMCArray']
  vivify_435:
    set $P1167, $P1166[1]
    unless_null $P1167, vivify_436
    new $P1167, "Undef"
  vivify_436:
    get_hll_global $P1168, ["PAST"], "Val"
    find_lex $P1169, "$past"
    $P1170 = $P1168."new"($P1169 :named("value"), "body_block" :named("named"))
    $P1167."push"($P1170)
  if_1151_end:
.annotate 'line', 463
    find_lex $P1177, "$/"
    unless_null $P1177, vivify_437
    $P1177 = root_new ['parrot';'Hash']
  vivify_437:
    set $P1178, $P1177["parent"]
    unless_null $P1178, vivify_438
    new $P1178, "Undef"
  vivify_438:
    if $P1178, if_1176
.annotate 'line', 477
    find_dynamic_lex $P1208, "$*PKGDECL"
    unless_null $P1208, vivify_439
    get_hll_global $P1208, "$PKGDECL"
    unless_null $P1208, vivify_440
    die "Contextual $*PKGDECL not found"
  vivify_440:
  vivify_439:
    set $S1209, $P1208
    iseq $I1210, $S1209, "grammar"
    unless $I1210, if_1207_end
.annotate 'line', 478
    find_dynamic_lex $P1211, "$*PACKAGE-SETUP"
    unless_null $P1211, vivify_441
    get_hll_global $P1211, "$PACKAGE-SETUP"
    unless_null $P1211, vivify_442
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_442:
  vivify_441:
    get_hll_global $P1212, ["PAST"], "Op"
.annotate 'line', 480
    get_hll_global $P1213, ["PAST"], "Op"
.annotate 'line', 483
    get_hll_global $P1214, ["PAST"], "Var"
    $P1215 = $P1214."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1216 = $P1213."new"($P1215, "get_how PP" :named("pirop"))
.annotate 'line', 485
    get_hll_global $P1217, ["PAST"], "Var"
    $P1218 = $P1217."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 486
    get_hll_global $P1219, ["PAST"], "Var"
    $P1220 = $P1219."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1221 = $P1212."new"($P1216, $P1218, $P1220, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 478
    $P1211."push"($P1221)
  if_1207_end:
.annotate 'line', 477
    goto if_1176_end
  if_1176:
.annotate 'line', 463
    .const 'Sub' $P1180 = "76_1299465732.713" 
    capture_lex $P1180
    $P1180()
  if_1176_end:
.annotate 'line', 491
    find_lex $P1223, "$/"
    unless_null $P1223, vivify_449
    $P1223 = root_new ['parrot';'Hash']
  vivify_449:
    set $P1224, $P1223["role"]
    unless_null $P1224, vivify_450
    new $P1224, "Undef"
  vivify_450:
    unless $P1224, if_1222_end
.annotate 'line', 492
    find_lex $P1226, "$/"
    unless_null $P1226, vivify_451
    $P1226 = root_new ['parrot';'Hash']
  vivify_451:
    set $P1227, $P1226["role"]
    unless_null $P1227, vivify_452
    new $P1227, "Undef"
  vivify_452:
    defined $I1228, $P1227
    unless $I1228, for_undef_453
    iter $P1225, $P1227
    new $P1258, 'ExceptionHandler'
    set_label $P1258, loop1257_handler
    $P1258."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1258
  loop1257_test:
    unless $P1225, loop1257_done
    shift $P1229, $P1225
  loop1257_redo:
    .const 'Sub' $P1231 = "77_1299465732.713" 
    capture_lex $P1231
    $P1231($P1229)
  loop1257_next:
    goto loop1257_test
  loop1257_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1259, exception, 'type'
    eq $P1259, .CONTROL_LOOP_NEXT, loop1257_next
    eq $P1259, .CONTROL_LOOP_REDO, loop1257_redo
  loop1257_done:
    pop_eh 
  for_undef_453:
  if_1222_end:
.annotate 'line', 509
    find_dynamic_lex $P1260, "$*PACKAGE-SETUP"
    unless_null $P1260, vivify_458
    get_hll_global $P1260, "$PACKAGE-SETUP"
    unless_null $P1260, vivify_459
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_459:
  vivify_458:
    get_hll_global $P1261, ["PAST"], "Op"
.annotate 'line', 511
    get_hll_global $P1262, ["PAST"], "Op"
.annotate 'line', 514
    get_hll_global $P1263, ["PAST"], "Var"
    $P1264 = $P1263."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1265 = $P1262."new"($P1264, "get_how PP" :named("pirop"))
.annotate 'line', 516
    get_hll_global $P1266, ["PAST"], "Var"
    $P1267 = $P1266."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1268 = $P1261."new"($P1265, $P1267, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 509
    $P1260."push"($P1268)
.annotate 'line', 520
    get_global $P1269, "@BLOCK"
    unless_null $P1269, vivify_460
    $P1269 = root_new ['parrot';'ResizablePMCArray']
  vivify_460:
    set $P1270, $P1269[0]
    unless_null $P1270, vivify_461
    $P1270 = root_new ['parrot';'ResizablePMCArray']
  vivify_461:
    set $P1271, $P1270[0]
    unless_null $P1271, vivify_462
    new $P1271, "Undef"
  vivify_462:
    get_hll_global $P1272, ["PAST"], "Var"
    find_lex $P1273, "$name"
    find_lex $P1274, "@ns"
    $P1275 = $P1272."new"($P1273 :named("name"), $P1274 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P1271."unshift"($P1275)
.annotate 'line', 523
    find_lex $P1276, "$past"
    $P1277 = $P1276."loadinit"()
    get_hll_global $P1278, ["PAST"], "Block"
    find_dynamic_lex $P1279, "$*PACKAGE-SETUP"
    unless_null $P1279, vivify_463
    get_hll_global $P1279, "$PACKAGE-SETUP"
    unless_null $P1279, vivify_464
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_464:
  vivify_463:
    $P1280 = $P1278."new"($P1279, "immediate" :named("blocktype"))
    $P1277."push"($P1280)
.annotate 'line', 525
    find_lex $P1281, "$/"
    find_lex $P1282, "$past"
    $P1283 = $P1281."!make"($P1282)
.annotate 'line', 406
    .return ($P1283)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1137"  :anon :subid("75_1299465732.713") :outer("74_1299465732.713")
.annotate 'line', 439
    new $P1139, "Undef"
    .lex "$repr_name", $P1139
    find_lex $P1140, "$/"
    unless_null $P1140, vivify_424
    $P1140 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1141, $P1140["repr"]
    unless_null $P1141, vivify_425
    $P1141 = root_new ['parrot';'ResizablePMCArray']
  vivify_425:
    set $P1142, $P1141[0]
    unless_null $P1142, vivify_426
    new $P1142, "Undef"
  vivify_426:
    $P1143 = $P1142."ast"()
    store_lex "$repr_name", $P1143
.annotate 'line', 440
    find_lex $P1144, "$repr_name"
    $P1144."named"("repr")
.annotate 'line', 441
    find_dynamic_lex $P1145, "$*PACKAGE-SETUP"
    unless_null $P1145, vivify_427
    get_hll_global $P1145, "$PACKAGE-SETUP"
    unless_null $P1145, vivify_428
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_428:
  vivify_427:
    set $P1146, $P1145[0]
    unless_null $P1146, vivify_429
    $P1146 = root_new ['parrot';'ResizablePMCArray']
  vivify_429:
    set $P1147, $P1146[0]
    unless_null $P1147, vivify_430
    $P1147 = root_new ['parrot';'ResizablePMCArray']
  vivify_430:
    set $P1148, $P1147[1]
    unless_null $P1148, vivify_431
    new $P1148, "Undef"
  vivify_431:
    find_lex $P1149, "$repr_name"
    $P1150 = $P1148."push"($P1149)
.annotate 'line', 438
    .return ($P1150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1179"  :anon :subid("76_1299465732.713") :outer("74_1299465732.713")
.annotate 'line', 464
    $P1181 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1181
.annotate 'line', 465
    new $P1182, "Undef"
    .lex "$name", $P1182
.annotate 'line', 464
    find_lex $P1183, "$/"
    unless_null $P1183, vivify_443
    $P1183 = root_new ['parrot';'Hash']
  vivify_443:
    set $P1184, $P1183["parent"]
    unless_null $P1184, vivify_444
    $P1184 = root_new ['parrot';'ResizablePMCArray']
  vivify_444:
    set $P1185, $P1184[0]
    unless_null $P1185, vivify_445
    $P1185 = root_new ['parrot';'Hash']
  vivify_445:
    set $P1186, $P1185["identifier"]
    unless_null $P1186, vivify_446
    new $P1186, "Undef"
  vivify_446:
    clone $P1187, $P1186
    store_lex "@ns", $P1187
.annotate 'line', 465
    find_lex $P1188, "@ns"
    $P1189 = $P1188."pop"()
    set $S1190, $P1189
    new $P1191, 'String'
    set $P1191, $S1190
    store_lex "$name", $P1191
.annotate 'line', 466
    find_dynamic_lex $P1192, "$*PACKAGE-SETUP"
    unless_null $P1192, vivify_447
    get_hll_global $P1192, "$PACKAGE-SETUP"
    unless_null $P1192, vivify_448
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_448:
  vivify_447:
    get_hll_global $P1193, ["PAST"], "Op"
.annotate 'line', 468
    get_hll_global $P1194, ["PAST"], "Op"
.annotate 'line', 471
    get_hll_global $P1195, ["PAST"], "Var"
    $P1196 = $P1195."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1197 = $P1194."new"($P1196, "get_how PP" :named("pirop"))
.annotate 'line', 473
    get_hll_global $P1198, ["PAST"], "Var"
    $P1199 = $P1198."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 474
    get_hll_global $P1200, ["PAST"], "Var"
    find_lex $P1201, "$name"
    set $S1202, $P1201
    find_lex $P1203, "@ns"
    $P1204 = $P1200."new"($S1202 :named("name"), $P1203 :named("namespace"), "package" :named("scope"))
    $P1205 = $P1193."new"($P1197, $P1199, $P1204, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 466
    $P1206 = $P1192."push"($P1205)
.annotate 'line', 463
    .return ($P1206)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1230"  :anon :subid("77_1299465732.713") :outer("74_1299465732.713")
    .param pmc param_1234
.annotate 'line', 493
    $P1232 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1232
.annotate 'line', 494
    new $P1233, "Undef"
    .lex "$name", $P1233
    .lex "$_", param_1234
.annotate 'line', 493
    find_lex $P1235, "$_"
    unless_null $P1235, vivify_454
    $P1235 = root_new ['parrot';'Hash']
  vivify_454:
    set $P1236, $P1235["identifier"]
    unless_null $P1236, vivify_455
    new $P1236, "Undef"
  vivify_455:
    clone $P1237, $P1236
    store_lex "@ns", $P1237
.annotate 'line', 494
    find_lex $P1238, "@ns"
    $P1239 = $P1238."pop"()
    set $S1240, $P1239
    new $P1241, 'String'
    set $P1241, $S1240
    store_lex "$name", $P1241
.annotate 'line', 495
    find_dynamic_lex $P1242, "$*PACKAGE-SETUP"
    unless_null $P1242, vivify_456
    get_hll_global $P1242, "$PACKAGE-SETUP"
    unless_null $P1242, vivify_457
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_457:
  vivify_456:
    get_hll_global $P1243, ["PAST"], "Op"
.annotate 'line', 497
    get_hll_global $P1244, ["PAST"], "Op"
.annotate 'line', 500
    get_hll_global $P1245, ["PAST"], "Var"
    $P1246 = $P1245."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1247 = $P1244."new"($P1246, "get_how PP" :named("pirop"))
.annotate 'line', 502
    get_hll_global $P1248, ["PAST"], "Var"
    $P1249 = $P1248."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 503
    get_hll_global $P1250, ["PAST"], "Var"
    find_lex $P1251, "$name"
    set $S1252, $P1251
    find_lex $P1253, "@ns"
    $P1254 = $P1250."new"($S1252 :named("name"), $P1253 :named("namespace"), "package" :named("scope"))
    $P1255 = $P1243."new"($P1247, $P1249, $P1254, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 495
    $P1256 = $P1242."push"($P1255)
.annotate 'line', 492
    .return ($P1256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("78_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1285
    .param pmc param_1286
.annotate 'line', 528
    .lex "self", param_1285
    .lex "$/", param_1286
    find_lex $P1287, "$/"
    find_lex $P1288, "$/"
    unless_null $P1288, vivify_465
    $P1288 = root_new ['parrot';'Hash']
  vivify_465:
    set $P1289, $P1288["scoped"]
    unless_null $P1289, vivify_466
    new $P1289, "Undef"
  vivify_466:
    $P1290 = $P1289."ast"()
    $P1291 = $P1287."!make"($P1290)
    .return ($P1291)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("79_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1293
    .param pmc param_1294
.annotate 'line', 529
    .lex "self", param_1293
    .lex "$/", param_1294
    find_lex $P1295, "$/"
    find_lex $P1296, "$/"
    unless_null $P1296, vivify_467
    $P1296 = root_new ['parrot';'Hash']
  vivify_467:
    set $P1297, $P1296["scoped"]
    unless_null $P1297, vivify_468
    new $P1297, "Undef"
  vivify_468:
    $P1298 = $P1297."ast"()
    $P1299 = $P1295."!make"($P1298)
    .return ($P1299)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("80_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1301
    .param pmc param_1302
.annotate 'line', 530
    .lex "self", param_1301
    .lex "$/", param_1302
    find_lex $P1303, "$/"
    find_lex $P1304, "$/"
    unless_null $P1304, vivify_469
    $P1304 = root_new ['parrot';'Hash']
  vivify_469:
    set $P1305, $P1304["scoped"]
    unless_null $P1305, vivify_470
    new $P1305, "Undef"
  vivify_470:
    $P1306 = $P1305."ast"()
    $P1307 = $P1303."!make"($P1306)
    .return ($P1307)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("81_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1309
    .param pmc param_1310
.annotate 'line', 532
    .lex "self", param_1309
    .lex "$/", param_1310
.annotate 'line', 533
    find_lex $P1311, "$/"
.annotate 'line', 534
    find_lex $P1314, "$/"
    unless_null $P1314, vivify_471
    $P1314 = root_new ['parrot';'Hash']
  vivify_471:
    set $P1315, $P1314["declarator"]
    unless_null $P1315, vivify_472
    new $P1315, "Undef"
  vivify_472:
    if $P1315, if_1313
.annotate 'line', 535
    find_lex $P1319, "$/"
    unless_null $P1319, vivify_473
    $P1319 = root_new ['parrot';'Hash']
  vivify_473:
    set $P1320, $P1319["multi_declarator"]
    unless_null $P1320, vivify_474
    new $P1320, "Undef"
  vivify_474:
    $P1321 = $P1320."ast"()
    set $P1312, $P1321
.annotate 'line', 534
    goto if_1313_end
  if_1313:
    find_lex $P1316, "$/"
    unless_null $P1316, vivify_475
    $P1316 = root_new ['parrot';'Hash']
  vivify_475:
    set $P1317, $P1316["declarator"]
    unless_null $P1317, vivify_476
    new $P1317, "Undef"
  vivify_476:
    $P1318 = $P1317."ast"()
    set $P1312, $P1318
  if_1313_end:
    $P1322 = $P1311."!make"($P1312)
.annotate 'line', 532
    .return ($P1322)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("82_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1324
    .param pmc param_1325
.annotate 'line', 538
    .lex "self", param_1324
    .lex "$/", param_1325
.annotate 'line', 539
    find_lex $P1326, "$/"
.annotate 'line', 540
    find_lex $P1329, "$/"
    unless_null $P1329, vivify_477
    $P1329 = root_new ['parrot';'Hash']
  vivify_477:
    set $P1330, $P1329["routine_declarator"]
    unless_null $P1330, vivify_478
    new $P1330, "Undef"
  vivify_478:
    if $P1330, if_1328
.annotate 'line', 541
    find_lex $P1334, "$/"
    unless_null $P1334, vivify_479
    $P1334 = root_new ['parrot';'Hash']
  vivify_479:
    set $P1335, $P1334["variable_declarator"]
    unless_null $P1335, vivify_480
    new $P1335, "Undef"
  vivify_480:
    $P1336 = $P1335."ast"()
    set $P1327, $P1336
.annotate 'line', 540
    goto if_1328_end
  if_1328:
    find_lex $P1331, "$/"
    unless_null $P1331, vivify_481
    $P1331 = root_new ['parrot';'Hash']
  vivify_481:
    set $P1332, $P1331["routine_declarator"]
    unless_null $P1332, vivify_482
    new $P1332, "Undef"
  vivify_482:
    $P1333 = $P1332."ast"()
    set $P1327, $P1333
  if_1328_end:
    $P1337 = $P1326."!make"($P1327)
.annotate 'line', 538
    .return ($P1337)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("83_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1339
    .param pmc param_1340
.annotate 'line', 544
    .lex "self", param_1339
    .lex "$/", param_1340
    find_lex $P1341, "$/"
    find_lex $P1344, "$/"
    unless_null $P1344, vivify_483
    $P1344 = root_new ['parrot';'Hash']
  vivify_483:
    set $P1345, $P1344["declarator"]
    unless_null $P1345, vivify_484
    new $P1345, "Undef"
  vivify_484:
    if $P1345, if_1343
    find_lex $P1349, "$/"
    unless_null $P1349, vivify_485
    $P1349 = root_new ['parrot';'Hash']
  vivify_485:
    set $P1350, $P1349["routine_def"]
    unless_null $P1350, vivify_486
    new $P1350, "Undef"
  vivify_486:
    $P1351 = $P1350."ast"()
    set $P1342, $P1351
    goto if_1343_end
  if_1343:
    find_lex $P1346, "$/"
    unless_null $P1346, vivify_487
    $P1346 = root_new ['parrot';'Hash']
  vivify_487:
    set $P1347, $P1346["declarator"]
    unless_null $P1347, vivify_488
    new $P1347, "Undef"
  vivify_488:
    $P1348 = $P1347."ast"()
    set $P1342, $P1348
  if_1343_end:
    $P1352 = $P1341."!make"($P1342)
    .return ($P1352)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("84_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1354
    .param pmc param_1355
.annotate 'line', 545
    .lex "self", param_1354
    .lex "$/", param_1355
    find_lex $P1356, "$/"
    find_lex $P1359, "$/"
    unless_null $P1359, vivify_489
    $P1359 = root_new ['parrot';'Hash']
  vivify_489:
    set $P1360, $P1359["declarator"]
    unless_null $P1360, vivify_490
    new $P1360, "Undef"
  vivify_490:
    if $P1360, if_1358
    find_lex $P1364, "$/"
    unless_null $P1364, vivify_491
    $P1364 = root_new ['parrot';'Hash']
  vivify_491:
    set $P1365, $P1364["routine_def"]
    unless_null $P1365, vivify_492
    new $P1365, "Undef"
  vivify_492:
    $P1366 = $P1365."ast"()
    set $P1357, $P1366
    goto if_1358_end
  if_1358:
    find_lex $P1361, "$/"
    unless_null $P1361, vivify_493
    $P1361 = root_new ['parrot';'Hash']
  vivify_493:
    set $P1362, $P1361["declarator"]
    unless_null $P1362, vivify_494
    new $P1362, "Undef"
  vivify_494:
    $P1363 = $P1362."ast"()
    set $P1357, $P1363
  if_1358_end:
    $P1367 = $P1356."!make"($P1357)
    .return ($P1367)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("85_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1369
    .param pmc param_1370
.annotate 'line', 546
    .lex "self", param_1369
    .lex "$/", param_1370
    find_lex $P1371, "$/"
    find_lex $P1372, "$/"
    unless_null $P1372, vivify_495
    $P1372 = root_new ['parrot';'Hash']
  vivify_495:
    set $P1373, $P1372["declarator"]
    unless_null $P1373, vivify_496
    new $P1373, "Undef"
  vivify_496:
    $P1374 = $P1373."ast"()
    $P1375 = $P1371."!make"($P1374)
    .return ($P1375)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("86_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1377
    .param pmc param_1378
.annotate 'line', 549
    .const 'Sub' $P1450 = "89_1299465732.713" 
    capture_lex $P1450
    .const 'Sub' $P1405 = "87_1299465732.713" 
    capture_lex $P1405
    .lex "self", param_1377
    .lex "$/", param_1378
.annotate 'line', 550
    new $P1379, "Undef"
    .lex "$past", $P1379
.annotate 'line', 551
    new $P1380, "Undef"
    .lex "$sigil", $P1380
.annotate 'line', 552
    new $P1381, "Undef"
    .lex "$name", $P1381
.annotate 'line', 553
    new $P1382, "Undef"
    .lex "$BLOCK", $P1382
.annotate 'line', 550
    find_lex $P1383, "$/"
    unless_null $P1383, vivify_497
    $P1383 = root_new ['parrot';'Hash']
  vivify_497:
    set $P1384, $P1383["variable"]
    unless_null $P1384, vivify_498
    new $P1384, "Undef"
  vivify_498:
    $P1385 = $P1384."ast"()
    store_lex "$past", $P1385
.annotate 'line', 551
    find_lex $P1386, "$/"
    unless_null $P1386, vivify_499
    $P1386 = root_new ['parrot';'Hash']
  vivify_499:
    set $P1387, $P1386["variable"]
    unless_null $P1387, vivify_500
    $P1387 = root_new ['parrot';'Hash']
  vivify_500:
    set $P1388, $P1387["sigil"]
    unless_null $P1388, vivify_501
    new $P1388, "Undef"
  vivify_501:
    store_lex "$sigil", $P1388
.annotate 'line', 552
    find_lex $P1389, "$past"
    $P1390 = $P1389."name"()
    store_lex "$name", $P1390
.annotate 'line', 553
    get_global $P1391, "@BLOCK"
    unless_null $P1391, vivify_502
    $P1391 = root_new ['parrot';'ResizablePMCArray']
  vivify_502:
    set $P1392, $P1391[0]
    unless_null $P1392, vivify_503
    new $P1392, "Undef"
  vivify_503:
    store_lex "$BLOCK", $P1392
.annotate 'line', 554
    find_lex $P1394, "$BLOCK"
    find_lex $P1395, "$name"
    $P1396 = $P1394."symbol"($P1395)
    unless $P1396, if_1393_end
.annotate 'line', 555
    find_lex $P1397, "$/"
    $P1398 = $P1397."CURSOR"()
    find_lex $P1399, "$name"
    $P1398."panic"("Redeclaration of symbol ", $P1399)
  if_1393_end:
.annotate 'line', 557
    find_dynamic_lex $P1401, "$*SCOPE"
    unless_null $P1401, vivify_504
    get_hll_global $P1401, "$SCOPE"
    unless_null $P1401, vivify_505
    die "Contextual $*SCOPE not found"
  vivify_505:
  vivify_504:
    set $S1402, $P1401
    iseq $I1403, $S1402, "has"
    if $I1403, if_1400
.annotate 'line', 582
    .const 'Sub' $P1450 = "89_1299465732.713" 
    capture_lex $P1450
    $P1450()
    goto if_1400_end
  if_1400:
.annotate 'line', 557
    .const 'Sub' $P1405 = "87_1299465732.713" 
    capture_lex $P1405
    $P1405()
  if_1400_end:
.annotate 'line', 590
    find_lex $P1474, "$/"
    find_lex $P1475, "$past"
    $P1476 = $P1474."!make"($P1475)
.annotate 'line', 549
    .return ($P1476)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1449"  :anon :subid("89_1299465732.713") :outer("86_1299465732.713")
.annotate 'line', 583
    new $P1451, "Undef"
    .lex "$scope", $P1451
.annotate 'line', 584
    new $P1452, "Undef"
    .lex "$decl", $P1452
.annotate 'line', 583
    find_dynamic_lex $P1455, "$*SCOPE"
    unless_null $P1455, vivify_506
    get_hll_global $P1455, "$SCOPE"
    unless_null $P1455, vivify_507
    die "Contextual $*SCOPE not found"
  vivify_507:
  vivify_506:
    set $S1456, $P1455
    iseq $I1457, $S1456, "our"
    if $I1457, if_1454
    new $P1459, "String"
    assign $P1459, "lexical"
    set $P1453, $P1459
    goto if_1454_end
  if_1454:
    new $P1458, "String"
    assign $P1458, "package"
    set $P1453, $P1458
  if_1454_end:
    store_lex "$scope", $P1453
.annotate 'line', 584
    get_hll_global $P1460, ["PAST"], "Var"
    find_lex $P1461, "$name"
    find_lex $P1462, "$scope"
.annotate 'line', 585
    find_lex $P1463, "$sigil"
    $P1464 = "vivitype"($P1463)
    find_lex $P1465, "$/"
    $P1466 = $P1460."new"($P1461 :named("name"), $P1462 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1464 :named("viviself"), $P1465 :named("node"))
.annotate 'line', 584
    store_lex "$decl", $P1466
.annotate 'line', 587
    find_lex $P1467, "$BLOCK"
    find_lex $P1468, "$name"
    find_lex $P1469, "$scope"
    $P1467."symbol"($P1468, $P1469 :named("scope"))
.annotate 'line', 588
    find_lex $P1470, "$BLOCK"
    unless_null $P1470, vivify_508
    $P1470 = root_new ['parrot';'ResizablePMCArray']
  vivify_508:
    set $P1471, $P1470[0]
    unless_null $P1471, vivify_509
    new $P1471, "Undef"
  vivify_509:
    find_lex $P1472, "$decl"
    $P1473 = $P1471."push"($P1472)
.annotate 'line', 582
    .return ($P1473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1404"  :anon :subid("87_1299465732.713") :outer("86_1299465732.713")
.annotate 'line', 557
    .const 'Sub' $P1435 = "88_1299465732.713" 
    capture_lex $P1435
.annotate 'line', 559
    new $P1406, "Undef"
    .lex "$meta-attr-type", $P1406
.annotate 'line', 567
    new $P1407, "Undef"
    .lex "$meta_args", $P1407
.annotate 'line', 559
    find_dynamic_lex $P1410, "$*PKGDECL"
    unless_null $P1410, vivify_510
    get_hll_global $P1410, "$PKGDECL"
    unless_null $P1410, vivify_511
    die "Contextual $*PKGDECL not found"
  vivify_511:
  vivify_510:
    find_dynamic_lex $P1411, "%*HOW-METAATTR"
    unless_null $P1411, vivify_512
    get_hll_global $P1411, "%HOW-METAATTR"
    unless_null $P1411, vivify_513
    die "Contextual %*HOW-METAATTR not found"
  vivify_513:
  vivify_512:
    set $P1412, $P1411[$P1410]
    unless_null $P1412, vivify_514
    new $P1412, "Undef"
  vivify_514:
    unless $P1412, unless_1409
    set $P1408, $P1412
    goto unless_1409_end
  unless_1409:
    find_dynamic_lex $P1413, "$*DEFAULT-METAATTR"
    unless_null $P1413, vivify_515
    get_hll_global $P1413, "$DEFAULT-METAATTR"
    unless_null $P1413, vivify_516
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_516:
  vivify_515:
    set $P1408, $P1413
  unless_1409_end:
    store_lex "$meta-attr-type", $P1408
.annotate 'line', 560
    find_dynamic_lex $P1414, "$*PACKAGE-SETUP"
    unless_null $P1414, vivify_517
    get_hll_global $P1414, "$PACKAGE-SETUP"
    unless_null $P1414, vivify_518
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_518:
  vivify_517:
    get_hll_global $P1415, ["PAST"], "Op"
.annotate 'line', 562
    get_hll_global $P1416, ["PAST"], "Op"
.annotate 'line', 564
    get_hll_global $P1417, ["PAST"], "Var"
    $P1418 = $P1417."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1419 = $P1416."new"($P1418, "get_how PP" :named("pirop"))
.annotate 'line', 566
    get_hll_global $P1420, ["PAST"], "Var"
    $P1421 = $P1420."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 567
    get_hll_global $P1422, ["PAST"], "Op"
.annotate 'line', 569
    get_hll_global $P1423, ["PAST"], "Var"
    find_lex $P1424, "$meta-attr-type"
    $P1425 = $P1423."new"($P1424 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 570
    get_hll_global $P1426, ["PAST"], "Val"
    find_lex $P1427, "$name"
    $P1428 = $P1426."new"($P1427 :named("value"), "name" :named("named"))
    $P1429 = $P1422."new"($P1425, $P1428, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 567
    store_lex "$meta_args", $P1429
    $P1430 = $P1415."new"($P1419, $P1421, $P1429, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 560
    $P1414."push"($P1430)
.annotate 'line', 573
    find_lex $P1432, "$/"
    unless_null $P1432, vivify_519
    $P1432 = root_new ['parrot';'Hash']
  vivify_519:
    set $P1433, $P1432["typename"]
    unless_null $P1433, vivify_520
    new $P1433, "Undef"
  vivify_520:
    unless $P1433, if_1431_end
    .const 'Sub' $P1435 = "88_1299465732.713" 
    capture_lex $P1435
    $P1435()
  if_1431_end:
.annotate 'line', 579
    find_lex $P1445, "$BLOCK"
    find_lex $P1446, "$name"
    $P1445."symbol"($P1446, "attribute" :named("scope"))
.annotate 'line', 580
    get_hll_global $P1447, ["PAST"], "Stmts"
    $P1448 = $P1447."new"()
    store_lex "$past", $P1448
.annotate 'line', 557
    .return ($P1448)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1434"  :anon :subid("88_1299465732.713") :outer("87_1299465732.713")
.annotate 'line', 574
    new $P1436, "Undef"
    .lex "$type", $P1436
    find_lex $P1437, "$/"
    unless_null $P1437, vivify_521
    $P1437 = root_new ['parrot';'Hash']
  vivify_521:
    set $P1438, $P1437["typename"]
    unless_null $P1438, vivify_522
    $P1438 = root_new ['parrot';'ResizablePMCArray']
  vivify_522:
    set $P1439, $P1438[0]
    unless_null $P1439, vivify_523
    new $P1439, "Undef"
  vivify_523:
    $P1440 = $P1439."ast"()
    store_lex "$type", $P1440
.annotate 'line', 575
    find_lex $P1441, "$type"
    $P1441."named"("type")
.annotate 'line', 576
    find_lex $P1442, "$meta_args"
    find_lex $P1443, "$type"
    $P1444 = $P1442."push"($P1443)
.annotate 'line', 573
    .return ($P1444)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("90_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1478
    .param pmc param_1479
.annotate 'line', 593
    .lex "self", param_1478
    .lex "$/", param_1479
    find_lex $P1480, "$/"
    find_lex $P1481, "$/"
    unless_null $P1481, vivify_524
    $P1481 = root_new ['parrot';'Hash']
  vivify_524:
    set $P1482, $P1481["routine_def"]
    unless_null $P1482, vivify_525
    new $P1482, "Undef"
  vivify_525:
    $P1483 = $P1482."ast"()
    $P1484 = $P1480."!make"($P1483)
    .return ($P1484)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("91_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1486
    .param pmc param_1487
.annotate 'line', 594
    .lex "self", param_1486
    .lex "$/", param_1487
    find_lex $P1488, "$/"
    find_lex $P1489, "$/"
    unless_null $P1489, vivify_526
    $P1489 = root_new ['parrot';'Hash']
  vivify_526:
    set $P1490, $P1489["method_def"]
    unless_null $P1490, vivify_527
    new $P1490, "Undef"
  vivify_527:
    $P1491 = $P1490."ast"()
    $P1492 = $P1488."!make"($P1491)
    .return ($P1492)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("92_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1494
    .param pmc param_1495
.annotate 'line', 596
    .const 'Sub' $P1723 = "98_1299465732.713" 
    capture_lex $P1723
    .const 'Sub' $P1515 = "93_1299465732.713" 
    capture_lex $P1515
    .lex "self", param_1494
    .lex "$/", param_1495
.annotate 'line', 599
    new $P1496, "Undef"
    .lex "$past", $P1496
.annotate 'line', 610
    new $P1497, "Undef"
    .lex "$block", $P1497
.annotate 'line', 596
    find_lex $P1498, "$past"
.annotate 'line', 600
    find_lex $P1500, "$/"
    unless_null $P1500, vivify_528
    $P1500 = root_new ['parrot';'Hash']
  vivify_528:
    set $P1501, $P1500["onlystar"]
    unless_null $P1501, vivify_529
    new $P1501, "Undef"
  vivify_529:
    if $P1501, if_1499
.annotate 'line', 604
    find_lex $P1503, "$/"
    unless_null $P1503, vivify_530
    $P1503 = root_new ['parrot';'Hash']
  vivify_530:
    set $P1504, $P1503["blockoid"]
    unless_null $P1504, vivify_531
    new $P1504, "Undef"
  vivify_531:
    $P1505 = $P1504."ast"()
    store_lex "$past", $P1505
.annotate 'line', 605
    find_lex $P1506, "$past"
    $P1506."blocktype"("declaration")
.annotate 'line', 606
    find_dynamic_lex $P1508, "$*RETURN_USED"
    unless_null $P1508, vivify_532
    get_hll_global $P1508, "$RETURN_USED"
    unless_null $P1508, vivify_533
    die "Contextual $*RETURN_USED not found"
  vivify_533:
  vivify_532:
    unless $P1508, if_1507_end
.annotate 'line', 607
    find_lex $P1509, "$past"
    $P1509."control"("return_pir")
  if_1507_end:
.annotate 'line', 603
    goto if_1499_end
  if_1499:
.annotate 'line', 601
    $P1502 = "only_star_block"()
    store_lex "$past", $P1502
  if_1499_end:
.annotate 'line', 610
    find_lex $P1510, "$past"
    store_lex "$block", $P1510
.annotate 'line', 612
    find_lex $P1512, "$/"
    unless_null $P1512, vivify_534
    $P1512 = root_new ['parrot';'Hash']
  vivify_534:
    set $P1513, $P1512["deflongname"]
    unless_null $P1513, vivify_535
    new $P1513, "Undef"
  vivify_535:
    unless $P1513, if_1511_end
    .const 'Sub' $P1515 = "93_1299465732.713" 
    capture_lex $P1515
    $P1515()
  if_1511_end:
.annotate 'line', 712
    find_lex $P1712, "$block"
    find_lex $P1713, "$past"
    unless_null $P1713, vivify_596
    $P1713 = root_new ['parrot';'Hash']
    store_lex "$past", $P1713
  vivify_596:
    set $P1713["block_past"], $P1712
.annotate 'line', 713
    find_lex $P1715, "$/"
    unless_null $P1715, vivify_597
    $P1715 = root_new ['parrot';'Hash']
  vivify_597:
    set $P1716, $P1715["trait"]
    unless_null $P1716, vivify_598
    new $P1716, "Undef"
  vivify_598:
    unless $P1716, if_1714_end
.annotate 'line', 714
    find_lex $P1718, "$/"
    unless_null $P1718, vivify_599
    $P1718 = root_new ['parrot';'Hash']
  vivify_599:
    set $P1719, $P1718["trait"]
    unless_null $P1719, vivify_600
    new $P1719, "Undef"
  vivify_600:
    defined $I1720, $P1719
    unless $I1720, for_undef_601
    iter $P1717, $P1719
    new $P1730, 'ExceptionHandler'
    set_label $P1730, loop1729_handler
    $P1730."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1730
  loop1729_test:
    unless $P1717, loop1729_done
    shift $P1721, $P1717
  loop1729_redo:
    .const 'Sub' $P1723 = "98_1299465732.713" 
    capture_lex $P1723
    $P1723($P1721)
  loop1729_next:
    goto loop1729_test
  loop1729_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1731, exception, 'type'
    eq $P1731, .CONTROL_LOOP_NEXT, loop1729_next
    eq $P1731, .CONTROL_LOOP_REDO, loop1729_redo
  loop1729_done:
    pop_eh 
  for_undef_601:
  if_1714_end:
.annotate 'line', 717
    find_lex $P1732, "$/"
    find_lex $P1733, "$past"
    $P1734 = $P1732."!make"($P1733)
.annotate 'line', 596
    .return ($P1734)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1514"  :anon :subid("93_1299465732.713") :outer("92_1299465732.713")
.annotate 'line', 612
    .const 'Sub' $P1638 = "97_1299465732.713" 
    capture_lex $P1638
    .const 'Sub' $P1549 = "94_1299465732.713" 
    capture_lex $P1549
.annotate 'line', 613
    new $P1516, "Undef"
    .lex "$name", $P1516
    find_lex $P1517, "$/"
    unless_null $P1517, vivify_536
    $P1517 = root_new ['parrot';'Hash']
  vivify_536:
    set $P1518, $P1517["sigil"]
    unless_null $P1518, vivify_537
    $P1518 = root_new ['parrot';'ResizablePMCArray']
  vivify_537:
    set $P1519, $P1518[0]
    unless_null $P1519, vivify_538
    new $P1519, "Undef"
  vivify_538:
    set $S1520, $P1519
    new $P1521, 'String'
    set $P1521, $S1520
    find_lex $P1522, "$/"
    unless_null $P1522, vivify_539
    $P1522 = root_new ['parrot';'Hash']
  vivify_539:
    set $P1523, $P1522["deflongname"]
    unless_null $P1523, vivify_540
    $P1523 = root_new ['parrot';'ResizablePMCArray']
  vivify_540:
    set $P1524, $P1523[0]
    unless_null $P1524, vivify_541
    new $P1524, "Undef"
  vivify_541:
    $S1525 = $P1524."ast"()
    concat $P1526, $P1521, $S1525
    store_lex "$name", $P1526
.annotate 'line', 614
    find_lex $P1527, "$past"
    find_lex $P1528, "$name"
    $P1527."name"($P1528)
.annotate 'line', 615
    find_dynamic_lex $P1535, "$*SCOPE"
    unless_null $P1535, vivify_542
    get_hll_global $P1535, "$SCOPE"
    unless_null $P1535, vivify_543
    die "Contextual $*SCOPE not found"
  vivify_543:
  vivify_542:
    set $S1536, $P1535
    iseq $I1537, $S1536, ""
    unless $I1537, unless_1534
    new $P1533, 'Integer'
    set $P1533, $I1537
    goto unless_1534_end
  unless_1534:
    find_dynamic_lex $P1538, "$*SCOPE"
    unless_null $P1538, vivify_544
    get_hll_global $P1538, "$SCOPE"
    unless_null $P1538, vivify_545
    die "Contextual $*SCOPE not found"
  vivify_545:
  vivify_544:
    set $S1539, $P1538
    iseq $I1540, $S1539, "my"
    new $P1533, 'Integer'
    set $P1533, $I1540
  unless_1534_end:
    unless $P1533, unless_1532
    set $P1531, $P1533
    goto unless_1532_end
  unless_1532:
    find_dynamic_lex $P1541, "$*SCOPE"
    unless_null $P1541, vivify_546
    get_hll_global $P1541, "$SCOPE"
    unless_null $P1541, vivify_547
    die "Contextual $*SCOPE not found"
  vivify_547:
  vivify_546:
    set $S1542, $P1541
    iseq $I1543, $S1542, "our"
    new $P1531, 'Integer'
    set $P1531, $I1543
  unless_1532_end:
    if $P1531, if_1530
.annotate 'line', 707
    find_lex $P1707, "$/"
    $P1708 = $P1707."CURSOR"()
    find_dynamic_lex $P1709, "$*SCOPE"
    unless_null $P1709, vivify_548
    get_hll_global $P1709, "$SCOPE"
    unless_null $P1709, vivify_549
    die "Contextual $*SCOPE not found"
  vivify_549:
  vivify_548:
    concat $P1710, $P1709, " scoped routines are not supported yet"
    $P1711 = $P1708."panic"($P1710)
.annotate 'line', 706
    set $P1529, $P1711
.annotate 'line', 615
    goto if_1530_end
  if_1530:
.annotate 'line', 616
    find_dynamic_lex $P1545, "$*MULTINESS"
    unless_null $P1545, vivify_550
    get_hll_global $P1545, "$MULTINESS"
    unless_null $P1545, vivify_551
    die "Contextual $*MULTINESS not found"
  vivify_551:
  vivify_550:
    set $S1546, $P1545
    iseq $I1547, $S1546, "multi"
    if $I1547, if_1544
.annotate 'line', 667
    find_dynamic_lex $P1634, "$*MULTINESS"
    unless_null $P1634, vivify_552
    get_hll_global $P1634, "$MULTINESS"
    unless_null $P1634, vivify_553
    die "Contextual $*MULTINESS not found"
  vivify_553:
  vivify_552:
    set $S1635, $P1634
    iseq $I1636, $S1635, "proto"
    if $I1636, if_1633
.annotate 'line', 686
    get_global $P1668, "@BLOCK"
    unless_null $P1668, vivify_554
    $P1668 = root_new ['parrot';'ResizablePMCArray']
  vivify_554:
    set $P1669, $P1668[0]
    unless_null $P1669, vivify_555
    $P1669 = root_new ['parrot';'ResizablePMCArray']
  vivify_555:
    set $P1670, $P1669[0]
    unless_null $P1670, vivify_556
    new $P1670, "Undef"
  vivify_556:
    get_hll_global $P1671, ["PAST"], "Var"
    find_lex $P1672, "$name"
    find_lex $P1673, "$past"
    $P1674 = $P1671."new"($P1672 :named("name"), 1 :named("isdecl"), $P1673 :named("viviself"), "lexical" :named("scope"))
    $P1670."push"($P1674)
.annotate 'line', 688
    get_global $P1675, "@BLOCK"
    unless_null $P1675, vivify_557
    $P1675 = root_new ['parrot';'ResizablePMCArray']
  vivify_557:
    set $P1676, $P1675[0]
    unless_null $P1676, vivify_558
    new $P1676, "Undef"
  vivify_558:
    find_lex $P1677, "$name"
    $P1676."symbol"($P1677, "lexical" :named("scope"))
.annotate 'line', 689
    find_dynamic_lex $P1679, "$*SCOPE"
    unless_null $P1679, vivify_559
    get_hll_global $P1679, "$SCOPE"
    unless_null $P1679, vivify_560
    die "Contextual $*SCOPE not found"
  vivify_560:
  vivify_559:
    set $S1680, $P1679
    iseq $I1681, $S1680, "our"
    unless $I1681, if_1678_end
.annotate 'line', 692
    get_global $P1682, "@BLOCK"
    unless_null $P1682, vivify_561
    $P1682 = root_new ['parrot';'ResizablePMCArray']
  vivify_561:
    set $P1683, $P1682[0]
    unless_null $P1683, vivify_562
    $P1683 = root_new ['parrot';'ResizablePMCArray']
  vivify_562:
    set $P1684, $P1683[0]
    unless_null $P1684, vivify_563
    new $P1684, "Undef"
  vivify_563:
    get_hll_global $P1685, ["PAST"], "Op"
.annotate 'line', 694
    get_hll_global $P1686, ["PAST"], "Var"
    find_lex $P1687, "$name"
    $P1688 = $P1686."new"($P1687 :named("name"), "package" :named("scope"))
.annotate 'line', 695
    get_hll_global $P1689, ["PAST"], "Var"
    find_lex $P1690, "$name"
    $P1691 = $P1689."new"($P1690 :named("name"), "lexical" :named("scope"))
    $P1692 = $P1685."new"($P1688, $P1691, "bind" :named("pasttype"))
.annotate 'line', 692
    $P1684."push"($P1692)
.annotate 'line', 697
    get_global $P1693, "@BLOCK"
    unless_null $P1693, vivify_564
    $P1693 = root_new ['parrot';'ResizablePMCArray']
  vivify_564:
    set $P1694, $P1693[0]
    unless_null $P1694, vivify_565
    new $P1694, "Undef"
  vivify_565:
    $P1695 = $P1694."loadinit"()
    get_hll_global $P1696, ["PAST"], "Op"
.annotate 'line', 699
    get_hll_global $P1697, ["PAST"], "Var"
    find_lex $P1698, "$name"
    $P1699 = $P1697."new"($P1698 :named("name"), "package" :named("scope"))
.annotate 'line', 700
    get_hll_global $P1700, ["PAST"], "Val"
    find_lex $P1701, "$past"
    $P1702 = $P1700."new"($P1701 :named("value"))
    $P1703 = $P1696."new"($P1699, $P1702, "bind" :named("pasttype"))
.annotate 'line', 697
    $P1695."push"($P1703)
  if_1678_end:
.annotate 'line', 685
    goto if_1633_end
  if_1633:
.annotate 'line', 667
    .const 'Sub' $P1638 = "97_1299465732.713" 
    capture_lex $P1638
    $P1638()
  if_1633_end:
    goto if_1544_end
  if_1544:
.annotate 'line', 616
    .const 'Sub' $P1549 = "94_1299465732.713" 
    capture_lex $P1549
    $P1549()
  if_1544_end:
.annotate 'line', 704
    get_hll_global $P1704, ["PAST"], "Var"
    find_lex $P1705, "$name"
    $P1706 = $P1704."new"($P1705 :named("name"))
    store_lex "$past", $P1706
.annotate 'line', 615
    set $P1529, $P1706
  if_1530_end:
.annotate 'line', 612
    .return ($P1529)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1637"  :anon :subid("97_1299465732.713") :outer("93_1299465732.713")
.annotate 'line', 672
    new $P1639, "Undef"
    .lex "$cholder", $P1639
.annotate 'line', 671
    find_dynamic_lex $P1641, "$*SCOPE"
    unless_null $P1641, vivify_566
    get_hll_global $P1641, "$SCOPE"
    unless_null $P1641, vivify_567
    die "Contextual $*SCOPE not found"
  vivify_567:
  vivify_566:
    set $S1642, $P1641
    iseq $I1643, $S1642, "our"
    unless $I1643, if_1640_end
    die "our-scoped protos not yet implemented"
  if_1640_end:
.annotate 'line', 672
    get_hll_global $P1644, ["PAST"], "Op"
    $P1645 = $P1644."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1645
.annotate 'line', 673
    get_global $P1646, "@BLOCK"
    unless_null $P1646, vivify_568
    $P1646 = root_new ['parrot';'ResizablePMCArray']
  vivify_568:
    set $P1647, $P1646[0]
    unless_null $P1647, vivify_569
    $P1647 = root_new ['parrot';'ResizablePMCArray']
  vivify_569:
    set $P1648, $P1647[0]
    unless_null $P1648, vivify_570
    new $P1648, "Undef"
  vivify_570:
    get_hll_global $P1649, ["PAST"], "Var"
    find_lex $P1650, "$name"
    find_lex $P1651, "$past"
    $P1652 = $P1649."new"($P1650 :named("name"), 1 :named("isdecl"), $P1651 :named("viviself"), "lexical" :named("scope"))
    $P1648."push"($P1652)
.annotate 'line', 675
    get_global $P1653, "@BLOCK"
    unless_null $P1653, vivify_571
    $P1653 = root_new ['parrot';'ResizablePMCArray']
  vivify_571:
    set $P1654, $P1653[0]
    unless_null $P1654, vivify_572
    $P1654 = root_new ['parrot';'ResizablePMCArray']
  vivify_572:
    set $P1655, $P1654[0]
    unless_null $P1655, vivify_573
    new $P1655, "Undef"
  vivify_573:
    get_hll_global $P1656, ["PAST"], "Op"
.annotate 'line', 677
    get_hll_global $P1657, ["PAST"], "Var"
    find_lex $P1658, "$name"
    $P1659 = $P1657."new"($P1658 :named("name"))
    find_lex $P1660, "$cholder"
    $P1661 = $P1656."new"($P1659, $P1660, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 675
    $P1655."push"($P1661)
.annotate 'line', 680
    get_global $P1662, "@BLOCK"
    unless_null $P1662, vivify_574
    $P1662 = root_new ['parrot';'ResizablePMCArray']
  vivify_574:
    set $P1663, $P1662[0]
    unless_null $P1663, vivify_575
    new $P1663, "Undef"
  vivify_575:
    find_lex $P1664, "$name"
    find_lex $P1665, "$cholder"
    $P1663."symbol"($P1664, "lexical" :named("scope"), 1 :named("proto"), $P1665 :named("cholder"))
.annotate 'line', 683
    find_lex $P1666, "$past"
    $P1667 = $P1666."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 667
    .return ($P1667)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1548"  :anon :subid("94_1299465732.713") :outer("93_1299465732.713")
.annotate 'line', 616
    .const 'Sub' $P1567 = "95_1299465732.713" 
    capture_lex $P1567
.annotate 'line', 619
    new $P1550, "Undef"
    .lex "$cholder", $P1550
.annotate 'line', 620
    $P1551 = root_new ['parrot';'Hash']
    .lex "%sym", $P1551
.annotate 'line', 618
    find_dynamic_lex $P1553, "$*SCOPE"
    unless_null $P1553, vivify_576
    get_hll_global $P1553, "$SCOPE"
    unless_null $P1553, vivify_577
    die "Contextual $*SCOPE not found"
  vivify_577:
  vivify_576:
    set $S1554, $P1553
    iseq $I1555, $S1554, "our"
    unless $I1555, if_1552_end
    die "our-scoped multis not yet implemented"
  if_1552_end:
    find_lex $P1556, "$cholder"
.annotate 'line', 620
    get_global $P1557, "@BLOCK"
    unless_null $P1557, vivify_578
    $P1557 = root_new ['parrot';'ResizablePMCArray']
  vivify_578:
    set $P1558, $P1557[0]
    unless_null $P1558, vivify_579
    new $P1558, "Undef"
  vivify_579:
    find_lex $P1559, "$name"
    $P1560 = $P1558."symbol"($P1559)
    store_lex "%sym", $P1560
.annotate 'line', 621
    find_lex $P1562, "%sym"
    unless_null $P1562, vivify_580
    $P1562 = root_new ['parrot';'Hash']
  vivify_580:
    set $P1563, $P1562["cholder"]
    unless_null $P1563, vivify_581
    new $P1563, "Undef"
  vivify_581:
    if $P1563, if_1561
.annotate 'line', 626
    .const 'Sub' $P1567 = "95_1299465732.713" 
    capture_lex $P1567
    $P1567()
    goto if_1561_end
  if_1561:
.annotate 'line', 622
    find_lex $P1564, "%sym"
    unless_null $P1564, vivify_594
    $P1564 = root_new ['parrot';'Hash']
  vivify_594:
    set $P1565, $P1564["cholder"]
    unless_null $P1565, vivify_595
    new $P1565, "Undef"
  vivify_595:
    store_lex "$cholder", $P1565
  if_1561_end:
.annotate 'line', 662
    find_lex $P1629, "$cholder"
    find_lex $P1630, "$past"
    $P1629."push"($P1630)
.annotate 'line', 665
    find_lex $P1631, "$past"
    $P1632 = "attach_multi_signature"($P1631)
.annotate 'line', 616
    .return ($P1632)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1566"  :anon :subid("95_1299465732.713") :outer("94_1299465732.713")
.annotate 'line', 626
    .const 'Sub' $P1581 = "96_1299465732.713" 
    capture_lex $P1581
.annotate 'line', 633
    new $P1568, "Undef"
    .lex "$found_proto", $P1568
.annotate 'line', 651
    new $P1569, "Undef"
    .lex "$dispatch_setup", $P1569
.annotate 'line', 628
    find_lex $P1571, "%sym"
    unless_null $P1571, vivify_582
    $P1571 = root_new ['parrot';'Hash']
  vivify_582:
    set $P1572, $P1571["proto"]
    unless_null $P1572, vivify_583
    new $P1572, "Undef"
  vivify_583:
    unless $P1572, if_1570_end
.annotate 'line', 631
    find_lex $P1573, "$/"
    $P1574 = $P1573."CURSOR"()
    $P1574."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1570_end:
.annotate 'line', 628
    find_lex $P1575, "$found_proto"
.annotate 'line', 634
    get_global $P1577, "@BLOCK"
    defined $I1578, $P1577
    unless $I1578, for_undef_584
    iter $P1576, $P1577
    new $P1603, 'ExceptionHandler'
    set_label $P1603, loop1602_handler
    $P1603."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1603
  loop1602_test:
    unless $P1576, loop1602_done
    shift $P1579, $P1576
  loop1602_redo:
    .const 'Sub' $P1581 = "96_1299465732.713" 
    capture_lex $P1581
    $P1581($P1579)
  loop1602_next:
    goto loop1602_test
  loop1602_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1604, exception, 'type'
    eq $P1604, .CONTROL_LOOP_NEXT, loop1602_next
    eq $P1604, .CONTROL_LOOP_REDO, loop1602_redo
  loop1602_done:
    pop_eh 
  for_undef_584:
.annotate 'line', 645
    find_lex $P1606, "$found_proto"
    if $P1606, unless_1605_end
.annotate 'line', 646
    find_lex $P1607, "$/"
    $P1608 = $P1607."CURSOR"()
    $P1608."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1605_end:
.annotate 'line', 650
    get_hll_global $P1609, ["PAST"], "Op"
    $P1610 = $P1609."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1610
.annotate 'line', 651
    get_hll_global $P1611, ["PAST"], "Op"
.annotate 'line', 653
    get_hll_global $P1612, ["PAST"], "Var"
    find_lex $P1613, "$name"
    $P1614 = $P1612."new"($P1613 :named("name"), "outer" :named("scope"))
    find_lex $P1615, "$cholder"
    $P1616 = $P1611."new"($P1614, $P1615, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 651
    store_lex "$dispatch_setup", $P1616
.annotate 'line', 656
    get_global $P1617, "@BLOCK"
    unless_null $P1617, vivify_589
    $P1617 = root_new ['parrot';'ResizablePMCArray']
  vivify_589:
    set $P1618, $P1617[0]
    unless_null $P1618, vivify_590
    $P1618 = root_new ['parrot';'ResizablePMCArray']
  vivify_590:
    set $P1619, $P1618[0]
    unless_null $P1619, vivify_591
    new $P1619, "Undef"
  vivify_591:
    get_hll_global $P1620, ["PAST"], "Var"
    find_lex $P1621, "$name"
    find_lex $P1622, "$dispatch_setup"
    $P1623 = $P1620."new"($P1621 :named("name"), 1 :named("isdecl"), $P1622 :named("viviself"), "lexical" :named("scope"))
    $P1619."push"($P1623)
.annotate 'line', 658
    get_global $P1624, "@BLOCK"
    unless_null $P1624, vivify_592
    $P1624 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    set $P1625, $P1624[0]
    unless_null $P1625, vivify_593
    new $P1625, "Undef"
  vivify_593:
    find_lex $P1626, "$name"
    find_lex $P1627, "$cholder"
    $P1628 = $P1625."symbol"($P1626, "lexical" :named("scope"), $P1627 :named("cholder"))
.annotate 'line', 626
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1580"  :anon :subid("96_1299465732.713") :outer("95_1299465732.713")
    .param pmc param_1583
.annotate 'line', 635
    $P1582 = root_new ['parrot';'Hash']
    .lex "%sym", $P1582
    .lex "$_", param_1583
    find_lex $P1584, "$_"
    find_lex $P1585, "$name"
    $P1586 = $P1584."symbol"($P1585)
    store_lex "%sym", $P1586
.annotate 'line', 636
    find_lex $P1591, "%sym"
    unless_null $P1591, vivify_585
    $P1591 = root_new ['parrot';'Hash']
  vivify_585:
    set $P1592, $P1591["proto"]
    unless_null $P1592, vivify_586
    new $P1592, "Undef"
  vivify_586:
    unless $P1592, unless_1590
    set $P1589, $P1592
    goto unless_1590_end
  unless_1590:
    find_lex $P1593, "%sym"
    unless_null $P1593, vivify_587
    $P1593 = root_new ['parrot';'Hash']
  vivify_587:
    set $P1594, $P1593["cholder"]
    unless_null $P1594, vivify_588
    new $P1594, "Undef"
  vivify_588:
    set $P1589, $P1594
  unless_1590_end:
    if $P1589, if_1588
.annotate 'line', 639
    find_lex $P1598, "%sym"
    if $P1598, if_1597
    set $P1596, $P1598
    goto if_1597_end
  if_1597:
.annotate 'line', 640
    find_lex $P1599, "$/"
    $P1600 = $P1599."CURSOR"()
    $P1601 = $P1600."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 639
    set $P1596, $P1601
  if_1597_end:
    set $P1587, $P1596
.annotate 'line', 636
    goto if_1588_end
  if_1588:
.annotate 'line', 637
    new $P1595, "Integer"
    assign $P1595, 1
    store_lex "$found_proto", $P1595
.annotate 'line', 636
    set $P1587, $P1595
  if_1588_end:
.annotate 'line', 634
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1722"  :anon :subid("98_1299465732.713") :outer("92_1299465732.713")
    .param pmc param_1724
.annotate 'line', 714
    .lex "$_", param_1724
    find_lex $P1725, "$_"
    $P1726 = $P1725."ast"()
    find_lex $P1727, "$/"
    $P1728 = $P1726($P1727)
    .return ($P1728)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("99_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1736
    .param pmc param_1737
.annotate 'line', 721
    .const 'Sub' $P1849 = "101_1299465732.713" 
    capture_lex $P1849
    .const 'Sub' $P1765 = "100_1299465732.713" 
    capture_lex $P1765
    .lex "self", param_1736
    .lex "$/", param_1737
.annotate 'line', 724
    new $P1738, "Undef"
    .lex "$past", $P1738
.annotate 'line', 721
    find_lex $P1739, "$past"
.annotate 'line', 725
    find_lex $P1741, "$/"
    unless_null $P1741, vivify_602
    $P1741 = root_new ['parrot';'Hash']
  vivify_602:
    set $P1742, $P1741["onlystar"]
    unless_null $P1742, vivify_603
    new $P1742, "Undef"
  vivify_603:
    if $P1742, if_1740
.annotate 'line', 729
    find_lex $P1744, "$/"
    unless_null $P1744, vivify_604
    $P1744 = root_new ['parrot';'Hash']
  vivify_604:
    set $P1745, $P1744["blockoid"]
    unless_null $P1745, vivify_605
    new $P1745, "Undef"
  vivify_605:
    $P1746 = $P1745."ast"()
    store_lex "$past", $P1746
.annotate 'line', 730
    find_lex $P1747, "$past"
    $P1747."blocktype"("declaration")
.annotate 'line', 731
    find_dynamic_lex $P1749, "$*RETURN_USED"
    unless_null $P1749, vivify_606
    get_hll_global $P1749, "$RETURN_USED"
    unless_null $P1749, vivify_607
    die "Contextual $*RETURN_USED not found"
  vivify_607:
  vivify_606:
    unless $P1749, if_1748_end
.annotate 'line', 732
    find_lex $P1750, "$past"
    $P1750."control"("return_pir")
  if_1748_end:
.annotate 'line', 728
    goto if_1740_end
  if_1740:
.annotate 'line', 726
    $P1743 = "only_star_block"()
    store_lex "$past", $P1743
  if_1740_end:
.annotate 'line', 737
    find_lex $P1752, "$past"
    unless_null $P1752, vivify_608
    $P1752 = root_new ['parrot';'Hash']
  vivify_608:
    set $P1753, $P1752["signature_has_invocant"]
    unless_null $P1753, vivify_609
    new $P1753, "Undef"
  vivify_609:
    if $P1753, unless_1751_end
.annotate 'line', 738
    find_lex $P1754, "$past"
    unless_null $P1754, vivify_610
    $P1754 = root_new ['parrot';'ResizablePMCArray']
  vivify_610:
    set $P1755, $P1754[0]
    unless_null $P1755, vivify_611
    new $P1755, "Undef"
  vivify_611:
    get_hll_global $P1756, ["PAST"], "Var"
.annotate 'line', 740
    get_hll_global $P1757, ["PAST"], "Var"
    $P1758 = $P1757."new"("$?CLASS" :named("name"))
    $P1759 = $P1756."new"("self" :named("name"), "parameter" :named("scope"), $P1758 :named("multitype"))
.annotate 'line', 738
    $P1755."unshift"($P1759)
  unless_1751_end:
.annotate 'line', 743
    find_lex $P1760, "$past"
    $P1760."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 746
    find_lex $P1762, "$/"
    unless_null $P1762, vivify_612
    $P1762 = root_new ['parrot';'Hash']
  vivify_612:
    set $P1763, $P1762["deflongname"]
    unless_null $P1763, vivify_613
    new $P1763, "Undef"
  vivify_613:
    unless $P1763, if_1761_end
    .const 'Sub' $P1765 = "100_1299465732.713" 
    capture_lex $P1765
    $P1765()
  if_1761_end:
.annotate 'line', 781
    find_dynamic_lex $P1831, "$*SCOPE"
    unless_null $P1831, vivify_631
    get_hll_global $P1831, "$SCOPE"
    unless_null $P1831, vivify_632
    die "Contextual $*SCOPE not found"
  vivify_632:
  vivify_631:
    set $S1832, $P1831
    iseq $I1833, $S1832, "our"
    unless $I1833, if_1830_end
.annotate 'line', 782
    find_lex $P1834, "$past"
    $P1834."pirflags"(":nsentry")
  if_1830_end:
.annotate 'line', 786
    find_lex $P1835, "$/"
    find_lex $P1836, "$past"
    $P1835."!make"($P1836)
.annotate 'line', 787
    find_lex $P1837, "$past"
    find_lex $P1838, "$past"
    unless_null $P1838, vivify_633
    $P1838 = root_new ['parrot';'Hash']
    store_lex "$past", $P1838
  vivify_633:
    set $P1838["block_past"], $P1837
.annotate 'line', 788
    find_lex $P1841, "$/"
    unless_null $P1841, vivify_634
    $P1841 = root_new ['parrot';'Hash']
  vivify_634:
    set $P1842, $P1841["trait"]
    unless_null $P1842, vivify_635
    new $P1842, "Undef"
  vivify_635:
    if $P1842, if_1840
    set $P1839, $P1842
    goto if_1840_end
  if_1840:
.annotate 'line', 789
    find_lex $P1844, "$/"
    unless_null $P1844, vivify_636
    $P1844 = root_new ['parrot';'Hash']
  vivify_636:
    set $P1845, $P1844["trait"]
    unless_null $P1845, vivify_637
    new $P1845, "Undef"
  vivify_637:
    defined $I1846, $P1845
    unless $I1846, for_undef_638
    iter $P1843, $P1845
    new $P1856, 'ExceptionHandler'
    set_label $P1856, loop1855_handler
    $P1856."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1856
  loop1855_test:
    unless $P1843, loop1855_done
    shift $P1847, $P1843
  loop1855_redo:
    .const 'Sub' $P1849 = "101_1299465732.713" 
    capture_lex $P1849
    $P1849($P1847)
  loop1855_next:
    goto loop1855_test
  loop1855_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1857, exception, 'type'
    eq $P1857, .CONTROL_LOOP_NEXT, loop1855_next
    eq $P1857, .CONTROL_LOOP_REDO, loop1855_redo
  loop1855_done:
    pop_eh 
  for_undef_638:
.annotate 'line', 788
    set $P1839, $P1843
  if_1840_end:
.annotate 'line', 721
    .return ($P1839)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1764"  :anon :subid("100_1299465732.713") :outer("99_1299465732.713")
.annotate 'line', 748
    new $P1766, "Undef"
    .lex "$name", $P1766
.annotate 'line', 753
    new $P1767, "Undef"
    .lex "$to_add", $P1767
.annotate 'line', 748
    find_lex $P1768, "$/"
    unless_null $P1768, vivify_614
    $P1768 = root_new ['parrot';'Hash']
  vivify_614:
    set $P1769, $P1768["private"]
    unless_null $P1769, vivify_615
    new $P1769, "Undef"
  vivify_615:
    set $S1770, $P1769
    new $P1771, 'String'
    set $P1771, $S1770
    find_lex $P1772, "$/"
    unless_null $P1772, vivify_616
    $P1772 = root_new ['parrot';'Hash']
  vivify_616:
    set $P1773, $P1772["deflongname"]
    unless_null $P1773, vivify_617
    $P1773 = root_new ['parrot';'ResizablePMCArray']
  vivify_617:
    set $P1774, $P1773[0]
    unless_null $P1774, vivify_618
    new $P1774, "Undef"
  vivify_618:
    $P1775 = $P1774."ast"()
    set $S1776, $P1775
    concat $P1777, $P1771, $S1776
    store_lex "$name", $P1777
.annotate 'line', 749
    find_lex $P1778, "$past"
    find_lex $P1779, "$name"
    $P1778."name"($P1779)
.annotate 'line', 753
    find_dynamic_lex $P1782, "$*MULTINESS"
    unless_null $P1782, vivify_619
    get_hll_global $P1782, "$MULTINESS"
    unless_null $P1782, vivify_620
    die "Contextual $*MULTINESS not found"
  vivify_620:
  vivify_619:
    set $S1783, $P1782
    isne $I1784, $S1783, "proto"
    if $I1784, if_1781
.annotate 'line', 755
    get_hll_global $P1788, ["PAST"], "Op"
.annotate 'line', 757
    get_hll_global $P1789, ["PAST"], "Val"
    find_lex $P1790, "$past"
    $P1791 = $P1789."new"($P1790 :named("value"))
.annotate 'line', 758
    get_hll_global $P1792, ["PAST"], "Op"
    $P1793 = $P1792."new"("list" :named("pasttype"))
    $P1794 = $P1788."new"($P1791, $P1793, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 755
    set $P1780, $P1794
.annotate 'line', 753
    goto if_1781_end
  if_1781:
.annotate 'line', 754
    get_hll_global $P1785, ["PAST"], "Val"
    find_lex $P1786, "$past"
    $P1787 = $P1785."new"($P1786 :named("value"))
    set $P1780, $P1787
  if_1781_end:
.annotate 'line', 753
    store_lex "$to_add", $P1780
.annotate 'line', 760
    find_dynamic_lex $P1796, "$*MULTINESS"
    unless_null $P1796, vivify_621
    get_hll_global $P1796, "$MULTINESS"
    unless_null $P1796, vivify_622
    die "Contextual $*MULTINESS not found"
  vivify_622:
  vivify_621:
    set $S1797, $P1796
    iseq $I1798, $S1797, "proto"
    unless $I1798, if_1795_end
    find_lex $P1799, "$past"
    $P1799."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1795_end:
.annotate 'line', 764
    find_dynamic_lex $P1801, "$*MULTINESS"
    unless_null $P1801, vivify_623
    get_hll_global $P1801, "$MULTINESS"
    unless_null $P1801, vivify_624
    die "Contextual $*MULTINESS not found"
  vivify_624:
  vivify_623:
    set $S1802, $P1801
    iseq $I1803, $S1802, "multi"
    unless $I1803, if_1800_end
    find_lex $P1804, "$past"
    "attach_multi_signature"($P1804)
  if_1800_end:
.annotate 'line', 767
    find_dynamic_lex $P1807, "$*PACKAGE-SETUP"
    unless_null $P1807, vivify_625
    get_hll_global $P1807, "$PACKAGE-SETUP"
    unless_null $P1807, vivify_626
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_626:
  vivify_625:
    defined $I1808, $P1807
    if $I1808, if_1806
    new $P1805, 'Integer'
    set $P1805, $I1808
    goto if_1806_end
  if_1806:
.annotate 'line', 768
    find_dynamic_lex $P1809, "$*PACKAGE-SETUP"
    unless_null $P1809, vivify_627
    get_hll_global $P1809, "$PACKAGE-SETUP"
    unless_null $P1809, vivify_628
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_628:
  vivify_627:
    get_hll_global $P1810, ["PAST"], "Op"
.annotate 'line', 769
    find_dynamic_lex $P1813, "$*MULTINESS"
    unless_null $P1813, vivify_629
    get_hll_global $P1813, "$MULTINESS"
    unless_null $P1813, vivify_630
    die "Contextual $*MULTINESS not found"
  vivify_630:
  vivify_629:
    set $S1814, $P1813
    iseq $I1815, $S1814, "multi"
    if $I1815, if_1812
    new $P1817, "String"
    assign $P1817, "add_method"
    set $P1811, $P1817
    goto if_1812_end
  if_1812:
    new $P1816, "String"
    assign $P1816, "add_multi_method"
    set $P1811, $P1816
  if_1812_end:
.annotate 'line', 770
    get_hll_global $P1818, ["PAST"], "Op"
.annotate 'line', 773
    get_hll_global $P1819, ["PAST"], "Var"
    $P1820 = $P1819."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1821 = $P1818."new"($P1820, "get_how PP" :named("pirop"))
.annotate 'line', 775
    get_hll_global $P1822, ["PAST"], "Var"
    $P1823 = $P1822."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 776
    get_hll_global $P1824, ["PAST"], "Val"
    find_lex $P1825, "$name"
    $P1826 = $P1824."new"($P1825 :named("value"))
    find_lex $P1827, "$to_add"
    $P1828 = $P1810."new"($P1821, $P1823, $P1826, $P1827, "callmethod" :named("pasttype"), $P1811 :named("name"))
.annotate 'line', 768
    $P1829 = $P1809."push"($P1828)
.annotate 'line', 767
    set $P1805, $P1829
  if_1806_end:
.annotate 'line', 746
    .return ($P1805)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1848"  :anon :subid("101_1299465732.713") :outer("99_1299465732.713")
    .param pmc param_1850
.annotate 'line', 789
    .lex "$_", param_1850
    find_lex $P1851, "$_"
    $P1852 = $P1851."ast"()
    find_lex $P1853, "$/"
    $P1854 = $P1852($P1853)
    .return ($P1854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("102_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1861
    .param pmc param_1862
.annotate 'line', 821
    .const 'Sub' $P1895 = "104_1299465732.713" 
    capture_lex $P1895
    .const 'Sub' $P1871 = "103_1299465732.713" 
    capture_lex $P1871
    .lex "self", param_1861
    .lex "$/", param_1862
.annotate 'line', 822
    new $P1863, "Undef"
    .lex "$BLOCKINIT", $P1863
    get_global $P1864, "@BLOCK"
    unless_null $P1864, vivify_639
    $P1864 = root_new ['parrot';'ResizablePMCArray']
  vivify_639:
    set $P1865, $P1864[0]
    unless_null $P1865, vivify_640
    $P1865 = root_new ['parrot';'ResizablePMCArray']
  vivify_640:
    set $P1866, $P1865[0]
    unless_null $P1866, vivify_641
    new $P1866, "Undef"
  vivify_641:
    store_lex "$BLOCKINIT", $P1866
.annotate 'line', 823
    find_lex $P1868, "$/"
    unless_null $P1868, vivify_642
    $P1868 = root_new ['parrot';'Hash']
  vivify_642:
    set $P1869, $P1868["invocant"]
    unless_null $P1869, vivify_643
    new $P1869, "Undef"
  vivify_643:
    unless $P1869, if_1867_end
    .const 'Sub' $P1871 = "103_1299465732.713" 
    capture_lex $P1871
    $P1871()
  if_1867_end:
.annotate 'line', 832
    find_lex $P1890, "$/"
    unless_null $P1890, vivify_649
    $P1890 = root_new ['parrot';'Hash']
  vivify_649:
    set $P1891, $P1890["parameter"]
    unless_null $P1891, vivify_650
    new $P1891, "Undef"
  vivify_650:
    defined $I1892, $P1891
    unless $I1892, for_undef_651
    iter $P1889, $P1891
    new $P1902, 'ExceptionHandler'
    set_label $P1902, loop1901_handler
    $P1902."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1902
  loop1901_test:
    unless $P1889, loop1901_done
    shift $P1893, $P1889
  loop1901_redo:
    .const 'Sub' $P1895 = "104_1299465732.713" 
    capture_lex $P1895
    $P1895($P1893)
  loop1901_next:
    goto loop1901_test
  loop1901_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1903, exception, 'type'
    eq $P1903, .CONTROL_LOOP_NEXT, loop1901_next
    eq $P1903, .CONTROL_LOOP_REDO, loop1901_redo
  loop1901_done:
    pop_eh 
  for_undef_651:
.annotate 'line', 821
    .return ($P1889)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1870"  :anon :subid("103_1299465732.713") :outer("102_1299465732.713")
.annotate 'line', 824
    new $P1872, "Undef"
    .lex "$inv", $P1872
    find_lex $P1873, "$/"
    unless_null $P1873, vivify_644
    $P1873 = root_new ['parrot';'Hash']
  vivify_644:
    set $P1874, $P1873["invocant"]
    unless_null $P1874, vivify_645
    $P1874 = root_new ['parrot';'ResizablePMCArray']
  vivify_645:
    set $P1875, $P1874[0]
    unless_null $P1875, vivify_646
    new $P1875, "Undef"
  vivify_646:
    $P1876 = $P1875."ast"()
    store_lex "$inv", $P1876
.annotate 'line', 825
    find_lex $P1877, "$BLOCKINIT"
    find_lex $P1878, "$inv"
    $P1877."push"($P1878)
.annotate 'line', 826
    find_lex $P1879, "$BLOCKINIT"
    get_hll_global $P1880, ["PAST"], "Var"
.annotate 'line', 828
    get_hll_global $P1881, ["PAST"], "Var"
    find_lex $P1882, "$inv"
    $P1883 = $P1882."name"()
    $P1884 = $P1881."new"("lexical" :named("scope"), $P1883 :named("name"))
    $P1885 = $P1880."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1884 :named("viviself"))
.annotate 'line', 826
    $P1879."push"($P1885)
.annotate 'line', 830
    new $P1886, "Integer"
    assign $P1886, 1
    get_global $P1887, "@BLOCK"
    unless_null $P1887, vivify_647
    $P1887 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1887
  vivify_647:
    set $P1888, $P1887[0]
    unless_null $P1888, vivify_648
    $P1888 = root_new ['parrot';'Hash']
    set $P1887[0], $P1888
  vivify_648:
    set $P1888["signature_has_invocant"], $P1886
.annotate 'line', 823
    .return ($P1886)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1894"  :anon :subid("104_1299465732.713") :outer("102_1299465732.713")
    .param pmc param_1896
.annotate 'line', 832
    .lex "$_", param_1896
    find_lex $P1897, "$BLOCKINIT"
    find_lex $P1898, "$_"
    $P1899 = $P1898."ast"()
    $P1900 = $P1897."push"($P1899)
    .return ($P1900)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("105_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_1905
    .param pmc param_1906
.annotate 'line', 835
    .lex "self", param_1905
    .lex "$/", param_1906
.annotate 'line', 836
    new $P1907, "Undef"
    .lex "$quant", $P1907
.annotate 'line', 837
    new $P1908, "Undef"
    .lex "$past", $P1908
.annotate 'line', 836
    find_lex $P1909, "$/"
    unless_null $P1909, vivify_652
    $P1909 = root_new ['parrot';'Hash']
  vivify_652:
    set $P1910, $P1909["quant"]
    unless_null $P1910, vivify_653
    new $P1910, "Undef"
  vivify_653:
    store_lex "$quant", $P1910
    find_lex $P1911, "$past"
.annotate 'line', 838
    find_lex $P1913, "$/"
    unless_null $P1913, vivify_654
    $P1913 = root_new ['parrot';'Hash']
  vivify_654:
    set $P1914, $P1913["named_param"]
    unless_null $P1914, vivify_655
    new $P1914, "Undef"
  vivify_655:
    if $P1914, if_1912
.annotate 'line', 845
    find_lex $P1928, "$/"
    unless_null $P1928, vivify_656
    $P1928 = root_new ['parrot';'Hash']
  vivify_656:
    set $P1929, $P1928["param_var"]
    unless_null $P1929, vivify_657
    new $P1929, "Undef"
  vivify_657:
    $P1930 = $P1929."ast"()
    store_lex "$past", $P1930
.annotate 'line', 846
    find_lex $P1932, "$quant"
    set $S1933, $P1932
    iseq $I1934, $S1933, "*"
    if $I1934, if_1931
.annotate 'line', 850
    find_lex $P1943, "$quant"
    set $S1944, $P1943
    iseq $I1945, $S1944, "?"
    unless $I1945, if_1942_end
.annotate 'line', 851
    find_lex $P1946, "$past"
    find_lex $P1947, "$/"
    unless_null $P1947, vivify_658
    $P1947 = root_new ['parrot';'Hash']
  vivify_658:
    set $P1948, $P1947["param_var"]
    unless_null $P1948, vivify_659
    $P1948 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1949, $P1948["sigil"]
    unless_null $P1949, vivify_660
    new $P1949, "Undef"
  vivify_660:
    $P1950 = "vivitype"($P1949)
    $P1946."viviself"($P1950)
  if_1942_end:
.annotate 'line', 850
    goto if_1931_end
  if_1931:
.annotate 'line', 847
    find_lex $P1935, "$past"
    $P1935."slurpy"(1)
.annotate 'line', 848
    find_lex $P1936, "$past"
    find_lex $P1937, "$/"
    unless_null $P1937, vivify_661
    $P1937 = root_new ['parrot';'Hash']
  vivify_661:
    set $P1938, $P1937["param_var"]
    unless_null $P1938, vivify_662
    $P1938 = root_new ['parrot';'Hash']
  vivify_662:
    set $P1939, $P1938["sigil"]
    unless_null $P1939, vivify_663
    new $P1939, "Undef"
  vivify_663:
    set $S1940, $P1939
    iseq $I1941, $S1940, "%"
    $P1936."named"($I1941)
  if_1931_end:
.annotate 'line', 844
    goto if_1912_end
  if_1912:
.annotate 'line', 839
    find_lex $P1915, "$/"
    unless_null $P1915, vivify_664
    $P1915 = root_new ['parrot';'Hash']
  vivify_664:
    set $P1916, $P1915["named_param"]
    unless_null $P1916, vivify_665
    new $P1916, "Undef"
  vivify_665:
    $P1917 = $P1916."ast"()
    store_lex "$past", $P1917
.annotate 'line', 840
    find_lex $P1919, "$quant"
    set $S1920, $P1919
    isne $I1921, $S1920, "!"
    unless $I1921, if_1918_end
.annotate 'line', 841
    find_lex $P1922, "$past"
    find_lex $P1923, "$/"
    unless_null $P1923, vivify_666
    $P1923 = root_new ['parrot';'Hash']
  vivify_666:
    set $P1924, $P1923["named_param"]
    unless_null $P1924, vivify_667
    $P1924 = root_new ['parrot';'Hash']
  vivify_667:
    set $P1925, $P1924["param_var"]
    unless_null $P1925, vivify_668
    $P1925 = root_new ['parrot';'Hash']
  vivify_668:
    set $P1926, $P1925["sigil"]
    unless_null $P1926, vivify_669
    new $P1926, "Undef"
  vivify_669:
    $P1927 = "vivitype"($P1926)
    $P1922."viviself"($P1927)
  if_1918_end:
  if_1912_end:
.annotate 'line', 854
    find_lex $P1952, "$/"
    unless_null $P1952, vivify_670
    $P1952 = root_new ['parrot';'Hash']
  vivify_670:
    set $P1953, $P1952["default_value"]
    unless_null $P1953, vivify_671
    new $P1953, "Undef"
  vivify_671:
    unless $P1953, if_1951_end
.annotate 'line', 855
    find_lex $P1955, "$quant"
    set $S1956, $P1955
    iseq $I1957, $S1956, "*"
    unless $I1957, if_1954_end
.annotate 'line', 856
    find_lex $P1958, "$/"
    $P1959 = $P1958."CURSOR"()
    $P1959."panic"("Can't put default on slurpy parameter")
  if_1954_end:
.annotate 'line', 858
    find_lex $P1961, "$quant"
    set $S1962, $P1961
    iseq $I1963, $S1962, "!"
    unless $I1963, if_1960_end
.annotate 'line', 859
    find_lex $P1964, "$/"
    $P1965 = $P1964."CURSOR"()
    $P1965."panic"("Can't put default on required parameter")
  if_1960_end:
.annotate 'line', 861
    find_lex $P1966, "$past"
    find_lex $P1967, "$/"
    unless_null $P1967, vivify_672
    $P1967 = root_new ['parrot';'Hash']
  vivify_672:
    set $P1968, $P1967["default_value"]
    unless_null $P1968, vivify_673
    $P1968 = root_new ['parrot';'ResizablePMCArray']
  vivify_673:
    set $P1969, $P1968[0]
    unless_null $P1969, vivify_674
    $P1969 = root_new ['parrot';'Hash']
  vivify_674:
    set $P1970, $P1969["EXPR"]
    unless_null $P1970, vivify_675
    new $P1970, "Undef"
  vivify_675:
    $P1971 = $P1970."ast"()
    $P1966."viviself"($P1971)
  if_1951_end:
.annotate 'line', 863
    find_lex $P1973, "$past"
    $P1974 = $P1973."viviself"()
    if $P1974, unless_1972_end
    get_global $P1975, "@BLOCK"
    unless_null $P1975, vivify_676
    $P1975 = root_new ['parrot';'ResizablePMCArray']
  vivify_676:
    set $P1976, $P1975[0]
    unless_null $P1976, vivify_677
    new $P1976, "Undef"
  vivify_677:
    get_global $P1977, "@BLOCK"
    unless_null $P1977, vivify_678
    $P1977 = root_new ['parrot';'ResizablePMCArray']
  vivify_678:
    set $P1978, $P1977[0]
    unless_null $P1978, vivify_679
    new $P1978, "Undef"
  vivify_679:
    $P1979 = $P1978."arity"()
    set $N1980, $P1979
    new $P1981, 'Float'
    set $P1981, $N1980
    add $P1982, $P1981, 1
    $P1976."arity"($P1982)
  unless_1972_end:
.annotate 'line', 867
    find_lex $P1984, "$/"
    unless_null $P1984, vivify_680
    $P1984 = root_new ['parrot';'Hash']
  vivify_680:
    set $P1985, $P1984["typename"]
    unless_null $P1985, vivify_681
    new $P1985, "Undef"
  vivify_681:
    unless $P1985, if_1983_end
.annotate 'line', 868
    find_lex $P1986, "$past"
    find_lex $P1987, "$/"
    unless_null $P1987, vivify_682
    $P1987 = root_new ['parrot';'Hash']
  vivify_682:
    set $P1988, $P1987["typename"]
    unless_null $P1988, vivify_683
    $P1988 = root_new ['parrot';'ResizablePMCArray']
  vivify_683:
    set $P1989, $P1988[0]
    unless_null $P1989, vivify_684
    new $P1989, "Undef"
  vivify_684:
    $P1990 = $P1989."ast"()
    $P1986."multitype"($P1990)
  if_1983_end:
.annotate 'line', 872
    find_lex $P1992, "$/"
    unless_null $P1992, vivify_685
    $P1992 = root_new ['parrot';'Hash']
  vivify_685:
    set $P1993, $P1992["definedness"]
    unless_null $P1993, vivify_686
    new $P1993, "Undef"
  vivify_686:
    unless $P1993, if_1991_end
.annotate 'line', 873
    find_lex $P1994, "$/"
    unless_null $P1994, vivify_687
    $P1994 = root_new ['parrot';'Hash']
  vivify_687:
    set $P1995, $P1994["definedness"]
    unless_null $P1995, vivify_688
    $P1995 = root_new ['parrot';'ResizablePMCArray']
  vivify_688:
    set $P1996, $P1995[0]
    unless_null $P1996, vivify_689
    new $P1996, "Undef"
  vivify_689:
    set $S1997, $P1996
    new $P1998, 'String'
    set $P1998, $S1997
    find_lex $P1999, "$past"
    unless_null $P1999, vivify_690
    $P1999 = root_new ['parrot';'Hash']
    store_lex "$past", $P1999
  vivify_690:
    set $P1999["definedness"], $P1998
  if_1991_end:
.annotate 'line', 876
    find_lex $P2000, "$/"
    find_lex $P2001, "$past"
    $P2002 = $P2000."!make"($P2001)
.annotate 'line', 835
    .return ($P2002)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("106_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2004
    .param pmc param_2005
.annotate 'line', 879
    .lex "self", param_2004
    .lex "$/", param_2005
.annotate 'line', 880
    new $P2006, "Undef"
    .lex "$name", $P2006
.annotate 'line', 881
    new $P2007, "Undef"
    .lex "$past", $P2007
.annotate 'line', 880
    find_lex $P2008, "$/"
    set $S2009, $P2008
    new $P2010, 'String'
    set $P2010, $S2009
    store_lex "$name", $P2010
.annotate 'line', 881
    get_hll_global $P2011, ["PAST"], "Var"
    find_lex $P2012, "$name"
    find_lex $P2013, "$/"
    $P2014 = $P2011."new"($P2012 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P2013 :named("node"))
    store_lex "$past", $P2014
.annotate 'line', 883
    get_global $P2015, "@BLOCK"
    unless_null $P2015, vivify_691
    $P2015 = root_new ['parrot';'ResizablePMCArray']
  vivify_691:
    set $P2016, $P2015[0]
    unless_null $P2016, vivify_692
    new $P2016, "Undef"
  vivify_692:
    find_lex $P2017, "$name"
    $P2016."symbol"($P2017, "lexical" :named("scope"))
.annotate 'line', 884
    find_lex $P2018, "$/"
    find_lex $P2019, "$past"
    $P2020 = $P2018."!make"($P2019)
.annotate 'line', 879
    .return ($P2020)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("107_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2022
    .param pmc param_2023
.annotate 'line', 887
    .lex "self", param_2022
    .lex "$/", param_2023
.annotate 'line', 888
    new $P2024, "Undef"
    .lex "$past", $P2024
    find_lex $P2025, "$/"
    unless_null $P2025, vivify_693
    $P2025 = root_new ['parrot';'Hash']
  vivify_693:
    set $P2026, $P2025["param_var"]
    unless_null $P2026, vivify_694
    new $P2026, "Undef"
  vivify_694:
    $P2027 = $P2026."ast"()
    store_lex "$past", $P2027
.annotate 'line', 889
    find_lex $P2028, "$past"
    find_lex $P2029, "$/"
    unless_null $P2029, vivify_695
    $P2029 = root_new ['parrot';'Hash']
  vivify_695:
    set $P2030, $P2029["param_var"]
    unless_null $P2030, vivify_696
    $P2030 = root_new ['parrot';'Hash']
  vivify_696:
    set $P2031, $P2030["name"]
    unless_null $P2031, vivify_697
    new $P2031, "Undef"
  vivify_697:
    set $S2032, $P2031
    $P2028."named"($S2032)
.annotate 'line', 890
    find_lex $P2033, "$/"
    find_lex $P2034, "$past"
    $P2035 = $P2033."!make"($P2034)
.annotate 'line', 887
    .return ($P2035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("108_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2037
    .param pmc param_2038
.annotate 'line', 893
    .lex "self", param_2037
    .lex "$/", param_2038
.annotate 'line', 894
    $P2039 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2039
    get_hll_global $P2040, ["HLL"], "Compiler"
    find_lex $P2041, "$/"
    set $S2042, $P2041
    $P2043 = $P2040."parse_name"($S2042)
    store_lex "@name", $P2043
.annotate 'line', 895
    find_lex $P2044, "$/"
    get_hll_global $P2045, ["PAST"], "Var"
.annotate 'line', 896
    find_lex $P2046, "@name"
    $P2047 = $P2046."pop"()
    find_lex $P2048, "@name"
    $P2049 = $P2045."new"($P2047 :named("name"), $P2048 :named("namespace"), "package" :named("scope"))
.annotate 'line', 895
    $P2050 = $P2044."!make"($P2049)
.annotate 'line', 893
    .return ($P2050)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("109_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2052
    .param pmc param_2053
.annotate 'line', 902
    .lex "self", param_2052
    .lex "$/", param_2053
.annotate 'line', 903
    find_lex $P2054, "$/"
    find_lex $P2055, "$/"
    unless_null $P2055, vivify_698
    $P2055 = root_new ['parrot';'Hash']
  vivify_698:
    set $P2056, $P2055["trait_mod"]
    unless_null $P2056, vivify_699
    new $P2056, "Undef"
  vivify_699:
    $P2057 = $P2056."ast"()
    $P2058 = $P2054."!make"($P2057)
.annotate 'line', 902
    .return ($P2058)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("110_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2060
    .param pmc param_2061
.annotate 'line', 906
    .const 'Sub' $P2081 = "111_1299465732.713" 
    capture_lex $P2081
    .lex "self", param_2060
    .lex "$/", param_2061
.annotate 'line', 907
    new $P2062, "Undef"
    .lex "$cpast", $P2062
    find_lex $P2063, "$/"
    unless_null $P2063, vivify_700
    $P2063 = root_new ['parrot';'Hash']
  vivify_700:
    set $P2064, $P2063["circumfix"]
    unless_null $P2064, vivify_701
    $P2064 = root_new ['parrot';'ResizablePMCArray']
  vivify_701:
    set $P2065, $P2064[0]
    unless_null $P2065, vivify_702
    new $P2065, "Undef"
  vivify_702:
    $P2066 = $P2065."ast"()
    store_lex "$cpast", $P2066
.annotate 'line', 908
    find_lex $P2069, "$/"
    unless_null $P2069, vivify_703
    $P2069 = root_new ['parrot';'Hash']
  vivify_703:
    set $P2070, $P2069["longname"]
    unless_null $P2070, vivify_704
    new $P2070, "Undef"
  vivify_704:
    set $S2071, $P2070
    iseq $I2072, $S2071, "parrot_vtable"
    if $I2072, if_2068
.annotate 'line', 928
    find_lex $P2107, "$/"
    unless_null $P2107, vivify_705
    $P2107 = root_new ['parrot';'Hash']
  vivify_705:
    set $P2108, $P2107["longname"]
    unless_null $P2108, vivify_706
    new $P2108, "Undef"
  vivify_706:
    set $S2109, $P2108
    iseq $I2110, $S2109, "pirflags"
    if $I2110, if_2106
.annotate 'line', 932
    find_lex $P2114, "$/"
    $P2115 = $P2114."CURSOR"()
    new $P2116, 'String'
    set $P2116, "Trait '"
    find_lex $P2117, "$/"
    unless_null $P2117, vivify_707
    $P2117 = root_new ['parrot';'Hash']
  vivify_707:
    set $P2118, $P2117["longname"]
    unless_null $P2118, vivify_708
    new $P2118, "Undef"
  vivify_708:
    concat $P2119, $P2116, $P2118
    concat $P2120, $P2119, "' not implemented"
    $P2121 = $P2115."panic"($P2120)
.annotate 'line', 931
    set $P2105, $P2121
.annotate 'line', 928
    goto if_2106_end
  if_2106:
.annotate 'line', 929
    find_lex $P2111, "$/"
    $P2112 = $P2111."CURSOR"()
    $P2113 = $P2112."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 928
    set $P2105, $P2113
  if_2106_end:
    set $P2067, $P2105
.annotate 'line', 908
    goto if_2068_end
  if_2068:
.annotate 'line', 911
    get_hll_global $P2074, ["PAST"], "Val"
    find_lex $P2075, "$cpast"
    $P2076 = $P2074."ACCEPTS"($P2075)
    if $P2076, unless_2073_end
.annotate 'line', 910
    find_lex $P2077, "$/"
    $P2078 = $P2077."CURSOR"()
    $P2078."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2073_end:
.annotate 'line', 912
    find_lex $P2079, "$/"
    .const 'Sub' $P2081 = "111_1299465732.713" 
    newclosure $P2103, $P2081
    $P2104 = $P2079."!make"($P2103)
.annotate 'line', 908
    set $P2067, $P2104
  if_2068_end:
.annotate 'line', 906
    .return ($P2067)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2080"  :anon :subid("111_1299465732.713") :outer("110_1299465732.713")
    .param pmc param_2082
.annotate 'line', 912
    .lex "$match", param_2082
.annotate 'line', 913
    new $P2083, "Undef"
    .lex "$meth", $P2083
    find_lex $P2084, "$match"
    $P2085 = $P2084."ast"()
    set $P2086, $P2085["block_past"]
    unless_null $P2086, vivify_709
    new $P2086, "Undef"
  vivify_709:
    store_lex "$meth", $P2086
.annotate 'line', 914
    find_dynamic_lex $P2089, "$*PACKAGE-SETUP"
    unless_null $P2089, vivify_710
    get_hll_global $P2089, "$PACKAGE-SETUP"
    unless_null $P2089, vivify_711
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_711:
  vivify_710:
    defined $I2090, $P2089
    if $I2090, if_2088
    new $P2087, 'Integer'
    set $P2087, $I2090
    goto if_2088_end
  if_2088:
.annotate 'line', 915
    find_dynamic_lex $P2091, "$*PACKAGE-SETUP"
    unless_null $P2091, vivify_712
    get_hll_global $P2091, "$PACKAGE-SETUP"
    unless_null $P2091, vivify_713
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_713:
  vivify_712:
    get_hll_global $P2092, ["PAST"], "Op"
.annotate 'line', 917
    get_hll_global $P2093, ["PAST"], "Op"
.annotate 'line', 920
    get_hll_global $P2094, ["PAST"], "Var"
    $P2095 = $P2094."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2096 = $P2093."new"($P2095, "get_how PP" :named("pirop"))
.annotate 'line', 922
    get_hll_global $P2097, ["PAST"], "Var"
    $P2098 = $P2097."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2099, "$cpast"
    find_lex $P2100, "$meth"
    $P2101 = $P2092."new"($P2096, $P2098, $P2099, $P2100, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 915
    $P2102 = $P2091."push"($P2101)
.annotate 'line', 914
    set $P2087, $P2102
  if_2088_end:
.annotate 'line', 912
    .return ($P2087)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("112_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2125
    .param pmc param_2126
    .param pmc param_2127 :optional
    .param int has_param_2127 :opt_flag
.annotate 'line', 936
    .const 'Sub' $P2225 = "115_1299465732.713" 
    capture_lex $P2225
    .const 'Sub' $P2197 = "114_1299465732.713" 
    capture_lex $P2197
    .const 'Sub' $P2170 = "113_1299465732.713" 
    capture_lex $P2170
    new $P2124, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2124, control_2123
    push_eh $P2124
    .lex "self", param_2125
    .lex "$/", param_2126
    if has_param_2127, optparam_714
    new $P2128, "Undef"
    set param_2127, $P2128
  optparam_714:
    .lex "$key", param_2127
.annotate 'line', 937
    $P2129 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2129
.annotate 'line', 940
    new $P2130, "Undef"
    .lex "$name", $P2130
.annotate 'line', 941
    new $P2131, "Undef"
    .lex "$past", $P2131
.annotate 'line', 937

        $P2132 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2132
.annotate 'line', 940
    find_lex $P2133, "$/"
    unless_null $P2133, vivify_715
    $P2133 = root_new ['parrot';'Hash']
  vivify_715:
    set $P2134, $P2133["deflongname"]
    unless_null $P2134, vivify_716
    new $P2134, "Undef"
  vivify_716:
    $P2135 = $P2134."ast"()
    set $S2136, $P2135
    new $P2137, 'String'
    set $P2137, $S2136
    store_lex "$name", $P2137
    find_lex $P2138, "$past"
.annotate 'line', 942
    find_lex $P2140, "$/"
    unless_null $P2140, vivify_717
    $P2140 = root_new ['parrot';'Hash']
  vivify_717:
    set $P2141, $P2140["proto"]
    unless_null $P2141, vivify_718
    new $P2141, "Undef"
  vivify_718:
    if $P2141, if_2139
.annotate 'line', 981
    find_lex $P2193, "$key"
    set $S2194, $P2193
    iseq $I2195, $S2194, "open"
    if $I2195, if_2192
.annotate 'line', 994
    .const 'Sub' $P2225 = "115_1299465732.713" 
    capture_lex $P2225
    $P2225()
    goto if_2192_end
  if_2192:
.annotate 'line', 981
    .const 'Sub' $P2197 = "114_1299465732.713" 
    capture_lex $P2197
    $P2197()
  if_2192_end:
    goto if_2139_end
  if_2139:
.annotate 'line', 944
    get_hll_global $P2142, ["PAST"], "Stmts"
.annotate 'line', 945
    get_hll_global $P2143, ["PAST"], "Block"
    find_lex $P2144, "$name"
.annotate 'line', 946
    get_hll_global $P2145, ["PAST"], "Op"
.annotate 'line', 947
    get_hll_global $P2146, ["PAST"], "Var"
    $P2147 = $P2146."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2148, "$name"
    $P2149 = $P2145."new"($P2147, $P2148, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 946
    find_lex $P2150, "$/"
    $P2151 = $P2143."new"($P2149, $P2144 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2150 :named("node"))
.annotate 'line', 956
    get_hll_global $P2152, ["PAST"], "Block"
    new $P2153, "String"
    assign $P2153, "!PREFIX__"
    find_lex $P2154, "$name"
    concat $P2155, $P2153, $P2154
.annotate 'line', 957
    get_hll_global $P2156, ["PAST"], "Op"
.annotate 'line', 958
    get_hll_global $P2157, ["PAST"], "Var"
    $P2158 = $P2157."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2159, "$name"
    $P2160 = $P2156."new"($P2158, $P2159, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 957
    find_lex $P2161, "$/"
    $P2162 = $P2152."new"($P2160, $P2155 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2161 :named("node"))
.annotate 'line', 956
    $P2163 = $P2142."new"($P2151, $P2162)
.annotate 'line', 944
    store_lex "$past", $P2163
.annotate 'line', 968
    find_lex $P2165, "$past"
    $P2166 = $P2165."list"()
    defined $I2167, $P2166
    unless $I2167, for_undef_739
    iter $P2164, $P2166
    new $P2190, 'ExceptionHandler'
    set_label $P2190, loop2189_handler
    $P2190."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2190
  loop2189_test:
    unless $P2164, loop2189_done
    shift $P2168, $P2164
  loop2189_redo:
    .const 'Sub' $P2170 = "113_1299465732.713" 
    capture_lex $P2170
    $P2170($P2168)
  loop2189_next:
    goto loop2189_test
  loop2189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2191, exception, 'type'
    eq $P2191, .CONTROL_LOOP_NEXT, loop2189_next
    eq $P2191, .CONTROL_LOOP_REDO, loop2189_redo
  loop2189_done:
    pop_eh 
  for_undef_739:
  if_2139_end:
.annotate 'line', 1030
    find_lex $P2283, "$/"
    find_lex $P2284, "$past"
    $P2285 = $P2283."!make"($P2284)
.annotate 'line', 936
    .return ($P2285)
  control_2123:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2286, exception, "payload"
    .return ($P2286)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2224"  :anon :subid("115_1299465732.713") :outer("112_1299465732.713")
.annotate 'line', 995
    new $P2226, "Undef"
    .lex "$regex", $P2226
.annotate 'line', 996
    get_hll_global $P2227, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2228, "$/"
    unless_null $P2228, vivify_719
    $P2228 = root_new ['parrot';'Hash']
  vivify_719:
    set $P2229, $P2228["p6regex"]
    unless_null $P2229, vivify_720
    new $P2229, "Undef"
  vivify_720:
    $P2230 = $P2229."ast"()
    get_global $P2231, "@BLOCK"
    $P2232 = $P2231."shift"()
    $P2233 = $P2227($P2230, $P2232)
    store_lex "$regex", $P2233
.annotate 'line', 997
    find_lex $P2234, "$regex"
    find_lex $P2235, "$name"
    $P2234."name"($P2235)
.annotate 'line', 999
    get_hll_global $P2236, ["PAST"], "Op"
.annotate 'line', 1001
    get_hll_global $P2237, ["PAST"], "Var"
    new $P2238, "ResizablePMCArray"
    push $P2238, "Regex"
    $P2239 = $P2237."new"("Method" :named("name"), $P2238 :named("namespace"), "package" :named("scope"))
    find_lex $P2240, "$regex"
    $P2241 = $P2236."new"($P2239, $P2240, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 999
    store_lex "$past", $P2241
.annotate 'line', 1004
    find_dynamic_lex $P2243, "$*PACKAGE-SETUP"
    unless_null $P2243, vivify_721
    get_hll_global $P2243, "$PACKAGE-SETUP"
    unless_null $P2243, vivify_722
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_722:
  vivify_721:
    defined $I2244, $P2243
    unless $I2244, if_2242_end
.annotate 'line', 1005
    find_dynamic_lex $P2245, "$*PACKAGE-SETUP"
    unless_null $P2245, vivify_723
    get_hll_global $P2245, "$PACKAGE-SETUP"
    unless_null $P2245, vivify_724
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_724:
  vivify_723:
    get_hll_global $P2246, ["PAST"], "Op"
.annotate 'line', 1007
    get_hll_global $P2247, ["PAST"], "Op"
.annotate 'line', 1009
    get_hll_global $P2248, ["PAST"], "Var"
    $P2249 = $P2248."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2250 = $P2247."new"($P2249, "get_how PP" :named("pirop"))
.annotate 'line', 1011
    get_hll_global $P2251, ["PAST"], "Var"
    $P2252 = $P2251."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1012
    get_hll_global $P2253, ["PAST"], "Val"
    find_lex $P2254, "$name"
    $P2255 = $P2253."new"($P2254 :named("value"))
.annotate 'line', 1013
    get_hll_global $P2256, ["PAST"], "Val"
    find_lex $P2257, "$regex"
    $P2258 = $P2256."new"($P2257 :named("value"))
    $P2259 = $P2246."new"($P2250, $P2252, $P2255, $P2258, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1005
    $P2245."push"($P2259)
.annotate 'line', 1015
    find_dynamic_lex $P2260, "$*PACKAGE-SETUP"
    unless_null $P2260, vivify_725
    get_hll_global $P2260, "$PACKAGE-SETUP"
    unless_null $P2260, vivify_726
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_726:
  vivify_725:
    get_hll_global $P2261, ["PAST"], "Op"
.annotate 'line', 1017
    get_hll_global $P2262, ["PAST"], "Op"
.annotate 'line', 1019
    get_hll_global $P2263, ["PAST"], "Var"
    $P2264 = $P2263."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2265 = $P2262."new"($P2264, "get_how PP" :named("pirop"))
.annotate 'line', 1021
    get_hll_global $P2266, ["PAST"], "Var"
    $P2267 = $P2266."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1022
    get_hll_global $P2268, ["PAST"], "Val"
    new $P2269, "String"
    assign $P2269, "!PREFIX__"
    find_lex $P2270, "$name"
    concat $P2271, $P2269, $P2270
    $P2272 = $P2268."new"($P2271 :named("value"))
.annotate 'line', 1023
    get_hll_global $P2273, ["PAST"], "Var"
    new $P2274, "String"
    assign $P2274, "!PREFIX__"
    find_lex $P2275, "$name"
    concat $P2276, $P2274, $P2275
    $P2277 = $P2273."new"($P2276 :named("name"), "package" :named("scope"))
    $P2278 = $P2261."new"($P2265, $P2267, $P2272, $P2277, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1015
    $P2260."push"($P2278)
  if_2242_end:
.annotate 'line', 1027
    find_lex $P2279, "$regex"
    find_lex $P2280, "$past"
    unless_null $P2280, vivify_727
    $P2280 = root_new ['parrot';'Hash']
    store_lex "$past", $P2280
  vivify_727:
    set $P2280["sink"], $P2279
.annotate 'line', 1028
    find_lex $P2281, "@MODIFIERS"
    $P2282 = $P2281."shift"()
.annotate 'line', 994
    .return ($P2282)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2196"  :anon :subid("114_1299465732.713") :outer("112_1299465732.713")
.annotate 'line', 982
    $P2198 = root_new ['parrot';'Hash']
    .lex "%h", $P2198
.annotate 'line', 981
    find_lex $P2199, "%h"
.annotate 'line', 983
    find_lex $P2201, "$/"
    unless_null $P2201, vivify_728
    $P2201 = root_new ['parrot';'Hash']
  vivify_728:
    set $P2202, $P2201["sym"]
    unless_null $P2202, vivify_729
    new $P2202, "Undef"
  vivify_729:
    set $S2203, $P2202
    iseq $I2204, $S2203, "token"
    unless $I2204, if_2200_end
    new $P2205, "Integer"
    assign $P2205, 1
    find_lex $P2206, "%h"
    unless_null $P2206, vivify_730
    $P2206 = root_new ['parrot';'Hash']
    store_lex "%h", $P2206
  vivify_730:
    set $P2206["r"], $P2205
  if_2200_end:
.annotate 'line', 984
    find_lex $P2208, "$/"
    unless_null $P2208, vivify_731
    $P2208 = root_new ['parrot';'Hash']
  vivify_731:
    set $P2209, $P2208["sym"]
    unless_null $P2209, vivify_732
    new $P2209, "Undef"
  vivify_732:
    set $S2210, $P2209
    iseq $I2211, $S2210, "rule"
    unless $I2211, if_2207_end
    new $P2212, "Integer"
    assign $P2212, 1
    find_lex $P2213, "%h"
    unless_null $P2213, vivify_733
    $P2213 = root_new ['parrot';'Hash']
    store_lex "%h", $P2213
  vivify_733:
    set $P2213["r"], $P2212
    new $P2214, "Integer"
    assign $P2214, 1
    find_lex $P2215, "%h"
    unless_null $P2215, vivify_734
    $P2215 = root_new ['parrot';'Hash']
    store_lex "%h", $P2215
  vivify_734:
    set $P2215["s"], $P2214
  if_2207_end:
.annotate 'line', 985
    find_lex $P2216, "@MODIFIERS"
    find_lex $P2217, "%h"
    $P2216."unshift"($P2217)
.annotate 'line', 986

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 990
    get_global $P2218, "@BLOCK"
    unless_null $P2218, vivify_735
    $P2218 = root_new ['parrot';'ResizablePMCArray']
  vivify_735:
    set $P2219, $P2218[0]
    unless_null $P2219, vivify_736
    new $P2219, "Undef"
  vivify_736:
    $P2219."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 991
    get_global $P2220, "@BLOCK"
    unless_null $P2220, vivify_737
    $P2220 = root_new ['parrot';'ResizablePMCArray']
  vivify_737:
    set $P2221, $P2220[0]
    unless_null $P2221, vivify_738
    new $P2221, "Undef"
  vivify_738:
    $P2221."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 992
    new $P2222, "Exception"
    set $P2222['type'], .CONTROL_RETURN
    new $P2223, "Integer"
    assign $P2223, 0
    setattribute $P2222, 'payload', $P2223
    throw $P2222
.annotate 'line', 981
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2169"  :anon :subid("113_1299465732.713") :outer("112_1299465732.713")
    .param pmc param_2171
.annotate 'line', 968
    .lex "$_", param_2171
.annotate 'line', 969
    find_dynamic_lex $P2172, "$*PACKAGE-SETUP"
    unless_null $P2172, vivify_740
    get_hll_global $P2172, "$PACKAGE-SETUP"
    unless_null $P2172, vivify_741
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_741:
  vivify_740:
    get_hll_global $P2173, ["PAST"], "Op"
.annotate 'line', 971
    get_hll_global $P2174, ["PAST"], "Op"
.annotate 'line', 973
    get_hll_global $P2175, ["PAST"], "Var"
    $P2176 = $P2175."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2177 = $P2174."new"($P2176, "get_how PP" :named("pirop"))
.annotate 'line', 975
    get_hll_global $P2178, ["PAST"], "Var"
    $P2179 = $P2178."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 976
    get_hll_global $P2180, ["PAST"], "Val"
    find_lex $P2181, "$_"
    $P2182 = $P2181."name"()
    $P2183 = $P2180."new"($P2182 :named("value"))
.annotate 'line', 977
    get_hll_global $P2184, ["PAST"], "Val"
    find_lex $P2185, "$_"
    $P2186 = $P2184."new"($P2185 :named("value"))
    $P2187 = $P2173."new"($P2177, $P2179, $P2183, $P2186, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 969
    $P2188 = $P2172."push"($P2187)
.annotate 'line', 968
    .return ($P2188)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("116_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2288
    .param pmc param_2289
.annotate 'line', 1034
    .lex "self", param_2288
    .lex "$/", param_2289
.annotate 'line', 1035
    new $P2290, "Undef"
    .lex "$past", $P2290
    find_lex $P2293, "$/"
    unless_null $P2293, vivify_742
    $P2293 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2294, $P2293["args"]
    unless_null $P2294, vivify_743
    new $P2294, "Undef"
  vivify_743:
    if $P2294, if_2292
    get_hll_global $P2299, ["PAST"], "Op"
    find_lex $P2300, "$/"
    $P2301 = $P2299."new"($P2300 :named("node"))
    set $P2291, $P2301
    goto if_2292_end
  if_2292:
    find_lex $P2295, "$/"
    unless_null $P2295, vivify_744
    $P2295 = root_new ['parrot';'Hash']
  vivify_744:
    set $P2296, $P2295["args"]
    unless_null $P2296, vivify_745
    $P2296 = root_new ['parrot';'ResizablePMCArray']
  vivify_745:
    set $P2297, $P2296[0]
    unless_null $P2297, vivify_746
    new $P2297, "Undef"
  vivify_746:
    $P2298 = $P2297."ast"()
    set $P2291, $P2298
  if_2292_end:
    store_lex "$past", $P2291
.annotate 'line', 1036
    find_lex $P2303, "$/"
    unless_null $P2303, vivify_747
    $P2303 = root_new ['parrot';'Hash']
  vivify_747:
    set $P2304, $P2303["quote"]
    unless_null $P2304, vivify_748
    new $P2304, "Undef"
  vivify_748:
    if $P2304, if_2302
.annotate 'line', 1040
    find_lex $P2311, "$/"
    unless_null $P2311, vivify_749
    $P2311 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2312, $P2311["longname"]
    unless_null $P2312, vivify_750
    new $P2312, "Undef"
  vivify_750:
    set $S2313, $P2312
    iseq $I2314, $S2313, "HOW"
    if $I2314, if_2310
.annotate 'line', 1044
    find_lex $P2318, "$/"
    unless_null $P2318, vivify_751
    $P2318 = root_new ['parrot';'Hash']
  vivify_751:
    set $P2319, $P2318["longname"]
    unless_null $P2319, vivify_752
    new $P2319, "Undef"
  vivify_752:
    set $S2320, $P2319
    iseq $I2321, $S2320, "WHAT"
    if $I2321, if_2317
.annotate 'line', 1048
    find_lex $P2323, "$past"
    find_lex $P2324, "$/"
    unless_null $P2324, vivify_753
    $P2324 = root_new ['parrot';'Hash']
  vivify_753:
    set $P2325, $P2324["longname"]
    unless_null $P2325, vivify_754
    new $P2325, "Undef"
  vivify_754:
    set $S2326, $P2325
    $P2323."name"($S2326)
.annotate 'line', 1049
    find_lex $P2327, "$past"
    $P2327."pasttype"("callmethod")
.annotate 'line', 1047
    goto if_2317_end
  if_2317:
.annotate 'line', 1045
    find_lex $P2322, "$past"
    $P2322."pirop"("get_what PP")
  if_2317_end:
.annotate 'line', 1044
    goto if_2310_end
  if_2310:
.annotate 'line', 1041
    find_lex $P2315, "$past"
    $P2315."pirop"("get_how PP")
.annotate 'line', 1042
    find_lex $P2316, "$past"
    $P2316."pasttype"("pirop")
  if_2310_end:
.annotate 'line', 1040
    goto if_2302_end
  if_2302:
.annotate 'line', 1037
    find_lex $P2305, "$past"
    find_lex $P2306, "$/"
    unless_null $P2306, vivify_755
    $P2306 = root_new ['parrot';'Hash']
  vivify_755:
    set $P2307, $P2306["quote"]
    unless_null $P2307, vivify_756
    new $P2307, "Undef"
  vivify_756:
    $P2308 = $P2307."ast"()
    $P2305."name"($P2308)
.annotate 'line', 1038
    find_lex $P2309, "$past"
    $P2309."pasttype"("callmethod")
  if_2302_end:
.annotate 'line', 1051
    find_lex $P2328, "$/"
    find_lex $P2329, "$past"
    $P2330 = $P2328."!make"($P2329)
.annotate 'line', 1034
    .return ($P2330)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("117_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2332
    .param pmc param_2333
.annotate 'line', 1056
    .lex "self", param_2332
    .lex "$/", param_2333
.annotate 'line', 1057
    find_lex $P2334, "$/"
    get_hll_global $P2335, ["PAST"], "Var"
    $P2336 = $P2335."new"("self" :named("name"))
    $P2337 = $P2334."!make"($P2336)
.annotate 'line', 1056
    .return ($P2337)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("118_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2339
    .param pmc param_2340
.annotate 'line', 1060
    .lex "self", param_2339
    .lex "$/", param_2340
.annotate 'line', 1061
    new $P2341, "Undef"
    .lex "$past", $P2341
    find_lex $P2342, "$/"
    unless_null $P2342, vivify_757
    $P2342 = root_new ['parrot';'Hash']
  vivify_757:
    set $P2343, $P2342["args"]
    unless_null $P2343, vivify_758
    new $P2343, "Undef"
  vivify_758:
    $P2344 = $P2343."ast"()
    store_lex "$past", $P2344
.annotate 'line', 1062
    find_lex $P2345, "$past"
    find_lex $P2346, "$/"
    unless_null $P2346, vivify_759
    $P2346 = root_new ['parrot';'Hash']
  vivify_759:
    set $P2347, $P2346["deflongname"]
    unless_null $P2347, vivify_760
    new $P2347, "Undef"
  vivify_760:
    set $S2348, $P2347
    $P2345."name"($S2348)
.annotate 'line', 1063
    find_lex $P2349, "$/"
    find_lex $P2350, "$past"
    $P2351 = $P2349."!make"($P2350)
.annotate 'line', 1060
    .return ($P2351)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("119_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2353
    .param pmc param_2354
.annotate 'line', 1066
    .lex "self", param_2353
    .lex "$/", param_2354
.annotate 'line', 1067
    $P2355 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2355
.annotate 'line', 1068
    new $P2356, "Undef"
    .lex "$name", $P2356
.annotate 'line', 1070
    new $P2357, "Undef"
    .lex "$var", $P2357
.annotate 'line', 1072
    new $P2358, "Undef"
    .lex "$past", $P2358
.annotate 'line', 1067
    find_lex $P2359, "$/"
    unless_null $P2359, vivify_761
    $P2359 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2360, $P2359["name"]
    unless_null $P2360, vivify_762
    $P2360 = root_new ['parrot';'Hash']
  vivify_762:
    set $P2361, $P2360["identifier"]
    unless_null $P2361, vivify_763
    new $P2361, "Undef"
  vivify_763:
    clone $P2362, $P2361
    store_lex "@ns", $P2362
.annotate 'line', 1068
    find_lex $P2363, "@ns"
    $P2364 = $P2363."pop"()
    store_lex "$name", $P2364
.annotate 'line', 1069
    find_lex $P2368, "@ns"
    if $P2368, if_2367
    set $P2366, $P2368
    goto if_2367_end
  if_2367:
    find_lex $P2369, "@ns"
    unless_null $P2369, vivify_764
    $P2369 = root_new ['parrot';'ResizablePMCArray']
  vivify_764:
    set $P2370, $P2369[0]
    unless_null $P2370, vivify_765
    new $P2370, "Undef"
  vivify_765:
    set $S2371, $P2370
    iseq $I2372, $S2371, "GLOBAL"
    new $P2366, 'Integer'
    set $P2366, $I2372
  if_2367_end:
    unless $P2366, if_2365_end
    find_lex $P2373, "@ns"
    $P2373."shift"()
  if_2365_end:
.annotate 'line', 1071
    get_hll_global $P2374, ["PAST"], "Var"
    find_lex $P2375, "$name"
    set $S2376, $P2375
    find_lex $P2377, "@ns"
    $P2378 = $P2374."new"($S2376 :named("name"), $P2377 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2378
.annotate 'line', 1072
    find_lex $P2379, "$var"
    store_lex "$past", $P2379
.annotate 'line', 1073
    find_lex $P2381, "$/"
    unless_null $P2381, vivify_766
    $P2381 = root_new ['parrot';'Hash']
  vivify_766:
    set $P2382, $P2381["args"]
    unless_null $P2382, vivify_767
    new $P2382, "Undef"
  vivify_767:
    unless $P2382, if_2380_end
.annotate 'line', 1074
    find_lex $P2383, "$/"
    unless_null $P2383, vivify_768
    $P2383 = root_new ['parrot';'Hash']
  vivify_768:
    set $P2384, $P2383["args"]
    unless_null $P2384, vivify_769
    $P2384 = root_new ['parrot';'ResizablePMCArray']
  vivify_769:
    set $P2385, $P2384[0]
    unless_null $P2385, vivify_770
    new $P2385, "Undef"
  vivify_770:
    $P2386 = $P2385."ast"()
    store_lex "$past", $P2386
.annotate 'line', 1075
    find_lex $P2387, "$past"
    find_lex $P2388, "$var"
    $P2387."unshift"($P2388)
  if_2380_end:
.annotate 'line', 1077
    find_lex $P2389, "$/"
    find_lex $P2390, "$past"
    $P2391 = $P2389."!make"($P2390)
.annotate 'line', 1066
    .return ($P2391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("120_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2393
    .param pmc param_2394
.annotate 'line', 1080
    .lex "self", param_2393
    .lex "$/", param_2394
.annotate 'line', 1081
    new $P2395, "Undef"
    .lex "$past", $P2395
.annotate 'line', 1082
    new $P2396, "Undef"
    .lex "$pirop", $P2396
.annotate 'line', 1081
    find_lex $P2399, "$/"
    unless_null $P2399, vivify_771
    $P2399 = root_new ['parrot';'Hash']
  vivify_771:
    set $P2400, $P2399["args"]
    unless_null $P2400, vivify_772
    new $P2400, "Undef"
  vivify_772:
    if $P2400, if_2398
    get_hll_global $P2405, ["PAST"], "Op"
    find_lex $P2406, "$/"
    $P2407 = $P2405."new"($P2406 :named("node"))
    set $P2397, $P2407
    goto if_2398_end
  if_2398:
    find_lex $P2401, "$/"
    unless_null $P2401, vivify_773
    $P2401 = root_new ['parrot';'Hash']
  vivify_773:
    set $P2402, $P2401["args"]
    unless_null $P2402, vivify_774
    $P2402 = root_new ['parrot';'ResizablePMCArray']
  vivify_774:
    set $P2403, $P2402[0]
    unless_null $P2403, vivify_775
    new $P2403, "Undef"
  vivify_775:
    $P2404 = $P2403."ast"()
    set $P2397, $P2404
  if_2398_end:
    store_lex "$past", $P2397
.annotate 'line', 1082
    find_lex $P2408, "$/"
    unless_null $P2408, vivify_776
    $P2408 = root_new ['parrot';'Hash']
  vivify_776:
    set $P2409, $P2408["op"]
    unless_null $P2409, vivify_777
    new $P2409, "Undef"
  vivify_777:
    set $S2410, $P2409
    new $P2411, 'String'
    set $P2411, $S2410
    store_lex "$pirop", $P2411
.annotate 'line', 1083

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2412 = box $S0
    
    store_lex "$pirop", $P2412
.annotate 'line', 1090
    find_lex $P2413, "$past"
    find_lex $P2414, "$pirop"
    $P2413."pirop"($P2414)
.annotate 'line', 1091
    find_lex $P2415, "$past"
    $P2415."pasttype"("pirop")
.annotate 'line', 1092
    find_lex $P2416, "$/"
    find_lex $P2417, "$past"
    $P2418 = $P2416."!make"($P2417)
.annotate 'line', 1080
    .return ($P2418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("121_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2420
    .param pmc param_2421
.annotate 'line', 1095
    .lex "self", param_2420
    .lex "$/", param_2421
.annotate 'line', 1096
    find_lex $P2422, "$/"
    get_hll_global $P2423, ["PAST"], "Op"
    $P2424 = $P2423."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2425 = $P2422."!make"($P2424)
.annotate 'line', 1095
    .return ($P2425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("122_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2427
    .param pmc param_2428
.annotate 'line', 1101
    .lex "self", param_2427
    .lex "$/", param_2428
    find_lex $P2429, "$/"
    find_lex $P2430, "$/"
    unless_null $P2430, vivify_778
    $P2430 = root_new ['parrot';'Hash']
  vivify_778:
    set $P2431, $P2430["arglist"]
    unless_null $P2431, vivify_779
    new $P2431, "Undef"
  vivify_779:
    $P2432 = $P2431."ast"()
    $P2433 = $P2429."!make"($P2432)
    .return ($P2433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("123_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2435
    .param pmc param_2436
.annotate 'line', 1103
    .const 'Sub' $P2447 = "124_1299465732.713" 
    capture_lex $P2447
    .lex "self", param_2435
    .lex "$/", param_2436
.annotate 'line', 1104
    new $P2437, "Undef"
    .lex "$past", $P2437
.annotate 'line', 1112
    new $P2438, "Undef"
    .lex "$i", $P2438
.annotate 'line', 1113
    new $P2439, "Undef"
    .lex "$n", $P2439
.annotate 'line', 1104
    get_hll_global $P2440, ["PAST"], "Op"
    find_lex $P2441, "$/"
    $P2442 = $P2440."new"("call" :named("pasttype"), $P2441 :named("node"))
    store_lex "$past", $P2442
.annotate 'line', 1105
    find_lex $P2444, "$/"
    unless_null $P2444, vivify_780
    $P2444 = root_new ['parrot';'Hash']
  vivify_780:
    set $P2445, $P2444["EXPR"]
    unless_null $P2445, vivify_781
    new $P2445, "Undef"
  vivify_781:
    unless $P2445, if_2443_end
    .const 'Sub' $P2447 = "124_1299465732.713" 
    capture_lex $P2447
    $P2447()
  if_2443_end:
.annotate 'line', 1112
    new $P2479, "Integer"
    assign $P2479, 0
    store_lex "$i", $P2479
.annotate 'line', 1113
    find_lex $P2480, "$past"
    $P2481 = $P2480."list"()
    set $N2482, $P2481
    new $P2483, 'Float'
    set $P2483, $N2482
    store_lex "$n", $P2483
.annotate 'line', 1114
    new $P2531, 'ExceptionHandler'
    set_label $P2531, loop2530_handler
    $P2531."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2531
  loop2530_test:
    find_lex $P2484, "$i"
    set $N2485, $P2484
    find_lex $P2486, "$n"
    set $N2487, $P2486
    islt $I2488, $N2485, $N2487
    unless $I2488, loop2530_done
  loop2530_redo:
.annotate 'line', 1115
    find_lex $P2490, "$i"
    set $I2491, $P2490
    find_lex $P2492, "$past"
    unless_null $P2492, vivify_785
    $P2492 = root_new ['parrot';'ResizablePMCArray']
  vivify_785:
    set $P2493, $P2492[$I2491]
    unless_null $P2493, vivify_786
    new $P2493, "Undef"
  vivify_786:
    $S2494 = $P2493."name"()
    iseq $I2495, $S2494, "&prefix:<|>"
    unless $I2495, if_2489_end
.annotate 'line', 1116
    find_lex $P2496, "$i"
    set $I2497, $P2496
    find_lex $P2498, "$past"
    unless_null $P2498, vivify_787
    $P2498 = root_new ['parrot';'ResizablePMCArray']
  vivify_787:
    set $P2499, $P2498[$I2497]
    unless_null $P2499, vivify_788
    $P2499 = root_new ['parrot';'ResizablePMCArray']
  vivify_788:
    set $P2500, $P2499[0]
    unless_null $P2500, vivify_789
    new $P2500, "Undef"
  vivify_789:
    find_lex $P2501, "$i"
    set $I2502, $P2501
    find_lex $P2503, "$past"
    unless_null $P2503, vivify_790
    $P2503 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2503
  vivify_790:
    set $P2503[$I2502], $P2500
.annotate 'line', 1117
    find_lex $P2504, "$i"
    set $I2505, $P2504
    find_lex $P2506, "$past"
    unless_null $P2506, vivify_791
    $P2506 = root_new ['parrot';'ResizablePMCArray']
  vivify_791:
    set $P2507, $P2506[$I2505]
    unless_null $P2507, vivify_792
    new $P2507, "Undef"
  vivify_792:
    $P2507."flat"(1)
.annotate 'line', 1118
    find_lex $P2511, "$i"
    set $I2512, $P2511
    find_lex $P2513, "$past"
    unless_null $P2513, vivify_793
    $P2513 = root_new ['parrot';'ResizablePMCArray']
  vivify_793:
    set $P2514, $P2513[$I2512]
    unless_null $P2514, vivify_794
    new $P2514, "Undef"
  vivify_794:
    get_hll_global $P2515, ["PAST"], "Val"
    $P2516 = $P2514."isa"($P2515)
    if $P2516, if_2510
    set $P2509, $P2516
    goto if_2510_end
  if_2510:
.annotate 'line', 1119
    find_lex $P2517, "$i"
    set $I2518, $P2517
    find_lex $P2519, "$past"
    unless_null $P2519, vivify_795
    $P2519 = root_new ['parrot';'ResizablePMCArray']
  vivify_795:
    set $P2520, $P2519[$I2518]
    unless_null $P2520, vivify_796
    new $P2520, "Undef"
  vivify_796:
    $S2521 = $P2520."name"()
    substr $S2522, $S2521, 0, 1
    iseq $I2523, $S2522, "%"
    new $P2509, 'Integer'
    set $P2509, $I2523
  if_2510_end:
    unless $P2509, if_2508_end
.annotate 'line', 1120
    find_lex $P2524, "$i"
    set $I2525, $P2524
    find_lex $P2526, "$past"
    unless_null $P2526, vivify_797
    $P2526 = root_new ['parrot';'ResizablePMCArray']
  vivify_797:
    set $P2527, $P2526[$I2525]
    unless_null $P2527, vivify_798
    new $P2527, "Undef"
  vivify_798:
    $P2527."named"(1)
  if_2508_end:
  if_2489_end:
.annotate 'line', 1115
    find_lex $P2528, "$i"
    clone $P2529, $P2528
    inc $P2528
  loop2530_next:
.annotate 'line', 1114
    goto loop2530_test
  loop2530_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2532, exception, 'type'
    eq $P2532, .CONTROL_LOOP_NEXT, loop2530_next
    eq $P2532, .CONTROL_LOOP_REDO, loop2530_redo
  loop2530_done:
    pop_eh 
.annotate 'line', 1125
    find_lex $P2533, "$/"
    find_lex $P2534, "$past"
    $P2535 = $P2533."!make"($P2534)
.annotate 'line', 1103
    .return ($P2535)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2446"  :anon :subid("124_1299465732.713") :outer("123_1299465732.713")
.annotate 'line', 1105
    .const 'Sub' $P2468 = "125_1299465732.713" 
    capture_lex $P2468
.annotate 'line', 1106
    new $P2448, "Undef"
    .lex "$expr", $P2448
    find_lex $P2449, "$/"
    unless_null $P2449, vivify_782
    $P2449 = root_new ['parrot';'Hash']
  vivify_782:
    set $P2450, $P2449["EXPR"]
    unless_null $P2450, vivify_783
    new $P2450, "Undef"
  vivify_783:
    $P2451 = $P2450."ast"()
    store_lex "$expr", $P2451
.annotate 'line', 1107
    find_lex $P2456, "$expr"
    $S2457 = $P2456."name"()
    iseq $I2458, $S2457, "&infix:<,>"
    if $I2458, if_2455
    new $P2454, 'Integer'
    set $P2454, $I2458
    goto if_2455_end
  if_2455:
    find_lex $P2459, "$expr"
    $P2460 = $P2459."named"()
    isfalse $I2461, $P2460
    new $P2454, 'Integer'
    set $P2454, $I2461
  if_2455_end:
    if $P2454, if_2453
.annotate 'line', 1110
    find_lex $P2476, "$past"
    find_lex $P2477, "$expr"
    $P2478 = $P2476."push"($P2477)
    set $P2452, $P2478
.annotate 'line', 1107
    goto if_2453_end
  if_2453:
.annotate 'line', 1108
    find_lex $P2463, "$expr"
    $P2464 = $P2463."list"()
    defined $I2465, $P2464
    unless $I2465, for_undef_784
    iter $P2462, $P2464
    new $P2474, 'ExceptionHandler'
    set_label $P2474, loop2473_handler
    $P2474."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2474
  loop2473_test:
    unless $P2462, loop2473_done
    shift $P2466, $P2462
  loop2473_redo:
    .const 'Sub' $P2468 = "125_1299465732.713" 
    capture_lex $P2468
    $P2468($P2466)
  loop2473_next:
    goto loop2473_test
  loop2473_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2475, exception, 'type'
    eq $P2475, .CONTROL_LOOP_NEXT, loop2473_next
    eq $P2475, .CONTROL_LOOP_REDO, loop2473_redo
  loop2473_done:
    pop_eh 
  for_undef_784:
.annotate 'line', 1107
    set $P2452, $P2462
  if_2453_end:
.annotate 'line', 1105
    .return ($P2452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2467"  :anon :subid("125_1299465732.713") :outer("124_1299465732.713")
    .param pmc param_2469
.annotate 'line', 1108
    .lex "$_", param_2469
    find_lex $P2470, "$past"
    find_lex $P2471, "$_"
    $P2472 = $P2470."push"($P2471)
    .return ($P2472)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("126_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2537
    .param pmc param_2538
.annotate 'line', 1128
    .lex "self", param_2537
    .lex "$/", param_2538
    find_lex $P2539, "$/"
    find_lex $P2540, "$/"
    unless_null $P2540, vivify_799
    $P2540 = root_new ['parrot';'Hash']
  vivify_799:
    set $P2541, $P2540["multi_declarator"]
    unless_null $P2541, vivify_800
    new $P2541, "Undef"
  vivify_800:
    $P2542 = $P2541."ast"()
    $P2543 = $P2539."!make"($P2542)
    .return ($P2543)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("127_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2545
    .param pmc param_2546
.annotate 'line', 1130
    .lex "self", param_2545
    .lex "$/", param_2546
    find_lex $P2547, "$/"
    find_lex $P2548, "$/"
    unless_null $P2548, vivify_801
    $P2548 = root_new ['parrot';'Hash']
  vivify_801:
    set $P2549, $P2548["value"]
    unless_null $P2549, vivify_802
    new $P2549, "Undef"
  vivify_802:
    $P2550 = $P2549."ast"()
    $P2551 = $P2547."!make"($P2550)
    .return ($P2551)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("128_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2553
    .param pmc param_2554
.annotate 'line', 1132
    .lex "self", param_2553
    .lex "$/", param_2554
.annotate 'line', 1133
    find_lex $P2555, "$/"
.annotate 'line', 1134
    find_lex $P2558, "$/"
    unless_null $P2558, vivify_803
    $P2558 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2559, $P2558["EXPR"]
    unless_null $P2559, vivify_804
    new $P2559, "Undef"
  vivify_804:
    if $P2559, if_2557
.annotate 'line', 1135
    get_hll_global $P2564, ["PAST"], "Op"
    find_lex $P2565, "$/"
    $P2566 = $P2564."new"("list" :named("pasttype"), $P2565 :named("node"))
    set $P2556, $P2566
.annotate 'line', 1134
    goto if_2557_end
  if_2557:
    find_lex $P2560, "$/"
    unless_null $P2560, vivify_805
    $P2560 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2561, $P2560["EXPR"]
    unless_null $P2561, vivify_806
    $P2561 = root_new ['parrot';'ResizablePMCArray']
  vivify_806:
    set $P2562, $P2561[0]
    unless_null $P2562, vivify_807
    new $P2562, "Undef"
  vivify_807:
    $P2563 = $P2562."ast"()
    set $P2556, $P2563
  if_2557_end:
    $P2567 = $P2555."!make"($P2556)
.annotate 'line', 1132
    .return ($P2567)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("129_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2569
    .param pmc param_2570
.annotate 'line', 1138
    .lex "self", param_2569
    .lex "$/", param_2570
.annotate 'line', 1139
    new $P2571, "Undef"
    .lex "$past", $P2571
.annotate 'line', 1138
    find_lex $P2572, "$past"
.annotate 'line', 1140
    find_lex $P2574, "$/"
    unless_null $P2574, vivify_808
    $P2574 = root_new ['parrot';'Hash']
  vivify_808:
    set $P2575, $P2574["EXPR"]
    unless_null $P2575, vivify_809
    new $P2575, "Undef"
  vivify_809:
    if $P2575, if_2573
.annotate 'line', 1147
    get_hll_global $P2587, ["PAST"], "Op"
    $P2588 = $P2587."new"("list" :named("pasttype"))
    store_lex "$past", $P2588
.annotate 'line', 1146
    goto if_2573_end
  if_2573:
.annotate 'line', 1141
    find_lex $P2576, "$/"
    unless_null $P2576, vivify_810
    $P2576 = root_new ['parrot';'Hash']
  vivify_810:
    set $P2577, $P2576["EXPR"]
    unless_null $P2577, vivify_811
    $P2577 = root_new ['parrot';'ResizablePMCArray']
  vivify_811:
    set $P2578, $P2577[0]
    unless_null $P2578, vivify_812
    new $P2578, "Undef"
  vivify_812:
    $P2579 = $P2578."ast"()
    store_lex "$past", $P2579
.annotate 'line', 1142
    find_lex $P2581, "$past"
    $S2582 = $P2581."name"()
    isne $I2583, $S2582, "&infix:<,>"
    unless $I2583, if_2580_end
.annotate 'line', 1143
    get_hll_global $P2584, ["PAST"], "Op"
    find_lex $P2585, "$past"
    $P2586 = $P2584."new"($P2585, "list" :named("pasttype"))
    store_lex "$past", $P2586
  if_2580_end:
  if_2573_end:
.annotate 'line', 1149
    find_lex $P2589, "$past"
    $P2589."name"("&circumfix:<[ ]>")
.annotate 'line', 1150
    find_lex $P2590, "$/"
    find_lex $P2591, "$past"
    $P2592 = $P2590."!make"($P2591)
.annotate 'line', 1138
    .return ($P2592)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("130_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2594
    .param pmc param_2595
.annotate 'line', 1153
    .lex "self", param_2594
    .lex "$/", param_2595
    find_lex $P2596, "$/"
    find_lex $P2597, "$/"
    unless_null $P2597, vivify_813
    $P2597 = root_new ['parrot';'Hash']
  vivify_813:
    set $P2598, $P2597["quote_EXPR"]
    unless_null $P2598, vivify_814
    new $P2598, "Undef"
  vivify_814:
    $P2599 = $P2598."ast"()
    $P2600 = $P2596."!make"($P2599)
    .return ($P2600)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("131_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2602
    .param pmc param_2603
.annotate 'line', 1154
    .lex "self", param_2602
    .lex "$/", param_2603
    find_lex $P2604, "$/"
    find_lex $P2605, "$/"
    unless_null $P2605, vivify_815
    $P2605 = root_new ['parrot';'Hash']
  vivify_815:
    set $P2606, $P2605["quote_EXPR"]
    unless_null $P2606, vivify_816
    new $P2606, "Undef"
  vivify_816:
    $P2607 = $P2606."ast"()
    $P2608 = $P2604."!make"($P2607)
    .return ($P2608)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("132_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2610
    .param pmc param_2611
.annotate 'line', 1156
    .const 'Sub' $P2622 = "133_1299465732.713" 
    capture_lex $P2622
    .lex "self", param_2610
    .lex "$/", param_2611
.annotate 'line', 1157
    find_lex $P2614, "$/"
    unless_null $P2614, vivify_817
    $P2614 = root_new ['parrot';'Hash']
  vivify_817:
    set $P2615, $P2614["pblock"]
    unless_null $P2615, vivify_818
    $P2615 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2616, $P2615["blockoid"]
    unless_null $P2616, vivify_819
    $P2616 = root_new ['parrot';'Hash']
  vivify_819:
    set $P2617, $P2616["statementlist"]
    unless_null $P2617, vivify_820
    $P2617 = root_new ['parrot';'Hash']
  vivify_820:
    set $P2618, $P2617["statement"]
    unless_null $P2618, vivify_821
    new $P2618, "Undef"
  vivify_821:
    set $N2619, $P2618
    isgt $I2620, $N2619, 0.0
    if $I2620, if_2613
.annotate 'line', 1162
    find_lex $P2635, "$/"
    unless_null $P2635, vivify_822
    $P2635 = root_new ['parrot';'Hash']
  vivify_822:
    set $P2636, $P2635["pblock"]
    unless_null $P2636, vivify_823
    $P2636 = root_new ['parrot';'Hash']
  vivify_823:
    set $P2637, $P2636["blockoid"]
    unless_null $P2637, vivify_824
    $P2637 = root_new ['parrot';'Hash']
  vivify_824:
    set $P2638, $P2637["you_are_here"]
    unless_null $P2638, vivify_825
    new $P2638, "Undef"
  vivify_825:
    if $P2638, if_2634
.annotate 'line', 1166
    find_lex $P2644, "$/"
    $P2645 = "vivitype"("%")
    $P2646 = $P2644."!make"($P2645)
.annotate 'line', 1165
    set $P2633, $P2646
.annotate 'line', 1162
    goto if_2634_end
  if_2634:
.annotate 'line', 1163
    find_lex $P2639, "$/"
    find_lex $P2640, "$/"
    unless_null $P2640, vivify_826
    $P2640 = root_new ['parrot';'Hash']
  vivify_826:
    set $P2641, $P2640["pblock"]
    unless_null $P2641, vivify_827
    new $P2641, "Undef"
  vivify_827:
    $P2642 = $P2641."ast"()
    $P2643 = $P2639."!make"($P2642)
.annotate 'line', 1162
    set $P2633, $P2643
  if_2634_end:
    set $P2612, $P2633
.annotate 'line', 1157
    goto if_2613_end
  if_2613:
    .const 'Sub' $P2622 = "133_1299465732.713" 
    capture_lex $P2622
    $P2632 = $P2622()
    set $P2612, $P2632
  if_2613_end:
.annotate 'line', 1156
    .return ($P2612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2621"  :anon :subid("133_1299465732.713") :outer("132_1299465732.713")
.annotate 'line', 1158
    new $P2623, "Undef"
    .lex "$past", $P2623
    find_lex $P2624, "$/"
    unless_null $P2624, vivify_828
    $P2624 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2625, $P2624["pblock"]
    unless_null $P2625, vivify_829
    new $P2625, "Undef"
  vivify_829:
    $P2626 = $P2625."ast"()
    store_lex "$past", $P2626
.annotate 'line', 1159
    new $P2627, "Integer"
    assign $P2627, 1
    find_lex $P2628, "$past"
    unless_null $P2628, vivify_830
    $P2628 = root_new ['parrot';'Hash']
    store_lex "$past", $P2628
  vivify_830:
    set $P2628["bareblock"], $P2627
.annotate 'line', 1160
    find_dynamic_lex $P2629, "$/"
    find_lex $P2630, "$past"
    $P2631 = $P2629."!make"($P2630)
.annotate 'line', 1157
    .return ($P2631)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("134_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2648
    .param pmc param_2649
.annotate 'line', 1170
    .lex "self", param_2648
    .lex "$/", param_2649
.annotate 'line', 1171
    new $P2650, "Undef"
    .lex "$name", $P2650
    find_lex $P2653, "$/"
    unless_null $P2653, vivify_831
    $P2653 = root_new ['parrot';'Hash']
  vivify_831:
    set $P2654, $P2653["sigil"]
    unless_null $P2654, vivify_832
    new $P2654, "Undef"
  vivify_832:
    set $S2655, $P2654
    iseq $I2656, $S2655, "@"
    if $I2656, if_2652
.annotate 'line', 1172
    find_lex $P2660, "$/"
    unless_null $P2660, vivify_833
    $P2660 = root_new ['parrot';'Hash']
  vivify_833:
    set $P2661, $P2660["sigil"]
    unless_null $P2661, vivify_834
    new $P2661, "Undef"
  vivify_834:
    set $S2662, $P2661
    iseq $I2663, $S2662, "%"
    if $I2663, if_2659
    new $P2665, "String"
    assign $P2665, "item"
    set $P2658, $P2665
    goto if_2659_end
  if_2659:
    new $P2664, "String"
    assign $P2664, "hash"
    set $P2658, $P2664
  if_2659_end:
    set $P2651, $P2658
.annotate 'line', 1171
    goto if_2652_end
  if_2652:
    new $P2657, "String"
    assign $P2657, "list"
    set $P2651, $P2657
  if_2652_end:
    store_lex "$name", $P2651
.annotate 'line', 1174
    find_lex $P2666, "$/"
    get_hll_global $P2667, ["PAST"], "Op"
    find_lex $P2668, "$name"
    find_lex $P2669, "$/"
    unless_null $P2669, vivify_835
    $P2669 = root_new ['parrot';'Hash']
  vivify_835:
    set $P2670, $P2669["semilist"]
    unless_null $P2670, vivify_836
    new $P2670, "Undef"
  vivify_836:
    $P2671 = $P2670."ast"()
    $P2672 = $P2667."new"($P2671, "callmethod" :named("pasttype"), $P2668 :named("name"))
    $P2673 = $P2666."!make"($P2672)
.annotate 'line', 1170
    .return ($P2673)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("135_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2675
    .param pmc param_2676
.annotate 'line', 1177
    .lex "self", param_2675
    .lex "$/", param_2676
    find_lex $P2677, "$/"
    find_lex $P2678, "$/"
    unless_null $P2678, vivify_837
    $P2678 = root_new ['parrot';'Hash']
  vivify_837:
    set $P2679, $P2678["statement"]
    unless_null $P2679, vivify_838
    new $P2679, "Undef"
  vivify_838:
    $P2680 = $P2679."ast"()
    $P2681 = $P2677."!make"($P2680)
    .return ($P2681)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("136_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2683
    .param pmc param_2684
.annotate 'line', 1179
    .lex "self", param_2683
    .lex "$/", param_2684
.annotate 'line', 1180
    find_lex $P2685, "$/"
    get_hll_global $P2686, ["PAST"], "Var"
    find_lex $P2687, "$/"
    unless_null $P2687, vivify_839
    $P2687 = root_new ['parrot';'Hash']
  vivify_839:
    set $P2688, $P2687["EXPR"]
    unless_null $P2688, vivify_840
    new $P2688, "Undef"
  vivify_840:
    $P2689 = $P2688."ast"()
.annotate 'line', 1182
    $P2690 = "vivitype"("@")
    $P2691 = $P2686."new"($P2689, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2690 :named("vivibase"))
.annotate 'line', 1180
    $P2692 = $P2685."!make"($P2691)
.annotate 'line', 1179
    .return ($P2692)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("137_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2694
    .param pmc param_2695
.annotate 'line', 1185
    .lex "self", param_2694
    .lex "$/", param_2695
.annotate 'line', 1186
    find_lex $P2696, "$/"
    get_hll_global $P2697, ["PAST"], "Var"
    find_lex $P2698, "$/"
    unless_null $P2698, vivify_841
    $P2698 = root_new ['parrot';'Hash']
  vivify_841:
    set $P2699, $P2698["EXPR"]
    unless_null $P2699, vivify_842
    new $P2699, "Undef"
  vivify_842:
    $P2700 = $P2699."ast"()
.annotate 'line', 1188
    $P2701 = "vivitype"("%")
    $P2702 = $P2697."new"($P2700, "keyed" :named("scope"), "Undef" :named("viviself"), $P2701 :named("vivibase"))
.annotate 'line', 1186
    $P2703 = $P2696."!make"($P2702)
.annotate 'line', 1185
    .return ($P2703)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("138_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2705
    .param pmc param_2706
.annotate 'line', 1191
    .lex "self", param_2705
    .lex "$/", param_2706
.annotate 'line', 1192
    find_lex $P2707, "$/"
    get_hll_global $P2708, ["PAST"], "Var"
    find_lex $P2709, "$/"
    unless_null $P2709, vivify_843
    $P2709 = root_new ['parrot';'Hash']
  vivify_843:
    set $P2710, $P2709["quote_EXPR"]
    unless_null $P2710, vivify_844
    new $P2710, "Undef"
  vivify_844:
    $P2711 = $P2710."ast"()
.annotate 'line', 1194
    $P2712 = "vivitype"("%")
    $P2713 = $P2708."new"($P2711, "keyed" :named("scope"), "Undef" :named("viviself"), $P2712 :named("vivibase"))
.annotate 'line', 1192
    $P2714 = $P2707."!make"($P2713)
.annotate 'line', 1191
    .return ($P2714)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("139_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2716
    .param pmc param_2717
.annotate 'line', 1197
    .lex "self", param_2716
    .lex "$/", param_2717
.annotate 'line', 1198
    find_lex $P2718, "$/"
    find_lex $P2719, "$/"
    unless_null $P2719, vivify_845
    $P2719 = root_new ['parrot';'Hash']
  vivify_845:
    set $P2720, $P2719["arglist"]
    unless_null $P2720, vivify_846
    new $P2720, "Undef"
  vivify_846:
    $P2721 = $P2720."ast"()
    $P2722 = $P2718."!make"($P2721)
.annotate 'line', 1197
    .return ($P2722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("140_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2724
    .param pmc param_2725
.annotate 'line', 1201
    .lex "self", param_2724
    .lex "$/", param_2725
.annotate 'line', 1202
    find_lex $P2726, "$/"
    find_lex $P2729, "$/"
    unless_null $P2729, vivify_847
    $P2729 = root_new ['parrot';'Hash']
  vivify_847:
    set $P2730, $P2729["quote"]
    unless_null $P2730, vivify_848
    new $P2730, "Undef"
  vivify_848:
    if $P2730, if_2728
    find_lex $P2734, "$/"
    unless_null $P2734, vivify_849
    $P2734 = root_new ['parrot';'Hash']
  vivify_849:
    set $P2735, $P2734["number"]
    unless_null $P2735, vivify_850
    new $P2735, "Undef"
  vivify_850:
    $P2736 = $P2735."ast"()
    set $P2727, $P2736
    goto if_2728_end
  if_2728:
    find_lex $P2731, "$/"
    unless_null $P2731, vivify_851
    $P2731 = root_new ['parrot';'Hash']
  vivify_851:
    set $P2732, $P2731["quote"]
    unless_null $P2732, vivify_852
    new $P2732, "Undef"
  vivify_852:
    $P2733 = $P2732."ast"()
    set $P2727, $P2733
  if_2728_end:
    $P2737 = $P2726."!make"($P2727)
.annotate 'line', 1201
    .return ($P2737)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("141_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2739
    .param pmc param_2740
.annotate 'line', 1205
    .lex "self", param_2739
    .lex "$/", param_2740
.annotate 'line', 1206
    new $P2741, "Undef"
    .lex "$value", $P2741
    find_lex $P2744, "$/"
    unless_null $P2744, vivify_853
    $P2744 = root_new ['parrot';'Hash']
  vivify_853:
    set $P2745, $P2744["dec_number"]
    unless_null $P2745, vivify_854
    new $P2745, "Undef"
  vivify_854:
    if $P2745, if_2743
    find_lex $P2749, "$/"
    unless_null $P2749, vivify_855
    $P2749 = root_new ['parrot';'Hash']
  vivify_855:
    set $P2750, $P2749["integer"]
    unless_null $P2750, vivify_856
    new $P2750, "Undef"
  vivify_856:
    $P2751 = $P2750."ast"()
    set $P2742, $P2751
    goto if_2743_end
  if_2743:
    find_lex $P2746, "$/"
    unless_null $P2746, vivify_857
    $P2746 = root_new ['parrot';'Hash']
  vivify_857:
    set $P2747, $P2746["dec_number"]
    unless_null $P2747, vivify_858
    new $P2747, "Undef"
  vivify_858:
    $P2748 = $P2747."ast"()
    set $P2742, $P2748
  if_2743_end:
    store_lex "$value", $P2742
.annotate 'line', 1207
    find_lex $P2753, "$/"
    unless_null $P2753, vivify_859
    $P2753 = root_new ['parrot';'Hash']
  vivify_859:
    set $P2754, $P2753["sign"]
    unless_null $P2754, vivify_860
    new $P2754, "Undef"
  vivify_860:
    set $S2755, $P2754
    iseq $I2756, $S2755, "-"
    unless $I2756, if_2752_end
    find_lex $P2757, "$value"
    neg $P2758, $P2757
    store_lex "$value", $P2758
  if_2752_end:
.annotate 'line', 1208
    find_lex $P2759, "$/"
    get_hll_global $P2760, ["PAST"], "Val"
    find_lex $P2761, "$value"
    $P2762 = $P2760."new"($P2761 :named("value"))
    $P2763 = $P2759."!make"($P2762)
.annotate 'line', 1205
    .return ($P2763)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("142_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2765
    .param pmc param_2766
.annotate 'line', 1211
    .lex "self", param_2765
    .lex "$/", param_2766
    find_lex $P2767, "$/"
    find_lex $P2768, "$/"
    unless_null $P2768, vivify_861
    $P2768 = root_new ['parrot';'Hash']
  vivify_861:
    set $P2769, $P2768["quote_EXPR"]
    unless_null $P2769, vivify_862
    new $P2769, "Undef"
  vivify_862:
    $P2770 = $P2769."ast"()
    $P2771 = $P2767."!make"($P2770)
    .return ($P2771)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("143_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2773
    .param pmc param_2774
.annotate 'line', 1212
    .lex "self", param_2773
    .lex "$/", param_2774
    find_lex $P2775, "$/"
    find_lex $P2776, "$/"
    unless_null $P2776, vivify_863
    $P2776 = root_new ['parrot';'Hash']
  vivify_863:
    set $P2777, $P2776["quote_EXPR"]
    unless_null $P2777, vivify_864
    new $P2777, "Undef"
  vivify_864:
    $P2778 = $P2777."ast"()
    $P2779 = $P2775."!make"($P2778)
    .return ($P2779)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("144_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2781
    .param pmc param_2782
.annotate 'line', 1213
    .lex "self", param_2781
    .lex "$/", param_2782
    find_lex $P2783, "$/"
    find_lex $P2784, "$/"
    unless_null $P2784, vivify_865
    $P2784 = root_new ['parrot';'Hash']
  vivify_865:
    set $P2785, $P2784["quote_EXPR"]
    unless_null $P2785, vivify_866
    new $P2785, "Undef"
  vivify_866:
    $P2786 = $P2785."ast"()
    $P2787 = $P2783."!make"($P2786)
    .return ($P2787)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("145_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2789
    .param pmc param_2790
.annotate 'line', 1214
    .lex "self", param_2789
    .lex "$/", param_2790
    find_lex $P2791, "$/"
    find_lex $P2792, "$/"
    unless_null $P2792, vivify_867
    $P2792 = root_new ['parrot';'Hash']
  vivify_867:
    set $P2793, $P2792["quote_EXPR"]
    unless_null $P2793, vivify_868
    new $P2793, "Undef"
  vivify_868:
    $P2794 = $P2793."ast"()
    $P2795 = $P2791."!make"($P2794)
    .return ($P2795)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("146_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2797
    .param pmc param_2798
.annotate 'line', 1215
    .lex "self", param_2797
    .lex "$/", param_2798
    find_lex $P2799, "$/"
    find_lex $P2800, "$/"
    unless_null $P2800, vivify_869
    $P2800 = root_new ['parrot';'Hash']
  vivify_869:
    set $P2801, $P2800["quote_EXPR"]
    unless_null $P2801, vivify_870
    new $P2801, "Undef"
  vivify_870:
    $P2802 = $P2801."ast"()
    $P2803 = $P2799."!make"($P2802)
    .return ($P2803)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("147_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2805
    .param pmc param_2806
.annotate 'line', 1216
    .lex "self", param_2805
    .lex "$/", param_2806
.annotate 'line', 1217
    find_lex $P2807, "$/"
    get_hll_global $P2808, ["PAST"], "Op"
    find_lex $P2809, "$/"
    unless_null $P2809, vivify_871
    $P2809 = root_new ['parrot';'Hash']
  vivify_871:
    set $P2810, $P2809["quote_EXPR"]
    unless_null $P2810, vivify_872
    new $P2810, "Undef"
  vivify_872:
    $P2811 = $P2810."ast"()
    $P2812 = $P2811."value"()
    find_lex $P2813, "$/"
    $P2814 = $P2808."new"($P2812 :named("inline"), "inline" :named("pasttype"), $P2813 :named("node"))
    $P2815 = $P2807."!make"($P2814)
.annotate 'line', 1216
    .return ($P2815)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("148_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2819
    .param pmc param_2820
    .param pmc param_2821 :optional
    .param int has_param_2821 :opt_flag
.annotate 'line', 1222
    new $P2818, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2818, control_2817
    push_eh $P2818
    .lex "self", param_2819
    .lex "$/", param_2820
    if has_param_2821, optparam_873
    new $P2822, "Undef"
    set param_2821, $P2822
  optparam_873:
    .lex "$key", param_2821
.annotate 'line', 1232
    new $P2823, "Undef"
    .lex "$regex", $P2823
.annotate 'line', 1234
    new $P2824, "Undef"
    .lex "$past", $P2824
.annotate 'line', 1223
    find_lex $P2826, "$key"
    set $S2827, $P2826
    iseq $I2828, $S2827, "open"
    unless $I2828, if_2825_end
.annotate 'line', 1224

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1228
    get_global $P2829, "@BLOCK"
    unless_null $P2829, vivify_874
    $P2829 = root_new ['parrot';'ResizablePMCArray']
  vivify_874:
    set $P2830, $P2829[0]
    unless_null $P2830, vivify_875
    new $P2830, "Undef"
  vivify_875:
    $P2830."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1229
    get_global $P2831, "@BLOCK"
    unless_null $P2831, vivify_876
    $P2831 = root_new ['parrot';'ResizablePMCArray']
  vivify_876:
    set $P2832, $P2831[0]
    unless_null $P2832, vivify_877
    new $P2832, "Undef"
  vivify_877:
    $P2832."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1230
    new $P2833, "Exception"
    set $P2833['type'], .CONTROL_RETURN
    new $P2834, "Integer"
    assign $P2834, 0
    setattribute $P2833, 'payload', $P2834
    throw $P2833
  if_2825_end:
.annotate 'line', 1233
    get_hll_global $P2835, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2836, "$/"
    unless_null $P2836, vivify_878
    $P2836 = root_new ['parrot';'Hash']
  vivify_878:
    set $P2837, $P2836["p6regex"]
    unless_null $P2837, vivify_879
    new $P2837, "Undef"
  vivify_879:
    $P2838 = $P2837."ast"()
    get_global $P2839, "@BLOCK"
    $P2840 = $P2839."shift"()
    $P2841 = $P2835($P2838, $P2840)
    store_lex "$regex", $P2841
.annotate 'line', 1235
    get_hll_global $P2842, ["PAST"], "Op"
.annotate 'line', 1237
    get_hll_global $P2843, ["PAST"], "Var"
    new $P2844, "ResizablePMCArray"
    push $P2844, "Regex"
    $P2845 = $P2843."new"("Regex" :named("name"), $P2844 :named("namespace"), "package" :named("scope"))
    find_lex $P2846, "$regex"
    $P2847 = $P2842."new"($P2845, $P2846, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1235
    store_lex "$past", $P2847
.annotate 'line', 1241
    find_lex $P2848, "$regex"
    find_lex $P2849, "$past"
    unless_null $P2849, vivify_880
    $P2849 = root_new ['parrot';'Hash']
    store_lex "$past", $P2849
  vivify_880:
    set $P2849["sink"], $P2848
.annotate 'line', 1242
    find_lex $P2850, "$/"
    find_lex $P2851, "$past"
    $P2852 = $P2850."!make"($P2851)
.annotate 'line', 1222
    .return ($P2852)
  control_2817:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2853, exception, "payload"
    .return ($P2853)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("149_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2855
    .param pmc param_2856
.annotate 'line', 1245
    .lex "self", param_2855
    .lex "$/", param_2856
    find_lex $P2857, "$/"
    find_lex $P2858, "$/"
    unless_null $P2858, vivify_881
    $P2858 = root_new ['parrot';'Hash']
  vivify_881:
    set $P2859, $P2858["variable"]
    unless_null $P2859, vivify_882
    new $P2859, "Undef"
  vivify_882:
    $P2860 = $P2859."ast"()
    $P2861 = $P2857."!make"($P2860)
    .return ($P2861)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("150_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2863
    .param pmc param_2864
.annotate 'line', 1246
    .lex "self", param_2863
    .lex "$/", param_2864
.annotate 'line', 1247
    find_lex $P2865, "$/"
    get_hll_global $P2866, ["PAST"], "Op"
.annotate 'line', 1248
    find_lex $P2867, "$/"
    unless_null $P2867, vivify_883
    $P2867 = root_new ['parrot';'Hash']
  vivify_883:
    set $P2868, $P2867["block"]
    unless_null $P2868, vivify_884
    new $P2868, "Undef"
  vivify_884:
    $P2869 = $P2868."ast"()
    $P2870 = "block_immediate"($P2869)
    find_lex $P2871, "$/"
    $P2872 = $P2866."new"($P2870, "set S*" :named("pirop"), $P2871 :named("node"))
.annotate 'line', 1247
    $P2873 = $P2865."!make"($P2872)
.annotate 'line', 1246
    .return ($P2873)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("151_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2875
    .param pmc param_2876
.annotate 'line', 1251
    .lex "self", param_2875
    .lex "$/", param_2876
    find_lex $P2877, "$/"
    $P2878 = $P2877."!make"("\e")
    .return ($P2878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("152_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2880
    .param pmc param_2881
.annotate 'line', 1255
    .lex "self", param_2880
    .lex "$/", param_2881
    find_lex $P2882, "$/"
    find_lex $P2883, "$/"
    unless_null $P2883, vivify_885
    $P2883 = root_new ['parrot';'Hash']
  vivify_885:
    set $P2884, $P2883["dotty"]
    unless_null $P2884, vivify_886
    new $P2884, "Undef"
  vivify_886:
    $P2885 = $P2884."ast"()
    $P2886 = $P2882."!make"($P2885)
    .return ($P2886)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("153_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2888
    .param pmc param_2889
.annotate 'line', 1257
    .lex "self", param_2888
    .lex "$/", param_2889
.annotate 'line', 1258
    find_lex $P2890, "$/"
    get_hll_global $P2891, ["PAST"], "Op"
.annotate 'line', 1259
    new $P2892, "ResizablePMCArray"
    push $P2892, "    clone %r, %0"
    push $P2892, "    inc %0"
    $P2893 = $P2891."new"("postfix:<++>" :named("name"), $P2892 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1258
    $P2894 = $P2890."!make"($P2893)
.annotate 'line', 1257
    .return ($P2894)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("154_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2896
    .param pmc param_2897
.annotate 'line', 1263
    .lex "self", param_2896
    .lex "$/", param_2897
.annotate 'line', 1264
    find_lex $P2898, "$/"
    get_hll_global $P2899, ["PAST"], "Op"
.annotate 'line', 1265
    new $P2900, "ResizablePMCArray"
    push $P2900, "    clone %r, %0"
    push $P2900, "    dec %0"
    $P2901 = $P2899."new"("postfix:<-->" :named("name"), $P2900 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1264
    $P2902 = $P2898."!make"($P2901)
.annotate 'line', 1263
    .return ($P2902)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("155_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2904
    .param pmc param_2905
.annotate 'line', 1269
    .lex "self", param_2904
    .lex "$/", param_2905
.annotate 'line', 1270
    find_lex $P2906, "$/"
    get_hll_global $P2907, ["PAST"], "Op"
.annotate 'line', 1271
    get_hll_global $P2908, ["PAST"], "Var"
    $P2909 = $P2908."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2910, "$/"
    $P2911 = $P2907."new"($P2909, "callmethod" :named("pasttype"), "!make" :named("name"), $P2910 :named("node"))
.annotate 'line', 1270
    $P2912 = $P2906."!make"($P2911)
.annotate 'line', 1269
    .return ($P2912)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("156_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2915
    .param pmc param_2916
.annotate 'line', 1287
    .lex "self", param_2915
    .lex "$/", param_2916
    find_lex $P2917, "$/"
    $P2918 = "control"($P2917, "CONTROL_LOOP_NEXT")
    .return ($P2918)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("157_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2920
    .param pmc param_2921
.annotate 'line', 1288
    .lex "self", param_2920
    .lex "$/", param_2921
    find_lex $P2922, "$/"
    $P2923 = "control"($P2922, "CONTROL_LOOP_LAST")
    .return ($P2923)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("158_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2925
    .param pmc param_2926
.annotate 'line', 1289
    .lex "self", param_2925
    .lex "$/", param_2926
    find_lex $P2927, "$/"
    $P2928 = "control"($P2927, "CONTROL_LOOP_REDO")
    .return ($P2928)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("159_1299465732.713") :outer("11_1299465732.713")
    .param pmc param_2930
    .param pmc param_2931
.annotate 'line', 1291
    .lex "self", param_2930
    .lex "$/", param_2931
.annotate 'line', 1292
    find_lex $P2932, "$/"
    get_hll_global $P2933, ["PAST"], "Op"
    find_lex $P2934, "$/"
    $P2935 = $P2933."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2934 :named("node"))
    $P2936 = $P2932."!make"($P2935)
.annotate 'line', 1291
    .return ($P2936)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block2937"  :subid("160_1299465732.713") :outer("11_1299465732.713")
.annotate 'line', 1296
    .const 'Sub' $P3037 = "168_1299465732.713" 
    capture_lex $P3037
    .const 'Sub' $P3012 = "167_1299465732.713" 
    capture_lex $P3012
    .const 'Sub' $P3001 = "166_1299465732.713" 
    capture_lex $P3001
    .const 'Sub' $P2986 = "165_1299465732.713" 
    capture_lex $P2986
    .const 'Sub' $P2975 = "164_1299465732.713" 
    capture_lex $P2975
    .const 'Sub' $P2964 = "163_1299465732.713" 
    capture_lex $P2964
    .const 'Sub' $P2953 = "162_1299465732.713" 
    capture_lex $P2953
    .const 'Sub' $P2940 = "161_1299465732.713" 
    capture_lex $P2940
    get_global $P2939, "$?CLASS"
.annotate 'line', 1330
    .const 'Sub' $P3012 = "167_1299465732.713" 
    newclosure $P3035, $P3012
.annotate 'line', 1296
    .return ($P3035)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post887") :outer("160_1299465732.713")
.annotate 'line', 1296
    get_hll_global $P2938, ["NQP";"RegexActions"], "_block2937" 
    .local pmc block
    set block, $P2938
    .const 'Sub' $P3037 = "168_1299465732.713" 
    capture_lex $P3037
    $P3037()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3036"  :anon :subid("168_1299465732.713") :outer("160_1299465732.713")
.annotate 'line', 1296
    get_hll_global $P3038, "NQPClassHOW"
    $P3039 = $P3038."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3039
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3040, type_obj
    .const 'Sub' $P3041 = "161_1299465732.713" 
    $P3040."add_method"(type_obj, "metachar:sym<:my>", $P3041)
    get_how $P3042, type_obj
    .const 'Sub' $P3043 = "162_1299465732.713" 
    $P3042."add_method"(type_obj, "metachar:sym<{ }>", $P3043)
    get_how $P3044, type_obj
    .const 'Sub' $P3045 = "163_1299465732.713" 
    $P3044."add_method"(type_obj, "metachar:sym<nqpvar>", $P3045)
    get_how $P3046, type_obj
    .const 'Sub' $P3047 = "164_1299465732.713" 
    $P3046."add_method"(type_obj, "assertion:sym<{ }>", $P3047)
    get_how $P3048, type_obj
    .const 'Sub' $P3049 = "165_1299465732.713" 
    $P3048."add_method"(type_obj, "assertion:sym<?{ }>", $P3049)
    get_how $P3050, type_obj
    .const 'Sub' $P3051 = "166_1299465732.713" 
    $P3050."add_method"(type_obj, "assertion:sym<var>", $P3051)
    get_how $P3052, type_obj
    .const 'Sub' $P3053 = "167_1299465732.713" 
    $P3052."add_method"(type_obj, "codeblock", $P3053)
    get_how $P3054, type_obj
    get_hll_global $P3055, ["Regex";"P6Regex"], "Actions"
    $P3054."add_parent"(type_obj, $P3055)
    get_how $P3056, type_obj
    $P3057 = $P3056."compose"(type_obj)
    .return ($P3057)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("161_1299465732.713") :outer("160_1299465732.713")
    .param pmc param_2941
    .param pmc param_2942
.annotate 'line', 1298
    .lex "self", param_2941
    .lex "$/", param_2942
.annotate 'line', 1299
    new $P2943, "Undef"
    .lex "$past", $P2943
    find_lex $P2944, "$/"
    unless_null $P2944, vivify_888
    $P2944 = root_new ['parrot';'Hash']
  vivify_888:
    set $P2945, $P2944["statement"]
    unless_null $P2945, vivify_889
    new $P2945, "Undef"
  vivify_889:
    $P2946 = $P2945."ast"()
    store_lex "$past", $P2946
.annotate 'line', 1300
    find_lex $P2947, "$/"
    get_hll_global $P2948, ["PAST"], "Regex"
    find_lex $P2949, "$past"
    find_lex $P2950, "$/"
    $P2951 = $P2948."new"($P2949, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2950 :named("node"))
    $P2952 = $P2947."!make"($P2951)
.annotate 'line', 1298
    .return ($P2952)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("162_1299465732.713") :outer("160_1299465732.713")
    .param pmc param_2954
    .param pmc param_2955
.annotate 'line', 1304
    .lex "self", param_2954
    .lex "$/", param_2955
.annotate 'line', 1305
    find_lex $P2956, "$/"
    get_hll_global $P2957, ["PAST"], "Regex"
    find_lex $P2958, "$/"
    unless_null $P2958, vivify_890
    $P2958 = root_new ['parrot';'Hash']
  vivify_890:
    set $P2959, $P2958["codeblock"]
    unless_null $P2959, vivify_891
    new $P2959, "Undef"
  vivify_891:
    $P2960 = $P2959."ast"()
    find_lex $P2961, "$/"
    $P2962 = $P2957."new"($P2960, "pastnode" :named("pasttype"), $P2961 :named("node"))
    $P2963 = $P2956."!make"($P2962)
.annotate 'line', 1304
    .return ($P2963)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("163_1299465732.713") :outer("160_1299465732.713")
    .param pmc param_2965
    .param pmc param_2966
.annotate 'line', 1309
    .lex "self", param_2965
    .lex "$/", param_2966
.annotate 'line', 1310
    find_lex $P2967, "$/"
    get_hll_global $P2968, ["PAST"], "Regex"
    find_lex $P2969, "$/"
    unless_null $P2969, vivify_892
    $P2969 = root_new ['parrot';'Hash']
  vivify_892:
    set $P2970, $P2969["var"]
    unless_null $P2970, vivify_893
    new $P2970, "Undef"
  vivify_893:
    $P2971 = $P2970."ast"()
    find_lex $P2972, "$/"
    $P2973 = $P2968."new"("!INTERPOLATE", $P2971, "subrule" :named("pasttype"), "method" :named("subtype"), $P2972 :named("node"))
    $P2974 = $P2967."!make"($P2973)
.annotate 'line', 1309
    .return ($P2974)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("164_1299465732.713") :outer("160_1299465732.713")
    .param pmc param_2976
    .param pmc param_2977
.annotate 'line', 1314
    .lex "self", param_2976
    .lex "$/", param_2977
.annotate 'line', 1315
    find_lex $P2978, "$/"
    get_hll_global $P2979, ["PAST"], "Regex"
    find_lex $P2980, "$/"
    unless_null $P2980, vivify_894
    $P2980 = root_new ['parrot';'Hash']
  vivify_894:
    set $P2981, $P2980["codeblock"]
    unless_null $P2981, vivify_895
    new $P2981, "Undef"
  vivify_895:
    $P2982 = $P2981."ast"()
    find_lex $P2983, "$/"
    $P2984 = $P2979."new"("!INTERPOLATE_REGEX", $P2982, "subrule" :named("pasttype"), "method" :named("subtype"), $P2983 :named("node"))
    $P2985 = $P2978."!make"($P2984)
.annotate 'line', 1314
    .return ($P2985)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("165_1299465732.713") :outer("160_1299465732.713")
    .param pmc param_2987
    .param pmc param_2988
.annotate 'line', 1319
    .lex "self", param_2987
    .lex "$/", param_2988
.annotate 'line', 1320
    find_lex $P2989, "$/"
    get_hll_global $P2990, ["PAST"], "Regex"
    find_lex $P2991, "$/"
    unless_null $P2991, vivify_896
    $P2991 = root_new ['parrot';'Hash']
  vivify_896:
    set $P2992, $P2991["codeblock"]
    unless_null $P2992, vivify_897
    new $P2992, "Undef"
  vivify_897:
    $P2993 = $P2992."ast"()
.annotate 'line', 1321
    find_lex $P2994, "$/"
    unless_null $P2994, vivify_898
    $P2994 = root_new ['parrot';'Hash']
  vivify_898:
    set $P2995, $P2994["zw"]
    unless_null $P2995, vivify_899
    new $P2995, "Undef"
  vivify_899:
    set $S2996, $P2995
    iseq $I2997, $S2996, "!"
    find_lex $P2998, "$/"
    $P2999 = $P2990."new"($P2993, "zerowidth" :named("subtype"), $I2997 :named("negate"), "pastnode" :named("pasttype"), $P2998 :named("node"))
.annotate 'line', 1320
    $P3000 = $P2989."!make"($P2999)
.annotate 'line', 1319
    .return ($P3000)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("166_1299465732.713") :outer("160_1299465732.713")
    .param pmc param_3002
    .param pmc param_3003
.annotate 'line', 1325
    .lex "self", param_3002
    .lex "$/", param_3003
.annotate 'line', 1326
    find_lex $P3004, "$/"
    get_hll_global $P3005, ["PAST"], "Regex"
    find_lex $P3006, "$/"
    unless_null $P3006, vivify_900
    $P3006 = root_new ['parrot';'Hash']
  vivify_900:
    set $P3007, $P3006["var"]
    unless_null $P3007, vivify_901
    new $P3007, "Undef"
  vivify_901:
    $P3008 = $P3007."ast"()
    find_lex $P3009, "$/"
    $P3010 = $P3005."new"("!INTERPOLATE_REGEX", $P3008, "subrule" :named("pasttype"), "method" :named("subtype"), $P3009 :named("node"))
    $P3011 = $P3004."!make"($P3010)
.annotate 'line', 1325
    .return ($P3011)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("167_1299465732.713") :outer("160_1299465732.713")
    .param pmc param_3013
    .param pmc param_3014
.annotate 'line', 1330
    .lex "self", param_3013
    .lex "$/", param_3014
.annotate 'line', 1331
    new $P3015, "Undef"
    .lex "$block", $P3015
.annotate 'line', 1333
    new $P3016, "Undef"
    .lex "$past", $P3016
.annotate 'line', 1331
    find_lex $P3017, "$/"
    unless_null $P3017, vivify_902
    $P3017 = root_new ['parrot';'Hash']
  vivify_902:
    set $P3018, $P3017["block"]
    unless_null $P3018, vivify_903
    new $P3018, "Undef"
  vivify_903:
    $P3019 = $P3018."ast"()
    store_lex "$block", $P3019
.annotate 'line', 1332
    find_lex $P3020, "$block"
    $P3020."blocktype"("immediate")
.annotate 'line', 1334
    get_hll_global $P3021, ["PAST"], "Stmts"
.annotate 'line', 1335
    get_hll_global $P3022, ["PAST"], "Op"
.annotate 'line', 1336
    get_hll_global $P3023, ["PAST"], "Var"
    $P3024 = $P3023."new"("$/" :named("name"))
.annotate 'line', 1337
    get_hll_global $P3025, ["PAST"], "Op"
.annotate 'line', 1338
    get_hll_global $P3026, ["PAST"], "Var"
    $P3027 = $P3026."new"(unicode:"$\x{a2}" :named("name"))
    $P3028 = $P3025."new"($P3027, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1337
    $P3029 = $P3022."new"($P3024, $P3028, "bind" :named("pasttype"))
.annotate 'line', 1335
    find_lex $P3030, "$block"
    $P3031 = $P3021."new"($P3029, $P3030)
.annotate 'line', 1334
    store_lex "$past", $P3031
.annotate 'line', 1346
    find_lex $P3032, "$/"
    find_lex $P3033, "$past"
    $P3034 = $P3032."!make"($P3033)
.annotate 'line', 1330
    .return ($P3034)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3059" :load :anon :subid("169_1299465732.713")
.annotate 'line', 3
    .const 'Sub' $P3061 = "11_1299465732.713" 
    $P3062 = $P3061()
    .return ($P3062)
.end


.HLL "nqp"

.namespace []
.sub "_block3286" :load :anon :subid("171_1299465732.713")
.annotate 'line', 1
    .const 'Sub' $P3288 = "10_1299465732.713" 
    $P3289 = $P3288()
    .return ($P3289)
.end

### .include 'gen/nqp-compiler.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299465735.322")
.annotate 'line', 0
    get_hll_global $P18, ["NQP";"Compiler"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    nqp_dynop_setup 
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    get_hll_global $P16, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P18, ["NQP";"Compiler"], "_block17" 
    capture_lex $P18
    $P77 = $P18()
    .return ($P77)
    .const 'Sub' $P79 = "15_1299465735.322" 
    .return ($P79)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block17"  :subid("11_1299465735.322") :outer("10_1299465735.322")
.annotate 'line', 1
    .const 'Sub' $P65 = "14_1299465735.322" 
    capture_lex $P65
    .const 'Sub' $P20 = "12_1299465735.322" 
    capture_lex $P20
    get_global $P19, "$?CLASS"
.annotate 'line', 4
    .const 'Sub' $P20 = "12_1299465735.322" 
    newclosure $P63, $P20
.annotate 'line', 1
    .return ($P63)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post16") :outer("11_1299465735.322")
.annotate 'line', 1
    get_hll_global $P18, ["NQP";"Compiler"], "_block17" 
    .local pmc block
    set block, $P18
    .const 'Sub' $P65 = "14_1299465735.322" 
    capture_lex $P65
    $P65()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block64"  :anon :subid("14_1299465735.322") :outer("11_1299465735.322")
.annotate 'line', 1
    get_hll_global $P66, "NQPClassHOW"
    $P67 = $P66."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P67
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P68, type_obj
    get_hll_global $P69, "NQPAttribute"
    $P70 = $P69."new"("%!settings_loaded" :named("name"))
    $P68."add_attribute"(type_obj, $P70)
    get_how $P71, type_obj
    .const 'Sub' $P72 = "12_1299465735.322" 
    $P71."add_method"(type_obj, "load_setting", $P72)
    get_how $P73, type_obj
    get_hll_global $P74, ["HLL"], "Compiler"
    $P73."add_parent"(type_obj, $P74)
    get_how $P75, type_obj
    $P76 = $P75."compose"(type_obj)
    .return ($P76)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "load_setting"  :subid("12_1299465735.322") :outer("11_1299465735.322")
    .param pmc param_21
    .param pmc param_22
.annotate 'line', 4
    .const 'Sub' $P36 = "13_1299465735.322" 
    capture_lex $P36
    .lex "self", param_21
    .lex "$setting_name", param_22
.annotate 'line', 5
    find_lex $P25, "$setting_name"
    set $S26, $P25
    isne $I27, $S26, "NULL"
    if $I27, if_24
    new $P23, 'Integer'
    set $P23, $I27
    goto if_24_end
  if_24:
.annotate 'line', 7
    find_lex $P29, "$setting_name"
    find_lex $P30, "self"
    get_global $P31, "$?CLASS"
    getattribute $P32, $P30, $P31, "%!settings_loaded"
    unless_null $P32, vivify_17
    $P32 = root_new ['parrot';'Hash']
  vivify_17:
    set $P33, $P32[$P29]
    unless_null $P33, vivify_18
    new $P33, "Undef"
  vivify_18:
    defined $I34, $P33
    if $I34, unless_28_end
    .const 'Sub' $P36 = "13_1299465735.322" 
    capture_lex $P36
    $P36()
  unless_28_end:
.annotate 'line', 19
    find_lex $P56, "$setting_name"
    find_lex $P57, "self"
    get_global $P58, "$?CLASS"
    getattribute $P59, $P57, $P58, "%!settings_loaded"
    unless_null $P59, vivify_26
    $P59 = root_new ['parrot';'Hash']
  vivify_26:
    set $P60, $P59[$P56]
    unless_null $P60, vivify_27
    new $P60, "Undef"
  vivify_27:
    find_dynamic_lex $P61, "%*COMPILING"
    unless_null $P61, vivify_28
    get_hll_global $P61, "%COMPILING"
    unless_null $P61, vivify_29
    die "Contextual %*COMPILING not found"
  vivify_29:
    store_dynamic_lex "%*COMPILING", $P61
  vivify_28:
    set $P62, $P61["%?OPTIONS"]
    unless_null $P62, vivify_30
    $P62 = root_new ['parrot';'Hash']
    set $P61["%?OPTIONS"], $P62
  vivify_30:
    set $P62["outer_ctx"], $P60
.annotate 'line', 5
    set $P23, $P60
  if_24_end:
.annotate 'line', 4
    .return ($P23)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block35"  :anon :subid("13_1299465735.322") :outer("12_1299465735.322")
.annotate 'line', 8
    new $P37, "Undef"
    .lex "$*CTXSAVE", $P37
.annotate 'line', 9
    new $P38, "Undef"
    .lex "$*MAIN_CTX", $P38
.annotate 'line', 8
    find_lex $P39, "self"
    store_lex "$*CTXSAVE", $P39
    find_lex $P40, "$*MAIN_CTX"
    unless_null $P40, vivify_19
    get_hll_global $P40, "$MAIN_CTX"
    unless_null $P40, vivify_20
    die "Contextual $*MAIN_CTX not found"
  vivify_20:
  vivify_19:
.annotate 'line', 10
    find_lex $P41, "$setting_name"
    concat $P42, $P41, ".setting.pbc"
    set $S43, $P42
    load_bytecode $S43
.annotate 'line', 11
    find_lex $P45, "$*MAIN_CTX"
    unless_null $P45, vivify_21
    get_hll_global $P45, "$MAIN_CTX"
    unless_null $P45, vivify_22
    die "Contextual $*MAIN_CTX not found"
  vivify_22:
  vivify_21:
    defined $I46, $P45
    if $I46, unless_44_end
.annotate 'line', 12
    new $P47, 'String'
    set $P47, "Unable to load setting "
    find_lex $P48, "$setting_name"
    concat $P49, $P47, $P48
    concat $P50, $P49, "; maybe it is missing a YOU_ARE_HERE?"
    die $P50
  unless_44_end:
.annotate 'line', 14
    find_lex $P51, "$*MAIN_CTX"
    unless_null $P51, vivify_23
    get_hll_global $P51, "$MAIN_CTX"
    unless_null $P51, vivify_24
    die "Contextual $*MAIN_CTX not found"
  vivify_24:
  vivify_23:
    find_lex $P52, "$setting_name"
    find_lex $P53, "self"
    get_global $P54, "$?CLASS"
    getattribute $P55, $P53, $P54, "%!settings_loaded"
    unless_null $P55, vivify_25
    $P55 = root_new ['parrot';'Hash']
    setattribute $P53, $P54, "%!settings_loaded", $P55
  vivify_25:
    set $P55[$P52], $P51
.annotate 'line', 7
    .return ($P51)
.end


.HLL "nqp"

.namespace []
.sub "_block78" :load :anon :subid("15_1299465735.322")
.annotate 'line', 1
    .const 'Sub' $P80 = "10_1299465735.322" 
    $P81 = $P80()
    .return ($P81)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('nqp')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
    push $P0, 'setting=s'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'nqp'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
