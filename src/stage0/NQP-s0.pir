# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

.HLL 'nqp'

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup

    .local pmc interp, lexpad, nqplexpad
    interp = getinterp
    lexpad = get_class 'LexPad'
    nqplexpad = get_class 'NQPLexPad'
    interp.'hll_map'(lexpad, nqplexpad)
    
    load_bytecode 'SettingManager.pbc'
    load_bytecode 'nqpmo.pbc'
.end

.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
    
    ## Bring in PAST and PCT
    .local pmc hllns, parrotns, imports
    hllns = get_hll_namespace
    parrotns = get_root_namespace ['parrot']
    imports = split ' ', 'PAST PCT'
    parrotns.'export_to'(hllns, imports)
.end

### .include 'gen/nqp-grammar.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299602538.98")
.annotate 'line', 0
    get_hll_global $P18, ["NQP";"Grammar"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    get_hll_global $P16, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P18, ["NQP";"Grammar"], "_block17" 
    capture_lex $P18
    $P2486 = $P18()
.annotate 'line', 1
    .return ($P2486)
    .const 'Sub' $P2488 = "403_1299602538.98" 
    .return ($P2488)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post404") :outer("10_1299602538.98")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1299602538.98" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P2492, "1299602532.997"
    isnull $I2493, $P2492
    if $I2493, if_2491
    goto if_2491_end
  if_2491:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P2494, "1299602532.997"
    .local pmc cur_sc
    set cur_sc, $P2494
    load_bytecode "SettingManager.pbc"
    get_hll_global $P2495, ["HLL"], "SettingManager"
    $P2496 = $P2495."load_setting"("NQPCORE")
    block."set_outer_ctx"($P2496)
    get_hll_global $P2497, "NQPClassHOW"
    $P2498 = $P2497."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P2498, cur_sc
    nqp_set_sc_object "1299602532.997", 0, $P2498
    get_hll_global $P2499, "NQPClassHOW"
    $P2500 = $P2499."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P2500, cur_sc
    nqp_set_sc_object "1299602532.997", 1, $P2500
  if_2491_end:
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block17"  :subid("11_1299602538.98") :outer("10_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P1772 = "402_1299602538.98" 
    capture_lex $P1772
    get_hll_global $P1654, ["NQP";"Regex"], "_block1653" 
    capture_lex $P1654
    .const 'Sub' $P1642 = "378_1299602538.98" 
    capture_lex $P1642
    .const 'Sub' $P1636 = "376_1299602538.98" 
    capture_lex $P1636
    .const 'Sub' $P1630 = "374_1299602538.98" 
    capture_lex $P1630
    .const 'Sub' $P1624 = "372_1299602538.98" 
    capture_lex $P1624
    .const 'Sub' $P1618 = "370_1299602538.98" 
    capture_lex $P1618
    .const 'Sub' $P1606 = "367_1299602538.98" 
    capture_lex $P1606
    .const 'Sub' $P1599 = "365_1299602538.98" 
    capture_lex $P1599
    .const 'Sub' $P1592 = "363_1299602538.98" 
    capture_lex $P1592
    .const 'Sub' $P1585 = "361_1299602538.98" 
    capture_lex $P1585
    .const 'Sub' $P1578 = "359_1299602538.98" 
    capture_lex $P1578
    .const 'Sub' $P1572 = "357_1299602538.98" 
    capture_lex $P1572
    .const 'Sub' $P1565 = "355_1299602538.98" 
    capture_lex $P1565
    .const 'Sub' $P1558 = "353_1299602538.98" 
    capture_lex $P1558
    .const 'Sub' $P1551 = "351_1299602538.98" 
    capture_lex $P1551
    .const 'Sub' $P1544 = "349_1299602538.98" 
    capture_lex $P1544
    .const 'Sub' $P1537 = "347_1299602538.98" 
    capture_lex $P1537
    .const 'Sub' $P1530 = "345_1299602538.98" 
    capture_lex $P1530
    .const 'Sub' $P1523 = "343_1299602538.98" 
    capture_lex $P1523
    .const 'Sub' $P1516 = "341_1299602538.98" 
    capture_lex $P1516
    .const 'Sub' $P1509 = "339_1299602538.98" 
    capture_lex $P1509
    .const 'Sub' $P1502 = "337_1299602538.98" 
    capture_lex $P1502
    .const 'Sub' $P1495 = "335_1299602538.98" 
    capture_lex $P1495
    .const 'Sub' $P1488 = "333_1299602538.98" 
    capture_lex $P1488
    .const 'Sub' $P1481 = "331_1299602538.98" 
    capture_lex $P1481
    .const 'Sub' $P1474 = "329_1299602538.98" 
    capture_lex $P1474
    .const 'Sub' $P1467 = "327_1299602538.98" 
    capture_lex $P1467
    .const 'Sub' $P1460 = "325_1299602538.98" 
    capture_lex $P1460
    .const 'Sub' $P1453 = "323_1299602538.98" 
    capture_lex $P1453
    .const 'Sub' $P1446 = "321_1299602538.98" 
    capture_lex $P1446
    .const 'Sub' $P1439 = "319_1299602538.98" 
    capture_lex $P1439
    .const 'Sub' $P1432 = "317_1299602538.98" 
    capture_lex $P1432
    .const 'Sub' $P1425 = "315_1299602538.98" 
    capture_lex $P1425
    .const 'Sub' $P1418 = "313_1299602538.98" 
    capture_lex $P1418
    .const 'Sub' $P1411 = "311_1299602538.98" 
    capture_lex $P1411
    .const 'Sub' $P1404 = "309_1299602538.98" 
    capture_lex $P1404
    .const 'Sub' $P1397 = "307_1299602538.98" 
    capture_lex $P1397
    .const 'Sub' $P1390 = "305_1299602538.98" 
    capture_lex $P1390
    .const 'Sub' $P1383 = "303_1299602538.98" 
    capture_lex $P1383
    .const 'Sub' $P1376 = "301_1299602538.98" 
    capture_lex $P1376
    .const 'Sub' $P1369 = "299_1299602538.98" 
    capture_lex $P1369
    .const 'Sub' $P1363 = "297_1299602538.98" 
    capture_lex $P1363
    .const 'Sub' $P1356 = "295_1299602538.98" 
    capture_lex $P1356
    .const 'Sub' $P1349 = "293_1299602538.98" 
    capture_lex $P1349
    .const 'Sub' $P1342 = "291_1299602538.98" 
    capture_lex $P1342
    .const 'Sub' $P1335 = "289_1299602538.98" 
    capture_lex $P1335
    .const 'Sub' $P1328 = "287_1299602538.98" 
    capture_lex $P1328
    .const 'Sub' $P1321 = "285_1299602538.98" 
    capture_lex $P1321
    .const 'Sub' $P1314 = "283_1299602538.98" 
    capture_lex $P1314
    .const 'Sub' $P1308 = "281_1299602538.98" 
    capture_lex $P1308
    .const 'Sub' $P1302 = "279_1299602538.98" 
    capture_lex $P1302
    .const 'Sub' $P1297 = "277_1299602538.98" 
    capture_lex $P1297
    .const 'Sub' $P1291 = "275_1299602538.98" 
    capture_lex $P1291
    .const 'Sub' $P1285 = "273_1299602538.98" 
    capture_lex $P1285
    .const 'Sub' $P1280 = "271_1299602538.98" 
    capture_lex $P1280
    .const 'Sub' $P1275 = "269_1299602538.98" 
    capture_lex $P1275
    .const 'Sub' $P1259 = "268_1299602538.98" 
    capture_lex $P1259
    .const 'Sub' $P1250 = "266_1299602538.98" 
    capture_lex $P1250
    .const 'Sub' $P1241 = "264_1299602538.98" 
    capture_lex $P1241
    .const 'Sub' $P1236 = "262_1299602538.98" 
    capture_lex $P1236
    .const 'Sub' $P1231 = "260_1299602538.98" 
    capture_lex $P1231
    .const 'Sub' $P1226 = "258_1299602538.98" 
    capture_lex $P1226
    .const 'Sub' $P1218 = "256_1299602538.98" 
    capture_lex $P1218
    .const 'Sub' $P1210 = "254_1299602538.98" 
    capture_lex $P1210
    .const 'Sub' $P1205 = "252_1299602538.98" 
    capture_lex $P1205
    .const 'Sub' $P1200 = "250_1299602538.98" 
    capture_lex $P1200
    .const 'Sub' $P1195 = "248_1299602538.98" 
    capture_lex $P1195
    .const 'Sub' $P1189 = "246_1299602538.98" 
    capture_lex $P1189
    .const 'Sub' $P1183 = "244_1299602538.98" 
    capture_lex $P1183
    .const 'Sub' $P1177 = "242_1299602538.98" 
    capture_lex $P1177
    .const 'Sub' $P1171 = "240_1299602538.98" 
    capture_lex $P1171
    .const 'Sub' $P1165 = "238_1299602538.98" 
    capture_lex $P1165
    .const 'Sub' $P1160 = "236_1299602538.98" 
    capture_lex $P1160
    .const 'Sub' $P1155 = "234_1299602538.98" 
    capture_lex $P1155
    .const 'Sub' $P1141 = "230_1299602538.98" 
    capture_lex $P1141
    .const 'Sub' $P1133 = "228_1299602538.98" 
    capture_lex $P1133
    .const 'Sub' $P1127 = "226_1299602538.98" 
    capture_lex $P1127
    .const 'Sub' $P1120 = "224_1299602538.98" 
    capture_lex $P1120
    .const 'Sub' $P1114 = "222_1299602538.98" 
    capture_lex $P1114
    .const 'Sub' $P1100 = "219_1299602538.98" 
    capture_lex $P1100
    .const 'Sub' $P1092 = "217_1299602538.98" 
    capture_lex $P1092
    .const 'Sub' $P1084 = "215_1299602538.98" 
    capture_lex $P1084
    .const 'Sub' $P1078 = "213_1299602538.98" 
    capture_lex $P1078
    .const 'Sub' $P1072 = "211_1299602538.98" 
    capture_lex $P1072
    .const 'Sub' $P1056 = "207_1299602538.98" 
    capture_lex $P1056
    .const 'Sub' $P1015 = "205_1299602538.98" 
    capture_lex $P1015
    .const 'Sub' $P1004 = "203_1299602538.98" 
    capture_lex $P1004
    .const 'Sub' $P990 = "199_1299602538.98" 
    capture_lex $P990
    .const 'Sub' $P981 = "197_1299602538.98" 
    capture_lex $P981
    .const 'Sub' $P975 = "195_1299602538.98" 
    capture_lex $P975
    .const 'Sub' $P965 = "193_1299602538.98" 
    capture_lex $P965
    .const 'Sub' $P950 = "191_1299602538.98" 
    capture_lex $P950
    .const 'Sub' $P936 = "188_1299602538.98" 
    capture_lex $P936
    .const 'Sub' $P928 = "186_1299602538.98" 
    capture_lex $P928
    .const 'Sub' $P918 = "184_1299602538.98" 
    capture_lex $P918
    .const 'Sub' $P908 = "182_1299602538.98" 
    capture_lex $P908
    .const 'Sub' $P889 = "177_1299602538.98" 
    capture_lex $P889
    .const 'Sub' $P845 = "174_1299602538.98" 
    capture_lex $P845
    .const 'Sub' $P811 = "172_1299602538.98" 
    capture_lex $P811
    .const 'Sub' $P804 = "170_1299602538.98" 
    capture_lex $P804
    .const 'Sub' $P797 = "168_1299602538.98" 
    capture_lex $P797
    .const 'Sub' $P780 = "164_1299602538.98" 
    capture_lex $P780
    .const 'Sub' $P772 = "162_1299602538.98" 
    capture_lex $P772
    .const 'Sub' $P766 = "160_1299602538.98" 
    capture_lex $P766
    .const 'Sub' $P753 = "158_1299602538.98" 
    capture_lex $P753
    .const 'Sub' $P746 = "156_1299602538.98" 
    capture_lex $P746
    .const 'Sub' $P739 = "154_1299602538.98" 
    capture_lex $P739
    .const 'Sub' $P732 = "152_1299602538.98" 
    capture_lex $P732
    .const 'Sub' $P654 = "147_1299602538.98" 
    capture_lex $P654
    .const 'Sub' $P642 = "145_1299602538.98" 
    capture_lex $P642
    .const 'Sub' $P630 = "143_1299602538.98" 
    capture_lex $P630
    .const 'Sub' $P618 = "141_1299602538.98" 
    capture_lex $P618
    .const 'Sub' $P606 = "139_1299602538.98" 
    capture_lex $P606
    .const 'Sub' $P594 = "137_1299602538.98" 
    capture_lex $P594
    .const 'Sub' $P582 = "135_1299602538.98" 
    capture_lex $P582
    .const 'Sub' $P571 = "131_1299602538.98" 
    capture_lex $P571
    .const 'Sub' $P566 = "129_1299602538.98" 
    capture_lex $P566
    .const 'Sub' $P554 = "127_1299602538.98" 
    capture_lex $P554
    .const 'Sub' $P542 = "125_1299602538.98" 
    capture_lex $P542
    .const 'Sub' $P535 = "123_1299602538.98" 
    capture_lex $P535
    .const 'Sub' $P530 = "121_1299602538.98" 
    capture_lex $P530
    .const 'Sub' $P524 = "119_1299602538.98" 
    capture_lex $P524
    .const 'Sub' $P518 = "117_1299602538.98" 
    capture_lex $P518
    .const 'Sub' $P503 = "113_1299602538.98" 
    capture_lex $P503
    .const 'Sub' $P497 = "111_1299602538.98" 
    capture_lex $P497
    .const 'Sub' $P491 = "109_1299602538.98" 
    capture_lex $P491
    .const 'Sub' $P485 = "107_1299602538.98" 
    capture_lex $P485
    .const 'Sub' $P479 = "105_1299602538.98" 
    capture_lex $P479
    .const 'Sub' $P473 = "103_1299602538.98" 
    capture_lex $P473
    .const 'Sub' $P467 = "101_1299602538.98" 
    capture_lex $P467
    .const 'Sub' $P458 = "99_1299602538.98" 
    capture_lex $P458
    .const 'Sub' $P449 = "97_1299602538.98" 
    capture_lex $P449
    .const 'Sub' $P440 = "95_1299602538.98" 
    capture_lex $P440
    .const 'Sub' $P425 = "91_1299602538.98" 
    capture_lex $P425
    .const 'Sub' $P416 = "89_1299602538.98" 
    capture_lex $P416
    .const 'Sub' $P404 = "85_1299602538.98" 
    capture_lex $P404
    .const 'Sub' $P397 = "83_1299602538.98" 
    capture_lex $P397
    .const 'Sub' $P390 = "81_1299602538.98" 
    capture_lex $P390
    .const 'Sub' $P376 = "77_1299602538.98" 
    capture_lex $P376
    .const 'Sub' $P368 = "75_1299602538.98" 
    capture_lex $P368
    .const 'Sub' $P360 = "73_1299602538.98" 
    capture_lex $P360
    .const 'Sub' $P340 = "71_1299602538.98" 
    capture_lex $P340
    .const 'Sub' $P331 = "69_1299602538.98" 
    capture_lex $P331
    .const 'Sub' $P313 = "66_1299602538.98" 
    capture_lex $P313
    .const 'Sub' $P295 = "64_1299602538.98" 
    capture_lex $P295
    .const 'Sub' $P284 = "60_1299602538.98" 
    capture_lex $P284
    .const 'Sub' $P279 = "58_1299602538.98" 
    capture_lex $P279
    .const 'Sub' $P268 = "54_1299602538.98" 
    capture_lex $P268
    .const 'Sub' $P263 = "52_1299602538.98" 
    capture_lex $P263
    .const 'Sub' $P258 = "50_1299602538.98" 
    capture_lex $P258
    .const 'Sub' $P253 = "48_1299602538.98" 
    capture_lex $P253
    .const 'Sub' $P243 = "46_1299602538.98" 
    capture_lex $P243
    .const 'Sub' $P236 = "44_1299602538.98" 
    capture_lex $P236
    .const 'Sub' $P230 = "42_1299602538.98" 
    capture_lex $P230
    .const 'Sub' $P222 = "40_1299602538.98" 
    capture_lex $P222
    .const 'Sub' $P216 = "38_1299602538.98" 
    capture_lex $P216
    .const 'Sub' $P210 = "36_1299602538.98" 
    capture_lex $P210
    .const 'Sub' $P195 = "33_1299602538.98" 
    capture_lex $P195
    .const 'Sub' $P181 = "31_1299602538.98" 
    capture_lex $P181
    .const 'Sub' $P172 = "29_1299602538.98" 
    capture_lex $P172
    .const 'Sub' $P133 = "26_1299602538.98" 
    capture_lex $P133
    .const 'Sub' $P118 = "23_1299602538.98" 
    capture_lex $P118
    .const 'Sub' $P107 = "21_1299602538.98" 
    capture_lex $P107
    .const 'Sub' $P95 = "19_1299602538.98" 
    capture_lex $P95
    .const 'Sub' $P87 = "17_1299602538.98" 
    capture_lex $P87
    .const 'Sub' $P80 = "15_1299602538.98" 
    capture_lex $P80
    .const 'Sub' $P73 = "13_1299602538.98" 
    capture_lex $P73
    .const 'Sub' $P24 = "12_1299602538.98" 
    capture_lex $P24
    get_global $P19, "$?CLASS"
    getinterp $P20
    get_class $P21, "LexPad"
    get_class $P22, "NQPLexPad"
    $P20."hll_map"($P21, $P22)
    get_hll_global $P23, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1259 = "268_1299602538.98" 
    capture_lex $P1259
    $P1259()
.annotate 'line', 686
    get_hll_global $P1654, ["NQP";"Regex"], "_block1653" 
    capture_lex $P1654
    $P1756 = $P1654()
.annotate 'line', 4
    .return ($P1756)
    .const 'Sub' $P1758 = "401_1299602538.98" 
    .return ($P1758)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post405") :outer("11_1299602538.98")
.annotate 'line', 4
    get_hll_global $P18, ["NQP";"Grammar"], "_block17" 
    .local pmc block
    set block, $P18
    nqp_get_sc $P1762, "1299602532.997"
    isnull $I1763, $P1762
    if $I1763, if_1761
    goto if_1761_end
  if_1761:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P1764, "1299602532.997"
    .local pmc cur_sc
    set cur_sc, $P1764
    load_bytecode "SettingManager.pbc"
    get_hll_global $P1765, ["HLL"], "SettingManager"
    $P1766 = $P1765."load_setting"("NQPCORE")
    block."set_outer_ctx"($P1766)
    get_hll_global $P1767, "NQPClassHOW"
    $P1768 = $P1767."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P1768, cur_sc
    nqp_set_sc_object "1299602532.997", 0, $P1768
    get_hll_global $P1769, "NQPClassHOW"
    $P1770 = $P1769."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P1770, cur_sc
    nqp_set_sc_object "1299602532.997", 1, $P1770
  if_1761_end:
    .const 'Sub' $P1772 = "402_1299602538.98" 
    capture_lex $P1772
    $P1772()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1771"  :anon :subid("402_1299602538.98") :outer("11_1299602538.98")
.annotate 'line', 4
    nqp_get_sc_object $P1773, "1299602532.997", 0
    .local pmc type_obj
    set type_obj, $P1773
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1774, type_obj
    .const 'Sub' $P1775 = "12_1299602538.98" 
    $P1774."add_method"(type_obj, "TOP", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "13_1299602538.98" 
    $P1776."add_method"(type_obj, "identifier", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__identifier"
    $P1778."add_method"(type_obj, "!PREFIX__identifier", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "15_1299602538.98" 
    $P1780."add_method"(type_obj, "name", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__name"
    $P1782."add_method"(type_obj, "!PREFIX__name", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "17_1299602538.98" 
    $P1784."add_method"(type_obj, "deflongname", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__deflongname"
    $P1786."add_method"(type_obj, "!PREFIX__deflongname", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "19_1299602538.98" 
    $P1788."add_method"(type_obj, "ENDSTMT", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__ENDSTMT"
    $P1790."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "21_1299602538.98" 
    $P1792."add_method"(type_obj, "ws", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__ws"
    $P1794."add_method"(type_obj, "!PREFIX__ws", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "23_1299602538.98" 
    $P1796."add_method"(type_obj, "unv", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__unv"
    $P1798."add_method"(type_obj, "!PREFIX__unv", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "26_1299602538.98" 
    $P1800."add_method"(type_obj, "pod_comment", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__pod_comment"
    $P1802."add_method"(type_obj, "!PREFIX__pod_comment", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "29_1299602538.98" 
    $P1804."add_method"(type_obj, "comp_unit", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__comp_unit"
    $P1806."add_method"(type_obj, "!PREFIX__comp_unit", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "31_1299602538.98" 
    $P1808."add_method"(type_obj, "statementlist", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statementlist"
    $P1810."add_method"(type_obj, "!PREFIX__statementlist", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "33_1299602538.98" 
    $P1812."add_method"(type_obj, "statement", $P1813)
    get_how $P1814, type_obj
    get_global $P1815, "!PREFIX__statement"
    $P1814."add_method"(type_obj, "!PREFIX__statement", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "36_1299602538.98" 
    $P1816."add_method"(type_obj, "eat_terminator", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__eat_terminator"
    $P1818."add_method"(type_obj, "!PREFIX__eat_terminator", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "38_1299602538.98" 
    $P1820."add_method"(type_obj, "xblock", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__xblock"
    $P1822."add_method"(type_obj, "!PREFIX__xblock", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "40_1299602538.98" 
    $P1824."add_method"(type_obj, "pblock", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__pblock"
    $P1826."add_method"(type_obj, "!PREFIX__pblock", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "42_1299602538.98" 
    $P1828."add_method"(type_obj, "lambda", $P1829)
    get_how $P1830, type_obj
    get_global $P1831, "!PREFIX__lambda"
    $P1830."add_method"(type_obj, "!PREFIX__lambda", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "44_1299602538.98" 
    $P1832."add_method"(type_obj, "block", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__block"
    $P1834."add_method"(type_obj, "!PREFIX__block", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "46_1299602538.98" 
    $P1836."add_method"(type_obj, "blockoid", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__blockoid"
    $P1838."add_method"(type_obj, "!PREFIX__blockoid", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "48_1299602538.98" 
    $P1840."add_method"(type_obj, "newpad", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__newpad"
    $P1842."add_method"(type_obj, "!PREFIX__newpad", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "50_1299602538.98" 
    $P1844."add_method"(type_obj, "outerctx", $P1845)
    get_how $P1846, type_obj
    get_global $P1847, "!PREFIX__outerctx"
    $P1846."add_method"(type_obj, "!PREFIX__outerctx", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "52_1299602538.98" 
    $P1848."add_method"(type_obj, "finishpad", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__finishpad"
    $P1850."add_method"(type_obj, "!PREFIX__finishpad", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "54_1299602538.98" 
    $P1852."add_method"(type_obj, "you_are_here", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__you_are_here"
    $P1854."add_method"(type_obj, "!PREFIX__you_are_here", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "56_1299602538.98" 
    $P1856."add_method"(type_obj, "terminator", $P1857)
    get_how $P1858, type_obj
    .const 'Sub' $P1859 = "57_1299602538.98" 
    $P1858."add_method"(type_obj, "!PREFIX__terminator", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "58_1299602538.98" 
    $P1860."add_method"(type_obj, "terminator:sym<;>", $P1861)
    get_how $P1862, type_obj
    get_global $P1863, "!PREFIX__terminator:sym<;>"
    $P1862."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "60_1299602538.98" 
    $P1864."add_method"(type_obj, "terminator:sym<}>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__terminator:sym<}>"
    $P1866."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "62_1299602538.98" 
    $P1868."add_method"(type_obj, "statement_control", $P1869)
    get_how $P1870, type_obj
    .const 'Sub' $P1871 = "63_1299602538.98" 
    $P1870."add_method"(type_obj, "!PREFIX__statement_control", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "64_1299602538.98" 
    $P1872."add_method"(type_obj, "statement_control:sym<if>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__statement_control:sym<if>"
    $P1874."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "66_1299602538.98" 
    $P1876."add_method"(type_obj, "statement_control:sym<unless>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__statement_control:sym<unless>"
    $P1878."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "69_1299602538.98" 
    $P1880."add_method"(type_obj, "statement_control:sym<while>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__statement_control:sym<while>"
    $P1882."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "71_1299602538.98" 
    $P1884."add_method"(type_obj, "statement_control:sym<repeat>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__statement_control:sym<repeat>"
    $P1886."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "73_1299602538.98" 
    $P1888."add_method"(type_obj, "statement_control:sym<for>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__statement_control:sym<for>"
    $P1890."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "75_1299602538.98" 
    $P1892."add_method"(type_obj, "statement_control:sym<CATCH>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__statement_control:sym<CATCH>"
    $P1894."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "77_1299602538.98" 
    $P1896."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__statement_control:sym<CONTROL>"
    $P1898."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "79_1299602538.98" 
    $P1900."add_method"(type_obj, "statement_prefix", $P1901)
    get_how $P1902, type_obj
    .const 'Sub' $P1903 = "80_1299602538.98" 
    $P1902."add_method"(type_obj, "!PREFIX__statement_prefix", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "81_1299602538.98" 
    $P1904."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__statement_prefix:sym<INIT>"
    $P1906."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "83_1299602538.98" 
    $P1908."add_method"(type_obj, "statement_prefix:sym<try>", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__statement_prefix:sym<try>"
    $P1910."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "85_1299602538.98" 
    $P1912."add_method"(type_obj, "blorst", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__blorst"
    $P1914."add_method"(type_obj, "!PREFIX__blorst", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "87_1299602538.98" 
    $P1916."add_method"(type_obj, "statement_mod_cond", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "88_1299602538.98" 
    $P1918."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "89_1299602538.98" 
    $P1920."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__statement_mod_cond:sym<if>"
    $P1922."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "91_1299602538.98" 
    $P1924."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1926."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "93_1299602538.98" 
    $P1928."add_method"(type_obj, "statement_mod_loop", $P1929)
    get_how $P1930, type_obj
    .const 'Sub' $P1931 = "94_1299602538.98" 
    $P1930."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "95_1299602538.98" 
    $P1932."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__statement_mod_loop:sym<while>"
    $P1934."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "97_1299602538.98" 
    $P1936."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__statement_mod_loop:sym<until>"
    $P1938."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "99_1299602538.98" 
    $P1940."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__statement_mod_loop:sym<for>"
    $P1942."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "101_1299602538.98" 
    $P1944."add_method"(type_obj, "term:sym<fatarrow>", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__term:sym<fatarrow>"
    $P1946."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "103_1299602538.98" 
    $P1948."add_method"(type_obj, "term:sym<colonpair>", $P1949)
    get_how $P1950, type_obj
    get_global $P1951, "!PREFIX__term:sym<colonpair>"
    $P1950."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "105_1299602538.98" 
    $P1952."add_method"(type_obj, "term:sym<variable>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__term:sym<variable>"
    $P1954."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "107_1299602538.98" 
    $P1956."add_method"(type_obj, "term:sym<package_declarator>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__term:sym<package_declarator>"
    $P1958."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "109_1299602538.98" 
    $P1960."add_method"(type_obj, "term:sym<scope_declarator>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__term:sym<scope_declarator>"
    $P1962."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "111_1299602538.98" 
    $P1964."add_method"(type_obj, "term:sym<routine_declarator>", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__term:sym<routine_declarator>"
    $P1966."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "113_1299602538.98" 
    $P1968."add_method"(type_obj, "term:sym<multi_declarator>", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__term:sym<multi_declarator>"
    $P1970."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "117_1299602538.98" 
    $P1972."add_method"(type_obj, "term:sym<regex_declarator>", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__term:sym<regex_declarator>"
    $P1974."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "119_1299602538.98" 
    $P1976."add_method"(type_obj, "term:sym<statement_prefix>", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__term:sym<statement_prefix>"
    $P1978."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "121_1299602538.98" 
    $P1980."add_method"(type_obj, "term:sym<lambda>", $P1981)
    get_how $P1982, type_obj
    get_global $P1983, "!PREFIX__term:sym<lambda>"
    $P1982."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "123_1299602538.98" 
    $P1984."add_method"(type_obj, "fatarrow", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__fatarrow"
    $P1986."add_method"(type_obj, "!PREFIX__fatarrow", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "125_1299602538.98" 
    $P1988."add_method"(type_obj, "colonpair", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__colonpair"
    $P1990."add_method"(type_obj, "!PREFIX__colonpair", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "127_1299602538.98" 
    $P1992."add_method"(type_obj, "variable", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__variable"
    $P1994."add_method"(type_obj, "!PREFIX__variable", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "129_1299602538.98" 
    $P1996."add_method"(type_obj, "sigil", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__sigil"
    $P1998."add_method"(type_obj, "!PREFIX__sigil", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "131_1299602538.98" 
    $P2000."add_method"(type_obj, "twigil", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__twigil"
    $P2002."add_method"(type_obj, "!PREFIX__twigil", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "133_1299602538.98" 
    $P2004."add_method"(type_obj, "package_declarator", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "134_1299602538.98" 
    $P2006."add_method"(type_obj, "!PREFIX__package_declarator", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "135_1299602538.98" 
    $P2008."add_method"(type_obj, "package_declarator:sym<module>", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__package_declarator:sym<module>"
    $P2010."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "137_1299602538.98" 
    $P2012."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__package_declarator:sym<knowhow>"
    $P2014."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "139_1299602538.98" 
    $P2016."add_method"(type_obj, "package_declarator:sym<class>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__package_declarator:sym<class>"
    $P2018."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "141_1299602538.98" 
    $P2020."add_method"(type_obj, "package_declarator:sym<grammar>", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__package_declarator:sym<grammar>"
    $P2022."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "143_1299602538.98" 
    $P2024."add_method"(type_obj, "package_declarator:sym<role>", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__package_declarator:sym<role>"
    $P2026."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "145_1299602538.98" 
    $P2028."add_method"(type_obj, "package_declarator:sym<native>", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__package_declarator:sym<native>"
    $P2030."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "147_1299602538.98" 
    $P2032."add_method"(type_obj, "package_def", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__package_def"
    $P2034."add_method"(type_obj, "!PREFIX__package_def", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "150_1299602538.98" 
    $P2036."add_method"(type_obj, "scope_declarator", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "151_1299602538.98" 
    $P2038."add_method"(type_obj, "!PREFIX__scope_declarator", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "152_1299602538.98" 
    $P2040."add_method"(type_obj, "scope_declarator:sym<my>", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__scope_declarator:sym<my>"
    $P2042."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "154_1299602538.98" 
    $P2044."add_method"(type_obj, "scope_declarator:sym<our>", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__scope_declarator:sym<our>"
    $P2046."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "156_1299602538.98" 
    $P2048."add_method"(type_obj, "scope_declarator:sym<has>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__scope_declarator:sym<has>"
    $P2050."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "158_1299602538.98" 
    $P2052."add_method"(type_obj, "scoped", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__scoped"
    $P2054."add_method"(type_obj, "!PREFIX__scoped", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "160_1299602538.98" 
    $P2056."add_method"(type_obj, "typename", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__typename"
    $P2058."add_method"(type_obj, "!PREFIX__typename", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "162_1299602538.98" 
    $P2060."add_method"(type_obj, "declarator", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__declarator"
    $P2062."add_method"(type_obj, "!PREFIX__declarator", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "164_1299602538.98" 
    $P2064."add_method"(type_obj, "variable_declarator", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__variable_declarator"
    $P2066."add_method"(type_obj, "!PREFIX__variable_declarator", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "166_1299602538.98" 
    $P2068."add_method"(type_obj, "routine_declarator", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "167_1299602538.98" 
    $P2070."add_method"(type_obj, "!PREFIX__routine_declarator", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "168_1299602538.98" 
    $P2072."add_method"(type_obj, "routine_declarator:sym<sub>", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__routine_declarator:sym<sub>"
    $P2074."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "170_1299602538.98" 
    $P2076."add_method"(type_obj, "routine_declarator:sym<method>", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__routine_declarator:sym<method>"
    $P2078."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "172_1299602538.98" 
    $P2080."add_method"(type_obj, "routine_def", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__routine_def"
    $P2082."add_method"(type_obj, "!PREFIX__routine_def", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "174_1299602538.98" 
    $P2084."add_method"(type_obj, "method_def", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__method_def"
    $P2086."add_method"(type_obj, "!PREFIX__method_def", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "177_1299602538.98" 
    $P2088."add_method"(type_obj, "onlystar", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__onlystar"
    $P2090."add_method"(type_obj, "!PREFIX__onlystar", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "180_1299602538.98" 
    $P2092."add_method"(type_obj, "multi_declarator", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "181_1299602538.98" 
    $P2094."add_method"(type_obj, "!PREFIX__multi_declarator", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "182_1299602538.98" 
    $P2096."add_method"(type_obj, "multi_declarator:sym<multi>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__multi_declarator:sym<multi>"
    $P2098."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "184_1299602538.98" 
    $P2100."add_method"(type_obj, "multi_declarator:sym<proto>", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__multi_declarator:sym<proto>"
    $P2102."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "186_1299602538.98" 
    $P2104."add_method"(type_obj, "multi_declarator:sym<null>", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__multi_declarator:sym<null>"
    $P2106."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "188_1299602538.98" 
    $P2108."add_method"(type_obj, "signature", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__signature"
    $P2110."add_method"(type_obj, "!PREFIX__signature", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "191_1299602538.98" 
    $P2112."add_method"(type_obj, "parameter", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__parameter"
    $P2114."add_method"(type_obj, "!PREFIX__parameter", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "193_1299602538.98" 
    $P2116."add_method"(type_obj, "param_var", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__param_var"
    $P2118."add_method"(type_obj, "!PREFIX__param_var", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "195_1299602538.98" 
    $P2120."add_method"(type_obj, "named_param", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__named_param"
    $P2122."add_method"(type_obj, "!PREFIX__named_param", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "197_1299602538.98" 
    $P2124."add_method"(type_obj, "default_value", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__default_value"
    $P2126."add_method"(type_obj, "!PREFIX__default_value", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "199_1299602538.98" 
    $P2128."add_method"(type_obj, "trait", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__trait"
    $P2130."add_method"(type_obj, "!PREFIX__trait", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "201_1299602538.98" 
    $P2132."add_method"(type_obj, "trait_mod", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "202_1299602538.98" 
    $P2134."add_method"(type_obj, "!PREFIX__trait_mod", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "203_1299602538.98" 
    $P2136."add_method"(type_obj, "trait_mod:sym<is>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__trait_mod:sym<is>"
    $P2138."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "205_1299602538.98" 
    $P2140."add_method"(type_obj, "regex_declarator", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__regex_declarator"
    $P2142."add_method"(type_obj, "!PREFIX__regex_declarator", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "207_1299602538.98" 
    $P2144."add_method"(type_obj, "dotty", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__dotty"
    $P2146."add_method"(type_obj, "!PREFIX__dotty", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "209_1299602538.98" 
    $P2148."add_method"(type_obj, "term", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "210_1299602538.98" 
    $P2150."add_method"(type_obj, "!PREFIX__term", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "211_1299602538.98" 
    $P2152."add_method"(type_obj, "term:sym<self>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__term:sym<self>"
    $P2154."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "213_1299602538.98" 
    $P2156."add_method"(type_obj, "term:sym<identifier>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__term:sym<identifier>"
    $P2158."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "215_1299602538.98" 
    $P2160."add_method"(type_obj, "term:sym<name>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__term:sym<name>"
    $P2162."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "217_1299602538.98" 
    $P2164."add_method"(type_obj, "term:sym<pir::op>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__term:sym<pir::op>"
    $P2166."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "219_1299602538.98" 
    $P2168."add_method"(type_obj, "term:sym<onlystar>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__term:sym<onlystar>"
    $P2170."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "222_1299602538.98" 
    $P2172."add_method"(type_obj, "args", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__args"
    $P2174."add_method"(type_obj, "!PREFIX__args", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "224_1299602538.98" 
    $P2176."add_method"(type_obj, "arglist", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__arglist"
    $P2178."add_method"(type_obj, "!PREFIX__arglist", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "226_1299602538.98" 
    $P2180."add_method"(type_obj, "term:sym<value>", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__term:sym<value>"
    $P2182."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "228_1299602538.98" 
    $P2184."add_method"(type_obj, "value", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__value"
    $P2186."add_method"(type_obj, "!PREFIX__value", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "230_1299602538.98" 
    $P2188."add_method"(type_obj, "number", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__number"
    $P2190."add_method"(type_obj, "!PREFIX__number", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "232_1299602538.98" 
    $P2192."add_method"(type_obj, "quote", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "233_1299602538.98" 
    $P2194."add_method"(type_obj, "!PREFIX__quote", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "234_1299602538.98" 
    $P2196."add_method"(type_obj, "quote:sym<apos>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__quote:sym<apos>"
    $P2198."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "236_1299602538.98" 
    $P2200."add_method"(type_obj, "quote:sym<dblq>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__quote:sym<dblq>"
    $P2202."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "238_1299602538.98" 
    $P2204."add_method"(type_obj, "quote:sym<q>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__quote:sym<q>"
    $P2206."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "240_1299602538.98" 
    $P2208."add_method"(type_obj, "quote:sym<qq>", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__quote:sym<qq>"
    $P2210."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "242_1299602538.98" 
    $P2212."add_method"(type_obj, "quote:sym<Q>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__quote:sym<Q>"
    $P2214."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "244_1299602538.98" 
    $P2216."add_method"(type_obj, "quote:sym<Q:PIR>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__quote:sym<Q:PIR>"
    $P2218."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "246_1299602538.98" 
    $P2220."add_method"(type_obj, "quote:sym</ />", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__quote:sym</ />"
    $P2222."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "248_1299602538.98" 
    $P2224."add_method"(type_obj, "quote_escape:sym<$>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__quote_escape:sym<$>"
    $P2226."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "250_1299602538.98" 
    $P2228."add_method"(type_obj, "quote_escape:sym<{ }>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__quote_escape:sym<{ }>"
    $P2230."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "252_1299602538.98" 
    $P2232."add_method"(type_obj, "quote_escape:sym<esc>", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__quote_escape:sym<esc>"
    $P2234."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "254_1299602538.98" 
    $P2236."add_method"(type_obj, "circumfix:sym<( )>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__circumfix:sym<( )>"
    $P2238."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "256_1299602538.98" 
    $P2240."add_method"(type_obj, "circumfix:sym<[ ]>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__circumfix:sym<[ ]>"
    $P2242."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "258_1299602538.98" 
    $P2244."add_method"(type_obj, "circumfix:sym<ang>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__circumfix:sym<ang>"
    $P2246."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "260_1299602538.98" 
    $P2248."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2250."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "262_1299602538.98" 
    $P2252."add_method"(type_obj, "circumfix:sym<{ }>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__circumfix:sym<{ }>"
    $P2254."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "264_1299602538.98" 
    $P2256."add_method"(type_obj, "circumfix:sym<sigil>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__circumfix:sym<sigil>"
    $P2258."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "266_1299602538.98" 
    $P2260."add_method"(type_obj, "semilist", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__semilist"
    $P2262."add_method"(type_obj, "!PREFIX__semilist", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "269_1299602538.98" 
    $P2264."add_method"(type_obj, "infixish", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__infixish"
    $P2266."add_method"(type_obj, "!PREFIX__infixish", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "271_1299602538.98" 
    $P2268."add_method"(type_obj, "infixstopper", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infixstopper"
    $P2270."add_method"(type_obj, "!PREFIX__infixstopper", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "273_1299602538.98" 
    $P2272."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2274."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "275_1299602538.98" 
    $P2276."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__postcircumfix:sym<{ }>"
    $P2278."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "277_1299602538.98" 
    $P2280."add_method"(type_obj, "postcircumfix:sym<ang>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__postcircumfix:sym<ang>"
    $P2282."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "279_1299602538.98" 
    $P2284."add_method"(type_obj, "postcircumfix:sym<( )>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__postcircumfix:sym<( )>"
    $P2286."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "281_1299602538.98" 
    $P2288."add_method"(type_obj, "postfix:sym<.>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__postfix:sym<.>"
    $P2290."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "283_1299602538.98" 
    $P2292."add_method"(type_obj, "prefix:sym<++>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__prefix:sym<++>"
    $P2294."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "285_1299602538.98" 
    $P2296."add_method"(type_obj, "prefix:sym<-->", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__prefix:sym<-->"
    $P2298."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "287_1299602538.98" 
    $P2300."add_method"(type_obj, "postfix:sym<++>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__postfix:sym<++>"
    $P2302."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "289_1299602538.98" 
    $P2304."add_method"(type_obj, "postfix:sym<-->", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__postfix:sym<-->"
    $P2306."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "291_1299602538.98" 
    $P2308."add_method"(type_obj, "infix:sym<**>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<**>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "293_1299602538.98" 
    $P2312."add_method"(type_obj, "prefix:sym<+>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__prefix:sym<+>"
    $P2314."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "295_1299602538.98" 
    $P2316."add_method"(type_obj, "prefix:sym<~>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__prefix:sym<~>"
    $P2318."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "297_1299602538.98" 
    $P2320."add_method"(type_obj, "prefix:sym<->", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__prefix:sym<->"
    $P2322."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "299_1299602538.98" 
    $P2324."add_method"(type_obj, "prefix:sym<?>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__prefix:sym<?>"
    $P2326."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "301_1299602538.98" 
    $P2328."add_method"(type_obj, "prefix:sym<!>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__prefix:sym<!>"
    $P2330."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "303_1299602538.98" 
    $P2332."add_method"(type_obj, "prefix:sym<|>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__prefix:sym<|>"
    $P2334."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "305_1299602538.98" 
    $P2336."add_method"(type_obj, "infix:sym<*>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<*>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "307_1299602538.98" 
    $P2340."add_method"(type_obj, "infix:sym</>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym</>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "309_1299602538.98" 
    $P2344."add_method"(type_obj, "infix:sym<%>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<%>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "311_1299602538.98" 
    $P2348."add_method"(type_obj, "infix:sym<+&>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<+&>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "313_1299602538.98" 
    $P2352."add_method"(type_obj, "infix:sym<+>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<+>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "315_1299602538.98" 
    $P2356."add_method"(type_obj, "infix:sym<->", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<->"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "317_1299602538.98" 
    $P2360."add_method"(type_obj, "infix:sym<+|>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<+|>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "319_1299602538.98" 
    $P2364."add_method"(type_obj, "infix:sym<+^>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<+^>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "321_1299602538.98" 
    $P2368."add_method"(type_obj, "infix:sym<~>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<~>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "323_1299602538.98" 
    $P2372."add_method"(type_obj, "infix:sym<==>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__infix:sym<==>"
    $P2374."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "325_1299602538.98" 
    $P2376."add_method"(type_obj, "infix:sym<!=>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__infix:sym<!=>"
    $P2378."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "327_1299602538.98" 
    $P2380."add_method"(type_obj, "infix:sym<<=>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__infix:sym<<=>"
    $P2382."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "329_1299602538.98" 
    $P2384."add_method"(type_obj, "infix:sym<>=>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__infix:sym<>=>"
    $P2386."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "331_1299602538.98" 
    $P2388."add_method"(type_obj, "infix:sym<<>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__infix:sym<<>"
    $P2390."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "333_1299602538.98" 
    $P2392."add_method"(type_obj, "infix:sym<>>", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__infix:sym<>>"
    $P2394."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "335_1299602538.98" 
    $P2396."add_method"(type_obj, "infix:sym<eq>", $P2397)
    get_how $P2398, type_obj
    get_global $P2399, "!PREFIX__infix:sym<eq>"
    $P2398."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2399)
    get_how $P2400, type_obj
    .const 'Sub' $P2401 = "337_1299602538.98" 
    $P2400."add_method"(type_obj, "infix:sym<ne>", $P2401)
    get_how $P2402, type_obj
    get_global $P2403, "!PREFIX__infix:sym<ne>"
    $P2402."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2403)
    get_how $P2404, type_obj
    .const 'Sub' $P2405 = "339_1299602538.98" 
    $P2404."add_method"(type_obj, "infix:sym<le>", $P2405)
    get_how $P2406, type_obj
    get_global $P2407, "!PREFIX__infix:sym<le>"
    $P2406."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2407)
    get_how $P2408, type_obj
    .const 'Sub' $P2409 = "341_1299602538.98" 
    $P2408."add_method"(type_obj, "infix:sym<ge>", $P2409)
    get_how $P2410, type_obj
    get_global $P2411, "!PREFIX__infix:sym<ge>"
    $P2410."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2411)
    get_how $P2412, type_obj
    .const 'Sub' $P2413 = "343_1299602538.98" 
    $P2412."add_method"(type_obj, "infix:sym<lt>", $P2413)
    get_how $P2414, type_obj
    get_global $P2415, "!PREFIX__infix:sym<lt>"
    $P2414."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2415)
    get_how $P2416, type_obj
    .const 'Sub' $P2417 = "345_1299602538.98" 
    $P2416."add_method"(type_obj, "infix:sym<gt>", $P2417)
    get_how $P2418, type_obj
    get_global $P2419, "!PREFIX__infix:sym<gt>"
    $P2418."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2419)
    get_how $P2420, type_obj
    .const 'Sub' $P2421 = "347_1299602538.98" 
    $P2420."add_method"(type_obj, "infix:sym<=:=>", $P2421)
    get_how $P2422, type_obj
    get_global $P2423, "!PREFIX__infix:sym<=:=>"
    $P2422."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2423)
    get_how $P2424, type_obj
    .const 'Sub' $P2425 = "349_1299602538.98" 
    $P2424."add_method"(type_obj, "infix:sym<~~>", $P2425)
    get_how $P2426, type_obj
    get_global $P2427, "!PREFIX__infix:sym<~~>"
    $P2426."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2427)
    get_how $P2428, type_obj
    .const 'Sub' $P2429 = "351_1299602538.98" 
    $P2428."add_method"(type_obj, "infix:sym<&&>", $P2429)
    get_how $P2430, type_obj
    get_global $P2431, "!PREFIX__infix:sym<&&>"
    $P2430."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2431)
    get_how $P2432, type_obj
    .const 'Sub' $P2433 = "353_1299602538.98" 
    $P2432."add_method"(type_obj, "infix:sym<||>", $P2433)
    get_how $P2434, type_obj
    get_global $P2435, "!PREFIX__infix:sym<||>"
    $P2434."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2435)
    get_how $P2436, type_obj
    .const 'Sub' $P2437 = "355_1299602538.98" 
    $P2436."add_method"(type_obj, "infix:sym<//>", $P2437)
    get_how $P2438, type_obj
    get_global $P2439, "!PREFIX__infix:sym<//>"
    $P2438."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2439)
    get_how $P2440, type_obj
    .const 'Sub' $P2441 = "357_1299602538.98" 
    $P2440."add_method"(type_obj, "infix:sym<?? !!>", $P2441)
    get_how $P2442, type_obj
    get_global $P2443, "!PREFIX__infix:sym<?? !!>"
    $P2442."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2443)
    get_how $P2444, type_obj
    .const 'Sub' $P2445 = "359_1299602538.98" 
    $P2444."add_method"(type_obj, "infix:sym<=>", $P2445)
    get_how $P2446, type_obj
    get_global $P2447, "!PREFIX__infix:sym<=>"
    $P2446."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2447)
    get_how $P2448, type_obj
    .const 'Sub' $P2449 = "361_1299602538.98" 
    $P2448."add_method"(type_obj, "infix:sym<:=>", $P2449)
    get_how $P2450, type_obj
    get_global $P2451, "!PREFIX__infix:sym<:=>"
    $P2450."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2451)
    get_how $P2452, type_obj
    .const 'Sub' $P2453 = "363_1299602538.98" 
    $P2452."add_method"(type_obj, "infix:sym<::=>", $P2453)
    get_how $P2454, type_obj
    get_global $P2455, "!PREFIX__infix:sym<::=>"
    $P2454."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2455)
    get_how $P2456, type_obj
    .const 'Sub' $P2457 = "365_1299602538.98" 
    $P2456."add_method"(type_obj, "infix:sym<,>", $P2457)
    get_how $P2458, type_obj
    get_global $P2459, "!PREFIX__infix:sym<,>"
    $P2458."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2459)
    get_how $P2460, type_obj
    .const 'Sub' $P2461 = "367_1299602538.98" 
    $P2460."add_method"(type_obj, "prefix:sym<return>", $P2461)
    get_how $P2462, type_obj
    get_global $P2463, "!PREFIX__prefix:sym<return>"
    $P2462."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2463)
    get_how $P2464, type_obj
    .const 'Sub' $P2465 = "370_1299602538.98" 
    $P2464."add_method"(type_obj, "prefix:sym<make>", $P2465)
    get_how $P2466, type_obj
    get_global $P2467, "!PREFIX__prefix:sym<make>"
    $P2466."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2467)
    get_how $P2468, type_obj
    .const 'Sub' $P2469 = "372_1299602538.98" 
    $P2468."add_method"(type_obj, "term:sym<last>", $P2469)
    get_how $P2470, type_obj
    get_global $P2471, "!PREFIX__term:sym<last>"
    $P2470."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2471)
    get_how $P2472, type_obj
    .const 'Sub' $P2473 = "374_1299602538.98" 
    $P2472."add_method"(type_obj, "term:sym<next>", $P2473)
    get_how $P2474, type_obj
    get_global $P2475, "!PREFIX__term:sym<next>"
    $P2474."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2475)
    get_how $P2476, type_obj
    .const 'Sub' $P2477 = "376_1299602538.98" 
    $P2476."add_method"(type_obj, "term:sym<redo>", $P2477)
    get_how $P2478, type_obj
    get_global $P2479, "!PREFIX__term:sym<redo>"
    $P2478."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2479)
    get_how $P2480, type_obj
    .const 'Sub' $P2481 = "378_1299602538.98" 
    $P2480."add_method"(type_obj, "smartmatch", $P2481)
    get_how $P2482, type_obj
    get_hll_global $P2483, ["HLL"], "Grammar"
    $P2482."add_parent"(type_obj, $P2483)
    get_how $P2484, type_obj
    $P2485 = $P2484."compose"(type_obj)
    .return ($P2485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1299602538.98") :outer("11_1299602538.98")
    .param pmc param_25
.annotate 'line', 4
    .lex "self", param_25
.annotate 'line', 6
    $P26 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P26
.annotate 'line', 13
    $P27 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P27
.annotate 'line', 22
    new $P28, "Undef"
    .lex "$*DEFAULT-METAATTR", $P28
.annotate 'line', 23
    $P29 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P29
.annotate 'line', 29
    new $P30, "Undef"
    .lex "$*SC", $P30
.annotate 'line', 33
    new $P31, "Undef"
    .lex "$*SCOPE", $P31
.annotate 'line', 34
    new $P32, "Undef"
    .lex "$*MULTINESS", $P32
.annotate 'line', 35
    new $P33, "Undef"
    .lex "$*INVOCANT_OK", $P33
.annotate 'line', 36
    new $P34, "Undef"
    .lex "$*RETURN_USED", $P34
.annotate 'line', 37
    new $P35, "Undef"
    .lex "$*PACKAGE-SETUP", $P35
.annotate 'line', 4
    find_lex $P36, "%*LANG"
    unless_null $P36, vivify_406
    get_hll_global $P36, "%LANG"
    unless_null $P36, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
  vivify_406:
.annotate 'line', 7
    get_hll_global $P37, ["NQP"], "Regex"
    find_lex $P38, "%*LANG"
    unless_null $P38, vivify_408
    get_hll_global $P38, "%LANG"
    unless_null $P38, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P38
  vivify_408:
    set $P38["Regex"], $P37
.annotate 'line', 8
    get_hll_global $P39, ["NQP"], "RegexActions"
    find_lex $P40, "%*LANG"
    unless_null $P40, vivify_410
    get_hll_global $P40, "%LANG"
    unless_null $P40, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P40
  vivify_410:
    set $P40["Regex-actions"], $P39
.annotate 'line', 9
    get_hll_global $P41, ["NQP"], "Grammar"
    find_lex $P42, "%*LANG"
    unless_null $P42, vivify_412
    get_hll_global $P42, "%LANG"
    unless_null $P42, vivify_413
    die "Contextual %*LANG not found"
  vivify_413:
    store_lex "%*LANG", $P42
  vivify_412:
    set $P42["MAIN"], $P41
.annotate 'line', 10
    get_hll_global $P43, ["NQP"], "Actions"
    find_lex $P44, "%*LANG"
    unless_null $P44, vivify_414
    get_hll_global $P44, "%LANG"
    unless_null $P44, vivify_415
    die "Contextual %*LANG not found"
  vivify_415:
    store_lex "%*LANG", $P44
  vivify_414:
    set $P44["MAIN-actions"], $P43
    find_lex $P45, "%*HOW"
    unless_null $P45, vivify_416
    get_hll_global $P45, "%HOW"
    unless_null $P45, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
  vivify_416:
.annotate 'line', 14
    get_hll_global $P46, "KnowHOW"
    find_lex $P47, "%*HOW"
    unless_null $P47, vivify_418
    get_hll_global $P47, "%HOW"
    unless_null $P47, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P47
  vivify_418:
    set $P47["knowhow"], $P46
.annotate 'line', 15
    get_hll_global $P48, "NQPModuleHOW"
    find_lex $P49, "%*HOW"
    unless_null $P49, vivify_420
    get_hll_global $P49, "%HOW"
    unless_null $P49, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P49
  vivify_420:
    set $P49["module"], $P48
.annotate 'line', 16
    get_hll_global $P50, "NQPClassHOW"
    find_lex $P51, "%*HOW"
    unless_null $P51, vivify_422
    get_hll_global $P51, "%HOW"
    unless_null $P51, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P51
  vivify_422:
    set $P51["class"], $P50
.annotate 'line', 17
    get_hll_global $P52, "NQPClassHOW"
    find_lex $P53, "%*HOW"
    unless_null $P53, vivify_424
    get_hll_global $P53, "%HOW"
    unless_null $P53, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P53
  vivify_424:
    set $P53["grammar"], $P52
.annotate 'line', 18
    get_hll_global $P54, "NQPParametricRoleHOW"
    find_lex $P55, "%*HOW"
    unless_null $P55, vivify_426
    get_hll_global $P55, "%HOW"
    unless_null $P55, vivify_427
    die "Contextual %*HOW not found"
  vivify_427:
    store_lex "%*HOW", $P55
  vivify_426:
    set $P55["role"], $P54
.annotate 'line', 19
    get_hll_global $P56, "NQPNativeHOW"
    find_lex $P57, "%*HOW"
    unless_null $P57, vivify_428
    get_hll_global $P57, "%HOW"
    unless_null $P57, vivify_429
    die "Contextual %*HOW not found"
  vivify_429:
    store_lex "%*HOW", $P57
  vivify_428:
    set $P57["native"], $P56
.annotate 'line', 22
    new $P58, "String"
    assign $P58, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P58
    find_lex $P59, "%*HOW-METAATTR"
    unless_null $P59, vivify_430
    get_hll_global $P59, "%HOW-METAATTR"
    unless_null $P59, vivify_431
    die "Contextual %*HOW-METAATTR not found"
  vivify_431:
  vivify_430:
.annotate 'line', 24
    new $P60, "String"
    assign $P60, "KnowHOWAttribute"
    find_lex $P61, "%*HOW-METAATTR"
    unless_null $P61, vivify_432
    get_hll_global $P61, "%HOW-METAATTR"
    unless_null $P61, vivify_433
    die "Contextual %*HOW-METAATTR not found"
  vivify_433:
    store_lex "%*HOW-METAATTR", $P61
  vivify_432:
    set $P61["knowhow"], $P60
.annotate 'line', 29
    get_hll_global $P62, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 31
    time $N63
    set $S64, $N63
    $P65 = $P62."new"($S64 :named("handle"))
.annotate 'line', 29
    store_lex "$*SC", $P65
.annotate 'line', 33
    new $P66, "String"
    assign $P66, ""
    store_lex "$*SCOPE", $P66
.annotate 'line', 34
    new $P67, "String"
    assign $P67, ""
    store_lex "$*MULTINESS", $P67
.annotate 'line', 35
    new $P68, "Integer"
    assign $P68, 0
    store_lex "$*INVOCANT_OK", $P68
.annotate 'line', 36
    new $P69, "Integer"
    assign $P69, 0
    store_lex "$*RETURN_USED", $P69
    find_lex $P70, "$*PACKAGE-SETUP"
    unless_null $P70, vivify_434
    get_hll_global $P70, "$PACKAGE-SETUP"
    unless_null $P70, vivify_435
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_435:
  vivify_434:
.annotate 'line', 38
    find_lex $P71, "self"
    $P72 = $P71."comp_unit"()
.annotate 'line', 4
    .return ($P72)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx74_tgt
    .local int rx74_pos
    .local int rx74_off
    .local int rx74_eos
    .local int rx74_rep
    .local pmc rx74_cur
    .local pmc rx74_debug
    (rx74_cur, rx74_pos, rx74_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx74_cur
    .local pmc match
    .lex "$/", match
    length rx74_eos, rx74_tgt
    gt rx74_pos, rx74_eos, rx74_done
    set rx74_off, 0
    lt rx74_pos, 2, rx74_start
    sub rx74_off, rx74_pos, 1
    substr rx74_tgt, rx74_tgt, rx74_off
  rx74_start:
    eq $I10, 1, rx74_restart
    if_null rx74_debug, debug_436
    rx74_cur."!cursor_debug"("START", "identifier")
  debug_436:
    $I10 = self.'from'()
    ne $I10, -1, rxscan78_done
    goto rxscan78_scan
  rxscan78_loop:
    (rx74_pos) = rx74_cur."from"()
    inc rx74_pos
    rx74_cur."!cursor_from"(rx74_pos)
    ge rx74_pos, rx74_eos, rxscan78_done
  rxscan78_scan:
    set_addr $I10, rxscan78_loop
    rx74_cur."!mark_push"(0, rx74_pos, $I10)
  rxscan78_done:
.annotate 'line', 43
  # rx subrule "ident" subtype=method negate=
    rx74_cur."!cursor_pos"(rx74_pos)
    $P10 = rx74_cur."ident"()
    unless $P10, rx74_fail
    rx74_pos = $P10."pos"()
  # rx rxquantr79 ** 0..*
    set_addr $I10, rxquantr79_done
    rx74_cur."!mark_push"(0, rx74_pos, $I10)
  rxquantr79_loop:
  # rx enumcharlist negate=0 
    ge rx74_pos, rx74_eos, rx74_fail
    sub $I10, rx74_pos, rx74_off
    substr $S10, rx74_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx74_fail
    inc rx74_pos
  # rx subrule "ident" subtype=method negate=
    rx74_cur."!cursor_pos"(rx74_pos)
    $P10 = rx74_cur."ident"()
    unless $P10, rx74_fail
    rx74_pos = $P10."pos"()
    set_addr $I10, rxquantr79_done
    (rx74_rep) = rx74_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr79_done
    rx74_cur."!mark_push"(rx74_rep, rx74_pos, $I10)
    goto rxquantr79_loop
  rxquantr79_done:
  # rx pass
    rx74_cur."!cursor_pass"(rx74_pos, "identifier")
    if_null rx74_debug, debug_437
    rx74_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx74_pos)
  debug_437:
    .return (rx74_cur)
  rx74_restart:
.annotate 'line', 4
    if_null rx74_debug, debug_438
    rx74_cur."!cursor_debug"("NEXT", "identifier")
  debug_438:
  rx74_fail:
    (rx74_rep, rx74_pos, $I10, $P10) = rx74_cur."!mark_fail"(0)
    lt rx74_pos, -1, rx74_done
    eq rx74_pos, -1, rx74_fail
    jump $I10
  rx74_done:
    rx74_cur."!cursor_fail"()
    if_null rx74_debug, debug_439
    rx74_cur."!cursor_debug"("FAIL", "identifier")
  debug_439:
    .return (rx74_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1299602538.98") :method
.annotate 'line', 4
    $P76 = self."!PREFIX__!subrule"("ident", "")
    new $P77, "ResizablePMCArray"
    push $P77, $P76
    .return ($P77)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx81_tgt
    .local int rx81_pos
    .local int rx81_off
    .local int rx81_eos
    .local int rx81_rep
    .local pmc rx81_cur
    .local pmc rx81_debug
    (rx81_cur, rx81_pos, rx81_tgt, $I10) = self."!cursor_start"()
    rx81_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx81_cur
    .local pmc match
    .lex "$/", match
    length rx81_eos, rx81_tgt
    gt rx81_pos, rx81_eos, rx81_done
    set rx81_off, 0
    lt rx81_pos, 2, rx81_start
    sub rx81_off, rx81_pos, 1
    substr rx81_tgt, rx81_tgt, rx81_off
  rx81_start:
    eq $I10, 1, rx81_restart
    if_null rx81_debug, debug_440
    rx81_cur."!cursor_debug"("START", "name")
  debug_440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan84_done
    goto rxscan84_scan
  rxscan84_loop:
    (rx81_pos) = rx81_cur."from"()
    inc rx81_pos
    rx81_cur."!cursor_from"(rx81_pos)
    ge rx81_pos, rx81_eos, rxscan84_done
  rxscan84_scan:
    set_addr $I10, rxscan84_loop
    rx81_cur."!mark_push"(0, rx81_pos, $I10)
  rxscan84_done:
.annotate 'line', 45
  # rx rxquantr85 ** 1..*
    set_addr $I10, rxquantr85_done
    rx81_cur."!mark_push"(0, -1, $I10)
  rxquantr85_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx81_cur."!cursor_pos"(rx81_pos)
    $P10 = rx81_cur."identifier"()
    unless $P10, rx81_fail
    goto rxsubrule86_pass
  rxsubrule86_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx81_fail
  rxsubrule86_pass:
    set_addr $I10, rxsubrule86_back
    rx81_cur."!mark_push"(0, rx81_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx81_pos = $P10."pos"()
    set_addr $I10, rxquantr85_done
    (rx81_rep) = rx81_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr85_done
    rx81_cur."!mark_push"(rx81_rep, rx81_pos, $I10)
  # rx literal  "::"
    add $I11, rx81_pos, 2
    gt $I11, rx81_eos, rx81_fail
    sub $I11, rx81_pos, rx81_off
    substr $S10, rx81_tgt, $I11, 2
    ne $S10, "::", rx81_fail
    add rx81_pos, 2
    goto rxquantr85_loop
  rxquantr85_done:
  # rx pass
    rx81_cur."!cursor_pass"(rx81_pos, "name")
    if_null rx81_debug, debug_441
    rx81_cur."!cursor_debug"("PASS", "name", " at pos=", rx81_pos)
  debug_441:
    .return (rx81_cur)
  rx81_restart:
.annotate 'line', 4
    if_null rx81_debug, debug_442
    rx81_cur."!cursor_debug"("NEXT", "name")
  debug_442:
  rx81_fail:
    (rx81_rep, rx81_pos, $I10, $P10) = rx81_cur."!mark_fail"(0)
    lt rx81_pos, -1, rx81_done
    eq rx81_pos, -1, rx81_fail
    jump $I10
  rx81_done:
    rx81_cur."!cursor_fail"()
    if_null rx81_debug, debug_443
    rx81_cur."!cursor_debug"("FAIL", "name")
  debug_443:
    .return (rx81_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1299602538.98") :method
.annotate 'line', 4
    new $P83, "ResizablePMCArray"
    push $P83, ""
    .return ($P83)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx88_tgt
    .local int rx88_pos
    .local int rx88_off
    .local int rx88_eos
    .local int rx88_rep
    .local pmc rx88_cur
    .local pmc rx88_debug
    (rx88_cur, rx88_pos, rx88_tgt, $I10) = self."!cursor_start"()
    rx88_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx88_cur
    .local pmc match
    .lex "$/", match
    length rx88_eos, rx88_tgt
    gt rx88_pos, rx88_eos, rx88_done
    set rx88_off, 0
    lt rx88_pos, 2, rx88_start
    sub rx88_off, rx88_pos, 1
    substr rx88_tgt, rx88_tgt, rx88_off
  rx88_start:
    eq $I10, 1, rx88_restart
    if_null rx88_debug, debug_444
    rx88_cur."!cursor_debug"("START", "deflongname")
  debug_444:
    $I10 = self.'from'()
    ne $I10, -1, rxscan92_done
    goto rxscan92_scan
  rxscan92_loop:
    (rx88_pos) = rx88_cur."from"()
    inc rx88_pos
    rx88_cur."!cursor_from"(rx88_pos)
    ge rx88_pos, rx88_eos, rxscan92_done
  rxscan92_scan:
    set_addr $I10, rxscan92_loop
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
  rxscan92_done:
.annotate 'line', 48
  # rx subrule "identifier" subtype=capture negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."identifier"()
    unless $P10, rx88_fail
    rx88_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx88_pos = $P10."pos"()
  # rx rxquantr93 ** 0..1
    set_addr $I10, rxquantr93_done
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
  rxquantr93_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."colonpair"()
    unless $P10, rx88_fail
    goto rxsubrule94_pass
  rxsubrule94_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx88_fail
  rxsubrule94_pass:
    set_addr $I10, rxsubrule94_back
    rx88_cur."!mark_push"(0, rx88_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx88_pos = $P10."pos"()
    set_addr $I10, rxquantr93_done
    (rx88_rep) = rx88_cur."!mark_commit"($I10)
  rxquantr93_done:
.annotate 'line', 47
  # rx pass
    rx88_cur."!cursor_pass"(rx88_pos, "deflongname")
    if_null rx88_debug, debug_445
    rx88_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx88_pos)
  debug_445:
    .return (rx88_cur)
  rx88_restart:
.annotate 'line', 4
    if_null rx88_debug, debug_446
    rx88_cur."!cursor_debug"("NEXT", "deflongname")
  debug_446:
  rx88_fail:
    (rx88_rep, rx88_pos, $I10, $P10) = rx88_cur."!mark_fail"(0)
    lt rx88_pos, -1, rx88_done
    eq rx88_pos, -1, rx88_fail
    jump $I10
  rx88_done:
    rx88_cur."!cursor_fail"()
    if_null rx88_debug, debug_447
    rx88_cur."!cursor_debug"("FAIL", "deflongname")
  debug_447:
    .return (rx88_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1299602538.98") :method
.annotate 'line', 4
    $P90 = self."!PREFIX__!subrule"("identifier", "")
    new $P91, "ResizablePMCArray"
    push $P91, $P90
    .return ($P91)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx96_tgt
    .local int rx96_pos
    .local int rx96_off
    .local int rx96_eos
    .local int rx96_rep
    .local pmc rx96_cur
    .local pmc rx96_debug
    (rx96_cur, rx96_pos, rx96_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx96_cur
    .local pmc match
    .lex "$/", match
    length rx96_eos, rx96_tgt
    gt rx96_pos, rx96_eos, rx96_done
    set rx96_off, 0
    lt rx96_pos, 2, rx96_start
    sub rx96_off, rx96_pos, 1
    substr rx96_tgt, rx96_tgt, rx96_off
  rx96_start:
    eq $I10, 1, rx96_restart
    if_null rx96_debug, debug_448
    rx96_cur."!cursor_debug"("START", "ENDSTMT")
  debug_448:
    $I10 = self.'from'()
    ne $I10, -1, rxscan99_done
    goto rxscan99_scan
  rxscan99_loop:
    (rx96_pos) = rx96_cur."from"()
    inc rx96_pos
    rx96_cur."!cursor_from"(rx96_pos)
    ge rx96_pos, rx96_eos, rxscan99_done
  rxscan99_scan:
    set_addr $I10, rxscan99_loop
    rx96_cur."!mark_push"(0, rx96_pos, $I10)
  rxscan99_done:
.annotate 'line', 55
  # rx rxquantr100 ** 0..1
    set_addr $I10, rxquantr100_done
    rx96_cur."!mark_push"(0, rx96_pos, $I10)
  rxquantr100_loop:
  alt101_0:
.annotate 'line', 52
    set_addr $I10, alt101_1
    rx96_cur."!mark_push"(0, rx96_pos, $I10)
.annotate 'line', 53
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx96_pos, rx96_off
    set rx96_rep, 0
    sub $I12, rx96_eos, rx96_pos
  rxenumcharlistq102_loop:
    le $I12, 0, rxenumcharlistq102_done
    substr $S10, rx96_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq102_done
    inc rx96_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq102_loop
  rxenumcharlistq102_done:
    add rx96_pos, rx96_pos, rx96_rep
  # rxanchor eol
    sub $I10, rx96_pos, rx96_off
    is_cclass $I11, 4096, rx96_tgt, $I10
    if $I11, rxanchor103_done
    ne rx96_pos, rx96_eos, rx96_fail
    eq rx96_pos, 0, rxanchor103_done
    dec $I10
    is_cclass $I11, 4096, rx96_tgt, $I10
    if $I11, rx96_fail
  rxanchor103_done:
  # rx subrule "ws" subtype=method negate=
    rx96_cur."!cursor_pos"(rx96_pos)
    $P10 = rx96_cur."ws"()
    unless $P10, rx96_fail
    rx96_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx96_cur."!cursor_pos"(rx96_pos)
    $P10 = rx96_cur."MARKER"("endstmt")
    unless $P10, rx96_fail
    goto alt101_end
  alt101_1:
.annotate 'line', 54
  # rx rxquantr104 ** 0..1
    set_addr $I10, rxquantr104_done
    rx96_cur."!mark_push"(0, rx96_pos, $I10)
  rxquantr104_loop:
  # rx subrule "unv" subtype=method negate=
    rx96_cur."!cursor_pos"(rx96_pos)
    $P10 = rx96_cur."unv"()
    unless $P10, rx96_fail
    goto rxsubrule105_pass
  rxsubrule105_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx96_fail
  rxsubrule105_pass:
    set_addr $I10, rxsubrule105_back
    rx96_cur."!mark_push"(0, rx96_pos, $I10, $P10)
    rx96_pos = $P10."pos"()
    set_addr $I10, rxquantr104_done
    (rx96_rep) = rx96_cur."!mark_commit"($I10)
  rxquantr104_done:
  # rxanchor eol
    sub $I10, rx96_pos, rx96_off
    is_cclass $I11, 4096, rx96_tgt, $I10
    if $I11, rxanchor106_done
    ne rx96_pos, rx96_eos, rx96_fail
    eq rx96_pos, 0, rxanchor106_done
    dec $I10
    is_cclass $I11, 4096, rx96_tgt, $I10
    if $I11, rx96_fail
  rxanchor106_done:
  # rx subrule "ws" subtype=method negate=
    rx96_cur."!cursor_pos"(rx96_pos)
    $P10 = rx96_cur."ws"()
    unless $P10, rx96_fail
    rx96_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx96_cur."!cursor_pos"(rx96_pos)
    $P10 = rx96_cur."MARKER"("endstmt")
    unless $P10, rx96_fail
  alt101_end:
.annotate 'line', 55
    set_addr $I10, rxquantr100_done
    (rx96_rep) = rx96_cur."!mark_commit"($I10)
  rxquantr100_done:
.annotate 'line', 51
  # rx pass
    rx96_cur."!cursor_pass"(rx96_pos, "ENDSTMT")
    if_null rx96_debug, debug_449
    rx96_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx96_pos)
  debug_449:
    .return (rx96_cur)
  rx96_restart:
.annotate 'line', 4
    if_null rx96_debug, debug_450
    rx96_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_450:
  rx96_fail:
    (rx96_rep, rx96_pos, $I10, $P10) = rx96_cur."!mark_fail"(0)
    lt rx96_pos, -1, rx96_done
    eq rx96_pos, -1, rx96_fail
    jump $I10
  rx96_done:
    rx96_cur."!cursor_fail"()
    if_null rx96_debug, debug_451
    rx96_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_451:
    .return (rx96_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1299602538.98") :method
.annotate 'line', 4
    new $P98, "ResizablePMCArray"
    push $P98, ""
    .return ($P98)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_452
    rx108_cur."!cursor_debug"("START", "ws")
  debug_452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
  alt112_0:
.annotate 'line', 58
    set_addr $I10, alt112_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 59
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKED"("ws")
    unless $P10, rx108_fail
    goto alt112_end
  alt112_1:
.annotate 'line', 60
  # rx subrule "ww" subtype=zerowidth negate=1
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."ww"()
    if $P10, rx108_fail
.annotate 'line', 65
  # rx rxquantr113 ** 0..*
    set_addr $I10, rxquantr113_done
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxquantr113_loop:
  alt114_0:
.annotate 'line', 61
    set_addr $I10, alt114_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq115_loop:
    le $I12, 0, rxenumcharlistq115_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq115_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq115_loop
  rxenumcharlistq115_done:
    lt rx108_rep, 1, rx108_fail
    add rx108_pos, rx108_pos, rx108_rep
    goto alt114_end
  alt114_1:
    set_addr $I10, alt114_2
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 62
  # rx literal  "#"
    add $I11, rx108_pos, 1
    gt $I11, rx108_eos, rx108_fail
    sub $I11, rx108_pos, rx108_off
    ord $I11, rx108_tgt, $I11
    ne $I11, 35, rx108_fail
    add rx108_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx108_pos, rx108_off
    find_cclass $I11, 4096, rx108_tgt, $I10, rx108_eos
    add rx108_pos, rx108_off, $I11
    goto alt114_end
  alt114_2:
    set_addr $I10, alt114_3
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 63
  # rxanchor bol
    eq rx108_pos, 0, rxanchor116_done
    ge rx108_pos, rx108_eos, rx108_fail
    sub $I10, rx108_pos, rx108_off
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    unless $I11, rx108_fail
  rxanchor116_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."pod_comment"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
    goto alt114_end
  alt114_3:
.annotate 'line', 64
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq117_loop:
    le $I12, 0, rxenumcharlistq117_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq117_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq117_loop
  rxenumcharlistq117_done:
    lt rx108_rep, 1, rx108_fail
    add rx108_pos, rx108_pos, rx108_rep
  alt114_end:
.annotate 'line', 65
    set_addr $I10, rxquantr113_done
    (rx108_rep) = rx108_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr113_done
    rx108_cur."!mark_push"(rx108_rep, rx108_pos, $I10)
    goto rxquantr113_loop
  rxquantr113_done:
.annotate 'line', 66
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKER"("ws")
    unless $P10, rx108_fail
  alt112_end:
.annotate 'line', 58
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "ws")
    if_null rx108_debug, debug_453
    rx108_cur."!cursor_debug"("PASS", "ws", " at pos=", rx108_pos)
  debug_453:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 4
    if_null rx108_debug, debug_454
    rx108_cur."!cursor_debug"("NEXT", "ws")
  debug_454:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_455
    rx108_cur."!cursor_debug"("FAIL", "ws")
  debug_455:
    .return (rx108_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1299602538.98") :method
.annotate 'line', 4
    new $P110, "ResizablePMCArray"
    push $P110, ""
    push $P110, ""
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P126 = "25_1299602538.98" 
    capture_lex $P126
    .local string rx119_tgt
    .local int rx119_pos
    .local int rx119_off
    .local int rx119_eos
    .local int rx119_rep
    .local pmc rx119_cur
    .local pmc rx119_debug
    (rx119_cur, rx119_pos, rx119_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx119_cur
    .local pmc match
    .lex "$/", match
    length rx119_eos, rx119_tgt
    gt rx119_pos, rx119_eos, rx119_done
    set rx119_off, 0
    lt rx119_pos, 2, rx119_start
    sub rx119_off, rx119_pos, 1
    substr rx119_tgt, rx119_tgt, rx119_off
  rx119_start:
    eq $I10, 1, rx119_restart
    if_null rx119_debug, debug_456
    rx119_cur."!cursor_debug"("START", "unv")
  debug_456:
    $I10 = self.'from'()
    ne $I10, -1, rxscan122_done
    goto rxscan122_scan
  rxscan122_loop:
    (rx119_pos) = rx119_cur."from"()
    inc rx119_pos
    rx119_cur."!cursor_from"(rx119_pos)
    ge rx119_pos, rx119_eos, rxscan122_done
  rxscan122_scan:
    set_addr $I10, rxscan122_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  rxscan122_done:
  alt123_0:
.annotate 'line', 71
    set_addr $I10, alt123_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 72
  # rxanchor bol
    eq rx119_pos, 0, rxanchor124_done
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    dec $I10
    is_cclass $I11, 4096, rx119_tgt, $I10
    unless $I11, rx119_fail
  rxanchor124_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    .const 'Sub' $P126 = "25_1299602538.98" 
    capture_lex $P126
    $P10 = rx119_cur."before"($P126)
    unless $P10, rx119_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."pod_comment"()
    unless $P10, rx119_fail
    rx119_pos = $P10."pos"()
    goto alt123_end
  alt123_1:
    set_addr $I10, alt123_2
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq131_loop:
    le $I12, 0, rxenumcharlistq131_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq131_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq131_loop
  rxenumcharlistq131_done:
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "#"
    add $I11, rx119_pos, 1
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    ord $I11, rx119_tgt, $I11
    ne $I11, 35, rx119_fail
    add rx119_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx119_pos, rx119_off
    find_cclass $I11, 4096, rx119_tgt, $I10, rx119_eos
    add rx119_pos, rx119_off, $I11
    goto alt123_end
  alt123_2:
.annotate 'line', 74
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq132_loop:
    le $I12, 0, rxenumcharlistq132_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq132_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq132_loop
  rxenumcharlistq132_done:
    lt rx119_rep, 1, rx119_fail
    add rx119_pos, rx119_pos, rx119_rep
  alt123_end:
.annotate 'line', 69
  # rx pass
    rx119_cur."!cursor_pass"(rx119_pos, "unv")
    if_null rx119_debug, debug_461
    rx119_cur."!cursor_debug"("PASS", "unv", " at pos=", rx119_pos)
  debug_461:
    .return (rx119_cur)
  rx119_restart:
.annotate 'line', 4
    if_null rx119_debug, debug_462
    rx119_cur."!cursor_debug"("NEXT", "unv")
  debug_462:
  rx119_fail:
    (rx119_rep, rx119_pos, $I10, $P10) = rx119_cur."!mark_fail"(0)
    lt rx119_pos, -1, rx119_done
    eq rx119_pos, -1, rx119_fail
    jump $I10
  rx119_done:
    rx119_cur."!cursor_fail"()
    if_null rx119_debug, debug_463
    rx119_cur."!cursor_debug"("FAIL", "unv")
  debug_463:
    .return (rx119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1299602538.98") :method
.annotate 'line', 4
    new $P121, "ResizablePMCArray"
    push $P121, ""
    push $P121, ""
    push $P121, ""
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block125"  :anon :subid("25_1299602538.98") :method :outer("23_1299602538.98")
.annotate 'line', 72
    .local string rx127_tgt
    .local int rx127_pos
    .local int rx127_off
    .local int rx127_eos
    .local int rx127_rep
    .local pmc rx127_cur
    .local pmc rx127_debug
    (rx127_cur, rx127_pos, rx127_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx127_cur
    .local pmc match
    .lex "$/", match
    length rx127_eos, rx127_tgt
    gt rx127_pos, rx127_eos, rx127_done
    set rx127_off, 0
    lt rx127_pos, 2, rx127_start
    sub rx127_off, rx127_pos, 1
    substr rx127_tgt, rx127_tgt, rx127_off
  rx127_start:
    eq $I10, 1, rx127_restart
    if_null rx127_debug, debug_457
    rx127_cur."!cursor_debug"("START", "")
  debug_457:
    $I10 = self.'from'()
    ne $I10, -1, rxscan128_done
    goto rxscan128_scan
  rxscan128_loop:
    (rx127_pos) = rx127_cur."from"()
    inc rx127_pos
    rx127_cur."!cursor_from"(rx127_pos)
    ge rx127_pos, rx127_eos, rxscan128_done
  rxscan128_scan:
    set_addr $I10, rxscan128_loop
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  rxscan128_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx127_pos, rx127_off
    set rx127_rep, 0
    sub $I12, rx127_eos, rx127_pos
  rxenumcharlistq129_loop:
    le $I12, 0, rxenumcharlistq129_done
    substr $S10, rx127_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq129_done
    inc rx127_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq129_loop
  rxenumcharlistq129_done:
    add rx127_pos, rx127_pos, rx127_rep
  # rx literal  "="
    add $I11, rx127_pos, 1
    gt $I11, rx127_eos, rx127_fail
    sub $I11, rx127_pos, rx127_off
    ord $I11, rx127_tgt, $I11
    ne $I11, 61, rx127_fail
    add rx127_pos, 1
  alt130_0:
    set_addr $I10, alt130_1
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  # rx charclass w
    ge rx127_pos, rx127_eos, rx127_fail
    sub $I10, rx127_pos, rx127_off
    is_cclass $I11, 8192, rx127_tgt, $I10
    unless $I11, rx127_fail
    inc rx127_pos
    goto alt130_end
  alt130_1:
  # rx literal  "\\"
    add $I11, rx127_pos, 1
    gt $I11, rx127_eos, rx127_fail
    sub $I11, rx127_pos, rx127_off
    ord $I11, rx127_tgt, $I11
    ne $I11, 92, rx127_fail
    add rx127_pos, 1
  alt130_end:
  # rx pass
    rx127_cur."!cursor_pass"(rx127_pos, "")
    if_null rx127_debug, debug_458
    rx127_cur."!cursor_debug"("PASS", "", " at pos=", rx127_pos)
  debug_458:
    .return (rx127_cur)
  rx127_restart:
    if_null rx127_debug, debug_459
    rx127_cur."!cursor_debug"("NEXT", "")
  debug_459:
  rx127_fail:
    (rx127_rep, rx127_pos, $I10, $P10) = rx127_cur."!mark_fail"(0)
    lt rx127_pos, -1, rx127_done
    eq rx127_pos, -1, rx127_fail
    jump $I10
  rx127_done:
    rx127_cur."!cursor_fail"()
    if_null rx127_debug, debug_460
    rx127_cur."!cursor_debug"("FAIL", "")
  debug_460:
    .return (rx127_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P165 = "28_1299602538.98" 
    capture_lex $P165
    .local string rx134_tgt
    .local int rx134_pos
    .local int rx134_off
    .local int rx134_eos
    .local int rx134_rep
    .local pmc rx134_cur
    .local pmc rx134_debug
    (rx134_cur, rx134_pos, rx134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx134_cur
    .local pmc match
    .lex "$/", match
    length rx134_eos, rx134_tgt
    gt rx134_pos, rx134_eos, rx134_done
    set rx134_off, 0
    lt rx134_pos, 2, rx134_start
    sub rx134_off, rx134_pos, 1
    substr rx134_tgt, rx134_tgt, rx134_off
  rx134_start:
    eq $I10, 1, rx134_restart
    if_null rx134_debug, debug_464
    rx134_cur."!cursor_debug"("START", "pod_comment")
  debug_464:
    $I10 = self.'from'()
    ne $I10, -1, rxscan137_done
    goto rxscan137_scan
  rxscan137_loop:
    (rx134_pos) = rx134_cur."from"()
    inc rx134_pos
    rx134_cur."!cursor_from"(rx134_pos)
    ge rx134_pos, rx134_eos, rxscan137_done
  rxscan137_scan:
    set_addr $I10, rxscan137_loop
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
  rxscan137_done:
.annotate 'line', 79
  # rxanchor bol
    eq rx134_pos, 0, rxanchor138_done
    ge rx134_pos, rx134_eos, rx134_fail
    sub $I10, rx134_pos, rx134_off
    dec $I10
    is_cclass $I11, 4096, rx134_tgt, $I10
    unless $I11, rx134_fail
  rxanchor138_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq139_loop:
    le $I12, 0, rxenumcharlistq139_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq139_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq139_loop
  rxenumcharlistq139_done:
    add rx134_pos, rx134_pos, rx134_rep
  # rx literal  "="
    add $I11, rx134_pos, 1
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    ord $I11, rx134_tgt, $I11
    ne $I11, 61, rx134_fail
    add rx134_pos, 1
  alt140_0:
.annotate 'line', 80
    set_addr $I10, alt140_1
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
.annotate 'line', 81
  # rx literal  "begin"
    add $I11, rx134_pos, 5
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 5
    ne $S10, "begin", rx134_fail
    add rx134_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    lt rx134_rep, 1, rx134_fail
    add rx134_pos, rx134_pos, rx134_rep
  # rx literal  "END"
    add $I11, rx134_pos, 3
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 3
    ne $S10, "END", rx134_fail
    add rx134_pos, 3
  # rxanchor rwb
    le rx134_pos, 0, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 8192, rx134_tgt, $I10
    if $I11, rx134_fail
    dec $I10
    is_cclass $I11, 8192, rx134_tgt, $I10
    unless $I11, rx134_fail
  alt142_0:
.annotate 'line', 82
    set_addr $I10, alt142_1
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
  # rx rxquantf143 ** 0..*
    set_addr $I10, rxquantf143_loop
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
    goto rxquantf143_done
  rxquantf143_loop:
  # rx charclass .
    ge rx134_pos, rx134_eos, rx134_fail
    inc rx134_pos
    set_addr $I10, rxquantf143_loop
    rx134_cur."!mark_push"(rx134_rep, rx134_pos, $I10)
  rxquantf143_done:
  # rx charclass nl
    ge rx134_pos, rx134_eos, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 4096, rx134_tgt, $I10
    unless $I11, rx134_fail
    substr $S10, rx134_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx134_pos, $I11
    inc rx134_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq145_loop:
    le $I12, 0, rxenumcharlistq145_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq145_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq145_loop
  rxenumcharlistq145_done:
    add rx134_pos, rx134_pos, rx134_rep
  # rx literal  "=end"
    add $I11, rx134_pos, 4
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 4
    ne $S10, "=end", rx134_fail
    add rx134_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq146_loop:
    le $I12, 0, rxenumcharlistq146_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq146_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq146_loop
  rxenumcharlistq146_done:
    lt rx134_rep, 1, rx134_fail
    add rx134_pos, rx134_pos, rx134_rep
  # rx literal  "END"
    add $I11, rx134_pos, 3
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 3
    ne $S10, "END", rx134_fail
    add rx134_pos, 3
  # rxanchor rwb
    le rx134_pos, 0, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 8192, rx134_tgt, $I10
    if $I11, rx134_fail
    dec $I10
    is_cclass $I11, 8192, rx134_tgt, $I10
    unless $I11, rx134_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx134_pos, rx134_off
    find_cclass $I11, 4096, rx134_tgt, $I10, rx134_eos
    add rx134_pos, rx134_off, $I11
    goto alt142_end
  alt142_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx134_pos, rx134_off
    find_not_cclass $I11, 65535, rx134_tgt, $I10, rx134_eos
    add rx134_pos, rx134_off, $I11
  alt142_end:
.annotate 'line', 81
    goto alt140_end
  alt140_1:
    set_addr $I10, alt140_2
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
.annotate 'line', 83
  # rx literal  "begin"
    add $I11, rx134_pos, 5
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 5
    ne $S10, "begin", rx134_fail
    add rx134_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq147_loop:
    le $I12, 0, rxenumcharlistq147_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq147_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq147_loop
  rxenumcharlistq147_done:
    lt rx134_rep, 1, rx134_fail
    add rx134_pos, rx134_pos, rx134_rep
  # rx subrule "identifier" subtype=capture negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    $P10 = rx134_cur."identifier"()
    unless $P10, rx134_fail
    rx134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx134_pos = $P10."pos"()
  alt148_0:
.annotate 'line', 84
    set_addr $I10, alt148_1
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
.annotate 'line', 85
  # rx rxquantf149 ** 0..*
    set_addr $I10, rxquantf149_loop
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
    goto rxquantf149_done
  rxquantf149_loop:
  # rx charclass .
    ge rx134_pos, rx134_eos, rx134_fail
    inc rx134_pos
    set_addr $I10, rxquantf149_loop
    rx134_cur."!mark_push"(rx134_rep, rx134_pos, $I10)
  rxquantf149_done:
  # rx charclass nl
    ge rx134_pos, rx134_eos, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 4096, rx134_tgt, $I10
    unless $I11, rx134_fail
    substr $S10, rx134_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx134_pos, $I11
    inc rx134_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq151_loop:
    le $I12, 0, rxenumcharlistq151_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq151_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq151_loop
  rxenumcharlistq151_done:
    add rx134_pos, rx134_pos, rx134_rep
  # rx literal  "=end"
    add $I11, rx134_pos, 4
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 4
    ne $S10, "=end", rx134_fail
    add rx134_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq152_loop:
    le $I12, 0, rxenumcharlistq152_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq152_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq152_loop
  rxenumcharlistq152_done:
    lt rx134_rep, 1, rx134_fail
    add rx134_pos, rx134_pos, rx134_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    $P10 = rx134_cur."!BACKREF"("identifier")
    unless $P10, rx134_fail
    rx134_pos = $P10."pos"()
  # rxanchor rwb
    le rx134_pos, 0, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 8192, rx134_tgt, $I10
    if $I11, rx134_fail
    dec $I10
    is_cclass $I11, 8192, rx134_tgt, $I10
    unless $I11, rx134_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx134_pos, rx134_off
    find_cclass $I11, 4096, rx134_tgt, $I10, rx134_eos
    add rx134_pos, rx134_off, $I11
    goto alt148_end
  alt148_1:
.annotate 'line', 86
  # rx subrule "panic" subtype=method negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    $P10 = rx134_cur."panic"("=begin without matching =end")
    unless $P10, rx134_fail
    rx134_pos = $P10."pos"()
  alt148_end:
.annotate 'line', 83
    goto alt140_end
  alt140_2:
    set_addr $I10, alt140_3
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
.annotate 'line', 88
  # rx literal  "begin"
    add $I11, rx134_pos, 5
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 5
    ne $S10, "begin", rx134_fail
    add rx134_pos, 5
  # rxanchor rwb
    le rx134_pos, 0, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 8192, rx134_tgt, $I10
    if $I11, rx134_fail
    dec $I10
    is_cclass $I11, 8192, rx134_tgt, $I10
    unless $I11, rx134_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq154_loop:
    le $I12, 0, rxenumcharlistq154_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq154_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq154_loop
  rxenumcharlistq154_done:
    add rx134_pos, rx134_pos, rx134_rep
  alt155_0:
.annotate 'line', 89
    set_addr $I10, alt155_1
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
  # rxanchor eol
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 4096, rx134_tgt, $I10
    if $I11, rxanchor156_done
    ne rx134_pos, rx134_eos, rx134_fail
    eq rx134_pos, 0, rxanchor156_done
    dec $I10
    is_cclass $I11, 4096, rx134_tgt, $I10
    if $I11, rx134_fail
  rxanchor156_done:
    goto alt155_end
  alt155_1:
    set_addr $I10, alt155_2
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
  # rx literal  "#"
    add $I11, rx134_pos, 1
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    ord $I11, rx134_tgt, $I11
    ne $I11, 35, rx134_fail
    add rx134_pos, 1
    goto alt155_end
  alt155_2:
  # rx subrule "panic" subtype=method negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    $P10 = rx134_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx134_fail
    rx134_pos = $P10."pos"()
  alt155_end:
  alt157_0:
.annotate 'line', 90
    set_addr $I10, alt157_1
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
.annotate 'line', 91
  # rx rxquantf158 ** 0..*
    set_addr $I10, rxquantf158_loop
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
    goto rxquantf158_done
  rxquantf158_loop:
  # rx charclass .
    ge rx134_pos, rx134_eos, rx134_fail
    inc rx134_pos
    set_addr $I10, rxquantf158_loop
    rx134_cur."!mark_push"(rx134_rep, rx134_pos, $I10)
  rxquantf158_done:
  # rx charclass nl
    ge rx134_pos, rx134_eos, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 4096, rx134_tgt, $I10
    unless $I11, rx134_fail
    substr $S10, rx134_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx134_pos, $I11
    inc rx134_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx134_pos, rx134_off
    set rx134_rep, 0
    sub $I12, rx134_eos, rx134_pos
  rxenumcharlistq160_loop:
    le $I12, 0, rxenumcharlistq160_done
    substr $S10, rx134_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq160_done
    inc rx134_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq160_loop
  rxenumcharlistq160_done:
    add rx134_pos, rx134_pos, rx134_rep
  # rx literal  "=end"
    add $I11, rx134_pos, 4
    gt $I11, rx134_eos, rx134_fail
    sub $I11, rx134_pos, rx134_off
    substr $S10, rx134_tgt, $I11, 4
    ne $S10, "=end", rx134_fail
    add rx134_pos, 4
  # rxanchor rwb
    le rx134_pos, 0, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 8192, rx134_tgt, $I10
    if $I11, rx134_fail
    dec $I10
    is_cclass $I11, 8192, rx134_tgt, $I10
    unless $I11, rx134_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx134_pos, rx134_off
    find_cclass $I11, 4096, rx134_tgt, $I10, rx134_eos
    add rx134_pos, rx134_off, $I11
    goto alt157_end
  alt157_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    $P10 = rx134_cur."panic"("=begin without matching =end")
    unless $P10, rx134_fail
    rx134_pos = $P10."pos"()
  alt157_end:
.annotate 'line', 88
    goto alt140_end
  alt140_3:
    set_addr $I10, alt140_4
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
.annotate 'line', 94
  # rx subrule "identifier" subtype=capture negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    $P10 = rx134_cur."identifier"()
    unless $P10, rx134_fail
    rx134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx134_pos = $P10."pos"()
.annotate 'line', 95
  # rx rxquantf161 ** 0..*
    set_addr $I10, rxquantf161_loop
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
    goto rxquantf161_done
  rxquantf161_loop:
  # rx charclass .
    ge rx134_pos, rx134_eos, rx134_fail
    inc rx134_pos
    set_addr $I10, rxquantf161_loop
    rx134_cur."!mark_push"(rx134_rep, rx134_pos, $I10)
  rxquantf161_done:
  # rxanchor bol
    eq rx134_pos, 0, rxanchor163_done
    ge rx134_pos, rx134_eos, rx134_fail
    sub $I10, rx134_pos, rx134_off
    dec $I10
    is_cclass $I11, 4096, rx134_tgt, $I10
    unless $I11, rx134_fail
  rxanchor163_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    .const 'Sub' $P165 = "28_1299602538.98" 
    capture_lex $P165
    $P10 = rx134_cur."before"($P165)
    unless $P10, rx134_fail
.annotate 'line', 94
    goto alt140_end
  alt140_4:
  alt171_0:
.annotate 'line', 101
    set_addr $I10, alt171_1
    rx134_cur."!mark_push"(0, rx134_pos, $I10)
  # rx charclass s
    ge rx134_pos, rx134_eos, rx134_fail
    sub $I10, rx134_pos, rx134_off
    is_cclass $I11, 32, rx134_tgt, $I10
    unless $I11, rx134_fail
    inc rx134_pos
    goto alt171_end
  alt171_1:
  # rx subrule "panic" subtype=method negate=
    rx134_cur."!cursor_pos"(rx134_pos)
    $P10 = rx134_cur."panic"("Illegal pod directive")
    unless $P10, rx134_fail
    rx134_pos = $P10."pos"()
  alt171_end:
.annotate 'line', 102
  # rx charclass_q N r 0..-1
    sub $I10, rx134_pos, rx134_off
    find_cclass $I11, 4096, rx134_tgt, $I10, rx134_eos
    add rx134_pos, rx134_off, $I11
  alt140_end:
.annotate 'line', 78
  # rx pass
    rx134_cur."!cursor_pass"(rx134_pos, "pod_comment")
    if_null rx134_debug, debug_469
    rx134_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx134_pos)
  debug_469:
    .return (rx134_cur)
  rx134_restart:
.annotate 'line', 4
    if_null rx134_debug, debug_470
    rx134_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_470:
  rx134_fail:
    (rx134_rep, rx134_pos, $I10, $P10) = rx134_cur."!mark_fail"(0)
    lt rx134_pos, -1, rx134_done
    eq rx134_pos, -1, rx134_fail
    jump $I10
  rx134_done:
    rx134_cur."!cursor_fail"()
    if_null rx134_debug, debug_471
    rx134_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_471:
    .return (rx134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1299602538.98") :method
.annotate 'line', 4
    new $P136, "ResizablePMCArray"
    push $P136, ""
    .return ($P136)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block164"  :anon :subid("28_1299602538.98") :method :outer("26_1299602538.98")
.annotate 'line', 95
    .local string rx166_tgt
    .local int rx166_pos
    .local int rx166_off
    .local int rx166_eos
    .local int rx166_rep
    .local pmc rx166_cur
    .local pmc rx166_debug
    (rx166_cur, rx166_pos, rx166_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx166_cur
    .local pmc match
    .lex "$/", match
    length rx166_eos, rx166_tgt
    gt rx166_pos, rx166_eos, rx166_done
    set rx166_off, 0
    lt rx166_pos, 2, rx166_start
    sub rx166_off, rx166_pos, 1
    substr rx166_tgt, rx166_tgt, rx166_off
  rx166_start:
    eq $I10, 1, rx166_restart
    if_null rx166_debug, debug_465
    rx166_cur."!cursor_debug"("START", "")
  debug_465:
    $I10 = self.'from'()
    ne $I10, -1, rxscan167_done
    goto rxscan167_scan
  rxscan167_loop:
    (rx166_pos) = rx166_cur."from"()
    inc rx166_pos
    rx166_cur."!cursor_from"(rx166_pos)
    ge rx166_pos, rx166_eos, rxscan167_done
  rxscan167_scan:
    set_addr $I10, rxscan167_loop
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
  rxscan167_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq168_loop:
    le $I12, 0, rxenumcharlistq168_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq168_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq168_loop
  rxenumcharlistq168_done:
    add rx166_pos, rx166_pos, rx166_rep
  alt169_0:
    set_addr $I10, alt169_1
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
.annotate 'line', 96
  # rx literal  "="
    add $I11, rx166_pos, 1
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    ord $I11, rx166_tgt, $I11
    ne $I11, 61, rx166_fail
    add rx166_pos, 1
.annotate 'line', 98
  # rx rxquantr170 ** 0..1
    set_addr $I10, rxquantr170_done
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
  rxquantr170_loop:
.annotate 'line', 97
  # rx literal  "cut"
    add $I11, rx166_pos, 3
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 3
    ne $S10, "cut", rx166_fail
    add rx166_pos, 3
  # rxanchor rwb
    le rx166_pos, 0, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 8192, rx166_tgt, $I10
    if $I11, rx166_fail
    dec $I10
    is_cclass $I11, 8192, rx166_tgt, $I10
    unless $I11, rx166_fail
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx166_fail
    rx166_pos = $P10."pos"()
    set_addr $I10, rxquantr170_done
    (rx166_rep) = rx166_cur."!mark_commit"($I10)
  rxquantr170_done:
.annotate 'line', 95
    goto alt169_end
  alt169_1:
.annotate 'line', 99
  # rx charclass nl
    ge rx166_pos, rx166_eos, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 4096, rx166_tgt, $I10
    unless $I11, rx166_fail
    substr $S10, rx166_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx166_pos, $I11
    inc rx166_pos
  alt169_end:
.annotate 'line', 95
  # rx pass
    rx166_cur."!cursor_pass"(rx166_pos, "")
    if_null rx166_debug, debug_466
    rx166_cur."!cursor_debug"("PASS", "", " at pos=", rx166_pos)
  debug_466:
    .return (rx166_cur)
  rx166_restart:
    if_null rx166_debug, debug_467
    rx166_cur."!cursor_debug"("NEXT", "")
  debug_467:
  rx166_fail:
    (rx166_rep, rx166_pos, $I10, $P10) = rx166_cur."!mark_fail"(0)
    lt rx166_pos, -1, rx166_done
    eq rx166_pos, -1, rx166_fail
    jump $I10
  rx166_done:
    rx166_cur."!cursor_fail"()
    if_null rx166_debug, debug_468
    rx166_cur."!cursor_debug"("FAIL", "")
  debug_468:
    .return (rx166_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 110
    new $P173, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P173
.annotate 'line', 4
    .local string rx174_tgt
    .local int rx174_pos
    .local int rx174_off
    .local int rx174_eos
    .local int rx174_rep
    .local pmc rx174_cur
    .local pmc rx174_debug
    (rx174_cur, rx174_pos, rx174_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx174_cur
    .local pmc match
    .lex "$/", match
    length rx174_eos, rx174_tgt
    gt rx174_pos, rx174_eos, rx174_done
    set rx174_off, 0
    lt rx174_pos, 2, rx174_start
    sub rx174_off, rx174_pos, 1
    substr rx174_tgt, rx174_tgt, rx174_off
  rx174_start:
    eq $I10, 1, rx174_restart
    if_null rx174_debug, debug_472
    rx174_cur."!cursor_debug"("START", "comp_unit")
  debug_472:
    $I10 = self.'from'()
    ne $I10, -1, rxscan178_done
    goto rxscan178_scan
  rxscan178_loop:
    (rx174_pos) = rx174_cur."from"()
    inc rx174_pos
    rx174_cur."!cursor_from"(rx174_pos)
    ge rx174_pos, rx174_eos, rxscan178_done
  rxscan178_scan:
    set_addr $I10, rxscan178_loop
    rx174_cur."!mark_push"(0, rx174_pos, $I10)
  rxscan178_done:
.annotate 'line', 110
    rx174_cur."!cursor_pos"(rx174_pos)
    new $P179, "Integer"
    assign $P179, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P179
.annotate 'line', 111
  # rx subrule "newpad" subtype=method negate=
    rx174_cur."!cursor_pos"(rx174_pos)
    $P10 = rx174_cur."newpad"()
    unless $P10, rx174_fail
    rx174_pos = $P10."pos"()
.annotate 'line', 112
  # rx subrule "outerctx" subtype=method negate=
    rx174_cur."!cursor_pos"(rx174_pos)
    $P10 = rx174_cur."outerctx"()
    unless $P10, rx174_fail
    rx174_pos = $P10."pos"()
.annotate 'line', 113
  # rx subrule "statementlist" subtype=capture negate=
    rx174_cur."!cursor_pos"(rx174_pos)
    $P10 = rx174_cur."statementlist"()
    unless $P10, rx174_fail
    rx174_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx174_pos = $P10."pos"()
  alt180_0:
.annotate 'line', 114
    set_addr $I10, alt180_1
    rx174_cur."!mark_push"(0, rx174_pos, $I10)
  # rxanchor eos
    ne rx174_pos, rx174_eos, rx174_fail
    goto alt180_end
  alt180_1:
  # rx subrule "panic" subtype=method negate=
    rx174_cur."!cursor_pos"(rx174_pos)
    $P10 = rx174_cur."panic"("Confused")
    unless $P10, rx174_fail
    rx174_pos = $P10."pos"()
  alt180_end:
.annotate 'line', 109
  # rx pass
    rx174_cur."!cursor_pass"(rx174_pos, "comp_unit")
    if_null rx174_debug, debug_473
    rx174_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx174_pos)
  debug_473:
    .return (rx174_cur)
  rx174_restart:
.annotate 'line', 4
    if_null rx174_debug, debug_474
    rx174_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_474:
  rx174_fail:
    (rx174_rep, rx174_pos, $I10, $P10) = rx174_cur."!mark_fail"(0)
    lt rx174_pos, -1, rx174_done
    eq rx174_pos, -1, rx174_fail
    jump $I10
  rx174_done:
    rx174_cur."!cursor_fail"()
    if_null rx174_debug, debug_475
    rx174_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_475:
    .return (rx174_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1299602538.98") :method
.annotate 'line', 4
    $P176 = self."!PREFIX__!subrule"("newpad", "")
    new $P177, "ResizablePMCArray"
    push $P177, $P176
    .return ($P177)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx182_tgt
    .local int rx182_pos
    .local int rx182_off
    .local int rx182_eos
    .local int rx182_rep
    .local pmc rx182_cur
    .local pmc rx182_debug
    (rx182_cur, rx182_pos, rx182_tgt, $I10) = self."!cursor_start"()
    rx182_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx182_cur
    .local pmc match
    .lex "$/", match
    length rx182_eos, rx182_tgt
    gt rx182_pos, rx182_eos, rx182_done
    set rx182_off, 0
    lt rx182_pos, 2, rx182_start
    sub rx182_off, rx182_pos, 1
    substr rx182_tgt, rx182_tgt, rx182_off
  rx182_start:
    eq $I10, 1, rx182_restart
    if_null rx182_debug, debug_476
    rx182_cur."!cursor_debug"("START", "statementlist")
  debug_476:
    $I10 = self.'from'()
    ne $I10, -1, rxscan187_done
    goto rxscan187_scan
  rxscan187_loop:
    (rx182_pos) = rx182_cur."from"()
    inc rx182_pos
    rx182_cur."!cursor_from"(rx182_pos)
    ge rx182_pos, rx182_eos, rxscan187_done
  rxscan187_scan:
    set_addr $I10, rxscan187_loop
    rx182_cur."!mark_push"(0, rx182_pos, $I10)
  rxscan187_done:
  alt188_0:
.annotate 'line', 117
    set_addr $I10, alt188_1
    rx182_cur."!mark_push"(0, rx182_pos, $I10)
.annotate 'line', 118
  # rx subrule "ws" subtype=method negate=
    rx182_cur."!cursor_pos"(rx182_pos)
    $P10 = rx182_cur."ws"()
    unless $P10, rx182_fail
    rx182_pos = $P10."pos"()
  # rxanchor eos
    ne rx182_pos, rx182_eos, rx182_fail
  # rx subrule "ws" subtype=method negate=
    rx182_cur."!cursor_pos"(rx182_pos)
    $P10 = rx182_cur."ws"()
    unless $P10, rx182_fail
    rx182_pos = $P10."pos"()
    goto alt188_end
  alt188_1:
.annotate 'line', 119
  # rx subrule "ws" subtype=method negate=
    rx182_cur."!cursor_pos"(rx182_pos)
    $P10 = rx182_cur."ws"()
    unless $P10, rx182_fail
    rx182_pos = $P10."pos"()
  # rx rxquantr192 ** 0..*
    set_addr $I10, rxquantr192_done
    rx182_cur."!mark_push"(0, rx182_pos, $I10)
  rxquantr192_loop:
  # rx subrule "statement" subtype=capture negate=
    rx182_cur."!cursor_pos"(rx182_pos)
    $P10 = rx182_cur."statement"()
    unless $P10, rx182_fail
    rx182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx182_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx182_cur."!cursor_pos"(rx182_pos)
    $P10 = rx182_cur."eat_terminator"()
    unless $P10, rx182_fail
    rx182_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx182_cur."!cursor_pos"(rx182_pos)
    $P10 = rx182_cur."ws"()
    unless $P10, rx182_fail
    rx182_pos = $P10."pos"()
    set_addr $I10, rxquantr192_done
    (rx182_rep) = rx182_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr192_done
    rx182_cur."!mark_push"(rx182_rep, rx182_pos, $I10)
    goto rxquantr192_loop
  rxquantr192_done:
  # rx subrule "ws" subtype=method negate=
    rx182_cur."!cursor_pos"(rx182_pos)
    $P10 = rx182_cur."ws"()
    unless $P10, rx182_fail
    rx182_pos = $P10."pos"()
  alt188_end:
.annotate 'line', 117
  # rx pass
    rx182_cur."!cursor_pass"(rx182_pos, "statementlist")
    if_null rx182_debug, debug_477
    rx182_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx182_pos)
  debug_477:
    .return (rx182_cur)
  rx182_restart:
.annotate 'line', 4
    if_null rx182_debug, debug_478
    rx182_cur."!cursor_debug"("NEXT", "statementlist")
  debug_478:
  rx182_fail:
    (rx182_rep, rx182_pos, $I10, $P10) = rx182_cur."!mark_fail"(0)
    lt rx182_pos, -1, rx182_done
    eq rx182_pos, -1, rx182_fail
    jump $I10
  rx182_done:
    rx182_cur."!cursor_fail"()
    if_null rx182_debug, debug_479
    rx182_cur."!cursor_debug"("FAIL", "statementlist")
  debug_479:
    .return (rx182_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1299602538.98") :method
.annotate 'line', 4
    $P184 = self."!PREFIX__!subrule"("ws", "")
    $P185 = self."!PREFIX__!subrule"("ws", "")
    new $P186, "ResizablePMCArray"
    push $P186, $P184
    push $P186, $P185
    .return ($P186)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P201 = "35_1299602538.98" 
    capture_lex $P201
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    rx196_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_480
    rx196_cur."!cursor_debug"("START", "statement")
  debug_480:
    $I10 = self.'from'()
    ne $I10, -1, rxscan199_done
    goto rxscan199_scan
  rxscan199_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan199_done
  rxscan199_scan:
    set_addr $I10, rxscan199_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan199_done:
.annotate 'line', 123
  # rx subrule "before" subtype=zerowidth negate=1
    rx196_cur."!cursor_pos"(rx196_pos)
    .const 'Sub' $P201 = "35_1299602538.98" 
    capture_lex $P201
    $P10 = rx196_cur."before"($P201)
    if $P10, rx196_fail
  alt205_0:
.annotate 'line', 124
    set_addr $I10, alt205_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 125
  # rx subrule "statement_control" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."statement_control"()
    unless $P10, rx196_fail
    rx196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx196_pos = $P10."pos"()
    goto alt205_end
  alt205_1:
.annotate 'line', 126
  # rx subrule "EXPR" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."EXPR"()
    unless $P10, rx196_fail
    rx196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx196_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
.annotate 'line', 131
  # rx rxquantr206 ** 0..1
    set_addr $I10, rxquantr206_done
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxquantr206_loop:
  alt207_0:
.annotate 'line', 127
    set_addr $I10, alt207_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 128
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."MARKED"("endstmt")
    unless $P10, rx196_fail
    goto alt207_end
  alt207_1:
    set_addr $I10, alt207_2
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 129
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."statement_mod_cond"()
    unless $P10, rx196_fail
    rx196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx196_pos = $P10."pos"()
  # rx rxquantr208 ** 0..1
    set_addr $I10, rxquantr208_done
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxquantr208_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."statement_mod_loop"()
    unless $P10, rx196_fail
    goto rxsubrule209_pass
  rxsubrule209_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx196_fail
  rxsubrule209_pass:
    set_addr $I10, rxsubrule209_back
    rx196_cur."!mark_push"(0, rx196_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx196_pos = $P10."pos"()
    set_addr $I10, rxquantr208_done
    (rx196_rep) = rx196_cur."!mark_commit"($I10)
  rxquantr208_done:
    goto alt207_end
  alt207_2:
.annotate 'line', 130
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."statement_mod_loop"()
    unless $P10, rx196_fail
    rx196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx196_pos = $P10."pos"()
  alt207_end:
.annotate 'line', 131
    set_addr $I10, rxquantr206_done
    (rx196_rep) = rx196_cur."!mark_commit"($I10)
  rxquantr206_done:
  alt205_end:
.annotate 'line', 122
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "statement")
    if_null rx196_debug, debug_485
    rx196_cur."!cursor_debug"("PASS", "statement", " at pos=", rx196_pos)
  debug_485:
    .return (rx196_cur)
  rx196_restart:
.annotate 'line', 4
    if_null rx196_debug, debug_486
    rx196_cur."!cursor_debug"("NEXT", "statement")
  debug_486:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_487
    rx196_cur."!cursor_debug"("FAIL", "statement")
  debug_487:
    .return (rx196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1299602538.98") :method
.annotate 'line', 4
    new $P198, "ResizablePMCArray"
    push $P198, ""
    .return ($P198)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block200"  :anon :subid("35_1299602538.98") :method :outer("33_1299602538.98")
.annotate 'line', 123
    .local string rx202_tgt
    .local int rx202_pos
    .local int rx202_off
    .local int rx202_eos
    .local int rx202_rep
    .local pmc rx202_cur
    .local pmc rx202_debug
    (rx202_cur, rx202_pos, rx202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx202_cur
    .local pmc match
    .lex "$/", match
    length rx202_eos, rx202_tgt
    gt rx202_pos, rx202_eos, rx202_done
    set rx202_off, 0
    lt rx202_pos, 2, rx202_start
    sub rx202_off, rx202_pos, 1
    substr rx202_tgt, rx202_tgt, rx202_off
  rx202_start:
    eq $I10, 1, rx202_restart
    if_null rx202_debug, debug_481
    rx202_cur."!cursor_debug"("START", "")
  debug_481:
    $I10 = self.'from'()
    ne $I10, -1, rxscan203_done
    goto rxscan203_scan
  rxscan203_loop:
    (rx202_pos) = rx202_cur."from"()
    inc rx202_pos
    rx202_cur."!cursor_from"(rx202_pos)
    ge rx202_pos, rx202_eos, rxscan203_done
  rxscan203_scan:
    set_addr $I10, rxscan203_loop
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxscan203_done:
  alt204_0:
    set_addr $I10, alt204_1
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx202_pos, rx202_eos, rx202_fail
    sub $I10, rx202_pos, rx202_off
    substr $S10, rx202_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx202_fail
    inc rx202_pos
    goto alt204_end
  alt204_1:
  # rxanchor eos
    ne rx202_pos, rx202_eos, rx202_fail
  alt204_end:
  # rx pass
    rx202_cur."!cursor_pass"(rx202_pos, "")
    if_null rx202_debug, debug_482
    rx202_cur."!cursor_debug"("PASS", "", " at pos=", rx202_pos)
  debug_482:
    .return (rx202_cur)
  rx202_restart:
    if_null rx202_debug, debug_483
    rx202_cur."!cursor_debug"("NEXT", "")
  debug_483:
  rx202_fail:
    (rx202_rep, rx202_pos, $I10, $P10) = rx202_cur."!mark_fail"(0)
    lt rx202_pos, -1, rx202_done
    eq rx202_pos, -1, rx202_fail
    jump $I10
  rx202_done:
    rx202_cur."!cursor_fail"()
    if_null rx202_debug, debug_484
    rx202_cur."!cursor_debug"("FAIL", "")
  debug_484:
    .return (rx202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx211_tgt
    .local int rx211_pos
    .local int rx211_off
    .local int rx211_eos
    .local int rx211_rep
    .local pmc rx211_cur
    .local pmc rx211_debug
    (rx211_cur, rx211_pos, rx211_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx211_cur
    .local pmc match
    .lex "$/", match
    length rx211_eos, rx211_tgt
    gt rx211_pos, rx211_eos, rx211_done
    set rx211_off, 0
    lt rx211_pos, 2, rx211_start
    sub rx211_off, rx211_pos, 1
    substr rx211_tgt, rx211_tgt, rx211_off
  rx211_start:
    eq $I10, 1, rx211_restart
    if_null rx211_debug, debug_488
    rx211_cur."!cursor_debug"("START", "eat_terminator")
  debug_488:
    $I10 = self.'from'()
    ne $I10, -1, rxscan214_done
    goto rxscan214_scan
  rxscan214_loop:
    (rx211_pos) = rx211_cur."from"()
    inc rx211_pos
    rx211_cur."!cursor_from"(rx211_pos)
    ge rx211_pos, rx211_eos, rxscan214_done
  rxscan214_scan:
    set_addr $I10, rxscan214_loop
    rx211_cur."!mark_push"(0, rx211_pos, $I10)
  rxscan214_done:
  alt215_0:
.annotate 'line', 135
    set_addr $I10, alt215_1
    rx211_cur."!mark_push"(0, rx211_pos, $I10)
.annotate 'line', 136
  # rx literal  ";"
    add $I11, rx211_pos, 1
    gt $I11, rx211_eos, rx211_fail
    sub $I11, rx211_pos, rx211_off
    ord $I11, rx211_tgt, $I11
    ne $I11, 59, rx211_fail
    add rx211_pos, 1
    goto alt215_end
  alt215_1:
    set_addr $I10, alt215_2
    rx211_cur."!mark_push"(0, rx211_pos, $I10)
.annotate 'line', 137
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx211_cur."!cursor_pos"(rx211_pos)
    $P10 = rx211_cur."MARKED"("endstmt")
    unless $P10, rx211_fail
    goto alt215_end
  alt215_2:
    set_addr $I10, alt215_3
    rx211_cur."!mark_push"(0, rx211_pos, $I10)
.annotate 'line', 138
  # rx subrule "terminator" subtype=zerowidth negate=
    rx211_cur."!cursor_pos"(rx211_pos)
    $P10 = rx211_cur."terminator"()
    unless $P10, rx211_fail
    goto alt215_end
  alt215_3:
.annotate 'line', 139
  # rxanchor eos
    ne rx211_pos, rx211_eos, rx211_fail
  alt215_end:
.annotate 'line', 135
  # rx pass
    rx211_cur."!cursor_pass"(rx211_pos, "eat_terminator")
    if_null rx211_debug, debug_489
    rx211_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx211_pos)
  debug_489:
    .return (rx211_cur)
  rx211_restart:
.annotate 'line', 4
    if_null rx211_debug, debug_490
    rx211_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_490:
  rx211_fail:
    (rx211_rep, rx211_pos, $I10, $P10) = rx211_cur."!mark_fail"(0)
    lt rx211_pos, -1, rx211_done
    eq rx211_pos, -1, rx211_fail
    jump $I10
  rx211_done:
    rx211_cur."!cursor_fail"()
    if_null rx211_debug, debug_491
    rx211_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_491:
    .return (rx211_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1299602538.98") :method
.annotate 'line', 4
    new $P213, "ResizablePMCArray"
    push $P213, ""
    push $P213, ""
    push $P213, ""
    push $P213, ";"
    .return ($P213)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx217_tgt
    .local int rx217_pos
    .local int rx217_off
    .local int rx217_eos
    .local int rx217_rep
    .local pmc rx217_cur
    .local pmc rx217_debug
    (rx217_cur, rx217_pos, rx217_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx217_cur
    .local pmc match
    .lex "$/", match
    length rx217_eos, rx217_tgt
    gt rx217_pos, rx217_eos, rx217_done
    set rx217_off, 0
    lt rx217_pos, 2, rx217_start
    sub rx217_off, rx217_pos, 1
    substr rx217_tgt, rx217_tgt, rx217_off
  rx217_start:
    eq $I10, 1, rx217_restart
    if_null rx217_debug, debug_492
    rx217_cur."!cursor_debug"("START", "xblock")
  debug_492:
    $I10 = self.'from'()
    ne $I10, -1, rxscan221_done
    goto rxscan221_scan
  rxscan221_loop:
    (rx217_pos) = rx217_cur."from"()
    inc rx217_pos
    rx217_cur."!cursor_from"(rx217_pos)
    ge rx217_pos, rx217_eos, rxscan221_done
  rxscan221_scan:
    set_addr $I10, rxscan221_loop
    rx217_cur."!mark_push"(0, rx217_pos, $I10)
  rxscan221_done:
.annotate 'line', 143
  # rx subrule "EXPR" subtype=capture negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."EXPR"()
    unless $P10, rx217_fail
    rx217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx217_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."ws"()
    unless $P10, rx217_fail
    rx217_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."pblock"()
    unless $P10, rx217_fail
    rx217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx217_pos = $P10."pos"()
.annotate 'line', 142
  # rx pass
    rx217_cur."!cursor_pass"(rx217_pos, "xblock")
    if_null rx217_debug, debug_493
    rx217_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx217_pos)
  debug_493:
    .return (rx217_cur)
  rx217_restart:
.annotate 'line', 4
    if_null rx217_debug, debug_494
    rx217_cur."!cursor_debug"("NEXT", "xblock")
  debug_494:
  rx217_fail:
    (rx217_rep, rx217_pos, $I10, $P10) = rx217_cur."!mark_fail"(0)
    lt rx217_pos, -1, rx217_done
    eq rx217_pos, -1, rx217_fail
    jump $I10
  rx217_done:
    rx217_cur."!cursor_fail"()
    if_null rx217_debug, debug_495
    rx217_cur."!cursor_debug"("FAIL", "xblock")
  debug_495:
    .return (rx217_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1299602538.98") :method
.annotate 'line', 4
    $P219 = self."!PREFIX__!subrule"("EXPR", "")
    new $P220, "ResizablePMCArray"
    push $P220, $P219
    .return ($P220)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx223_tgt
    .local int rx223_pos
    .local int rx223_off
    .local int rx223_eos
    .local int rx223_rep
    .local pmc rx223_cur
    .local pmc rx223_debug
    (rx223_cur, rx223_pos, rx223_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx223_cur
    .local pmc match
    .lex "$/", match
    length rx223_eos, rx223_tgt
    gt rx223_pos, rx223_eos, rx223_done
    set rx223_off, 0
    lt rx223_pos, 2, rx223_start
    sub rx223_off, rx223_pos, 1
    substr rx223_tgt, rx223_tgt, rx223_off
  rx223_start:
    eq $I10, 1, rx223_restart
    if_null rx223_debug, debug_496
    rx223_cur."!cursor_debug"("START", "pblock")
  debug_496:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx223_pos) = rx223_cur."from"()
    inc rx223_pos
    rx223_cur."!cursor_from"(rx223_pos)
    ge rx223_pos, rx223_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 146
    set_addr $I10, alt229_1
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
.annotate 'line', 147
  # rx subrule "lambda" subtype=method negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."lambda"()
    unless $P10, rx223_fail
    rx223_pos = $P10."pos"()
.annotate 'line', 148
  # rx subrule "newpad" subtype=method negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."newpad"()
    unless $P10, rx223_fail
    rx223_pos = $P10."pos"()
.annotate 'line', 149
  # rx subrule "signature" subtype=capture negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."signature"()
    unless $P10, rx223_fail
    rx223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx223_pos = $P10."pos"()
.annotate 'line', 150
  # rx subrule "blockoid" subtype=capture negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."blockoid"()
    unless $P10, rx223_fail
    rx223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx223_pos = $P10."pos"()
.annotate 'line', 147
    goto alt229_end
  alt229_1:
    set_addr $I10, alt229_2
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
.annotate 'line', 151
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx223_pos, rx223_off
    substr $S10, rx223_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx223_fail
.annotate 'line', 152
  # rx subrule "newpad" subtype=method negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."newpad"()
    unless $P10, rx223_fail
    rx223_pos = $P10."pos"()
.annotate 'line', 153
  # rx subrule "blockoid" subtype=capture negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."blockoid"()
    unless $P10, rx223_fail
    rx223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx223_pos = $P10."pos"()
.annotate 'line', 151
    goto alt229_end
  alt229_2:
.annotate 'line', 154
  # rx subrule "panic" subtype=method negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."panic"("Missing block")
    unless $P10, rx223_fail
    rx223_pos = $P10."pos"()
  alt229_end:
.annotate 'line', 146
  # rx pass
    rx223_cur."!cursor_pass"(rx223_pos, "pblock")
    if_null rx223_debug, debug_497
    rx223_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx223_pos)
  debug_497:
    .return (rx223_cur)
  rx223_restart:
.annotate 'line', 4
    if_null rx223_debug, debug_498
    rx223_cur."!cursor_debug"("NEXT", "pblock")
  debug_498:
  rx223_fail:
    (rx223_rep, rx223_pos, $I10, $P10) = rx223_cur."!mark_fail"(0)
    lt rx223_pos, -1, rx223_done
    eq rx223_pos, -1, rx223_fail
    jump $I10
  rx223_done:
    rx223_cur."!cursor_fail"()
    if_null rx223_debug, debug_499
    rx223_cur."!cursor_debug"("FAIL", "pblock")
  debug_499:
    .return (rx223_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1299602538.98") :method
.annotate 'line', 4
    $P225 = self."!PREFIX__!subrule"("panic", "")
    $P226 = self."!PREFIX__!subrule"("lambda", "")
    new $P227, "ResizablePMCArray"
    push $P227, $P225
    push $P227, "{"
    push $P227, $P226
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_500
    rx231_cur."!cursor_debug"("START", "lambda")
  debug_500:
    $I10 = self.'from'()
    ne $I10, -1, rxscan234_done
    goto rxscan234_scan
  rxscan234_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan234_done
  rxscan234_scan:
    set_addr $I10, rxscan234_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan234_done:
  alt235_0:
.annotate 'line', 157
    set_addr $I10, alt235_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  # rx literal  "->"
    add $I11, rx231_pos, 2
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    substr $S10, rx231_tgt, $I11, 2
    ne $S10, "->", rx231_fail
    add rx231_pos, 2
    goto alt235_end
  alt235_1:
  # rx literal  "<->"
    add $I11, rx231_pos, 3
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    substr $S10, rx231_tgt, $I11, 3
    ne $S10, "<->", rx231_fail
    add rx231_pos, 3
  alt235_end:
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "lambda")
    if_null rx231_debug, debug_501
    rx231_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx231_pos)
  debug_501:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 4
    if_null rx231_debug, debug_502
    rx231_cur."!cursor_debug"("NEXT", "lambda")
  debug_502:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_503
    rx231_cur."!cursor_debug"("FAIL", "lambda")
  debug_503:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1299602538.98") :method
.annotate 'line', 4
    new $P233, "ResizablePMCArray"
    push $P233, "<->"
    push $P233, "->"
    .return ($P233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx237_tgt
    .local int rx237_pos
    .local int rx237_off
    .local int rx237_eos
    .local int rx237_rep
    .local pmc rx237_cur
    .local pmc rx237_debug
    (rx237_cur, rx237_pos, rx237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx237_cur
    .local pmc match
    .lex "$/", match
    length rx237_eos, rx237_tgt
    gt rx237_pos, rx237_eos, rx237_done
    set rx237_off, 0
    lt rx237_pos, 2, rx237_start
    sub rx237_off, rx237_pos, 1
    substr rx237_tgt, rx237_tgt, rx237_off
  rx237_start:
    eq $I10, 1, rx237_restart
    if_null rx237_debug, debug_504
    rx237_cur."!cursor_debug"("START", "block")
  debug_504:
    $I10 = self.'from'()
    ne $I10, -1, rxscan241_done
    goto rxscan241_scan
  rxscan241_loop:
    (rx237_pos) = rx237_cur."from"()
    inc rx237_pos
    rx237_cur."!cursor_from"(rx237_pos)
    ge rx237_pos, rx237_eos, rxscan241_done
  rxscan241_scan:
    set_addr $I10, rxscan241_loop
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
  rxscan241_done:
  alt242_0:
.annotate 'line', 160
    set_addr $I10, alt242_1
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx237_pos, rx237_off
    substr $S10, rx237_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx237_fail
    goto alt242_end
  alt242_1:
  # rx subrule "panic" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."panic"("Missing block")
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
  alt242_end:
.annotate 'line', 161
  # rx subrule "newpad" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."newpad"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."blockoid"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx237_pos = $P10."pos"()
.annotate 'line', 159
  # rx pass
    rx237_cur."!cursor_pass"(rx237_pos, "block")
    if_null rx237_debug, debug_505
    rx237_cur."!cursor_debug"("PASS", "block", " at pos=", rx237_pos)
  debug_505:
    .return (rx237_cur)
  rx237_restart:
.annotate 'line', 4
    if_null rx237_debug, debug_506
    rx237_cur."!cursor_debug"("NEXT", "block")
  debug_506:
  rx237_fail:
    (rx237_rep, rx237_pos, $I10, $P10) = rx237_cur."!mark_fail"(0)
    lt rx237_pos, -1, rx237_done
    eq rx237_pos, -1, rx237_fail
    jump $I10
  rx237_done:
    rx237_cur."!cursor_fail"()
    if_null rx237_debug, debug_507
    rx237_cur."!cursor_debug"("FAIL", "block")
  debug_507:
    .return (rx237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1299602538.98") :method
.annotate 'line', 4
    $P239 = self."!PREFIX__!subrule"("panic", "")
    new $P240, "ResizablePMCArray"
    push $P240, $P239
    push $P240, "{"
    .return ($P240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx244_tgt
    .local int rx244_pos
    .local int rx244_off
    .local int rx244_eos
    .local int rx244_rep
    .local pmc rx244_cur
    .local pmc rx244_debug
    (rx244_cur, rx244_pos, rx244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx244_cur
    .local pmc match
    .lex "$/", match
    length rx244_eos, rx244_tgt
    gt rx244_pos, rx244_eos, rx244_done
    set rx244_off, 0
    lt rx244_pos, 2, rx244_start
    sub rx244_off, rx244_pos, 1
    substr rx244_tgt, rx244_tgt, rx244_off
  rx244_start:
    eq $I10, 1, rx244_restart
    if_null rx244_debug, debug_508
    rx244_cur."!cursor_debug"("START", "blockoid")
  debug_508:
    $I10 = self.'from'()
    ne $I10, -1, rxscan248_done
    goto rxscan248_scan
  rxscan248_loop:
    (rx244_pos) = rx244_cur."from"()
    inc rx244_pos
    rx244_cur."!cursor_from"(rx244_pos)
    ge rx244_pos, rx244_eos, rxscan248_done
  rxscan248_scan:
    set_addr $I10, rxscan248_loop
    rx244_cur."!mark_push"(0, rx244_pos, $I10)
  rxscan248_done:
.annotate 'line', 166
  # rx subrule "finishpad" subtype=method negate=
    rx244_cur."!cursor_pos"(rx244_pos)
    $P10 = rx244_cur."finishpad"()
    unless $P10, rx244_fail
    rx244_pos = $P10."pos"()
  alt249_0:
.annotate 'line', 167
    set_addr $I10, alt249_1
    rx244_cur."!mark_push"(0, rx244_pos, $I10)
.annotate 'line', 168
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx244_pos, 14
    gt $I11, rx244_eos, rx244_fail
    sub $I11, rx244_pos, rx244_off
    substr $S10, rx244_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx244_fail
    add rx244_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx244_cur."!cursor_pos"(rx244_pos)
    $P10 = rx244_cur."you_are_here"()
    unless $P10, rx244_fail
    rx244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx244_pos = $P10."pos"()
    goto alt249_end
  alt249_1:
.annotate 'line', 169
  # rx literal  "{"
    add $I11, rx244_pos, 1
    gt $I11, rx244_eos, rx244_fail
    sub $I11, rx244_pos, rx244_off
    ord $I11, rx244_tgt, $I11
    ne $I11, 123, rx244_fail
    add rx244_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx244_cur."!cursor_pos"(rx244_pos)
    $P10 = rx244_cur."statementlist"()
    unless $P10, rx244_fail
    rx244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx244_pos = $P10."pos"()
  alt250_0:
    set_addr $I10, alt250_1
    rx244_cur."!mark_push"(0, rx244_pos, $I10)
  # rx literal  "}"
    add $I11, rx244_pos, 1
    gt $I11, rx244_eos, rx244_fail
    sub $I11, rx244_pos, rx244_off
    ord $I11, rx244_tgt, $I11
    ne $I11, 125, rx244_fail
    add rx244_pos, 1
    goto alt250_end
  alt250_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx244_cur."!cursor_pos"(rx244_pos)
    $P10 = rx244_cur."FAILGOAL"("'}'")
    unless $P10, rx244_fail
    goto rxsubrule252_pass
  rxsubrule252_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx244_fail
  rxsubrule252_pass:
    set_addr $I10, rxsubrule252_back
    rx244_cur."!mark_push"(0, rx244_pos, $I10, $P10)
    rx244_pos = $P10."pos"()
  alt250_end:
  alt249_end:
.annotate 'line', 171
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx244_cur."!cursor_pos"(rx244_pos)
    $P10 = rx244_cur."ENDSTMT"()
    unless $P10, rx244_fail
.annotate 'line', 165
  # rx pass
    rx244_cur."!cursor_pass"(rx244_pos, "blockoid")
    if_null rx244_debug, debug_509
    rx244_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx244_pos)
  debug_509:
    .return (rx244_cur)
  rx244_restart:
.annotate 'line', 4
    if_null rx244_debug, debug_510
    rx244_cur."!cursor_debug"("NEXT", "blockoid")
  debug_510:
  rx244_fail:
    (rx244_rep, rx244_pos, $I10, $P10) = rx244_cur."!mark_fail"(0)
    lt rx244_pos, -1, rx244_done
    eq rx244_pos, -1, rx244_fail
    jump $I10
  rx244_done:
    rx244_cur."!cursor_fail"()
    if_null rx244_debug, debug_511
    rx244_cur."!cursor_debug"("FAIL", "blockoid")
  debug_511:
    .return (rx244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1299602538.98") :method
.annotate 'line', 4
    $P246 = self."!PREFIX__!subrule"("finishpad", "")
    new $P247, "ResizablePMCArray"
    push $P247, $P246
    .return ($P247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx254_tgt
    .local int rx254_pos
    .local int rx254_off
    .local int rx254_eos
    .local int rx254_rep
    .local pmc rx254_cur
    .local pmc rx254_debug
    (rx254_cur, rx254_pos, rx254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx254_cur
    .local pmc match
    .lex "$/", match
    length rx254_eos, rx254_tgt
    gt rx254_pos, rx254_eos, rx254_done
    set rx254_off, 0
    lt rx254_pos, 2, rx254_start
    sub rx254_off, rx254_pos, 1
    substr rx254_tgt, rx254_tgt, rx254_off
  rx254_start:
    eq $I10, 1, rx254_restart
    if_null rx254_debug, debug_512
    rx254_cur."!cursor_debug"("START", "newpad")
  debug_512:
    $I10 = self.'from'()
    ne $I10, -1, rxscan257_done
    goto rxscan257_scan
  rxscan257_loop:
    (rx254_pos) = rx254_cur."from"()
    inc rx254_pos
    rx254_cur."!cursor_from"(rx254_pos)
    ge rx254_pos, rx254_eos, rxscan257_done
  rxscan257_scan:
    set_addr $I10, rxscan257_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  rxscan257_done:
.annotate 'line', 174
  # rx pass
    rx254_cur."!cursor_pass"(rx254_pos, "newpad")
    if_null rx254_debug, debug_513
    rx254_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx254_pos)
  debug_513:
    .return (rx254_cur)
  rx254_restart:
.annotate 'line', 4
    if_null rx254_debug, debug_514
    rx254_cur."!cursor_debug"("NEXT", "newpad")
  debug_514:
  rx254_fail:
    (rx254_rep, rx254_pos, $I10, $P10) = rx254_cur."!mark_fail"(0)
    lt rx254_pos, -1, rx254_done
    eq rx254_pos, -1, rx254_fail
    jump $I10
  rx254_done:
    rx254_cur."!cursor_fail"()
    if_null rx254_debug, debug_515
    rx254_cur."!cursor_debug"("FAIL", "newpad")
  debug_515:
    .return (rx254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1299602538.98") :method
.annotate 'line', 4
    new $P256, "ResizablePMCArray"
    push $P256, ""
    .return ($P256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx259_tgt
    .local int rx259_pos
    .local int rx259_off
    .local int rx259_eos
    .local int rx259_rep
    .local pmc rx259_cur
    .local pmc rx259_debug
    (rx259_cur, rx259_pos, rx259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx259_cur
    .local pmc match
    .lex "$/", match
    length rx259_eos, rx259_tgt
    gt rx259_pos, rx259_eos, rx259_done
    set rx259_off, 0
    lt rx259_pos, 2, rx259_start
    sub rx259_off, rx259_pos, 1
    substr rx259_tgt, rx259_tgt, rx259_off
  rx259_start:
    eq $I10, 1, rx259_restart
    if_null rx259_debug, debug_516
    rx259_cur."!cursor_debug"("START", "outerctx")
  debug_516:
    $I10 = self.'from'()
    ne $I10, -1, rxscan262_done
    goto rxscan262_scan
  rxscan262_loop:
    (rx259_pos) = rx259_cur."from"()
    inc rx259_pos
    rx259_cur."!cursor_from"(rx259_pos)
    ge rx259_pos, rx259_eos, rxscan262_done
  rxscan262_scan:
    set_addr $I10, rxscan262_loop
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
  rxscan262_done:
.annotate 'line', 175
  # rx pass
    rx259_cur."!cursor_pass"(rx259_pos, "outerctx")
    if_null rx259_debug, debug_517
    rx259_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx259_pos)
  debug_517:
    .return (rx259_cur)
  rx259_restart:
.annotate 'line', 4
    if_null rx259_debug, debug_518
    rx259_cur."!cursor_debug"("NEXT", "outerctx")
  debug_518:
  rx259_fail:
    (rx259_rep, rx259_pos, $I10, $P10) = rx259_cur."!mark_fail"(0)
    lt rx259_pos, -1, rx259_done
    eq rx259_pos, -1, rx259_fail
    jump $I10
  rx259_done:
    rx259_cur."!cursor_fail"()
    if_null rx259_debug, debug_519
    rx259_cur."!cursor_debug"("FAIL", "outerctx")
  debug_519:
    .return (rx259_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1299602538.98") :method
.annotate 'line', 4
    new $P261, "ResizablePMCArray"
    push $P261, ""
    .return ($P261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx264_tgt
    .local int rx264_pos
    .local int rx264_off
    .local int rx264_eos
    .local int rx264_rep
    .local pmc rx264_cur
    .local pmc rx264_debug
    (rx264_cur, rx264_pos, rx264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx264_cur
    .local pmc match
    .lex "$/", match
    length rx264_eos, rx264_tgt
    gt rx264_pos, rx264_eos, rx264_done
    set rx264_off, 0
    lt rx264_pos, 2, rx264_start
    sub rx264_off, rx264_pos, 1
    substr rx264_tgt, rx264_tgt, rx264_off
  rx264_start:
    eq $I10, 1, rx264_restart
    if_null rx264_debug, debug_520
    rx264_cur."!cursor_debug"("START", "finishpad")
  debug_520:
    $I10 = self.'from'()
    ne $I10, -1, rxscan267_done
    goto rxscan267_scan
  rxscan267_loop:
    (rx264_pos) = rx264_cur."from"()
    inc rx264_pos
    rx264_cur."!cursor_from"(rx264_pos)
    ge rx264_pos, rx264_eos, rxscan267_done
  rxscan267_scan:
    set_addr $I10, rxscan267_loop
    rx264_cur."!mark_push"(0, rx264_pos, $I10)
  rxscan267_done:
.annotate 'line', 176
  # rx pass
    rx264_cur."!cursor_pass"(rx264_pos, "finishpad")
    if_null rx264_debug, debug_521
    rx264_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx264_pos)
  debug_521:
    .return (rx264_cur)
  rx264_restart:
.annotate 'line', 4
    if_null rx264_debug, debug_522
    rx264_cur."!cursor_debug"("NEXT", "finishpad")
  debug_522:
  rx264_fail:
    (rx264_rep, rx264_pos, $I10, $P10) = rx264_cur."!mark_fail"(0)
    lt rx264_pos, -1, rx264_done
    eq rx264_pos, -1, rx264_fail
    jump $I10
  rx264_done:
    rx264_cur."!cursor_fail"()
    if_null rx264_debug, debug_523
    rx264_cur."!cursor_debug"("FAIL", "finishpad")
  debug_523:
    .return (rx264_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1299602538.98") :method
.annotate 'line', 4
    new $P266, "ResizablePMCArray"
    push $P266, ""
    .return ($P266)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("54_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx269_tgt
    .local int rx269_pos
    .local int rx269_off
    .local int rx269_eos
    .local int rx269_rep
    .local pmc rx269_cur
    .local pmc rx269_debug
    (rx269_cur, rx269_pos, rx269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx269_cur
    .local pmc match
    .lex "$/", match
    length rx269_eos, rx269_tgt
    gt rx269_pos, rx269_eos, rx269_done
    set rx269_off, 0
    lt rx269_pos, 2, rx269_start
    sub rx269_off, rx269_pos, 1
    substr rx269_tgt, rx269_tgt, rx269_off
  rx269_start:
    eq $I10, 1, rx269_restart
    if_null rx269_debug, debug_524
    rx269_cur."!cursor_debug"("START", "you_are_here")
  debug_524:
    $I10 = self.'from'()
    ne $I10, -1, rxscan272_done
    goto rxscan272_scan
  rxscan272_loop:
    (rx269_pos) = rx269_cur."from"()
    inc rx269_pos
    rx269_cur."!cursor_from"(rx269_pos)
    ge rx269_pos, rx269_eos, rxscan272_done
  rxscan272_scan:
    set_addr $I10, rxscan272_loop
    rx269_cur."!mark_push"(0, rx269_pos, $I10)
  rxscan272_done:
.annotate 'line', 177
  # rx pass
    rx269_cur."!cursor_pass"(rx269_pos, "you_are_here")
    if_null rx269_debug, debug_525
    rx269_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx269_pos)
  debug_525:
    .return (rx269_cur)
  rx269_restart:
.annotate 'line', 4
    if_null rx269_debug, debug_526
    rx269_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_526:
  rx269_fail:
    (rx269_rep, rx269_pos, $I10, $P10) = rx269_cur."!mark_fail"(0)
    lt rx269_pos, -1, rx269_done
    eq rx269_pos, -1, rx269_fail
    jump $I10
  rx269_done:
    rx269_cur."!cursor_fail"()
    if_null rx269_debug, debug_527
    rx269_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_527:
    .return (rx269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("55_1299602538.98") :method
.annotate 'line', 4
    new $P271, "ResizablePMCArray"
    push $P271, ""
    .return ($P271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("56_1299602538.98")
    .param pmc param_274
.annotate 'line', 179
    .lex "self", param_274
    $P275 = param_274."!protoregex"("terminator")
    .return ($P275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("57_1299602538.98")
    .param pmc param_277
.annotate 'line', 179
    .lex "self", param_277
    $P278 = param_277."!PREFIX__!protoregex"("terminator")
    .return ($P278)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("58_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx280_tgt
    .local int rx280_pos
    .local int rx280_off
    .local int rx280_eos
    .local int rx280_rep
    .local pmc rx280_cur
    .local pmc rx280_debug
    (rx280_cur, rx280_pos, rx280_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx280_cur
    .local pmc match
    .lex "$/", match
    length rx280_eos, rx280_tgt
    gt rx280_pos, rx280_eos, rx280_done
    set rx280_off, 0
    lt rx280_pos, 2, rx280_start
    sub rx280_off, rx280_pos, 1
    substr rx280_tgt, rx280_tgt, rx280_off
  rx280_start:
    eq $I10, 1, rx280_restart
    if_null rx280_debug, debug_528
    rx280_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_528:
    $I10 = self.'from'()
    ne $I10, -1, rxscan283_done
    goto rxscan283_scan
  rxscan283_loop:
    (rx280_pos) = rx280_cur."from"()
    inc rx280_pos
    rx280_cur."!cursor_from"(rx280_pos)
    ge rx280_pos, rx280_eos, rxscan283_done
  rxscan283_scan:
    set_addr $I10, rxscan283_loop
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
  rxscan283_done:
.annotate 'line', 181
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx280_pos, rx280_off
    substr $S10, rx280_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx280_fail
  # rx pass
    rx280_cur."!cursor_pass"(rx280_pos, "terminator:sym<;>")
    if_null rx280_debug, debug_529
    rx280_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx280_pos)
  debug_529:
    .return (rx280_cur)
  rx280_restart:
.annotate 'line', 4
    if_null rx280_debug, debug_530
    rx280_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_530:
  rx280_fail:
    (rx280_rep, rx280_pos, $I10, $P10) = rx280_cur."!mark_fail"(0)
    lt rx280_pos, -1, rx280_done
    eq rx280_pos, -1, rx280_fail
    jump $I10
  rx280_done:
    rx280_cur."!cursor_fail"()
    if_null rx280_debug, debug_531
    rx280_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_531:
    .return (rx280_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("59_1299602538.98") :method
.annotate 'line', 4
    new $P282, "ResizablePMCArray"
    push $P282, ";"
    .return ($P282)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("60_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx285_tgt
    .local int rx285_pos
    .local int rx285_off
    .local int rx285_eos
    .local int rx285_rep
    .local pmc rx285_cur
    .local pmc rx285_debug
    (rx285_cur, rx285_pos, rx285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx285_cur
    .local pmc match
    .lex "$/", match
    length rx285_eos, rx285_tgt
    gt rx285_pos, rx285_eos, rx285_done
    set rx285_off, 0
    lt rx285_pos, 2, rx285_start
    sub rx285_off, rx285_pos, 1
    substr rx285_tgt, rx285_tgt, rx285_off
  rx285_start:
    eq $I10, 1, rx285_restart
    if_null rx285_debug, debug_532
    rx285_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_532:
    $I10 = self.'from'()
    ne $I10, -1, rxscan288_done
    goto rxscan288_scan
  rxscan288_loop:
    (rx285_pos) = rx285_cur."from"()
    inc rx285_pos
    rx285_cur."!cursor_from"(rx285_pos)
    ge rx285_pos, rx285_eos, rxscan288_done
  rxscan288_scan:
    set_addr $I10, rxscan288_loop
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  rxscan288_done:
.annotate 'line', 182
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx285_pos, rx285_off
    substr $S10, rx285_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx285_fail
  # rx pass
    rx285_cur."!cursor_pass"(rx285_pos, "terminator:sym<}>")
    if_null rx285_debug, debug_533
    rx285_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx285_pos)
  debug_533:
    .return (rx285_cur)
  rx285_restart:
.annotate 'line', 4
    if_null rx285_debug, debug_534
    rx285_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_534:
  rx285_fail:
    (rx285_rep, rx285_pos, $I10, $P10) = rx285_cur."!mark_fail"(0)
    lt rx285_pos, -1, rx285_done
    eq rx285_pos, -1, rx285_fail
    jump $I10
  rx285_done:
    rx285_cur."!cursor_fail"()
    if_null rx285_debug, debug_535
    rx285_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_535:
    .return (rx285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("61_1299602538.98") :method
.annotate 'line', 4
    new $P287, "ResizablePMCArray"
    push $P287, "}"
    .return ($P287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("62_1299602538.98")
    .param pmc param_290
.annotate 'line', 186
    .lex "self", param_290
    $P291 = param_290."!protoregex"("statement_control")
    .return ($P291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("63_1299602538.98")
    .param pmc param_293
.annotate 'line', 186
    .lex "self", param_293
    $P294 = param_293."!PREFIX__!protoregex"("statement_control")
    .return ($P294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("64_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx296_tgt
    .local int rx296_pos
    .local int rx296_off
    .local int rx296_eos
    .local int rx296_rep
    .local pmc rx296_cur
    .local pmc rx296_debug
    (rx296_cur, rx296_pos, rx296_tgt, $I10) = self."!cursor_start"()
    rx296_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx296_cur
    .local pmc match
    .lex "$/", match
    length rx296_eos, rx296_tgt
    gt rx296_pos, rx296_eos, rx296_done
    set rx296_off, 0
    lt rx296_pos, 2, rx296_start
    sub rx296_off, rx296_pos, 1
    substr rx296_tgt, rx296_tgt, rx296_off
  rx296_start:
    eq $I10, 1, rx296_restart
    if_null rx296_debug, debug_536
    rx296_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_536:
    $I10 = self.'from'()
    ne $I10, -1, rxscan299_done
    goto rxscan299_scan
  rxscan299_loop:
    (rx296_pos) = rx296_cur."from"()
    inc rx296_pos
    rx296_cur."!cursor_from"(rx296_pos)
    ge rx296_pos, rx296_eos, rxscan299_done
  rxscan299_scan:
    set_addr $I10, rxscan299_loop
    rx296_cur."!mark_push"(0, rx296_pos, $I10)
  rxscan299_done:
.annotate 'line', 189
  # rx subcapture "sym"
    set_addr $I10, rxcap_300_fail
    rx296_cur."!mark_push"(0, rx296_pos, $I10)
  # rx literal  "if"
    add $I11, rx296_pos, 2
    gt $I11, rx296_eos, rx296_fail
    sub $I11, rx296_pos, rx296_off
    substr $S10, rx296_tgt, $I11, 2
    ne $S10, "if", rx296_fail
    add rx296_pos, 2
    set_addr $I10, rxcap_300_fail
    ($I12, $I11) = rx296_cur."!mark_peek"($I10)
    rx296_cur."!cursor_pos"($I11)
    ($P10) = rx296_cur."!cursor_start"()
    $P10."!cursor_pass"(rx296_pos, "")
    rx296_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_300_done
  rxcap_300_fail:
    goto rx296_fail
  rxcap_300_done:
  # rx charclass s
    ge rx296_pos, rx296_eos, rx296_fail
    sub $I10, rx296_pos, rx296_off
    is_cclass $I11, 32, rx296_tgt, $I10
    unless $I11, rx296_fail
    inc rx296_pos
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
.annotate 'line', 190
  # rx subrule "xblock" subtype=capture negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."xblock"()
    unless $P10, rx296_fail
    rx296_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx296_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
.annotate 'line', 191
  # rx rxquantr303 ** 0..*
    set_addr $I10, rxquantr303_done
    rx296_cur."!mark_push"(0, rx296_pos, $I10)
  rxquantr303_loop:
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx296_pos, 5
    gt $I11, rx296_eos, rx296_fail
    sub $I11, rx296_pos, rx296_off
    substr $S10, rx296_tgt, $I11, 5
    ne $S10, "elsif", rx296_fail
    add rx296_pos, 5
  # rx charclass s
    ge rx296_pos, rx296_eos, rx296_fail
    sub $I10, rx296_pos, rx296_off
    is_cclass $I11, 32, rx296_tgt, $I10
    unless $I11, rx296_fail
    inc rx296_pos
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."xblock"()
    unless $P10, rx296_fail
    rx296_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx296_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
    set_addr $I10, rxquantr303_done
    (rx296_rep) = rx296_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr303_done
    rx296_cur."!mark_push"(rx296_rep, rx296_pos, $I10)
    goto rxquantr303_loop
  rxquantr303_done:
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
.annotate 'line', 192
  # rx rxquantr308 ** 0..1
    set_addr $I10, rxquantr308_done
    rx296_cur."!mark_push"(0, rx296_pos, $I10)
  rxquantr308_loop:
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx296_pos, 4
    gt $I11, rx296_eos, rx296_fail
    sub $I11, rx296_pos, rx296_off
    substr $S10, rx296_tgt, $I11, 4
    ne $S10, "else", rx296_fail
    add rx296_pos, 4
  # rx charclass s
    ge rx296_pos, rx296_eos, rx296_fail
    sub $I10, rx296_pos, rx296_off
    is_cclass $I11, 32, rx296_tgt, $I10
    unless $I11, rx296_fail
    inc rx296_pos
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."pblock"()
    unless $P10, rx296_fail
    rx296_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx296_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
    set_addr $I10, rxquantr308_done
    (rx296_rep) = rx296_cur."!mark_commit"($I10)
  rxquantr308_done:
  # rx subrule "ws" subtype=method negate=
    rx296_cur."!cursor_pos"(rx296_pos)
    $P10 = rx296_cur."ws"()
    unless $P10, rx296_fail
    rx296_pos = $P10."pos"()
.annotate 'line', 188
  # rx pass
    rx296_cur."!cursor_pass"(rx296_pos, "statement_control:sym<if>")
    if_null rx296_debug, debug_537
    rx296_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx296_pos)
  debug_537:
    .return (rx296_cur)
  rx296_restart:
.annotate 'line', 4
    if_null rx296_debug, debug_538
    rx296_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_538:
  rx296_fail:
    (rx296_rep, rx296_pos, $I10, $P10) = rx296_cur."!mark_fail"(0)
    lt rx296_pos, -1, rx296_done
    eq rx296_pos, -1, rx296_fail
    jump $I10
  rx296_done:
    rx296_cur."!cursor_fail"()
    if_null rx296_debug, debug_539
    rx296_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_539:
    .return (rx296_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("65_1299602538.98") :method
.annotate 'line', 4
    new $P298, "ResizablePMCArray"
    push $P298, "if"
    .return ($P298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("66_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P324 = "68_1299602538.98" 
    capture_lex $P324
    .local string rx314_tgt
    .local int rx314_pos
    .local int rx314_off
    .local int rx314_eos
    .local int rx314_rep
    .local pmc rx314_cur
    .local pmc rx314_debug
    (rx314_cur, rx314_pos, rx314_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx314_cur
    .local pmc match
    .lex "$/", match
    length rx314_eos, rx314_tgt
    gt rx314_pos, rx314_eos, rx314_done
    set rx314_off, 0
    lt rx314_pos, 2, rx314_start
    sub rx314_off, rx314_pos, 1
    substr rx314_tgt, rx314_tgt, rx314_off
  rx314_start:
    eq $I10, 1, rx314_restart
    if_null rx314_debug, debug_540
    rx314_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_540:
    $I10 = self.'from'()
    ne $I10, -1, rxscan317_done
    goto rxscan317_scan
  rxscan317_loop:
    (rx314_pos) = rx314_cur."from"()
    inc rx314_pos
    rx314_cur."!cursor_from"(rx314_pos)
    ge rx314_pos, rx314_eos, rxscan317_done
  rxscan317_scan:
    set_addr $I10, rxscan317_loop
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxscan317_done:
.annotate 'line', 196
  # rx subcapture "sym"
    set_addr $I10, rxcap_318_fail
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  # rx literal  "unless"
    add $I11, rx314_pos, 6
    gt $I11, rx314_eos, rx314_fail
    sub $I11, rx314_pos, rx314_off
    substr $S10, rx314_tgt, $I11, 6
    ne $S10, "unless", rx314_fail
    add rx314_pos, 6
    set_addr $I10, rxcap_318_fail
    ($I12, $I11) = rx314_cur."!mark_peek"($I10)
    rx314_cur."!cursor_pos"($I11)
    ($P10) = rx314_cur."!cursor_start"()
    $P10."!cursor_pass"(rx314_pos, "")
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_318_done
  rxcap_318_fail:
    goto rx314_fail
  rxcap_318_done:
  # rx charclass s
    ge rx314_pos, rx314_eos, rx314_fail
    sub $I10, rx314_pos, rx314_off
    is_cclass $I11, 32, rx314_tgt, $I10
    unless $I11, rx314_fail
    inc rx314_pos
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
.annotate 'line', 197
  # rx subrule "xblock" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."xblock"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx314_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
  alt321_0:
.annotate 'line', 198
    set_addr $I10, alt321_1
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx314_cur."!cursor_pos"(rx314_pos)
    .const 'Sub' $P324 = "68_1299602538.98" 
    capture_lex $P324
    $P10 = rx314_cur."before"($P324)
    if $P10, rx314_fail
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
    goto alt321_end
  alt321_1:
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
  alt321_end:
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
.annotate 'line', 195
  # rx pass
    rx314_cur."!cursor_pass"(rx314_pos, "statement_control:sym<unless>")
    if_null rx314_debug, debug_545
    rx314_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx314_pos)
  debug_545:
    .return (rx314_cur)
  rx314_restart:
.annotate 'line', 4
    if_null rx314_debug, debug_546
    rx314_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_546:
  rx314_fail:
    (rx314_rep, rx314_pos, $I10, $P10) = rx314_cur."!mark_fail"(0)
    lt rx314_pos, -1, rx314_done
    eq rx314_pos, -1, rx314_fail
    jump $I10
  rx314_done:
    rx314_cur."!cursor_fail"()
    if_null rx314_debug, debug_547
    rx314_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_547:
    .return (rx314_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("67_1299602538.98") :method
.annotate 'line', 4
    new $P316, "ResizablePMCArray"
    push $P316, "unless"
    .return ($P316)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block323"  :anon :subid("68_1299602538.98") :method :outer("66_1299602538.98")
.annotate 'line', 198
    .local string rx325_tgt
    .local int rx325_pos
    .local int rx325_off
    .local int rx325_eos
    .local int rx325_rep
    .local pmc rx325_cur
    .local pmc rx325_debug
    (rx325_cur, rx325_pos, rx325_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx325_cur
    .local pmc match
    .lex "$/", match
    length rx325_eos, rx325_tgt
    gt rx325_pos, rx325_eos, rx325_done
    set rx325_off, 0
    lt rx325_pos, 2, rx325_start
    sub rx325_off, rx325_pos, 1
    substr rx325_tgt, rx325_tgt, rx325_off
  rx325_start:
    eq $I10, 1, rx325_restart
    if_null rx325_debug, debug_541
    rx325_cur."!cursor_debug"("START", "")
  debug_541:
    $I10 = self.'from'()
    ne $I10, -1, rxscan326_done
    goto rxscan326_scan
  rxscan326_loop:
    (rx325_pos) = rx325_cur."from"()
    inc rx325_pos
    rx325_cur."!cursor_from"(rx325_pos)
    ge rx325_pos, rx325_eos, rxscan326_done
  rxscan326_scan:
    set_addr $I10, rxscan326_loop
    rx325_cur."!mark_push"(0, rx325_pos, $I10)
  rxscan326_done:
  # rx literal  "else"
    add $I11, rx325_pos, 4
    gt $I11, rx325_eos, rx325_fail
    sub $I11, rx325_pos, rx325_off
    substr $S10, rx325_tgt, $I11, 4
    ne $S10, "else", rx325_fail
    add rx325_pos, 4
  # rx pass
    rx325_cur."!cursor_pass"(rx325_pos, "")
    if_null rx325_debug, debug_542
    rx325_cur."!cursor_debug"("PASS", "", " at pos=", rx325_pos)
  debug_542:
    .return (rx325_cur)
  rx325_restart:
    if_null rx325_debug, debug_543
    rx325_cur."!cursor_debug"("NEXT", "")
  debug_543:
  rx325_fail:
    (rx325_rep, rx325_pos, $I10, $P10) = rx325_cur."!mark_fail"(0)
    lt rx325_pos, -1, rx325_done
    eq rx325_pos, -1, rx325_fail
    jump $I10
  rx325_done:
    rx325_cur."!cursor_fail"()
    if_null rx325_debug, debug_544
    rx325_cur."!cursor_debug"("FAIL", "")
  debug_544:
    .return (rx325_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("69_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx332_tgt
    .local int rx332_pos
    .local int rx332_off
    .local int rx332_eos
    .local int rx332_rep
    .local pmc rx332_cur
    .local pmc rx332_debug
    (rx332_cur, rx332_pos, rx332_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx332_cur
    .local pmc match
    .lex "$/", match
    length rx332_eos, rx332_tgt
    gt rx332_pos, rx332_eos, rx332_done
    set rx332_off, 0
    lt rx332_pos, 2, rx332_start
    sub rx332_off, rx332_pos, 1
    substr rx332_tgt, rx332_tgt, rx332_off
  rx332_start:
    eq $I10, 1, rx332_restart
    if_null rx332_debug, debug_548
    rx332_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_548:
    $I10 = self.'from'()
    ne $I10, -1, rxscan335_done
    goto rxscan335_scan
  rxscan335_loop:
    (rx332_pos) = rx332_cur."from"()
    inc rx332_pos
    rx332_cur."!cursor_from"(rx332_pos)
    ge rx332_pos, rx332_eos, rxscan335_done
  rxscan335_scan:
    set_addr $I10, rxscan335_loop
    rx332_cur."!mark_push"(0, rx332_pos, $I10)
  rxscan335_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_337_fail
    rx332_cur."!mark_push"(0, rx332_pos, $I10)
  alt336_0:
    set_addr $I10, alt336_1
    rx332_cur."!mark_push"(0, rx332_pos, $I10)
  # rx literal  "while"
    add $I11, rx332_pos, 5
    gt $I11, rx332_eos, rx332_fail
    sub $I11, rx332_pos, rx332_off
    substr $S10, rx332_tgt, $I11, 5
    ne $S10, "while", rx332_fail
    add rx332_pos, 5
    goto alt336_end
  alt336_1:
  # rx literal  "until"
    add $I11, rx332_pos, 5
    gt $I11, rx332_eos, rx332_fail
    sub $I11, rx332_pos, rx332_off
    substr $S10, rx332_tgt, $I11, 5
    ne $S10, "until", rx332_fail
    add rx332_pos, 5
  alt336_end:
    set_addr $I10, rxcap_337_fail
    ($I12, $I11) = rx332_cur."!mark_peek"($I10)
    rx332_cur."!cursor_pos"($I11)
    ($P10) = rx332_cur."!cursor_start"()
    $P10."!cursor_pass"(rx332_pos, "")
    rx332_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_337_done
  rxcap_337_fail:
    goto rx332_fail
  rxcap_337_done:
  # rx charclass s
    ge rx332_pos, rx332_eos, rx332_fail
    sub $I10, rx332_pos, rx332_off
    is_cclass $I11, 32, rx332_tgt, $I10
    unless $I11, rx332_fail
    inc rx332_pos
  # rx subrule "ws" subtype=method negate=
    rx332_cur."!cursor_pos"(rx332_pos)
    $P10 = rx332_cur."ws"()
    unless $P10, rx332_fail
    rx332_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx332_cur."!cursor_pos"(rx332_pos)
    $P10 = rx332_cur."xblock"()
    unless $P10, rx332_fail
    rx332_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx332_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx332_cur."!cursor_pos"(rx332_pos)
    $P10 = rx332_cur."ws"()
    unless $P10, rx332_fail
    rx332_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx332_cur."!cursor_pass"(rx332_pos, "statement_control:sym<while>")
    if_null rx332_debug, debug_549
    rx332_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx332_pos)
  debug_549:
    .return (rx332_cur)
  rx332_restart:
.annotate 'line', 4
    if_null rx332_debug, debug_550
    rx332_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_550:
  rx332_fail:
    (rx332_rep, rx332_pos, $I10, $P10) = rx332_cur."!mark_fail"(0)
    lt rx332_pos, -1, rx332_done
    eq rx332_pos, -1, rx332_fail
    jump $I10
  rx332_done:
    rx332_cur."!cursor_fail"()
    if_null rx332_debug, debug_551
    rx332_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_551:
    .return (rx332_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("70_1299602538.98") :method
.annotate 'line', 4
    new $P334, "ResizablePMCArray"
    push $P334, "until"
    push $P334, "while"
    .return ($P334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("71_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx341_tgt
    .local int rx341_pos
    .local int rx341_off
    .local int rx341_eos
    .local int rx341_rep
    .local pmc rx341_cur
    .local pmc rx341_debug
    (rx341_cur, rx341_pos, rx341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx341_cur
    .local pmc match
    .lex "$/", match
    length rx341_eos, rx341_tgt
    gt rx341_pos, rx341_eos, rx341_done
    set rx341_off, 0
    lt rx341_pos, 2, rx341_start
    sub rx341_off, rx341_pos, 1
    substr rx341_tgt, rx341_tgt, rx341_off
  rx341_start:
    eq $I10, 1, rx341_restart
    if_null rx341_debug, debug_552
    rx341_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_552:
    $I10 = self.'from'()
    ne $I10, -1, rxscan344_done
    goto rxscan344_scan
  rxscan344_loop:
    (rx341_pos) = rx341_cur."from"()
    inc rx341_pos
    rx341_cur."!cursor_from"(rx341_pos)
    ge rx341_pos, rx341_eos, rxscan344_done
  rxscan344_scan:
    set_addr $I10, rxscan344_loop
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  rxscan344_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_345_fail
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx341_pos, 6
    gt $I11, rx341_eos, rx341_fail
    sub $I11, rx341_pos, rx341_off
    substr $S10, rx341_tgt, $I11, 6
    ne $S10, "repeat", rx341_fail
    add rx341_pos, 6
    set_addr $I10, rxcap_345_fail
    ($I12, $I11) = rx341_cur."!mark_peek"($I10)
    rx341_cur."!cursor_pos"($I11)
    ($P10) = rx341_cur."!cursor_start"()
    $P10."!cursor_pass"(rx341_pos, "")
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_345_done
  rxcap_345_fail:
    goto rx341_fail
  rxcap_345_done:
  # rx charclass s
    ge rx341_pos, rx341_eos, rx341_fail
    sub $I10, rx341_pos, rx341_off
    is_cclass $I11, 32, rx341_tgt, $I10
    unless $I11, rx341_fail
    inc rx341_pos
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  alt347_0:
.annotate 'line', 208
    set_addr $I10, alt347_1
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
.annotate 'line', 209
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_350_fail
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  alt349_0:
    set_addr $I10, alt349_1
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  # rx literal  "while"
    add $I11, rx341_pos, 5
    gt $I11, rx341_eos, rx341_fail
    sub $I11, rx341_pos, rx341_off
    substr $S10, rx341_tgt, $I11, 5
    ne $S10, "while", rx341_fail
    add rx341_pos, 5
    goto alt349_end
  alt349_1:
  # rx literal  "until"
    add $I11, rx341_pos, 5
    gt $I11, rx341_eos, rx341_fail
    sub $I11, rx341_pos, rx341_off
    substr $S10, rx341_tgt, $I11, 5
    ne $S10, "until", rx341_fail
    add rx341_pos, 5
  alt349_end:
    set_addr $I10, rxcap_350_fail
    ($I12, $I11) = rx341_cur."!mark_peek"($I10)
    rx341_cur."!cursor_pos"($I11)
    ($P10) = rx341_cur."!cursor_start"()
    $P10."!cursor_pass"(rx341_pos, "")
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_350_done
  rxcap_350_fail:
    goto rx341_fail
  rxcap_350_done:
  # rx charclass s
    ge rx341_pos, rx341_eos, rx341_fail
    sub $I10, rx341_pos, rx341_off
    is_cclass $I11, 32, rx341_tgt, $I10
    unless $I11, rx341_fail
    inc rx341_pos
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."xblock"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx341_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
    goto alt347_end
  alt347_1:
.annotate 'line', 210
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."pblock"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx341_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_356_fail
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  alt355_0:
    set_addr $I10, alt355_1
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  # rx literal  "while"
    add $I11, rx341_pos, 5
    gt $I11, rx341_eos, rx341_fail
    sub $I11, rx341_pos, rx341_off
    substr $S10, rx341_tgt, $I11, 5
    ne $S10, "while", rx341_fail
    add rx341_pos, 5
    goto alt355_end
  alt355_1:
  # rx literal  "until"
    add $I11, rx341_pos, 5
    gt $I11, rx341_eos, rx341_fail
    sub $I11, rx341_pos, rx341_off
    substr $S10, rx341_tgt, $I11, 5
    ne $S10, "until", rx341_fail
    add rx341_pos, 5
  alt355_end:
    set_addr $I10, rxcap_356_fail
    ($I12, $I11) = rx341_cur."!mark_peek"($I10)
    rx341_cur."!cursor_pos"($I11)
    ($P10) = rx341_cur."!cursor_start"()
    $P10."!cursor_pass"(rx341_pos, "")
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_356_done
  rxcap_356_fail:
    goto rx341_fail
  rxcap_356_done:
  # rx charclass s
    ge rx341_pos, rx341_eos, rx341_fail
    sub $I10, rx341_pos, rx341_off
    is_cclass $I11, 32, rx341_tgt, $I10
    unless $I11, rx341_fail
    inc rx341_pos
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."EXPR"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx341_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  alt347_end:
.annotate 'line', 211
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx341_cur."!cursor_pass"(rx341_pos, "statement_control:sym<repeat>")
    if_null rx341_debug, debug_553
    rx341_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx341_pos)
  debug_553:
    .return (rx341_cur)
  rx341_restart:
.annotate 'line', 4
    if_null rx341_debug, debug_554
    rx341_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_554:
  rx341_fail:
    (rx341_rep, rx341_pos, $I10, $P10) = rx341_cur."!mark_fail"(0)
    lt rx341_pos, -1, rx341_done
    eq rx341_pos, -1, rx341_fail
    jump $I10
  rx341_done:
    rx341_cur."!cursor_fail"()
    if_null rx341_debug, debug_555
    rx341_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_555:
    .return (rx341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("72_1299602538.98") :method
.annotate 'line', 4
    new $P343, "ResizablePMCArray"
    push $P343, "repeat"
    .return ($P343)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("73_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx361_tgt
    .local int rx361_pos
    .local int rx361_off
    .local int rx361_eos
    .local int rx361_rep
    .local pmc rx361_cur
    .local pmc rx361_debug
    (rx361_cur, rx361_pos, rx361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx361_cur
    .local pmc match
    .lex "$/", match
    length rx361_eos, rx361_tgt
    gt rx361_pos, rx361_eos, rx361_done
    set rx361_off, 0
    lt rx361_pos, 2, rx361_start
    sub rx361_off, rx361_pos, 1
    substr rx361_tgt, rx361_tgt, rx361_off
  rx361_start:
    eq $I10, 1, rx361_restart
    if_null rx361_debug, debug_556
    rx361_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_556:
    $I10 = self.'from'()
    ne $I10, -1, rxscan364_done
    goto rxscan364_scan
  rxscan364_loop:
    (rx361_pos) = rx361_cur."from"()
    inc rx361_pos
    rx361_cur."!cursor_from"(rx361_pos)
    ge rx361_pos, rx361_eos, rxscan364_done
  rxscan364_scan:
    set_addr $I10, rxscan364_loop
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  rxscan364_done:
.annotate 'line', 215
  # rx subcapture "sym"
    set_addr $I10, rxcap_365_fail
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  # rx literal  "for"
    add $I11, rx361_pos, 3
    gt $I11, rx361_eos, rx361_fail
    sub $I11, rx361_pos, rx361_off
    substr $S10, rx361_tgt, $I11, 3
    ne $S10, "for", rx361_fail
    add rx361_pos, 3
    set_addr $I10, rxcap_365_fail
    ($I12, $I11) = rx361_cur."!mark_peek"($I10)
    rx361_cur."!cursor_pos"($I11)
    ($P10) = rx361_cur."!cursor_start"()
    $P10."!cursor_pass"(rx361_pos, "")
    rx361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_365_done
  rxcap_365_fail:
    goto rx361_fail
  rxcap_365_done:
  # rx charclass s
    ge rx361_pos, rx361_eos, rx361_fail
    sub $I10, rx361_pos, rx361_off
    is_cclass $I11, 32, rx361_tgt, $I10
    unless $I11, rx361_fail
    inc rx361_pos
  # rx subrule "ws" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."ws"()
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
.annotate 'line', 216
  # rx subrule "xblock" subtype=capture negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."xblock"()
    unless $P10, rx361_fail
    rx361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx361_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."ws"()
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
.annotate 'line', 214
  # rx pass
    rx361_cur."!cursor_pass"(rx361_pos, "statement_control:sym<for>")
    if_null rx361_debug, debug_557
    rx361_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx361_pos)
  debug_557:
    .return (rx361_cur)
  rx361_restart:
.annotate 'line', 4
    if_null rx361_debug, debug_558
    rx361_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_558:
  rx361_fail:
    (rx361_rep, rx361_pos, $I10, $P10) = rx361_cur."!mark_fail"(0)
    lt rx361_pos, -1, rx361_done
    eq rx361_pos, -1, rx361_fail
    jump $I10
  rx361_done:
    rx361_cur."!cursor_fail"()
    if_null rx361_debug, debug_559
    rx361_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_559:
    .return (rx361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("74_1299602538.98") :method
.annotate 'line', 4
    new $P363, "ResizablePMCArray"
    push $P363, "for"
    .return ($P363)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("75_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx369_tgt
    .local int rx369_pos
    .local int rx369_off
    .local int rx369_eos
    .local int rx369_rep
    .local pmc rx369_cur
    .local pmc rx369_debug
    (rx369_cur, rx369_pos, rx369_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx369_cur
    .local pmc match
    .lex "$/", match
    length rx369_eos, rx369_tgt
    gt rx369_pos, rx369_eos, rx369_done
    set rx369_off, 0
    lt rx369_pos, 2, rx369_start
    sub rx369_off, rx369_pos, 1
    substr rx369_tgt, rx369_tgt, rx369_off
  rx369_start:
    eq $I10, 1, rx369_restart
    if_null rx369_debug, debug_560
    rx369_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_560:
    $I10 = self.'from'()
    ne $I10, -1, rxscan372_done
    goto rxscan372_scan
  rxscan372_loop:
    (rx369_pos) = rx369_cur."from"()
    inc rx369_pos
    rx369_cur."!cursor_from"(rx369_pos)
    ge rx369_pos, rx369_eos, rxscan372_done
  rxscan372_scan:
    set_addr $I10, rxscan372_loop
    rx369_cur."!mark_push"(0, rx369_pos, $I10)
  rxscan372_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_373_fail
    rx369_cur."!mark_push"(0, rx369_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx369_pos, 5
    gt $I11, rx369_eos, rx369_fail
    sub $I11, rx369_pos, rx369_off
    substr $S10, rx369_tgt, $I11, 5
    ne $S10, "CATCH", rx369_fail
    add rx369_pos, 5
    set_addr $I10, rxcap_373_fail
    ($I12, $I11) = rx369_cur."!mark_peek"($I10)
    rx369_cur."!cursor_pos"($I11)
    ($P10) = rx369_cur."!cursor_start"()
    $P10."!cursor_pass"(rx369_pos, "")
    rx369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_373_done
  rxcap_373_fail:
    goto rx369_fail
  rxcap_373_done:
  # rx charclass s
    ge rx369_pos, rx369_eos, rx369_fail
    sub $I10, rx369_pos, rx369_off
    is_cclass $I11, 32, rx369_tgt, $I10
    unless $I11, rx369_fail
    inc rx369_pos
  # rx subrule "ws" subtype=method negate=
    rx369_cur."!cursor_pos"(rx369_pos)
    $P10 = rx369_cur."ws"()
    unless $P10, rx369_fail
    rx369_pos = $P10."pos"()
.annotate 'line', 221
  # rx subrule "block" subtype=capture negate=
    rx369_cur."!cursor_pos"(rx369_pos)
    $P10 = rx369_cur."block"()
    unless $P10, rx369_fail
    rx369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx369_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx369_cur."!cursor_pos"(rx369_pos)
    $P10 = rx369_cur."ws"()
    unless $P10, rx369_fail
    rx369_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx369_cur."!cursor_pass"(rx369_pos, "statement_control:sym<CATCH>")
    if_null rx369_debug, debug_561
    rx369_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx369_pos)
  debug_561:
    .return (rx369_cur)
  rx369_restart:
.annotate 'line', 4
    if_null rx369_debug, debug_562
    rx369_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_562:
  rx369_fail:
    (rx369_rep, rx369_pos, $I10, $P10) = rx369_cur."!mark_fail"(0)
    lt rx369_pos, -1, rx369_done
    eq rx369_pos, -1, rx369_fail
    jump $I10
  rx369_done:
    rx369_cur."!cursor_fail"()
    if_null rx369_debug, debug_563
    rx369_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_563:
    .return (rx369_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("76_1299602538.98") :method
.annotate 'line', 4
    new $P371, "ResizablePMCArray"
    push $P371, "CATCH"
    .return ($P371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("77_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx377_tgt
    .local int rx377_pos
    .local int rx377_off
    .local int rx377_eos
    .local int rx377_rep
    .local pmc rx377_cur
    .local pmc rx377_debug
    (rx377_cur, rx377_pos, rx377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx377_cur
    .local pmc match
    .lex "$/", match
    length rx377_eos, rx377_tgt
    gt rx377_pos, rx377_eos, rx377_done
    set rx377_off, 0
    lt rx377_pos, 2, rx377_start
    sub rx377_off, rx377_pos, 1
    substr rx377_tgt, rx377_tgt, rx377_off
  rx377_start:
    eq $I10, 1, rx377_restart
    if_null rx377_debug, debug_564
    rx377_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_564:
    $I10 = self.'from'()
    ne $I10, -1, rxscan380_done
    goto rxscan380_scan
  rxscan380_loop:
    (rx377_pos) = rx377_cur."from"()
    inc rx377_pos
    rx377_cur."!cursor_from"(rx377_pos)
    ge rx377_pos, rx377_eos, rxscan380_done
  rxscan380_scan:
    set_addr $I10, rxscan380_loop
    rx377_cur."!mark_push"(0, rx377_pos, $I10)
  rxscan380_done:
.annotate 'line', 225
  # rx subcapture "sym"
    set_addr $I10, rxcap_381_fail
    rx377_cur."!mark_push"(0, rx377_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx377_pos, 7
    gt $I11, rx377_eos, rx377_fail
    sub $I11, rx377_pos, rx377_off
    substr $S10, rx377_tgt, $I11, 7
    ne $S10, "CONTROL", rx377_fail
    add rx377_pos, 7
    set_addr $I10, rxcap_381_fail
    ($I12, $I11) = rx377_cur."!mark_peek"($I10)
    rx377_cur."!cursor_pos"($I11)
    ($P10) = rx377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx377_pos, "")
    rx377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_381_done
  rxcap_381_fail:
    goto rx377_fail
  rxcap_381_done:
  # rx charclass s
    ge rx377_pos, rx377_eos, rx377_fail
    sub $I10, rx377_pos, rx377_off
    is_cclass $I11, 32, rx377_tgt, $I10
    unless $I11, rx377_fail
    inc rx377_pos
  # rx subrule "ws" subtype=method negate=
    rx377_cur."!cursor_pos"(rx377_pos)
    $P10 = rx377_cur."ws"()
    unless $P10, rx377_fail
    rx377_pos = $P10."pos"()
.annotate 'line', 226
  # rx subrule "block" subtype=capture negate=
    rx377_cur."!cursor_pos"(rx377_pos)
    $P10 = rx377_cur."block"()
    unless $P10, rx377_fail
    rx377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx377_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx377_cur."!cursor_pos"(rx377_pos)
    $P10 = rx377_cur."ws"()
    unless $P10, rx377_fail
    rx377_pos = $P10."pos"()
.annotate 'line', 224
  # rx pass
    rx377_cur."!cursor_pass"(rx377_pos, "statement_control:sym<CONTROL>")
    if_null rx377_debug, debug_565
    rx377_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx377_pos)
  debug_565:
    .return (rx377_cur)
  rx377_restart:
.annotate 'line', 4
    if_null rx377_debug, debug_566
    rx377_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_566:
  rx377_fail:
    (rx377_rep, rx377_pos, $I10, $P10) = rx377_cur."!mark_fail"(0)
    lt rx377_pos, -1, rx377_done
    eq rx377_pos, -1, rx377_fail
    jump $I10
  rx377_done:
    rx377_cur."!cursor_fail"()
    if_null rx377_debug, debug_567
    rx377_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_567:
    .return (rx377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("78_1299602538.98") :method
.annotate 'line', 4
    new $P379, "ResizablePMCArray"
    push $P379, "CONTROL"
    .return ($P379)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("79_1299602538.98")
    .param pmc param_385
.annotate 'line', 229
    .lex "self", param_385
    $P386 = param_385."!protoregex"("statement_prefix")
    .return ($P386)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("80_1299602538.98")
    .param pmc param_388
.annotate 'line', 229
    .lex "self", param_388
    $P389 = param_388."!PREFIX__!protoregex"("statement_prefix")
    .return ($P389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("81_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx391_tgt
    .local int rx391_pos
    .local int rx391_off
    .local int rx391_eos
    .local int rx391_rep
    .local pmc rx391_cur
    .local pmc rx391_debug
    (rx391_cur, rx391_pos, rx391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx391_cur
    .local pmc match
    .lex "$/", match
    length rx391_eos, rx391_tgt
    gt rx391_pos, rx391_eos, rx391_done
    set rx391_off, 0
    lt rx391_pos, 2, rx391_start
    sub rx391_off, rx391_pos, 1
    substr rx391_tgt, rx391_tgt, rx391_off
  rx391_start:
    eq $I10, 1, rx391_restart
    if_null rx391_debug, debug_568
    rx391_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_568:
    $I10 = self.'from'()
    ne $I10, -1, rxscan395_done
    goto rxscan395_scan
  rxscan395_loop:
    (rx391_pos) = rx391_cur."from"()
    inc rx391_pos
    rx391_cur."!cursor_from"(rx391_pos)
    ge rx391_pos, rx391_eos, rxscan395_done
  rxscan395_scan:
    set_addr $I10, rxscan395_loop
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  rxscan395_done:
.annotate 'line', 230
  # rx subcapture "sym"
    set_addr $I10, rxcap_396_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx391_pos, 4
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 4
    ne $S10, "INIT", rx391_fail
    add rx391_pos, 4
    set_addr $I10, rxcap_396_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_396_done
  rxcap_396_fail:
    goto rx391_fail
  rxcap_396_done:
  # rx subrule "blorst" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."blorst"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx391_pos = $P10."pos"()
  # rx pass
    rx391_cur."!cursor_pass"(rx391_pos, "statement_prefix:sym<INIT>")
    if_null rx391_debug, debug_569
    rx391_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx391_pos)
  debug_569:
    .return (rx391_cur)
  rx391_restart:
.annotate 'line', 4
    if_null rx391_debug, debug_570
    rx391_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_570:
  rx391_fail:
    (rx391_rep, rx391_pos, $I10, $P10) = rx391_cur."!mark_fail"(0)
    lt rx391_pos, -1, rx391_done
    eq rx391_pos, -1, rx391_fail
    jump $I10
  rx391_done:
    rx391_cur."!cursor_fail"()
    if_null rx391_debug, debug_571
    rx391_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_571:
    .return (rx391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("82_1299602538.98") :method
.annotate 'line', 4
    $P393 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P394, "ResizablePMCArray"
    push $P394, $P393
    .return ($P394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("83_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx398_tgt
    .local int rx398_pos
    .local int rx398_off
    .local int rx398_eos
    .local int rx398_rep
    .local pmc rx398_cur
    .local pmc rx398_debug
    (rx398_cur, rx398_pos, rx398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx398_cur
    .local pmc match
    .lex "$/", match
    length rx398_eos, rx398_tgt
    gt rx398_pos, rx398_eos, rx398_done
    set rx398_off, 0
    lt rx398_pos, 2, rx398_start
    sub rx398_off, rx398_pos, 1
    substr rx398_tgt, rx398_tgt, rx398_off
  rx398_start:
    eq $I10, 1, rx398_restart
    if_null rx398_debug, debug_572
    rx398_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_572:
    $I10 = self.'from'()
    ne $I10, -1, rxscan402_done
    goto rxscan402_scan
  rxscan402_loop:
    (rx398_pos) = rx398_cur."from"()
    inc rx398_pos
    rx398_cur."!cursor_from"(rx398_pos)
    ge rx398_pos, rx398_eos, rxscan402_done
  rxscan402_scan:
    set_addr $I10, rxscan402_loop
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  rxscan402_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_403_fail
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  # rx literal  "try"
    add $I11, rx398_pos, 3
    gt $I11, rx398_eos, rx398_fail
    sub $I11, rx398_pos, rx398_off
    substr $S10, rx398_tgt, $I11, 3
    ne $S10, "try", rx398_fail
    add rx398_pos, 3
    set_addr $I10, rxcap_403_fail
    ($I12, $I11) = rx398_cur."!mark_peek"($I10)
    rx398_cur."!cursor_pos"($I11)
    ($P10) = rx398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx398_pos, "")
    rx398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_403_done
  rxcap_403_fail:
    goto rx398_fail
  rxcap_403_done:
.annotate 'line', 234
  # rx subrule "blorst" subtype=capture negate=
    rx398_cur."!cursor_pos"(rx398_pos)
    $P10 = rx398_cur."blorst"()
    unless $P10, rx398_fail
    rx398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx398_pos = $P10."pos"()
.annotate 'line', 232
  # rx pass
    rx398_cur."!cursor_pass"(rx398_pos, "statement_prefix:sym<try>")
    if_null rx398_debug, debug_573
    rx398_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx398_pos)
  debug_573:
    .return (rx398_cur)
  rx398_restart:
.annotate 'line', 4
    if_null rx398_debug, debug_574
    rx398_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_574:
  rx398_fail:
    (rx398_rep, rx398_pos, $I10, $P10) = rx398_cur."!mark_fail"(0)
    lt rx398_pos, -1, rx398_done
    eq rx398_pos, -1, rx398_fail
    jump $I10
  rx398_done:
    rx398_cur."!cursor_fail"()
    if_null rx398_debug, debug_575
    rx398_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_575:
    .return (rx398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("84_1299602538.98") :method
.annotate 'line', 4
    $P400 = self."!PREFIX__!subrule"("blorst", "try")
    new $P401, "ResizablePMCArray"
    push $P401, $P400
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("85_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx405_tgt
    .local int rx405_pos
    .local int rx405_off
    .local int rx405_eos
    .local int rx405_rep
    .local pmc rx405_cur
    .local pmc rx405_debug
    (rx405_cur, rx405_pos, rx405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx405_cur
    .local pmc match
    .lex "$/", match
    length rx405_eos, rx405_tgt
    gt rx405_pos, rx405_eos, rx405_done
    set rx405_off, 0
    lt rx405_pos, 2, rx405_start
    sub rx405_off, rx405_pos, 1
    substr rx405_tgt, rx405_tgt, rx405_off
  rx405_start:
    eq $I10, 1, rx405_restart
    if_null rx405_debug, debug_576
    rx405_cur."!cursor_debug"("START", "blorst")
  debug_576:
    $I10 = self.'from'()
    ne $I10, -1, rxscan408_done
    goto rxscan408_scan
  rxscan408_loop:
    (rx405_pos) = rx405_cur."from"()
    inc rx405_pos
    rx405_cur."!cursor_from"(rx405_pos)
    ge rx405_pos, rx405_eos, rxscan408_done
  rxscan408_scan:
    set_addr $I10, rxscan408_loop
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  rxscan408_done:
.annotate 'line', 238
  # rx charclass s
    ge rx405_pos, rx405_eos, rx405_fail
    sub $I10, rx405_pos, rx405_off
    is_cclass $I11, 32, rx405_tgt, $I10
    unless $I11, rx405_fail
    inc rx405_pos
  # rx subrule "ws" subtype=method negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."ws"()
    unless $P10, rx405_fail
    rx405_pos = $P10."pos"()
  alt409_0:
    set_addr $I10, alt409_1
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx405_pos, rx405_off
    substr $S10, rx405_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx405_fail
  # rx subrule "block" subtype=capture negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."block"()
    unless $P10, rx405_fail
    rx405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx405_pos = $P10."pos"()
    goto alt409_end
  alt409_1:
  # rx subrule "statement" subtype=capture negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."statement"()
    unless $P10, rx405_fail
    rx405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx405_pos = $P10."pos"()
  alt409_end:
.annotate 'line', 237
  # rx pass
    rx405_cur."!cursor_pass"(rx405_pos, "blorst")
    if_null rx405_debug, debug_577
    rx405_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx405_pos)
  debug_577:
    .return (rx405_cur)
  rx405_restart:
.annotate 'line', 4
    if_null rx405_debug, debug_578
    rx405_cur."!cursor_debug"("NEXT", "blorst")
  debug_578:
  rx405_fail:
    (rx405_rep, rx405_pos, $I10, $P10) = rx405_cur."!mark_fail"(0)
    lt rx405_pos, -1, rx405_done
    eq rx405_pos, -1, rx405_fail
    jump $I10
  rx405_done:
    rx405_cur."!cursor_fail"()
    if_null rx405_debug, debug_579
    rx405_cur."!cursor_debug"("FAIL", "blorst")
  debug_579:
    .return (rx405_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("86_1299602538.98") :method
.annotate 'line', 4
    new $P407, "ResizablePMCArray"
    push $P407, ""
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("87_1299602538.98")
    .param pmc param_411
.annotate 'line', 243
    .lex "self", param_411
    $P412 = param_411."!protoregex"("statement_mod_cond")
    .return ($P412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("88_1299602538.98")
    .param pmc param_414
.annotate 'line', 243
    .lex "self", param_414
    $P415 = param_414."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P415)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("89_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx417_tgt
    .local int rx417_pos
    .local int rx417_off
    .local int rx417_eos
    .local int rx417_rep
    .local pmc rx417_cur
    .local pmc rx417_debug
    (rx417_cur, rx417_pos, rx417_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx417_cur
    .local pmc match
    .lex "$/", match
    length rx417_eos, rx417_tgt
    gt rx417_pos, rx417_eos, rx417_done
    set rx417_off, 0
    lt rx417_pos, 2, rx417_start
    sub rx417_off, rx417_pos, 1
    substr rx417_tgt, rx417_tgt, rx417_off
  rx417_start:
    eq $I10, 1, rx417_restart
    if_null rx417_debug, debug_580
    rx417_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_580:
    $I10 = self.'from'()
    ne $I10, -1, rxscan421_done
    goto rxscan421_scan
  rxscan421_loop:
    (rx417_pos) = rx417_cur."from"()
    inc rx417_pos
    rx417_cur."!cursor_from"(rx417_pos)
    ge rx417_pos, rx417_eos, rxscan421_done
  rxscan421_scan:
    set_addr $I10, rxscan421_loop
    rx417_cur."!mark_push"(0, rx417_pos, $I10)
  rxscan421_done:
.annotate 'line', 245
  # rx subcapture "sym"
    set_addr $I10, rxcap_422_fail
    rx417_cur."!mark_push"(0, rx417_pos, $I10)
  # rx literal  "if"
    add $I11, rx417_pos, 2
    gt $I11, rx417_eos, rx417_fail
    sub $I11, rx417_pos, rx417_off
    substr $S10, rx417_tgt, $I11, 2
    ne $S10, "if", rx417_fail
    add rx417_pos, 2
    set_addr $I10, rxcap_422_fail
    ($I12, $I11) = rx417_cur."!mark_peek"($I10)
    rx417_cur."!cursor_pos"($I11)
    ($P10) = rx417_cur."!cursor_start"()
    $P10."!cursor_pass"(rx417_pos, "")
    rx417_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_422_done
  rxcap_422_fail:
    goto rx417_fail
  rxcap_422_done:
  # rx subrule "ws" subtype=method negate=
    rx417_cur."!cursor_pos"(rx417_pos)
    $P10 = rx417_cur."ws"()
    unless $P10, rx417_fail
    rx417_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx417_cur."!cursor_pos"(rx417_pos)
    $P10 = rx417_cur."EXPR"()
    unless $P10, rx417_fail
    rx417_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx417_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx417_cur."!cursor_pos"(rx417_pos)
    $P10 = rx417_cur."ws"()
    unless $P10, rx417_fail
    rx417_pos = $P10."pos"()
  # rx pass
    rx417_cur."!cursor_pass"(rx417_pos, "statement_mod_cond:sym<if>")
    if_null rx417_debug, debug_581
    rx417_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx417_pos)
  debug_581:
    .return (rx417_cur)
  rx417_restart:
.annotate 'line', 4
    if_null rx417_debug, debug_582
    rx417_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_582:
  rx417_fail:
    (rx417_rep, rx417_pos, $I10, $P10) = rx417_cur."!mark_fail"(0)
    lt rx417_pos, -1, rx417_done
    eq rx417_pos, -1, rx417_fail
    jump $I10
  rx417_done:
    rx417_cur."!cursor_fail"()
    if_null rx417_debug, debug_583
    rx417_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_583:
    .return (rx417_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("90_1299602538.98") :method
.annotate 'line', 4
    $P419 = self."!PREFIX__!subrule"("ws", "if")
    new $P420, "ResizablePMCArray"
    push $P420, $P419
    .return ($P420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("91_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx426_tgt
    .local int rx426_pos
    .local int rx426_off
    .local int rx426_eos
    .local int rx426_rep
    .local pmc rx426_cur
    .local pmc rx426_debug
    (rx426_cur, rx426_pos, rx426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx426_cur
    .local pmc match
    .lex "$/", match
    length rx426_eos, rx426_tgt
    gt rx426_pos, rx426_eos, rx426_done
    set rx426_off, 0
    lt rx426_pos, 2, rx426_start
    sub rx426_off, rx426_pos, 1
    substr rx426_tgt, rx426_tgt, rx426_off
  rx426_start:
    eq $I10, 1, rx426_restart
    if_null rx426_debug, debug_584
    rx426_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_584:
    $I10 = self.'from'()
    ne $I10, -1, rxscan430_done
    goto rxscan430_scan
  rxscan430_loop:
    (rx426_pos) = rx426_cur."from"()
    inc rx426_pos
    rx426_cur."!cursor_from"(rx426_pos)
    ge rx426_pos, rx426_eos, rxscan430_done
  rxscan430_scan:
    set_addr $I10, rxscan430_loop
    rx426_cur."!mark_push"(0, rx426_pos, $I10)
  rxscan430_done:
.annotate 'line', 246
  # rx subcapture "sym"
    set_addr $I10, rxcap_431_fail
    rx426_cur."!mark_push"(0, rx426_pos, $I10)
  # rx literal  "unless"
    add $I11, rx426_pos, 6
    gt $I11, rx426_eos, rx426_fail
    sub $I11, rx426_pos, rx426_off
    substr $S10, rx426_tgt, $I11, 6
    ne $S10, "unless", rx426_fail
    add rx426_pos, 6
    set_addr $I10, rxcap_431_fail
    ($I12, $I11) = rx426_cur."!mark_peek"($I10)
    rx426_cur."!cursor_pos"($I11)
    ($P10) = rx426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx426_pos, "")
    rx426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_431_done
  rxcap_431_fail:
    goto rx426_fail
  rxcap_431_done:
  # rx subrule "ws" subtype=method negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."ws"()
    unless $P10, rx426_fail
    rx426_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."EXPR"()
    unless $P10, rx426_fail
    rx426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx426_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."ws"()
    unless $P10, rx426_fail
    rx426_pos = $P10."pos"()
  # rx pass
    rx426_cur."!cursor_pass"(rx426_pos, "statement_mod_cond:sym<unless>")
    if_null rx426_debug, debug_585
    rx426_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx426_pos)
  debug_585:
    .return (rx426_cur)
  rx426_restart:
.annotate 'line', 4
    if_null rx426_debug, debug_586
    rx426_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_586:
  rx426_fail:
    (rx426_rep, rx426_pos, $I10, $P10) = rx426_cur."!mark_fail"(0)
    lt rx426_pos, -1, rx426_done
    eq rx426_pos, -1, rx426_fail
    jump $I10
  rx426_done:
    rx426_cur."!cursor_fail"()
    if_null rx426_debug, debug_587
    rx426_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_587:
    .return (rx426_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("92_1299602538.98") :method
.annotate 'line', 4
    $P428 = self."!PREFIX__!subrule"("ws", "unless")
    new $P429, "ResizablePMCArray"
    push $P429, $P428
    .return ($P429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("93_1299602538.98")
    .param pmc param_435
.annotate 'line', 248
    .lex "self", param_435
    $P436 = param_435."!protoregex"("statement_mod_loop")
    .return ($P436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("94_1299602538.98")
    .param pmc param_438
.annotate 'line', 248
    .lex "self", param_438
    $P439 = param_438."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("95_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx441_tgt
    .local int rx441_pos
    .local int rx441_off
    .local int rx441_eos
    .local int rx441_rep
    .local pmc rx441_cur
    .local pmc rx441_debug
    (rx441_cur, rx441_pos, rx441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx441_cur
    .local pmc match
    .lex "$/", match
    length rx441_eos, rx441_tgt
    gt rx441_pos, rx441_eos, rx441_done
    set rx441_off, 0
    lt rx441_pos, 2, rx441_start
    sub rx441_off, rx441_pos, 1
    substr rx441_tgt, rx441_tgt, rx441_off
  rx441_start:
    eq $I10, 1, rx441_restart
    if_null rx441_debug, debug_588
    rx441_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_588:
    $I10 = self.'from'()
    ne $I10, -1, rxscan445_done
    goto rxscan445_scan
  rxscan445_loop:
    (rx441_pos) = rx441_cur."from"()
    inc rx441_pos
    rx441_cur."!cursor_from"(rx441_pos)
    ge rx441_pos, rx441_eos, rxscan445_done
  rxscan445_scan:
    set_addr $I10, rxscan445_loop
    rx441_cur."!mark_push"(0, rx441_pos, $I10)
  rxscan445_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_446_fail
    rx441_cur."!mark_push"(0, rx441_pos, $I10)
  # rx literal  "while"
    add $I11, rx441_pos, 5
    gt $I11, rx441_eos, rx441_fail
    sub $I11, rx441_pos, rx441_off
    substr $S10, rx441_tgt, $I11, 5
    ne $S10, "while", rx441_fail
    add rx441_pos, 5
    set_addr $I10, rxcap_446_fail
    ($I12, $I11) = rx441_cur."!mark_peek"($I10)
    rx441_cur."!cursor_pos"($I11)
    ($P10) = rx441_cur."!cursor_start"()
    $P10."!cursor_pass"(rx441_pos, "")
    rx441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_446_done
  rxcap_446_fail:
    goto rx441_fail
  rxcap_446_done:
  # rx subrule "ws" subtype=method negate=
    rx441_cur."!cursor_pos"(rx441_pos)
    $P10 = rx441_cur."ws"()
    unless $P10, rx441_fail
    rx441_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx441_cur."!cursor_pos"(rx441_pos)
    $P10 = rx441_cur."EXPR"()
    unless $P10, rx441_fail
    rx441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx441_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx441_cur."!cursor_pos"(rx441_pos)
    $P10 = rx441_cur."ws"()
    unless $P10, rx441_fail
    rx441_pos = $P10."pos"()
  # rx pass
    rx441_cur."!cursor_pass"(rx441_pos, "statement_mod_loop:sym<while>")
    if_null rx441_debug, debug_589
    rx441_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx441_pos)
  debug_589:
    .return (rx441_cur)
  rx441_restart:
.annotate 'line', 4
    if_null rx441_debug, debug_590
    rx441_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_590:
  rx441_fail:
    (rx441_rep, rx441_pos, $I10, $P10) = rx441_cur."!mark_fail"(0)
    lt rx441_pos, -1, rx441_done
    eq rx441_pos, -1, rx441_fail
    jump $I10
  rx441_done:
    rx441_cur."!cursor_fail"()
    if_null rx441_debug, debug_591
    rx441_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_591:
    .return (rx441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("96_1299602538.98") :method
.annotate 'line', 4
    $P443 = self."!PREFIX__!subrule"("ws", "while")
    new $P444, "ResizablePMCArray"
    push $P444, $P443
    .return ($P444)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("97_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx450_tgt
    .local int rx450_pos
    .local int rx450_off
    .local int rx450_eos
    .local int rx450_rep
    .local pmc rx450_cur
    .local pmc rx450_debug
    (rx450_cur, rx450_pos, rx450_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx450_cur
    .local pmc match
    .lex "$/", match
    length rx450_eos, rx450_tgt
    gt rx450_pos, rx450_eos, rx450_done
    set rx450_off, 0
    lt rx450_pos, 2, rx450_start
    sub rx450_off, rx450_pos, 1
    substr rx450_tgt, rx450_tgt, rx450_off
  rx450_start:
    eq $I10, 1, rx450_restart
    if_null rx450_debug, debug_592
    rx450_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_592:
    $I10 = self.'from'()
    ne $I10, -1, rxscan454_done
    goto rxscan454_scan
  rxscan454_loop:
    (rx450_pos) = rx450_cur."from"()
    inc rx450_pos
    rx450_cur."!cursor_from"(rx450_pos)
    ge rx450_pos, rx450_eos, rxscan454_done
  rxscan454_scan:
    set_addr $I10, rxscan454_loop
    rx450_cur."!mark_push"(0, rx450_pos, $I10)
  rxscan454_done:
.annotate 'line', 251
  # rx subcapture "sym"
    set_addr $I10, rxcap_455_fail
    rx450_cur."!mark_push"(0, rx450_pos, $I10)
  # rx literal  "until"
    add $I11, rx450_pos, 5
    gt $I11, rx450_eos, rx450_fail
    sub $I11, rx450_pos, rx450_off
    substr $S10, rx450_tgt, $I11, 5
    ne $S10, "until", rx450_fail
    add rx450_pos, 5
    set_addr $I10, rxcap_455_fail
    ($I12, $I11) = rx450_cur."!mark_peek"($I10)
    rx450_cur."!cursor_pos"($I11)
    ($P10) = rx450_cur."!cursor_start"()
    $P10."!cursor_pass"(rx450_pos, "")
    rx450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_455_done
  rxcap_455_fail:
    goto rx450_fail
  rxcap_455_done:
  # rx subrule "ws" subtype=method negate=
    rx450_cur."!cursor_pos"(rx450_pos)
    $P10 = rx450_cur."ws"()
    unless $P10, rx450_fail
    rx450_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx450_cur."!cursor_pos"(rx450_pos)
    $P10 = rx450_cur."EXPR"()
    unless $P10, rx450_fail
    rx450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx450_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx450_cur."!cursor_pos"(rx450_pos)
    $P10 = rx450_cur."ws"()
    unless $P10, rx450_fail
    rx450_pos = $P10."pos"()
  # rx pass
    rx450_cur."!cursor_pass"(rx450_pos, "statement_mod_loop:sym<until>")
    if_null rx450_debug, debug_593
    rx450_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx450_pos)
  debug_593:
    .return (rx450_cur)
  rx450_restart:
.annotate 'line', 4
    if_null rx450_debug, debug_594
    rx450_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_594:
  rx450_fail:
    (rx450_rep, rx450_pos, $I10, $P10) = rx450_cur."!mark_fail"(0)
    lt rx450_pos, -1, rx450_done
    eq rx450_pos, -1, rx450_fail
    jump $I10
  rx450_done:
    rx450_cur."!cursor_fail"()
    if_null rx450_debug, debug_595
    rx450_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_595:
    .return (rx450_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("98_1299602538.98") :method
.annotate 'line', 4
    $P452 = self."!PREFIX__!subrule"("ws", "until")
    new $P453, "ResizablePMCArray"
    push $P453, $P452
    .return ($P453)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("99_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx459_tgt
    .local int rx459_pos
    .local int rx459_off
    .local int rx459_eos
    .local int rx459_rep
    .local pmc rx459_cur
    .local pmc rx459_debug
    (rx459_cur, rx459_pos, rx459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx459_cur
    .local pmc match
    .lex "$/", match
    length rx459_eos, rx459_tgt
    gt rx459_pos, rx459_eos, rx459_done
    set rx459_off, 0
    lt rx459_pos, 2, rx459_start
    sub rx459_off, rx459_pos, 1
    substr rx459_tgt, rx459_tgt, rx459_off
  rx459_start:
    eq $I10, 1, rx459_restart
    if_null rx459_debug, debug_596
    rx459_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_596:
    $I10 = self.'from'()
    ne $I10, -1, rxscan463_done
    goto rxscan463_scan
  rxscan463_loop:
    (rx459_pos) = rx459_cur."from"()
    inc rx459_pos
    rx459_cur."!cursor_from"(rx459_pos)
    ge rx459_pos, rx459_eos, rxscan463_done
  rxscan463_scan:
    set_addr $I10, rxscan463_loop
    rx459_cur."!mark_push"(0, rx459_pos, $I10)
  rxscan463_done:
.annotate 'line', 252
  # rx subcapture "sym"
    set_addr $I10, rxcap_464_fail
    rx459_cur."!mark_push"(0, rx459_pos, $I10)
  # rx literal  "for"
    add $I11, rx459_pos, 3
    gt $I11, rx459_eos, rx459_fail
    sub $I11, rx459_pos, rx459_off
    substr $S10, rx459_tgt, $I11, 3
    ne $S10, "for", rx459_fail
    add rx459_pos, 3
    set_addr $I10, rxcap_464_fail
    ($I12, $I11) = rx459_cur."!mark_peek"($I10)
    rx459_cur."!cursor_pos"($I11)
    ($P10) = rx459_cur."!cursor_start"()
    $P10."!cursor_pass"(rx459_pos, "")
    rx459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_464_done
  rxcap_464_fail:
    goto rx459_fail
  rxcap_464_done:
  # rx subrule "ws" subtype=method negate=
    rx459_cur."!cursor_pos"(rx459_pos)
    $P10 = rx459_cur."ws"()
    unless $P10, rx459_fail
    rx459_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx459_cur."!cursor_pos"(rx459_pos)
    $P10 = rx459_cur."EXPR"()
    unless $P10, rx459_fail
    rx459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx459_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx459_cur."!cursor_pos"(rx459_pos)
    $P10 = rx459_cur."ws"()
    unless $P10, rx459_fail
    rx459_pos = $P10."pos"()
  # rx pass
    rx459_cur."!cursor_pass"(rx459_pos, "statement_mod_loop:sym<for>")
    if_null rx459_debug, debug_597
    rx459_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx459_pos)
  debug_597:
    .return (rx459_cur)
  rx459_restart:
.annotate 'line', 4
    if_null rx459_debug, debug_598
    rx459_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_598:
  rx459_fail:
    (rx459_rep, rx459_pos, $I10, $P10) = rx459_cur."!mark_fail"(0)
    lt rx459_pos, -1, rx459_done
    eq rx459_pos, -1, rx459_fail
    jump $I10
  rx459_done:
    rx459_cur."!cursor_fail"()
    if_null rx459_debug, debug_599
    rx459_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_599:
    .return (rx459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("100_1299602538.98") :method
.annotate 'line', 4
    $P461 = self."!PREFIX__!subrule"("ws", "for")
    new $P462, "ResizablePMCArray"
    push $P462, $P461
    .return ($P462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("101_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx468_tgt
    .local int rx468_pos
    .local int rx468_off
    .local int rx468_eos
    .local int rx468_rep
    .local pmc rx468_cur
    .local pmc rx468_debug
    (rx468_cur, rx468_pos, rx468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx468_cur
    .local pmc match
    .lex "$/", match
    length rx468_eos, rx468_tgt
    gt rx468_pos, rx468_eos, rx468_done
    set rx468_off, 0
    lt rx468_pos, 2, rx468_start
    sub rx468_off, rx468_pos, 1
    substr rx468_tgt, rx468_tgt, rx468_off
  rx468_start:
    eq $I10, 1, rx468_restart
    if_null rx468_debug, debug_600
    rx468_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_600:
    $I10 = self.'from'()
    ne $I10, -1, rxscan472_done
    goto rxscan472_scan
  rxscan472_loop:
    (rx468_pos) = rx468_cur."from"()
    inc rx468_pos
    rx468_cur."!cursor_from"(rx468_pos)
    ge rx468_pos, rx468_eos, rxscan472_done
  rxscan472_scan:
    set_addr $I10, rxscan472_loop
    rx468_cur."!mark_push"(0, rx468_pos, $I10)
  rxscan472_done:
.annotate 'line', 256
  # rx subrule "fatarrow" subtype=capture negate=
    rx468_cur."!cursor_pos"(rx468_pos)
    $P10 = rx468_cur."fatarrow"()
    unless $P10, rx468_fail
    rx468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx468_pos = $P10."pos"()
  # rx pass
    rx468_cur."!cursor_pass"(rx468_pos, "term:sym<fatarrow>")
    if_null rx468_debug, debug_601
    rx468_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx468_pos)
  debug_601:
    .return (rx468_cur)
  rx468_restart:
.annotate 'line', 4
    if_null rx468_debug, debug_602
    rx468_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_602:
  rx468_fail:
    (rx468_rep, rx468_pos, $I10, $P10) = rx468_cur."!mark_fail"(0)
    lt rx468_pos, -1, rx468_done
    eq rx468_pos, -1, rx468_fail
    jump $I10
  rx468_done:
    rx468_cur."!cursor_fail"()
    if_null rx468_debug, debug_603
    rx468_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_603:
    .return (rx468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("102_1299602538.98") :method
.annotate 'line', 4
    $P470 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P471, "ResizablePMCArray"
    push $P471, $P470
    .return ($P471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("103_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx474_tgt
    .local int rx474_pos
    .local int rx474_off
    .local int rx474_eos
    .local int rx474_rep
    .local pmc rx474_cur
    .local pmc rx474_debug
    (rx474_cur, rx474_pos, rx474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx474_cur
    .local pmc match
    .lex "$/", match
    length rx474_eos, rx474_tgt
    gt rx474_pos, rx474_eos, rx474_done
    set rx474_off, 0
    lt rx474_pos, 2, rx474_start
    sub rx474_off, rx474_pos, 1
    substr rx474_tgt, rx474_tgt, rx474_off
  rx474_start:
    eq $I10, 1, rx474_restart
    if_null rx474_debug, debug_604
    rx474_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_604:
    $I10 = self.'from'()
    ne $I10, -1, rxscan478_done
    goto rxscan478_scan
  rxscan478_loop:
    (rx474_pos) = rx474_cur."from"()
    inc rx474_pos
    rx474_cur."!cursor_from"(rx474_pos)
    ge rx474_pos, rx474_eos, rxscan478_done
  rxscan478_scan:
    set_addr $I10, rxscan478_loop
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  rxscan478_done:
.annotate 'line', 257
  # rx subrule "colonpair" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."colonpair"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx474_pos = $P10."pos"()
  # rx pass
    rx474_cur."!cursor_pass"(rx474_pos, "term:sym<colonpair>")
    if_null rx474_debug, debug_605
    rx474_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx474_pos)
  debug_605:
    .return (rx474_cur)
  rx474_restart:
.annotate 'line', 4
    if_null rx474_debug, debug_606
    rx474_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_606:
  rx474_fail:
    (rx474_rep, rx474_pos, $I10, $P10) = rx474_cur."!mark_fail"(0)
    lt rx474_pos, -1, rx474_done
    eq rx474_pos, -1, rx474_fail
    jump $I10
  rx474_done:
    rx474_cur."!cursor_fail"()
    if_null rx474_debug, debug_607
    rx474_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_607:
    .return (rx474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("104_1299602538.98") :method
.annotate 'line', 4
    $P476 = self."!PREFIX__!subrule"("colonpair", "")
    new $P477, "ResizablePMCArray"
    push $P477, $P476
    .return ($P477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("105_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx480_tgt
    .local int rx480_pos
    .local int rx480_off
    .local int rx480_eos
    .local int rx480_rep
    .local pmc rx480_cur
    .local pmc rx480_debug
    (rx480_cur, rx480_pos, rx480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx480_cur
    .local pmc match
    .lex "$/", match
    length rx480_eos, rx480_tgt
    gt rx480_pos, rx480_eos, rx480_done
    set rx480_off, 0
    lt rx480_pos, 2, rx480_start
    sub rx480_off, rx480_pos, 1
    substr rx480_tgt, rx480_tgt, rx480_off
  rx480_start:
    eq $I10, 1, rx480_restart
    if_null rx480_debug, debug_608
    rx480_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_608:
    $I10 = self.'from'()
    ne $I10, -1, rxscan484_done
    goto rxscan484_scan
  rxscan484_loop:
    (rx480_pos) = rx480_cur."from"()
    inc rx480_pos
    rx480_cur."!cursor_from"(rx480_pos)
    ge rx480_pos, rx480_eos, rxscan484_done
  rxscan484_scan:
    set_addr $I10, rxscan484_loop
    rx480_cur."!mark_push"(0, rx480_pos, $I10)
  rxscan484_done:
.annotate 'line', 258
  # rx subrule "variable" subtype=capture negate=
    rx480_cur."!cursor_pos"(rx480_pos)
    $P10 = rx480_cur."variable"()
    unless $P10, rx480_fail
    rx480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx480_pos = $P10."pos"()
  # rx pass
    rx480_cur."!cursor_pass"(rx480_pos, "term:sym<variable>")
    if_null rx480_debug, debug_609
    rx480_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx480_pos)
  debug_609:
    .return (rx480_cur)
  rx480_restart:
.annotate 'line', 4
    if_null rx480_debug, debug_610
    rx480_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_610:
  rx480_fail:
    (rx480_rep, rx480_pos, $I10, $P10) = rx480_cur."!mark_fail"(0)
    lt rx480_pos, -1, rx480_done
    eq rx480_pos, -1, rx480_fail
    jump $I10
  rx480_done:
    rx480_cur."!cursor_fail"()
    if_null rx480_debug, debug_611
    rx480_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_611:
    .return (rx480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("106_1299602538.98") :method
.annotate 'line', 4
    $P482 = self."!PREFIX__!subrule"("variable", "")
    new $P483, "ResizablePMCArray"
    push $P483, $P482
    .return ($P483)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("107_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx486_tgt
    .local int rx486_pos
    .local int rx486_off
    .local int rx486_eos
    .local int rx486_rep
    .local pmc rx486_cur
    .local pmc rx486_debug
    (rx486_cur, rx486_pos, rx486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx486_cur
    .local pmc match
    .lex "$/", match
    length rx486_eos, rx486_tgt
    gt rx486_pos, rx486_eos, rx486_done
    set rx486_off, 0
    lt rx486_pos, 2, rx486_start
    sub rx486_off, rx486_pos, 1
    substr rx486_tgt, rx486_tgt, rx486_off
  rx486_start:
    eq $I10, 1, rx486_restart
    if_null rx486_debug, debug_612
    rx486_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_612:
    $I10 = self.'from'()
    ne $I10, -1, rxscan490_done
    goto rxscan490_scan
  rxscan490_loop:
    (rx486_pos) = rx486_cur."from"()
    inc rx486_pos
    rx486_cur."!cursor_from"(rx486_pos)
    ge rx486_pos, rx486_eos, rxscan490_done
  rxscan490_scan:
    set_addr $I10, rxscan490_loop
    rx486_cur."!mark_push"(0, rx486_pos, $I10)
  rxscan490_done:
.annotate 'line', 259
  # rx subrule "package_declarator" subtype=capture negate=
    rx486_cur."!cursor_pos"(rx486_pos)
    $P10 = rx486_cur."package_declarator"()
    unless $P10, rx486_fail
    rx486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx486_pos = $P10."pos"()
  # rx pass
    rx486_cur."!cursor_pass"(rx486_pos, "term:sym<package_declarator>")
    if_null rx486_debug, debug_613
    rx486_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx486_pos)
  debug_613:
    .return (rx486_cur)
  rx486_restart:
.annotate 'line', 4
    if_null rx486_debug, debug_614
    rx486_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_614:
  rx486_fail:
    (rx486_rep, rx486_pos, $I10, $P10) = rx486_cur."!mark_fail"(0)
    lt rx486_pos, -1, rx486_done
    eq rx486_pos, -1, rx486_fail
    jump $I10
  rx486_done:
    rx486_cur."!cursor_fail"()
    if_null rx486_debug, debug_615
    rx486_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_615:
    .return (rx486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("108_1299602538.98") :method
.annotate 'line', 4
    $P488 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P489, "ResizablePMCArray"
    push $P489, $P488
    .return ($P489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("109_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx492_tgt
    .local int rx492_pos
    .local int rx492_off
    .local int rx492_eos
    .local int rx492_rep
    .local pmc rx492_cur
    .local pmc rx492_debug
    (rx492_cur, rx492_pos, rx492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx492_cur
    .local pmc match
    .lex "$/", match
    length rx492_eos, rx492_tgt
    gt rx492_pos, rx492_eos, rx492_done
    set rx492_off, 0
    lt rx492_pos, 2, rx492_start
    sub rx492_off, rx492_pos, 1
    substr rx492_tgt, rx492_tgt, rx492_off
  rx492_start:
    eq $I10, 1, rx492_restart
    if_null rx492_debug, debug_616
    rx492_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_616:
    $I10 = self.'from'()
    ne $I10, -1, rxscan496_done
    goto rxscan496_scan
  rxscan496_loop:
    (rx492_pos) = rx492_cur."from"()
    inc rx492_pos
    rx492_cur."!cursor_from"(rx492_pos)
    ge rx492_pos, rx492_eos, rxscan496_done
  rxscan496_scan:
    set_addr $I10, rxscan496_loop
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  rxscan496_done:
.annotate 'line', 260
  # rx subrule "scope_declarator" subtype=capture negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."scope_declarator"()
    unless $P10, rx492_fail
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx492_pos = $P10."pos"()
  # rx pass
    rx492_cur."!cursor_pass"(rx492_pos, "term:sym<scope_declarator>")
    if_null rx492_debug, debug_617
    rx492_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx492_pos)
  debug_617:
    .return (rx492_cur)
  rx492_restart:
.annotate 'line', 4
    if_null rx492_debug, debug_618
    rx492_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_618:
  rx492_fail:
    (rx492_rep, rx492_pos, $I10, $P10) = rx492_cur."!mark_fail"(0)
    lt rx492_pos, -1, rx492_done
    eq rx492_pos, -1, rx492_fail
    jump $I10
  rx492_done:
    rx492_cur."!cursor_fail"()
    if_null rx492_debug, debug_619
    rx492_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_619:
    .return (rx492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("110_1299602538.98") :method
.annotate 'line', 4
    $P494 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P495, "ResizablePMCArray"
    push $P495, $P494
    .return ($P495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("111_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx498_tgt
    .local int rx498_pos
    .local int rx498_off
    .local int rx498_eos
    .local int rx498_rep
    .local pmc rx498_cur
    .local pmc rx498_debug
    (rx498_cur, rx498_pos, rx498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx498_cur
    .local pmc match
    .lex "$/", match
    length rx498_eos, rx498_tgt
    gt rx498_pos, rx498_eos, rx498_done
    set rx498_off, 0
    lt rx498_pos, 2, rx498_start
    sub rx498_off, rx498_pos, 1
    substr rx498_tgt, rx498_tgt, rx498_off
  rx498_start:
    eq $I10, 1, rx498_restart
    if_null rx498_debug, debug_620
    rx498_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_620:
    $I10 = self.'from'()
    ne $I10, -1, rxscan502_done
    goto rxscan502_scan
  rxscan502_loop:
    (rx498_pos) = rx498_cur."from"()
    inc rx498_pos
    rx498_cur."!cursor_from"(rx498_pos)
    ge rx498_pos, rx498_eos, rxscan502_done
  rxscan502_scan:
    set_addr $I10, rxscan502_loop
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  rxscan502_done:
.annotate 'line', 261
  # rx subrule "routine_declarator" subtype=capture negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."routine_declarator"()
    unless $P10, rx498_fail
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx498_pos = $P10."pos"()
  # rx pass
    rx498_cur."!cursor_pass"(rx498_pos, "term:sym<routine_declarator>")
    if_null rx498_debug, debug_621
    rx498_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx498_pos)
  debug_621:
    .return (rx498_cur)
  rx498_restart:
.annotate 'line', 4
    if_null rx498_debug, debug_622
    rx498_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_622:
  rx498_fail:
    (rx498_rep, rx498_pos, $I10, $P10) = rx498_cur."!mark_fail"(0)
    lt rx498_pos, -1, rx498_done
    eq rx498_pos, -1, rx498_fail
    jump $I10
  rx498_done:
    rx498_cur."!cursor_fail"()
    if_null rx498_debug, debug_623
    rx498_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_623:
    .return (rx498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("112_1299602538.98") :method
.annotate 'line', 4
    $P500 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P501, "ResizablePMCArray"
    push $P501, $P500
    .return ($P501)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("113_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P514 = "116_1299602538.98" 
    capture_lex $P514
    .const 'Sub' $P509 = "115_1299602538.98" 
    capture_lex $P509
    .local string rx504_tgt
    .local int rx504_pos
    .local int rx504_off
    .local int rx504_eos
    .local int rx504_rep
    .local pmc rx504_cur
    .local pmc rx504_debug
    (rx504_cur, rx504_pos, rx504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx504_cur
    .local pmc match
    .lex "$/", match
    length rx504_eos, rx504_tgt
    gt rx504_pos, rx504_eos, rx504_done
    set rx504_off, 0
    lt rx504_pos, 2, rx504_start
    sub rx504_off, rx504_pos, 1
    substr rx504_tgt, rx504_tgt, rx504_off
  rx504_start:
    eq $I10, 1, rx504_restart
    if_null rx504_debug, debug_624
    rx504_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_624:
    $I10 = self.'from'()
    ne $I10, -1, rxscan507_done
    goto rxscan507_scan
  rxscan507_loop:
    (rx504_pos) = rx504_cur."from"()
    inc rx504_pos
    rx504_cur."!cursor_from"(rx504_pos)
    ge rx504_pos, rx504_eos, rxscan507_done
  rxscan507_scan:
    set_addr $I10, rxscan507_loop
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  rxscan507_done:
.annotate 'line', 263
  # rx subrule "before" subtype=zerowidth negate=
    rx504_cur."!cursor_pos"(rx504_pos)
    .const 'Sub' $P509 = "115_1299602538.98" 
    capture_lex $P509
    $P10 = rx504_cur."before"($P509)
    unless $P10, rx504_fail
.annotate 'line', 264
  # rx subrule "before" subtype=zerowidth negate=1
    rx504_cur."!cursor_pos"(rx504_pos)
    .const 'Sub' $P514 = "116_1299602538.98" 
    capture_lex $P514
    $P10 = rx504_cur."before"($P514)
    if $P10, rx504_fail
.annotate 'line', 265
  # rx subrule "multi_declarator" subtype=capture negate=
    rx504_cur."!cursor_pos"(rx504_pos)
    $P10 = rx504_cur."multi_declarator"()
    unless $P10, rx504_fail
    rx504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx504_pos = $P10."pos"()
.annotate 'line', 262
  # rx pass
    rx504_cur."!cursor_pass"(rx504_pos, "term:sym<multi_declarator>")
    if_null rx504_debug, debug_633
    rx504_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx504_pos)
  debug_633:
    .return (rx504_cur)
  rx504_restart:
.annotate 'line', 4
    if_null rx504_debug, debug_634
    rx504_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_634:
  rx504_fail:
    (rx504_rep, rx504_pos, $I10, $P10) = rx504_cur."!mark_fail"(0)
    lt rx504_pos, -1, rx504_done
    eq rx504_pos, -1, rx504_fail
    jump $I10
  rx504_done:
    rx504_cur."!cursor_fail"()
    if_null rx504_debug, debug_635
    rx504_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_635:
    .return (rx504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("114_1299602538.98") :method
.annotate 'line', 4
    new $P506, "ResizablePMCArray"
    push $P506, ""
    .return ($P506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block508"  :anon :subid("115_1299602538.98") :method :outer("113_1299602538.98")
.annotate 'line', 263
    .local string rx510_tgt
    .local int rx510_pos
    .local int rx510_off
    .local int rx510_eos
    .local int rx510_rep
    .local pmc rx510_cur
    .local pmc rx510_debug
    (rx510_cur, rx510_pos, rx510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx510_cur
    .local pmc match
    .lex "$/", match
    length rx510_eos, rx510_tgt
    gt rx510_pos, rx510_eos, rx510_done
    set rx510_off, 0
    lt rx510_pos, 2, rx510_start
    sub rx510_off, rx510_pos, 1
    substr rx510_tgt, rx510_tgt, rx510_off
  rx510_start:
    eq $I10, 1, rx510_restart
    if_null rx510_debug, debug_625
    rx510_cur."!cursor_debug"("START", "")
  debug_625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan511_done
    goto rxscan511_scan
  rxscan511_loop:
    (rx510_pos) = rx510_cur."from"()
    inc rx510_pos
    rx510_cur."!cursor_from"(rx510_pos)
    ge rx510_pos, rx510_eos, rxscan511_done
  rxscan511_scan:
    set_addr $I10, rxscan511_loop
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  rxscan511_done:
  alt512_0:
    set_addr $I10, alt512_1
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  # rx literal  "multi"
    add $I11, rx510_pos, 5
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 5
    ne $S10, "multi", rx510_fail
    add rx510_pos, 5
    goto alt512_end
  alt512_1:
    set_addr $I10, alt512_2
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  # rx literal  "proto"
    add $I11, rx510_pos, 5
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 5
    ne $S10, "proto", rx510_fail
    add rx510_pos, 5
    goto alt512_end
  alt512_2:
  # rx literal  "only"
    add $I11, rx510_pos, 4
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 4
    ne $S10, "only", rx510_fail
    add rx510_pos, 4
  alt512_end:
  # rx pass
    rx510_cur."!cursor_pass"(rx510_pos, "")
    if_null rx510_debug, debug_626
    rx510_cur."!cursor_debug"("PASS", "", " at pos=", rx510_pos)
  debug_626:
    .return (rx510_cur)
  rx510_restart:
    if_null rx510_debug, debug_627
    rx510_cur."!cursor_debug"("NEXT", "")
  debug_627:
  rx510_fail:
    (rx510_rep, rx510_pos, $I10, $P10) = rx510_cur."!mark_fail"(0)
    lt rx510_pos, -1, rx510_done
    eq rx510_pos, -1, rx510_fail
    jump $I10
  rx510_done:
    rx510_cur."!cursor_fail"()
    if_null rx510_debug, debug_628
    rx510_cur."!cursor_debug"("FAIL", "")
  debug_628:
    .return (rx510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block513"  :anon :subid("116_1299602538.98") :method :outer("113_1299602538.98")
.annotate 'line', 264
    .local string rx515_tgt
    .local int rx515_pos
    .local int rx515_off
    .local int rx515_eos
    .local int rx515_rep
    .local pmc rx515_cur
    .local pmc rx515_debug
    (rx515_cur, rx515_pos, rx515_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx515_cur
    .local pmc match
    .lex "$/", match
    length rx515_eos, rx515_tgt
    gt rx515_pos, rx515_eos, rx515_done
    set rx515_off, 0
    lt rx515_pos, 2, rx515_start
    sub rx515_off, rx515_pos, 1
    substr rx515_tgt, rx515_tgt, rx515_off
  rx515_start:
    eq $I10, 1, rx515_restart
    if_null rx515_debug, debug_629
    rx515_cur."!cursor_debug"("START", "")
  debug_629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan516_done
    goto rxscan516_scan
  rxscan516_loop:
    (rx515_pos) = rx515_cur."from"()
    inc rx515_pos
    rx515_cur."!cursor_from"(rx515_pos)
    ge rx515_pos, rx515_eos, rxscan516_done
  rxscan516_scan:
    set_addr $I10, rxscan516_loop
    rx515_cur."!mark_push"(0, rx515_pos, $I10)
  rxscan516_done:
  # rx literal  "proto"
    add $I11, rx515_pos, 5
    gt $I11, rx515_eos, rx515_fail
    sub $I11, rx515_pos, rx515_off
    substr $S10, rx515_tgt, $I11, 5
    ne $S10, "proto", rx515_fail
    add rx515_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx515_cur."!cursor_pos"(rx515_pos)
    $P10 = rx515_cur."ws"()
    unless $P10, rx515_fail
    rx515_pos = $P10."pos"()
  alt517_0:
    set_addr $I10, alt517_1
    rx515_cur."!mark_push"(0, rx515_pos, $I10)
  # rx literal  "regex"
    add $I11, rx515_pos, 5
    gt $I11, rx515_eos, rx515_fail
    sub $I11, rx515_pos, rx515_off
    substr $S10, rx515_tgt, $I11, 5
    ne $S10, "regex", rx515_fail
    add rx515_pos, 5
    goto alt517_end
  alt517_1:
    set_addr $I10, alt517_2
    rx515_cur."!mark_push"(0, rx515_pos, $I10)
  # rx literal  "token"
    add $I11, rx515_pos, 5
    gt $I11, rx515_eos, rx515_fail
    sub $I11, rx515_pos, rx515_off
    substr $S10, rx515_tgt, $I11, 5
    ne $S10, "token", rx515_fail
    add rx515_pos, 5
    goto alt517_end
  alt517_2:
  # rx literal  "rule"
    add $I11, rx515_pos, 4
    gt $I11, rx515_eos, rx515_fail
    sub $I11, rx515_pos, rx515_off
    substr $S10, rx515_tgt, $I11, 4
    ne $S10, "rule", rx515_fail
    add rx515_pos, 4
  alt517_end:
  # rx pass
    rx515_cur."!cursor_pass"(rx515_pos, "")
    if_null rx515_debug, debug_630
    rx515_cur."!cursor_debug"("PASS", "", " at pos=", rx515_pos)
  debug_630:
    .return (rx515_cur)
  rx515_restart:
    if_null rx515_debug, debug_631
    rx515_cur."!cursor_debug"("NEXT", "")
  debug_631:
  rx515_fail:
    (rx515_rep, rx515_pos, $I10, $P10) = rx515_cur."!mark_fail"(0)
    lt rx515_pos, -1, rx515_done
    eq rx515_pos, -1, rx515_fail
    jump $I10
  rx515_done:
    rx515_cur."!cursor_fail"()
    if_null rx515_debug, debug_632
    rx515_cur."!cursor_debug"("FAIL", "")
  debug_632:
    .return (rx515_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("117_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx519_tgt
    .local int rx519_pos
    .local int rx519_off
    .local int rx519_eos
    .local int rx519_rep
    .local pmc rx519_cur
    .local pmc rx519_debug
    (rx519_cur, rx519_pos, rx519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx519_cur
    .local pmc match
    .lex "$/", match
    length rx519_eos, rx519_tgt
    gt rx519_pos, rx519_eos, rx519_done
    set rx519_off, 0
    lt rx519_pos, 2, rx519_start
    sub rx519_off, rx519_pos, 1
    substr rx519_tgt, rx519_tgt, rx519_off
  rx519_start:
    eq $I10, 1, rx519_restart
    if_null rx519_debug, debug_636
    rx519_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan523_done
    goto rxscan523_scan
  rxscan523_loop:
    (rx519_pos) = rx519_cur."from"()
    inc rx519_pos
    rx519_cur."!cursor_from"(rx519_pos)
    ge rx519_pos, rx519_eos, rxscan523_done
  rxscan523_scan:
    set_addr $I10, rxscan523_loop
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
  rxscan523_done:
.annotate 'line', 267
  # rx subrule "regex_declarator" subtype=capture negate=
    rx519_cur."!cursor_pos"(rx519_pos)
    $P10 = rx519_cur."regex_declarator"()
    unless $P10, rx519_fail
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx519_pos = $P10."pos"()
  # rx pass
    rx519_cur."!cursor_pass"(rx519_pos, "term:sym<regex_declarator>")
    if_null rx519_debug, debug_637
    rx519_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx519_pos)
  debug_637:
    .return (rx519_cur)
  rx519_restart:
.annotate 'line', 4
    if_null rx519_debug, debug_638
    rx519_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_638:
  rx519_fail:
    (rx519_rep, rx519_pos, $I10, $P10) = rx519_cur."!mark_fail"(0)
    lt rx519_pos, -1, rx519_done
    eq rx519_pos, -1, rx519_fail
    jump $I10
  rx519_done:
    rx519_cur."!cursor_fail"()
    if_null rx519_debug, debug_639
    rx519_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_639:
    .return (rx519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("118_1299602538.98") :method
.annotate 'line', 4
    $P521 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P522, "ResizablePMCArray"
    push $P522, $P521
    .return ($P522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("119_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx525_tgt
    .local int rx525_pos
    .local int rx525_off
    .local int rx525_eos
    .local int rx525_rep
    .local pmc rx525_cur
    .local pmc rx525_debug
    (rx525_cur, rx525_pos, rx525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx525_cur
    .local pmc match
    .lex "$/", match
    length rx525_eos, rx525_tgt
    gt rx525_pos, rx525_eos, rx525_done
    set rx525_off, 0
    lt rx525_pos, 2, rx525_start
    sub rx525_off, rx525_pos, 1
    substr rx525_tgt, rx525_tgt, rx525_off
  rx525_start:
    eq $I10, 1, rx525_restart
    if_null rx525_debug, debug_640
    rx525_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_640:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx525_pos) = rx525_cur."from"()
    inc rx525_pos
    rx525_cur."!cursor_from"(rx525_pos)
    ge rx525_pos, rx525_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx525_cur."!mark_push"(0, rx525_pos, $I10)
  rxscan529_done:
.annotate 'line', 268
  # rx subrule "statement_prefix" subtype=capture negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."statement_prefix"()
    unless $P10, rx525_fail
    rx525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx525_pos = $P10."pos"()
  # rx pass
    rx525_cur."!cursor_pass"(rx525_pos, "term:sym<statement_prefix>")
    if_null rx525_debug, debug_641
    rx525_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx525_pos)
  debug_641:
    .return (rx525_cur)
  rx525_restart:
.annotate 'line', 4
    if_null rx525_debug, debug_642
    rx525_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_642:
  rx525_fail:
    (rx525_rep, rx525_pos, $I10, $P10) = rx525_cur."!mark_fail"(0)
    lt rx525_pos, -1, rx525_done
    eq rx525_pos, -1, rx525_fail
    jump $I10
  rx525_done:
    rx525_cur."!cursor_fail"()
    if_null rx525_debug, debug_643
    rx525_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_643:
    .return (rx525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("120_1299602538.98") :method
.annotate 'line', 4
    $P527 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P528, "ResizablePMCArray"
    push $P528, $P527
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("121_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx531_tgt
    .local int rx531_pos
    .local int rx531_off
    .local int rx531_eos
    .local int rx531_rep
    .local pmc rx531_cur
    .local pmc rx531_debug
    (rx531_cur, rx531_pos, rx531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx531_cur
    .local pmc match
    .lex "$/", match
    length rx531_eos, rx531_tgt
    gt rx531_pos, rx531_eos, rx531_done
    set rx531_off, 0
    lt rx531_pos, 2, rx531_start
    sub rx531_off, rx531_pos, 1
    substr rx531_tgt, rx531_tgt, rx531_off
  rx531_start:
    eq $I10, 1, rx531_restart
    if_null rx531_debug, debug_644
    rx531_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan534_done
    goto rxscan534_scan
  rxscan534_loop:
    (rx531_pos) = rx531_cur."from"()
    inc rx531_pos
    rx531_cur."!cursor_from"(rx531_pos)
    ge rx531_pos, rx531_eos, rxscan534_done
  rxscan534_scan:
    set_addr $I10, rxscan534_loop
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  rxscan534_done:
.annotate 'line', 269
  # rx subrule "lambda" subtype=zerowidth negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."lambda"()
    unless $P10, rx531_fail
  # rx subrule "pblock" subtype=capture negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."pblock"()
    unless $P10, rx531_fail
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx531_pos = $P10."pos"()
  # rx pass
    rx531_cur."!cursor_pass"(rx531_pos, "term:sym<lambda>")
    if_null rx531_debug, debug_645
    rx531_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx531_pos)
  debug_645:
    .return (rx531_cur)
  rx531_restart:
.annotate 'line', 4
    if_null rx531_debug, debug_646
    rx531_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_646:
  rx531_fail:
    (rx531_rep, rx531_pos, $I10, $P10) = rx531_cur."!mark_fail"(0)
    lt rx531_pos, -1, rx531_done
    eq rx531_pos, -1, rx531_fail
    jump $I10
  rx531_done:
    rx531_cur."!cursor_fail"()
    if_null rx531_debug, debug_647
    rx531_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_647:
    .return (rx531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("122_1299602538.98") :method
.annotate 'line', 4
    new $P533, "ResizablePMCArray"
    push $P533, ""
    .return ($P533)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("123_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_648
    rx536_cur."!cursor_debug"("START", "fatarrow")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan540_done
    goto rxscan540_scan
  rxscan540_loop:
    (rx536_pos) = rx536_cur."from"()
    inc rx536_pos
    rx536_cur."!cursor_from"(rx536_pos)
    ge rx536_pos, rx536_eos, rxscan540_done
  rxscan540_scan:
    set_addr $I10, rxscan540_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan540_done:
.annotate 'line', 272
  # rx subrule "identifier" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."identifier"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx536_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx536_pos, rx536_off
    set rx536_rep, 0
    sub $I12, rx536_eos, rx536_pos
  rxenumcharlistq541_loop:
    le $I12, 0, rxenumcharlistq541_done
    substr $S10, rx536_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq541_done
    inc rx536_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq541_loop
  rxenumcharlistq541_done:
    add rx536_pos, rx536_pos, rx536_rep
  # rx literal  "=>"
    add $I11, rx536_pos, 2
    gt $I11, rx536_eos, rx536_fail
    sub $I11, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I11, 2
    ne $S10, "=>", rx536_fail
    add rx536_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."ws"()
    unless $P10, rx536_fail
    rx536_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."EXPR"("i=")
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx536_pos = $P10."pos"()
.annotate 'line', 271
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "fatarrow")
    if_null rx536_debug, debug_649
    rx536_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx536_pos)
  debug_649:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 4
    if_null rx536_debug, debug_650
    rx536_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_650:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_651
    rx536_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_651:
    .return (rx536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("124_1299602538.98") :method
.annotate 'line', 4
    $P538 = self."!PREFIX__!subrule"("identifier", "")
    new $P539, "ResizablePMCArray"
    push $P539, $P538
    .return ($P539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("125_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx543_tgt
    .local int rx543_pos
    .local int rx543_off
    .local int rx543_eos
    .local int rx543_rep
    .local pmc rx543_cur
    .local pmc rx543_debug
    (rx543_cur, rx543_pos, rx543_tgt, $I10) = self."!cursor_start"()
    rx543_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx543_cur
    .local pmc match
    .lex "$/", match
    length rx543_eos, rx543_tgt
    gt rx543_pos, rx543_eos, rx543_done
    set rx543_off, 0
    lt rx543_pos, 2, rx543_start
    sub rx543_off, rx543_pos, 1
    substr rx543_tgt, rx543_tgt, rx543_off
  rx543_start:
    eq $I10, 1, rx543_restart
    if_null rx543_debug, debug_652
    rx543_cur."!cursor_debug"("START", "colonpair")
  debug_652:
    $I10 = self.'from'()
    ne $I10, -1, rxscan549_done
    goto rxscan549_scan
  rxscan549_loop:
    (rx543_pos) = rx543_cur."from"()
    inc rx543_pos
    rx543_cur."!cursor_from"(rx543_pos)
    ge rx543_pos, rx543_eos, rxscan549_done
  rxscan549_scan:
    set_addr $I10, rxscan549_loop
    rx543_cur."!mark_push"(0, rx543_pos, $I10)
  rxscan549_done:
.annotate 'line', 276
  # rx literal  ":"
    add $I11, rx543_pos, 1
    gt $I11, rx543_eos, rx543_fail
    sub $I11, rx543_pos, rx543_off
    ord $I11, rx543_tgt, $I11
    ne $I11, 58, rx543_fail
    add rx543_pos, 1
  alt550_0:
.annotate 'line', 277
    set_addr $I10, alt550_1
    rx543_cur."!mark_push"(0, rx543_pos, $I10)
.annotate 'line', 278
  # rx subcapture "not"
    set_addr $I10, rxcap_551_fail
    rx543_cur."!mark_push"(0, rx543_pos, $I10)
  # rx literal  "!"
    add $I11, rx543_pos, 1
    gt $I11, rx543_eos, rx543_fail
    sub $I11, rx543_pos, rx543_off
    ord $I11, rx543_tgt, $I11
    ne $I11, 33, rx543_fail
    add rx543_pos, 1
    set_addr $I10, rxcap_551_fail
    ($I12, $I11) = rx543_cur."!mark_peek"($I10)
    rx543_cur."!cursor_pos"($I11)
    ($P10) = rx543_cur."!cursor_start"()
    $P10."!cursor_pass"(rx543_pos, "")
    rx543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_551_done
  rxcap_551_fail:
    goto rx543_fail
  rxcap_551_done:
  # rx subrule "identifier" subtype=capture negate=
    rx543_cur."!cursor_pos"(rx543_pos)
    $P10 = rx543_cur."identifier"()
    unless $P10, rx543_fail
    rx543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx543_pos = $P10."pos"()
    goto alt550_end
  alt550_1:
    set_addr $I10, alt550_2
    rx543_cur."!mark_push"(0, rx543_pos, $I10)
.annotate 'line', 279
  # rx subrule "identifier" subtype=capture negate=
    rx543_cur."!cursor_pos"(rx543_pos)
    $P10 = rx543_cur."identifier"()
    unless $P10, rx543_fail
    rx543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx543_pos = $P10."pos"()
  # rx rxquantr552 ** 0..1
    set_addr $I10, rxquantr552_done
    rx543_cur."!mark_push"(0, rx543_pos, $I10)
  rxquantr552_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx543_cur."!cursor_pos"(rx543_pos)
    $P10 = rx543_cur."circumfix"()
    unless $P10, rx543_fail
    goto rxsubrule553_pass
  rxsubrule553_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx543_fail
  rxsubrule553_pass:
    set_addr $I10, rxsubrule553_back
    rx543_cur."!mark_push"(0, rx543_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx543_pos = $P10."pos"()
    set_addr $I10, rxquantr552_done
    (rx543_rep) = rx543_cur."!mark_commit"($I10)
  rxquantr552_done:
    goto alt550_end
  alt550_2:
.annotate 'line', 280
  # rx subrule "circumfix" subtype=capture negate=
    rx543_cur."!cursor_pos"(rx543_pos)
    $P10 = rx543_cur."circumfix"()
    unless $P10, rx543_fail
    rx543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx543_pos = $P10."pos"()
  alt550_end:
.annotate 'line', 275
  # rx pass
    rx543_cur."!cursor_pass"(rx543_pos, "colonpair")
    if_null rx543_debug, debug_653
    rx543_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx543_pos)
  debug_653:
    .return (rx543_cur)
  rx543_restart:
.annotate 'line', 4
    if_null rx543_debug, debug_654
    rx543_cur."!cursor_debug"("NEXT", "colonpair")
  debug_654:
  rx543_fail:
    (rx543_rep, rx543_pos, $I10, $P10) = rx543_cur."!mark_fail"(0)
    lt rx543_pos, -1, rx543_done
    eq rx543_pos, -1, rx543_fail
    jump $I10
  rx543_done:
    rx543_cur."!cursor_fail"()
    if_null rx543_debug, debug_655
    rx543_cur."!cursor_debug"("FAIL", "colonpair")
  debug_655:
    .return (rx543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("126_1299602538.98") :method
.annotate 'line', 4
    $P545 = self."!PREFIX__!subrule"("circumfix", ":")
    $P546 = self."!PREFIX__!subrule"("identifier", ":")
    $P547 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P548, "ResizablePMCArray"
    push $P548, $P545
    push $P548, $P546
    push $P548, $P547
    .return ($P548)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("127_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx555_tgt
    .local int rx555_pos
    .local int rx555_off
    .local int rx555_eos
    .local int rx555_rep
    .local pmc rx555_cur
    .local pmc rx555_debug
    (rx555_cur, rx555_pos, rx555_tgt, $I10) = self."!cursor_start"()
    rx555_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx555_cur
    .local pmc match
    .lex "$/", match
    length rx555_eos, rx555_tgt
    gt rx555_pos, rx555_eos, rx555_done
    set rx555_off, 0
    lt rx555_pos, 2, rx555_start
    sub rx555_off, rx555_pos, 1
    substr rx555_tgt, rx555_tgt, rx555_off
  rx555_start:
    eq $I10, 1, rx555_restart
    if_null rx555_debug, debug_656
    rx555_cur."!cursor_debug"("START", "variable")
  debug_656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan560_done
    goto rxscan560_scan
  rxscan560_loop:
    (rx555_pos) = rx555_cur."from"()
    inc rx555_pos
    rx555_cur."!cursor_from"(rx555_pos)
    ge rx555_pos, rx555_eos, rxscan560_done
  rxscan560_scan:
    set_addr $I10, rxscan560_loop
    rx555_cur."!mark_push"(0, rx555_pos, $I10)
  rxscan560_done:
  alt561_0:
.annotate 'line', 284
    set_addr $I10, alt561_1
    rx555_cur."!mark_push"(0, rx555_pos, $I10)
.annotate 'line', 285
  # rx subrule "sigil" subtype=capture negate=
    rx555_cur."!cursor_pos"(rx555_pos)
    $P10 = rx555_cur."sigil"()
    unless $P10, rx555_fail
    rx555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx555_pos = $P10."pos"()
  # rx rxquantr562 ** 0..1
    set_addr $I10, rxquantr562_done
    rx555_cur."!mark_push"(0, rx555_pos, $I10)
  rxquantr562_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx555_cur."!cursor_pos"(rx555_pos)
    $P10 = rx555_cur."twigil"()
    unless $P10, rx555_fail
    goto rxsubrule563_pass
  rxsubrule563_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx555_fail
  rxsubrule563_pass:
    set_addr $I10, rxsubrule563_back
    rx555_cur."!mark_push"(0, rx555_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx555_pos = $P10."pos"()
    set_addr $I10, rxquantr562_done
    (rx555_rep) = rx555_cur."!mark_commit"($I10)
  rxquantr562_done:
  # rx subrule "name" subtype=capture negate=
    rx555_cur."!cursor_pos"(rx555_pos)
    $P10 = rx555_cur."name"()
    unless $P10, rx555_fail
    rx555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx555_pos = $P10."pos"()
    goto alt561_end
  alt561_1:
    set_addr $I10, alt561_2
    rx555_cur."!mark_push"(0, rx555_pos, $I10)
.annotate 'line', 286
  # rx subrule "sigil" subtype=capture negate=
    rx555_cur."!cursor_pos"(rx555_pos)
    $P10 = rx555_cur."sigil"()
    unless $P10, rx555_fail
    rx555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx555_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx555_pos, rx555_off
    substr $S10, rx555_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx555_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx555_cur."!cursor_pos"(rx555_pos)
    $P10 = rx555_cur."postcircumfix"()
    unless $P10, rx555_fail
    rx555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx555_pos = $P10."pos"()
    goto alt561_end
  alt561_2:
.annotate 'line', 287
  # rx subcapture "sigil"
    set_addr $I10, rxcap_564_fail
    rx555_cur."!mark_push"(0, rx555_pos, $I10)
  # rx literal  "$"
    add $I11, rx555_pos, 1
    gt $I11, rx555_eos, rx555_fail
    sub $I11, rx555_pos, rx555_off
    ord $I11, rx555_tgt, $I11
    ne $I11, 36, rx555_fail
    add rx555_pos, 1
    set_addr $I10, rxcap_564_fail
    ($I12, $I11) = rx555_cur."!mark_peek"($I10)
    rx555_cur."!cursor_pos"($I11)
    ($P10) = rx555_cur."!cursor_start"()
    $P10."!cursor_pass"(rx555_pos, "")
    rx555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_564_done
  rxcap_564_fail:
    goto rx555_fail
  rxcap_564_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_565_fail
    rx555_cur."!mark_push"(0, rx555_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx555_pos, rx555_eos, rx555_fail
    sub $I10, rx555_pos, rx555_off
    substr $S10, rx555_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx555_fail
    inc rx555_pos
    set_addr $I10, rxcap_565_fail
    ($I12, $I11) = rx555_cur."!mark_peek"($I10)
    rx555_cur."!cursor_pos"($I11)
    ($P10) = rx555_cur."!cursor_start"()
    $P10."!cursor_pass"(rx555_pos, "")
    rx555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_565_done
  rxcap_565_fail:
    goto rx555_fail
  rxcap_565_done:
  alt561_end:
.annotate 'line', 284
  # rx pass
    rx555_cur."!cursor_pass"(rx555_pos, "variable")
    if_null rx555_debug, debug_657
    rx555_cur."!cursor_debug"("PASS", "variable", " at pos=", rx555_pos)
  debug_657:
    .return (rx555_cur)
  rx555_restart:
.annotate 'line', 4
    if_null rx555_debug, debug_658
    rx555_cur."!cursor_debug"("NEXT", "variable")
  debug_658:
  rx555_fail:
    (rx555_rep, rx555_pos, $I10, $P10) = rx555_cur."!mark_fail"(0)
    lt rx555_pos, -1, rx555_done
    eq rx555_pos, -1, rx555_fail
    jump $I10
  rx555_done:
    rx555_cur."!cursor_fail"()
    if_null rx555_debug, debug_659
    rx555_cur."!cursor_debug"("FAIL", "variable")
  debug_659:
    .return (rx555_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("128_1299602538.98") :method
.annotate 'line', 4
    $P557 = self."!PREFIX__!subrule"("sigil", "")
    $P558 = self."!PREFIX__!subrule"("sigil", "")
    new $P559, "ResizablePMCArray"
    push $P559, "$!"
    push $P559, "$_"
    push $P559, "$/"
    push $P559, $P557
    push $P559, $P558
    .return ($P559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("129_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx567_tgt
    .local int rx567_pos
    .local int rx567_off
    .local int rx567_eos
    .local int rx567_rep
    .local pmc rx567_cur
    .local pmc rx567_debug
    (rx567_cur, rx567_pos, rx567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx567_cur
    .local pmc match
    .lex "$/", match
    length rx567_eos, rx567_tgt
    gt rx567_pos, rx567_eos, rx567_done
    set rx567_off, 0
    lt rx567_pos, 2, rx567_start
    sub rx567_off, rx567_pos, 1
    substr rx567_tgt, rx567_tgt, rx567_off
  rx567_start:
    eq $I10, 1, rx567_restart
    if_null rx567_debug, debug_660
    rx567_cur."!cursor_debug"("START", "sigil")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan570_done
    goto rxscan570_scan
  rxscan570_loop:
    (rx567_pos) = rx567_cur."from"()
    inc rx567_pos
    rx567_cur."!cursor_from"(rx567_pos)
    ge rx567_pos, rx567_eos, rxscan570_done
  rxscan570_scan:
    set_addr $I10, rxscan570_loop
    rx567_cur."!mark_push"(0, rx567_pos, $I10)
  rxscan570_done:
.annotate 'line', 290
  # rx enumcharlist negate=0 
    ge rx567_pos, rx567_eos, rx567_fail
    sub $I10, rx567_pos, rx567_off
    substr $S10, rx567_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx567_fail
    inc rx567_pos
  # rx pass
    rx567_cur."!cursor_pass"(rx567_pos, "sigil")
    if_null rx567_debug, debug_661
    rx567_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx567_pos)
  debug_661:
    .return (rx567_cur)
  rx567_restart:
.annotate 'line', 4
    if_null rx567_debug, debug_662
    rx567_cur."!cursor_debug"("NEXT", "sigil")
  debug_662:
  rx567_fail:
    (rx567_rep, rx567_pos, $I10, $P10) = rx567_cur."!mark_fail"(0)
    lt rx567_pos, -1, rx567_done
    eq rx567_pos, -1, rx567_fail
    jump $I10
  rx567_done:
    rx567_cur."!cursor_fail"()
    if_null rx567_debug, debug_663
    rx567_cur."!cursor_debug"("FAIL", "sigil")
  debug_663:
    .return (rx567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("130_1299602538.98") :method
.annotate 'line', 4
    new $P569, "ResizablePMCArray"
    push $P569, "&"
    push $P569, "%"
    push $P569, "@"
    push $P569, "$"
    .return ($P569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("131_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx572_tgt
    .local int rx572_pos
    .local int rx572_off
    .local int rx572_eos
    .local int rx572_rep
    .local pmc rx572_cur
    .local pmc rx572_debug
    (rx572_cur, rx572_pos, rx572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx572_cur
    .local pmc match
    .lex "$/", match
    length rx572_eos, rx572_tgt
    gt rx572_pos, rx572_eos, rx572_done
    set rx572_off, 0
    lt rx572_pos, 2, rx572_start
    sub rx572_off, rx572_pos, 1
    substr rx572_tgt, rx572_tgt, rx572_off
  rx572_start:
    eq $I10, 1, rx572_restart
    if_null rx572_debug, debug_664
    rx572_cur."!cursor_debug"("START", "twigil")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan575_done
    goto rxscan575_scan
  rxscan575_loop:
    (rx572_pos) = rx572_cur."from"()
    inc rx572_pos
    rx572_cur."!cursor_from"(rx572_pos)
    ge rx572_pos, rx572_eos, rxscan575_done
  rxscan575_scan:
    set_addr $I10, rxscan575_loop
    rx572_cur."!mark_push"(0, rx572_pos, $I10)
  rxscan575_done:
.annotate 'line', 292
  # rx enumcharlist negate=0 
    ge rx572_pos, rx572_eos, rx572_fail
    sub $I10, rx572_pos, rx572_off
    substr $S10, rx572_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx572_fail
    inc rx572_pos
  # rx pass
    rx572_cur."!cursor_pass"(rx572_pos, "twigil")
    if_null rx572_debug, debug_665
    rx572_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx572_pos)
  debug_665:
    .return (rx572_cur)
  rx572_restart:
.annotate 'line', 4
    if_null rx572_debug, debug_666
    rx572_cur."!cursor_debug"("NEXT", "twigil")
  debug_666:
  rx572_fail:
    (rx572_rep, rx572_pos, $I10, $P10) = rx572_cur."!mark_fail"(0)
    lt rx572_pos, -1, rx572_done
    eq rx572_pos, -1, rx572_fail
    jump $I10
  rx572_done:
    rx572_cur."!cursor_fail"()
    if_null rx572_debug, debug_667
    rx572_cur."!cursor_debug"("FAIL", "twigil")
  debug_667:
    .return (rx572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("132_1299602538.98") :method
.annotate 'line', 4
    new $P574, "ResizablePMCArray"
    push $P574, "?"
    push $P574, "!"
    push $P574, "*"
    .return ($P574)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("133_1299602538.98")
    .param pmc param_577
.annotate 'line', 294
    .lex "self", param_577
    $P578 = param_577."!protoregex"("package_declarator")
    .return ($P578)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("134_1299602538.98")
    .param pmc param_580
.annotate 'line', 294
    .lex "self", param_580
    $P581 = param_580."!PREFIX__!protoregex"("package_declarator")
    .return ($P581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("135_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 296
    new $P583, "Undef"
    .lex "$*PACKAGE-SETUP", $P583
.annotate 'line', 297
    new $P584, "Undef"
    .lex "$*PKGDECL", $P584
.annotate 'line', 4
    .local string rx585_tgt
    .local int rx585_pos
    .local int rx585_off
    .local int rx585_eos
    .local int rx585_rep
    .local pmc rx585_cur
    .local pmc rx585_debug
    (rx585_cur, rx585_pos, rx585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx585_cur
    .local pmc match
    .lex "$/", match
    length rx585_eos, rx585_tgt
    gt rx585_pos, rx585_eos, rx585_done
    set rx585_off, 0
    lt rx585_pos, 2, rx585_start
    sub rx585_off, rx585_pos, 1
    substr rx585_tgt, rx585_tgt, rx585_off
  rx585_start:
    eq $I10, 1, rx585_restart
    if_null rx585_debug, debug_668
    rx585_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan589_done
    goto rxscan589_scan
  rxscan589_loop:
    (rx585_pos) = rx585_cur."from"()
    inc rx585_pos
    rx585_cur."!cursor_from"(rx585_pos)
    ge rx585_pos, rx585_eos, rxscan589_done
  rxscan589_scan:
    set_addr $I10, rxscan589_loop
    rx585_cur."!mark_push"(0, rx585_pos, $I10)
  rxscan589_done:
.annotate 'line', 296
    rx585_cur."!cursor_pos"(rx585_pos)
    get_hll_global $P590, ["PAST"], "Stmts"
    $P591 = $P590."new"()
    store_lex "$*PACKAGE-SETUP", $P591
.annotate 'line', 297
    rx585_cur."!cursor_pos"(rx585_pos)
    new $P592, "String"
    assign $P592, "module"
    store_lex "$*PKGDECL", $P592
.annotate 'line', 298
  # rx subcapture "sym"
    set_addr $I10, rxcap_593_fail
    rx585_cur."!mark_push"(0, rx585_pos, $I10)
  # rx literal  "module"
    add $I11, rx585_pos, 6
    gt $I11, rx585_eos, rx585_fail
    sub $I11, rx585_pos, rx585_off
    substr $S10, rx585_tgt, $I11, 6
    ne $S10, "module", rx585_fail
    add rx585_pos, 6
    set_addr $I10, rxcap_593_fail
    ($I12, $I11) = rx585_cur."!mark_peek"($I10)
    rx585_cur."!cursor_pos"($I11)
    ($P10) = rx585_cur."!cursor_start"()
    $P10."!cursor_pass"(rx585_pos, "")
    rx585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_593_done
  rxcap_593_fail:
    goto rx585_fail
  rxcap_593_done:
  # rx subrule "package_def" subtype=capture negate=
    rx585_cur."!cursor_pos"(rx585_pos)
    $P10 = rx585_cur."package_def"()
    unless $P10, rx585_fail
    rx585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx585_pos = $P10."pos"()
.annotate 'line', 295
  # rx pass
    rx585_cur."!cursor_pass"(rx585_pos, "package_declarator:sym<module>")
    if_null rx585_debug, debug_669
    rx585_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx585_pos)
  debug_669:
    .return (rx585_cur)
  rx585_restart:
.annotate 'line', 4
    if_null rx585_debug, debug_670
    rx585_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_670:
  rx585_fail:
    (rx585_rep, rx585_pos, $I10, $P10) = rx585_cur."!mark_fail"(0)
    lt rx585_pos, -1, rx585_done
    eq rx585_pos, -1, rx585_fail
    jump $I10
  rx585_done:
    rx585_cur."!cursor_fail"()
    if_null rx585_debug, debug_671
    rx585_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_671:
    .return (rx585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("136_1299602538.98") :method
.annotate 'line', 4
    $P587 = self."!PREFIX__!subrule"("package_def", "module")
    new $P588, "ResizablePMCArray"
    push $P588, $P587
    .return ($P588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("137_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 301
    new $P595, "Undef"
    .lex "$*PACKAGE-SETUP", $P595
.annotate 'line', 302
    new $P596, "Undef"
    .lex "$*PKGDECL", $P596
.annotate 'line', 4
    .local string rx597_tgt
    .local int rx597_pos
    .local int rx597_off
    .local int rx597_eos
    .local int rx597_rep
    .local pmc rx597_cur
    .local pmc rx597_debug
    (rx597_cur, rx597_pos, rx597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx597_cur
    .local pmc match
    .lex "$/", match
    length rx597_eos, rx597_tgt
    gt rx597_pos, rx597_eos, rx597_done
    set rx597_off, 0
    lt rx597_pos, 2, rx597_start
    sub rx597_off, rx597_pos, 1
    substr rx597_tgt, rx597_tgt, rx597_off
  rx597_start:
    eq $I10, 1, rx597_restart
    if_null rx597_debug, debug_672
    rx597_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan601_done
    goto rxscan601_scan
  rxscan601_loop:
    (rx597_pos) = rx597_cur."from"()
    inc rx597_pos
    rx597_cur."!cursor_from"(rx597_pos)
    ge rx597_pos, rx597_eos, rxscan601_done
  rxscan601_scan:
    set_addr $I10, rxscan601_loop
    rx597_cur."!mark_push"(0, rx597_pos, $I10)
  rxscan601_done:
.annotate 'line', 301
    rx597_cur."!cursor_pos"(rx597_pos)
    get_hll_global $P602, ["PAST"], "Stmts"
    $P603 = $P602."new"()
    store_lex "$*PACKAGE-SETUP", $P603
.annotate 'line', 302
    rx597_cur."!cursor_pos"(rx597_pos)
    new $P604, "String"
    assign $P604, "knowhow"
    store_lex "$*PKGDECL", $P604
.annotate 'line', 303
  # rx subcapture "sym"
    set_addr $I10, rxcap_605_fail
    rx597_cur."!mark_push"(0, rx597_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx597_pos, 7
    gt $I11, rx597_eos, rx597_fail
    sub $I11, rx597_pos, rx597_off
    substr $S10, rx597_tgt, $I11, 7
    ne $S10, "knowhow", rx597_fail
    add rx597_pos, 7
    set_addr $I10, rxcap_605_fail
    ($I12, $I11) = rx597_cur."!mark_peek"($I10)
    rx597_cur."!cursor_pos"($I11)
    ($P10) = rx597_cur."!cursor_start"()
    $P10."!cursor_pass"(rx597_pos, "")
    rx597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_605_done
  rxcap_605_fail:
    goto rx597_fail
  rxcap_605_done:
  # rx subrule "package_def" subtype=capture negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."package_def"()
    unless $P10, rx597_fail
    rx597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx597_pos = $P10."pos"()
.annotate 'line', 300
  # rx pass
    rx597_cur."!cursor_pass"(rx597_pos, "package_declarator:sym<knowhow>")
    if_null rx597_debug, debug_673
    rx597_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx597_pos)
  debug_673:
    .return (rx597_cur)
  rx597_restart:
.annotate 'line', 4
    if_null rx597_debug, debug_674
    rx597_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_674:
  rx597_fail:
    (rx597_rep, rx597_pos, $I10, $P10) = rx597_cur."!mark_fail"(0)
    lt rx597_pos, -1, rx597_done
    eq rx597_pos, -1, rx597_fail
    jump $I10
  rx597_done:
    rx597_cur."!cursor_fail"()
    if_null rx597_debug, debug_675
    rx597_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_675:
    .return (rx597_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("138_1299602538.98") :method
.annotate 'line', 4
    $P599 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P600, "ResizablePMCArray"
    push $P600, $P599
    .return ($P600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("139_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 306
    new $P607, "Undef"
    .lex "$*PACKAGE-SETUP", $P607
.annotate 'line', 307
    new $P608, "Undef"
    .lex "$*PKGDECL", $P608
.annotate 'line', 4
    .local string rx609_tgt
    .local int rx609_pos
    .local int rx609_off
    .local int rx609_eos
    .local int rx609_rep
    .local pmc rx609_cur
    .local pmc rx609_debug
    (rx609_cur, rx609_pos, rx609_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx609_cur
    .local pmc match
    .lex "$/", match
    length rx609_eos, rx609_tgt
    gt rx609_pos, rx609_eos, rx609_done
    set rx609_off, 0
    lt rx609_pos, 2, rx609_start
    sub rx609_off, rx609_pos, 1
    substr rx609_tgt, rx609_tgt, rx609_off
  rx609_start:
    eq $I10, 1, rx609_restart
    if_null rx609_debug, debug_676
    rx609_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan613_done
    goto rxscan613_scan
  rxscan613_loop:
    (rx609_pos) = rx609_cur."from"()
    inc rx609_pos
    rx609_cur."!cursor_from"(rx609_pos)
    ge rx609_pos, rx609_eos, rxscan613_done
  rxscan613_scan:
    set_addr $I10, rxscan613_loop
    rx609_cur."!mark_push"(0, rx609_pos, $I10)
  rxscan613_done:
.annotate 'line', 306
    rx609_cur."!cursor_pos"(rx609_pos)
    get_hll_global $P614, ["PAST"], "Stmts"
    $P615 = $P614."new"()
    store_lex "$*PACKAGE-SETUP", $P615
.annotate 'line', 307
    rx609_cur."!cursor_pos"(rx609_pos)
    new $P616, "String"
    assign $P616, "class"
    store_lex "$*PKGDECL", $P616
.annotate 'line', 308
  # rx subcapture "sym"
    set_addr $I10, rxcap_617_fail
    rx609_cur."!mark_push"(0, rx609_pos, $I10)
  # rx literal  "class"
    add $I11, rx609_pos, 5
    gt $I11, rx609_eos, rx609_fail
    sub $I11, rx609_pos, rx609_off
    substr $S10, rx609_tgt, $I11, 5
    ne $S10, "class", rx609_fail
    add rx609_pos, 5
    set_addr $I10, rxcap_617_fail
    ($I12, $I11) = rx609_cur."!mark_peek"($I10)
    rx609_cur."!cursor_pos"($I11)
    ($P10) = rx609_cur."!cursor_start"()
    $P10."!cursor_pass"(rx609_pos, "")
    rx609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_617_done
  rxcap_617_fail:
    goto rx609_fail
  rxcap_617_done:
  # rx subrule "package_def" subtype=capture negate=
    rx609_cur."!cursor_pos"(rx609_pos)
    $P10 = rx609_cur."package_def"()
    unless $P10, rx609_fail
    rx609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx609_pos = $P10."pos"()
.annotate 'line', 305
  # rx pass
    rx609_cur."!cursor_pass"(rx609_pos, "package_declarator:sym<class>")
    if_null rx609_debug, debug_677
    rx609_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx609_pos)
  debug_677:
    .return (rx609_cur)
  rx609_restart:
.annotate 'line', 4
    if_null rx609_debug, debug_678
    rx609_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_678:
  rx609_fail:
    (rx609_rep, rx609_pos, $I10, $P10) = rx609_cur."!mark_fail"(0)
    lt rx609_pos, -1, rx609_done
    eq rx609_pos, -1, rx609_fail
    jump $I10
  rx609_done:
    rx609_cur."!cursor_fail"()
    if_null rx609_debug, debug_679
    rx609_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_679:
    .return (rx609_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("140_1299602538.98") :method
.annotate 'line', 4
    $P611 = self."!PREFIX__!subrule"("package_def", "class")
    new $P612, "ResizablePMCArray"
    push $P612, $P611
    .return ($P612)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("141_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 311
    new $P619, "Undef"
    .lex "$*PACKAGE-SETUP", $P619
.annotate 'line', 312
    new $P620, "Undef"
    .lex "$*PKGDECL", $P620
.annotate 'line', 4
    .local string rx621_tgt
    .local int rx621_pos
    .local int rx621_off
    .local int rx621_eos
    .local int rx621_rep
    .local pmc rx621_cur
    .local pmc rx621_debug
    (rx621_cur, rx621_pos, rx621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx621_cur
    .local pmc match
    .lex "$/", match
    length rx621_eos, rx621_tgt
    gt rx621_pos, rx621_eos, rx621_done
    set rx621_off, 0
    lt rx621_pos, 2, rx621_start
    sub rx621_off, rx621_pos, 1
    substr rx621_tgt, rx621_tgt, rx621_off
  rx621_start:
    eq $I10, 1, rx621_restart
    if_null rx621_debug, debug_680
    rx621_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan625_done
    goto rxscan625_scan
  rxscan625_loop:
    (rx621_pos) = rx621_cur."from"()
    inc rx621_pos
    rx621_cur."!cursor_from"(rx621_pos)
    ge rx621_pos, rx621_eos, rxscan625_done
  rxscan625_scan:
    set_addr $I10, rxscan625_loop
    rx621_cur."!mark_push"(0, rx621_pos, $I10)
  rxscan625_done:
.annotate 'line', 311
    rx621_cur."!cursor_pos"(rx621_pos)
    get_hll_global $P626, ["PAST"], "Stmts"
    $P627 = $P626."new"()
    store_lex "$*PACKAGE-SETUP", $P627
.annotate 'line', 312
    rx621_cur."!cursor_pos"(rx621_pos)
    new $P628, "String"
    assign $P628, "grammar"
    store_lex "$*PKGDECL", $P628
.annotate 'line', 313
  # rx subcapture "sym"
    set_addr $I10, rxcap_629_fail
    rx621_cur."!mark_push"(0, rx621_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx621_pos, 7
    gt $I11, rx621_eos, rx621_fail
    sub $I11, rx621_pos, rx621_off
    substr $S10, rx621_tgt, $I11, 7
    ne $S10, "grammar", rx621_fail
    add rx621_pos, 7
    set_addr $I10, rxcap_629_fail
    ($I12, $I11) = rx621_cur."!mark_peek"($I10)
    rx621_cur."!cursor_pos"($I11)
    ($P10) = rx621_cur."!cursor_start"()
    $P10."!cursor_pass"(rx621_pos, "")
    rx621_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_629_done
  rxcap_629_fail:
    goto rx621_fail
  rxcap_629_done:
  # rx subrule "package_def" subtype=capture negate=
    rx621_cur."!cursor_pos"(rx621_pos)
    $P10 = rx621_cur."package_def"()
    unless $P10, rx621_fail
    rx621_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx621_pos = $P10."pos"()
.annotate 'line', 310
  # rx pass
    rx621_cur."!cursor_pass"(rx621_pos, "package_declarator:sym<grammar>")
    if_null rx621_debug, debug_681
    rx621_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx621_pos)
  debug_681:
    .return (rx621_cur)
  rx621_restart:
.annotate 'line', 4
    if_null rx621_debug, debug_682
    rx621_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_682:
  rx621_fail:
    (rx621_rep, rx621_pos, $I10, $P10) = rx621_cur."!mark_fail"(0)
    lt rx621_pos, -1, rx621_done
    eq rx621_pos, -1, rx621_fail
    jump $I10
  rx621_done:
    rx621_cur."!cursor_fail"()
    if_null rx621_debug, debug_683
    rx621_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_683:
    .return (rx621_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("142_1299602538.98") :method
.annotate 'line', 4
    $P623 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P624, "ResizablePMCArray"
    push $P624, $P623
    .return ($P624)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("143_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 316
    new $P631, "Undef"
    .lex "$*PACKAGE-SETUP", $P631
.annotate 'line', 317
    new $P632, "Undef"
    .lex "$*PKGDECL", $P632
.annotate 'line', 4
    .local string rx633_tgt
    .local int rx633_pos
    .local int rx633_off
    .local int rx633_eos
    .local int rx633_rep
    .local pmc rx633_cur
    .local pmc rx633_debug
    (rx633_cur, rx633_pos, rx633_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx633_cur
    .local pmc match
    .lex "$/", match
    length rx633_eos, rx633_tgt
    gt rx633_pos, rx633_eos, rx633_done
    set rx633_off, 0
    lt rx633_pos, 2, rx633_start
    sub rx633_off, rx633_pos, 1
    substr rx633_tgt, rx633_tgt, rx633_off
  rx633_start:
    eq $I10, 1, rx633_restart
    if_null rx633_debug, debug_684
    rx633_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan637_done
    goto rxscan637_scan
  rxscan637_loop:
    (rx633_pos) = rx633_cur."from"()
    inc rx633_pos
    rx633_cur."!cursor_from"(rx633_pos)
    ge rx633_pos, rx633_eos, rxscan637_done
  rxscan637_scan:
    set_addr $I10, rxscan637_loop
    rx633_cur."!mark_push"(0, rx633_pos, $I10)
  rxscan637_done:
.annotate 'line', 316
    rx633_cur."!cursor_pos"(rx633_pos)
    get_hll_global $P638, ["PAST"], "Stmts"
    $P639 = $P638."new"()
    store_lex "$*PACKAGE-SETUP", $P639
.annotate 'line', 317
    rx633_cur."!cursor_pos"(rx633_pos)
    new $P640, "String"
    assign $P640, "role"
    store_lex "$*PKGDECL", $P640
.annotate 'line', 318
  # rx subcapture "sym"
    set_addr $I10, rxcap_641_fail
    rx633_cur."!mark_push"(0, rx633_pos, $I10)
  # rx literal  "role"
    add $I11, rx633_pos, 4
    gt $I11, rx633_eos, rx633_fail
    sub $I11, rx633_pos, rx633_off
    substr $S10, rx633_tgt, $I11, 4
    ne $S10, "role", rx633_fail
    add rx633_pos, 4
    set_addr $I10, rxcap_641_fail
    ($I12, $I11) = rx633_cur."!mark_peek"($I10)
    rx633_cur."!cursor_pos"($I11)
    ($P10) = rx633_cur."!cursor_start"()
    $P10."!cursor_pass"(rx633_pos, "")
    rx633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_641_done
  rxcap_641_fail:
    goto rx633_fail
  rxcap_641_done:
  # rx subrule "package_def" subtype=capture negate=
    rx633_cur."!cursor_pos"(rx633_pos)
    $P10 = rx633_cur."package_def"()
    unless $P10, rx633_fail
    rx633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx633_pos = $P10."pos"()
.annotate 'line', 315
  # rx pass
    rx633_cur."!cursor_pass"(rx633_pos, "package_declarator:sym<role>")
    if_null rx633_debug, debug_685
    rx633_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx633_pos)
  debug_685:
    .return (rx633_cur)
  rx633_restart:
.annotate 'line', 4
    if_null rx633_debug, debug_686
    rx633_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_686:
  rx633_fail:
    (rx633_rep, rx633_pos, $I10, $P10) = rx633_cur."!mark_fail"(0)
    lt rx633_pos, -1, rx633_done
    eq rx633_pos, -1, rx633_fail
    jump $I10
  rx633_done:
    rx633_cur."!cursor_fail"()
    if_null rx633_debug, debug_687
    rx633_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_687:
    .return (rx633_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("144_1299602538.98") :method
.annotate 'line', 4
    $P635 = self."!PREFIX__!subrule"("package_def", "role")
    new $P636, "ResizablePMCArray"
    push $P636, $P635
    .return ($P636)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("145_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 321
    new $P643, "Undef"
    .lex "$*PACKAGE-SETUP", $P643
.annotate 'line', 322
    new $P644, "Undef"
    .lex "$*PKGDECL", $P644
.annotate 'line', 4
    .local string rx645_tgt
    .local int rx645_pos
    .local int rx645_off
    .local int rx645_eos
    .local int rx645_rep
    .local pmc rx645_cur
    .local pmc rx645_debug
    (rx645_cur, rx645_pos, rx645_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx645_cur
    .local pmc match
    .lex "$/", match
    length rx645_eos, rx645_tgt
    gt rx645_pos, rx645_eos, rx645_done
    set rx645_off, 0
    lt rx645_pos, 2, rx645_start
    sub rx645_off, rx645_pos, 1
    substr rx645_tgt, rx645_tgt, rx645_off
  rx645_start:
    eq $I10, 1, rx645_restart
    if_null rx645_debug, debug_688
    rx645_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan649_done
    goto rxscan649_scan
  rxscan649_loop:
    (rx645_pos) = rx645_cur."from"()
    inc rx645_pos
    rx645_cur."!cursor_from"(rx645_pos)
    ge rx645_pos, rx645_eos, rxscan649_done
  rxscan649_scan:
    set_addr $I10, rxscan649_loop
    rx645_cur."!mark_push"(0, rx645_pos, $I10)
  rxscan649_done:
.annotate 'line', 321
    rx645_cur."!cursor_pos"(rx645_pos)
    get_hll_global $P650, ["PAST"], "Stmts"
    $P651 = $P650."new"()
    store_lex "$*PACKAGE-SETUP", $P651
.annotate 'line', 322
    rx645_cur."!cursor_pos"(rx645_pos)
    new $P652, "String"
    assign $P652, "native"
    store_lex "$*PKGDECL", $P652
.annotate 'line', 323
  # rx subcapture "sym"
    set_addr $I10, rxcap_653_fail
    rx645_cur."!mark_push"(0, rx645_pos, $I10)
  # rx literal  "native"
    add $I11, rx645_pos, 6
    gt $I11, rx645_eos, rx645_fail
    sub $I11, rx645_pos, rx645_off
    substr $S10, rx645_tgt, $I11, 6
    ne $S10, "native", rx645_fail
    add rx645_pos, 6
    set_addr $I10, rxcap_653_fail
    ($I12, $I11) = rx645_cur."!mark_peek"($I10)
    rx645_cur."!cursor_pos"($I11)
    ($P10) = rx645_cur."!cursor_start"()
    $P10."!cursor_pass"(rx645_pos, "")
    rx645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_653_done
  rxcap_653_fail:
    goto rx645_fail
  rxcap_653_done:
  # rx subrule "package_def" subtype=capture negate=
    rx645_cur."!cursor_pos"(rx645_pos)
    $P10 = rx645_cur."package_def"()
    unless $P10, rx645_fail
    rx645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx645_pos = $P10."pos"()
.annotate 'line', 320
  # rx pass
    rx645_cur."!cursor_pass"(rx645_pos, "package_declarator:sym<native>")
    if_null rx645_debug, debug_689
    rx645_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx645_pos)
  debug_689:
    .return (rx645_cur)
  rx645_restart:
.annotate 'line', 4
    if_null rx645_debug, debug_690
    rx645_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_690:
  rx645_fail:
    (rx645_rep, rx645_pos, $I10, $P10) = rx645_cur."!mark_fail"(0)
    lt rx645_pos, -1, rx645_done
    eq rx645_pos, -1, rx645_fail
    jump $I10
  rx645_done:
    rx645_cur."!cursor_fail"()
    if_null rx645_debug, debug_691
    rx645_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_691:
    .return (rx645_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("146_1299602538.98") :method
.annotate 'line', 4
    $P647 = self."!PREFIX__!subrule"("package_def", "native")
    new $P648, "ResizablePMCArray"
    push $P648, $P647
    .return ($P648)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("147_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P678 = "149_1299602538.98" 
    capture_lex $P678
.annotate 'line', 327
    new $P655, "Undef"
    .lex "$*PKGMETA", $P655
.annotate 'line', 328
    $P656 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P656
.annotate 'line', 4
    .local string rx657_tgt
    .local int rx657_pos
    .local int rx657_off
    .local int rx657_eos
    .local int rx657_rep
    .local pmc rx657_cur
    .local pmc rx657_debug
    (rx657_cur, rx657_pos, rx657_tgt, $I10) = self."!cursor_start"()
    rx657_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx657_cur
    .local pmc match
    .lex "$/", match
    length rx657_eos, rx657_tgt
    gt rx657_pos, rx657_eos, rx657_done
    set rx657_off, 0
    lt rx657_pos, 2, rx657_start
    sub rx657_off, rx657_pos, 1
    substr rx657_tgt, rx657_tgt, rx657_off
  rx657_start:
    eq $I10, 1, rx657_restart
    if_null rx657_debug, debug_692
    rx657_cur."!cursor_debug"("START", "package_def")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan661_done
    goto rxscan661_scan
  rxscan661_loop:
    (rx657_pos) = rx657_cur."from"()
    inc rx657_pos
    rx657_cur."!cursor_from"(rx657_pos)
    ge rx657_pos, rx657_eos, rxscan661_done
  rxscan661_scan:
    set_addr $I10, rxscan661_loop
    rx657_cur."!mark_push"(0, rx657_pos, $I10)
  rxscan661_done:
.annotate 'line', 326
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 327
    rx657_cur."!cursor_pos"(rx657_pos)
    find_lex $P663, "$*PKGMETA"
    unless_null $P663, vivify_693
    get_hll_global $P663, "$PKGMETA"
    unless_null $P663, vivify_694
    die "Contextual $*PKGMETA not found"
  vivify_694:
  vivify_693:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 328
    rx657_cur."!cursor_pos"(rx657_pos)
    find_lex $P665, "%*ATTR-CHECK"
    unless_null $P665, vivify_695
    get_hll_global $P665, "%ATTR-CHECK"
    unless_null $P665, vivify_696
    die "Contextual %*ATTR-CHECK not found"
  vivify_696:
  vivify_695:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 330
  # rx subrule "name" subtype=capture negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."name"()
    unless $P10, rx657_fail
    rx657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 331
  # rx rxquantr668 ** 0..1
    set_addr $I10, rxquantr668_done
    rx657_cur."!mark_push"(0, rx657_pos, $I10)
  rxquantr668_loop:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx657_pos, 2
    gt $I11, rx657_eos, rx657_fail
    sub $I11, rx657_pos, rx657_off
    substr $S10, rx657_tgt, $I11, 2
    ne $S10, "is", rx657_fail
    add rx657_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx657_pos, 5
    gt $I11, rx657_eos, rx657_fail
    sub $I11, rx657_pos, rx657_off
    substr $S10, rx657_tgt, $I11, 5
    ne $S10, "repr(", rx657_fail
    add rx657_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."quote_EXPR"()
    unless $P10, rx657_fail
    rx657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx657_pos, 1
    gt $I11, rx657_eos, rx657_fail
    sub $I11, rx657_pos, rx657_off
    ord $I11, rx657_tgt, $I11
    ne $I11, 41, rx657_fail
    add rx657_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
    set_addr $I10, rxquantr668_done
    (rx657_rep) = rx657_cur."!mark_commit"($I10)
  rxquantr668_done:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 333
    rx657_cur."!cursor_pos"(rx657_pos)
    find_lex $P675, unicode:"$\x{a2}"
    $P676 = $P675."MATCH"()
    store_lex "$/", $P676
    .const 'Sub' $P678 = "149_1299602538.98" 
    capture_lex $P678
    $P704 = $P678()
.annotate 'line', 342
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 344
  # rx rxquantr706 ** 0..1
    set_addr $I10, rxquantr706_done
    rx657_cur."!mark_push"(0, rx657_pos, $I10)
  rxquantr706_loop:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx657_pos, 2
    gt $I11, rx657_eos, rx657_fail
    sub $I11, rx657_pos, rx657_off
    substr $S10, rx657_tgt, $I11, 2
    ne $S10, "is", rx657_fail
    add rx657_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."name"()
    unless $P10, rx657_fail
    rx657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
    set_addr $I10, rxquantr706_done
    (rx657_rep) = rx657_cur."!mark_commit"($I10)
  rxquantr706_done:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 345
  # rx rxquantr711 ** 0..*
    set_addr $I10, rxquantr711_done
    rx657_cur."!mark_push"(0, rx657_pos, $I10)
  rxquantr711_loop:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx657_pos, 4
    gt $I11, rx657_eos, rx657_fail
    sub $I11, rx657_pos, rx657_off
    substr $S10, rx657_tgt, $I11, 4
    ne $S10, "does", rx657_fail
    add rx657_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."name"()
    unless $P10, rx657_fail
    rx657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
    set_addr $I10, rxquantr711_done
    (rx657_rep) = rx657_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr711_done
    rx657_cur."!mark_push"(rx657_rep, rx657_pos, $I10)
    goto rxquantr711_loop
  rxquantr711_done:
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  alt716_0:
.annotate 'line', 346
    set_addr $I10, alt716_1
    rx657_cur."!mark_push"(0, rx657_pos, $I10)
.annotate 'line', 347
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx657_pos, 1
    gt $I11, rx657_eos, rx657_fail
    sub $I11, rx657_pos, rx657_off
    ord $I11, rx657_tgt, $I11
    ne $I11, 59, rx657_fail
    add rx657_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."comp_unit"()
    unless $P10, rx657_fail
    rx657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
    goto alt716_end
  alt716_1:
    set_addr $I10, alt716_2
    rx657_cur."!mark_push"(0, rx657_pos, $I10)
.annotate 'line', 348
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx657_pos, rx657_off
    substr $S10, rx657_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx657_fail
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."block"()
    unless $P10, rx657_fail
    rx657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
    goto alt716_end
  alt716_2:
.annotate 'line', 349
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."panic"("Malformed package declaration")
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
  alt716_end:
.annotate 'line', 350
  # rx subrule "ws" subtype=method negate=
    rx657_cur."!cursor_pos"(rx657_pos)
    $P10 = rx657_cur."ws"()
    unless $P10, rx657_fail
    rx657_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx657_cur."!cursor_pass"(rx657_pos, "package_def")
    if_null rx657_debug, debug_716
    rx657_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx657_pos)
  debug_716:
    .return (rx657_cur)
  rx657_restart:
.annotate 'line', 4
    if_null rx657_debug, debug_717
    rx657_cur."!cursor_debug"("NEXT", "package_def")
  debug_717:
  rx657_fail:
    (rx657_rep, rx657_pos, $I10, $P10) = rx657_cur."!mark_fail"(0)
    lt rx657_pos, -1, rx657_done
    eq rx657_pos, -1, rx657_fail
    jump $I10
  rx657_done:
    rx657_cur."!cursor_fail"()
    if_null rx657_debug, debug_718
    rx657_cur."!cursor_debug"("FAIL", "package_def")
  debug_718:
    .return (rx657_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("148_1299602538.98") :method
.annotate 'line', 4
    $P659 = self."!PREFIX__!subrule"("ws", "")
    new $P660, "ResizablePMCArray"
    push $P660, $P659
    .return ($P660)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block677"  :anon :subid("149_1299602538.98") :outer("147_1299602538.98")
.annotate 'line', 336
    $P679 = root_new ['parrot';'Hash']
    .lex "%args", $P679
.annotate 'line', 333
    find_lex $P680, "%args"
.annotate 'line', 337
    find_lex $P681, "$/"
    unless_null $P681, vivify_697
    $P681 = root_new ['parrot';'Hash']
  vivify_697:
    set $P682, $P681["name"]
    unless_null $P682, vivify_698
    new $P682, "Undef"
  vivify_698:
    set $S683, $P682
    new $P684, 'String'
    set $P684, $S683
    find_lex $P685, "%args"
    unless_null $P685, vivify_699
    $P685 = root_new ['parrot';'Hash']
    store_lex "%args", $P685
  vivify_699:
    set $P685["name"], $P684
.annotate 'line', 338
    find_lex $P687, "$/"
    unless_null $P687, vivify_700
    $P687 = root_new ['parrot';'Hash']
  vivify_700:
    set $P688, $P687["repr"]
    unless_null $P688, vivify_701
    new $P688, "Undef"
  vivify_701:
    unless $P688, if_686_end
.annotate 'line', 339
    find_lex $P689, "$/"
    unless_null $P689, vivify_702
    $P689 = root_new ['parrot';'Hash']
  vivify_702:
    set $P690, $P689["repr"]
    unless_null $P690, vivify_703
    $P690 = root_new ['parrot';'ResizablePMCArray']
  vivify_703:
    set $P691, $P690[0]
    unless_null $P691, vivify_704
    $P691 = root_new ['parrot';'Hash']
  vivify_704:
    set $P692, $P691["quote_delimited"]
    unless_null $P692, vivify_705
    $P692 = root_new ['parrot';'Hash']
  vivify_705:
    set $P693, $P692["quote_atom"]
    unless_null $P693, vivify_706
    $P693 = root_new ['parrot';'ResizablePMCArray']
  vivify_706:
    set $P694, $P693[0]
    unless_null $P694, vivify_707
    new $P694, "Undef"
  vivify_707:
    set $S695, $P694
    new $P696, 'String'
    set $P696, $S695
    find_lex $P697, "%args"
    unless_null $P697, vivify_708
    $P697 = root_new ['parrot';'Hash']
    store_lex "%args", $P697
  vivify_708:
    set $P697["repr"], $P696
  if_686_end:
.annotate 'line', 341
    find_dynamic_lex $P698, "$*SC"
    unless_null $P698, vivify_709
    get_hll_global $P698, "$SC"
    unless_null $P698, vivify_710
    die "Contextual $*SC not found"
  vivify_710:
  vivify_709:
    find_dynamic_lex $P699, "$*PKGDECL"
    unless_null $P699, vivify_711
    get_hll_global $P699, "$PKGDECL"
    unless_null $P699, vivify_712
    die "Contextual $*PKGDECL not found"
  vivify_712:
  vivify_711:
    find_dynamic_lex $P700, "%*HOW"
    unless_null $P700, vivify_713
    get_hll_global $P700, "%HOW"
    unless_null $P700, vivify_714
    die "Contextual %*HOW not found"
  vivify_714:
  vivify_713:
    set $P701, $P700[$P699]
    unless_null $P701, vivify_715
    new $P701, "Undef"
  vivify_715:
    find_lex $P702, "%args"
    $P703 = $P698."pkg_create_mo"($P701, $P702 :flat)
    store_dynamic_lex "$*PKGMETA", $P703
.annotate 'line', 333
    .return ($P703)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("150_1299602538.98")
    .param pmc param_727
.annotate 'line', 353
    .lex "self", param_727
    $P728 = param_727."!protoregex"("scope_declarator")
    .return ($P728)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("151_1299602538.98")
    .param pmc param_730
.annotate 'line', 353
    .lex "self", param_730
    $P731 = param_730."!PREFIX__!protoregex"("scope_declarator")
    .return ($P731)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("152_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx733_tgt
    .local int rx733_pos
    .local int rx733_off
    .local int rx733_eos
    .local int rx733_rep
    .local pmc rx733_cur
    .local pmc rx733_debug
    (rx733_cur, rx733_pos, rx733_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx733_cur
    .local pmc match
    .lex "$/", match
    length rx733_eos, rx733_tgt
    gt rx733_pos, rx733_eos, rx733_done
    set rx733_off, 0
    lt rx733_pos, 2, rx733_start
    sub rx733_off, rx733_pos, 1
    substr rx733_tgt, rx733_tgt, rx733_off
  rx733_start:
    eq $I10, 1, rx733_restart
    if_null rx733_debug, debug_719
    rx733_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_719:
    $I10 = self.'from'()
    ne $I10, -1, rxscan737_done
    goto rxscan737_scan
  rxscan737_loop:
    (rx733_pos) = rx733_cur."from"()
    inc rx733_pos
    rx733_cur."!cursor_from"(rx733_pos)
    ge rx733_pos, rx733_eos, rxscan737_done
  rxscan737_scan:
    set_addr $I10, rxscan737_loop
    rx733_cur."!mark_push"(0, rx733_pos, $I10)
  rxscan737_done:
.annotate 'line', 354
  # rx subcapture "sym"
    set_addr $I10, rxcap_738_fail
    rx733_cur."!mark_push"(0, rx733_pos, $I10)
  # rx literal  "my"
    add $I11, rx733_pos, 2
    gt $I11, rx733_eos, rx733_fail
    sub $I11, rx733_pos, rx733_off
    substr $S10, rx733_tgt, $I11, 2
    ne $S10, "my", rx733_fail
    add rx733_pos, 2
    set_addr $I10, rxcap_738_fail
    ($I12, $I11) = rx733_cur."!mark_peek"($I10)
    rx733_cur."!cursor_pos"($I11)
    ($P10) = rx733_cur."!cursor_start"()
    $P10."!cursor_pass"(rx733_pos, "")
    rx733_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_738_done
  rxcap_738_fail:
    goto rx733_fail
  rxcap_738_done:
  # rx subrule "scoped" subtype=capture negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."scoped"("my")
    unless $P10, rx733_fail
    rx733_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx733_pos = $P10."pos"()
  # rx pass
    rx733_cur."!cursor_pass"(rx733_pos, "scope_declarator:sym<my>")
    if_null rx733_debug, debug_720
    rx733_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx733_pos)
  debug_720:
    .return (rx733_cur)
  rx733_restart:
.annotate 'line', 4
    if_null rx733_debug, debug_721
    rx733_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_721:
  rx733_fail:
    (rx733_rep, rx733_pos, $I10, $P10) = rx733_cur."!mark_fail"(0)
    lt rx733_pos, -1, rx733_done
    eq rx733_pos, -1, rx733_fail
    jump $I10
  rx733_done:
    rx733_cur."!cursor_fail"()
    if_null rx733_debug, debug_722
    rx733_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_722:
    .return (rx733_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("153_1299602538.98") :method
.annotate 'line', 4
    $P735 = self."!PREFIX__!subrule"("scoped", "my")
    new $P736, "ResizablePMCArray"
    push $P736, $P735
    .return ($P736)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("154_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx740_tgt
    .local int rx740_pos
    .local int rx740_off
    .local int rx740_eos
    .local int rx740_rep
    .local pmc rx740_cur
    .local pmc rx740_debug
    (rx740_cur, rx740_pos, rx740_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx740_cur
    .local pmc match
    .lex "$/", match
    length rx740_eos, rx740_tgt
    gt rx740_pos, rx740_eos, rx740_done
    set rx740_off, 0
    lt rx740_pos, 2, rx740_start
    sub rx740_off, rx740_pos, 1
    substr rx740_tgt, rx740_tgt, rx740_off
  rx740_start:
    eq $I10, 1, rx740_restart
    if_null rx740_debug, debug_723
    rx740_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan744_done
    goto rxscan744_scan
  rxscan744_loop:
    (rx740_pos) = rx740_cur."from"()
    inc rx740_pos
    rx740_cur."!cursor_from"(rx740_pos)
    ge rx740_pos, rx740_eos, rxscan744_done
  rxscan744_scan:
    set_addr $I10, rxscan744_loop
    rx740_cur."!mark_push"(0, rx740_pos, $I10)
  rxscan744_done:
.annotate 'line', 355
  # rx subcapture "sym"
    set_addr $I10, rxcap_745_fail
    rx740_cur."!mark_push"(0, rx740_pos, $I10)
  # rx literal  "our"
    add $I11, rx740_pos, 3
    gt $I11, rx740_eos, rx740_fail
    sub $I11, rx740_pos, rx740_off
    substr $S10, rx740_tgt, $I11, 3
    ne $S10, "our", rx740_fail
    add rx740_pos, 3
    set_addr $I10, rxcap_745_fail
    ($I12, $I11) = rx740_cur."!mark_peek"($I10)
    rx740_cur."!cursor_pos"($I11)
    ($P10) = rx740_cur."!cursor_start"()
    $P10."!cursor_pass"(rx740_pos, "")
    rx740_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_745_done
  rxcap_745_fail:
    goto rx740_fail
  rxcap_745_done:
  # rx subrule "scoped" subtype=capture negate=
    rx740_cur."!cursor_pos"(rx740_pos)
    $P10 = rx740_cur."scoped"("our")
    unless $P10, rx740_fail
    rx740_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx740_pos = $P10."pos"()
  # rx pass
    rx740_cur."!cursor_pass"(rx740_pos, "scope_declarator:sym<our>")
    if_null rx740_debug, debug_724
    rx740_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx740_pos)
  debug_724:
    .return (rx740_cur)
  rx740_restart:
.annotate 'line', 4
    if_null rx740_debug, debug_725
    rx740_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_725:
  rx740_fail:
    (rx740_rep, rx740_pos, $I10, $P10) = rx740_cur."!mark_fail"(0)
    lt rx740_pos, -1, rx740_done
    eq rx740_pos, -1, rx740_fail
    jump $I10
  rx740_done:
    rx740_cur."!cursor_fail"()
    if_null rx740_debug, debug_726
    rx740_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_726:
    .return (rx740_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("155_1299602538.98") :method
.annotate 'line', 4
    $P742 = self."!PREFIX__!subrule"("scoped", "our")
    new $P743, "ResizablePMCArray"
    push $P743, $P742
    .return ($P743)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("156_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx747_tgt
    .local int rx747_pos
    .local int rx747_off
    .local int rx747_eos
    .local int rx747_rep
    .local pmc rx747_cur
    .local pmc rx747_debug
    (rx747_cur, rx747_pos, rx747_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx747_cur
    .local pmc match
    .lex "$/", match
    length rx747_eos, rx747_tgt
    gt rx747_pos, rx747_eos, rx747_done
    set rx747_off, 0
    lt rx747_pos, 2, rx747_start
    sub rx747_off, rx747_pos, 1
    substr rx747_tgt, rx747_tgt, rx747_off
  rx747_start:
    eq $I10, 1, rx747_restart
    if_null rx747_debug, debug_727
    rx747_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_727:
    $I10 = self.'from'()
    ne $I10, -1, rxscan751_done
    goto rxscan751_scan
  rxscan751_loop:
    (rx747_pos) = rx747_cur."from"()
    inc rx747_pos
    rx747_cur."!cursor_from"(rx747_pos)
    ge rx747_pos, rx747_eos, rxscan751_done
  rxscan751_scan:
    set_addr $I10, rxscan751_loop
    rx747_cur."!mark_push"(0, rx747_pos, $I10)
  rxscan751_done:
.annotate 'line', 356
  # rx subcapture "sym"
    set_addr $I10, rxcap_752_fail
    rx747_cur."!mark_push"(0, rx747_pos, $I10)
  # rx literal  "has"
    add $I11, rx747_pos, 3
    gt $I11, rx747_eos, rx747_fail
    sub $I11, rx747_pos, rx747_off
    substr $S10, rx747_tgt, $I11, 3
    ne $S10, "has", rx747_fail
    add rx747_pos, 3
    set_addr $I10, rxcap_752_fail
    ($I12, $I11) = rx747_cur."!mark_peek"($I10)
    rx747_cur."!cursor_pos"($I11)
    ($P10) = rx747_cur."!cursor_start"()
    $P10."!cursor_pass"(rx747_pos, "")
    rx747_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_752_done
  rxcap_752_fail:
    goto rx747_fail
  rxcap_752_done:
  # rx subrule "scoped" subtype=capture negate=
    rx747_cur."!cursor_pos"(rx747_pos)
    $P10 = rx747_cur."scoped"("has")
    unless $P10, rx747_fail
    rx747_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx747_pos = $P10."pos"()
  # rx pass
    rx747_cur."!cursor_pass"(rx747_pos, "scope_declarator:sym<has>")
    if_null rx747_debug, debug_728
    rx747_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx747_pos)
  debug_728:
    .return (rx747_cur)
  rx747_restart:
.annotate 'line', 4
    if_null rx747_debug, debug_729
    rx747_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_729:
  rx747_fail:
    (rx747_rep, rx747_pos, $I10, $P10) = rx747_cur."!mark_fail"(0)
    lt rx747_pos, -1, rx747_done
    eq rx747_pos, -1, rx747_fail
    jump $I10
  rx747_done:
    rx747_cur."!cursor_fail"()
    if_null rx747_debug, debug_730
    rx747_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_730:
    .return (rx747_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("157_1299602538.98") :method
.annotate 'line', 4
    $P749 = self."!PREFIX__!subrule"("scoped", "has")
    new $P750, "ResizablePMCArray"
    push $P750, $P749
    .return ($P750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("158_1299602538.98") :method :outer("11_1299602538.98")
    .param pmc param_754
.annotate 'line', 358
    .lex "$*SCOPE", param_754
.annotate 'line', 4
    .local string rx755_tgt
    .local int rx755_pos
    .local int rx755_off
    .local int rx755_eos
    .local int rx755_rep
    .local pmc rx755_cur
    .local pmc rx755_debug
    (rx755_cur, rx755_pos, rx755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx755_cur
    .local pmc match
    .lex "$/", match
    length rx755_eos, rx755_tgt
    gt rx755_pos, rx755_eos, rx755_done
    set rx755_off, 0
    lt rx755_pos, 2, rx755_start
    sub rx755_off, rx755_pos, 1
    substr rx755_tgt, rx755_tgt, rx755_off
  rx755_start:
    eq $I10, 1, rx755_restart
    if_null rx755_debug, debug_731
    rx755_cur."!cursor_debug"("START", "scoped")
  debug_731:
    $I10 = self.'from'()
    ne $I10, -1, rxscan760_done
    goto rxscan760_scan
  rxscan760_loop:
    (rx755_pos) = rx755_cur."from"()
    inc rx755_pos
    rx755_cur."!cursor_from"(rx755_pos)
    ge rx755_pos, rx755_eos, rxscan760_done
  rxscan760_scan:
    set_addr $I10, rxscan760_loop
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  rxscan760_done:
  alt761_0:
.annotate 'line', 358
    set_addr $I10, alt761_1
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
.annotate 'line', 359
  # rx subrule "ws" subtype=method negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."ws"()
    unless $P10, rx755_fail
    rx755_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."declarator"()
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx755_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."ws"()
    unless $P10, rx755_fail
    rx755_pos = $P10."pos"()
    goto alt761_end
  alt761_1:
.annotate 'line', 360
  # rx subrule "ws" subtype=method negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."ws"()
    unless $P10, rx755_fail
    rx755_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."multi_declarator"()
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx755_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."ws"()
    unless $P10, rx755_fail
    rx755_pos = $P10."pos"()
  alt761_end:
.annotate 'line', 358
  # rx pass
    rx755_cur."!cursor_pass"(rx755_pos, "scoped")
    if_null rx755_debug, debug_732
    rx755_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx755_pos)
  debug_732:
    .return (rx755_cur)
  rx755_restart:
.annotate 'line', 4
    if_null rx755_debug, debug_733
    rx755_cur."!cursor_debug"("NEXT", "scoped")
  debug_733:
  rx755_fail:
    (rx755_rep, rx755_pos, $I10, $P10) = rx755_cur."!mark_fail"(0)
    lt rx755_pos, -1, rx755_done
    eq rx755_pos, -1, rx755_fail
    jump $I10
  rx755_done:
    rx755_cur."!cursor_fail"()
    if_null rx755_debug, debug_734
    rx755_cur."!cursor_debug"("FAIL", "scoped")
  debug_734:
    .return (rx755_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("159_1299602538.98") :method
.annotate 'line', 4
    $P757 = self."!PREFIX__!subrule"("ws", "")
    $P758 = self."!PREFIX__!subrule"("ws", "")
    new $P759, "ResizablePMCArray"
    push $P759, $P757
    push $P759, $P758
    .return ($P759)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("160_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx767_tgt
    .local int rx767_pos
    .local int rx767_off
    .local int rx767_eos
    .local int rx767_rep
    .local pmc rx767_cur
    .local pmc rx767_debug
    (rx767_cur, rx767_pos, rx767_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx767_cur
    .local pmc match
    .lex "$/", match
    length rx767_eos, rx767_tgt
    gt rx767_pos, rx767_eos, rx767_done
    set rx767_off, 0
    lt rx767_pos, 2, rx767_start
    sub rx767_off, rx767_pos, 1
    substr rx767_tgt, rx767_tgt, rx767_off
  rx767_start:
    eq $I10, 1, rx767_restart
    if_null rx767_debug, debug_735
    rx767_cur."!cursor_debug"("START", "typename")
  debug_735:
    $I10 = self.'from'()
    ne $I10, -1, rxscan771_done
    goto rxscan771_scan
  rxscan771_loop:
    (rx767_pos) = rx767_cur."from"()
    inc rx767_pos
    rx767_cur."!cursor_from"(rx767_pos)
    ge rx767_pos, rx767_eos, rxscan771_done
  rxscan771_scan:
    set_addr $I10, rxscan771_loop
    rx767_cur."!mark_push"(0, rx767_pos, $I10)
  rxscan771_done:
.annotate 'line', 363
  # rx subrule "name" subtype=capture negate=
    rx767_cur."!cursor_pos"(rx767_pos)
    $P10 = rx767_cur."name"()
    unless $P10, rx767_fail
    rx767_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx767_pos = $P10."pos"()
  # rx pass
    rx767_cur."!cursor_pass"(rx767_pos, "typename")
    if_null rx767_debug, debug_736
    rx767_cur."!cursor_debug"("PASS", "typename", " at pos=", rx767_pos)
  debug_736:
    .return (rx767_cur)
  rx767_restart:
.annotate 'line', 4
    if_null rx767_debug, debug_737
    rx767_cur."!cursor_debug"("NEXT", "typename")
  debug_737:
  rx767_fail:
    (rx767_rep, rx767_pos, $I10, $P10) = rx767_cur."!mark_fail"(0)
    lt rx767_pos, -1, rx767_done
    eq rx767_pos, -1, rx767_fail
    jump $I10
  rx767_done:
    rx767_cur."!cursor_fail"()
    if_null rx767_debug, debug_738
    rx767_cur."!cursor_debug"("FAIL", "typename")
  debug_738:
    .return (rx767_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("161_1299602538.98") :method
.annotate 'line', 4
    $P769 = self."!PREFIX__!subrule"("name", "")
    new $P770, "ResizablePMCArray"
    push $P770, $P769
    .return ($P770)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("162_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx773_tgt
    .local int rx773_pos
    .local int rx773_off
    .local int rx773_eos
    .local int rx773_rep
    .local pmc rx773_cur
    .local pmc rx773_debug
    (rx773_cur, rx773_pos, rx773_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx773_cur
    .local pmc match
    .lex "$/", match
    length rx773_eos, rx773_tgt
    gt rx773_pos, rx773_eos, rx773_done
    set rx773_off, 0
    lt rx773_pos, 2, rx773_start
    sub rx773_off, rx773_pos, 1
    substr rx773_tgt, rx773_tgt, rx773_off
  rx773_start:
    eq $I10, 1, rx773_restart
    if_null rx773_debug, debug_739
    rx773_cur."!cursor_debug"("START", "declarator")
  debug_739:
    $I10 = self.'from'()
    ne $I10, -1, rxscan778_done
    goto rxscan778_scan
  rxscan778_loop:
    (rx773_pos) = rx773_cur."from"()
    inc rx773_pos
    rx773_cur."!cursor_from"(rx773_pos)
    ge rx773_pos, rx773_eos, rxscan778_done
  rxscan778_scan:
    set_addr $I10, rxscan778_loop
    rx773_cur."!mark_push"(0, rx773_pos, $I10)
  rxscan778_done:
  alt779_0:
.annotate 'line', 365
    set_addr $I10, alt779_1
    rx773_cur."!mark_push"(0, rx773_pos, $I10)
.annotate 'line', 366
  # rx subrule "variable_declarator" subtype=capture negate=
    rx773_cur."!cursor_pos"(rx773_pos)
    $P10 = rx773_cur."variable_declarator"()
    unless $P10, rx773_fail
    rx773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx773_pos = $P10."pos"()
    goto alt779_end
  alt779_1:
.annotate 'line', 367
  # rx subrule "routine_declarator" subtype=capture negate=
    rx773_cur."!cursor_pos"(rx773_pos)
    $P10 = rx773_cur."routine_declarator"()
    unless $P10, rx773_fail
    rx773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx773_pos = $P10."pos"()
  alt779_end:
.annotate 'line', 365
  # rx pass
    rx773_cur."!cursor_pass"(rx773_pos, "declarator")
    if_null rx773_debug, debug_740
    rx773_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx773_pos)
  debug_740:
    .return (rx773_cur)
  rx773_restart:
.annotate 'line', 4
    if_null rx773_debug, debug_741
    rx773_cur."!cursor_debug"("NEXT", "declarator")
  debug_741:
  rx773_fail:
    (rx773_rep, rx773_pos, $I10, $P10) = rx773_cur."!mark_fail"(0)
    lt rx773_pos, -1, rx773_done
    eq rx773_pos, -1, rx773_fail
    jump $I10
  rx773_done:
    rx773_cur."!cursor_fail"()
    if_null rx773_debug, debug_742
    rx773_cur."!cursor_debug"("FAIL", "declarator")
  debug_742:
    .return (rx773_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("163_1299602538.98") :method
.annotate 'line', 4
    $P775 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P776 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P777, "ResizablePMCArray"
    push $P777, $P775
    push $P777, $P776
    .return ($P777)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("164_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx781_tgt
    .local int rx781_pos
    .local int rx781_off
    .local int rx781_eos
    .local int rx781_rep
    .local pmc rx781_cur
    .local pmc rx781_debug
    (rx781_cur, rx781_pos, rx781_tgt, $I10) = self."!cursor_start"()
    rx781_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx781_cur
    .local pmc match
    .lex "$/", match
    length rx781_eos, rx781_tgt
    gt rx781_pos, rx781_eos, rx781_done
    set rx781_off, 0
    lt rx781_pos, 2, rx781_start
    sub rx781_off, rx781_pos, 1
    substr rx781_tgt, rx781_tgt, rx781_off
  rx781_start:
    eq $I10, 1, rx781_restart
    if_null rx781_debug, debug_743
    rx781_cur."!cursor_debug"("START", "variable_declarator")
  debug_743:
    $I10 = self.'from'()
    ne $I10, -1, rxscan785_done
    goto rxscan785_scan
  rxscan785_loop:
    (rx781_pos) = rx781_cur."from"()
    inc rx781_pos
    rx781_cur."!cursor_from"(rx781_pos)
    ge rx781_pos, rx781_eos, rxscan785_done
  rxscan785_scan:
    set_addr $I10, rxscan785_loop
    rx781_cur."!mark_push"(0, rx781_pos, $I10)
  rxscan785_done:
.annotate 'line', 370
  # rx subrule "ws" subtype=method negate=
    rx781_cur."!cursor_pos"(rx781_pos)
    $P10 = rx781_cur."ws"()
    unless $P10, rx781_fail
    rx781_pos = $P10."pos"()
  # rx rxquantr787 ** 0..1
    set_addr $I10, rxquantr787_done
    rx781_cur."!mark_push"(0, rx781_pos, $I10)
  rxquantr787_loop:
  # rx subrule "typename" subtype=capture negate=
    rx781_cur."!cursor_pos"(rx781_pos)
    $P10 = rx781_cur."typename"()
    unless $P10, rx781_fail
    goto rxsubrule788_pass
  rxsubrule788_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx781_fail
  rxsubrule788_pass:
    set_addr $I10, rxsubrule788_back
    rx781_cur."!mark_push"(0, rx781_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx781_pos = $P10."pos"()
    set_addr $I10, rxquantr787_done
    (rx781_rep) = rx781_cur."!mark_commit"($I10)
  rxquantr787_done:
  # rx subrule "ws" subtype=method negate=
    rx781_cur."!cursor_pos"(rx781_pos)
    $P10 = rx781_cur."ws"()
    unless $P10, rx781_fail
    rx781_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx781_cur."!cursor_pos"(rx781_pos)
    $P10 = rx781_cur."variable"()
    unless $P10, rx781_fail
    rx781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx781_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx781_cur."!cursor_pos"(rx781_pos)
    $P10 = rx781_cur."ws"()
    unless $P10, rx781_fail
    rx781_pos = $P10."pos"()
  # rx pass
    rx781_cur."!cursor_pass"(rx781_pos, "variable_declarator")
    if_null rx781_debug, debug_744
    rx781_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx781_pos)
  debug_744:
    .return (rx781_cur)
  rx781_restart:
.annotate 'line', 4
    if_null rx781_debug, debug_745
    rx781_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_745:
  rx781_fail:
    (rx781_rep, rx781_pos, $I10, $P10) = rx781_cur."!mark_fail"(0)
    lt rx781_pos, -1, rx781_done
    eq rx781_pos, -1, rx781_fail
    jump $I10
  rx781_done:
    rx781_cur."!cursor_fail"()
    if_null rx781_debug, debug_746
    rx781_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_746:
    .return (rx781_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("165_1299602538.98") :method
.annotate 'line', 4
    $P783 = self."!PREFIX__!subrule"("ws", "")
    new $P784, "ResizablePMCArray"
    push $P784, $P783
    .return ($P784)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("166_1299602538.98")
    .param pmc param_792
.annotate 'line', 372
    .lex "self", param_792
    $P793 = param_792."!protoregex"("routine_declarator")
    .return ($P793)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("167_1299602538.98")
    .param pmc param_795
.annotate 'line', 372
    .lex "self", param_795
    $P796 = param_795."!PREFIX__!protoregex"("routine_declarator")
    .return ($P796)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("168_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx798_tgt
    .local int rx798_pos
    .local int rx798_off
    .local int rx798_eos
    .local int rx798_rep
    .local pmc rx798_cur
    .local pmc rx798_debug
    (rx798_cur, rx798_pos, rx798_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx798_cur
    .local pmc match
    .lex "$/", match
    length rx798_eos, rx798_tgt
    gt rx798_pos, rx798_eos, rx798_done
    set rx798_off, 0
    lt rx798_pos, 2, rx798_start
    sub rx798_off, rx798_pos, 1
    substr rx798_tgt, rx798_tgt, rx798_off
  rx798_start:
    eq $I10, 1, rx798_restart
    if_null rx798_debug, debug_747
    rx798_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_747:
    $I10 = self.'from'()
    ne $I10, -1, rxscan802_done
    goto rxscan802_scan
  rxscan802_loop:
    (rx798_pos) = rx798_cur."from"()
    inc rx798_pos
    rx798_cur."!cursor_from"(rx798_pos)
    ge rx798_pos, rx798_eos, rxscan802_done
  rxscan802_scan:
    set_addr $I10, rxscan802_loop
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxscan802_done:
.annotate 'line', 373
  # rx subcapture "sym"
    set_addr $I10, rxcap_803_fail
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  # rx literal  "sub"
    add $I11, rx798_pos, 3
    gt $I11, rx798_eos, rx798_fail
    sub $I11, rx798_pos, rx798_off
    substr $S10, rx798_tgt, $I11, 3
    ne $S10, "sub", rx798_fail
    add rx798_pos, 3
    set_addr $I10, rxcap_803_fail
    ($I12, $I11) = rx798_cur."!mark_peek"($I10)
    rx798_cur."!cursor_pos"($I11)
    ($P10) = rx798_cur."!cursor_start"()
    $P10."!cursor_pass"(rx798_pos, "")
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_803_done
  rxcap_803_fail:
    goto rx798_fail
  rxcap_803_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."routine_def"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx798_pos = $P10."pos"()
  # rx pass
    rx798_cur."!cursor_pass"(rx798_pos, "routine_declarator:sym<sub>")
    if_null rx798_debug, debug_748
    rx798_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx798_pos)
  debug_748:
    .return (rx798_cur)
  rx798_restart:
.annotate 'line', 4
    if_null rx798_debug, debug_749
    rx798_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_749:
  rx798_fail:
    (rx798_rep, rx798_pos, $I10, $P10) = rx798_cur."!mark_fail"(0)
    lt rx798_pos, -1, rx798_done
    eq rx798_pos, -1, rx798_fail
    jump $I10
  rx798_done:
    rx798_cur."!cursor_fail"()
    if_null rx798_debug, debug_750
    rx798_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_750:
    .return (rx798_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("169_1299602538.98") :method
.annotate 'line', 4
    $P800 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P801, "ResizablePMCArray"
    push $P801, $P800
    .return ($P801)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("170_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx805_tgt
    .local int rx805_pos
    .local int rx805_off
    .local int rx805_eos
    .local int rx805_rep
    .local pmc rx805_cur
    .local pmc rx805_debug
    (rx805_cur, rx805_pos, rx805_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx805_cur
    .local pmc match
    .lex "$/", match
    length rx805_eos, rx805_tgt
    gt rx805_pos, rx805_eos, rx805_done
    set rx805_off, 0
    lt rx805_pos, 2, rx805_start
    sub rx805_off, rx805_pos, 1
    substr rx805_tgt, rx805_tgt, rx805_off
  rx805_start:
    eq $I10, 1, rx805_restart
    if_null rx805_debug, debug_751
    rx805_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_751:
    $I10 = self.'from'()
    ne $I10, -1, rxscan809_done
    goto rxscan809_scan
  rxscan809_loop:
    (rx805_pos) = rx805_cur."from"()
    inc rx805_pos
    rx805_cur."!cursor_from"(rx805_pos)
    ge rx805_pos, rx805_eos, rxscan809_done
  rxscan809_scan:
    set_addr $I10, rxscan809_loop
    rx805_cur."!mark_push"(0, rx805_pos, $I10)
  rxscan809_done:
.annotate 'line', 374
  # rx subcapture "sym"
    set_addr $I10, rxcap_810_fail
    rx805_cur."!mark_push"(0, rx805_pos, $I10)
  # rx literal  "method"
    add $I11, rx805_pos, 6
    gt $I11, rx805_eos, rx805_fail
    sub $I11, rx805_pos, rx805_off
    substr $S10, rx805_tgt, $I11, 6
    ne $S10, "method", rx805_fail
    add rx805_pos, 6
    set_addr $I10, rxcap_810_fail
    ($I12, $I11) = rx805_cur."!mark_peek"($I10)
    rx805_cur."!cursor_pos"($I11)
    ($P10) = rx805_cur."!cursor_start"()
    $P10."!cursor_pass"(rx805_pos, "")
    rx805_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_810_done
  rxcap_810_fail:
    goto rx805_fail
  rxcap_810_done:
  # rx subrule "method_def" subtype=capture negate=
    rx805_cur."!cursor_pos"(rx805_pos)
    $P10 = rx805_cur."method_def"()
    unless $P10, rx805_fail
    rx805_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx805_pos = $P10."pos"()
  # rx pass
    rx805_cur."!cursor_pass"(rx805_pos, "routine_declarator:sym<method>")
    if_null rx805_debug, debug_752
    rx805_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx805_pos)
  debug_752:
    .return (rx805_cur)
  rx805_restart:
.annotate 'line', 4
    if_null rx805_debug, debug_753
    rx805_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_753:
  rx805_fail:
    (rx805_rep, rx805_pos, $I10, $P10) = rx805_cur."!mark_fail"(0)
    lt rx805_pos, -1, rx805_done
    eq rx805_pos, -1, rx805_fail
    jump $I10
  rx805_done:
    rx805_cur."!cursor_fail"()
    if_null rx805_debug, debug_754
    rx805_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_754:
    .return (rx805_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("171_1299602538.98") :method
.annotate 'line', 4
    $P807 = self."!PREFIX__!subrule"("method_def", "method")
    new $P808, "ResizablePMCArray"
    push $P808, $P807
    .return ($P808)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("172_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 377
    new $P812, "Undef"
    .lex "$*RETURN_USED", $P812
.annotate 'line', 4
    .local string rx813_tgt
    .local int rx813_pos
    .local int rx813_off
    .local int rx813_eos
    .local int rx813_rep
    .local pmc rx813_cur
    .local pmc rx813_debug
    (rx813_cur, rx813_pos, rx813_tgt, $I10) = self."!cursor_start"()
    rx813_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx813_cur
    .local pmc match
    .lex "$/", match
    length rx813_eos, rx813_tgt
    gt rx813_pos, rx813_eos, rx813_done
    set rx813_off, 0
    lt rx813_pos, 2, rx813_start
    sub rx813_off, rx813_pos, 1
    substr rx813_tgt, rx813_tgt, rx813_off
  rx813_start:
    eq $I10, 1, rx813_restart
    if_null rx813_debug, debug_755
    rx813_cur."!cursor_debug"("START", "routine_def")
  debug_755:
    $I10 = self.'from'()
    ne $I10, -1, rxscan817_done
    goto rxscan817_scan
  rxscan817_loop:
    (rx813_pos) = rx813_cur."from"()
    inc rx813_pos
    rx813_cur."!cursor_from"(rx813_pos)
    ge rx813_pos, rx813_eos, rxscan817_done
  rxscan817_scan:
    set_addr $I10, rxscan817_loop
    rx813_cur."!mark_push"(0, rx813_pos, $I10)
  rxscan817_done:
.annotate 'line', 376
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
.annotate 'line', 377
    rx813_cur."!cursor_pos"(rx813_pos)
    new $P819, "Integer"
    assign $P819, 0
    store_lex "$*RETURN_USED", $P819
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
.annotate 'line', 378
  # rx rxquantr821 ** 0..1
    set_addr $I10, rxquantr821_done
    rx813_cur."!mark_push"(0, rx813_pos, $I10)
  rxquantr821_loop:
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_824_fail
    rx813_cur."!mark_push"(0, rx813_pos, $I10)
  # rx rxquantr823 ** 0..1
    set_addr $I10, rxquantr823_done
    rx813_cur."!mark_push"(0, rx813_pos, $I10)
  rxquantr823_loop:
  # rx literal  "&"
    add $I11, rx813_pos, 1
    gt $I11, rx813_eos, rx813_fail
    sub $I11, rx813_pos, rx813_off
    ord $I11, rx813_tgt, $I11
    ne $I11, 38, rx813_fail
    add rx813_pos, 1
    set_addr $I10, rxquantr823_done
    (rx813_rep) = rx813_cur."!mark_commit"($I10)
  rxquantr823_done:
    set_addr $I10, rxcap_824_fail
    ($I12, $I11) = rx813_cur."!mark_peek"($I10)
    rx813_cur."!cursor_pos"($I11)
    ($P10) = rx813_cur."!cursor_start"()
    $P10."!cursor_pass"(rx813_pos, "")
    rx813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_824_done
  rxcap_824_fail:
    goto rx813_fail
  rxcap_824_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."deflongname"()
    unless $P10, rx813_fail
    rx813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx813_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
    set_addr $I10, rxquantr821_done
    (rx813_rep) = rx813_cur."!mark_commit"($I10)
  rxquantr821_done:
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
.annotate 'line', 379
  # rx subrule "newpad" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."newpad"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  alt828_0:
.annotate 'line', 380
    set_addr $I10, alt828_1
    rx813_cur."!mark_push"(0, rx813_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx813_pos, 1
    gt $I11, rx813_eos, rx813_fail
    sub $I11, rx813_pos, rx813_off
    ord $I11, rx813_tgt, $I11
    ne $I11, 40, rx813_fail
    add rx813_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."signature"()
    unless $P10, rx813_fail
    rx813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx813_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx813_pos, 1
    gt $I11, rx813_eos, rx813_fail
    sub $I11, rx813_pos, rx813_off
    ord $I11, rx813_tgt, $I11
    ne $I11, 41, rx813_fail
    add rx813_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
    goto alt828_end
  alt828_1:
.annotate 'line', 381
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  alt828_end:
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
.annotate 'line', 382
  # rx rxquantr836 ** 0..*
    set_addr $I10, rxquantr836_done
    rx813_cur."!mark_push"(0, rx813_pos, $I10)
  rxquantr836_loop:
  # rx subrule "trait" subtype=capture negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."trait"()
    unless $P10, rx813_fail
    goto rxsubrule837_pass
  rxsubrule837_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx813_fail
  rxsubrule837_pass:
    set_addr $I10, rxsubrule837_back
    rx813_cur."!mark_push"(0, rx813_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx813_pos = $P10."pos"()
    set_addr $I10, rxquantr836_done
    (rx813_rep) = rx813_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr836_done
    rx813_cur."!mark_push"(rx813_rep, rx813_pos, $I10)
    goto rxquantr836_loop
  rxquantr836_done:
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  alt839_0:
.annotate 'line', 383
    set_addr $I10, alt839_1
    rx813_cur."!mark_push"(0, rx813_pos, $I10)
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."onlystar"()
    unless $P10, rx813_fail
    rx813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx813_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
    goto alt839_end
  alt839_1:
.annotate 'line', 385
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."blockoid"()
    unless $P10, rx813_fail
    rx813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx813_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
  alt839_end:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx813_cur."!cursor_pos"(rx813_pos)
    $P10 = rx813_cur."ws"()
    unless $P10, rx813_fail
    rx813_pos = $P10."pos"()
.annotate 'line', 376
  # rx pass
    rx813_cur."!cursor_pass"(rx813_pos, "routine_def")
    if_null rx813_debug, debug_756
    rx813_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx813_pos)
  debug_756:
    .return (rx813_cur)
  rx813_restart:
.annotate 'line', 4
    if_null rx813_debug, debug_757
    rx813_cur."!cursor_debug"("NEXT", "routine_def")
  debug_757:
  rx813_fail:
    (rx813_rep, rx813_pos, $I10, $P10) = rx813_cur."!mark_fail"(0)
    lt rx813_pos, -1, rx813_done
    eq rx813_pos, -1, rx813_fail
    jump $I10
  rx813_done:
    rx813_cur."!cursor_fail"()
    if_null rx813_debug, debug_758
    rx813_cur."!cursor_debug"("FAIL", "routine_def")
  debug_758:
    .return (rx813_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("173_1299602538.98") :method
.annotate 'line', 4
    $P815 = self."!PREFIX__!subrule"("ws", "")
    new $P816, "ResizablePMCArray"
    push $P816, $P815
    .return ($P816)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("174_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P876 = "176_1299602538.98" 
    capture_lex $P876
.annotate 'line', 390
    new $P846, "Undef"
    .lex "$*RETURN_USED", $P846
.annotate 'line', 391
    new $P847, "Undef"
    .lex "$*INVOCANT_OK", $P847
.annotate 'line', 4
    .local string rx848_tgt
    .local int rx848_pos
    .local int rx848_off
    .local int rx848_eos
    .local int rx848_rep
    .local pmc rx848_cur
    .local pmc rx848_debug
    (rx848_cur, rx848_pos, rx848_tgt, $I10) = self."!cursor_start"()
    rx848_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx848_cur
    .local pmc match
    .lex "$/", match
    length rx848_eos, rx848_tgt
    gt rx848_pos, rx848_eos, rx848_done
    set rx848_off, 0
    lt rx848_pos, 2, rx848_start
    sub rx848_off, rx848_pos, 1
    substr rx848_tgt, rx848_tgt, rx848_off
  rx848_start:
    eq $I10, 1, rx848_restart
    if_null rx848_debug, debug_759
    rx848_cur."!cursor_debug"("START", "method_def")
  debug_759:
    $I10 = self.'from'()
    ne $I10, -1, rxscan852_done
    goto rxscan852_scan
  rxscan852_loop:
    (rx848_pos) = rx848_cur."from"()
    inc rx848_pos
    rx848_cur."!cursor_from"(rx848_pos)
    ge rx848_pos, rx848_eos, rxscan852_done
  rxscan852_scan:
    set_addr $I10, rxscan852_loop
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
  rxscan852_done:
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 390
    rx848_cur."!cursor_pos"(rx848_pos)
    new $P854, "Integer"
    assign $P854, 0
    store_lex "$*RETURN_USED", $P854
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 391
    rx848_cur."!cursor_pos"(rx848_pos)
    new $P856, "Integer"
    assign $P856, 1
    store_lex "$*INVOCANT_OK", $P856
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 392
  # rx subcapture "private"
    set_addr $I10, rxcap_859_fail
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
  # rx rxquantr858 ** 0..1
    set_addr $I10, rxquantr858_done
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
  rxquantr858_loop:
  # rx literal  "!"
    add $I11, rx848_pos, 1
    gt $I11, rx848_eos, rx848_fail
    sub $I11, rx848_pos, rx848_off
    ord $I11, rx848_tgt, $I11
    ne $I11, 33, rx848_fail
    add rx848_pos, 1
    set_addr $I10, rxquantr858_done
    (rx848_rep) = rx848_cur."!mark_commit"($I10)
  rxquantr858_done:
    set_addr $I10, rxcap_859_fail
    ($I12, $I11) = rx848_cur."!mark_peek"($I10)
    rx848_cur."!cursor_pos"($I11)
    ($P10) = rx848_cur."!cursor_start"()
    $P10."!cursor_pass"(rx848_pos, "")
    rx848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_859_done
  rxcap_859_fail:
    goto rx848_fail
  rxcap_859_done:
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 393
  # rx rxquantr861 ** 0..1
    set_addr $I10, rxquantr861_done
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
  rxquantr861_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."deflongname"()
    unless $P10, rx848_fail
    goto rxsubrule862_pass
  rxsubrule862_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx848_fail
  rxsubrule862_pass:
    set_addr $I10, rxsubrule862_back
    rx848_cur."!mark_push"(0, rx848_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx848_pos = $P10."pos"()
    set_addr $I10, rxquantr861_done
    (rx848_rep) = rx848_cur."!mark_commit"($I10)
  rxquantr861_done:
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 394
  # rx subrule "newpad" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."newpad"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  alt865_0:
.annotate 'line', 395
    set_addr $I10, alt865_1
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx848_pos, 1
    gt $I11, rx848_eos, rx848_fail
    sub $I11, rx848_pos, rx848_off
    ord $I11, rx848_tgt, $I11
    ne $I11, 40, rx848_fail
    add rx848_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."signature"()
    unless $P10, rx848_fail
    rx848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx848_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx848_pos, 1
    gt $I11, rx848_eos, rx848_fail
    sub $I11, rx848_pos, rx848_off
    ord $I11, rx848_tgt, $I11
    ne $I11, 41, rx848_fail
    add rx848_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
    goto alt865_end
  alt865_1:
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  alt865_end:
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 397
    rx848_cur."!cursor_pos"(rx848_pos)
    find_lex $P873, unicode:"$\x{a2}"
    $P874 = $P873."MATCH"()
    store_lex "$/", $P874
    .const 'Sub' $P876 = "176_1299602538.98" 
    capture_lex $P876
    $P878 = $P876()
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 398
  # rx rxquantr880 ** 0..*
    set_addr $I10, rxquantr880_done
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
  rxquantr880_loop:
  # rx subrule "trait" subtype=capture negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."trait"()
    unless $P10, rx848_fail
    goto rxsubrule881_pass
  rxsubrule881_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx848_fail
  rxsubrule881_pass:
    set_addr $I10, rxsubrule881_back
    rx848_cur."!mark_push"(0, rx848_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx848_pos = $P10."pos"()
    set_addr $I10, rxquantr880_done
    (rx848_rep) = rx848_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr880_done
    rx848_cur."!mark_push"(rx848_rep, rx848_pos, $I10)
    goto rxquantr880_loop
  rxquantr880_done:
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  alt883_0:
.annotate 'line', 399
    set_addr $I10, alt883_1
    rx848_cur."!mark_push"(0, rx848_pos, $I10)
.annotate 'line', 400
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."onlystar"()
    unless $P10, rx848_fail
    rx848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx848_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
    goto alt883_end
  alt883_1:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."blockoid"()
    unless $P10, rx848_fail
    rx848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx848_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
  alt883_end:
.annotate 'line', 402
  # rx subrule "ws" subtype=method negate=
    rx848_cur."!cursor_pos"(rx848_pos)
    $P10 = rx848_cur."ws"()
    unless $P10, rx848_fail
    rx848_pos = $P10."pos"()
.annotate 'line', 389
  # rx pass
    rx848_cur."!cursor_pass"(rx848_pos, "method_def")
    if_null rx848_debug, debug_760
    rx848_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx848_pos)
  debug_760:
    .return (rx848_cur)
  rx848_restart:
.annotate 'line', 4
    if_null rx848_debug, debug_761
    rx848_cur."!cursor_debug"("NEXT", "method_def")
  debug_761:
  rx848_fail:
    (rx848_rep, rx848_pos, $I10, $P10) = rx848_cur."!mark_fail"(0)
    lt rx848_pos, -1, rx848_done
    eq rx848_pos, -1, rx848_fail
    jump $I10
  rx848_done:
    rx848_cur."!cursor_fail"()
    if_null rx848_debug, debug_762
    rx848_cur."!cursor_debug"("FAIL", "method_def")
  debug_762:
    .return (rx848_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("175_1299602538.98") :method
.annotate 'line', 4
    $P850 = self."!PREFIX__!subrule"("ws", "")
    new $P851, "ResizablePMCArray"
    push $P851, $P850
    .return ($P851)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block875"  :anon :subid("176_1299602538.98") :outer("174_1299602538.98")
.annotate 'line', 397
    new $P877, "Integer"
    assign $P877, 0
    store_dynamic_lex "$*INVOCANT_OK", $P877
    .return ($P877)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("177_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P897 = "179_1299602538.98" 
    capture_lex $P897
    .local string rx890_tgt
    .local int rx890_pos
    .local int rx890_off
    .local int rx890_eos
    .local int rx890_rep
    .local pmc rx890_cur
    .local pmc rx890_debug
    (rx890_cur, rx890_pos, rx890_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx890_cur
    .local pmc match
    .lex "$/", match
    length rx890_eos, rx890_tgt
    gt rx890_pos, rx890_eos, rx890_done
    set rx890_off, 0
    lt rx890_pos, 2, rx890_start
    sub rx890_off, rx890_pos, 1
    substr rx890_tgt, rx890_tgt, rx890_off
  rx890_start:
    eq $I10, 1, rx890_restart
    if_null rx890_debug, debug_763
    rx890_cur."!cursor_debug"("START", "onlystar")
  debug_763:
    $I10 = self.'from'()
    ne $I10, -1, rxscan893_done
    goto rxscan893_scan
  rxscan893_loop:
    (rx890_pos) = rx890_cur."from"()
    inc rx890_pos
    rx890_cur."!cursor_from"(rx890_pos)
    ge rx890_pos, rx890_eos, rxscan893_done
  rxscan893_scan:
    set_addr $I10, rxscan893_loop
    rx890_cur."!mark_push"(0, rx890_pos, $I10)
  rxscan893_done:
.annotate 'line', 406
    rx890_cur."!cursor_pos"(rx890_pos)
    find_lex $P894, unicode:"$\x{a2}"
    $P895 = $P894."MATCH"()
    store_lex "$/", $P895
    .const 'Sub' $P897 = "179_1299602538.98" 
    capture_lex $P897
    $P901 = $P897()
    unless $P901, rx890_fail
.annotate 'line', 407
  # rx literal  "{"
    add $I11, rx890_pos, 1
    gt $I11, rx890_eos, rx890_fail
    sub $I11, rx890_pos, rx890_off
    ord $I11, rx890_tgt, $I11
    ne $I11, 123, rx890_fail
    add rx890_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx890_cur."!cursor_pos"(rx890_pos)
    $P10 = rx890_cur."ws"()
    unless $P10, rx890_fail
    rx890_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx890_pos, 1
    gt $I11, rx890_eos, rx890_fail
    sub $I11, rx890_pos, rx890_off
    ord $I11, rx890_tgt, $I11
    ne $I11, 42, rx890_fail
    add rx890_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx890_cur."!cursor_pos"(rx890_pos)
    $P10 = rx890_cur."ws"()
    unless $P10, rx890_fail
    rx890_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx890_pos, 1
    gt $I11, rx890_eos, rx890_fail
    sub $I11, rx890_pos, rx890_off
    ord $I11, rx890_tgt, $I11
    ne $I11, 125, rx890_fail
    add rx890_pos, 1
.annotate 'line', 408
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx890_cur."!cursor_pos"(rx890_pos)
    $P10 = rx890_cur."ENDSTMT"()
    unless $P10, rx890_fail
.annotate 'line', 409
  # rx subrule "finishpad" subtype=method negate=
    rx890_cur."!cursor_pos"(rx890_pos)
    $P10 = rx890_cur."finishpad"()
    unless $P10, rx890_fail
    rx890_pos = $P10."pos"()
.annotate 'line', 405
  # rx pass
    rx890_cur."!cursor_pass"(rx890_pos, "onlystar")
    if_null rx890_debug, debug_766
    rx890_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx890_pos)
  debug_766:
    .return (rx890_cur)
  rx890_restart:
.annotate 'line', 4
    if_null rx890_debug, debug_767
    rx890_cur."!cursor_debug"("NEXT", "onlystar")
  debug_767:
  rx890_fail:
    (rx890_rep, rx890_pos, $I10, $P10) = rx890_cur."!mark_fail"(0)
    lt rx890_pos, -1, rx890_done
    eq rx890_pos, -1, rx890_fail
    jump $I10
  rx890_done:
    rx890_cur."!cursor_fail"()
    if_null rx890_debug, debug_768
    rx890_cur."!cursor_debug"("FAIL", "onlystar")
  debug_768:
    .return (rx890_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("178_1299602538.98") :method
.annotate 'line', 4
    new $P892, "ResizablePMCArray"
    push $P892, ""
    .return ($P892)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block896"  :anon :subid("179_1299602538.98") :outer("177_1299602538.98")
.annotate 'line', 406
    find_dynamic_lex $P898, "$*MULTINESS"
    unless_null $P898, vivify_764
    get_hll_global $P898, "$MULTINESS"
    unless_null $P898, vivify_765
    die "Contextual $*MULTINESS not found"
  vivify_765:
  vivify_764:
    set $S899, $P898
    iseq $I900, $S899, "proto"
    .return ($I900)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("180_1299602538.98")
    .param pmc param_903
.annotate 'line', 412
    .lex "self", param_903
    $P904 = param_903."!protoregex"("multi_declarator")
    .return ($P904)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("181_1299602538.98")
    .param pmc param_906
.annotate 'line', 412
    .lex "self", param_906
    $P907 = param_906."!PREFIX__!protoregex"("multi_declarator")
    .return ($P907)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("182_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 414
    new $P909, "Undef"
    .lex "$*MULTINESS", $P909
.annotate 'line', 4
    .local string rx910_tgt
    .local int rx910_pos
    .local int rx910_off
    .local int rx910_eos
    .local int rx910_rep
    .local pmc rx910_cur
    .local pmc rx910_debug
    (rx910_cur, rx910_pos, rx910_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx910_cur
    .local pmc match
    .lex "$/", match
    length rx910_eos, rx910_tgt
    gt rx910_pos, rx910_eos, rx910_done
    set rx910_off, 0
    lt rx910_pos, 2, rx910_start
    sub rx910_off, rx910_pos, 1
    substr rx910_tgt, rx910_tgt, rx910_off
  rx910_start:
    eq $I10, 1, rx910_restart
    if_null rx910_debug, debug_769
    rx910_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_769:
    $I10 = self.'from'()
    ne $I10, -1, rxscan914_done
    goto rxscan914_scan
  rxscan914_loop:
    (rx910_pos) = rx910_cur."from"()
    inc rx910_pos
    rx910_cur."!cursor_from"(rx910_pos)
    ge rx910_pos, rx910_eos, rxscan914_done
  rxscan914_scan:
    set_addr $I10, rxscan914_loop
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxscan914_done:
.annotate 'line', 414
    rx910_cur."!cursor_pos"(rx910_pos)
    new $P915, "String"
    assign $P915, "multi"
    store_lex "$*MULTINESS", $P915
.annotate 'line', 415
  # rx subcapture "sym"
    set_addr $I10, rxcap_916_fail
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  # rx literal  "multi"
    add $I11, rx910_pos, 5
    gt $I11, rx910_eos, rx910_fail
    sub $I11, rx910_pos, rx910_off
    substr $S10, rx910_tgt, $I11, 5
    ne $S10, "multi", rx910_fail
    add rx910_pos, 5
    set_addr $I10, rxcap_916_fail
    ($I12, $I11) = rx910_cur."!mark_peek"($I10)
    rx910_cur."!cursor_pos"($I11)
    ($P10) = rx910_cur."!cursor_start"()
    $P10."!cursor_pass"(rx910_pos, "")
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_916_done
  rxcap_916_fail:
    goto rx910_fail
  rxcap_916_done:
.annotate 'line', 416
  # rx subrule "ws" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ws"()
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  alt917_0:
    set_addr $I10, alt917_1
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."declarator"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx910_pos = $P10."pos"()
    goto alt917_end
  alt917_1:
    set_addr $I10, alt917_2
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."routine_def"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx910_pos = $P10."pos"()
    goto alt917_end
  alt917_2:
  # rx subrule "panic" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."panic"("Malformed multi")
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  alt917_end:
.annotate 'line', 413
  # rx pass
    rx910_cur."!cursor_pass"(rx910_pos, "multi_declarator:sym<multi>")
    if_null rx910_debug, debug_770
    rx910_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx910_pos)
  debug_770:
    .return (rx910_cur)
  rx910_restart:
.annotate 'line', 4
    if_null rx910_debug, debug_771
    rx910_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_771:
  rx910_fail:
    (rx910_rep, rx910_pos, $I10, $P10) = rx910_cur."!mark_fail"(0)
    lt rx910_pos, -1, rx910_done
    eq rx910_pos, -1, rx910_fail
    jump $I10
  rx910_done:
    rx910_cur."!cursor_fail"()
    if_null rx910_debug, debug_772
    rx910_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_772:
    .return (rx910_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("183_1299602538.98") :method
.annotate 'line', 4
    $P912 = self."!PREFIX__!subrule"("ws", "multi")
    new $P913, "ResizablePMCArray"
    push $P913, $P912
    .return ($P913)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("184_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 419
    new $P919, "Undef"
    .lex "$*MULTINESS", $P919
.annotate 'line', 4
    .local string rx920_tgt
    .local int rx920_pos
    .local int rx920_off
    .local int rx920_eos
    .local int rx920_rep
    .local pmc rx920_cur
    .local pmc rx920_debug
    (rx920_cur, rx920_pos, rx920_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx920_cur
    .local pmc match
    .lex "$/", match
    length rx920_eos, rx920_tgt
    gt rx920_pos, rx920_eos, rx920_done
    set rx920_off, 0
    lt rx920_pos, 2, rx920_start
    sub rx920_off, rx920_pos, 1
    substr rx920_tgt, rx920_tgt, rx920_off
  rx920_start:
    eq $I10, 1, rx920_restart
    if_null rx920_debug, debug_773
    rx920_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_773:
    $I10 = self.'from'()
    ne $I10, -1, rxscan924_done
    goto rxscan924_scan
  rxscan924_loop:
    (rx920_pos) = rx920_cur."from"()
    inc rx920_pos
    rx920_cur."!cursor_from"(rx920_pos)
    ge rx920_pos, rx920_eos, rxscan924_done
  rxscan924_scan:
    set_addr $I10, rxscan924_loop
    rx920_cur."!mark_push"(0, rx920_pos, $I10)
  rxscan924_done:
.annotate 'line', 419
    rx920_cur."!cursor_pos"(rx920_pos)
    new $P925, "String"
    assign $P925, "proto"
    store_lex "$*MULTINESS", $P925
.annotate 'line', 420
  # rx subcapture "sym"
    set_addr $I10, rxcap_926_fail
    rx920_cur."!mark_push"(0, rx920_pos, $I10)
  # rx literal  "proto"
    add $I11, rx920_pos, 5
    gt $I11, rx920_eos, rx920_fail
    sub $I11, rx920_pos, rx920_off
    substr $S10, rx920_tgt, $I11, 5
    ne $S10, "proto", rx920_fail
    add rx920_pos, 5
    set_addr $I10, rxcap_926_fail
    ($I12, $I11) = rx920_cur."!mark_peek"($I10)
    rx920_cur."!cursor_pos"($I11)
    ($P10) = rx920_cur."!cursor_start"()
    $P10."!cursor_pass"(rx920_pos, "")
    rx920_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_926_done
  rxcap_926_fail:
    goto rx920_fail
  rxcap_926_done:
.annotate 'line', 421
  # rx subrule "ws" subtype=method negate=
    rx920_cur."!cursor_pos"(rx920_pos)
    $P10 = rx920_cur."ws"()
    unless $P10, rx920_fail
    rx920_pos = $P10."pos"()
  alt927_0:
    set_addr $I10, alt927_1
    rx920_cur."!mark_push"(0, rx920_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx920_cur."!cursor_pos"(rx920_pos)
    $P10 = rx920_cur."declarator"()
    unless $P10, rx920_fail
    rx920_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx920_pos = $P10."pos"()
    goto alt927_end
  alt927_1:
    set_addr $I10, alt927_2
    rx920_cur."!mark_push"(0, rx920_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx920_cur."!cursor_pos"(rx920_pos)
    $P10 = rx920_cur."routine_def"()
    unless $P10, rx920_fail
    rx920_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx920_pos = $P10."pos"()
    goto alt927_end
  alt927_2:
  # rx subrule "panic" subtype=method negate=
    rx920_cur."!cursor_pos"(rx920_pos)
    $P10 = rx920_cur."panic"("Malformed proto")
    unless $P10, rx920_fail
    rx920_pos = $P10."pos"()
  alt927_end:
.annotate 'line', 418
  # rx pass
    rx920_cur."!cursor_pass"(rx920_pos, "multi_declarator:sym<proto>")
    if_null rx920_debug, debug_774
    rx920_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx920_pos)
  debug_774:
    .return (rx920_cur)
  rx920_restart:
.annotate 'line', 4
    if_null rx920_debug, debug_775
    rx920_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_775:
  rx920_fail:
    (rx920_rep, rx920_pos, $I10, $P10) = rx920_cur."!mark_fail"(0)
    lt rx920_pos, -1, rx920_done
    eq rx920_pos, -1, rx920_fail
    jump $I10
  rx920_done:
    rx920_cur."!cursor_fail"()
    if_null rx920_debug, debug_776
    rx920_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_776:
    .return (rx920_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("185_1299602538.98") :method
.annotate 'line', 4
    $P922 = self."!PREFIX__!subrule"("ws", "proto")
    new $P923, "ResizablePMCArray"
    push $P923, $P922
    .return ($P923)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("186_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 424
    new $P929, "Undef"
    .lex "$*MULTINESS", $P929
.annotate 'line', 4
    .local string rx930_tgt
    .local int rx930_pos
    .local int rx930_off
    .local int rx930_eos
    .local int rx930_rep
    .local pmc rx930_cur
    .local pmc rx930_debug
    (rx930_cur, rx930_pos, rx930_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx930_cur
    .local pmc match
    .lex "$/", match
    length rx930_eos, rx930_tgt
    gt rx930_pos, rx930_eos, rx930_done
    set rx930_off, 0
    lt rx930_pos, 2, rx930_start
    sub rx930_off, rx930_pos, 1
    substr rx930_tgt, rx930_tgt, rx930_off
  rx930_start:
    eq $I10, 1, rx930_restart
    if_null rx930_debug, debug_777
    rx930_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_777:
    $I10 = self.'from'()
    ne $I10, -1, rxscan934_done
    goto rxscan934_scan
  rxscan934_loop:
    (rx930_pos) = rx930_cur."from"()
    inc rx930_pos
    rx930_cur."!cursor_from"(rx930_pos)
    ge rx930_pos, rx930_eos, rxscan934_done
  rxscan934_scan:
    set_addr $I10, rxscan934_loop
    rx930_cur."!mark_push"(0, rx930_pos, $I10)
  rxscan934_done:
.annotate 'line', 424
    rx930_cur."!cursor_pos"(rx930_pos)
    new $P935, "String"
    assign $P935, ""
    store_lex "$*MULTINESS", $P935
.annotate 'line', 425
  # rx subrule "declarator" subtype=capture negate=
    rx930_cur."!cursor_pos"(rx930_pos)
    $P10 = rx930_cur."declarator"()
    unless $P10, rx930_fail
    rx930_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx930_pos = $P10."pos"()
.annotate 'line', 423
  # rx pass
    rx930_cur."!cursor_pass"(rx930_pos, "multi_declarator:sym<null>")
    if_null rx930_debug, debug_778
    rx930_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx930_pos)
  debug_778:
    .return (rx930_cur)
  rx930_restart:
.annotate 'line', 4
    if_null rx930_debug, debug_779
    rx930_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_779:
  rx930_fail:
    (rx930_rep, rx930_pos, $I10, $P10) = rx930_cur."!mark_fail"(0)
    lt rx930_pos, -1, rx930_done
    eq rx930_pos, -1, rx930_fail
    jump $I10
  rx930_done:
    rx930_cur."!cursor_fail"()
    if_null rx930_debug, debug_780
    rx930_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_780:
    .return (rx930_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("187_1299602538.98") :method
.annotate 'line', 4
    $P932 = self."!PREFIX__!subrule"("declarator", "")
    new $P933, "ResizablePMCArray"
    push $P933, $P932
    .return ($P933)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("188_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P945 = "190_1299602538.98" 
    capture_lex $P945
    .local string rx937_tgt
    .local int rx937_pos
    .local int rx937_off
    .local int rx937_eos
    .local int rx937_rep
    .local pmc rx937_cur
    .local pmc rx937_debug
    (rx937_cur, rx937_pos, rx937_tgt, $I10) = self."!cursor_start"()
    rx937_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx937_cur
    .local pmc match
    .lex "$/", match
    length rx937_eos, rx937_tgt
    gt rx937_pos, rx937_eos, rx937_done
    set rx937_off, 0
    lt rx937_pos, 2, rx937_start
    sub rx937_off, rx937_pos, 1
    substr rx937_tgt, rx937_tgt, rx937_off
  rx937_start:
    eq $I10, 1, rx937_restart
    if_null rx937_debug, debug_781
    rx937_cur."!cursor_debug"("START", "signature")
  debug_781:
    $I10 = self.'from'()
    ne $I10, -1, rxscan940_done
    goto rxscan940_scan
  rxscan940_loop:
    (rx937_pos) = rx937_cur."from"()
    inc rx937_pos
    rx937_cur."!cursor_from"(rx937_pos)
    ge rx937_pos, rx937_eos, rxscan940_done
  rxscan940_scan:
    set_addr $I10, rxscan940_loop
    rx937_cur."!mark_push"(0, rx937_pos, $I10)
  rxscan940_done:
.annotate 'line', 429
  # rx rxquantr941 ** 0..1
    set_addr $I10, rxquantr941_done
    rx937_cur."!mark_push"(0, rx937_pos, $I10)
  rxquantr941_loop:
    rx937_cur."!cursor_pos"(rx937_pos)
    find_lex $P942, unicode:"$\x{a2}"
    $P943 = $P942."MATCH"()
    store_lex "$/", $P943
    .const 'Sub' $P945 = "190_1299602538.98" 
    capture_lex $P945
    $P947 = $P945()
    unless $P947, rx937_fail
  # rx subrule "ws" subtype=method negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."ws"()
    unless $P10, rx937_fail
    rx937_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."parameter"()
    unless $P10, rx937_fail
    rx937_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx937_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."ws"()
    unless $P10, rx937_fail
    rx937_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx937_pos, 1
    gt $I11, rx937_eos, rx937_fail
    sub $I11, rx937_pos, rx937_off
    ord $I11, rx937_tgt, $I11
    ne $I11, 58, rx937_fail
    add rx937_pos, 1
    set_addr $I10, rxquantr941_done
    (rx937_rep) = rx937_cur."!mark_commit"($I10)
  rxquantr941_done:
.annotate 'line', 430
  # rx rxquantr948 ** 0..1
    set_addr $I10, rxquantr948_done
    rx937_cur."!mark_push"(0, rx937_pos, $I10)
  rxquantr948_loop:
  # rx rxquantr949 ** 1..*
    set_addr $I10, rxquantr949_done
    rx937_cur."!mark_push"(0, -1, $I10)
  rxquantr949_loop:
  # rx subrule "ws" subtype=method negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."ws"()
    unless $P10, rx937_fail
    rx937_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."parameter"()
    unless $P10, rx937_fail
    rx937_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx937_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."ws"()
    unless $P10, rx937_fail
    rx937_pos = $P10."pos"()
    set_addr $I10, rxquantr949_done
    (rx937_rep) = rx937_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr949_done
    rx937_cur."!mark_push"(rx937_rep, rx937_pos, $I10)
  # rx literal  ","
    add $I11, rx937_pos, 1
    gt $I11, rx937_eos, rx937_fail
    sub $I11, rx937_pos, rx937_off
    ord $I11, rx937_tgt, $I11
    ne $I11, 44, rx937_fail
    add rx937_pos, 1
    goto rxquantr949_loop
  rxquantr949_done:
    set_addr $I10, rxquantr948_done
    (rx937_rep) = rx937_cur."!mark_commit"($I10)
  rxquantr948_done:
.annotate 'line', 428
  # rx pass
    rx937_cur."!cursor_pass"(rx937_pos, "signature")
    if_null rx937_debug, debug_784
    rx937_cur."!cursor_debug"("PASS", "signature", " at pos=", rx937_pos)
  debug_784:
    .return (rx937_cur)
  rx937_restart:
.annotate 'line', 4
    if_null rx937_debug, debug_785
    rx937_cur."!cursor_debug"("NEXT", "signature")
  debug_785:
  rx937_fail:
    (rx937_rep, rx937_pos, $I10, $P10) = rx937_cur."!mark_fail"(0)
    lt rx937_pos, -1, rx937_done
    eq rx937_pos, -1, rx937_fail
    jump $I10
  rx937_done:
    rx937_cur."!cursor_fail"()
    if_null rx937_debug, debug_786
    rx937_cur."!cursor_debug"("FAIL", "signature")
  debug_786:
    .return (rx937_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("189_1299602538.98") :method
.annotate 'line', 4
    new $P939, "ResizablePMCArray"
    push $P939, ""
    .return ($P939)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block944"  :anon :subid("190_1299602538.98") :outer("188_1299602538.98")
.annotate 'line', 429
    find_dynamic_lex $P946, "$*INVOCANT_OK"
    unless_null $P946, vivify_782
    get_hll_global $P946, "$INVOCANT_OK"
    unless_null $P946, vivify_783
    die "Contextual $*INVOCANT_OK not found"
  vivify_783:
  vivify_782:
    .return ($P946)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("191_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx951_tgt
    .local int rx951_pos
    .local int rx951_off
    .local int rx951_eos
    .local int rx951_rep
    .local pmc rx951_cur
    .local pmc rx951_debug
    (rx951_cur, rx951_pos, rx951_tgt, $I10) = self."!cursor_start"()
    rx951_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx951_cur
    .local pmc match
    .lex "$/", match
    length rx951_eos, rx951_tgt
    gt rx951_pos, rx951_eos, rx951_done
    set rx951_off, 0
    lt rx951_pos, 2, rx951_start
    sub rx951_off, rx951_pos, 1
    substr rx951_tgt, rx951_tgt, rx951_off
  rx951_start:
    eq $I10, 1, rx951_restart
    if_null rx951_debug, debug_787
    rx951_cur."!cursor_debug"("START", "parameter")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan954_done
    goto rxscan954_scan
  rxscan954_loop:
    (rx951_pos) = rx951_cur."from"()
    inc rx951_pos
    rx951_cur."!cursor_from"(rx951_pos)
    ge rx951_pos, rx951_eos, rxscan954_done
  rxscan954_scan:
    set_addr $I10, rxscan954_loop
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  rxscan954_done:
.annotate 'line', 434
  # rx rxquantr955 ** 0..*
    set_addr $I10, rxquantr955_done
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  rxquantr955_loop:
  # rx subrule "typename" subtype=capture negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."typename"()
    unless $P10, rx951_fail
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx951_pos = $P10."pos"()
  # rx rxquantr956 ** 0..1
    set_addr $I10, rxquantr956_done
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  rxquantr956_loop:
  # rx literal  ":"
    add $I11, rx951_pos, 1
    gt $I11, rx951_eos, rx951_fail
    sub $I11, rx951_pos, rx951_off
    ord $I11, rx951_tgt, $I11
    ne $I11, 58, rx951_fail
    add rx951_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_957_fail
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx951_pos, rx951_eos, rx951_fail
    sub $I10, rx951_pos, rx951_off
    substr $S10, rx951_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx951_fail
    inc rx951_pos
    set_addr $I10, rxcap_957_fail
    ($I12, $I11) = rx951_cur."!mark_peek"($I10)
    rx951_cur."!cursor_pos"($I11)
    ($P10) = rx951_cur."!cursor_start"()
    $P10."!cursor_pass"(rx951_pos, "")
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_957_done
  rxcap_957_fail:
    goto rx951_fail
  rxcap_957_done:
    set_addr $I10, rxquantr956_done
    (rx951_rep) = rx951_cur."!mark_commit"($I10)
  rxquantr956_done:
  # rx subrule "ws" subtype=method negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."ws"()
    unless $P10, rx951_fail
    rx951_pos = $P10."pos"()
    set_addr $I10, rxquantr955_done
    (rx951_rep) = rx951_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr955_done
    rx951_cur."!mark_push"(rx951_rep, rx951_pos, $I10)
    goto rxquantr955_loop
  rxquantr955_done:
  alt958_0:
.annotate 'line', 435
    set_addr $I10, alt958_1
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
.annotate 'line', 436
  # rx subcapture "quant"
    set_addr $I10, rxcap_959_fail
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  # rx literal  "*"
    add $I11, rx951_pos, 1
    gt $I11, rx951_eos, rx951_fail
    sub $I11, rx951_pos, rx951_off
    ord $I11, rx951_tgt, $I11
    ne $I11, 42, rx951_fail
    add rx951_pos, 1
    set_addr $I10, rxcap_959_fail
    ($I12, $I11) = rx951_cur."!mark_peek"($I10)
    rx951_cur."!cursor_pos"($I11)
    ($P10) = rx951_cur."!cursor_start"()
    $P10."!cursor_pass"(rx951_pos, "")
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_959_done
  rxcap_959_fail:
    goto rx951_fail
  rxcap_959_done:
  # rx subrule "param_var" subtype=capture negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."param_var"()
    unless $P10, rx951_fail
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx951_pos = $P10."pos"()
    goto alt958_end
  alt958_1:
  alt960_0:
.annotate 'line', 437
    set_addr $I10, alt960_1
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."param_var"()
    unless $P10, rx951_fail
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx951_pos = $P10."pos"()
    goto alt960_end
  alt960_1:
  # rx subrule "named_param" subtype=capture negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."named_param"()
    unless $P10, rx951_fail
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx951_pos = $P10."pos"()
  alt960_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_962_fail
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  alt961_0:
    set_addr $I10, alt961_1
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  # rx literal  "?"
    add $I11, rx951_pos, 1
    gt $I11, rx951_eos, rx951_fail
    sub $I11, rx951_pos, rx951_off
    ord $I11, rx951_tgt, $I11
    ne $I11, 63, rx951_fail
    add rx951_pos, 1
    goto alt961_end
  alt961_1:
    set_addr $I10, alt961_2
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  # rx literal  "!"
    add $I11, rx951_pos, 1
    gt $I11, rx951_eos, rx951_fail
    sub $I11, rx951_pos, rx951_off
    ord $I11, rx951_tgt, $I11
    ne $I11, 33, rx951_fail
    add rx951_pos, 1
    goto alt961_end
  alt961_2:
  alt961_end:
    set_addr $I10, rxcap_962_fail
    ($I12, $I11) = rx951_cur."!mark_peek"($I10)
    rx951_cur."!cursor_pos"($I11)
    ($P10) = rx951_cur."!cursor_start"()
    $P10."!cursor_pass"(rx951_pos, "")
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_962_done
  rxcap_962_fail:
    goto rx951_fail
  rxcap_962_done:
  alt958_end:
.annotate 'line', 439
  # rx rxquantr963 ** 0..1
    set_addr $I10, rxquantr963_done
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  rxquantr963_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."default_value"()
    unless $P10, rx951_fail
    goto rxsubrule964_pass
  rxsubrule964_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx951_fail
  rxsubrule964_pass:
    set_addr $I10, rxsubrule964_back
    rx951_cur."!mark_push"(0, rx951_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx951_pos = $P10."pos"()
    set_addr $I10, rxquantr963_done
    (rx951_rep) = rx951_cur."!mark_commit"($I10)
  rxquantr963_done:
.annotate 'line', 433
  # rx pass
    rx951_cur."!cursor_pass"(rx951_pos, "parameter")
    if_null rx951_debug, debug_788
    rx951_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx951_pos)
  debug_788:
    .return (rx951_cur)
  rx951_restart:
.annotate 'line', 4
    if_null rx951_debug, debug_789
    rx951_cur."!cursor_debug"("NEXT", "parameter")
  debug_789:
  rx951_fail:
    (rx951_rep, rx951_pos, $I10, $P10) = rx951_cur."!mark_fail"(0)
    lt rx951_pos, -1, rx951_done
    eq rx951_pos, -1, rx951_fail
    jump $I10
  rx951_done:
    rx951_cur."!cursor_fail"()
    if_null rx951_debug, debug_790
    rx951_cur."!cursor_debug"("FAIL", "parameter")
  debug_790:
    .return (rx951_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("192_1299602538.98") :method
.annotate 'line', 4
    new $P953, "ResizablePMCArray"
    push $P953, ""
    .return ($P953)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("193_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx966_tgt
    .local int rx966_pos
    .local int rx966_off
    .local int rx966_eos
    .local int rx966_rep
    .local pmc rx966_cur
    .local pmc rx966_debug
    (rx966_cur, rx966_pos, rx966_tgt, $I10) = self."!cursor_start"()
    rx966_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx966_cur
    .local pmc match
    .lex "$/", match
    length rx966_eos, rx966_tgt
    gt rx966_pos, rx966_eos, rx966_done
    set rx966_off, 0
    lt rx966_pos, 2, rx966_start
    sub rx966_off, rx966_pos, 1
    substr rx966_tgt, rx966_tgt, rx966_off
  rx966_start:
    eq $I10, 1, rx966_restart
    if_null rx966_debug, debug_791
    rx966_cur."!cursor_debug"("START", "param_var")
  debug_791:
    $I10 = self.'from'()
    ne $I10, -1, rxscan970_done
    goto rxscan970_scan
  rxscan970_loop:
    (rx966_pos) = rx966_cur."from"()
    inc rx966_pos
    rx966_cur."!cursor_from"(rx966_pos)
    ge rx966_pos, rx966_eos, rxscan970_done
  rxscan970_scan:
    set_addr $I10, rxscan970_loop
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  rxscan970_done:
.annotate 'line', 443
  # rx subrule "sigil" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."sigil"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx966_pos = $P10."pos"()
  # rx rxquantr971 ** 0..1
    set_addr $I10, rxquantr971_done
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  rxquantr971_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."twigil"()
    unless $P10, rx966_fail
    goto rxsubrule972_pass
  rxsubrule972_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx966_fail
  rxsubrule972_pass:
    set_addr $I10, rxsubrule972_back
    rx966_cur."!mark_push"(0, rx966_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx966_pos = $P10."pos"()
    set_addr $I10, rxquantr971_done
    (rx966_rep) = rx966_cur."!mark_commit"($I10)
  rxquantr971_done:
  alt973_0:
.annotate 'line', 444
    set_addr $I10, alt973_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ident"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx966_pos = $P10."pos"()
    goto alt973_end
  alt973_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_974_fail
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx966_pos, rx966_eos, rx966_fail
    sub $I10, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx966_fail
    inc rx966_pos
    set_addr $I10, rxcap_974_fail
    ($I12, $I11) = rx966_cur."!mark_peek"($I10)
    rx966_cur."!cursor_pos"($I11)
    ($P10) = rx966_cur."!cursor_start"()
    $P10."!cursor_pass"(rx966_pos, "")
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_974_done
  rxcap_974_fail:
    goto rx966_fail
  rxcap_974_done:
  alt973_end:
.annotate 'line', 442
  # rx pass
    rx966_cur."!cursor_pass"(rx966_pos, "param_var")
    if_null rx966_debug, debug_792
    rx966_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx966_pos)
  debug_792:
    .return (rx966_cur)
  rx966_restart:
.annotate 'line', 4
    if_null rx966_debug, debug_793
    rx966_cur."!cursor_debug"("NEXT", "param_var")
  debug_793:
  rx966_fail:
    (rx966_rep, rx966_pos, $I10, $P10) = rx966_cur."!mark_fail"(0)
    lt rx966_pos, -1, rx966_done
    eq rx966_pos, -1, rx966_fail
    jump $I10
  rx966_done:
    rx966_cur."!cursor_fail"()
    if_null rx966_debug, debug_794
    rx966_cur."!cursor_debug"("FAIL", "param_var")
  debug_794:
    .return (rx966_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("194_1299602538.98") :method
.annotate 'line', 4
    $P968 = self."!PREFIX__!subrule"("sigil", "")
    new $P969, "ResizablePMCArray"
    push $P969, $P968
    .return ($P969)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("195_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx976_tgt
    .local int rx976_pos
    .local int rx976_off
    .local int rx976_eos
    .local int rx976_rep
    .local pmc rx976_cur
    .local pmc rx976_debug
    (rx976_cur, rx976_pos, rx976_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx976_cur
    .local pmc match
    .lex "$/", match
    length rx976_eos, rx976_tgt
    gt rx976_pos, rx976_eos, rx976_done
    set rx976_off, 0
    lt rx976_pos, 2, rx976_start
    sub rx976_off, rx976_pos, 1
    substr rx976_tgt, rx976_tgt, rx976_off
  rx976_start:
    eq $I10, 1, rx976_restart
    if_null rx976_debug, debug_795
    rx976_cur."!cursor_debug"("START", "named_param")
  debug_795:
    $I10 = self.'from'()
    ne $I10, -1, rxscan980_done
    goto rxscan980_scan
  rxscan980_loop:
    (rx976_pos) = rx976_cur."from"()
    inc rx976_pos
    rx976_cur."!cursor_from"(rx976_pos)
    ge rx976_pos, rx976_eos, rxscan980_done
  rxscan980_scan:
    set_addr $I10, rxscan980_loop
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxscan980_done:
.annotate 'line', 448
  # rx literal  ":"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 58, rx976_fail
    add rx976_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."param_var"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx976_pos = $P10."pos"()
.annotate 'line', 447
  # rx pass
    rx976_cur."!cursor_pass"(rx976_pos, "named_param")
    if_null rx976_debug, debug_796
    rx976_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx976_pos)
  debug_796:
    .return (rx976_cur)
  rx976_restart:
.annotate 'line', 4
    if_null rx976_debug, debug_797
    rx976_cur."!cursor_debug"("NEXT", "named_param")
  debug_797:
  rx976_fail:
    (rx976_rep, rx976_pos, $I10, $P10) = rx976_cur."!mark_fail"(0)
    lt rx976_pos, -1, rx976_done
    eq rx976_pos, -1, rx976_fail
    jump $I10
  rx976_done:
    rx976_cur."!cursor_fail"()
    if_null rx976_debug, debug_798
    rx976_cur."!cursor_debug"("FAIL", "named_param")
  debug_798:
    .return (rx976_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("196_1299602538.98") :method
.annotate 'line', 4
    $P978 = self."!PREFIX__!subrule"("param_var", ":")
    new $P979, "ResizablePMCArray"
    push $P979, $P978
    .return ($P979)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("197_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx982_tgt
    .local int rx982_pos
    .local int rx982_off
    .local int rx982_eos
    .local int rx982_rep
    .local pmc rx982_cur
    .local pmc rx982_debug
    (rx982_cur, rx982_pos, rx982_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx982_cur
    .local pmc match
    .lex "$/", match
    length rx982_eos, rx982_tgt
    gt rx982_pos, rx982_eos, rx982_done
    set rx982_off, 0
    lt rx982_pos, 2, rx982_start
    sub rx982_off, rx982_pos, 1
    substr rx982_tgt, rx982_tgt, rx982_off
  rx982_start:
    eq $I10, 1, rx982_restart
    if_null rx982_debug, debug_799
    rx982_cur."!cursor_debug"("START", "default_value")
  debug_799:
    $I10 = self.'from'()
    ne $I10, -1, rxscan986_done
    goto rxscan986_scan
  rxscan986_loop:
    (rx982_pos) = rx982_cur."from"()
    inc rx982_pos
    rx982_cur."!cursor_from"(rx982_pos)
    ge rx982_pos, rx982_eos, rxscan986_done
  rxscan986_scan:
    set_addr $I10, rxscan986_loop
    rx982_cur."!mark_push"(0, rx982_pos, $I10)
  rxscan986_done:
.annotate 'line', 451
  # rx subrule "ws" subtype=method negate=
    rx982_cur."!cursor_pos"(rx982_pos)
    $P10 = rx982_cur."ws"()
    unless $P10, rx982_fail
    rx982_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx982_pos, 1
    gt $I11, rx982_eos, rx982_fail
    sub $I11, rx982_pos, rx982_off
    ord $I11, rx982_tgt, $I11
    ne $I11, 61, rx982_fail
    add rx982_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx982_cur."!cursor_pos"(rx982_pos)
    $P10 = rx982_cur."ws"()
    unless $P10, rx982_fail
    rx982_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx982_cur."!cursor_pos"(rx982_pos)
    $P10 = rx982_cur."EXPR"("i=")
    unless $P10, rx982_fail
    rx982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx982_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx982_cur."!cursor_pos"(rx982_pos)
    $P10 = rx982_cur."ws"()
    unless $P10, rx982_fail
    rx982_pos = $P10."pos"()
  # rx pass
    rx982_cur."!cursor_pass"(rx982_pos, "default_value")
    if_null rx982_debug, debug_800
    rx982_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx982_pos)
  debug_800:
    .return (rx982_cur)
  rx982_restart:
.annotate 'line', 4
    if_null rx982_debug, debug_801
    rx982_cur."!cursor_debug"("NEXT", "default_value")
  debug_801:
  rx982_fail:
    (rx982_rep, rx982_pos, $I10, $P10) = rx982_cur."!mark_fail"(0)
    lt rx982_pos, -1, rx982_done
    eq rx982_pos, -1, rx982_fail
    jump $I10
  rx982_done:
    rx982_cur."!cursor_fail"()
    if_null rx982_debug, debug_802
    rx982_cur."!cursor_debug"("FAIL", "default_value")
  debug_802:
    .return (rx982_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("198_1299602538.98") :method
.annotate 'line', 4
    $P984 = self."!PREFIX__!subrule"("ws", "")
    new $P985, "ResizablePMCArray"
    push $P985, $P984
    .return ($P985)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("199_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx991_tgt
    .local int rx991_pos
    .local int rx991_off
    .local int rx991_eos
    .local int rx991_rep
    .local pmc rx991_cur
    .local pmc rx991_debug
    (rx991_cur, rx991_pos, rx991_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx991_cur
    .local pmc match
    .lex "$/", match
    length rx991_eos, rx991_tgt
    gt rx991_pos, rx991_eos, rx991_done
    set rx991_off, 0
    lt rx991_pos, 2, rx991_start
    sub rx991_off, rx991_pos, 1
    substr rx991_tgt, rx991_tgt, rx991_off
  rx991_start:
    eq $I10, 1, rx991_restart
    if_null rx991_debug, debug_803
    rx991_cur."!cursor_debug"("START", "trait")
  debug_803:
    $I10 = self.'from'()
    ne $I10, -1, rxscan995_done
    goto rxscan995_scan
  rxscan995_loop:
    (rx991_pos) = rx991_cur."from"()
    inc rx991_pos
    rx991_cur."!cursor_from"(rx991_pos)
    ge rx991_pos, rx991_eos, rxscan995_done
  rxscan995_scan:
    set_addr $I10, rxscan995_loop
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxscan995_done:
.annotate 'line', 453
  # rx subrule "ws" subtype=method negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ws"()
    unless $P10, rx991_fail
    rx991_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."trait_mod"()
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx991_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ws"()
    unless $P10, rx991_fail
    rx991_pos = $P10."pos"()
  # rx pass
    rx991_cur."!cursor_pass"(rx991_pos, "trait")
    if_null rx991_debug, debug_804
    rx991_cur."!cursor_debug"("PASS", "trait", " at pos=", rx991_pos)
  debug_804:
    .return (rx991_cur)
  rx991_restart:
.annotate 'line', 4
    if_null rx991_debug, debug_805
    rx991_cur."!cursor_debug"("NEXT", "trait")
  debug_805:
  rx991_fail:
    (rx991_rep, rx991_pos, $I10, $P10) = rx991_cur."!mark_fail"(0)
    lt rx991_pos, -1, rx991_done
    eq rx991_pos, -1, rx991_fail
    jump $I10
  rx991_done:
    rx991_cur."!cursor_fail"()
    if_null rx991_debug, debug_806
    rx991_cur."!cursor_debug"("FAIL", "trait")
  debug_806:
    .return (rx991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("200_1299602538.98") :method
.annotate 'line', 4
    $P993 = self."!PREFIX__!subrule"("ws", "")
    new $P994, "ResizablePMCArray"
    push $P994, $P993
    .return ($P994)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("201_1299602538.98")
    .param pmc param_999
.annotate 'line', 455
    .lex "self", param_999
    $P1000 = param_999."!protoregex"("trait_mod")
    .return ($P1000)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("202_1299602538.98")
    .param pmc param_1002
.annotate 'line', 455
    .lex "self", param_1002
    $P1003 = param_1002."!PREFIX__!protoregex"("trait_mod")
    .return ($P1003)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("203_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1005_tgt
    .local int rx1005_pos
    .local int rx1005_off
    .local int rx1005_eos
    .local int rx1005_rep
    .local pmc rx1005_cur
    .local pmc rx1005_debug
    (rx1005_cur, rx1005_pos, rx1005_tgt, $I10) = self."!cursor_start"()
    rx1005_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1005_cur
    .local pmc match
    .lex "$/", match
    length rx1005_eos, rx1005_tgt
    gt rx1005_pos, rx1005_eos, rx1005_done
    set rx1005_off, 0
    lt rx1005_pos, 2, rx1005_start
    sub rx1005_off, rx1005_pos, 1
    substr rx1005_tgt, rx1005_tgt, rx1005_off
  rx1005_start:
    eq $I10, 1, rx1005_restart
    if_null rx1005_debug, debug_807
    rx1005_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_807:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1009_done
    goto rxscan1009_scan
  rxscan1009_loop:
    (rx1005_pos) = rx1005_cur."from"()
    inc rx1005_pos
    rx1005_cur."!cursor_from"(rx1005_pos)
    ge rx1005_pos, rx1005_eos, rxscan1009_done
  rxscan1009_scan:
    set_addr $I10, rxscan1009_loop
    rx1005_cur."!mark_push"(0, rx1005_pos, $I10)
  rxscan1009_done:
.annotate 'line', 456
  # rx subcapture "sym"
    set_addr $I10, rxcap_1010_fail
    rx1005_cur."!mark_push"(0, rx1005_pos, $I10)
  # rx literal  "is"
    add $I11, rx1005_pos, 2
    gt $I11, rx1005_eos, rx1005_fail
    sub $I11, rx1005_pos, rx1005_off
    substr $S10, rx1005_tgt, $I11, 2
    ne $S10, "is", rx1005_fail
    add rx1005_pos, 2
    set_addr $I10, rxcap_1010_fail
    ($I12, $I11) = rx1005_cur."!mark_peek"($I10)
    rx1005_cur."!cursor_pos"($I11)
    ($P10) = rx1005_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1005_pos, "")
    rx1005_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1010_done
  rxcap_1010_fail:
    goto rx1005_fail
  rxcap_1010_done:
  # rx subrule "ws" subtype=method negate=
    rx1005_cur."!cursor_pos"(rx1005_pos)
    $P10 = rx1005_cur."ws"()
    unless $P10, rx1005_fail
    rx1005_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1005_cur."!cursor_pos"(rx1005_pos)
    $P10 = rx1005_cur."deflongname"()
    unless $P10, rx1005_fail
    rx1005_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1005_pos = $P10."pos"()
  # rx rxquantr1012 ** 0..1
    set_addr $I10, rxquantr1012_done
    rx1005_cur."!mark_push"(0, rx1005_pos, $I10)
  rxquantr1012_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1005_cur."!cursor_pos"(rx1005_pos)
    $P10 = rx1005_cur."circumfix"()
    unless $P10, rx1005_fail
    goto rxsubrule1013_pass
  rxsubrule1013_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1005_fail
  rxsubrule1013_pass:
    set_addr $I10, rxsubrule1013_back
    rx1005_cur."!mark_push"(0, rx1005_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1005_pos = $P10."pos"()
    set_addr $I10, rxquantr1012_done
    (rx1005_rep) = rx1005_cur."!mark_commit"($I10)
  rxquantr1012_done:
  # rx subrule "ws" subtype=method negate=
    rx1005_cur."!cursor_pos"(rx1005_pos)
    $P10 = rx1005_cur."ws"()
    unless $P10, rx1005_fail
    rx1005_pos = $P10."pos"()
  # rx pass
    rx1005_cur."!cursor_pass"(rx1005_pos, "trait_mod:sym<is>")
    if_null rx1005_debug, debug_808
    rx1005_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1005_pos)
  debug_808:
    .return (rx1005_cur)
  rx1005_restart:
.annotate 'line', 4
    if_null rx1005_debug, debug_809
    rx1005_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_809:
  rx1005_fail:
    (rx1005_rep, rx1005_pos, $I10, $P10) = rx1005_cur."!mark_fail"(0)
    lt rx1005_pos, -1, rx1005_done
    eq rx1005_pos, -1, rx1005_fail
    jump $I10
  rx1005_done:
    rx1005_cur."!cursor_fail"()
    if_null rx1005_debug, debug_810
    rx1005_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_810:
    .return (rx1005_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("204_1299602538.98") :method
.annotate 'line', 4
    $P1007 = self."!PREFIX__!subrule"("ws", "is")
    new $P1008, "ResizablePMCArray"
    push $P1008, $P1007
    .return ($P1008)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("205_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1016_tgt
    .local int rx1016_pos
    .local int rx1016_off
    .local int rx1016_eos
    .local int rx1016_rep
    .local pmc rx1016_cur
    .local pmc rx1016_debug
    (rx1016_cur, rx1016_pos, rx1016_tgt, $I10) = self."!cursor_start"()
    rx1016_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1016_cur
    .local pmc match
    .lex "$/", match
    length rx1016_eos, rx1016_tgt
    gt rx1016_pos, rx1016_eos, rx1016_done
    set rx1016_off, 0
    lt rx1016_pos, 2, rx1016_start
    sub rx1016_off, rx1016_pos, 1
    substr rx1016_tgt, rx1016_tgt, rx1016_off
  rx1016_start:
    eq $I10, 1, rx1016_restart
    if_null rx1016_debug, debug_811
    rx1016_cur."!cursor_debug"("START", "regex_declarator")
  debug_811:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1020_done
    goto rxscan1020_scan
  rxscan1020_loop:
    (rx1016_pos) = rx1016_cur."from"()
    inc rx1016_pos
    rx1016_cur."!cursor_from"(rx1016_pos)
    ge rx1016_pos, rx1016_eos, rxscan1020_done
  rxscan1020_scan:
    set_addr $I10, rxscan1020_loop
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  rxscan1020_done:
.annotate 'line', 458
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  alt1022_0:
.annotate 'line', 459
    set_addr $I10, alt1022_1
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
.annotate 'line', 460
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1024_fail
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1016_pos, 5
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 5
    ne $S10, "proto", rx1016_fail
    add rx1016_pos, 5
    set_addr $I10, rxcap_1024_fail
    ($I12, $I11) = rx1016_cur."!mark_peek"($I10)
    rx1016_cur."!cursor_pos"($I11)
    ($P10) = rx1016_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1016_pos, "")
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1024_done
  rxcap_1024_fail:
    goto rx1016_fail
  rxcap_1024_done:
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  alt1026_0:
    set_addr $I10, alt1026_1
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1016_pos, 5
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 5
    ne $S10, "regex", rx1016_fail
    add rx1016_pos, 5
    goto alt1026_end
  alt1026_1:
    set_addr $I10, alt1026_2
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  # rx literal  "token"
    add $I11, rx1016_pos, 5
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 5
    ne $S10, "token", rx1016_fail
    add rx1016_pos, 5
    goto alt1026_end
  alt1026_2:
  # rx literal  "rule"
    add $I11, rx1016_pos, 4
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 4
    ne $S10, "rule", rx1016_fail
    add rx1016_pos, 4
  alt1026_end:
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 461
  # rx subrule "deflongname" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."deflongname"()
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  alt1029_0:
.annotate 'line', 462
    set_addr $I10, alt1029_1
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
.annotate 'line', 463
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 123, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1016_pos, 5
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 5
    ne $S10, "<...>", rx1016_fail
    add rx1016_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 125, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ENDSTMT"()
    unless $P10, rx1016_fail
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
    goto alt1029_end
  alt1029_1:
    set_addr $I10, alt1029_2
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
.annotate 'line', 464
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 123, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1016_pos, 3
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 3
    ne $S10, "<*>", rx1016_fail
    add rx1016_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 125, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ENDSTMT"()
    unless $P10, rx1016_fail
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
    goto alt1029_end
  alt1029_2:
.annotate 'line', 465
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  alt1029_end:
.annotate 'line', 466
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 460
    goto alt1022_end
  alt1022_1:
.annotate 'line', 467
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1043_fail
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  alt1042_0:
    set_addr $I10, alt1042_1
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1016_pos, 5
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 5
    ne $S10, "regex", rx1016_fail
    add rx1016_pos, 5
    goto alt1042_end
  alt1042_1:
    set_addr $I10, alt1042_2
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  # rx literal  "token"
    add $I11, rx1016_pos, 5
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 5
    ne $S10, "token", rx1016_fail
    add rx1016_pos, 5
    goto alt1042_end
  alt1042_2:
  # rx literal  "rule"
    add $I11, rx1016_pos, 4
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    substr $S10, rx1016_tgt, $I11, 4
    ne $S10, "rule", rx1016_fail
    add rx1016_pos, 4
  alt1042_end:
    set_addr $I10, rxcap_1043_fail
    ($I12, $I11) = rx1016_cur."!mark_peek"($I10)
    rx1016_cur."!cursor_pos"($I11)
    ($P10) = rx1016_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1016_pos, "")
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1043_done
  rxcap_1043_fail:
    goto rx1016_fail
  rxcap_1043_done:
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 468
  # rx subrule "deflongname" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."deflongname"()
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 469
  # rx subrule "newpad" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."newpad"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 470
  # rx rxquantr1047 ** 0..1
    set_addr $I10, rxquantr1047_done
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  rxquantr1047_loop:
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 40, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."signature"()
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 41, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
    set_addr $I10, rxquantr1047_done
    (rx1016_rep) = rx1016_cur."!mark_commit"($I10)
  rxquantr1047_done:
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 471
  # rx reduce name="regex_declarator" key="open"
    rx1016_cur."!cursor_pos"(rx1016_pos)
    rx1016_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 472
  # rx literal  "{"
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 123, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1016_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 125, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ENDSTMT"()
    unless $P10, rx1016_fail
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  alt1022_end:
.annotate 'line', 473
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
.annotate 'line', 458
  # rx pass
    rx1016_cur."!cursor_pass"(rx1016_pos, "regex_declarator")
    if_null rx1016_debug, debug_812
    rx1016_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1016_pos)
  debug_812:
    .return (rx1016_cur)
  rx1016_restart:
.annotate 'line', 4
    if_null rx1016_debug, debug_813
    rx1016_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_813:
  rx1016_fail:
    (rx1016_rep, rx1016_pos, $I10, $P10) = rx1016_cur."!mark_fail"(0)
    lt rx1016_pos, -1, rx1016_done
    eq rx1016_pos, -1, rx1016_fail
    jump $I10
  rx1016_done:
    rx1016_cur."!cursor_fail"()
    if_null rx1016_debug, debug_814
    rx1016_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_814:
    .return (rx1016_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("206_1299602538.98") :method
.annotate 'line', 4
    $P1018 = self."!PREFIX__!subrule"("ws", "")
    new $P1019, "ResizablePMCArray"
    push $P1019, $P1018
    .return ($P1019)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("207_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1057_tgt
    .local int rx1057_pos
    .local int rx1057_off
    .local int rx1057_eos
    .local int rx1057_rep
    .local pmc rx1057_cur
    .local pmc rx1057_debug
    (rx1057_cur, rx1057_pos, rx1057_tgt, $I10) = self."!cursor_start"()
    rx1057_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1057_cur
    .local pmc match
    .lex "$/", match
    length rx1057_eos, rx1057_tgt
    gt rx1057_pos, rx1057_eos, rx1057_done
    set rx1057_off, 0
    lt rx1057_pos, 2, rx1057_start
    sub rx1057_off, rx1057_pos, 1
    substr rx1057_tgt, rx1057_tgt, rx1057_off
  rx1057_start:
    eq $I10, 1, rx1057_restart
    if_null rx1057_debug, debug_815
    rx1057_cur."!cursor_debug"("START", "dotty")
  debug_815:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1061_done
    goto rxscan1061_scan
  rxscan1061_loop:
    (rx1057_pos) = rx1057_cur."from"()
    inc rx1057_pos
    rx1057_cur."!cursor_from"(rx1057_pos)
    ge rx1057_pos, rx1057_eos, rxscan1061_done
  rxscan1061_scan:
    set_addr $I10, rxscan1061_loop
    rx1057_cur."!mark_push"(0, rx1057_pos, $I10)
  rxscan1061_done:
.annotate 'line', 477
  # rx literal  "."
    add $I11, rx1057_pos, 1
    gt $I11, rx1057_eos, rx1057_fail
    sub $I11, rx1057_pos, rx1057_off
    ord $I11, rx1057_tgt, $I11
    ne $I11, 46, rx1057_fail
    add rx1057_pos, 1
  alt1062_0:
.annotate 'line', 478
    set_addr $I10, alt1062_1
    rx1057_cur."!mark_push"(0, rx1057_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1057_cur."!cursor_pos"(rx1057_pos)
    $P10 = rx1057_cur."deflongname"()
    unless $P10, rx1057_fail
    rx1057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1057_pos = $P10."pos"()
    goto alt1062_end
  alt1062_1:
.annotate 'line', 479
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1057_pos, rx1057_off
    substr $S10, rx1057_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1057_fail
  # rx subrule "quote" subtype=capture negate=
    rx1057_cur."!cursor_pos"(rx1057_pos)
    $P10 = rx1057_cur."quote"()
    unless $P10, rx1057_fail
    rx1057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1057_pos = $P10."pos"()
  alt1063_0:
.annotate 'line', 480
    set_addr $I10, alt1063_1
    rx1057_cur."!mark_push"(0, rx1057_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1057_pos, rx1057_off
    substr $S10, rx1057_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1057_fail
    goto alt1063_end
  alt1063_1:
  # rx subrule "panic" subtype=method negate=
    rx1057_cur."!cursor_pos"(rx1057_pos)
    $P10 = rx1057_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1057_fail
    rx1057_pos = $P10."pos"()
  alt1063_end:
  alt1062_end:
.annotate 'line', 486
  # rx rxquantr1064 ** 0..1
    set_addr $I10, rxquantr1064_done
    rx1057_cur."!mark_push"(0, rx1057_pos, $I10)
  rxquantr1064_loop:
  alt1065_0:
.annotate 'line', 483
    set_addr $I10, alt1065_1
    rx1057_cur."!mark_push"(0, rx1057_pos, $I10)
.annotate 'line', 484
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1057_pos, rx1057_off
    substr $S10, rx1057_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1057_fail
  # rx subrule "args" subtype=capture negate=
    rx1057_cur."!cursor_pos"(rx1057_pos)
    $P10 = rx1057_cur."args"()
    unless $P10, rx1057_fail
    rx1057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1057_pos = $P10."pos"()
    goto alt1065_end
  alt1065_1:
.annotate 'line', 485
  # rx literal  ":"
    add $I11, rx1057_pos, 1
    gt $I11, rx1057_eos, rx1057_fail
    sub $I11, rx1057_pos, rx1057_off
    ord $I11, rx1057_tgt, $I11
    ne $I11, 58, rx1057_fail
    add rx1057_pos, 1
  # rx charclass s
    ge rx1057_pos, rx1057_eos, rx1057_fail
    sub $I10, rx1057_pos, rx1057_off
    is_cclass $I11, 32, rx1057_tgt, $I10
    unless $I11, rx1057_fail
    inc rx1057_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1057_cur."!cursor_pos"(rx1057_pos)
    $P10 = rx1057_cur."arglist"()
    unless $P10, rx1057_fail
    rx1057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1057_pos = $P10."pos"()
  alt1065_end:
.annotate 'line', 486
    set_addr $I10, rxquantr1064_done
    (rx1057_rep) = rx1057_cur."!mark_commit"($I10)
  rxquantr1064_done:
.annotate 'line', 476
  # rx pass
    rx1057_cur."!cursor_pass"(rx1057_pos, "dotty")
    if_null rx1057_debug, debug_816
    rx1057_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1057_pos)
  debug_816:
    .return (rx1057_cur)
  rx1057_restart:
.annotate 'line', 4
    if_null rx1057_debug, debug_817
    rx1057_cur."!cursor_debug"("NEXT", "dotty")
  debug_817:
  rx1057_fail:
    (rx1057_rep, rx1057_pos, $I10, $P10) = rx1057_cur."!mark_fail"(0)
    lt rx1057_pos, -1, rx1057_done
    eq rx1057_pos, -1, rx1057_fail
    jump $I10
  rx1057_done:
    rx1057_cur."!cursor_fail"()
    if_null rx1057_debug, debug_818
    rx1057_cur."!cursor_debug"("FAIL", "dotty")
  debug_818:
    .return (rx1057_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("208_1299602538.98") :method
.annotate 'line', 4
    $P1059 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1060, "ResizablePMCArray"
    push $P1060, "'"
    push $P1060, "\""
    push $P1060, $P1059
    .return ($P1060)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("209_1299602538.98")
    .param pmc param_1067
.annotate 'line', 490
    .lex "self", param_1067
    $P1068 = param_1067."!protoregex"("term")
    .return ($P1068)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("210_1299602538.98")
    .param pmc param_1070
.annotate 'line', 490
    .lex "self", param_1070
    $P1071 = param_1070."!PREFIX__!protoregex"("term")
    .return ($P1071)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("211_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1073_tgt
    .local int rx1073_pos
    .local int rx1073_off
    .local int rx1073_eos
    .local int rx1073_rep
    .local pmc rx1073_cur
    .local pmc rx1073_debug
    (rx1073_cur, rx1073_pos, rx1073_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1073_cur
    .local pmc match
    .lex "$/", match
    length rx1073_eos, rx1073_tgt
    gt rx1073_pos, rx1073_eos, rx1073_done
    set rx1073_off, 0
    lt rx1073_pos, 2, rx1073_start
    sub rx1073_off, rx1073_pos, 1
    substr rx1073_tgt, rx1073_tgt, rx1073_off
  rx1073_start:
    eq $I10, 1, rx1073_restart
    if_null rx1073_debug, debug_819
    rx1073_cur."!cursor_debug"("START", "term:sym<self>")
  debug_819:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1076_done
    goto rxscan1076_scan
  rxscan1076_loop:
    (rx1073_pos) = rx1073_cur."from"()
    inc rx1073_pos
    rx1073_cur."!cursor_from"(rx1073_pos)
    ge rx1073_pos, rx1073_eos, rxscan1076_done
  rxscan1076_scan:
    set_addr $I10, rxscan1076_loop
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
  rxscan1076_done:
.annotate 'line', 492
  # rx subcapture "sym"
    set_addr $I10, rxcap_1077_fail
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
  # rx literal  "self"
    add $I11, rx1073_pos, 4
    gt $I11, rx1073_eos, rx1073_fail
    sub $I11, rx1073_pos, rx1073_off
    substr $S10, rx1073_tgt, $I11, 4
    ne $S10, "self", rx1073_fail
    add rx1073_pos, 4
    set_addr $I10, rxcap_1077_fail
    ($I12, $I11) = rx1073_cur."!mark_peek"($I10)
    rx1073_cur."!cursor_pos"($I11)
    ($P10) = rx1073_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1073_pos, "")
    rx1073_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1077_done
  rxcap_1077_fail:
    goto rx1073_fail
  rxcap_1077_done:
  # rxanchor rwb
    le rx1073_pos, 0, rx1073_fail
    sub $I10, rx1073_pos, rx1073_off
    is_cclass $I11, 8192, rx1073_tgt, $I10
    if $I11, rx1073_fail
    dec $I10
    is_cclass $I11, 8192, rx1073_tgt, $I10
    unless $I11, rx1073_fail
  # rx pass
    rx1073_cur."!cursor_pass"(rx1073_pos, "term:sym<self>")
    if_null rx1073_debug, debug_820
    rx1073_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1073_pos)
  debug_820:
    .return (rx1073_cur)
  rx1073_restart:
.annotate 'line', 4
    if_null rx1073_debug, debug_821
    rx1073_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_821:
  rx1073_fail:
    (rx1073_rep, rx1073_pos, $I10, $P10) = rx1073_cur."!mark_fail"(0)
    lt rx1073_pos, -1, rx1073_done
    eq rx1073_pos, -1, rx1073_fail
    jump $I10
  rx1073_done:
    rx1073_cur."!cursor_fail"()
    if_null rx1073_debug, debug_822
    rx1073_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_822:
    .return (rx1073_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("212_1299602538.98") :method
.annotate 'line', 4
    new $P1075, "ResizablePMCArray"
    push $P1075, "self"
    .return ($P1075)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("213_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1079_tgt
    .local int rx1079_pos
    .local int rx1079_off
    .local int rx1079_eos
    .local int rx1079_rep
    .local pmc rx1079_cur
    .local pmc rx1079_debug
    (rx1079_cur, rx1079_pos, rx1079_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1079_cur
    .local pmc match
    .lex "$/", match
    length rx1079_eos, rx1079_tgt
    gt rx1079_pos, rx1079_eos, rx1079_done
    set rx1079_off, 0
    lt rx1079_pos, 2, rx1079_start
    sub rx1079_off, rx1079_pos, 1
    substr rx1079_tgt, rx1079_tgt, rx1079_off
  rx1079_start:
    eq $I10, 1, rx1079_restart
    if_null rx1079_debug, debug_823
    rx1079_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_823:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1083_done
    goto rxscan1083_scan
  rxscan1083_loop:
    (rx1079_pos) = rx1079_cur."from"()
    inc rx1079_pos
    rx1079_cur."!cursor_from"(rx1079_pos)
    ge rx1079_pos, rx1079_eos, rxscan1083_done
  rxscan1083_scan:
    set_addr $I10, rxscan1083_loop
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxscan1083_done:
.annotate 'line', 495
  # rx subrule "deflongname" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."deflongname"()
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1079_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1079_pos, rx1079_off
    substr $S10, rx1079_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1079_fail
  # rx subrule "args" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."args"()
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1079_pos = $P10."pos"()
.annotate 'line', 494
  # rx pass
    rx1079_cur."!cursor_pass"(rx1079_pos, "term:sym<identifier>")
    if_null rx1079_debug, debug_824
    rx1079_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1079_pos)
  debug_824:
    .return (rx1079_cur)
  rx1079_restart:
.annotate 'line', 4
    if_null rx1079_debug, debug_825
    rx1079_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_825:
  rx1079_fail:
    (rx1079_rep, rx1079_pos, $I10, $P10) = rx1079_cur."!mark_fail"(0)
    lt rx1079_pos, -1, rx1079_done
    eq rx1079_pos, -1, rx1079_fail
    jump $I10
  rx1079_done:
    rx1079_cur."!cursor_fail"()
    if_null rx1079_debug, debug_826
    rx1079_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_826:
    .return (rx1079_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("214_1299602538.98") :method
.annotate 'line', 4
    $P1081 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1082, "ResizablePMCArray"
    push $P1082, $P1081
    .return ($P1082)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("215_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1085_tgt
    .local int rx1085_pos
    .local int rx1085_off
    .local int rx1085_eos
    .local int rx1085_rep
    .local pmc rx1085_cur
    .local pmc rx1085_debug
    (rx1085_cur, rx1085_pos, rx1085_tgt, $I10) = self."!cursor_start"()
    rx1085_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1085_cur
    .local pmc match
    .lex "$/", match
    length rx1085_eos, rx1085_tgt
    gt rx1085_pos, rx1085_eos, rx1085_done
    set rx1085_off, 0
    lt rx1085_pos, 2, rx1085_start
    sub rx1085_off, rx1085_pos, 1
    substr rx1085_tgt, rx1085_tgt, rx1085_off
  rx1085_start:
    eq $I10, 1, rx1085_restart
    if_null rx1085_debug, debug_827
    rx1085_cur."!cursor_debug"("START", "term:sym<name>")
  debug_827:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1089_done
    goto rxscan1089_scan
  rxscan1089_loop:
    (rx1085_pos) = rx1085_cur."from"()
    inc rx1085_pos
    rx1085_cur."!cursor_from"(rx1085_pos)
    ge rx1085_pos, rx1085_eos, rxscan1089_done
  rxscan1089_scan:
    set_addr $I10, rxscan1089_loop
    rx1085_cur."!mark_push"(0, rx1085_pos, $I10)
  rxscan1089_done:
.annotate 'line', 499
  # rx subrule "name" subtype=capture negate=
    rx1085_cur."!cursor_pos"(rx1085_pos)
    $P10 = rx1085_cur."name"()
    unless $P10, rx1085_fail
    rx1085_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1085_pos = $P10."pos"()
  # rx rxquantr1090 ** 0..1
    set_addr $I10, rxquantr1090_done
    rx1085_cur."!mark_push"(0, rx1085_pos, $I10)
  rxquantr1090_loop:
  # rx subrule "args" subtype=capture negate=
    rx1085_cur."!cursor_pos"(rx1085_pos)
    $P10 = rx1085_cur."args"()
    unless $P10, rx1085_fail
    goto rxsubrule1091_pass
  rxsubrule1091_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1085_fail
  rxsubrule1091_pass:
    set_addr $I10, rxsubrule1091_back
    rx1085_cur."!mark_push"(0, rx1085_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1085_pos = $P10."pos"()
    set_addr $I10, rxquantr1090_done
    (rx1085_rep) = rx1085_cur."!mark_commit"($I10)
  rxquantr1090_done:
.annotate 'line', 498
  # rx pass
    rx1085_cur."!cursor_pass"(rx1085_pos, "term:sym<name>")
    if_null rx1085_debug, debug_828
    rx1085_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1085_pos)
  debug_828:
    .return (rx1085_cur)
  rx1085_restart:
.annotate 'line', 4
    if_null rx1085_debug, debug_829
    rx1085_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_829:
  rx1085_fail:
    (rx1085_rep, rx1085_pos, $I10, $P10) = rx1085_cur."!mark_fail"(0)
    lt rx1085_pos, -1, rx1085_done
    eq rx1085_pos, -1, rx1085_fail
    jump $I10
  rx1085_done:
    rx1085_cur."!cursor_fail"()
    if_null rx1085_debug, debug_830
    rx1085_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_830:
    .return (rx1085_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("216_1299602538.98") :method
.annotate 'line', 4
    $P1087 = self."!PREFIX__!subrule"("name", "")
    new $P1088, "ResizablePMCArray"
    push $P1088, $P1087
    .return ($P1088)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("217_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1093_tgt
    .local int rx1093_pos
    .local int rx1093_off
    .local int rx1093_eos
    .local int rx1093_rep
    .local pmc rx1093_cur
    .local pmc rx1093_debug
    (rx1093_cur, rx1093_pos, rx1093_tgt, $I10) = self."!cursor_start"()
    rx1093_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1093_cur
    .local pmc match
    .lex "$/", match
    length rx1093_eos, rx1093_tgt
    gt rx1093_pos, rx1093_eos, rx1093_done
    set rx1093_off, 0
    lt rx1093_pos, 2, rx1093_start
    sub rx1093_off, rx1093_pos, 1
    substr rx1093_tgt, rx1093_tgt, rx1093_off
  rx1093_start:
    eq $I10, 1, rx1093_restart
    if_null rx1093_debug, debug_831
    rx1093_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_831:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1096_done
    goto rxscan1096_scan
  rxscan1096_loop:
    (rx1093_pos) = rx1093_cur."from"()
    inc rx1093_pos
    rx1093_cur."!cursor_from"(rx1093_pos)
    ge rx1093_pos, rx1093_eos, rxscan1096_done
  rxscan1096_scan:
    set_addr $I10, rxscan1096_loop
    rx1093_cur."!mark_push"(0, rx1093_pos, $I10)
  rxscan1096_done:
.annotate 'line', 503
  # rx literal  "pir::"
    add $I11, rx1093_pos, 5
    gt $I11, rx1093_eos, rx1093_fail
    sub $I11, rx1093_pos, rx1093_off
    substr $S10, rx1093_tgt, $I11, 5
    ne $S10, "pir::", rx1093_fail
    add rx1093_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1097_fail
    rx1093_cur."!mark_push"(0, rx1093_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1093_pos, rx1093_off
    find_not_cclass $I11, 8192, rx1093_tgt, $I10, rx1093_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1093_fail
    add rx1093_pos, rx1093_off, $I11
    set_addr $I10, rxcap_1097_fail
    ($I12, $I11) = rx1093_cur."!mark_peek"($I10)
    rx1093_cur."!cursor_pos"($I11)
    ($P10) = rx1093_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1093_pos, "")
    rx1093_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1097_done
  rxcap_1097_fail:
    goto rx1093_fail
  rxcap_1097_done:
  # rx rxquantr1098 ** 0..1
    set_addr $I10, rxquantr1098_done
    rx1093_cur."!mark_push"(0, rx1093_pos, $I10)
  rxquantr1098_loop:
  # rx subrule "args" subtype=capture negate=
    rx1093_cur."!cursor_pos"(rx1093_pos)
    $P10 = rx1093_cur."args"()
    unless $P10, rx1093_fail
    goto rxsubrule1099_pass
  rxsubrule1099_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1093_fail
  rxsubrule1099_pass:
    set_addr $I10, rxsubrule1099_back
    rx1093_cur."!mark_push"(0, rx1093_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1093_pos = $P10."pos"()
    set_addr $I10, rxquantr1098_done
    (rx1093_rep) = rx1093_cur."!mark_commit"($I10)
  rxquantr1098_done:
.annotate 'line', 502
  # rx pass
    rx1093_cur."!cursor_pass"(rx1093_pos, "term:sym<pir::op>")
    if_null rx1093_debug, debug_832
    rx1093_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1093_pos)
  debug_832:
    .return (rx1093_cur)
  rx1093_restart:
.annotate 'line', 4
    if_null rx1093_debug, debug_833
    rx1093_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_833:
  rx1093_fail:
    (rx1093_rep, rx1093_pos, $I10, $P10) = rx1093_cur."!mark_fail"(0)
    lt rx1093_pos, -1, rx1093_done
    eq rx1093_pos, -1, rx1093_fail
    jump $I10
  rx1093_done:
    rx1093_cur."!cursor_fail"()
    if_null rx1093_debug, debug_834
    rx1093_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_834:
    .return (rx1093_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("218_1299602538.98") :method
.annotate 'line', 4
    new $P1095, "ResizablePMCArray"
    push $P1095, "pir::"
    .return ($P1095)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("219_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P1109 = "221_1299602538.98" 
    capture_lex $P1109
    .local string rx1101_tgt
    .local int rx1101_pos
    .local int rx1101_off
    .local int rx1101_eos
    .local int rx1101_rep
    .local pmc rx1101_cur
    .local pmc rx1101_debug
    (rx1101_cur, rx1101_pos, rx1101_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1101_cur
    .local pmc match
    .lex "$/", match
    length rx1101_eos, rx1101_tgt
    gt rx1101_pos, rx1101_eos, rx1101_done
    set rx1101_off, 0
    lt rx1101_pos, 2, rx1101_start
    sub rx1101_off, rx1101_pos, 1
    substr rx1101_tgt, rx1101_tgt, rx1101_off
  rx1101_start:
    eq $I10, 1, rx1101_restart
    if_null rx1101_debug, debug_835
    rx1101_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_835:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1104_done
    goto rxscan1104_scan
  rxscan1104_loop:
    (rx1101_pos) = rx1101_cur."from"()
    inc rx1101_pos
    rx1101_cur."!cursor_from"(rx1101_pos)
    ge rx1101_pos, rx1101_eos, rxscan1104_done
  rxscan1104_scan:
    set_addr $I10, rxscan1104_loop
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  rxscan1104_done:
.annotate 'line', 507
  # rx literal  "{*}"
    add $I11, rx1101_pos, 3
    gt $I11, rx1101_eos, rx1101_fail
    sub $I11, rx1101_pos, rx1101_off
    substr $S10, rx1101_tgt, $I11, 3
    ne $S10, "{*}", rx1101_fail
    add rx1101_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ENDSTMT"()
    unless $P10, rx1101_fail
  alt1105_0:
.annotate 'line', 508
    set_addr $I10, alt1105_1
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
    rx1101_cur."!cursor_pos"(rx1101_pos)
    find_lex $P1106, unicode:"$\x{a2}"
    $P1107 = $P1106."MATCH"()
    store_lex "$/", $P1107
    .const 'Sub' $P1109 = "221_1299602538.98" 
    capture_lex $P1109
    $P1113 = $P1109()
    unless $P1113, rx1101_fail
    goto alt1105_end
  alt1105_1:
  # rx subrule "panic" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  alt1105_end:
.annotate 'line', 506
  # rx pass
    rx1101_cur."!cursor_pass"(rx1101_pos, "term:sym<onlystar>")
    if_null rx1101_debug, debug_838
    rx1101_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1101_pos)
  debug_838:
    .return (rx1101_cur)
  rx1101_restart:
.annotate 'line', 4
    if_null rx1101_debug, debug_839
    rx1101_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_839:
  rx1101_fail:
    (rx1101_rep, rx1101_pos, $I10, $P10) = rx1101_cur."!mark_fail"(0)
    lt rx1101_pos, -1, rx1101_done
    eq rx1101_pos, -1, rx1101_fail
    jump $I10
  rx1101_done:
    rx1101_cur."!cursor_fail"()
    if_null rx1101_debug, debug_840
    rx1101_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_840:
    .return (rx1101_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("220_1299602538.98") :method
.annotate 'line', 4
    new $P1103, "ResizablePMCArray"
    push $P1103, "{*}"
    .return ($P1103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1108"  :anon :subid("221_1299602538.98") :outer("219_1299602538.98")
.annotate 'line', 508
    find_dynamic_lex $P1110, "$*MULTINESS"
    unless_null $P1110, vivify_836
    get_hll_global $P1110, "$MULTINESS"
    unless_null $P1110, vivify_837
    die "Contextual $*MULTINESS not found"
  vivify_837:
  vivify_836:
    set $S1111, $P1110
    iseq $I1112, $S1111, "proto"
    .return ($I1112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("222_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1115_tgt
    .local int rx1115_pos
    .local int rx1115_off
    .local int rx1115_eos
    .local int rx1115_rep
    .local pmc rx1115_cur
    .local pmc rx1115_debug
    (rx1115_cur, rx1115_pos, rx1115_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1115_cur
    .local pmc match
    .lex "$/", match
    length rx1115_eos, rx1115_tgt
    gt rx1115_pos, rx1115_eos, rx1115_done
    set rx1115_off, 0
    lt rx1115_pos, 2, rx1115_start
    sub rx1115_off, rx1115_pos, 1
    substr rx1115_tgt, rx1115_tgt, rx1115_off
  rx1115_start:
    eq $I10, 1, rx1115_restart
    if_null rx1115_debug, debug_841
    rx1115_cur."!cursor_debug"("START", "args")
  debug_841:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1119_done
    goto rxscan1119_scan
  rxscan1119_loop:
    (rx1115_pos) = rx1115_cur."from"()
    inc rx1115_pos
    rx1115_cur."!cursor_from"(rx1115_pos)
    ge rx1115_pos, rx1115_eos, rxscan1119_done
  rxscan1119_scan:
    set_addr $I10, rxscan1119_loop
    rx1115_cur."!mark_push"(0, rx1115_pos, $I10)
  rxscan1119_done:
.annotate 'line', 512
  # rx literal  "("
    add $I11, rx1115_pos, 1
    gt $I11, rx1115_eos, rx1115_fail
    sub $I11, rx1115_pos, rx1115_off
    ord $I11, rx1115_tgt, $I11
    ne $I11, 40, rx1115_fail
    add rx1115_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1115_cur."!cursor_pos"(rx1115_pos)
    $P10 = rx1115_cur."arglist"()
    unless $P10, rx1115_fail
    rx1115_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1115_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1115_pos, 1
    gt $I11, rx1115_eos, rx1115_fail
    sub $I11, rx1115_pos, rx1115_off
    ord $I11, rx1115_tgt, $I11
    ne $I11, 41, rx1115_fail
    add rx1115_pos, 1
  # rx pass
    rx1115_cur."!cursor_pass"(rx1115_pos, "args")
    if_null rx1115_debug, debug_842
    rx1115_cur."!cursor_debug"("PASS", "args", " at pos=", rx1115_pos)
  debug_842:
    .return (rx1115_cur)
  rx1115_restart:
.annotate 'line', 4
    if_null rx1115_debug, debug_843
    rx1115_cur."!cursor_debug"("NEXT", "args")
  debug_843:
  rx1115_fail:
    (rx1115_rep, rx1115_pos, $I10, $P10) = rx1115_cur."!mark_fail"(0)
    lt rx1115_pos, -1, rx1115_done
    eq rx1115_pos, -1, rx1115_fail
    jump $I10
  rx1115_done:
    rx1115_cur."!cursor_fail"()
    if_null rx1115_debug, debug_844
    rx1115_cur."!cursor_debug"("FAIL", "args")
  debug_844:
    .return (rx1115_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("223_1299602538.98") :method
.annotate 'line', 4
    $P1117 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1118, "ResizablePMCArray"
    push $P1118, $P1117
    .return ($P1118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("224_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1121_tgt
    .local int rx1121_pos
    .local int rx1121_off
    .local int rx1121_eos
    .local int rx1121_rep
    .local pmc rx1121_cur
    .local pmc rx1121_debug
    (rx1121_cur, rx1121_pos, rx1121_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1121_cur
    .local pmc match
    .lex "$/", match
    length rx1121_eos, rx1121_tgt
    gt rx1121_pos, rx1121_eos, rx1121_done
    set rx1121_off, 0
    lt rx1121_pos, 2, rx1121_start
    sub rx1121_off, rx1121_pos, 1
    substr rx1121_tgt, rx1121_tgt, rx1121_off
  rx1121_start:
    eq $I10, 1, rx1121_restart
    if_null rx1121_debug, debug_845
    rx1121_cur."!cursor_debug"("START", "arglist")
  debug_845:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1125_done
    goto rxscan1125_scan
  rxscan1125_loop:
    (rx1121_pos) = rx1121_cur."from"()
    inc rx1121_pos
    rx1121_cur."!cursor_from"(rx1121_pos)
    ge rx1121_pos, rx1121_eos, rxscan1125_done
  rxscan1125_scan:
    set_addr $I10, rxscan1125_loop
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
  rxscan1125_done:
.annotate 'line', 516
  # rx subrule "ws" subtype=method negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."ws"()
    unless $P10, rx1121_fail
    rx1121_pos = $P10."pos"()
  alt1126_0:
.annotate 'line', 517
    set_addr $I10, alt1126_1
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
.annotate 'line', 518
  # rx subrule "EXPR" subtype=capture negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."EXPR"("f=")
    unless $P10, rx1121_fail
    rx1121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1121_pos = $P10."pos"()
    goto alt1126_end
  alt1126_1:
  alt1126_end:
.annotate 'line', 515
  # rx pass
    rx1121_cur."!cursor_pass"(rx1121_pos, "arglist")
    if_null rx1121_debug, debug_846
    rx1121_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1121_pos)
  debug_846:
    .return (rx1121_cur)
  rx1121_restart:
.annotate 'line', 4
    if_null rx1121_debug, debug_847
    rx1121_cur."!cursor_debug"("NEXT", "arglist")
  debug_847:
  rx1121_fail:
    (rx1121_rep, rx1121_pos, $I10, $P10) = rx1121_cur."!mark_fail"(0)
    lt rx1121_pos, -1, rx1121_done
    eq rx1121_pos, -1, rx1121_fail
    jump $I10
  rx1121_done:
    rx1121_cur."!cursor_fail"()
    if_null rx1121_debug, debug_848
    rx1121_cur."!cursor_debug"("FAIL", "arglist")
  debug_848:
    .return (rx1121_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("225_1299602538.98") :method
.annotate 'line', 4
    $P1123 = self."!PREFIX__!subrule"("ws", "")
    new $P1124, "ResizablePMCArray"
    push $P1124, $P1123
    .return ($P1124)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("226_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1128_tgt
    .local int rx1128_pos
    .local int rx1128_off
    .local int rx1128_eos
    .local int rx1128_rep
    .local pmc rx1128_cur
    .local pmc rx1128_debug
    (rx1128_cur, rx1128_pos, rx1128_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1128_cur
    .local pmc match
    .lex "$/", match
    length rx1128_eos, rx1128_tgt
    gt rx1128_pos, rx1128_eos, rx1128_done
    set rx1128_off, 0
    lt rx1128_pos, 2, rx1128_start
    sub rx1128_off, rx1128_pos, 1
    substr rx1128_tgt, rx1128_tgt, rx1128_off
  rx1128_start:
    eq $I10, 1, rx1128_restart
    if_null rx1128_debug, debug_849
    rx1128_cur."!cursor_debug"("START", "term:sym<value>")
  debug_849:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1132_done
    goto rxscan1132_scan
  rxscan1132_loop:
    (rx1128_pos) = rx1128_cur."from"()
    inc rx1128_pos
    rx1128_cur."!cursor_from"(rx1128_pos)
    ge rx1128_pos, rx1128_eos, rxscan1132_done
  rxscan1132_scan:
    set_addr $I10, rxscan1132_loop
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxscan1132_done:
.annotate 'line', 524
  # rx subrule "value" subtype=capture negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."value"()
    unless $P10, rx1128_fail
    rx1128_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1128_pos = $P10."pos"()
  # rx pass
    rx1128_cur."!cursor_pass"(rx1128_pos, "term:sym<value>")
    if_null rx1128_debug, debug_850
    rx1128_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1128_pos)
  debug_850:
    .return (rx1128_cur)
  rx1128_restart:
.annotate 'line', 4
    if_null rx1128_debug, debug_851
    rx1128_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_851:
  rx1128_fail:
    (rx1128_rep, rx1128_pos, $I10, $P10) = rx1128_cur."!mark_fail"(0)
    lt rx1128_pos, -1, rx1128_done
    eq rx1128_pos, -1, rx1128_fail
    jump $I10
  rx1128_done:
    rx1128_cur."!cursor_fail"()
    if_null rx1128_debug, debug_852
    rx1128_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_852:
    .return (rx1128_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("227_1299602538.98") :method
.annotate 'line', 4
    $P1130 = self."!PREFIX__!subrule"("value", "")
    new $P1131, "ResizablePMCArray"
    push $P1131, $P1130
    .return ($P1131)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("228_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1134_tgt
    .local int rx1134_pos
    .local int rx1134_off
    .local int rx1134_eos
    .local int rx1134_rep
    .local pmc rx1134_cur
    .local pmc rx1134_debug
    (rx1134_cur, rx1134_pos, rx1134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1134_cur
    .local pmc match
    .lex "$/", match
    length rx1134_eos, rx1134_tgt
    gt rx1134_pos, rx1134_eos, rx1134_done
    set rx1134_off, 0
    lt rx1134_pos, 2, rx1134_start
    sub rx1134_off, rx1134_pos, 1
    substr rx1134_tgt, rx1134_tgt, rx1134_off
  rx1134_start:
    eq $I10, 1, rx1134_restart
    if_null rx1134_debug, debug_853
    rx1134_cur."!cursor_debug"("START", "value")
  debug_853:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1139_done
    goto rxscan1139_scan
  rxscan1139_loop:
    (rx1134_pos) = rx1134_cur."from"()
    inc rx1134_pos
    rx1134_cur."!cursor_from"(rx1134_pos)
    ge rx1134_pos, rx1134_eos, rxscan1139_done
  rxscan1139_scan:
    set_addr $I10, rxscan1139_loop
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxscan1139_done:
  alt1140_0:
.annotate 'line', 526
    set_addr $I10, alt1140_1
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
.annotate 'line', 527
  # rx subrule "quote" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."quote"()
    unless $P10, rx1134_fail
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1134_pos = $P10."pos"()
    goto alt1140_end
  alt1140_1:
.annotate 'line', 528
  # rx subrule "number" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."number"()
    unless $P10, rx1134_fail
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1134_pos = $P10."pos"()
  alt1140_end:
.annotate 'line', 526
  # rx pass
    rx1134_cur."!cursor_pass"(rx1134_pos, "value")
    if_null rx1134_debug, debug_854
    rx1134_cur."!cursor_debug"("PASS", "value", " at pos=", rx1134_pos)
  debug_854:
    .return (rx1134_cur)
  rx1134_restart:
.annotate 'line', 4
    if_null rx1134_debug, debug_855
    rx1134_cur."!cursor_debug"("NEXT", "value")
  debug_855:
  rx1134_fail:
    (rx1134_rep, rx1134_pos, $I10, $P10) = rx1134_cur."!mark_fail"(0)
    lt rx1134_pos, -1, rx1134_done
    eq rx1134_pos, -1, rx1134_fail
    jump $I10
  rx1134_done:
    rx1134_cur."!cursor_fail"()
    if_null rx1134_debug, debug_856
    rx1134_cur."!cursor_debug"("FAIL", "value")
  debug_856:
    .return (rx1134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("229_1299602538.98") :method
.annotate 'line', 4
    $P1136 = self."!PREFIX__!subrule"("number", "")
    $P1137 = self."!PREFIX__!subrule"("quote", "")
    new $P1138, "ResizablePMCArray"
    push $P1138, $P1136
    push $P1138, $P1137
    .return ($P1138)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("230_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1142_tgt
    .local int rx1142_pos
    .local int rx1142_off
    .local int rx1142_eos
    .local int rx1142_rep
    .local pmc rx1142_cur
    .local pmc rx1142_debug
    (rx1142_cur, rx1142_pos, rx1142_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1142_cur
    .local pmc match
    .lex "$/", match
    length rx1142_eos, rx1142_tgt
    gt rx1142_pos, rx1142_eos, rx1142_done
    set rx1142_off, 0
    lt rx1142_pos, 2, rx1142_start
    sub rx1142_off, rx1142_pos, 1
    substr rx1142_tgt, rx1142_tgt, rx1142_off
  rx1142_start:
    eq $I10, 1, rx1142_restart
    if_null rx1142_debug, debug_857
    rx1142_cur."!cursor_debug"("START", "number")
  debug_857:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1145_done
    goto rxscan1145_scan
  rxscan1145_loop:
    (rx1142_pos) = rx1142_cur."from"()
    inc rx1142_pos
    rx1142_cur."!cursor_from"(rx1142_pos)
    ge rx1142_pos, rx1142_eos, rxscan1145_done
  rxscan1145_scan:
    set_addr $I10, rxscan1145_loop
    rx1142_cur."!mark_push"(0, rx1142_pos, $I10)
  rxscan1145_done:
.annotate 'line', 532
  # rx subcapture "sign"
    set_addr $I10, rxcap_1147_fail
    rx1142_cur."!mark_push"(0, rx1142_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1142_pos, rx1142_off
    set rx1142_rep, 0
    sub $I12, rx1142_eos, rx1142_pos
    le $I12, 1, rxenumcharlistq1146_loop
    set $I12, 1
  rxenumcharlistq1146_loop:
    le $I12, 0, rxenumcharlistq1146_done
    substr $S10, rx1142_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1146_done
    inc rx1142_rep
  rxenumcharlistq1146_done:
    add rx1142_pos, rx1142_pos, rx1142_rep
    set_addr $I10, rxcap_1147_fail
    ($I12, $I11) = rx1142_cur."!mark_peek"($I10)
    rx1142_cur."!cursor_pos"($I11)
    ($P10) = rx1142_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1142_pos, "")
    rx1142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1147_done
  rxcap_1147_fail:
    goto rx1142_fail
  rxcap_1147_done:
  alt1148_0:
.annotate 'line', 533
    set_addr $I10, alt1148_1
    rx1142_cur."!mark_push"(0, rx1142_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."dec_number"()
    unless $P10, rx1142_fail
    rx1142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1142_pos = $P10."pos"()
    goto alt1148_end
  alt1148_1:
  # rx subrule "integer" subtype=capture negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."integer"()
    unless $P10, rx1142_fail
    rx1142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1142_pos = $P10."pos"()
  alt1148_end:
.annotate 'line', 531
  # rx pass
    rx1142_cur."!cursor_pass"(rx1142_pos, "number")
    if_null rx1142_debug, debug_858
    rx1142_cur."!cursor_debug"("PASS", "number", " at pos=", rx1142_pos)
  debug_858:
    .return (rx1142_cur)
  rx1142_restart:
.annotate 'line', 4
    if_null rx1142_debug, debug_859
    rx1142_cur."!cursor_debug"("NEXT", "number")
  debug_859:
  rx1142_fail:
    (rx1142_rep, rx1142_pos, $I10, $P10) = rx1142_cur."!mark_fail"(0)
    lt rx1142_pos, -1, rx1142_done
    eq rx1142_pos, -1, rx1142_fail
    jump $I10
  rx1142_done:
    rx1142_cur."!cursor_fail"()
    if_null rx1142_debug, debug_860
    rx1142_cur."!cursor_debug"("FAIL", "number")
  debug_860:
    .return (rx1142_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("231_1299602538.98") :method
.annotate 'line', 4
    new $P1144, "ResizablePMCArray"
    push $P1144, ""
    .return ($P1144)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("232_1299602538.98")
    .param pmc param_1150
.annotate 'line', 536
    .lex "self", param_1150
    $P1151 = param_1150."!protoregex"("quote")
    .return ($P1151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("233_1299602538.98")
    .param pmc param_1153
.annotate 'line', 536
    .lex "self", param_1153
    $P1154 = param_1153."!PREFIX__!protoregex"("quote")
    .return ($P1154)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("234_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1156_tgt
    .local int rx1156_pos
    .local int rx1156_off
    .local int rx1156_eos
    .local int rx1156_rep
    .local pmc rx1156_cur
    .local pmc rx1156_debug
    (rx1156_cur, rx1156_pos, rx1156_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1156_cur
    .local pmc match
    .lex "$/", match
    length rx1156_eos, rx1156_tgt
    gt rx1156_pos, rx1156_eos, rx1156_done
    set rx1156_off, 0
    lt rx1156_pos, 2, rx1156_start
    sub rx1156_off, rx1156_pos, 1
    substr rx1156_tgt, rx1156_tgt, rx1156_off
  rx1156_start:
    eq $I10, 1, rx1156_restart
    if_null rx1156_debug, debug_861
    rx1156_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_861:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1159_done
    goto rxscan1159_scan
  rxscan1159_loop:
    (rx1156_pos) = rx1156_cur."from"()
    inc rx1156_pos
    rx1156_cur."!cursor_from"(rx1156_pos)
    ge rx1156_pos, rx1156_eos, rxscan1159_done
  rxscan1159_scan:
    set_addr $I10, rxscan1159_loop
    rx1156_cur."!mark_push"(0, rx1156_pos, $I10)
  rxscan1159_done:
.annotate 'line', 537
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1156_pos, rx1156_off
    substr $S10, rx1156_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1156_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1156_cur."!cursor_pos"(rx1156_pos)
    $P10 = rx1156_cur."quote_EXPR"(":q")
    unless $P10, rx1156_fail
    rx1156_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1156_pos = $P10."pos"()
  # rx pass
    rx1156_cur."!cursor_pass"(rx1156_pos, "quote:sym<apos>")
    if_null rx1156_debug, debug_862
    rx1156_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1156_pos)
  debug_862:
    .return (rx1156_cur)
  rx1156_restart:
.annotate 'line', 4
    if_null rx1156_debug, debug_863
    rx1156_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_863:
  rx1156_fail:
    (rx1156_rep, rx1156_pos, $I10, $P10) = rx1156_cur."!mark_fail"(0)
    lt rx1156_pos, -1, rx1156_done
    eq rx1156_pos, -1, rx1156_fail
    jump $I10
  rx1156_done:
    rx1156_cur."!cursor_fail"()
    if_null rx1156_debug, debug_864
    rx1156_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_864:
    .return (rx1156_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("235_1299602538.98") :method
.annotate 'line', 4
    new $P1158, "ResizablePMCArray"
    push $P1158, "'"
    .return ($P1158)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("236_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1161_tgt
    .local int rx1161_pos
    .local int rx1161_off
    .local int rx1161_eos
    .local int rx1161_rep
    .local pmc rx1161_cur
    .local pmc rx1161_debug
    (rx1161_cur, rx1161_pos, rx1161_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1161_cur
    .local pmc match
    .lex "$/", match
    length rx1161_eos, rx1161_tgt
    gt rx1161_pos, rx1161_eos, rx1161_done
    set rx1161_off, 0
    lt rx1161_pos, 2, rx1161_start
    sub rx1161_off, rx1161_pos, 1
    substr rx1161_tgt, rx1161_tgt, rx1161_off
  rx1161_start:
    eq $I10, 1, rx1161_restart
    if_null rx1161_debug, debug_865
    rx1161_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_865:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1164_done
    goto rxscan1164_scan
  rxscan1164_loop:
    (rx1161_pos) = rx1161_cur."from"()
    inc rx1161_pos
    rx1161_cur."!cursor_from"(rx1161_pos)
    ge rx1161_pos, rx1161_eos, rxscan1164_done
  rxscan1164_scan:
    set_addr $I10, rxscan1164_loop
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
  rxscan1164_done:
.annotate 'line', 538
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1161_pos, rx1161_off
    substr $S10, rx1161_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1161_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    $P10 = rx1161_cur."quote_EXPR"(":qq")
    unless $P10, rx1161_fail
    rx1161_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1161_pos = $P10."pos"()
  # rx pass
    rx1161_cur."!cursor_pass"(rx1161_pos, "quote:sym<dblq>")
    if_null rx1161_debug, debug_866
    rx1161_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1161_pos)
  debug_866:
    .return (rx1161_cur)
  rx1161_restart:
.annotate 'line', 4
    if_null rx1161_debug, debug_867
    rx1161_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_867:
  rx1161_fail:
    (rx1161_rep, rx1161_pos, $I10, $P10) = rx1161_cur."!mark_fail"(0)
    lt rx1161_pos, -1, rx1161_done
    eq rx1161_pos, -1, rx1161_fail
    jump $I10
  rx1161_done:
    rx1161_cur."!cursor_fail"()
    if_null rx1161_debug, debug_868
    rx1161_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_868:
    .return (rx1161_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("237_1299602538.98") :method
.annotate 'line', 4
    new $P1163, "ResizablePMCArray"
    push $P1163, "\""
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("238_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1166_tgt
    .local int rx1166_pos
    .local int rx1166_off
    .local int rx1166_eos
    .local int rx1166_rep
    .local pmc rx1166_cur
    .local pmc rx1166_debug
    (rx1166_cur, rx1166_pos, rx1166_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1166_cur
    .local pmc match
    .lex "$/", match
    length rx1166_eos, rx1166_tgt
    gt rx1166_pos, rx1166_eos, rx1166_done
    set rx1166_off, 0
    lt rx1166_pos, 2, rx1166_start
    sub rx1166_off, rx1166_pos, 1
    substr rx1166_tgt, rx1166_tgt, rx1166_off
  rx1166_start:
    eq $I10, 1, rx1166_restart
    if_null rx1166_debug, debug_869
    rx1166_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_869:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1170_done
    goto rxscan1170_scan
  rxscan1170_loop:
    (rx1166_pos) = rx1166_cur."from"()
    inc rx1166_pos
    rx1166_cur."!cursor_from"(rx1166_pos)
    ge rx1166_pos, rx1166_eos, rxscan1170_done
  rxscan1170_scan:
    set_addr $I10, rxscan1170_loop
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
  rxscan1170_done:
.annotate 'line', 539
  # rx literal  "q"
    add $I11, rx1166_pos, 1
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    ord $I11, rx1166_tgt, $I11
    ne $I11, 113, rx1166_fail
    add rx1166_pos, 1
  # rxanchor rwb
    le rx1166_pos, 0, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 8192, rx1166_tgt, $I10
    if $I11, rx1166_fail
    dec $I10
    is_cclass $I11, 8192, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1166_fail
  # rx subrule "ws" subtype=method negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."ws"()
    unless $P10, rx1166_fail
    rx1166_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."quote_EXPR"(":q")
    unless $P10, rx1166_fail
    rx1166_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1166_pos = $P10."pos"()
  # rx pass
    rx1166_cur."!cursor_pass"(rx1166_pos, "quote:sym<q>")
    if_null rx1166_debug, debug_870
    rx1166_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1166_pos)
  debug_870:
    .return (rx1166_cur)
  rx1166_restart:
.annotate 'line', 4
    if_null rx1166_debug, debug_871
    rx1166_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_871:
  rx1166_fail:
    (rx1166_rep, rx1166_pos, $I10, $P10) = rx1166_cur."!mark_fail"(0)
    lt rx1166_pos, -1, rx1166_done
    eq rx1166_pos, -1, rx1166_fail
    jump $I10
  rx1166_done:
    rx1166_cur."!cursor_fail"()
    if_null rx1166_debug, debug_872
    rx1166_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_872:
    .return (rx1166_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("239_1299602538.98") :method
.annotate 'line', 4
    $P1168 = self."!PREFIX__!subrule"("ws", "q")
    new $P1169, "ResizablePMCArray"
    push $P1169, $P1168
    .return ($P1169)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("240_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1172_tgt
    .local int rx1172_pos
    .local int rx1172_off
    .local int rx1172_eos
    .local int rx1172_rep
    .local pmc rx1172_cur
    .local pmc rx1172_debug
    (rx1172_cur, rx1172_pos, rx1172_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1172_cur
    .local pmc match
    .lex "$/", match
    length rx1172_eos, rx1172_tgt
    gt rx1172_pos, rx1172_eos, rx1172_done
    set rx1172_off, 0
    lt rx1172_pos, 2, rx1172_start
    sub rx1172_off, rx1172_pos, 1
    substr rx1172_tgt, rx1172_tgt, rx1172_off
  rx1172_start:
    eq $I10, 1, rx1172_restart
    if_null rx1172_debug, debug_873
    rx1172_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_873:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1176_done
    goto rxscan1176_scan
  rxscan1176_loop:
    (rx1172_pos) = rx1172_cur."from"()
    inc rx1172_pos
    rx1172_cur."!cursor_from"(rx1172_pos)
    ge rx1172_pos, rx1172_eos, rxscan1176_done
  rxscan1176_scan:
    set_addr $I10, rxscan1176_loop
    rx1172_cur."!mark_push"(0, rx1172_pos, $I10)
  rxscan1176_done:
.annotate 'line', 540
  # rx literal  "qq"
    add $I11, rx1172_pos, 2
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    substr $S10, rx1172_tgt, $I11, 2
    ne $S10, "qq", rx1172_fail
    add rx1172_pos, 2
  # rxanchor rwb
    le rx1172_pos, 0, rx1172_fail
    sub $I10, rx1172_pos, rx1172_off
    is_cclass $I11, 8192, rx1172_tgt, $I10
    if $I11, rx1172_fail
    dec $I10
    is_cclass $I11, 8192, rx1172_tgt, $I10
    unless $I11, rx1172_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1172_pos, rx1172_off
    substr $S10, rx1172_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1172_fail
  # rx subrule "ws" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ws"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."quote_EXPR"(":qq")
    unless $P10, rx1172_fail
    rx1172_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1172_pos = $P10."pos"()
  # rx pass
    rx1172_cur."!cursor_pass"(rx1172_pos, "quote:sym<qq>")
    if_null rx1172_debug, debug_874
    rx1172_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1172_pos)
  debug_874:
    .return (rx1172_cur)
  rx1172_restart:
.annotate 'line', 4
    if_null rx1172_debug, debug_875
    rx1172_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_875:
  rx1172_fail:
    (rx1172_rep, rx1172_pos, $I10, $P10) = rx1172_cur."!mark_fail"(0)
    lt rx1172_pos, -1, rx1172_done
    eq rx1172_pos, -1, rx1172_fail
    jump $I10
  rx1172_done:
    rx1172_cur."!cursor_fail"()
    if_null rx1172_debug, debug_876
    rx1172_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_876:
    .return (rx1172_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("241_1299602538.98") :method
.annotate 'line', 4
    $P1174 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1175, "ResizablePMCArray"
    push $P1175, $P1174
    .return ($P1175)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("242_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1178_tgt
    .local int rx1178_pos
    .local int rx1178_off
    .local int rx1178_eos
    .local int rx1178_rep
    .local pmc rx1178_cur
    .local pmc rx1178_debug
    (rx1178_cur, rx1178_pos, rx1178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1178_cur
    .local pmc match
    .lex "$/", match
    length rx1178_eos, rx1178_tgt
    gt rx1178_pos, rx1178_eos, rx1178_done
    set rx1178_off, 0
    lt rx1178_pos, 2, rx1178_start
    sub rx1178_off, rx1178_pos, 1
    substr rx1178_tgt, rx1178_tgt, rx1178_off
  rx1178_start:
    eq $I10, 1, rx1178_restart
    if_null rx1178_debug, debug_877
    rx1178_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_877:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1182_done
    goto rxscan1182_scan
  rxscan1182_loop:
    (rx1178_pos) = rx1178_cur."from"()
    inc rx1178_pos
    rx1178_cur."!cursor_from"(rx1178_pos)
    ge rx1178_pos, rx1178_eos, rxscan1182_done
  rxscan1182_scan:
    set_addr $I10, rxscan1182_loop
    rx1178_cur."!mark_push"(0, rx1178_pos, $I10)
  rxscan1182_done:
.annotate 'line', 541
  # rx literal  "Q"
    add $I11, rx1178_pos, 1
    gt $I11, rx1178_eos, rx1178_fail
    sub $I11, rx1178_pos, rx1178_off
    ord $I11, rx1178_tgt, $I11
    ne $I11, 81, rx1178_fail
    add rx1178_pos, 1
  # rxanchor rwb
    le rx1178_pos, 0, rx1178_fail
    sub $I10, rx1178_pos, rx1178_off
    is_cclass $I11, 8192, rx1178_tgt, $I10
    if $I11, rx1178_fail
    dec $I10
    is_cclass $I11, 8192, rx1178_tgt, $I10
    unless $I11, rx1178_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1178_pos, rx1178_off
    substr $S10, rx1178_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1178_fail
  # rx subrule "ws" subtype=method negate=
    rx1178_cur."!cursor_pos"(rx1178_pos)
    $P10 = rx1178_cur."ws"()
    unless $P10, rx1178_fail
    rx1178_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1178_cur."!cursor_pos"(rx1178_pos)
    $P10 = rx1178_cur."quote_EXPR"()
    unless $P10, rx1178_fail
    rx1178_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1178_pos = $P10."pos"()
  # rx pass
    rx1178_cur."!cursor_pass"(rx1178_pos, "quote:sym<Q>")
    if_null rx1178_debug, debug_878
    rx1178_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1178_pos)
  debug_878:
    .return (rx1178_cur)
  rx1178_restart:
.annotate 'line', 4
    if_null rx1178_debug, debug_879
    rx1178_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_879:
  rx1178_fail:
    (rx1178_rep, rx1178_pos, $I10, $P10) = rx1178_cur."!mark_fail"(0)
    lt rx1178_pos, -1, rx1178_done
    eq rx1178_pos, -1, rx1178_fail
    jump $I10
  rx1178_done:
    rx1178_cur."!cursor_fail"()
    if_null rx1178_debug, debug_880
    rx1178_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_880:
    .return (rx1178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("243_1299602538.98") :method
.annotate 'line', 4
    $P1180 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1181, "ResizablePMCArray"
    push $P1181, $P1180
    .return ($P1181)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("244_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1184_tgt
    .local int rx1184_pos
    .local int rx1184_off
    .local int rx1184_eos
    .local int rx1184_rep
    .local pmc rx1184_cur
    .local pmc rx1184_debug
    (rx1184_cur, rx1184_pos, rx1184_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1184_cur
    .local pmc match
    .lex "$/", match
    length rx1184_eos, rx1184_tgt
    gt rx1184_pos, rx1184_eos, rx1184_done
    set rx1184_off, 0
    lt rx1184_pos, 2, rx1184_start
    sub rx1184_off, rx1184_pos, 1
    substr rx1184_tgt, rx1184_tgt, rx1184_off
  rx1184_start:
    eq $I10, 1, rx1184_restart
    if_null rx1184_debug, debug_881
    rx1184_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1188_done
    goto rxscan1188_scan
  rxscan1188_loop:
    (rx1184_pos) = rx1184_cur."from"()
    inc rx1184_pos
    rx1184_cur."!cursor_from"(rx1184_pos)
    ge rx1184_pos, rx1184_eos, rxscan1188_done
  rxscan1188_scan:
    set_addr $I10, rxscan1188_loop
    rx1184_cur."!mark_push"(0, rx1184_pos, $I10)
  rxscan1188_done:
.annotate 'line', 542
  # rx literal  "Q:PIR"
    add $I11, rx1184_pos, 5
    gt $I11, rx1184_eos, rx1184_fail
    sub $I11, rx1184_pos, rx1184_off
    substr $S10, rx1184_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1184_fail
    add rx1184_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1184_cur."!cursor_pos"(rx1184_pos)
    $P10 = rx1184_cur."ws"()
    unless $P10, rx1184_fail
    rx1184_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1184_cur."!cursor_pos"(rx1184_pos)
    $P10 = rx1184_cur."quote_EXPR"()
    unless $P10, rx1184_fail
    rx1184_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1184_pos = $P10."pos"()
  # rx pass
    rx1184_cur."!cursor_pass"(rx1184_pos, "quote:sym<Q:PIR>")
    if_null rx1184_debug, debug_882
    rx1184_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1184_pos)
  debug_882:
    .return (rx1184_cur)
  rx1184_restart:
.annotate 'line', 4
    if_null rx1184_debug, debug_883
    rx1184_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_883:
  rx1184_fail:
    (rx1184_rep, rx1184_pos, $I10, $P10) = rx1184_cur."!mark_fail"(0)
    lt rx1184_pos, -1, rx1184_done
    eq rx1184_pos, -1, rx1184_fail
    jump $I10
  rx1184_done:
    rx1184_cur."!cursor_fail"()
    if_null rx1184_debug, debug_884
    rx1184_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_884:
    .return (rx1184_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("245_1299602538.98") :method
.annotate 'line', 4
    $P1186 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1187, "ResizablePMCArray"
    push $P1187, $P1186
    .return ($P1187)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("246_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1190_tgt
    .local int rx1190_pos
    .local int rx1190_off
    .local int rx1190_eos
    .local int rx1190_rep
    .local pmc rx1190_cur
    .local pmc rx1190_debug
    (rx1190_cur, rx1190_pos, rx1190_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1190_cur
    .local pmc match
    .lex "$/", match
    length rx1190_eos, rx1190_tgt
    gt rx1190_pos, rx1190_eos, rx1190_done
    set rx1190_off, 0
    lt rx1190_pos, 2, rx1190_start
    sub rx1190_off, rx1190_pos, 1
    substr rx1190_tgt, rx1190_tgt, rx1190_off
  rx1190_start:
    eq $I10, 1, rx1190_restart
    if_null rx1190_debug, debug_885
    rx1190_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_885:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1194_done
    goto rxscan1194_scan
  rxscan1194_loop:
    (rx1190_pos) = rx1190_cur."from"()
    inc rx1190_pos
    rx1190_cur."!cursor_from"(rx1190_pos)
    ge rx1190_pos, rx1190_eos, rxscan1194_done
  rxscan1194_scan:
    set_addr $I10, rxscan1194_loop
    rx1190_cur."!mark_push"(0, rx1190_pos, $I10)
  rxscan1194_done:
.annotate 'line', 544
  # rx literal  "/"
    add $I11, rx1190_pos, 1
    gt $I11, rx1190_eos, rx1190_fail
    sub $I11, rx1190_pos, rx1190_off
    ord $I11, rx1190_tgt, $I11
    ne $I11, 47, rx1190_fail
    add rx1190_pos, 1
.annotate 'line', 545
  # rx subrule "newpad" subtype=method negate=
    rx1190_cur."!cursor_pos"(rx1190_pos)
    $P10 = rx1190_cur."newpad"()
    unless $P10, rx1190_fail
    rx1190_pos = $P10."pos"()
.annotate 'line', 546
  # rx reduce name="quote:sym</ />" key="open"
    rx1190_cur."!cursor_pos"(rx1190_pos)
    rx1190_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 547
  # rx subrule "LANG" subtype=capture negate=
    rx1190_cur."!cursor_pos"(rx1190_pos)
    $P10 = rx1190_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1190_fail
    rx1190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1190_pos = $P10."pos"()
.annotate 'line', 548
  # rx literal  "/"
    add $I11, rx1190_pos, 1
    gt $I11, rx1190_eos, rx1190_fail
    sub $I11, rx1190_pos, rx1190_off
    ord $I11, rx1190_tgt, $I11
    ne $I11, 47, rx1190_fail
    add rx1190_pos, 1
.annotate 'line', 543
  # rx pass
    rx1190_cur."!cursor_pass"(rx1190_pos, "quote:sym</ />")
    if_null rx1190_debug, debug_886
    rx1190_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1190_pos)
  debug_886:
    .return (rx1190_cur)
  rx1190_restart:
.annotate 'line', 4
    if_null rx1190_debug, debug_887
    rx1190_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_887:
  rx1190_fail:
    (rx1190_rep, rx1190_pos, $I10, $P10) = rx1190_cur."!mark_fail"(0)
    lt rx1190_pos, -1, rx1190_done
    eq rx1190_pos, -1, rx1190_fail
    jump $I10
  rx1190_done:
    rx1190_cur."!cursor_fail"()
    if_null rx1190_debug, debug_888
    rx1190_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_888:
    .return (rx1190_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("247_1299602538.98") :method
.annotate 'line', 4
    $P1192 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1193, "ResizablePMCArray"
    push $P1193, $P1192
    .return ($P1193)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("248_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1196_tgt
    .local int rx1196_pos
    .local int rx1196_off
    .local int rx1196_eos
    .local int rx1196_rep
    .local pmc rx1196_cur
    .local pmc rx1196_debug
    (rx1196_cur, rx1196_pos, rx1196_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1196_cur
    .local pmc match
    .lex "$/", match
    length rx1196_eos, rx1196_tgt
    gt rx1196_pos, rx1196_eos, rx1196_done
    set rx1196_off, 0
    lt rx1196_pos, 2, rx1196_start
    sub rx1196_off, rx1196_pos, 1
    substr rx1196_tgt, rx1196_tgt, rx1196_off
  rx1196_start:
    eq $I10, 1, rx1196_restart
    if_null rx1196_debug, debug_889
    rx1196_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1199_done
    goto rxscan1199_scan
  rxscan1199_loop:
    (rx1196_pos) = rx1196_cur."from"()
    inc rx1196_pos
    rx1196_cur."!cursor_from"(rx1196_pos)
    ge rx1196_pos, rx1196_eos, rxscan1199_done
  rxscan1199_scan:
    set_addr $I10, rxscan1199_loop
    rx1196_cur."!mark_push"(0, rx1196_pos, $I10)
  rxscan1199_done:
.annotate 'line', 551
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1196_pos, rx1196_off
    substr $S10, rx1196_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1196_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1196_cur."!cursor_pos"(rx1196_pos)
    $P10 = rx1196_cur."quotemod_check"("s")
    unless $P10, rx1196_fail
  # rx subrule "variable" subtype=capture negate=
    rx1196_cur."!cursor_pos"(rx1196_pos)
    $P10 = rx1196_cur."variable"()
    unless $P10, rx1196_fail
    rx1196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1196_pos = $P10."pos"()
  # rx pass
    rx1196_cur."!cursor_pass"(rx1196_pos, "quote_escape:sym<$>")
    if_null rx1196_debug, debug_890
    rx1196_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1196_pos)
  debug_890:
    .return (rx1196_cur)
  rx1196_restart:
.annotate 'line', 4
    if_null rx1196_debug, debug_891
    rx1196_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_891:
  rx1196_fail:
    (rx1196_rep, rx1196_pos, $I10, $P10) = rx1196_cur."!mark_fail"(0)
    lt rx1196_pos, -1, rx1196_done
    eq rx1196_pos, -1, rx1196_fail
    jump $I10
  rx1196_done:
    rx1196_cur."!cursor_fail"()
    if_null rx1196_debug, debug_892
    rx1196_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_892:
    .return (rx1196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("249_1299602538.98") :method
.annotate 'line', 4
    new $P1198, "ResizablePMCArray"
    push $P1198, "$"
    .return ($P1198)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("250_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1201_tgt
    .local int rx1201_pos
    .local int rx1201_off
    .local int rx1201_eos
    .local int rx1201_rep
    .local pmc rx1201_cur
    .local pmc rx1201_debug
    (rx1201_cur, rx1201_pos, rx1201_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1201_cur
    .local pmc match
    .lex "$/", match
    length rx1201_eos, rx1201_tgt
    gt rx1201_pos, rx1201_eos, rx1201_done
    set rx1201_off, 0
    lt rx1201_pos, 2, rx1201_start
    sub rx1201_off, rx1201_pos, 1
    substr rx1201_tgt, rx1201_tgt, rx1201_off
  rx1201_start:
    eq $I10, 1, rx1201_restart
    if_null rx1201_debug, debug_893
    rx1201_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_893:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1204_done
    goto rxscan1204_scan
  rxscan1204_loop:
    (rx1201_pos) = rx1201_cur."from"()
    inc rx1201_pos
    rx1201_cur."!cursor_from"(rx1201_pos)
    ge rx1201_pos, rx1201_eos, rxscan1204_done
  rxscan1204_scan:
    set_addr $I10, rxscan1204_loop
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxscan1204_done:
.annotate 'line', 552
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1201_pos, rx1201_off
    substr $S10, rx1201_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1201_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."quotemod_check"("c")
    unless $P10, rx1201_fail
  # rx subrule "block" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."block"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1201_pos = $P10."pos"()
  # rx pass
    rx1201_cur."!cursor_pass"(rx1201_pos, "quote_escape:sym<{ }>")
    if_null rx1201_debug, debug_894
    rx1201_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1201_pos)
  debug_894:
    .return (rx1201_cur)
  rx1201_restart:
.annotate 'line', 4
    if_null rx1201_debug, debug_895
    rx1201_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_895:
  rx1201_fail:
    (rx1201_rep, rx1201_pos, $I10, $P10) = rx1201_cur."!mark_fail"(0)
    lt rx1201_pos, -1, rx1201_done
    eq rx1201_pos, -1, rx1201_fail
    jump $I10
  rx1201_done:
    rx1201_cur."!cursor_fail"()
    if_null rx1201_debug, debug_896
    rx1201_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_896:
    .return (rx1201_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("251_1299602538.98") :method
.annotate 'line', 4
    new $P1203, "ResizablePMCArray"
    push $P1203, "{"
    .return ($P1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("252_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1206_tgt
    .local int rx1206_pos
    .local int rx1206_off
    .local int rx1206_eos
    .local int rx1206_rep
    .local pmc rx1206_cur
    .local pmc rx1206_debug
    (rx1206_cur, rx1206_pos, rx1206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1206_cur
    .local pmc match
    .lex "$/", match
    length rx1206_eos, rx1206_tgt
    gt rx1206_pos, rx1206_eos, rx1206_done
    set rx1206_off, 0
    lt rx1206_pos, 2, rx1206_start
    sub rx1206_off, rx1206_pos, 1
    substr rx1206_tgt, rx1206_tgt, rx1206_off
  rx1206_start:
    eq $I10, 1, rx1206_restart
    if_null rx1206_debug, debug_897
    rx1206_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_897:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1209_done
    goto rxscan1209_scan
  rxscan1209_loop:
    (rx1206_pos) = rx1206_cur."from"()
    inc rx1206_pos
    rx1206_cur."!cursor_from"(rx1206_pos)
    ge rx1206_pos, rx1206_eos, rxscan1209_done
  rxscan1209_scan:
    set_addr $I10, rxscan1209_loop
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxscan1209_done:
.annotate 'line', 553
  # rx literal  "\\e"
    add $I11, rx1206_pos, 2
    gt $I11, rx1206_eos, rx1206_fail
    sub $I11, rx1206_pos, rx1206_off
    substr $S10, rx1206_tgt, $I11, 2
    ne $S10, "\\e", rx1206_fail
    add rx1206_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."quotemod_check"("b")
    unless $P10, rx1206_fail
  # rx pass
    rx1206_cur."!cursor_pass"(rx1206_pos, "quote_escape:sym<esc>")
    if_null rx1206_debug, debug_898
    rx1206_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1206_pos)
  debug_898:
    .return (rx1206_cur)
  rx1206_restart:
.annotate 'line', 4
    if_null rx1206_debug, debug_899
    rx1206_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_899:
  rx1206_fail:
    (rx1206_rep, rx1206_pos, $I10, $P10) = rx1206_cur."!mark_fail"(0)
    lt rx1206_pos, -1, rx1206_done
    eq rx1206_pos, -1, rx1206_fail
    jump $I10
  rx1206_done:
    rx1206_cur."!cursor_fail"()
    if_null rx1206_debug, debug_900
    rx1206_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_900:
    .return (rx1206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("253_1299602538.98") :method
.annotate 'line', 4
    new $P1208, "ResizablePMCArray"
    push $P1208, "\\e"
    .return ($P1208)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("254_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1211_tgt
    .local int rx1211_pos
    .local int rx1211_off
    .local int rx1211_eos
    .local int rx1211_rep
    .local pmc rx1211_cur
    .local pmc rx1211_debug
    (rx1211_cur, rx1211_pos, rx1211_tgt, $I10) = self."!cursor_start"()
    rx1211_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1211_cur
    .local pmc match
    .lex "$/", match
    length rx1211_eos, rx1211_tgt
    gt rx1211_pos, rx1211_eos, rx1211_done
    set rx1211_off, 0
    lt rx1211_pos, 2, rx1211_start
    sub rx1211_off, rx1211_pos, 1
    substr rx1211_tgt, rx1211_tgt, rx1211_off
  rx1211_start:
    eq $I10, 1, rx1211_restart
    if_null rx1211_debug, debug_901
    rx1211_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_901:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1215_done
    goto rxscan1215_scan
  rxscan1215_loop:
    (rx1211_pos) = rx1211_cur."from"()
    inc rx1211_pos
    rx1211_cur."!cursor_from"(rx1211_pos)
    ge rx1211_pos, rx1211_eos, rxscan1215_done
  rxscan1215_scan:
    set_addr $I10, rxscan1215_loop
    rx1211_cur."!mark_push"(0, rx1211_pos, $I10)
  rxscan1215_done:
.annotate 'line', 555
  # rx literal  "("
    add $I11, rx1211_pos, 1
    gt $I11, rx1211_eos, rx1211_fail
    sub $I11, rx1211_pos, rx1211_off
    ord $I11, rx1211_tgt, $I11
    ne $I11, 40, rx1211_fail
    add rx1211_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1211_cur."!cursor_pos"(rx1211_pos)
    $P10 = rx1211_cur."ws"()
    unless $P10, rx1211_fail
    rx1211_pos = $P10."pos"()
  # rx rxquantr1216 ** 0..1
    set_addr $I10, rxquantr1216_done
    rx1211_cur."!mark_push"(0, rx1211_pos, $I10)
  rxquantr1216_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1211_cur."!cursor_pos"(rx1211_pos)
    $P10 = rx1211_cur."EXPR"()
    unless $P10, rx1211_fail
    goto rxsubrule1217_pass
  rxsubrule1217_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1211_fail
  rxsubrule1217_pass:
    set_addr $I10, rxsubrule1217_back
    rx1211_cur."!mark_push"(0, rx1211_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1211_pos = $P10."pos"()
    set_addr $I10, rxquantr1216_done
    (rx1211_rep) = rx1211_cur."!mark_commit"($I10)
  rxquantr1216_done:
  # rx literal  ")"
    add $I11, rx1211_pos, 1
    gt $I11, rx1211_eos, rx1211_fail
    sub $I11, rx1211_pos, rx1211_off
    ord $I11, rx1211_tgt, $I11
    ne $I11, 41, rx1211_fail
    add rx1211_pos, 1
  # rx pass
    rx1211_cur."!cursor_pass"(rx1211_pos, "circumfix:sym<( )>")
    if_null rx1211_debug, debug_902
    rx1211_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1211_pos)
  debug_902:
    .return (rx1211_cur)
  rx1211_restart:
.annotate 'line', 4
    if_null rx1211_debug, debug_903
    rx1211_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_903:
  rx1211_fail:
    (rx1211_rep, rx1211_pos, $I10, $P10) = rx1211_cur."!mark_fail"(0)
    lt rx1211_pos, -1, rx1211_done
    eq rx1211_pos, -1, rx1211_fail
    jump $I10
  rx1211_done:
    rx1211_cur."!cursor_fail"()
    if_null rx1211_debug, debug_904
    rx1211_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_904:
    .return (rx1211_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("255_1299602538.98") :method
.annotate 'line', 4
    $P1213 = self."!PREFIX__!subrule"("ws", "(")
    new $P1214, "ResizablePMCArray"
    push $P1214, $P1213
    .return ($P1214)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("256_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1219_tgt
    .local int rx1219_pos
    .local int rx1219_off
    .local int rx1219_eos
    .local int rx1219_rep
    .local pmc rx1219_cur
    .local pmc rx1219_debug
    (rx1219_cur, rx1219_pos, rx1219_tgt, $I10) = self."!cursor_start"()
    rx1219_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1219_cur
    .local pmc match
    .lex "$/", match
    length rx1219_eos, rx1219_tgt
    gt rx1219_pos, rx1219_eos, rx1219_done
    set rx1219_off, 0
    lt rx1219_pos, 2, rx1219_start
    sub rx1219_off, rx1219_pos, 1
    substr rx1219_tgt, rx1219_tgt, rx1219_off
  rx1219_start:
    eq $I10, 1, rx1219_restart
    if_null rx1219_debug, debug_905
    rx1219_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1223_done
    goto rxscan1223_scan
  rxscan1223_loop:
    (rx1219_pos) = rx1219_cur."from"()
    inc rx1219_pos
    rx1219_cur."!cursor_from"(rx1219_pos)
    ge rx1219_pos, rx1219_eos, rxscan1223_done
  rxscan1223_scan:
    set_addr $I10, rxscan1223_loop
    rx1219_cur."!mark_push"(0, rx1219_pos, $I10)
  rxscan1223_done:
.annotate 'line', 556
  # rx literal  "["
    add $I11, rx1219_pos, 1
    gt $I11, rx1219_eos, rx1219_fail
    sub $I11, rx1219_pos, rx1219_off
    ord $I11, rx1219_tgt, $I11
    ne $I11, 91, rx1219_fail
    add rx1219_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1219_cur."!cursor_pos"(rx1219_pos)
    $P10 = rx1219_cur."ws"()
    unless $P10, rx1219_fail
    rx1219_pos = $P10."pos"()
  # rx rxquantr1224 ** 0..1
    set_addr $I10, rxquantr1224_done
    rx1219_cur."!mark_push"(0, rx1219_pos, $I10)
  rxquantr1224_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1219_cur."!cursor_pos"(rx1219_pos)
    $P10 = rx1219_cur."EXPR"()
    unless $P10, rx1219_fail
    goto rxsubrule1225_pass
  rxsubrule1225_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1219_fail
  rxsubrule1225_pass:
    set_addr $I10, rxsubrule1225_back
    rx1219_cur."!mark_push"(0, rx1219_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1219_pos = $P10."pos"()
    set_addr $I10, rxquantr1224_done
    (rx1219_rep) = rx1219_cur."!mark_commit"($I10)
  rxquantr1224_done:
  # rx literal  "]"
    add $I11, rx1219_pos, 1
    gt $I11, rx1219_eos, rx1219_fail
    sub $I11, rx1219_pos, rx1219_off
    ord $I11, rx1219_tgt, $I11
    ne $I11, 93, rx1219_fail
    add rx1219_pos, 1
  # rx pass
    rx1219_cur."!cursor_pass"(rx1219_pos, "circumfix:sym<[ ]>")
    if_null rx1219_debug, debug_906
    rx1219_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1219_pos)
  debug_906:
    .return (rx1219_cur)
  rx1219_restart:
.annotate 'line', 4
    if_null rx1219_debug, debug_907
    rx1219_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_907:
  rx1219_fail:
    (rx1219_rep, rx1219_pos, $I10, $P10) = rx1219_cur."!mark_fail"(0)
    lt rx1219_pos, -1, rx1219_done
    eq rx1219_pos, -1, rx1219_fail
    jump $I10
  rx1219_done:
    rx1219_cur."!cursor_fail"()
    if_null rx1219_debug, debug_908
    rx1219_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_908:
    .return (rx1219_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("257_1299602538.98") :method
.annotate 'line', 4
    $P1221 = self."!PREFIX__!subrule"("ws", "[")
    new $P1222, "ResizablePMCArray"
    push $P1222, $P1221
    .return ($P1222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("258_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1227_tgt
    .local int rx1227_pos
    .local int rx1227_off
    .local int rx1227_eos
    .local int rx1227_rep
    .local pmc rx1227_cur
    .local pmc rx1227_debug
    (rx1227_cur, rx1227_pos, rx1227_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1227_cur
    .local pmc match
    .lex "$/", match
    length rx1227_eos, rx1227_tgt
    gt rx1227_pos, rx1227_eos, rx1227_done
    set rx1227_off, 0
    lt rx1227_pos, 2, rx1227_start
    sub rx1227_off, rx1227_pos, 1
    substr rx1227_tgt, rx1227_tgt, rx1227_off
  rx1227_start:
    eq $I10, 1, rx1227_restart
    if_null rx1227_debug, debug_909
    rx1227_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1230_done
    goto rxscan1230_scan
  rxscan1230_loop:
    (rx1227_pos) = rx1227_cur."from"()
    inc rx1227_pos
    rx1227_cur."!cursor_from"(rx1227_pos)
    ge rx1227_pos, rx1227_eos, rxscan1230_done
  rxscan1230_scan:
    set_addr $I10, rxscan1230_loop
    rx1227_cur."!mark_push"(0, rx1227_pos, $I10)
  rxscan1230_done:
.annotate 'line', 557
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1227_pos, rx1227_off
    substr $S10, rx1227_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1227_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1227_cur."!cursor_pos"(rx1227_pos)
    $P10 = rx1227_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1227_fail
    rx1227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1227_pos = $P10."pos"()
  # rx pass
    rx1227_cur."!cursor_pass"(rx1227_pos, "circumfix:sym<ang>")
    if_null rx1227_debug, debug_910
    rx1227_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1227_pos)
  debug_910:
    .return (rx1227_cur)
  rx1227_restart:
.annotate 'line', 4
    if_null rx1227_debug, debug_911
    rx1227_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_911:
  rx1227_fail:
    (rx1227_rep, rx1227_pos, $I10, $P10) = rx1227_cur."!mark_fail"(0)
    lt rx1227_pos, -1, rx1227_done
    eq rx1227_pos, -1, rx1227_fail
    jump $I10
  rx1227_done:
    rx1227_cur."!cursor_fail"()
    if_null rx1227_debug, debug_912
    rx1227_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_912:
    .return (rx1227_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("259_1299602538.98") :method
.annotate 'line', 4
    new $P1229, "ResizablePMCArray"
    push $P1229, "<"
    .return ($P1229)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("260_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1232_tgt
    .local int rx1232_pos
    .local int rx1232_off
    .local int rx1232_eos
    .local int rx1232_rep
    .local pmc rx1232_cur
    .local pmc rx1232_debug
    (rx1232_cur, rx1232_pos, rx1232_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1232_cur
    .local pmc match
    .lex "$/", match
    length rx1232_eos, rx1232_tgt
    gt rx1232_pos, rx1232_eos, rx1232_done
    set rx1232_off, 0
    lt rx1232_pos, 2, rx1232_start
    sub rx1232_off, rx1232_pos, 1
    substr rx1232_tgt, rx1232_tgt, rx1232_off
  rx1232_start:
    eq $I10, 1, rx1232_restart
    if_null rx1232_debug, debug_913
    rx1232_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1235_done
    goto rxscan1235_scan
  rxscan1235_loop:
    (rx1232_pos) = rx1232_cur."from"()
    inc rx1232_pos
    rx1232_cur."!cursor_from"(rx1232_pos)
    ge rx1232_pos, rx1232_eos, rxscan1235_done
  rxscan1235_scan:
    set_addr $I10, rxscan1235_loop
    rx1232_cur."!mark_push"(0, rx1232_pos, $I10)
  rxscan1235_done:
.annotate 'line', 558
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1232_pos, rx1232_off
    substr $S10, rx1232_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1232_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1232_cur."!cursor_pos"(rx1232_pos)
    $P10 = rx1232_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1232_fail
    rx1232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1232_pos = $P10."pos"()
  # rx pass
    rx1232_cur."!cursor_pass"(rx1232_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1232_debug, debug_914
    rx1232_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1232_pos)
  debug_914:
    .return (rx1232_cur)
  rx1232_restart:
.annotate 'line', 4
    if_null rx1232_debug, debug_915
    rx1232_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_915:
  rx1232_fail:
    (rx1232_rep, rx1232_pos, $I10, $P10) = rx1232_cur."!mark_fail"(0)
    lt rx1232_pos, -1, rx1232_done
    eq rx1232_pos, -1, rx1232_fail
    jump $I10
  rx1232_done:
    rx1232_cur."!cursor_fail"()
    if_null rx1232_debug, debug_916
    rx1232_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_916:
    .return (rx1232_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("261_1299602538.98") :method
.annotate 'line', 4
    new $P1234, "ResizablePMCArray"
    push $P1234, unicode:"\x{ab}"
    .return ($P1234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("262_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_917
    rx1237_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1240_done:
.annotate 'line', 559
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1237_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."pblock"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1237_pos = $P10."pos"()
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "circumfix:sym<{ }>")
    if_null rx1237_debug, debug_918
    rx1237_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1237_pos)
  debug_918:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 4
    if_null rx1237_debug, debug_919
    rx1237_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_919:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_920
    rx1237_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_920:
    .return (rx1237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("263_1299602538.98") :method
.annotate 'line', 4
    new $P1239, "ResizablePMCArray"
    push $P1239, "{"
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("264_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1242_tgt
    .local int rx1242_pos
    .local int rx1242_off
    .local int rx1242_eos
    .local int rx1242_rep
    .local pmc rx1242_cur
    .local pmc rx1242_debug
    (rx1242_cur, rx1242_pos, rx1242_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1242_cur
    .local pmc match
    .lex "$/", match
    length rx1242_eos, rx1242_tgt
    gt rx1242_pos, rx1242_eos, rx1242_done
    set rx1242_off, 0
    lt rx1242_pos, 2, rx1242_start
    sub rx1242_off, rx1242_pos, 1
    substr rx1242_tgt, rx1242_tgt, rx1242_off
  rx1242_start:
    eq $I10, 1, rx1242_restart
    if_null rx1242_debug, debug_921
    rx1242_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1246_done
    goto rxscan1246_scan
  rxscan1246_loop:
    (rx1242_pos) = rx1242_cur."from"()
    inc rx1242_pos
    rx1242_cur."!cursor_from"(rx1242_pos)
    ge rx1242_pos, rx1242_eos, rxscan1246_done
  rxscan1246_scan:
    set_addr $I10, rxscan1246_loop
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxscan1246_done:
.annotate 'line', 560
  # rx subrule "sigil" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."sigil"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1242_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1242_pos, 1
    gt $I11, rx1242_eos, rx1242_fail
    sub $I11, rx1242_pos, rx1242_off
    ord $I11, rx1242_tgt, $I11
    ne $I11, 40, rx1242_fail
    add rx1242_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."semilist"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1242_pos = $P10."pos"()
  alt1247_0:
    set_addr $I10, alt1247_1
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  # rx literal  ")"
    add $I11, rx1242_pos, 1
    gt $I11, rx1242_eos, rx1242_fail
    sub $I11, rx1242_pos, rx1242_off
    ord $I11, rx1242_tgt, $I11
    ne $I11, 41, rx1242_fail
    add rx1242_pos, 1
    goto alt1247_end
  alt1247_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."FAILGOAL"("')'")
    unless $P10, rx1242_fail
    goto rxsubrule1249_pass
  rxsubrule1249_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1242_fail
  rxsubrule1249_pass:
    set_addr $I10, rxsubrule1249_back
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10, $P10)
    rx1242_pos = $P10."pos"()
  alt1247_end:
  # rx pass
    rx1242_cur."!cursor_pass"(rx1242_pos, "circumfix:sym<sigil>")
    if_null rx1242_debug, debug_922
    rx1242_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1242_pos)
  debug_922:
    .return (rx1242_cur)
  rx1242_restart:
.annotate 'line', 4
    if_null rx1242_debug, debug_923
    rx1242_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_923:
  rx1242_fail:
    (rx1242_rep, rx1242_pos, $I10, $P10) = rx1242_cur."!mark_fail"(0)
    lt rx1242_pos, -1, rx1242_done
    eq rx1242_pos, -1, rx1242_fail
    jump $I10
  rx1242_done:
    rx1242_cur."!cursor_fail"()
    if_null rx1242_debug, debug_924
    rx1242_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_924:
    .return (rx1242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("265_1299602538.98") :method
.annotate 'line', 4
    $P1244 = self."!PREFIX__!subrule"("sigil", "")
    new $P1245, "ResizablePMCArray"
    push $P1245, $P1244
    .return ($P1245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("266_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1251_tgt
    .local int rx1251_pos
    .local int rx1251_off
    .local int rx1251_eos
    .local int rx1251_rep
    .local pmc rx1251_cur
    .local pmc rx1251_debug
    (rx1251_cur, rx1251_pos, rx1251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1251_cur
    .local pmc match
    .lex "$/", match
    length rx1251_eos, rx1251_tgt
    gt rx1251_pos, rx1251_eos, rx1251_done
    set rx1251_off, 0
    lt rx1251_pos, 2, rx1251_start
    sub rx1251_off, rx1251_pos, 1
    substr rx1251_tgt, rx1251_tgt, rx1251_off
  rx1251_start:
    eq $I10, 1, rx1251_restart
    if_null rx1251_debug, debug_925
    rx1251_cur."!cursor_debug"("START", "semilist")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1251_pos) = rx1251_cur."from"()
    inc rx1251_pos
    rx1251_cur."!cursor_from"(rx1251_pos)
    ge rx1251_pos, rx1251_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  rxscan1255_done:
.annotate 'line', 562
  # rx subrule "ws" subtype=method negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."ws"()
    unless $P10, rx1251_fail
    rx1251_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."statement"()
    unless $P10, rx1251_fail
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1251_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."ws"()
    unless $P10, rx1251_fail
    rx1251_pos = $P10."pos"()
  # rx pass
    rx1251_cur."!cursor_pass"(rx1251_pos, "semilist")
    if_null rx1251_debug, debug_926
    rx1251_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1251_pos)
  debug_926:
    .return (rx1251_cur)
  rx1251_restart:
.annotate 'line', 4
    if_null rx1251_debug, debug_927
    rx1251_cur."!cursor_debug"("NEXT", "semilist")
  debug_927:
  rx1251_fail:
    (rx1251_rep, rx1251_pos, $I10, $P10) = rx1251_cur."!mark_fail"(0)
    lt rx1251_pos, -1, rx1251_done
    eq rx1251_pos, -1, rx1251_fail
    jump $I10
  rx1251_done:
    rx1251_cur."!cursor_fail"()
    if_null rx1251_debug, debug_928
    rx1251_cur."!cursor_debug"("FAIL", "semilist")
  debug_928:
    .return (rx1251_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("267_1299602538.98") :method
.annotate 'line', 4
    $P1253 = self."!PREFIX__!subrule"("ws", "")
    new $P1254, "ResizablePMCArray"
    push $P1254, $P1253
    .return ($P1254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1258"  :anon :subid("268_1299602538.98") :outer("11_1299602538.98")
.annotate 'line', 4
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post929") :outer("268_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P1259 = "268_1299602538.98" 
    .local pmc block
    set block, $P1259
.annotate 'line', 567
    get_hll_global $P1260, ["NQP"], "Grammar"
    $P1260."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 568
    get_hll_global $P1261, ["NQP"], "Grammar"
    $P1261."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 569
    get_hll_global $P1262, ["NQP"], "Grammar"
    $P1262."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 570
    get_hll_global $P1263, ["NQP"], "Grammar"
    $P1263."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 571
    get_hll_global $P1264, ["NQP"], "Grammar"
    $P1264."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 572
    get_hll_global $P1265, ["NQP"], "Grammar"
    $P1265."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 573
    get_hll_global $P1266, ["NQP"], "Grammar"
    $P1266."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 574
    get_hll_global $P1267, ["NQP"], "Grammar"
    $P1267."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 575
    get_hll_global $P1268, ["NQP"], "Grammar"
    $P1268."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 576
    get_hll_global $P1269, ["NQP"], "Grammar"
    $P1269."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 577
    get_hll_global $P1270, ["NQP"], "Grammar"
    $P1270."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 578
    get_hll_global $P1271, ["NQP"], "Grammar"
    $P1271."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 579
    get_hll_global $P1272, ["NQP"], "Grammar"
    $P1272."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 580
    get_hll_global $P1273, ["NQP"], "Grammar"
    $P1273."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 581
    get_hll_global $P1274, ["NQP"], "Grammar"
    $P1274."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("269_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1276_tgt
    .local int rx1276_pos
    .local int rx1276_off
    .local int rx1276_eos
    .local int rx1276_rep
    .local pmc rx1276_cur
    .local pmc rx1276_debug
    (rx1276_cur, rx1276_pos, rx1276_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1276_cur
    .local pmc match
    .lex "$/", match
    length rx1276_eos, rx1276_tgt
    gt rx1276_pos, rx1276_eos, rx1276_done
    set rx1276_off, 0
    lt rx1276_pos, 2, rx1276_start
    sub rx1276_off, rx1276_pos, 1
    substr rx1276_tgt, rx1276_tgt, rx1276_off
  rx1276_start:
    eq $I10, 1, rx1276_restart
    if_null rx1276_debug, debug_930
    rx1276_cur."!cursor_debug"("START", "infixish")
  debug_930:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1279_done
    goto rxscan1279_scan
  rxscan1279_loop:
    (rx1276_pos) = rx1276_cur."from"()
    inc rx1276_pos
    rx1276_cur."!cursor_from"(rx1276_pos)
    ge rx1276_pos, rx1276_eos, rxscan1279_done
  rxscan1279_scan:
    set_addr $I10, rxscan1279_loop
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  rxscan1279_done:
.annotate 'line', 585
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."infixstopper"()
    if $P10, rx1276_fail
  # rx subrule "infix" subtype=capture negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."infix"()
    unless $P10, rx1276_fail
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1276_pos = $P10."pos"()
  # rx pass
    rx1276_cur."!cursor_pass"(rx1276_pos, "infixish")
    if_null rx1276_debug, debug_931
    rx1276_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1276_pos)
  debug_931:
    .return (rx1276_cur)
  rx1276_restart:
.annotate 'line', 4
    if_null rx1276_debug, debug_932
    rx1276_cur."!cursor_debug"("NEXT", "infixish")
  debug_932:
  rx1276_fail:
    (rx1276_rep, rx1276_pos, $I10, $P10) = rx1276_cur."!mark_fail"(0)
    lt rx1276_pos, -1, rx1276_done
    eq rx1276_pos, -1, rx1276_fail
    jump $I10
  rx1276_done:
    rx1276_cur."!cursor_fail"()
    if_null rx1276_debug, debug_933
    rx1276_cur."!cursor_debug"("FAIL", "infixish")
  debug_933:
    .return (rx1276_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("270_1299602538.98") :method
.annotate 'line', 4
    new $P1278, "ResizablePMCArray"
    push $P1278, ""
    .return ($P1278)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("271_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1281_tgt
    .local int rx1281_pos
    .local int rx1281_off
    .local int rx1281_eos
    .local int rx1281_rep
    .local pmc rx1281_cur
    .local pmc rx1281_debug
    (rx1281_cur, rx1281_pos, rx1281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1281_cur
    .local pmc match
    .lex "$/", match
    length rx1281_eos, rx1281_tgt
    gt rx1281_pos, rx1281_eos, rx1281_done
    set rx1281_off, 0
    lt rx1281_pos, 2, rx1281_start
    sub rx1281_off, rx1281_pos, 1
    substr rx1281_tgt, rx1281_tgt, rx1281_off
  rx1281_start:
    eq $I10, 1, rx1281_restart
    if_null rx1281_debug, debug_934
    rx1281_cur."!cursor_debug"("START", "infixstopper")
  debug_934:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1284_done
    goto rxscan1284_scan
  rxscan1284_loop:
    (rx1281_pos) = rx1281_cur."from"()
    inc rx1281_pos
    rx1281_cur."!cursor_from"(rx1281_pos)
    ge rx1281_pos, rx1281_eos, rxscan1284_done
  rxscan1284_scan:
    set_addr $I10, rxscan1284_loop
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  rxscan1284_done:
.annotate 'line', 586
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1281_cur."!cursor_pos"(rx1281_pos)
    $P10 = rx1281_cur."lambda"()
    unless $P10, rx1281_fail
  # rx pass
    rx1281_cur."!cursor_pass"(rx1281_pos, "infixstopper")
    if_null rx1281_debug, debug_935
    rx1281_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1281_pos)
  debug_935:
    .return (rx1281_cur)
  rx1281_restart:
.annotate 'line', 4
    if_null rx1281_debug, debug_936
    rx1281_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_936:
  rx1281_fail:
    (rx1281_rep, rx1281_pos, $I10, $P10) = rx1281_cur."!mark_fail"(0)
    lt rx1281_pos, -1, rx1281_done
    eq rx1281_pos, -1, rx1281_fail
    jump $I10
  rx1281_done:
    rx1281_cur."!cursor_fail"()
    if_null rx1281_debug, debug_937
    rx1281_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_937:
    .return (rx1281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("272_1299602538.98") :method
.annotate 'line', 4
    new $P1283, "ResizablePMCArray"
    push $P1283, ""
    .return ($P1283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("273_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1286_tgt
    .local int rx1286_pos
    .local int rx1286_off
    .local int rx1286_eos
    .local int rx1286_rep
    .local pmc rx1286_cur
    .local pmc rx1286_debug
    (rx1286_cur, rx1286_pos, rx1286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1286_cur
    .local pmc match
    .lex "$/", match
    length rx1286_eos, rx1286_tgt
    gt rx1286_pos, rx1286_eos, rx1286_done
    set rx1286_off, 0
    lt rx1286_pos, 2, rx1286_start
    sub rx1286_off, rx1286_pos, 1
    substr rx1286_tgt, rx1286_tgt, rx1286_off
  rx1286_start:
    eq $I10, 1, rx1286_restart
    if_null rx1286_debug, debug_938
    rx1286_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_938:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1290_done
    goto rxscan1290_scan
  rxscan1290_loop:
    (rx1286_pos) = rx1286_cur."from"()
    inc rx1286_pos
    rx1286_cur."!cursor_from"(rx1286_pos)
    ge rx1286_pos, rx1286_eos, rxscan1290_done
  rxscan1290_scan:
    set_addr $I10, rxscan1290_loop
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxscan1290_done:
.annotate 'line', 589
  # rx literal  "["
    add $I11, rx1286_pos, 1
    gt $I11, rx1286_eos, rx1286_fail
    sub $I11, rx1286_pos, rx1286_off
    ord $I11, rx1286_tgt, $I11
    ne $I11, 91, rx1286_fail
    add rx1286_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."ws"()
    unless $P10, rx1286_fail
    rx1286_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."EXPR"()
    unless $P10, rx1286_fail
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1286_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1286_pos, 1
    gt $I11, rx1286_eos, rx1286_fail
    sub $I11, rx1286_pos, rx1286_off
    ord $I11, rx1286_tgt, $I11
    ne $I11, 93, rx1286_fail
    add rx1286_pos, 1
.annotate 'line', 590
  # rx subrule "O" subtype=capture negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."O"("%methodop")
    unless $P10, rx1286_fail
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1286_pos = $P10."pos"()
.annotate 'line', 588
  # rx pass
    rx1286_cur."!cursor_pass"(rx1286_pos, "postcircumfix:sym<[ ]>")
    if_null rx1286_debug, debug_939
    rx1286_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1286_pos)
  debug_939:
    .return (rx1286_cur)
  rx1286_restart:
.annotate 'line', 4
    if_null rx1286_debug, debug_940
    rx1286_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_940:
  rx1286_fail:
    (rx1286_rep, rx1286_pos, $I10, $P10) = rx1286_cur."!mark_fail"(0)
    lt rx1286_pos, -1, rx1286_done
    eq rx1286_pos, -1, rx1286_fail
    jump $I10
  rx1286_done:
    rx1286_cur."!cursor_fail"()
    if_null rx1286_debug, debug_941
    rx1286_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_941:
    .return (rx1286_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("274_1299602538.98") :method
.annotate 'line', 4
    $P1288 = self."!PREFIX__!subrule"("ws", "[")
    new $P1289, "ResizablePMCArray"
    push $P1289, $P1288
    .return ($P1289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("275_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1292_tgt
    .local int rx1292_pos
    .local int rx1292_off
    .local int rx1292_eos
    .local int rx1292_rep
    .local pmc rx1292_cur
    .local pmc rx1292_debug
    (rx1292_cur, rx1292_pos, rx1292_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1292_cur
    .local pmc match
    .lex "$/", match
    length rx1292_eos, rx1292_tgt
    gt rx1292_pos, rx1292_eos, rx1292_done
    set rx1292_off, 0
    lt rx1292_pos, 2, rx1292_start
    sub rx1292_off, rx1292_pos, 1
    substr rx1292_tgt, rx1292_tgt, rx1292_off
  rx1292_start:
    eq $I10, 1, rx1292_restart
    if_null rx1292_debug, debug_942
    rx1292_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_942:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1296_done
    goto rxscan1296_scan
  rxscan1296_loop:
    (rx1292_pos) = rx1292_cur."from"()
    inc rx1292_pos
    rx1292_cur."!cursor_from"(rx1292_pos)
    ge rx1292_pos, rx1292_eos, rxscan1296_done
  rxscan1296_scan:
    set_addr $I10, rxscan1296_loop
    rx1292_cur."!mark_push"(0, rx1292_pos, $I10)
  rxscan1296_done:
.annotate 'line', 594
  # rx literal  "{"
    add $I11, rx1292_pos, 1
    gt $I11, rx1292_eos, rx1292_fail
    sub $I11, rx1292_pos, rx1292_off
    ord $I11, rx1292_tgt, $I11
    ne $I11, 123, rx1292_fail
    add rx1292_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1292_cur."!cursor_pos"(rx1292_pos)
    $P10 = rx1292_cur."ws"()
    unless $P10, rx1292_fail
    rx1292_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1292_cur."!cursor_pos"(rx1292_pos)
    $P10 = rx1292_cur."EXPR"()
    unless $P10, rx1292_fail
    rx1292_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1292_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1292_pos, 1
    gt $I11, rx1292_eos, rx1292_fail
    sub $I11, rx1292_pos, rx1292_off
    ord $I11, rx1292_tgt, $I11
    ne $I11, 125, rx1292_fail
    add rx1292_pos, 1
.annotate 'line', 595
  # rx subrule "O" subtype=capture negate=
    rx1292_cur."!cursor_pos"(rx1292_pos)
    $P10 = rx1292_cur."O"("%methodop")
    unless $P10, rx1292_fail
    rx1292_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1292_pos = $P10."pos"()
.annotate 'line', 593
  # rx pass
    rx1292_cur."!cursor_pass"(rx1292_pos, "postcircumfix:sym<{ }>")
    if_null rx1292_debug, debug_943
    rx1292_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1292_pos)
  debug_943:
    .return (rx1292_cur)
  rx1292_restart:
.annotate 'line', 4
    if_null rx1292_debug, debug_944
    rx1292_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_944:
  rx1292_fail:
    (rx1292_rep, rx1292_pos, $I10, $P10) = rx1292_cur."!mark_fail"(0)
    lt rx1292_pos, -1, rx1292_done
    eq rx1292_pos, -1, rx1292_fail
    jump $I10
  rx1292_done:
    rx1292_cur."!cursor_fail"()
    if_null rx1292_debug, debug_945
    rx1292_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_945:
    .return (rx1292_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("276_1299602538.98") :method
.annotate 'line', 4
    $P1294 = self."!PREFIX__!subrule"("ws", "{")
    new $P1295, "ResizablePMCArray"
    push $P1295, $P1294
    .return ($P1295)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("277_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1298_tgt
    .local int rx1298_pos
    .local int rx1298_off
    .local int rx1298_eos
    .local int rx1298_rep
    .local pmc rx1298_cur
    .local pmc rx1298_debug
    (rx1298_cur, rx1298_pos, rx1298_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1298_cur
    .local pmc match
    .lex "$/", match
    length rx1298_eos, rx1298_tgt
    gt rx1298_pos, rx1298_eos, rx1298_done
    set rx1298_off, 0
    lt rx1298_pos, 2, rx1298_start
    sub rx1298_off, rx1298_pos, 1
    substr rx1298_tgt, rx1298_tgt, rx1298_off
  rx1298_start:
    eq $I10, 1, rx1298_restart
    if_null rx1298_debug, debug_946
    rx1298_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_946:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1301_done
    goto rxscan1301_scan
  rxscan1301_loop:
    (rx1298_pos) = rx1298_cur."from"()
    inc rx1298_pos
    rx1298_cur."!cursor_from"(rx1298_pos)
    ge rx1298_pos, rx1298_eos, rxscan1301_done
  rxscan1301_scan:
    set_addr $I10, rxscan1301_loop
    rx1298_cur."!mark_push"(0, rx1298_pos, $I10)
  rxscan1301_done:
.annotate 'line', 599
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1298_pos, rx1298_off
    substr $S10, rx1298_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1298_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1298_cur."!cursor_pos"(rx1298_pos)
    $P10 = rx1298_cur."quote_EXPR"(":q")
    unless $P10, rx1298_fail
    rx1298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1298_pos = $P10."pos"()
.annotate 'line', 600
  # rx subrule "O" subtype=capture negate=
    rx1298_cur."!cursor_pos"(rx1298_pos)
    $P10 = rx1298_cur."O"("%methodop")
    unless $P10, rx1298_fail
    rx1298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1298_pos = $P10."pos"()
.annotate 'line', 598
  # rx pass
    rx1298_cur."!cursor_pass"(rx1298_pos, "postcircumfix:sym<ang>")
    if_null rx1298_debug, debug_947
    rx1298_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1298_pos)
  debug_947:
    .return (rx1298_cur)
  rx1298_restart:
.annotate 'line', 4
    if_null rx1298_debug, debug_948
    rx1298_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_948:
  rx1298_fail:
    (rx1298_rep, rx1298_pos, $I10, $P10) = rx1298_cur."!mark_fail"(0)
    lt rx1298_pos, -1, rx1298_done
    eq rx1298_pos, -1, rx1298_fail
    jump $I10
  rx1298_done:
    rx1298_cur."!cursor_fail"()
    if_null rx1298_debug, debug_949
    rx1298_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_949:
    .return (rx1298_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("278_1299602538.98") :method
.annotate 'line', 4
    new $P1300, "ResizablePMCArray"
    push $P1300, "<"
    .return ($P1300)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("279_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1303_tgt
    .local int rx1303_pos
    .local int rx1303_off
    .local int rx1303_eos
    .local int rx1303_rep
    .local pmc rx1303_cur
    .local pmc rx1303_debug
    (rx1303_cur, rx1303_pos, rx1303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1303_cur
    .local pmc match
    .lex "$/", match
    length rx1303_eos, rx1303_tgt
    gt rx1303_pos, rx1303_eos, rx1303_done
    set rx1303_off, 0
    lt rx1303_pos, 2, rx1303_start
    sub rx1303_off, rx1303_pos, 1
    substr rx1303_tgt, rx1303_tgt, rx1303_off
  rx1303_start:
    eq $I10, 1, rx1303_restart
    if_null rx1303_debug, debug_950
    rx1303_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_950:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1307_done
    goto rxscan1307_scan
  rxscan1307_loop:
    (rx1303_pos) = rx1303_cur."from"()
    inc rx1303_pos
    rx1303_cur."!cursor_from"(rx1303_pos)
    ge rx1303_pos, rx1303_eos, rxscan1307_done
  rxscan1307_scan:
    set_addr $I10, rxscan1307_loop
    rx1303_cur."!mark_push"(0, rx1303_pos, $I10)
  rxscan1307_done:
.annotate 'line', 604
  # rx literal  "("
    add $I11, rx1303_pos, 1
    gt $I11, rx1303_eos, rx1303_fail
    sub $I11, rx1303_pos, rx1303_off
    ord $I11, rx1303_tgt, $I11
    ne $I11, 40, rx1303_fail
    add rx1303_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1303_cur."!cursor_pos"(rx1303_pos)
    $P10 = rx1303_cur."ws"()
    unless $P10, rx1303_fail
    rx1303_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1303_cur."!cursor_pos"(rx1303_pos)
    $P10 = rx1303_cur."arglist"()
    unless $P10, rx1303_fail
    rx1303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1303_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1303_pos, 1
    gt $I11, rx1303_eos, rx1303_fail
    sub $I11, rx1303_pos, rx1303_off
    ord $I11, rx1303_tgt, $I11
    ne $I11, 41, rx1303_fail
    add rx1303_pos, 1
.annotate 'line', 605
  # rx subrule "O" subtype=capture negate=
    rx1303_cur."!cursor_pos"(rx1303_pos)
    $P10 = rx1303_cur."O"("%methodop")
    unless $P10, rx1303_fail
    rx1303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1303_pos = $P10."pos"()
.annotate 'line', 603
  # rx pass
    rx1303_cur."!cursor_pass"(rx1303_pos, "postcircumfix:sym<( )>")
    if_null rx1303_debug, debug_951
    rx1303_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1303_pos)
  debug_951:
    .return (rx1303_cur)
  rx1303_restart:
.annotate 'line', 4
    if_null rx1303_debug, debug_952
    rx1303_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_952:
  rx1303_fail:
    (rx1303_rep, rx1303_pos, $I10, $P10) = rx1303_cur."!mark_fail"(0)
    lt rx1303_pos, -1, rx1303_done
    eq rx1303_pos, -1, rx1303_fail
    jump $I10
  rx1303_done:
    rx1303_cur."!cursor_fail"()
    if_null rx1303_debug, debug_953
    rx1303_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_953:
    .return (rx1303_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("280_1299602538.98") :method
.annotate 'line', 4
    $P1305 = self."!PREFIX__!subrule"("ws", "(")
    new $P1306, "ResizablePMCArray"
    push $P1306, $P1305
    .return ($P1306)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("281_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1309_tgt
    .local int rx1309_pos
    .local int rx1309_off
    .local int rx1309_eos
    .local int rx1309_rep
    .local pmc rx1309_cur
    .local pmc rx1309_debug
    (rx1309_cur, rx1309_pos, rx1309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1309_cur
    .local pmc match
    .lex "$/", match
    length rx1309_eos, rx1309_tgt
    gt rx1309_pos, rx1309_eos, rx1309_done
    set rx1309_off, 0
    lt rx1309_pos, 2, rx1309_start
    sub rx1309_off, rx1309_pos, 1
    substr rx1309_tgt, rx1309_tgt, rx1309_off
  rx1309_start:
    eq $I10, 1, rx1309_restart
    if_null rx1309_debug, debug_954
    rx1309_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_954:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1313_done
    goto rxscan1313_scan
  rxscan1313_loop:
    (rx1309_pos) = rx1309_cur."from"()
    inc rx1309_pos
    rx1309_cur."!cursor_from"(rx1309_pos)
    ge rx1309_pos, rx1309_eos, rxscan1313_done
  rxscan1313_scan:
    set_addr $I10, rxscan1313_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  rxscan1313_done:
.annotate 'line', 608
  # rx subrule "dotty" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."dotty"()
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1309_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."O"("%methodop")
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1309_pos = $P10."pos"()
  # rx pass
    rx1309_cur."!cursor_pass"(rx1309_pos, "postfix:sym<.>")
    if_null rx1309_debug, debug_955
    rx1309_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1309_pos)
  debug_955:
    .return (rx1309_cur)
  rx1309_restart:
.annotate 'line', 4
    if_null rx1309_debug, debug_956
    rx1309_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_956:
  rx1309_fail:
    (rx1309_rep, rx1309_pos, $I10, $P10) = rx1309_cur."!mark_fail"(0)
    lt rx1309_pos, -1, rx1309_done
    eq rx1309_pos, -1, rx1309_fail
    jump $I10
  rx1309_done:
    rx1309_cur."!cursor_fail"()
    if_null rx1309_debug, debug_957
    rx1309_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_957:
    .return (rx1309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("282_1299602538.98") :method
.annotate 'line', 4
    $P1311 = self."!PREFIX__!subrule"("dotty", "")
    new $P1312, "ResizablePMCArray"
    push $P1312, $P1311
    .return ($P1312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("283_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1315_tgt
    .local int rx1315_pos
    .local int rx1315_off
    .local int rx1315_eos
    .local int rx1315_rep
    .local pmc rx1315_cur
    .local pmc rx1315_debug
    (rx1315_cur, rx1315_pos, rx1315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1315_cur
    .local pmc match
    .lex "$/", match
    length rx1315_eos, rx1315_tgt
    gt rx1315_pos, rx1315_eos, rx1315_done
    set rx1315_off, 0
    lt rx1315_pos, 2, rx1315_start
    sub rx1315_off, rx1315_pos, 1
    substr rx1315_tgt, rx1315_tgt, rx1315_off
  rx1315_start:
    eq $I10, 1, rx1315_restart
    if_null rx1315_debug, debug_958
    rx1315_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_958:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1319_done
    goto rxscan1319_scan
  rxscan1319_loop:
    (rx1315_pos) = rx1315_cur."from"()
    inc rx1315_pos
    rx1315_cur."!cursor_from"(rx1315_pos)
    ge rx1315_pos, rx1315_eos, rxscan1319_done
  rxscan1319_scan:
    set_addr $I10, rxscan1319_loop
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  rxscan1319_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1320_fail
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  # rx literal  "++"
    add $I11, rx1315_pos, 2
    gt $I11, rx1315_eos, rx1315_fail
    sub $I11, rx1315_pos, rx1315_off
    substr $S10, rx1315_tgt, $I11, 2
    ne $S10, "++", rx1315_fail
    add rx1315_pos, 2
    set_addr $I10, rxcap_1320_fail
    ($I12, $I11) = rx1315_cur."!mark_peek"($I10)
    rx1315_cur."!cursor_pos"($I11)
    ($P10) = rx1315_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1315_pos, "")
    rx1315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1320_done
  rxcap_1320_fail:
    goto rx1315_fail
  rxcap_1320_done:
  # rx subrule "O" subtype=capture negate=
    rx1315_cur."!cursor_pos"(rx1315_pos)
    $P10 = rx1315_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1315_fail
    rx1315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1315_pos = $P10."pos"()
  # rx pass
    rx1315_cur."!cursor_pass"(rx1315_pos, "prefix:sym<++>")
    if_null rx1315_debug, debug_959
    rx1315_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1315_pos)
  debug_959:
    .return (rx1315_cur)
  rx1315_restart:
.annotate 'line', 4
    if_null rx1315_debug, debug_960
    rx1315_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_960:
  rx1315_fail:
    (rx1315_rep, rx1315_pos, $I10, $P10) = rx1315_cur."!mark_fail"(0)
    lt rx1315_pos, -1, rx1315_done
    eq rx1315_pos, -1, rx1315_fail
    jump $I10
  rx1315_done:
    rx1315_cur."!cursor_fail"()
    if_null rx1315_debug, debug_961
    rx1315_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_961:
    .return (rx1315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("284_1299602538.98") :method
.annotate 'line', 4
    $P1317 = self."!PREFIX__!subrule"("O", "++")
    new $P1318, "ResizablePMCArray"
    push $P1318, $P1317
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("285_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1322_tgt
    .local int rx1322_pos
    .local int rx1322_off
    .local int rx1322_eos
    .local int rx1322_rep
    .local pmc rx1322_cur
    .local pmc rx1322_debug
    (rx1322_cur, rx1322_pos, rx1322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1322_cur
    .local pmc match
    .lex "$/", match
    length rx1322_eos, rx1322_tgt
    gt rx1322_pos, rx1322_eos, rx1322_done
    set rx1322_off, 0
    lt rx1322_pos, 2, rx1322_start
    sub rx1322_off, rx1322_pos, 1
    substr rx1322_tgt, rx1322_tgt, rx1322_off
  rx1322_start:
    eq $I10, 1, rx1322_restart
    if_null rx1322_debug, debug_962
    rx1322_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_962:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1322_pos) = rx1322_cur."from"()
    inc rx1322_pos
    rx1322_cur."!cursor_from"(rx1322_pos)
    ge rx1322_pos, rx1322_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  rxscan1326_done:
.annotate 'line', 611
  # rx subcapture "sym"
    set_addr $I10, rxcap_1327_fail
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  # rx literal  "--"
    add $I11, rx1322_pos, 2
    gt $I11, rx1322_eos, rx1322_fail
    sub $I11, rx1322_pos, rx1322_off
    substr $S10, rx1322_tgt, $I11, 2
    ne $S10, "--", rx1322_fail
    add rx1322_pos, 2
    set_addr $I10, rxcap_1327_fail
    ($I12, $I11) = rx1322_cur."!mark_peek"($I10)
    rx1322_cur."!cursor_pos"($I11)
    ($P10) = rx1322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1322_pos, "")
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1327_done
  rxcap_1327_fail:
    goto rx1322_fail
  rxcap_1327_done:
  # rx subrule "O" subtype=capture negate=
    rx1322_cur."!cursor_pos"(rx1322_pos)
    $P10 = rx1322_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1322_fail
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1322_pos = $P10."pos"()
  # rx pass
    rx1322_cur."!cursor_pass"(rx1322_pos, "prefix:sym<-->")
    if_null rx1322_debug, debug_963
    rx1322_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1322_pos)
  debug_963:
    .return (rx1322_cur)
  rx1322_restart:
.annotate 'line', 4
    if_null rx1322_debug, debug_964
    rx1322_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_964:
  rx1322_fail:
    (rx1322_rep, rx1322_pos, $I10, $P10) = rx1322_cur."!mark_fail"(0)
    lt rx1322_pos, -1, rx1322_done
    eq rx1322_pos, -1, rx1322_fail
    jump $I10
  rx1322_done:
    rx1322_cur."!cursor_fail"()
    if_null rx1322_debug, debug_965
    rx1322_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_965:
    .return (rx1322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("286_1299602538.98") :method
.annotate 'line', 4
    $P1324 = self."!PREFIX__!subrule"("O", "--")
    new $P1325, "ResizablePMCArray"
    push $P1325, $P1324
    .return ($P1325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("287_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1329_tgt
    .local int rx1329_pos
    .local int rx1329_off
    .local int rx1329_eos
    .local int rx1329_rep
    .local pmc rx1329_cur
    .local pmc rx1329_debug
    (rx1329_cur, rx1329_pos, rx1329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1329_cur
    .local pmc match
    .lex "$/", match
    length rx1329_eos, rx1329_tgt
    gt rx1329_pos, rx1329_eos, rx1329_done
    set rx1329_off, 0
    lt rx1329_pos, 2, rx1329_start
    sub rx1329_off, rx1329_pos, 1
    substr rx1329_tgt, rx1329_tgt, rx1329_off
  rx1329_start:
    eq $I10, 1, rx1329_restart
    if_null rx1329_debug, debug_966
    rx1329_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_966:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1333_done
    goto rxscan1333_scan
  rxscan1333_loop:
    (rx1329_pos) = rx1329_cur."from"()
    inc rx1329_pos
    rx1329_cur."!cursor_from"(rx1329_pos)
    ge rx1329_pos, rx1329_eos, rxscan1333_done
  rxscan1333_scan:
    set_addr $I10, rxscan1333_loop
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  rxscan1333_done:
.annotate 'line', 614
  # rx subcapture "sym"
    set_addr $I10, rxcap_1334_fail
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  # rx literal  "++"
    add $I11, rx1329_pos, 2
    gt $I11, rx1329_eos, rx1329_fail
    sub $I11, rx1329_pos, rx1329_off
    substr $S10, rx1329_tgt, $I11, 2
    ne $S10, "++", rx1329_fail
    add rx1329_pos, 2
    set_addr $I10, rxcap_1334_fail
    ($I12, $I11) = rx1329_cur."!mark_peek"($I10)
    rx1329_cur."!cursor_pos"($I11)
    ($P10) = rx1329_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1329_pos, "")
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1334_done
  rxcap_1334_fail:
    goto rx1329_fail
  rxcap_1334_done:
  # rx subrule "O" subtype=capture negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."O"("%autoincrement")
    unless $P10, rx1329_fail
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1329_pos = $P10."pos"()
  # rx pass
    rx1329_cur."!cursor_pass"(rx1329_pos, "postfix:sym<++>")
    if_null rx1329_debug, debug_967
    rx1329_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1329_pos)
  debug_967:
    .return (rx1329_cur)
  rx1329_restart:
.annotate 'line', 4
    if_null rx1329_debug, debug_968
    rx1329_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_968:
  rx1329_fail:
    (rx1329_rep, rx1329_pos, $I10, $P10) = rx1329_cur."!mark_fail"(0)
    lt rx1329_pos, -1, rx1329_done
    eq rx1329_pos, -1, rx1329_fail
    jump $I10
  rx1329_done:
    rx1329_cur."!cursor_fail"()
    if_null rx1329_debug, debug_969
    rx1329_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_969:
    .return (rx1329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("288_1299602538.98") :method
.annotate 'line', 4
    $P1331 = self."!PREFIX__!subrule"("O", "++")
    new $P1332, "ResizablePMCArray"
    push $P1332, $P1331
    .return ($P1332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("289_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1336_tgt
    .local int rx1336_pos
    .local int rx1336_off
    .local int rx1336_eos
    .local int rx1336_rep
    .local pmc rx1336_cur
    .local pmc rx1336_debug
    (rx1336_cur, rx1336_pos, rx1336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1336_cur
    .local pmc match
    .lex "$/", match
    length rx1336_eos, rx1336_tgt
    gt rx1336_pos, rx1336_eos, rx1336_done
    set rx1336_off, 0
    lt rx1336_pos, 2, rx1336_start
    sub rx1336_off, rx1336_pos, 1
    substr rx1336_tgt, rx1336_tgt, rx1336_off
  rx1336_start:
    eq $I10, 1, rx1336_restart
    if_null rx1336_debug, debug_970
    rx1336_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_970:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1340_done
    goto rxscan1340_scan
  rxscan1340_loop:
    (rx1336_pos) = rx1336_cur."from"()
    inc rx1336_pos
    rx1336_cur."!cursor_from"(rx1336_pos)
    ge rx1336_pos, rx1336_eos, rxscan1340_done
  rxscan1340_scan:
    set_addr $I10, rxscan1340_loop
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  rxscan1340_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1341_fail
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  # rx literal  "--"
    add $I11, rx1336_pos, 2
    gt $I11, rx1336_eos, rx1336_fail
    sub $I11, rx1336_pos, rx1336_off
    substr $S10, rx1336_tgt, $I11, 2
    ne $S10, "--", rx1336_fail
    add rx1336_pos, 2
    set_addr $I10, rxcap_1341_fail
    ($I12, $I11) = rx1336_cur."!mark_peek"($I10)
    rx1336_cur."!cursor_pos"($I11)
    ($P10) = rx1336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1336_pos, "")
    rx1336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1341_done
  rxcap_1341_fail:
    goto rx1336_fail
  rxcap_1341_done:
  # rx subrule "O" subtype=capture negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."O"("%autoincrement")
    unless $P10, rx1336_fail
    rx1336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1336_pos = $P10."pos"()
  # rx pass
    rx1336_cur."!cursor_pass"(rx1336_pos, "postfix:sym<-->")
    if_null rx1336_debug, debug_971
    rx1336_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1336_pos)
  debug_971:
    .return (rx1336_cur)
  rx1336_restart:
.annotate 'line', 4
    if_null rx1336_debug, debug_972
    rx1336_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_972:
  rx1336_fail:
    (rx1336_rep, rx1336_pos, $I10, $P10) = rx1336_cur."!mark_fail"(0)
    lt rx1336_pos, -1, rx1336_done
    eq rx1336_pos, -1, rx1336_fail
    jump $I10
  rx1336_done:
    rx1336_cur."!cursor_fail"()
    if_null rx1336_debug, debug_973
    rx1336_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_973:
    .return (rx1336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("290_1299602538.98") :method
.annotate 'line', 4
    $P1338 = self."!PREFIX__!subrule"("O", "--")
    new $P1339, "ResizablePMCArray"
    push $P1339, $P1338
    .return ($P1339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("291_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_974
    rx1343_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1348_fail
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx literal  "**"
    add $I11, rx1343_pos, 2
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I11, 2
    ne $S10, "**", rx1343_fail
    add rx1343_pos, 2
    set_addr $I10, rxcap_1348_fail
    ($I12, $I11) = rx1343_cur."!mark_peek"($I10)
    rx1343_cur."!cursor_pos"($I11)
    ($P10) = rx1343_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1343_pos, "")
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1348_done
  rxcap_1348_fail:
    goto rx1343_fail
  rxcap_1348_done:
  # rx subrule "O" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1343_pos = $P10."pos"()
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "infix:sym<**>")
    if_null rx1343_debug, debug_975
    rx1343_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1343_pos)
  debug_975:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 4
    if_null rx1343_debug, debug_976
    rx1343_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_976:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_977
    rx1343_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_977:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("292_1299602538.98") :method
.annotate 'line', 4
    $P1345 = self."!PREFIX__!subrule"("O", "**")
    new $P1346, "ResizablePMCArray"
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("293_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1350_tgt
    .local int rx1350_pos
    .local int rx1350_off
    .local int rx1350_eos
    .local int rx1350_rep
    .local pmc rx1350_cur
    .local pmc rx1350_debug
    (rx1350_cur, rx1350_pos, rx1350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1350_cur
    .local pmc match
    .lex "$/", match
    length rx1350_eos, rx1350_tgt
    gt rx1350_pos, rx1350_eos, rx1350_done
    set rx1350_off, 0
    lt rx1350_pos, 2, rx1350_start
    sub rx1350_off, rx1350_pos, 1
    substr rx1350_tgt, rx1350_tgt, rx1350_off
  rx1350_start:
    eq $I10, 1, rx1350_restart
    if_null rx1350_debug, debug_978
    rx1350_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1354_done
    goto rxscan1354_scan
  rxscan1354_loop:
    (rx1350_pos) = rx1350_cur."from"()
    inc rx1350_pos
    rx1350_cur."!cursor_from"(rx1350_pos)
    ge rx1350_pos, rx1350_eos, rxscan1354_done
  rxscan1354_scan:
    set_addr $I10, rxscan1354_loop
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  rxscan1354_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1355_fail
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  # rx literal  "+"
    add $I11, rx1350_pos, 1
    gt $I11, rx1350_eos, rx1350_fail
    sub $I11, rx1350_pos, rx1350_off
    ord $I11, rx1350_tgt, $I11
    ne $I11, 43, rx1350_fail
    add rx1350_pos, 1
    set_addr $I10, rxcap_1355_fail
    ($I12, $I11) = rx1350_cur."!mark_peek"($I10)
    rx1350_cur."!cursor_pos"($I11)
    ($P10) = rx1350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1350_pos, "")
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1355_done
  rxcap_1355_fail:
    goto rx1350_fail
  rxcap_1355_done:
  # rx subrule "O" subtype=capture negate=
    rx1350_cur."!cursor_pos"(rx1350_pos)
    $P10 = rx1350_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1350_fail
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1350_pos = $P10."pos"()
  # rx pass
    rx1350_cur."!cursor_pass"(rx1350_pos, "prefix:sym<+>")
    if_null rx1350_debug, debug_979
    rx1350_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1350_pos)
  debug_979:
    .return (rx1350_cur)
  rx1350_restart:
.annotate 'line', 4
    if_null rx1350_debug, debug_980
    rx1350_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_980:
  rx1350_fail:
    (rx1350_rep, rx1350_pos, $I10, $P10) = rx1350_cur."!mark_fail"(0)
    lt rx1350_pos, -1, rx1350_done
    eq rx1350_pos, -1, rx1350_fail
    jump $I10
  rx1350_done:
    rx1350_cur."!cursor_fail"()
    if_null rx1350_debug, debug_981
    rx1350_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_981:
    .return (rx1350_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("294_1299602538.98") :method
.annotate 'line', 4
    $P1352 = self."!PREFIX__!subrule"("O", "+")
    new $P1353, "ResizablePMCArray"
    push $P1353, $P1352
    .return ($P1353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("295_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1357_tgt
    .local int rx1357_pos
    .local int rx1357_off
    .local int rx1357_eos
    .local int rx1357_rep
    .local pmc rx1357_cur
    .local pmc rx1357_debug
    (rx1357_cur, rx1357_pos, rx1357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1357_cur
    .local pmc match
    .lex "$/", match
    length rx1357_eos, rx1357_tgt
    gt rx1357_pos, rx1357_eos, rx1357_done
    set rx1357_off, 0
    lt rx1357_pos, 2, rx1357_start
    sub rx1357_off, rx1357_pos, 1
    substr rx1357_tgt, rx1357_tgt, rx1357_off
  rx1357_start:
    eq $I10, 1, rx1357_restart
    if_null rx1357_debug, debug_982
    rx1357_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1361_done
    goto rxscan1361_scan
  rxscan1361_loop:
    (rx1357_pos) = rx1357_cur."from"()
    inc rx1357_pos
    rx1357_cur."!cursor_from"(rx1357_pos)
    ge rx1357_pos, rx1357_eos, rxscan1361_done
  rxscan1361_scan:
    set_addr $I10, rxscan1361_loop
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  rxscan1361_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1362_fail
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  # rx literal  "~"
    add $I11, rx1357_pos, 1
    gt $I11, rx1357_eos, rx1357_fail
    sub $I11, rx1357_pos, rx1357_off
    ord $I11, rx1357_tgt, $I11
    ne $I11, 126, rx1357_fail
    add rx1357_pos, 1
    set_addr $I10, rxcap_1362_fail
    ($I12, $I11) = rx1357_cur."!mark_peek"($I10)
    rx1357_cur."!cursor_pos"($I11)
    ($P10) = rx1357_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1357_pos, "")
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1362_done
  rxcap_1362_fail:
    goto rx1357_fail
  rxcap_1362_done:
  # rx subrule "O" subtype=capture negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1357_fail
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1357_pos = $P10."pos"()
  # rx pass
    rx1357_cur."!cursor_pass"(rx1357_pos, "prefix:sym<~>")
    if_null rx1357_debug, debug_983
    rx1357_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1357_pos)
  debug_983:
    .return (rx1357_cur)
  rx1357_restart:
.annotate 'line', 4
    if_null rx1357_debug, debug_984
    rx1357_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_984:
  rx1357_fail:
    (rx1357_rep, rx1357_pos, $I10, $P10) = rx1357_cur."!mark_fail"(0)
    lt rx1357_pos, -1, rx1357_done
    eq rx1357_pos, -1, rx1357_fail
    jump $I10
  rx1357_done:
    rx1357_cur."!cursor_fail"()
    if_null rx1357_debug, debug_985
    rx1357_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_985:
    .return (rx1357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("296_1299602538.98") :method
.annotate 'line', 4
    $P1359 = self."!PREFIX__!subrule"("O", "~")
    new $P1360, "ResizablePMCArray"
    push $P1360, $P1359
    .return ($P1360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("297_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1364_tgt
    .local int rx1364_pos
    .local int rx1364_off
    .local int rx1364_eos
    .local int rx1364_rep
    .local pmc rx1364_cur
    .local pmc rx1364_debug
    (rx1364_cur, rx1364_pos, rx1364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1364_cur
    .local pmc match
    .lex "$/", match
    length rx1364_eos, rx1364_tgt
    gt rx1364_pos, rx1364_eos, rx1364_done
    set rx1364_off, 0
    lt rx1364_pos, 2, rx1364_start
    sub rx1364_off, rx1364_pos, 1
    substr rx1364_tgt, rx1364_tgt, rx1364_off
  rx1364_start:
    eq $I10, 1, rx1364_restart
    if_null rx1364_debug, debug_986
    rx1364_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    (rx1364_pos) = rx1364_cur."from"()
    inc rx1364_pos
    rx1364_cur."!cursor_from"(rx1364_pos)
    ge rx1364_pos, rx1364_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1364_cur."!mark_push"(0, rx1364_pos, $I10)
  rxscan1367_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1368_fail
    rx1364_cur."!mark_push"(0, rx1364_pos, $I10)
  # rx literal  "-"
    add $I11, rx1364_pos, 1
    gt $I11, rx1364_eos, rx1364_fail
    sub $I11, rx1364_pos, rx1364_off
    ord $I11, rx1364_tgt, $I11
    ne $I11, 45, rx1364_fail
    add rx1364_pos, 1
    set_addr $I10, rxcap_1368_fail
    ($I12, $I11) = rx1364_cur."!mark_peek"($I10)
    rx1364_cur."!cursor_pos"($I11)
    ($P10) = rx1364_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1364_pos, "")
    rx1364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1368_done
  rxcap_1368_fail:
    goto rx1364_fail
  rxcap_1368_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1364_pos, rx1364_off
    substr $S10, rx1364_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1364_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1364_cur."!cursor_pos"(rx1364_pos)
    $P10 = rx1364_cur."number"()
    if $P10, rx1364_fail
  # rx subrule "O" subtype=capture negate=
    rx1364_cur."!cursor_pos"(rx1364_pos)
    $P10 = rx1364_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1364_fail
    rx1364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1364_pos = $P10."pos"()
  # rx pass
    rx1364_cur."!cursor_pass"(rx1364_pos, "prefix:sym<->")
    if_null rx1364_debug, debug_987
    rx1364_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1364_pos)
  debug_987:
    .return (rx1364_cur)
  rx1364_restart:
.annotate 'line', 4
    if_null rx1364_debug, debug_988
    rx1364_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_988:
  rx1364_fail:
    (rx1364_rep, rx1364_pos, $I10, $P10) = rx1364_cur."!mark_fail"(0)
    lt rx1364_pos, -1, rx1364_done
    eq rx1364_pos, -1, rx1364_fail
    jump $I10
  rx1364_done:
    rx1364_cur."!cursor_fail"()
    if_null rx1364_debug, debug_989
    rx1364_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_989:
    .return (rx1364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("298_1299602538.98") :method
.annotate 'line', 4
    new $P1366, "ResizablePMCArray"
    push $P1366, "-"
    .return ($P1366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("299_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_990
    rx1370_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    (rx1370_pos) = rx1370_cur."from"()
    inc rx1370_pos
    rx1370_cur."!cursor_from"(rx1370_pos)
    ge rx1370_pos, rx1370_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1374_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1375_fail
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  # rx literal  "?"
    add $I11, rx1370_pos, 1
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    ord $I11, rx1370_tgt, $I11
    ne $I11, 63, rx1370_fail
    add rx1370_pos, 1
    set_addr $I10, rxcap_1375_fail
    ($I12, $I11) = rx1370_cur."!mark_peek"($I10)
    rx1370_cur."!cursor_pos"($I11)
    ($P10) = rx1370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1370_pos, "")
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1375_done
  rxcap_1375_fail:
    goto rx1370_fail
  rxcap_1375_done:
  # rx subrule "O" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "prefix:sym<?>")
    if_null rx1370_debug, debug_991
    rx1370_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1370_pos)
  debug_991:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 4
    if_null rx1370_debug, debug_992
    rx1370_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_992:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_993
    rx1370_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_993:
    .return (rx1370_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("300_1299602538.98") :method
.annotate 'line', 4
    $P1372 = self."!PREFIX__!subrule"("O", "?")
    new $P1373, "ResizablePMCArray"
    push $P1373, $P1372
    .return ($P1373)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("301_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_994
    rx1377_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    (rx1377_pos) = rx1377_cur."from"()
    inc rx1377_pos
    rx1377_cur."!cursor_from"(rx1377_pos)
    ge rx1377_pos, rx1377_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1381_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1382_fail
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  # rx literal  "!"
    add $I11, rx1377_pos, 1
    gt $I11, rx1377_eos, rx1377_fail
    sub $I11, rx1377_pos, rx1377_off
    ord $I11, rx1377_tgt, $I11
    ne $I11, 33, rx1377_fail
    add rx1377_pos, 1
    set_addr $I10, rxcap_1382_fail
    ($I12, $I11) = rx1377_cur."!mark_peek"($I10)
    rx1377_cur."!cursor_pos"($I11)
    ($P10) = rx1377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1377_pos, "")
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1382_done
  rxcap_1382_fail:
    goto rx1377_fail
  rxcap_1382_done:
  # rx subrule "O" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1377_fail
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1377_pos = $P10."pos"()
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "prefix:sym<!>")
    if_null rx1377_debug, debug_995
    rx1377_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1377_pos)
  debug_995:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 4
    if_null rx1377_debug, debug_996
    rx1377_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_996:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_997
    rx1377_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_997:
    .return (rx1377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("302_1299602538.98") :method
.annotate 'line', 4
    $P1379 = self."!PREFIX__!subrule"("O", "!")
    new $P1380, "ResizablePMCArray"
    push $P1380, $P1379
    .return ($P1380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("303_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_998
    rx1384_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1389_fail
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  # rx literal  "|"
    add $I11, rx1384_pos, 1
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    ord $I11, rx1384_tgt, $I11
    ne $I11, 124, rx1384_fail
    add rx1384_pos, 1
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1384_cur."!mark_peek"($I10)
    rx1384_cur."!cursor_pos"($I11)
    ($P10) = rx1384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1384_pos, "")
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1384_fail
  rxcap_1389_done:
  # rx subrule "O" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."O"("%symbolic_unary")
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "prefix:sym<|>")
    if_null rx1384_debug, debug_999
    rx1384_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1384_pos)
  debug_999:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 4
    if_null rx1384_debug, debug_1000
    rx1384_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1000:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1001
    rx1384_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1001:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("304_1299602538.98") :method
.annotate 'line', 4
    $P1386 = self."!PREFIX__!subrule"("O", "|")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("305_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_1002
    rx1391_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1395_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1396_fail
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "*"
    add $I11, rx1391_pos, 1
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    ord $I11, rx1391_tgt, $I11
    ne $I11, 42, rx1391_fail
    add rx1391_pos, 1
    set_addr $I10, rxcap_1396_fail
    ($I12, $I11) = rx1391_cur."!mark_peek"($I10)
    rx1391_cur."!cursor_pos"($I11)
    ($P10) = rx1391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1391_pos, "")
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1396_done
  rxcap_1396_fail:
    goto rx1391_fail
  rxcap_1396_done:
  # rx subrule "O" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1391_pos = $P10."pos"()
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "infix:sym<*>")
    if_null rx1391_debug, debug_1003
    rx1391_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1391_pos)
  debug_1003:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 4
    if_null rx1391_debug, debug_1004
    rx1391_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1004:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_1005
    rx1391_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1005:
    .return (rx1391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("306_1299602538.98") :method
.annotate 'line', 4
    $P1393 = self."!PREFIX__!subrule"("O", "*")
    new $P1394, "ResizablePMCArray"
    push $P1394, $P1393
    .return ($P1394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("307_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1006
    rx1398_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1006:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    (rx1398_pos) = rx1398_cur."from"()
    inc rx1398_pos
    rx1398_cur."!cursor_from"(rx1398_pos)
    ge rx1398_pos, rx1398_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1402_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1403_fail
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  # rx literal  "/"
    add $I11, rx1398_pos, 1
    gt $I11, rx1398_eos, rx1398_fail
    sub $I11, rx1398_pos, rx1398_off
    ord $I11, rx1398_tgt, $I11
    ne $I11, 47, rx1398_fail
    add rx1398_pos, 1
    set_addr $I10, rxcap_1403_fail
    ($I12, $I11) = rx1398_cur."!mark_peek"($I10)
    rx1398_cur."!cursor_pos"($I11)
    ($P10) = rx1398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1398_pos, "")
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1403_done
  rxcap_1403_fail:
    goto rx1398_fail
  rxcap_1403_done:
  # rx subrule "O" subtype=capture negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1398_fail
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1398_pos = $P10."pos"()
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "infix:sym</>")
    if_null rx1398_debug, debug_1007
    rx1398_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1398_pos)
  debug_1007:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 4
    if_null rx1398_debug, debug_1008
    rx1398_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1008:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1009
    rx1398_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1009:
    .return (rx1398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("308_1299602538.98") :method
.annotate 'line', 4
    $P1400 = self."!PREFIX__!subrule"("O", "/")
    new $P1401, "ResizablePMCArray"
    push $P1401, $P1400
    .return ($P1401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("309_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1405_tgt
    .local int rx1405_pos
    .local int rx1405_off
    .local int rx1405_eos
    .local int rx1405_rep
    .local pmc rx1405_cur
    .local pmc rx1405_debug
    (rx1405_cur, rx1405_pos, rx1405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1405_cur
    .local pmc match
    .lex "$/", match
    length rx1405_eos, rx1405_tgt
    gt rx1405_pos, rx1405_eos, rx1405_done
    set rx1405_off, 0
    lt rx1405_pos, 2, rx1405_start
    sub rx1405_off, rx1405_pos, 1
    substr rx1405_tgt, rx1405_tgt, rx1405_off
  rx1405_start:
    eq $I10, 1, rx1405_restart
    if_null rx1405_debug, debug_1010
    rx1405_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1010:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1409_done
    goto rxscan1409_scan
  rxscan1409_loop:
    (rx1405_pos) = rx1405_cur."from"()
    inc rx1405_pos
    rx1405_cur."!cursor_from"(rx1405_pos)
    ge rx1405_pos, rx1405_eos, rxscan1409_done
  rxscan1409_scan:
    set_addr $I10, rxscan1409_loop
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  rxscan1409_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1410_fail
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  # rx literal  "%"
    add $I11, rx1405_pos, 1
    gt $I11, rx1405_eos, rx1405_fail
    sub $I11, rx1405_pos, rx1405_off
    ord $I11, rx1405_tgt, $I11
    ne $I11, 37, rx1405_fail
    add rx1405_pos, 1
    set_addr $I10, rxcap_1410_fail
    ($I12, $I11) = rx1405_cur."!mark_peek"($I10)
    rx1405_cur."!cursor_pos"($I11)
    ($P10) = rx1405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1405_pos, "")
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1410_done
  rxcap_1410_fail:
    goto rx1405_fail
  rxcap_1410_done:
  # rx subrule "O" subtype=capture negate=
    rx1405_cur."!cursor_pos"(rx1405_pos)
    $P10 = rx1405_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1405_fail
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1405_pos = $P10."pos"()
  # rx pass
    rx1405_cur."!cursor_pass"(rx1405_pos, "infix:sym<%>")
    if_null rx1405_debug, debug_1011
    rx1405_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1405_pos)
  debug_1011:
    .return (rx1405_cur)
  rx1405_restart:
.annotate 'line', 4
    if_null rx1405_debug, debug_1012
    rx1405_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1012:
  rx1405_fail:
    (rx1405_rep, rx1405_pos, $I10, $P10) = rx1405_cur."!mark_fail"(0)
    lt rx1405_pos, -1, rx1405_done
    eq rx1405_pos, -1, rx1405_fail
    jump $I10
  rx1405_done:
    rx1405_cur."!cursor_fail"()
    if_null rx1405_debug, debug_1013
    rx1405_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1013:
    .return (rx1405_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("310_1299602538.98") :method
.annotate 'line', 4
    $P1407 = self."!PREFIX__!subrule"("O", "%")
    new $P1408, "ResizablePMCArray"
    push $P1408, $P1407
    .return ($P1408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("311_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1412_tgt
    .local int rx1412_pos
    .local int rx1412_off
    .local int rx1412_eos
    .local int rx1412_rep
    .local pmc rx1412_cur
    .local pmc rx1412_debug
    (rx1412_cur, rx1412_pos, rx1412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1412_cur
    .local pmc match
    .lex "$/", match
    length rx1412_eos, rx1412_tgt
    gt rx1412_pos, rx1412_eos, rx1412_done
    set rx1412_off, 0
    lt rx1412_pos, 2, rx1412_start
    sub rx1412_off, rx1412_pos, 1
    substr rx1412_tgt, rx1412_tgt, rx1412_off
  rx1412_start:
    eq $I10, 1, rx1412_restart
    if_null rx1412_debug, debug_1014
    rx1412_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    (rx1412_pos) = rx1412_cur."from"()
    inc rx1412_pos
    rx1412_cur."!cursor_from"(rx1412_pos)
    ge rx1412_pos, rx1412_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  rxscan1416_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1417_fail
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1412_pos, 2
    gt $I11, rx1412_eos, rx1412_fail
    sub $I11, rx1412_pos, rx1412_off
    substr $S10, rx1412_tgt, $I11, 2
    ne $S10, "+&", rx1412_fail
    add rx1412_pos, 2
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1412_cur."!mark_peek"($I10)
    rx1412_cur."!cursor_pos"($I11)
    ($P10) = rx1412_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1412_pos, "")
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1412_fail
  rxcap_1417_done:
  # rx subrule "O" subtype=capture negate=
    rx1412_cur."!cursor_pos"(rx1412_pos)
    $P10 = rx1412_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1412_fail
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1412_pos = $P10."pos"()
  # rx pass
    rx1412_cur."!cursor_pass"(rx1412_pos, "infix:sym<+&>")
    if_null rx1412_debug, debug_1015
    rx1412_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1412_pos)
  debug_1015:
    .return (rx1412_cur)
  rx1412_restart:
.annotate 'line', 4
    if_null rx1412_debug, debug_1016
    rx1412_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1016:
  rx1412_fail:
    (rx1412_rep, rx1412_pos, $I10, $P10) = rx1412_cur."!mark_fail"(0)
    lt rx1412_pos, -1, rx1412_done
    eq rx1412_pos, -1, rx1412_fail
    jump $I10
  rx1412_done:
    rx1412_cur."!cursor_fail"()
    if_null rx1412_debug, debug_1017
    rx1412_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1017:
    .return (rx1412_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("312_1299602538.98") :method
.annotate 'line', 4
    $P1414 = self."!PREFIX__!subrule"("O", "+&")
    new $P1415, "ResizablePMCArray"
    push $P1415, $P1414
    .return ($P1415)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("313_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_1018
    rx1419_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1423_done
    goto rxscan1423_scan
  rxscan1423_loop:
    (rx1419_pos) = rx1419_cur."from"()
    inc rx1419_pos
    rx1419_cur."!cursor_from"(rx1419_pos)
    ge rx1419_pos, rx1419_eos, rxscan1423_done
  rxscan1423_scan:
    set_addr $I10, rxscan1423_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1423_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1424_fail
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  # rx literal  "+"
    add $I11, rx1419_pos, 1
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    ord $I11, rx1419_tgt, $I11
    ne $I11, 43, rx1419_fail
    add rx1419_pos, 1
    set_addr $I10, rxcap_1424_fail
    ($I12, $I11) = rx1419_cur."!mark_peek"($I10)
    rx1419_cur."!cursor_pos"($I11)
    ($P10) = rx1419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1419_pos, "")
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1424_done
  rxcap_1424_fail:
    goto rx1419_fail
  rxcap_1424_done:
  # rx subrule "O" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1419_pos = $P10."pos"()
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "infix:sym<+>")
    if_null rx1419_debug, debug_1019
    rx1419_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1419_pos)
  debug_1019:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 4
    if_null rx1419_debug, debug_1020
    rx1419_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1020:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_1021
    rx1419_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1021:
    .return (rx1419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("314_1299602538.98") :method
.annotate 'line', 4
    $P1421 = self."!PREFIX__!subrule"("O", "+")
    new $P1422, "ResizablePMCArray"
    push $P1422, $P1421
    .return ($P1422)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("315_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1426_tgt
    .local int rx1426_pos
    .local int rx1426_off
    .local int rx1426_eos
    .local int rx1426_rep
    .local pmc rx1426_cur
    .local pmc rx1426_debug
    (rx1426_cur, rx1426_pos, rx1426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1426_cur
    .local pmc match
    .lex "$/", match
    length rx1426_eos, rx1426_tgt
    gt rx1426_pos, rx1426_eos, rx1426_done
    set rx1426_off, 0
    lt rx1426_pos, 2, rx1426_start
    sub rx1426_off, rx1426_pos, 1
    substr rx1426_tgt, rx1426_tgt, rx1426_off
  rx1426_start:
    eq $I10, 1, rx1426_restart
    if_null rx1426_debug, debug_1022
    rx1426_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1022:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1430_done
    goto rxscan1430_scan
  rxscan1430_loop:
    (rx1426_pos) = rx1426_cur."from"()
    inc rx1426_pos
    rx1426_cur."!cursor_from"(rx1426_pos)
    ge rx1426_pos, rx1426_eos, rxscan1430_done
  rxscan1430_scan:
    set_addr $I10, rxscan1430_loop
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxscan1430_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1431_fail
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  # rx literal  "-"
    add $I11, rx1426_pos, 1
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    ord $I11, rx1426_tgt, $I11
    ne $I11, 45, rx1426_fail
    add rx1426_pos, 1
    set_addr $I10, rxcap_1431_fail
    ($I12, $I11) = rx1426_cur."!mark_peek"($I10)
    rx1426_cur."!cursor_pos"($I11)
    ($P10) = rx1426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1426_pos, "")
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1431_done
  rxcap_1431_fail:
    goto rx1426_fail
  rxcap_1431_done:
  # rx subrule "O" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1426_pos = $P10."pos"()
  # rx pass
    rx1426_cur."!cursor_pass"(rx1426_pos, "infix:sym<->")
    if_null rx1426_debug, debug_1023
    rx1426_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1426_pos)
  debug_1023:
    .return (rx1426_cur)
  rx1426_restart:
.annotate 'line', 4
    if_null rx1426_debug, debug_1024
    rx1426_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1024:
  rx1426_fail:
    (rx1426_rep, rx1426_pos, $I10, $P10) = rx1426_cur."!mark_fail"(0)
    lt rx1426_pos, -1, rx1426_done
    eq rx1426_pos, -1, rx1426_fail
    jump $I10
  rx1426_done:
    rx1426_cur."!cursor_fail"()
    if_null rx1426_debug, debug_1025
    rx1426_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1025:
    .return (rx1426_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("316_1299602538.98") :method
.annotate 'line', 4
    $P1428 = self."!PREFIX__!subrule"("O", "-")
    new $P1429, "ResizablePMCArray"
    push $P1429, $P1428
    .return ($P1429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("317_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1433_tgt
    .local int rx1433_pos
    .local int rx1433_off
    .local int rx1433_eos
    .local int rx1433_rep
    .local pmc rx1433_cur
    .local pmc rx1433_debug
    (rx1433_cur, rx1433_pos, rx1433_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1433_cur
    .local pmc match
    .lex "$/", match
    length rx1433_eos, rx1433_tgt
    gt rx1433_pos, rx1433_eos, rx1433_done
    set rx1433_off, 0
    lt rx1433_pos, 2, rx1433_start
    sub rx1433_off, rx1433_pos, 1
    substr rx1433_tgt, rx1433_tgt, rx1433_off
  rx1433_start:
    eq $I10, 1, rx1433_restart
    if_null rx1433_debug, debug_1026
    rx1433_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1026:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1437_done
    goto rxscan1437_scan
  rxscan1437_loop:
    (rx1433_pos) = rx1433_cur."from"()
    inc rx1433_pos
    rx1433_cur."!cursor_from"(rx1433_pos)
    ge rx1433_pos, rx1433_eos, rxscan1437_done
  rxscan1437_scan:
    set_addr $I10, rxscan1437_loop
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  rxscan1437_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1438_fail
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1433_pos, 2
    gt $I11, rx1433_eos, rx1433_fail
    sub $I11, rx1433_pos, rx1433_off
    substr $S10, rx1433_tgt, $I11, 2
    ne $S10, "+|", rx1433_fail
    add rx1433_pos, 2
    set_addr $I10, rxcap_1438_fail
    ($I12, $I11) = rx1433_cur."!mark_peek"($I10)
    rx1433_cur."!cursor_pos"($I11)
    ($P10) = rx1433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1433_pos, "")
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1438_done
  rxcap_1438_fail:
    goto rx1433_fail
  rxcap_1438_done:
  # rx subrule "O" subtype=capture negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1433_fail
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1433_pos = $P10."pos"()
  # rx pass
    rx1433_cur."!cursor_pass"(rx1433_pos, "infix:sym<+|>")
    if_null rx1433_debug, debug_1027
    rx1433_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1433_pos)
  debug_1027:
    .return (rx1433_cur)
  rx1433_restart:
.annotate 'line', 4
    if_null rx1433_debug, debug_1028
    rx1433_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1028:
  rx1433_fail:
    (rx1433_rep, rx1433_pos, $I10, $P10) = rx1433_cur."!mark_fail"(0)
    lt rx1433_pos, -1, rx1433_done
    eq rx1433_pos, -1, rx1433_fail
    jump $I10
  rx1433_done:
    rx1433_cur."!cursor_fail"()
    if_null rx1433_debug, debug_1029
    rx1433_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1029:
    .return (rx1433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("318_1299602538.98") :method
.annotate 'line', 4
    $P1435 = self."!PREFIX__!subrule"("O", "+|")
    new $P1436, "ResizablePMCArray"
    push $P1436, $P1435
    .return ($P1436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("319_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1440_tgt
    .local int rx1440_pos
    .local int rx1440_off
    .local int rx1440_eos
    .local int rx1440_rep
    .local pmc rx1440_cur
    .local pmc rx1440_debug
    (rx1440_cur, rx1440_pos, rx1440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1440_cur
    .local pmc match
    .lex "$/", match
    length rx1440_eos, rx1440_tgt
    gt rx1440_pos, rx1440_eos, rx1440_done
    set rx1440_off, 0
    lt rx1440_pos, 2, rx1440_start
    sub rx1440_off, rx1440_pos, 1
    substr rx1440_tgt, rx1440_tgt, rx1440_off
  rx1440_start:
    eq $I10, 1, rx1440_restart
    if_null rx1440_debug, debug_1030
    rx1440_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1030:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1444_done
    goto rxscan1444_scan
  rxscan1444_loop:
    (rx1440_pos) = rx1440_cur."from"()
    inc rx1440_pos
    rx1440_cur."!cursor_from"(rx1440_pos)
    ge rx1440_pos, rx1440_eos, rxscan1444_done
  rxscan1444_scan:
    set_addr $I10, rxscan1444_loop
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  rxscan1444_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1445_fail
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1440_pos, 2
    gt $I11, rx1440_eos, rx1440_fail
    sub $I11, rx1440_pos, rx1440_off
    substr $S10, rx1440_tgt, $I11, 2
    ne $S10, "+^", rx1440_fail
    add rx1440_pos, 2
    set_addr $I10, rxcap_1445_fail
    ($I12, $I11) = rx1440_cur."!mark_peek"($I10)
    rx1440_cur."!cursor_pos"($I11)
    ($P10) = rx1440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1440_pos, "")
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1445_done
  rxcap_1445_fail:
    goto rx1440_fail
  rxcap_1445_done:
  # rx subrule "O" subtype=capture negate=
    rx1440_cur."!cursor_pos"(rx1440_pos)
    $P10 = rx1440_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1440_fail
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1440_pos = $P10."pos"()
  # rx pass
    rx1440_cur."!cursor_pass"(rx1440_pos, "infix:sym<+^>")
    if_null rx1440_debug, debug_1031
    rx1440_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1440_pos)
  debug_1031:
    .return (rx1440_cur)
  rx1440_restart:
.annotate 'line', 4
    if_null rx1440_debug, debug_1032
    rx1440_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1032:
  rx1440_fail:
    (rx1440_rep, rx1440_pos, $I10, $P10) = rx1440_cur."!mark_fail"(0)
    lt rx1440_pos, -1, rx1440_done
    eq rx1440_pos, -1, rx1440_fail
    jump $I10
  rx1440_done:
    rx1440_cur."!cursor_fail"()
    if_null rx1440_debug, debug_1033
    rx1440_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1033:
    .return (rx1440_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("320_1299602538.98") :method
.annotate 'line', 4
    $P1442 = self."!PREFIX__!subrule"("O", "+^")
    new $P1443, "ResizablePMCArray"
    push $P1443, $P1442
    .return ($P1443)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("321_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1447_tgt
    .local int rx1447_pos
    .local int rx1447_off
    .local int rx1447_eos
    .local int rx1447_rep
    .local pmc rx1447_cur
    .local pmc rx1447_debug
    (rx1447_cur, rx1447_pos, rx1447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1447_cur
    .local pmc match
    .lex "$/", match
    length rx1447_eos, rx1447_tgt
    gt rx1447_pos, rx1447_eos, rx1447_done
    set rx1447_off, 0
    lt rx1447_pos, 2, rx1447_start
    sub rx1447_off, rx1447_pos, 1
    substr rx1447_tgt, rx1447_tgt, rx1447_off
  rx1447_start:
    eq $I10, 1, rx1447_restart
    if_null rx1447_debug, debug_1034
    rx1447_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1034:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1451_done
    goto rxscan1451_scan
  rxscan1451_loop:
    (rx1447_pos) = rx1447_cur."from"()
    inc rx1447_pos
    rx1447_cur."!cursor_from"(rx1447_pos)
    ge rx1447_pos, rx1447_eos, rxscan1451_done
  rxscan1451_scan:
    set_addr $I10, rxscan1451_loop
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  rxscan1451_done:
.annotate 'line', 636
  # rx subcapture "sym"
    set_addr $I10, rxcap_1452_fail
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  # rx literal  "~"
    add $I11, rx1447_pos, 1
    gt $I11, rx1447_eos, rx1447_fail
    sub $I11, rx1447_pos, rx1447_off
    ord $I11, rx1447_tgt, $I11
    ne $I11, 126, rx1447_fail
    add rx1447_pos, 1
    set_addr $I10, rxcap_1452_fail
    ($I12, $I11) = rx1447_cur."!mark_peek"($I10)
    rx1447_cur."!cursor_pos"($I11)
    ($P10) = rx1447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1447_pos, "")
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1452_done
  rxcap_1452_fail:
    goto rx1447_fail
  rxcap_1452_done:
  # rx subrule "O" subtype=capture negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1447_fail
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1447_pos = $P10."pos"()
  # rx pass
    rx1447_cur."!cursor_pass"(rx1447_pos, "infix:sym<~>")
    if_null rx1447_debug, debug_1035
    rx1447_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1447_pos)
  debug_1035:
    .return (rx1447_cur)
  rx1447_restart:
.annotate 'line', 4
    if_null rx1447_debug, debug_1036
    rx1447_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1036:
  rx1447_fail:
    (rx1447_rep, rx1447_pos, $I10, $P10) = rx1447_cur."!mark_fail"(0)
    lt rx1447_pos, -1, rx1447_done
    eq rx1447_pos, -1, rx1447_fail
    jump $I10
  rx1447_done:
    rx1447_cur."!cursor_fail"()
    if_null rx1447_debug, debug_1037
    rx1447_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1037:
    .return (rx1447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("322_1299602538.98") :method
.annotate 'line', 4
    $P1449 = self."!PREFIX__!subrule"("O", "~")
    new $P1450, "ResizablePMCArray"
    push $P1450, $P1449
    .return ($P1450)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("323_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1454_tgt
    .local int rx1454_pos
    .local int rx1454_off
    .local int rx1454_eos
    .local int rx1454_rep
    .local pmc rx1454_cur
    .local pmc rx1454_debug
    (rx1454_cur, rx1454_pos, rx1454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1454_cur
    .local pmc match
    .lex "$/", match
    length rx1454_eos, rx1454_tgt
    gt rx1454_pos, rx1454_eos, rx1454_done
    set rx1454_off, 0
    lt rx1454_pos, 2, rx1454_start
    sub rx1454_off, rx1454_pos, 1
    substr rx1454_tgt, rx1454_tgt, rx1454_off
  rx1454_start:
    eq $I10, 1, rx1454_restart
    if_null rx1454_debug, debug_1038
    rx1454_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1454_pos) = rx1454_cur."from"()
    inc rx1454_pos
    rx1454_cur."!cursor_from"(rx1454_pos)
    ge rx1454_pos, rx1454_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  rxscan1458_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  # rx literal  "=="
    add $I11, rx1454_pos, 2
    gt $I11, rx1454_eos, rx1454_fail
    sub $I11, rx1454_pos, rx1454_off
    substr $S10, rx1454_tgt, $I11, 2
    ne $S10, "==", rx1454_fail
    add rx1454_pos, 2
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1454_cur."!mark_peek"($I10)
    rx1454_cur."!cursor_pos"($I11)
    ($P10) = rx1454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1454_pos, "")
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1454_fail
  rxcap_1459_done:
  # rx subrule "O" subtype=capture negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1454_fail
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1454_pos = $P10."pos"()
  # rx pass
    rx1454_cur."!cursor_pass"(rx1454_pos, "infix:sym<==>")
    if_null rx1454_debug, debug_1039
    rx1454_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1454_pos)
  debug_1039:
    .return (rx1454_cur)
  rx1454_restart:
.annotate 'line', 4
    if_null rx1454_debug, debug_1040
    rx1454_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1040:
  rx1454_fail:
    (rx1454_rep, rx1454_pos, $I10, $P10) = rx1454_cur."!mark_fail"(0)
    lt rx1454_pos, -1, rx1454_done
    eq rx1454_pos, -1, rx1454_fail
    jump $I10
  rx1454_done:
    rx1454_cur."!cursor_fail"()
    if_null rx1454_debug, debug_1041
    rx1454_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1041:
    .return (rx1454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("324_1299602538.98") :method
.annotate 'line', 4
    $P1456 = self."!PREFIX__!subrule"("O", "==")
    new $P1457, "ResizablePMCArray"
    push $P1457, $P1456
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("325_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1042
    rx1461_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1465_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "!="
    add $I11, rx1461_pos, 2
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 2
    ne $S10, "!=", rx1461_fail
    add rx1461_pos, 2
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1461_fail
  rxcap_1466_done:
  # rx subrule "O" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1461_pos = $P10."pos"()
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "infix:sym<!=>")
    if_null rx1461_debug, debug_1043
    rx1461_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1461_pos)
  debug_1043:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 4
    if_null rx1461_debug, debug_1044
    rx1461_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1044:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1045
    rx1461_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1045:
    .return (rx1461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("326_1299602538.98") :method
.annotate 'line', 4
    $P1463 = self."!PREFIX__!subrule"("O", "!=")
    new $P1464, "ResizablePMCArray"
    push $P1464, $P1463
    .return ($P1464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("327_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1046
    rx1468_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1472_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "<="
    add $I11, rx1468_pos, 2
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I11, 2
    ne $S10, "<=", rx1468_fail
    add rx1468_pos, 2
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1468_fail
  rxcap_1473_done:
  # rx subrule "O" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "infix:sym<<=>")
    if_null rx1468_debug, debug_1047
    rx1468_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1468_pos)
  debug_1047:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 4
    if_null rx1468_debug, debug_1048
    rx1468_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1048:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1049
    rx1468_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1049:
    .return (rx1468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("328_1299602538.98") :method
.annotate 'line', 4
    $P1470 = self."!PREFIX__!subrule"("O", "<=")
    new $P1471, "ResizablePMCArray"
    push $P1471, $P1470
    .return ($P1471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("329_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1475_tgt
    .local int rx1475_pos
    .local int rx1475_off
    .local int rx1475_eos
    .local int rx1475_rep
    .local pmc rx1475_cur
    .local pmc rx1475_debug
    (rx1475_cur, rx1475_pos, rx1475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1475_cur
    .local pmc match
    .lex "$/", match
    length rx1475_eos, rx1475_tgt
    gt rx1475_pos, rx1475_eos, rx1475_done
    set rx1475_off, 0
    lt rx1475_pos, 2, rx1475_start
    sub rx1475_off, rx1475_pos, 1
    substr rx1475_tgt, rx1475_tgt, rx1475_off
  rx1475_start:
    eq $I10, 1, rx1475_restart
    if_null rx1475_debug, debug_1050
    rx1475_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    (rx1475_pos) = rx1475_cur."from"()
    inc rx1475_pos
    rx1475_cur."!cursor_from"(rx1475_pos)
    ge rx1475_pos, rx1475_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  rxscan1479_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  # rx literal  ">="
    add $I11, rx1475_pos, 2
    gt $I11, rx1475_eos, rx1475_fail
    sub $I11, rx1475_pos, rx1475_off
    substr $S10, rx1475_tgt, $I11, 2
    ne $S10, ">=", rx1475_fail
    add rx1475_pos, 2
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1475_cur."!mark_peek"($I10)
    rx1475_cur."!cursor_pos"($I11)
    ($P10) = rx1475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1475_pos, "")
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1475_fail
  rxcap_1480_done:
  # rx subrule "O" subtype=capture negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1475_fail
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1475_pos = $P10."pos"()
  # rx pass
    rx1475_cur."!cursor_pass"(rx1475_pos, "infix:sym<>=>")
    if_null rx1475_debug, debug_1051
    rx1475_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1475_pos)
  debug_1051:
    .return (rx1475_cur)
  rx1475_restart:
.annotate 'line', 4
    if_null rx1475_debug, debug_1052
    rx1475_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1052:
  rx1475_fail:
    (rx1475_rep, rx1475_pos, $I10, $P10) = rx1475_cur."!mark_fail"(0)
    lt rx1475_pos, -1, rx1475_done
    eq rx1475_pos, -1, rx1475_fail
    jump $I10
  rx1475_done:
    rx1475_cur."!cursor_fail"()
    if_null rx1475_debug, debug_1053
    rx1475_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1053:
    .return (rx1475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("330_1299602538.98") :method
.annotate 'line', 4
    $P1477 = self."!PREFIX__!subrule"("O", ">=")
    new $P1478, "ResizablePMCArray"
    push $P1478, $P1477
    .return ($P1478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("331_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1054
    rx1482_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 642
  # rx subcapture "sym"
    set_addr $I10, rxcap_1487_fail
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  # rx literal  "<"
    add $I11, rx1482_pos, 1
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    ord $I11, rx1482_tgt, $I11
    ne $I11, 60, rx1482_fail
    add rx1482_pos, 1
    set_addr $I10, rxcap_1487_fail
    ($I12, $I11) = rx1482_cur."!mark_peek"($I10)
    rx1482_cur."!cursor_pos"($I11)
    ($P10) = rx1482_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1482_pos, "")
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1487_done
  rxcap_1487_fail:
    goto rx1482_fail
  rxcap_1487_done:
  # rx subrule "O" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1482_pos = $P10."pos"()
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "infix:sym<<>")
    if_null rx1482_debug, debug_1055
    rx1482_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1482_pos)
  debug_1055:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 4
    if_null rx1482_debug, debug_1056
    rx1482_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1056:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1057
    rx1482_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1057:
    .return (rx1482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("332_1299602538.98") :method
.annotate 'line', 4
    $P1484 = self."!PREFIX__!subrule"("O", "<")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("333_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1489_tgt
    .local int rx1489_pos
    .local int rx1489_off
    .local int rx1489_eos
    .local int rx1489_rep
    .local pmc rx1489_cur
    .local pmc rx1489_debug
    (rx1489_cur, rx1489_pos, rx1489_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1489_cur
    .local pmc match
    .lex "$/", match
    length rx1489_eos, rx1489_tgt
    gt rx1489_pos, rx1489_eos, rx1489_done
    set rx1489_off, 0
    lt rx1489_pos, 2, rx1489_start
    sub rx1489_off, rx1489_pos, 1
    substr rx1489_tgt, rx1489_tgt, rx1489_off
  rx1489_start:
    eq $I10, 1, rx1489_restart
    if_null rx1489_debug, debug_1058
    rx1489_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1493_done
    goto rxscan1493_scan
  rxscan1493_loop:
    (rx1489_pos) = rx1489_cur."from"()
    inc rx1489_pos
    rx1489_cur."!cursor_from"(rx1489_pos)
    ge rx1489_pos, rx1489_eos, rxscan1493_done
  rxscan1493_scan:
    set_addr $I10, rxscan1493_loop
    rx1489_cur."!mark_push"(0, rx1489_pos, $I10)
  rxscan1493_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1494_fail
    rx1489_cur."!mark_push"(0, rx1489_pos, $I10)
  # rx literal  ">"
    add $I11, rx1489_pos, 1
    gt $I11, rx1489_eos, rx1489_fail
    sub $I11, rx1489_pos, rx1489_off
    ord $I11, rx1489_tgt, $I11
    ne $I11, 62, rx1489_fail
    add rx1489_pos, 1
    set_addr $I10, rxcap_1494_fail
    ($I12, $I11) = rx1489_cur."!mark_peek"($I10)
    rx1489_cur."!cursor_pos"($I11)
    ($P10) = rx1489_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1489_pos, "")
    rx1489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1494_done
  rxcap_1494_fail:
    goto rx1489_fail
  rxcap_1494_done:
  # rx subrule "O" subtype=capture negate=
    rx1489_cur."!cursor_pos"(rx1489_pos)
    $P10 = rx1489_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1489_fail
    rx1489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1489_pos = $P10."pos"()
  # rx pass
    rx1489_cur."!cursor_pass"(rx1489_pos, "infix:sym<>>")
    if_null rx1489_debug, debug_1059
    rx1489_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1489_pos)
  debug_1059:
    .return (rx1489_cur)
  rx1489_restart:
.annotate 'line', 4
    if_null rx1489_debug, debug_1060
    rx1489_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1060:
  rx1489_fail:
    (rx1489_rep, rx1489_pos, $I10, $P10) = rx1489_cur."!mark_fail"(0)
    lt rx1489_pos, -1, rx1489_done
    eq rx1489_pos, -1, rx1489_fail
    jump $I10
  rx1489_done:
    rx1489_cur."!cursor_fail"()
    if_null rx1489_debug, debug_1061
    rx1489_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1061:
    .return (rx1489_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("334_1299602538.98") :method
.annotate 'line', 4
    $P1491 = self."!PREFIX__!subrule"("O", ">")
    new $P1492, "ResizablePMCArray"
    push $P1492, $P1491
    .return ($P1492)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("335_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1496_tgt
    .local int rx1496_pos
    .local int rx1496_off
    .local int rx1496_eos
    .local int rx1496_rep
    .local pmc rx1496_cur
    .local pmc rx1496_debug
    (rx1496_cur, rx1496_pos, rx1496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1496_cur
    .local pmc match
    .lex "$/", match
    length rx1496_eos, rx1496_tgt
    gt rx1496_pos, rx1496_eos, rx1496_done
    set rx1496_off, 0
    lt rx1496_pos, 2, rx1496_start
    sub rx1496_off, rx1496_pos, 1
    substr rx1496_tgt, rx1496_tgt, rx1496_off
  rx1496_start:
    eq $I10, 1, rx1496_restart
    if_null rx1496_debug, debug_1062
    rx1496_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1500_done
    goto rxscan1500_scan
  rxscan1500_loop:
    (rx1496_pos) = rx1496_cur."from"()
    inc rx1496_pos
    rx1496_cur."!cursor_from"(rx1496_pos)
    ge rx1496_pos, rx1496_eos, rxscan1500_done
  rxscan1500_scan:
    set_addr $I10, rxscan1500_loop
    rx1496_cur."!mark_push"(0, rx1496_pos, $I10)
  rxscan1500_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1501_fail
    rx1496_cur."!mark_push"(0, rx1496_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1496_pos, 2
    gt $I11, rx1496_eos, rx1496_fail
    sub $I11, rx1496_pos, rx1496_off
    substr $S10, rx1496_tgt, $I11, 2
    ne $S10, "eq", rx1496_fail
    add rx1496_pos, 2
    set_addr $I10, rxcap_1501_fail
    ($I12, $I11) = rx1496_cur."!mark_peek"($I10)
    rx1496_cur."!cursor_pos"($I11)
    ($P10) = rx1496_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1496_pos, "")
    rx1496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1501_done
  rxcap_1501_fail:
    goto rx1496_fail
  rxcap_1501_done:
  # rx subrule "O" subtype=capture negate=
    rx1496_cur."!cursor_pos"(rx1496_pos)
    $P10 = rx1496_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1496_fail
    rx1496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1496_pos = $P10."pos"()
  # rx pass
    rx1496_cur."!cursor_pass"(rx1496_pos, "infix:sym<eq>")
    if_null rx1496_debug, debug_1063
    rx1496_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1496_pos)
  debug_1063:
    .return (rx1496_cur)
  rx1496_restart:
.annotate 'line', 4
    if_null rx1496_debug, debug_1064
    rx1496_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1064:
  rx1496_fail:
    (rx1496_rep, rx1496_pos, $I10, $P10) = rx1496_cur."!mark_fail"(0)
    lt rx1496_pos, -1, rx1496_done
    eq rx1496_pos, -1, rx1496_fail
    jump $I10
  rx1496_done:
    rx1496_cur."!cursor_fail"()
    if_null rx1496_debug, debug_1065
    rx1496_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1065:
    .return (rx1496_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("336_1299602538.98") :method
.annotate 'line', 4
    $P1498 = self."!PREFIX__!subrule"("O", "eq")
    new $P1499, "ResizablePMCArray"
    push $P1499, $P1498
    .return ($P1499)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("337_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1503_tgt
    .local int rx1503_pos
    .local int rx1503_off
    .local int rx1503_eos
    .local int rx1503_rep
    .local pmc rx1503_cur
    .local pmc rx1503_debug
    (rx1503_cur, rx1503_pos, rx1503_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1503_cur
    .local pmc match
    .lex "$/", match
    length rx1503_eos, rx1503_tgt
    gt rx1503_pos, rx1503_eos, rx1503_done
    set rx1503_off, 0
    lt rx1503_pos, 2, rx1503_start
    sub rx1503_off, rx1503_pos, 1
    substr rx1503_tgt, rx1503_tgt, rx1503_off
  rx1503_start:
    eq $I10, 1, rx1503_restart
    if_null rx1503_debug, debug_1066
    rx1503_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1066:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1503_pos) = rx1503_cur."from"()
    inc rx1503_pos
    rx1503_cur."!cursor_from"(rx1503_pos)
    ge rx1503_pos, rx1503_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxscan1507_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1508_fail
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1503_pos, 2
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    substr $S10, rx1503_tgt, $I11, 2
    ne $S10, "ne", rx1503_fail
    add rx1503_pos, 2
    set_addr $I10, rxcap_1508_fail
    ($I12, $I11) = rx1503_cur."!mark_peek"($I10)
    rx1503_cur."!cursor_pos"($I11)
    ($P10) = rx1503_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1503_pos, "")
    rx1503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1508_done
  rxcap_1508_fail:
    goto rx1503_fail
  rxcap_1508_done:
  # rx subrule "O" subtype=capture negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1503_fail
    rx1503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1503_pos = $P10."pos"()
  # rx pass
    rx1503_cur."!cursor_pass"(rx1503_pos, "infix:sym<ne>")
    if_null rx1503_debug, debug_1067
    rx1503_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1503_pos)
  debug_1067:
    .return (rx1503_cur)
  rx1503_restart:
.annotate 'line', 4
    if_null rx1503_debug, debug_1068
    rx1503_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1068:
  rx1503_fail:
    (rx1503_rep, rx1503_pos, $I10, $P10) = rx1503_cur."!mark_fail"(0)
    lt rx1503_pos, -1, rx1503_done
    eq rx1503_pos, -1, rx1503_fail
    jump $I10
  rx1503_done:
    rx1503_cur."!cursor_fail"()
    if_null rx1503_debug, debug_1069
    rx1503_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1069:
    .return (rx1503_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("338_1299602538.98") :method
.annotate 'line', 4
    $P1505 = self."!PREFIX__!subrule"("O", "ne")
    new $P1506, "ResizablePMCArray"
    push $P1506, $P1505
    .return ($P1506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("339_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1070
    rx1510_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1514_done
    goto rxscan1514_scan
  rxscan1514_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1514_done
  rxscan1514_scan:
    set_addr $I10, rxscan1514_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1514_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1515_fail
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  # rx literal  "le"
    add $I11, rx1510_pos, 2
    gt $I11, rx1510_eos, rx1510_fail
    sub $I11, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I11, 2
    ne $S10, "le", rx1510_fail
    add rx1510_pos, 2
    set_addr $I10, rxcap_1515_fail
    ($I12, $I11) = rx1510_cur."!mark_peek"($I10)
    rx1510_cur."!cursor_pos"($I11)
    ($P10) = rx1510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1510_pos, "")
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1515_done
  rxcap_1515_fail:
    goto rx1510_fail
  rxcap_1515_done:
  # rx subrule "O" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "infix:sym<le>")
    if_null rx1510_debug, debug_1071
    rx1510_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1510_pos)
  debug_1071:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 4
    if_null rx1510_debug, debug_1072
    rx1510_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1072:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1073
    rx1510_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1073:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("340_1299602538.98") :method
.annotate 'line', 4
    $P1512 = self."!PREFIX__!subrule"("O", "le")
    new $P1513, "ResizablePMCArray"
    push $P1513, $P1512
    .return ($P1513)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("341_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1517_tgt
    .local int rx1517_pos
    .local int rx1517_off
    .local int rx1517_eos
    .local int rx1517_rep
    .local pmc rx1517_cur
    .local pmc rx1517_debug
    (rx1517_cur, rx1517_pos, rx1517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1517_cur
    .local pmc match
    .lex "$/", match
    length rx1517_eos, rx1517_tgt
    gt rx1517_pos, rx1517_eos, rx1517_done
    set rx1517_off, 0
    lt rx1517_pos, 2, rx1517_start
    sub rx1517_off, rx1517_pos, 1
    substr rx1517_tgt, rx1517_tgt, rx1517_off
  rx1517_start:
    eq $I10, 1, rx1517_restart
    if_null rx1517_debug, debug_1074
    rx1517_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1521_done
    goto rxscan1521_scan
  rxscan1521_loop:
    (rx1517_pos) = rx1517_cur."from"()
    inc rx1517_pos
    rx1517_cur."!cursor_from"(rx1517_pos)
    ge rx1517_pos, rx1517_eos, rxscan1521_done
  rxscan1521_scan:
    set_addr $I10, rxscan1521_loop
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  rxscan1521_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1522_fail
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1517_pos, 2
    gt $I11, rx1517_eos, rx1517_fail
    sub $I11, rx1517_pos, rx1517_off
    substr $S10, rx1517_tgt, $I11, 2
    ne $S10, "ge", rx1517_fail
    add rx1517_pos, 2
    set_addr $I10, rxcap_1522_fail
    ($I12, $I11) = rx1517_cur."!mark_peek"($I10)
    rx1517_cur."!cursor_pos"($I11)
    ($P10) = rx1517_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1517_pos, "")
    rx1517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1522_done
  rxcap_1522_fail:
    goto rx1517_fail
  rxcap_1522_done:
  # rx subrule "O" subtype=capture negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1517_fail
    rx1517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1517_pos = $P10."pos"()
  # rx pass
    rx1517_cur."!cursor_pass"(rx1517_pos, "infix:sym<ge>")
    if_null rx1517_debug, debug_1075
    rx1517_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1517_pos)
  debug_1075:
    .return (rx1517_cur)
  rx1517_restart:
.annotate 'line', 4
    if_null rx1517_debug, debug_1076
    rx1517_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1076:
  rx1517_fail:
    (rx1517_rep, rx1517_pos, $I10, $P10) = rx1517_cur."!mark_fail"(0)
    lt rx1517_pos, -1, rx1517_done
    eq rx1517_pos, -1, rx1517_fail
    jump $I10
  rx1517_done:
    rx1517_cur."!cursor_fail"()
    if_null rx1517_debug, debug_1077
    rx1517_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1077:
    .return (rx1517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("342_1299602538.98") :method
.annotate 'line', 4
    $P1519 = self."!PREFIX__!subrule"("O", "ge")
    new $P1520, "ResizablePMCArray"
    push $P1520, $P1519
    .return ($P1520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("343_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1078
    rx1524_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1528_done
    goto rxscan1528_scan
  rxscan1528_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1528_done
  rxscan1528_scan:
    set_addr $I10, rxscan1528_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1528_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1529_fail
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1524_pos, 2
    gt $I11, rx1524_eos, rx1524_fail
    sub $I11, rx1524_pos, rx1524_off
    substr $S10, rx1524_tgt, $I11, 2
    ne $S10, "lt", rx1524_fail
    add rx1524_pos, 2
    set_addr $I10, rxcap_1529_fail
    ($I12, $I11) = rx1524_cur."!mark_peek"($I10)
    rx1524_cur."!cursor_pos"($I11)
    ($P10) = rx1524_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1524_pos, "")
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1529_done
  rxcap_1529_fail:
    goto rx1524_fail
  rxcap_1529_done:
  # rx subrule "O" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, "infix:sym<lt>")
    if_null rx1524_debug, debug_1079
    rx1524_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1524_pos)
  debug_1079:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 4
    if_null rx1524_debug, debug_1080
    rx1524_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1080:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1081
    rx1524_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1081:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("344_1299602538.98") :method
.annotate 'line', 4
    $P1526 = self."!PREFIX__!subrule"("O", "lt")
    new $P1527, "ResizablePMCArray"
    push $P1527, $P1526
    .return ($P1527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("345_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1531_tgt
    .local int rx1531_pos
    .local int rx1531_off
    .local int rx1531_eos
    .local int rx1531_rep
    .local pmc rx1531_cur
    .local pmc rx1531_debug
    (rx1531_cur, rx1531_pos, rx1531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1531_cur
    .local pmc match
    .lex "$/", match
    length rx1531_eos, rx1531_tgt
    gt rx1531_pos, rx1531_eos, rx1531_done
    set rx1531_off, 0
    lt rx1531_pos, 2, rx1531_start
    sub rx1531_off, rx1531_pos, 1
    substr rx1531_tgt, rx1531_tgt, rx1531_off
  rx1531_start:
    eq $I10, 1, rx1531_restart
    if_null rx1531_debug, debug_1082
    rx1531_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1535_done
    goto rxscan1535_scan
  rxscan1535_loop:
    (rx1531_pos) = rx1531_cur."from"()
    inc rx1531_pos
    rx1531_cur."!cursor_from"(rx1531_pos)
    ge rx1531_pos, rx1531_eos, rxscan1535_done
  rxscan1535_scan:
    set_addr $I10, rxscan1535_loop
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  rxscan1535_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1536_fail
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1531_pos, 2
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    substr $S10, rx1531_tgt, $I11, 2
    ne $S10, "gt", rx1531_fail
    add rx1531_pos, 2
    set_addr $I10, rxcap_1536_fail
    ($I12, $I11) = rx1531_cur."!mark_peek"($I10)
    rx1531_cur."!cursor_pos"($I11)
    ($P10) = rx1531_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1531_pos, "")
    rx1531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1536_done
  rxcap_1536_fail:
    goto rx1531_fail
  rxcap_1536_done:
  # rx subrule "O" subtype=capture negate=
    rx1531_cur."!cursor_pos"(rx1531_pos)
    $P10 = rx1531_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1531_fail
    rx1531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1531_pos = $P10."pos"()
  # rx pass
    rx1531_cur."!cursor_pass"(rx1531_pos, "infix:sym<gt>")
    if_null rx1531_debug, debug_1083
    rx1531_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1531_pos)
  debug_1083:
    .return (rx1531_cur)
  rx1531_restart:
.annotate 'line', 4
    if_null rx1531_debug, debug_1084
    rx1531_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1084:
  rx1531_fail:
    (rx1531_rep, rx1531_pos, $I10, $P10) = rx1531_cur."!mark_fail"(0)
    lt rx1531_pos, -1, rx1531_done
    eq rx1531_pos, -1, rx1531_fail
    jump $I10
  rx1531_done:
    rx1531_cur."!cursor_fail"()
    if_null rx1531_debug, debug_1085
    rx1531_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1085:
    .return (rx1531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("346_1299602538.98") :method
.annotate 'line', 4
    $P1533 = self."!PREFIX__!subrule"("O", "gt")
    new $P1534, "ResizablePMCArray"
    push $P1534, $P1533
    .return ($P1534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("347_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1538_tgt
    .local int rx1538_pos
    .local int rx1538_off
    .local int rx1538_eos
    .local int rx1538_rep
    .local pmc rx1538_cur
    .local pmc rx1538_debug
    (rx1538_cur, rx1538_pos, rx1538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1538_cur
    .local pmc match
    .lex "$/", match
    length rx1538_eos, rx1538_tgt
    gt rx1538_pos, rx1538_eos, rx1538_done
    set rx1538_off, 0
    lt rx1538_pos, 2, rx1538_start
    sub rx1538_off, rx1538_pos, 1
    substr rx1538_tgt, rx1538_tgt, rx1538_off
  rx1538_start:
    eq $I10, 1, rx1538_restart
    if_null rx1538_debug, debug_1086
    rx1538_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1542_done
    goto rxscan1542_scan
  rxscan1542_loop:
    (rx1538_pos) = rx1538_cur."from"()
    inc rx1538_pos
    rx1538_cur."!cursor_from"(rx1538_pos)
    ge rx1538_pos, rx1538_eos, rxscan1542_done
  rxscan1542_scan:
    set_addr $I10, rxscan1542_loop
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  rxscan1542_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1543_fail
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1538_pos, 3
    gt $I11, rx1538_eos, rx1538_fail
    sub $I11, rx1538_pos, rx1538_off
    substr $S10, rx1538_tgt, $I11, 3
    ne $S10, "=:=", rx1538_fail
    add rx1538_pos, 3
    set_addr $I10, rxcap_1543_fail
    ($I12, $I11) = rx1538_cur."!mark_peek"($I10)
    rx1538_cur."!cursor_pos"($I11)
    ($P10) = rx1538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1538_pos, "")
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1543_done
  rxcap_1543_fail:
    goto rx1538_fail
  rxcap_1543_done:
  # rx subrule "O" subtype=capture negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1538_fail
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1538_pos = $P10."pos"()
  # rx pass
    rx1538_cur."!cursor_pass"(rx1538_pos, "infix:sym<=:=>")
    if_null rx1538_debug, debug_1087
    rx1538_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1538_pos)
  debug_1087:
    .return (rx1538_cur)
  rx1538_restart:
.annotate 'line', 4
    if_null rx1538_debug, debug_1088
    rx1538_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1088:
  rx1538_fail:
    (rx1538_rep, rx1538_pos, $I10, $P10) = rx1538_cur."!mark_fail"(0)
    lt rx1538_pos, -1, rx1538_done
    eq rx1538_pos, -1, rx1538_fail
    jump $I10
  rx1538_done:
    rx1538_cur."!cursor_fail"()
    if_null rx1538_debug, debug_1089
    rx1538_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1089:
    .return (rx1538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("348_1299602538.98") :method
.annotate 'line', 4
    $P1540 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1541, "ResizablePMCArray"
    push $P1541, $P1540
    .return ($P1541)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("349_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1545_tgt
    .local int rx1545_pos
    .local int rx1545_off
    .local int rx1545_eos
    .local int rx1545_rep
    .local pmc rx1545_cur
    .local pmc rx1545_debug
    (rx1545_cur, rx1545_pos, rx1545_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1545_cur
    .local pmc match
    .lex "$/", match
    length rx1545_eos, rx1545_tgt
    gt rx1545_pos, rx1545_eos, rx1545_done
    set rx1545_off, 0
    lt rx1545_pos, 2, rx1545_start
    sub rx1545_off, rx1545_pos, 1
    substr rx1545_tgt, rx1545_tgt, rx1545_off
  rx1545_start:
    eq $I10, 1, rx1545_restart
    if_null rx1545_debug, debug_1090
    rx1545_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1090:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    (rx1545_pos) = rx1545_cur."from"()
    inc rx1545_pos
    rx1545_cur."!cursor_from"(rx1545_pos)
    ge rx1545_pos, rx1545_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1545_cur."!mark_push"(0, rx1545_pos, $I10)
  rxscan1549_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1550_fail
    rx1545_cur."!mark_push"(0, rx1545_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1545_pos, 2
    gt $I11, rx1545_eos, rx1545_fail
    sub $I11, rx1545_pos, rx1545_off
    substr $S10, rx1545_tgt, $I11, 2
    ne $S10, "~~", rx1545_fail
    add rx1545_pos, 2
    set_addr $I10, rxcap_1550_fail
    ($I12, $I11) = rx1545_cur."!mark_peek"($I10)
    rx1545_cur."!cursor_pos"($I11)
    ($P10) = rx1545_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1545_pos, "")
    rx1545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1550_done
  rxcap_1550_fail:
    goto rx1545_fail
  rxcap_1550_done:
  # rx subrule "O" subtype=capture negate=
    rx1545_cur."!cursor_pos"(rx1545_pos)
    $P10 = rx1545_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1545_fail
    rx1545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1545_pos = $P10."pos"()
  # rx pass
    rx1545_cur."!cursor_pass"(rx1545_pos, "infix:sym<~~>")
    if_null rx1545_debug, debug_1091
    rx1545_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1545_pos)
  debug_1091:
    .return (rx1545_cur)
  rx1545_restart:
.annotate 'line', 4
    if_null rx1545_debug, debug_1092
    rx1545_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1092:
  rx1545_fail:
    (rx1545_rep, rx1545_pos, $I10, $P10) = rx1545_cur."!mark_fail"(0)
    lt rx1545_pos, -1, rx1545_done
    eq rx1545_pos, -1, rx1545_fail
    jump $I10
  rx1545_done:
    rx1545_cur."!cursor_fail"()
    if_null rx1545_debug, debug_1093
    rx1545_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1093:
    .return (rx1545_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("350_1299602538.98") :method
.annotate 'line', 4
    $P1547 = self."!PREFIX__!subrule"("O", "~~")
    new $P1548, "ResizablePMCArray"
    push $P1548, $P1547
    .return ($P1548)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("351_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1552_tgt
    .local int rx1552_pos
    .local int rx1552_off
    .local int rx1552_eos
    .local int rx1552_rep
    .local pmc rx1552_cur
    .local pmc rx1552_debug
    (rx1552_cur, rx1552_pos, rx1552_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1552_cur
    .local pmc match
    .lex "$/", match
    length rx1552_eos, rx1552_tgt
    gt rx1552_pos, rx1552_eos, rx1552_done
    set rx1552_off, 0
    lt rx1552_pos, 2, rx1552_start
    sub rx1552_off, rx1552_pos, 1
    substr rx1552_tgt, rx1552_tgt, rx1552_off
  rx1552_start:
    eq $I10, 1, rx1552_restart
    if_null rx1552_debug, debug_1094
    rx1552_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1094:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1556_done
    goto rxscan1556_scan
  rxscan1556_loop:
    (rx1552_pos) = rx1552_cur."from"()
    inc rx1552_pos
    rx1552_cur."!cursor_from"(rx1552_pos)
    ge rx1552_pos, rx1552_eos, rxscan1556_done
  rxscan1556_scan:
    set_addr $I10, rxscan1556_loop
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  rxscan1556_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1557_fail
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1552_pos, 2
    gt $I11, rx1552_eos, rx1552_fail
    sub $I11, rx1552_pos, rx1552_off
    substr $S10, rx1552_tgt, $I11, 2
    ne $S10, "&&", rx1552_fail
    add rx1552_pos, 2
    set_addr $I10, rxcap_1557_fail
    ($I12, $I11) = rx1552_cur."!mark_peek"($I10)
    rx1552_cur."!cursor_pos"($I11)
    ($P10) = rx1552_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1552_pos, "")
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1557_done
  rxcap_1557_fail:
    goto rx1552_fail
  rxcap_1557_done:
  # rx subrule "O" subtype=capture negate=
    rx1552_cur."!cursor_pos"(rx1552_pos)
    $P10 = rx1552_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1552_fail
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1552_pos = $P10."pos"()
  # rx pass
    rx1552_cur."!cursor_pass"(rx1552_pos, "infix:sym<&&>")
    if_null rx1552_debug, debug_1095
    rx1552_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1552_pos)
  debug_1095:
    .return (rx1552_cur)
  rx1552_restart:
.annotate 'line', 4
    if_null rx1552_debug, debug_1096
    rx1552_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1096:
  rx1552_fail:
    (rx1552_rep, rx1552_pos, $I10, $P10) = rx1552_cur."!mark_fail"(0)
    lt rx1552_pos, -1, rx1552_done
    eq rx1552_pos, -1, rx1552_fail
    jump $I10
  rx1552_done:
    rx1552_cur."!cursor_fail"()
    if_null rx1552_debug, debug_1097
    rx1552_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1097:
    .return (rx1552_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("352_1299602538.98") :method
.annotate 'line', 4
    $P1554 = self."!PREFIX__!subrule"("O", "&&")
    new $P1555, "ResizablePMCArray"
    push $P1555, $P1554
    .return ($P1555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("353_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1098
    rx1559_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1098:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1563_done
    goto rxscan1563_scan
  rxscan1563_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1563_done
  rxscan1563_scan:
    set_addr $I10, rxscan1563_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1563_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1564_fail
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  # rx literal  "||"
    add $I11, rx1559_pos, 2
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 2
    ne $S10, "||", rx1559_fail
    add rx1559_pos, 2
    set_addr $I10, rxcap_1564_fail
    ($I12, $I11) = rx1559_cur."!mark_peek"($I10)
    rx1559_cur."!cursor_pos"($I11)
    ($P10) = rx1559_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1559_pos, "")
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1564_done
  rxcap_1564_fail:
    goto rx1559_fail
  rxcap_1564_done:
  # rx subrule "O" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1559_pos = $P10."pos"()
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "infix:sym<||>")
    if_null rx1559_debug, debug_1099
    rx1559_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1559_pos)
  debug_1099:
    .return (rx1559_cur)
  rx1559_restart:
.annotate 'line', 4
    if_null rx1559_debug, debug_1100
    rx1559_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1100:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1101
    rx1559_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1101:
    .return (rx1559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("354_1299602538.98") :method
.annotate 'line', 4
    $P1561 = self."!PREFIX__!subrule"("O", "||")
    new $P1562, "ResizablePMCArray"
    push $P1562, $P1561
    .return ($P1562)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("355_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1566_tgt
    .local int rx1566_pos
    .local int rx1566_off
    .local int rx1566_eos
    .local int rx1566_rep
    .local pmc rx1566_cur
    .local pmc rx1566_debug
    (rx1566_cur, rx1566_pos, rx1566_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1566_cur
    .local pmc match
    .lex "$/", match
    length rx1566_eos, rx1566_tgt
    gt rx1566_pos, rx1566_eos, rx1566_done
    set rx1566_off, 0
    lt rx1566_pos, 2, rx1566_start
    sub rx1566_off, rx1566_pos, 1
    substr rx1566_tgt, rx1566_tgt, rx1566_off
  rx1566_start:
    eq $I10, 1, rx1566_restart
    if_null rx1566_debug, debug_1102
    rx1566_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1570_done
    goto rxscan1570_scan
  rxscan1570_loop:
    (rx1566_pos) = rx1566_cur."from"()
    inc rx1566_pos
    rx1566_cur."!cursor_from"(rx1566_pos)
    ge rx1566_pos, rx1566_eos, rxscan1570_done
  rxscan1570_scan:
    set_addr $I10, rxscan1570_loop
    rx1566_cur."!mark_push"(0, rx1566_pos, $I10)
  rxscan1570_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1571_fail
    rx1566_cur."!mark_push"(0, rx1566_pos, $I10)
  # rx literal  "//"
    add $I11, rx1566_pos, 2
    gt $I11, rx1566_eos, rx1566_fail
    sub $I11, rx1566_pos, rx1566_off
    substr $S10, rx1566_tgt, $I11, 2
    ne $S10, "//", rx1566_fail
    add rx1566_pos, 2
    set_addr $I10, rxcap_1571_fail
    ($I12, $I11) = rx1566_cur."!mark_peek"($I10)
    rx1566_cur."!cursor_pos"($I11)
    ($P10) = rx1566_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1566_pos, "")
    rx1566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1571_done
  rxcap_1571_fail:
    goto rx1566_fail
  rxcap_1571_done:
  # rx subrule "O" subtype=capture negate=
    rx1566_cur."!cursor_pos"(rx1566_pos)
    $P10 = rx1566_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1566_fail
    rx1566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1566_pos = $P10."pos"()
  # rx pass
    rx1566_cur."!cursor_pass"(rx1566_pos, "infix:sym<//>")
    if_null rx1566_debug, debug_1103
    rx1566_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1566_pos)
  debug_1103:
    .return (rx1566_cur)
  rx1566_restart:
.annotate 'line', 4
    if_null rx1566_debug, debug_1104
    rx1566_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1104:
  rx1566_fail:
    (rx1566_rep, rx1566_pos, $I10, $P10) = rx1566_cur."!mark_fail"(0)
    lt rx1566_pos, -1, rx1566_done
    eq rx1566_pos, -1, rx1566_fail
    jump $I10
  rx1566_done:
    rx1566_cur."!cursor_fail"()
    if_null rx1566_debug, debug_1105
    rx1566_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1105:
    .return (rx1566_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("356_1299602538.98") :method
.annotate 'line', 4
    $P1568 = self."!PREFIX__!subrule"("O", "//")
    new $P1569, "ResizablePMCArray"
    push $P1569, $P1568
    .return ($P1569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("357_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1106
    rx1573_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1577_done
    goto rxscan1577_scan
  rxscan1577_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1577_done
  rxscan1577_scan:
    set_addr $I10, rxscan1577_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1577_done:
.annotate 'line', 659
  # rx literal  "??"
    add $I11, rx1573_pos, 2
    gt $I11, rx1573_eos, rx1573_fail
    sub $I11, rx1573_pos, rx1573_off
    substr $S10, rx1573_tgt, $I11, 2
    ne $S10, "??", rx1573_fail
    add rx1573_pos, 2
.annotate 'line', 660
  # rx subrule "ws" subtype=method negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."ws"()
    unless $P10, rx1573_fail
    rx1573_pos = $P10."pos"()
.annotate 'line', 661
  # rx subrule "EXPR" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."EXPR"("i=")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1573_pos = $P10."pos"()
.annotate 'line', 662
  # rx literal  "!!"
    add $I11, rx1573_pos, 2
    gt $I11, rx1573_eos, rx1573_fail
    sub $I11, rx1573_pos, rx1573_off
    substr $S10, rx1573_tgt, $I11, 2
    ne $S10, "!!", rx1573_fail
    add rx1573_pos, 2
.annotate 'line', 663
  # rx subrule "O" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1573_pos = $P10."pos"()
.annotate 'line', 658
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "infix:sym<?? !!>")
    if_null rx1573_debug, debug_1107
    rx1573_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1573_pos)
  debug_1107:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 4
    if_null rx1573_debug, debug_1108
    rx1573_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1108:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1109
    rx1573_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1109:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("358_1299602538.98") :method
.annotate 'line', 4
    $P1575 = self."!PREFIX__!subrule"("ws", "??")
    new $P1576, "ResizablePMCArray"
    push $P1576, $P1575
    .return ($P1576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("359_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1579_tgt
    .local int rx1579_pos
    .local int rx1579_off
    .local int rx1579_eos
    .local int rx1579_rep
    .local pmc rx1579_cur
    .local pmc rx1579_debug
    (rx1579_cur, rx1579_pos, rx1579_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1579_cur
    .local pmc match
    .lex "$/", match
    length rx1579_eos, rx1579_tgt
    gt rx1579_pos, rx1579_eos, rx1579_done
    set rx1579_off, 0
    lt rx1579_pos, 2, rx1579_start
    sub rx1579_off, rx1579_pos, 1
    substr rx1579_tgt, rx1579_tgt, rx1579_off
  rx1579_start:
    eq $I10, 1, rx1579_restart
    if_null rx1579_debug, debug_1110
    rx1579_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1583_done
    goto rxscan1583_scan
  rxscan1583_loop:
    (rx1579_pos) = rx1579_cur."from"()
    inc rx1579_pos
    rx1579_cur."!cursor_from"(rx1579_pos)
    ge rx1579_pos, rx1579_eos, rxscan1583_done
  rxscan1583_scan:
    set_addr $I10, rxscan1583_loop
    rx1579_cur."!mark_push"(0, rx1579_pos, $I10)
  rxscan1583_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1584_fail
    rx1579_cur."!mark_push"(0, rx1579_pos, $I10)
  # rx literal  "="
    add $I11, rx1579_pos, 1
    gt $I11, rx1579_eos, rx1579_fail
    sub $I11, rx1579_pos, rx1579_off
    ord $I11, rx1579_tgt, $I11
    ne $I11, 61, rx1579_fail
    add rx1579_pos, 1
    set_addr $I10, rxcap_1584_fail
    ($I12, $I11) = rx1579_cur."!mark_peek"($I10)
    rx1579_cur."!cursor_pos"($I11)
    ($P10) = rx1579_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1579_pos, "")
    rx1579_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1584_done
  rxcap_1584_fail:
    goto rx1579_fail
  rxcap_1584_done:
  # rx subrule "panic" subtype=method negate=
    rx1579_cur."!cursor_pos"(rx1579_pos)
    $P10 = rx1579_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1579_fail
    rx1579_pos = $P10."pos"()
.annotate 'line', 666
  # rx pass
    rx1579_cur."!cursor_pass"(rx1579_pos, "infix:sym<=>")
    if_null rx1579_debug, debug_1111
    rx1579_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1579_pos)
  debug_1111:
    .return (rx1579_cur)
  rx1579_restart:
.annotate 'line', 4
    if_null rx1579_debug, debug_1112
    rx1579_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1112:
  rx1579_fail:
    (rx1579_rep, rx1579_pos, $I10, $P10) = rx1579_cur."!mark_fail"(0)
    lt rx1579_pos, -1, rx1579_done
    eq rx1579_pos, -1, rx1579_fail
    jump $I10
  rx1579_done:
    rx1579_cur."!cursor_fail"()
    if_null rx1579_debug, debug_1113
    rx1579_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1113:
    .return (rx1579_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("360_1299602538.98") :method
.annotate 'line', 4
    $P1581 = self."!PREFIX__!subrule"("panic", "=")
    new $P1582, "ResizablePMCArray"
    push $P1582, $P1581
    .return ($P1582)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("361_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1586_tgt
    .local int rx1586_pos
    .local int rx1586_off
    .local int rx1586_eos
    .local int rx1586_rep
    .local pmc rx1586_cur
    .local pmc rx1586_debug
    (rx1586_cur, rx1586_pos, rx1586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1586_cur
    .local pmc match
    .lex "$/", match
    length rx1586_eos, rx1586_tgt
    gt rx1586_pos, rx1586_eos, rx1586_done
    set rx1586_off, 0
    lt rx1586_pos, 2, rx1586_start
    sub rx1586_off, rx1586_pos, 1
    substr rx1586_tgt, rx1586_tgt, rx1586_off
  rx1586_start:
    eq $I10, 1, rx1586_restart
    if_null rx1586_debug, debug_1114
    rx1586_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1590_done
    goto rxscan1590_scan
  rxscan1590_loop:
    (rx1586_pos) = rx1586_cur."from"()
    inc rx1586_pos
    rx1586_cur."!cursor_from"(rx1586_pos)
    ge rx1586_pos, rx1586_eos, rxscan1590_done
  rxscan1590_scan:
    set_addr $I10, rxscan1590_loop
    rx1586_cur."!mark_push"(0, rx1586_pos, $I10)
  rxscan1590_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1591_fail
    rx1586_cur."!mark_push"(0, rx1586_pos, $I10)
  # rx literal  ":="
    add $I11, rx1586_pos, 2
    gt $I11, rx1586_eos, rx1586_fail
    sub $I11, rx1586_pos, rx1586_off
    substr $S10, rx1586_tgt, $I11, 2
    ne $S10, ":=", rx1586_fail
    add rx1586_pos, 2
    set_addr $I10, rxcap_1591_fail
    ($I12, $I11) = rx1586_cur."!mark_peek"($I10)
    rx1586_cur."!cursor_pos"($I11)
    ($P10) = rx1586_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1586_pos, "")
    rx1586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1591_done
  rxcap_1591_fail:
    goto rx1586_fail
  rxcap_1591_done:
  # rx subrule "O" subtype=capture negate=
    rx1586_cur."!cursor_pos"(rx1586_pos)
    $P10 = rx1586_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1586_fail
    rx1586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1586_pos = $P10."pos"()
  # rx pass
    rx1586_cur."!cursor_pass"(rx1586_pos, "infix:sym<:=>")
    if_null rx1586_debug, debug_1115
    rx1586_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1586_pos)
  debug_1115:
    .return (rx1586_cur)
  rx1586_restart:
.annotate 'line', 4
    if_null rx1586_debug, debug_1116
    rx1586_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1116:
  rx1586_fail:
    (rx1586_rep, rx1586_pos, $I10, $P10) = rx1586_cur."!mark_fail"(0)
    lt rx1586_pos, -1, rx1586_done
    eq rx1586_pos, -1, rx1586_fail
    jump $I10
  rx1586_done:
    rx1586_cur."!cursor_fail"()
    if_null rx1586_debug, debug_1117
    rx1586_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1117:
    .return (rx1586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("362_1299602538.98") :method
.annotate 'line', 4
    $P1588 = self."!PREFIX__!subrule"("O", ":=")
    new $P1589, "ResizablePMCArray"
    push $P1589, $P1588
    .return ($P1589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("363_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1593_tgt
    .local int rx1593_pos
    .local int rx1593_off
    .local int rx1593_eos
    .local int rx1593_rep
    .local pmc rx1593_cur
    .local pmc rx1593_debug
    (rx1593_cur, rx1593_pos, rx1593_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1593_cur
    .local pmc match
    .lex "$/", match
    length rx1593_eos, rx1593_tgt
    gt rx1593_pos, rx1593_eos, rx1593_done
    set rx1593_off, 0
    lt rx1593_pos, 2, rx1593_start
    sub rx1593_off, rx1593_pos, 1
    substr rx1593_tgt, rx1593_tgt, rx1593_off
  rx1593_start:
    eq $I10, 1, rx1593_restart
    if_null rx1593_debug, debug_1118
    rx1593_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1597_done
    goto rxscan1597_scan
  rxscan1597_loop:
    (rx1593_pos) = rx1593_cur."from"()
    inc rx1593_pos
    rx1593_cur."!cursor_from"(rx1593_pos)
    ge rx1593_pos, rx1593_eos, rxscan1597_done
  rxscan1597_scan:
    set_addr $I10, rxscan1597_loop
    rx1593_cur."!mark_push"(0, rx1593_pos, $I10)
  rxscan1597_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1598_fail
    rx1593_cur."!mark_push"(0, rx1593_pos, $I10)
  # rx literal  "::="
    add $I11, rx1593_pos, 3
    gt $I11, rx1593_eos, rx1593_fail
    sub $I11, rx1593_pos, rx1593_off
    substr $S10, rx1593_tgt, $I11, 3
    ne $S10, "::=", rx1593_fail
    add rx1593_pos, 3
    set_addr $I10, rxcap_1598_fail
    ($I12, $I11) = rx1593_cur."!mark_peek"($I10)
    rx1593_cur."!cursor_pos"($I11)
    ($P10) = rx1593_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1593_pos, "")
    rx1593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1598_done
  rxcap_1598_fail:
    goto rx1593_fail
  rxcap_1598_done:
  # rx subrule "O" subtype=capture negate=
    rx1593_cur."!cursor_pos"(rx1593_pos)
    $P10 = rx1593_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1593_fail
    rx1593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1593_pos = $P10."pos"()
  # rx pass
    rx1593_cur."!cursor_pass"(rx1593_pos, "infix:sym<::=>")
    if_null rx1593_debug, debug_1119
    rx1593_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1593_pos)
  debug_1119:
    .return (rx1593_cur)
  rx1593_restart:
.annotate 'line', 4
    if_null rx1593_debug, debug_1120
    rx1593_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1120:
  rx1593_fail:
    (rx1593_rep, rx1593_pos, $I10, $P10) = rx1593_cur."!mark_fail"(0)
    lt rx1593_pos, -1, rx1593_done
    eq rx1593_pos, -1, rx1593_fail
    jump $I10
  rx1593_done:
    rx1593_cur."!cursor_fail"()
    if_null rx1593_debug, debug_1121
    rx1593_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1121:
    .return (rx1593_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("364_1299602538.98") :method
.annotate 'line', 4
    $P1595 = self."!PREFIX__!subrule"("O", "::=")
    new $P1596, "ResizablePMCArray"
    push $P1596, $P1595
    .return ($P1596)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("365_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1600_tgt
    .local int rx1600_pos
    .local int rx1600_off
    .local int rx1600_eos
    .local int rx1600_rep
    .local pmc rx1600_cur
    .local pmc rx1600_debug
    (rx1600_cur, rx1600_pos, rx1600_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1600_cur
    .local pmc match
    .lex "$/", match
    length rx1600_eos, rx1600_tgt
    gt rx1600_pos, rx1600_eos, rx1600_done
    set rx1600_off, 0
    lt rx1600_pos, 2, rx1600_start
    sub rx1600_off, rx1600_pos, 1
    substr rx1600_tgt, rx1600_tgt, rx1600_off
  rx1600_start:
    eq $I10, 1, rx1600_restart
    if_null rx1600_debug, debug_1122
    rx1600_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1604_done
    goto rxscan1604_scan
  rxscan1604_loop:
    (rx1600_pos) = rx1600_cur."from"()
    inc rx1600_pos
    rx1600_cur."!cursor_from"(rx1600_pos)
    ge rx1600_pos, rx1600_eos, rxscan1604_done
  rxscan1604_scan:
    set_addr $I10, rxscan1604_loop
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  rxscan1604_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1605_fail
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  # rx literal  ","
    add $I11, rx1600_pos, 1
    gt $I11, rx1600_eos, rx1600_fail
    sub $I11, rx1600_pos, rx1600_off
    ord $I11, rx1600_tgt, $I11
    ne $I11, 44, rx1600_fail
    add rx1600_pos, 1
    set_addr $I10, rxcap_1605_fail
    ($I12, $I11) = rx1600_cur."!mark_peek"($I10)
    rx1600_cur."!cursor_pos"($I11)
    ($P10) = rx1600_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1600_pos, "")
    rx1600_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1605_done
  rxcap_1605_fail:
    goto rx1600_fail
  rxcap_1605_done:
  # rx subrule "O" subtype=capture negate=
    rx1600_cur."!cursor_pos"(rx1600_pos)
    $P10 = rx1600_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1600_fail
    rx1600_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1600_pos = $P10."pos"()
  # rx pass
    rx1600_cur."!cursor_pass"(rx1600_pos, "infix:sym<,>")
    if_null rx1600_debug, debug_1123
    rx1600_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1600_pos)
  debug_1123:
    .return (rx1600_cur)
  rx1600_restart:
.annotate 'line', 4
    if_null rx1600_debug, debug_1124
    rx1600_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1124:
  rx1600_fail:
    (rx1600_rep, rx1600_pos, $I10, $P10) = rx1600_cur."!mark_fail"(0)
    lt rx1600_pos, -1, rx1600_done
    eq rx1600_pos, -1, rx1600_fail
    jump $I10
  rx1600_done:
    rx1600_cur."!cursor_fail"()
    if_null rx1600_debug, debug_1125
    rx1600_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1125:
    .return (rx1600_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("366_1299602538.98") :method
.annotate 'line', 4
    $P1602 = self."!PREFIX__!subrule"("O", ",")
    new $P1603, "ResizablePMCArray"
    push $P1603, $P1602
    .return ($P1603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("367_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P1615 = "369_1299602538.98" 
    capture_lex $P1615
    .local string rx1607_tgt
    .local int rx1607_pos
    .local int rx1607_off
    .local int rx1607_eos
    .local int rx1607_rep
    .local pmc rx1607_cur
    .local pmc rx1607_debug
    (rx1607_cur, rx1607_pos, rx1607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1607_cur
    .local pmc match
    .lex "$/", match
    length rx1607_eos, rx1607_tgt
    gt rx1607_pos, rx1607_eos, rx1607_done
    set rx1607_off, 0
    lt rx1607_pos, 2, rx1607_start
    sub rx1607_off, rx1607_pos, 1
    substr rx1607_tgt, rx1607_tgt, rx1607_off
  rx1607_start:
    eq $I10, 1, rx1607_restart
    if_null rx1607_debug, debug_1126
    rx1607_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1126:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1610_done
    goto rxscan1610_scan
  rxscan1610_loop:
    (rx1607_pos) = rx1607_cur."from"()
    inc rx1607_pos
    rx1607_cur."!cursor_from"(rx1607_pos)
    ge rx1607_pos, rx1607_eos, rxscan1610_done
  rxscan1610_scan:
    set_addr $I10, rxscan1610_loop
    rx1607_cur."!mark_push"(0, rx1607_pos, $I10)
  rxscan1610_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1611_fail
    rx1607_cur."!mark_push"(0, rx1607_pos, $I10)
  # rx literal  "return"
    add $I11, rx1607_pos, 6
    gt $I11, rx1607_eos, rx1607_fail
    sub $I11, rx1607_pos, rx1607_off
    substr $S10, rx1607_tgt, $I11, 6
    ne $S10, "return", rx1607_fail
    add rx1607_pos, 6
    set_addr $I10, rxcap_1611_fail
    ($I12, $I11) = rx1607_cur."!mark_peek"($I10)
    rx1607_cur."!cursor_pos"($I11)
    ($P10) = rx1607_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1607_pos, "")
    rx1607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1611_done
  rxcap_1611_fail:
    goto rx1607_fail
  rxcap_1611_done:
  # rx charclass s
    ge rx1607_pos, rx1607_eos, rx1607_fail
    sub $I10, rx1607_pos, rx1607_off
    is_cclass $I11, 32, rx1607_tgt, $I10
    unless $I11, rx1607_fail
    inc rx1607_pos
  # rx subrule "O" subtype=capture negate=
    rx1607_cur."!cursor_pos"(rx1607_pos)
    $P10 = rx1607_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1607_fail
    rx1607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1607_pos = $P10."pos"()
    rx1607_cur."!cursor_pos"(rx1607_pos)
    find_lex $P1612, unicode:"$\x{a2}"
    $P1613 = $P1612."MATCH"()
    store_lex "$/", $P1613
    .const 'Sub' $P1615 = "369_1299602538.98" 
    capture_lex $P1615
    $P1617 = $P1615()
  # rx pass
    rx1607_cur."!cursor_pass"(rx1607_pos, "prefix:sym<return>")
    if_null rx1607_debug, debug_1127
    rx1607_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1607_pos)
  debug_1127:
    .return (rx1607_cur)
  rx1607_restart:
.annotate 'line', 4
    if_null rx1607_debug, debug_1128
    rx1607_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1128:
  rx1607_fail:
    (rx1607_rep, rx1607_pos, $I10, $P10) = rx1607_cur."!mark_fail"(0)
    lt rx1607_pos, -1, rx1607_done
    eq rx1607_pos, -1, rx1607_fail
    jump $I10
  rx1607_done:
    rx1607_cur."!cursor_fail"()
    if_null rx1607_debug, debug_1129
    rx1607_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1129:
    .return (rx1607_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("368_1299602538.98") :method
.annotate 'line', 4
    new $P1609, "ResizablePMCArray"
    push $P1609, "return"
    .return ($P1609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1614"  :anon :subid("369_1299602538.98") :outer("367_1299602538.98")
.annotate 'line', 674
    new $P1616, "Integer"
    assign $P1616, 1
    store_dynamic_lex "$*RETURN_USED", $P1616
    .return ($P1616)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("370_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1619_tgt
    .local int rx1619_pos
    .local int rx1619_off
    .local int rx1619_eos
    .local int rx1619_rep
    .local pmc rx1619_cur
    .local pmc rx1619_debug
    (rx1619_cur, rx1619_pos, rx1619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1619_cur
    .local pmc match
    .lex "$/", match
    length rx1619_eos, rx1619_tgt
    gt rx1619_pos, rx1619_eos, rx1619_done
    set rx1619_off, 0
    lt rx1619_pos, 2, rx1619_start
    sub rx1619_off, rx1619_pos, 1
    substr rx1619_tgt, rx1619_tgt, rx1619_off
  rx1619_start:
    eq $I10, 1, rx1619_restart
    if_null rx1619_debug, debug_1130
    rx1619_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1619_pos) = rx1619_cur."from"()
    inc rx1619_pos
    rx1619_cur."!cursor_from"(rx1619_pos)
    ge rx1619_pos, rx1619_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  rxscan1622_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  # rx literal  "make"
    add $I11, rx1619_pos, 4
    gt $I11, rx1619_eos, rx1619_fail
    sub $I11, rx1619_pos, rx1619_off
    substr $S10, rx1619_tgt, $I11, 4
    ne $S10, "make", rx1619_fail
    add rx1619_pos, 4
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1619_cur."!mark_peek"($I10)
    rx1619_cur."!cursor_pos"($I11)
    ($P10) = rx1619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1619_pos, "")
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1619_fail
  rxcap_1623_done:
  # rx charclass s
    ge rx1619_pos, rx1619_eos, rx1619_fail
    sub $I10, rx1619_pos, rx1619_off
    is_cclass $I11, 32, rx1619_tgt, $I10
    unless $I11, rx1619_fail
    inc rx1619_pos
  # rx subrule "O" subtype=capture negate=
    rx1619_cur."!cursor_pos"(rx1619_pos)
    $P10 = rx1619_cur."O"("%list_prefix")
    unless $P10, rx1619_fail
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1619_pos = $P10."pos"()
  # rx pass
    rx1619_cur."!cursor_pass"(rx1619_pos, "prefix:sym<make>")
    if_null rx1619_debug, debug_1131
    rx1619_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1619_pos)
  debug_1131:
    .return (rx1619_cur)
  rx1619_restart:
.annotate 'line', 4
    if_null rx1619_debug, debug_1132
    rx1619_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1132:
  rx1619_fail:
    (rx1619_rep, rx1619_pos, $I10, $P10) = rx1619_cur."!mark_fail"(0)
    lt rx1619_pos, -1, rx1619_done
    eq rx1619_pos, -1, rx1619_fail
    jump $I10
  rx1619_done:
    rx1619_cur."!cursor_fail"()
    if_null rx1619_debug, debug_1133
    rx1619_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1133:
    .return (rx1619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("371_1299602538.98") :method
.annotate 'line', 4
    new $P1621, "ResizablePMCArray"
    push $P1621, "make"
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("372_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1134
    rx1625_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1628_done
    goto rxscan1628_scan
  rxscan1628_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1628_done
  rxscan1628_scan:
    set_addr $I10, rxscan1628_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1628_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1629_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  "last"
    add $I11, rx1625_pos, 4
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    substr $S10, rx1625_tgt, $I11, 4
    ne $S10, "last", rx1625_fail
    add rx1625_pos, 4
    set_addr $I10, rxcap_1629_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1629_done
  rxcap_1629_fail:
    goto rx1625_fail
  rxcap_1629_done:
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "term:sym<last>")
    if_null rx1625_debug, debug_1135
    rx1625_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1625_pos)
  debug_1135:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 4
    if_null rx1625_debug, debug_1136
    rx1625_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1136:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1137
    rx1625_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1137:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("373_1299602538.98") :method
.annotate 'line', 4
    new $P1627, "ResizablePMCArray"
    push $P1627, "last"
    .return ($P1627)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("374_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1631_tgt
    .local int rx1631_pos
    .local int rx1631_off
    .local int rx1631_eos
    .local int rx1631_rep
    .local pmc rx1631_cur
    .local pmc rx1631_debug
    (rx1631_cur, rx1631_pos, rx1631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1631_cur
    .local pmc match
    .lex "$/", match
    length rx1631_eos, rx1631_tgt
    gt rx1631_pos, rx1631_eos, rx1631_done
    set rx1631_off, 0
    lt rx1631_pos, 2, rx1631_start
    sub rx1631_off, rx1631_pos, 1
    substr rx1631_tgt, rx1631_tgt, rx1631_off
  rx1631_start:
    eq $I10, 1, rx1631_restart
    if_null rx1631_debug, debug_1138
    rx1631_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1138:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1634_done
    goto rxscan1634_scan
  rxscan1634_loop:
    (rx1631_pos) = rx1631_cur."from"()
    inc rx1631_pos
    rx1631_cur."!cursor_from"(rx1631_pos)
    ge rx1631_pos, rx1631_eos, rxscan1634_done
  rxscan1634_scan:
    set_addr $I10, rxscan1634_loop
    rx1631_cur."!mark_push"(0, rx1631_pos, $I10)
  rxscan1634_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1635_fail
    rx1631_cur."!mark_push"(0, rx1631_pos, $I10)
  # rx literal  "next"
    add $I11, rx1631_pos, 4
    gt $I11, rx1631_eos, rx1631_fail
    sub $I11, rx1631_pos, rx1631_off
    substr $S10, rx1631_tgt, $I11, 4
    ne $S10, "next", rx1631_fail
    add rx1631_pos, 4
    set_addr $I10, rxcap_1635_fail
    ($I12, $I11) = rx1631_cur."!mark_peek"($I10)
    rx1631_cur."!cursor_pos"($I11)
    ($P10) = rx1631_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1631_pos, "")
    rx1631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1635_done
  rxcap_1635_fail:
    goto rx1631_fail
  rxcap_1635_done:
  # rx pass
    rx1631_cur."!cursor_pass"(rx1631_pos, "term:sym<next>")
    if_null rx1631_debug, debug_1139
    rx1631_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1631_pos)
  debug_1139:
    .return (rx1631_cur)
  rx1631_restart:
.annotate 'line', 4
    if_null rx1631_debug, debug_1140
    rx1631_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1140:
  rx1631_fail:
    (rx1631_rep, rx1631_pos, $I10, $P10) = rx1631_cur."!mark_fail"(0)
    lt rx1631_pos, -1, rx1631_done
    eq rx1631_pos, -1, rx1631_fail
    jump $I10
  rx1631_done:
    rx1631_cur."!cursor_fail"()
    if_null rx1631_debug, debug_1141
    rx1631_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1141:
    .return (rx1631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("375_1299602538.98") :method
.annotate 'line', 4
    new $P1633, "ResizablePMCArray"
    push $P1633, "next"
    .return ($P1633)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("376_1299602538.98") :method :outer("11_1299602538.98")
.annotate 'line', 4
    .local string rx1637_tgt
    .local int rx1637_pos
    .local int rx1637_off
    .local int rx1637_eos
    .local int rx1637_rep
    .local pmc rx1637_cur
    .local pmc rx1637_debug
    (rx1637_cur, rx1637_pos, rx1637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1637_cur
    .local pmc match
    .lex "$/", match
    length rx1637_eos, rx1637_tgt
    gt rx1637_pos, rx1637_eos, rx1637_done
    set rx1637_off, 0
    lt rx1637_pos, 2, rx1637_start
    sub rx1637_off, rx1637_pos, 1
    substr rx1637_tgt, rx1637_tgt, rx1637_off
  rx1637_start:
    eq $I10, 1, rx1637_restart
    if_null rx1637_debug, debug_1142
    rx1637_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1640_done
    goto rxscan1640_scan
  rxscan1640_loop:
    (rx1637_pos) = rx1637_cur."from"()
    inc rx1637_pos
    rx1637_cur."!cursor_from"(rx1637_pos)
    ge rx1637_pos, rx1637_eos, rxscan1640_done
  rxscan1640_scan:
    set_addr $I10, rxscan1640_loop
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  rxscan1640_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1641_fail
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1637_pos, 4
    gt $I11, rx1637_eos, rx1637_fail
    sub $I11, rx1637_pos, rx1637_off
    substr $S10, rx1637_tgt, $I11, 4
    ne $S10, "redo", rx1637_fail
    add rx1637_pos, 4
    set_addr $I10, rxcap_1641_fail
    ($I12, $I11) = rx1637_cur."!mark_peek"($I10)
    rx1637_cur."!cursor_pos"($I11)
    ($P10) = rx1637_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1637_pos, "")
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1641_done
  rxcap_1641_fail:
    goto rx1637_fail
  rxcap_1641_done:
  # rx pass
    rx1637_cur."!cursor_pass"(rx1637_pos, "term:sym<redo>")
    if_null rx1637_debug, debug_1143
    rx1637_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1637_pos)
  debug_1143:
    .return (rx1637_cur)
  rx1637_restart:
.annotate 'line', 4
    if_null rx1637_debug, debug_1144
    rx1637_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1144:
  rx1637_fail:
    (rx1637_rep, rx1637_pos, $I10, $P10) = rx1637_cur."!mark_fail"(0)
    lt rx1637_pos, -1, rx1637_done
    eq rx1637_pos, -1, rx1637_fail
    jump $I10
  rx1637_done:
    rx1637_cur."!cursor_fail"()
    if_null rx1637_debug, debug_1145
    rx1637_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1145:
    .return (rx1637_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("377_1299602538.98") :method
.annotate 'line', 4
    new $P1639, "ResizablePMCArray"
    push $P1639, "redo"
    .return ($P1639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("378_1299602538.98") :outer("11_1299602538.98")
    .param pmc param_1643
    .param pmc param_1644
.annotate 'line', 680
    .lex "self", param_1643
    .lex "$/", param_1644
.annotate 'line', 682
    new $P1645, "Undef"
    .lex "$t", $P1645
    find_lex $P1646, "$/"
    unless_null $P1646, vivify_1146
    $P1646 = root_new ['parrot';'ResizablePMCArray']
  vivify_1146:
    set $P1647, $P1646[0]
    unless_null $P1647, vivify_1147
    new $P1647, "Undef"
  vivify_1147:
    store_lex "$t", $P1647
    find_lex $P1648, "$/"
    unless_null $P1648, vivify_1148
    $P1648 = root_new ['parrot';'ResizablePMCArray']
  vivify_1148:
    set $P1649, $P1648[1]
    unless_null $P1649, vivify_1149
    new $P1649, "Undef"
  vivify_1149:
    find_lex $P1650, "$/"
    unless_null $P1650, vivify_1150
    $P1650 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1650
  vivify_1150:
    set $P1650[0], $P1649
    find_lex $P1651, "$t"
    find_lex $P1652, "$/"
    unless_null $P1652, vivify_1151
    $P1652 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1652
  vivify_1151:
    set $P1652[1], $P1651
.annotate 'line', 680
    .return ($P1651)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1653"  :subid("379_1299602538.98") :outer("11_1299602538.98")
.annotate 'line', 686
    .const 'Sub' $P1718 = "400_1299602538.98" 
    capture_lex $P1718
    .const 'Sub' $P1711 = "398_1299602538.98" 
    capture_lex $P1711
    .const 'Sub' $P1706 = "396_1299602538.98" 
    capture_lex $P1706
    .const 'Sub' $P1694 = "393_1299602538.98" 
    capture_lex $P1694
    .const 'Sub' $P1684 = "390_1299602538.98" 
    capture_lex $P1684
    .const 'Sub' $P1679 = "388_1299602538.98" 
    capture_lex $P1679
    .const 'Sub' $P1670 = "385_1299602538.98" 
    capture_lex $P1670
    .const 'Sub' $P1665 = "383_1299602538.98" 
    capture_lex $P1665
    .const 'Sub' $P1656 = "380_1299602538.98" 
    capture_lex $P1656
    get_global $P1655, "$?CLASS"
    .const 'Sub' $P1711 = "398_1299602538.98" 
    capture_lex $P1711
    .return ($P1711)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1152") :outer("379_1299602538.98")
.annotate 'line', 686
    get_hll_global $P1654, ["NQP";"Regex"], "_block1653" 
    .local pmc block
    set block, $P1654
    .const 'Sub' $P1718 = "400_1299602538.98" 
    capture_lex $P1718
    $P1718()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1717"  :anon :subid("400_1299602538.98") :outer("379_1299602538.98")
.annotate 'line', 686
    nqp_get_sc_object $P1719, "1299602532.997", 1
    .local pmc type_obj
    set type_obj, $P1719
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "380_1299602538.98" 
    $P1720."add_method"(type_obj, "metachar:sym<:my>", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__metachar:sym<:my>"
    $P1722."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "383_1299602538.98" 
    $P1724."add_method"(type_obj, "metachar:sym<{ }>", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__metachar:sym<{ }>"
    $P1726."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "385_1299602538.98" 
    $P1728."add_method"(type_obj, "metachar:sym<nqpvar>", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__metachar:sym<nqpvar>"
    $P1730."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "388_1299602538.98" 
    $P1732."add_method"(type_obj, "assertion:sym<{ }>", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__assertion:sym<{ }>"
    $P1734."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "390_1299602538.98" 
    $P1736."add_method"(type_obj, "assertion:sym<?{ }>", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__assertion:sym<?{ }>"
    $P1738."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "393_1299602538.98" 
    $P1740."add_method"(type_obj, "assertion:sym<name>", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__assertion:sym<name>"
    $P1742."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "396_1299602538.98" 
    $P1744."add_method"(type_obj, "assertion:sym<var>", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__assertion:sym<var>"
    $P1746."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "398_1299602538.98" 
    $P1748."add_method"(type_obj, "codeblock", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__codeblock"
    $P1750."add_method"(type_obj, "!PREFIX__codeblock", $P1751)
    get_how $P1752, type_obj
    get_hll_global $P1753, ["Regex";"P6Regex"], "Grammar"
    $P1752."add_parent"(type_obj, $P1753)
    get_how $P1754, type_obj
    $P1755 = $P1754."compose"(type_obj)
    .return ($P1755)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("380_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .const 'Sub' $P1662 = "382_1299602538.98" 
    capture_lex $P1662
    .local string rx1657_tgt
    .local int rx1657_pos
    .local int rx1657_off
    .local int rx1657_eos
    .local int rx1657_rep
    .local pmc rx1657_cur
    .local pmc rx1657_debug
    (rx1657_cur, rx1657_pos, rx1657_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1657_cur
    .local pmc match
    .lex "$/", match
    length rx1657_eos, rx1657_tgt
    gt rx1657_pos, rx1657_eos, rx1657_done
    set rx1657_off, 0
    lt rx1657_pos, 2, rx1657_start
    sub rx1657_off, rx1657_pos, 1
    substr rx1657_tgt, rx1657_tgt, rx1657_off
  rx1657_start:
    eq $I10, 1, rx1657_restart
    if_null rx1657_debug, debug_1153
    rx1657_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1660_done
    goto rxscan1660_scan
  rxscan1660_loop:
    (rx1657_pos) = rx1657_cur."from"()
    inc rx1657_pos
    rx1657_cur."!cursor_from"(rx1657_pos)
    ge rx1657_pos, rx1657_eos, rxscan1660_done
  rxscan1660_scan:
    set_addr $I10, rxscan1660_loop
    rx1657_cur."!mark_push"(0, rx1657_pos, $I10)
  rxscan1660_done:
.annotate 'line', 688
  # rx literal  ":"
    add $I11, rx1657_pos, 1
    gt $I11, rx1657_eos, rx1657_fail
    sub $I11, rx1657_pos, rx1657_off
    ord $I11, rx1657_tgt, $I11
    ne $I11, 58, rx1657_fail
    add rx1657_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1657_cur."!cursor_pos"(rx1657_pos)
    .const 'Sub' $P1662 = "382_1299602538.98" 
    capture_lex $P1662
    $P10 = rx1657_cur."before"($P1662)
    unless $P10, rx1657_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1657_cur."!cursor_pos"(rx1657_pos)
    $P10 = rx1657_cur."LANG"("MAIN", "statement")
    unless $P10, rx1657_fail
    rx1657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1657_cur."!cursor_pos"(rx1657_pos)
    $P10 = rx1657_cur."ws"()
    unless $P10, rx1657_fail
    rx1657_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1657_pos, 1
    gt $I11, rx1657_eos, rx1657_fail
    sub $I11, rx1657_pos, rx1657_off
    ord $I11, rx1657_tgt, $I11
    ne $I11, 59, rx1657_fail
    add rx1657_pos, 1
.annotate 'line', 687
  # rx pass
    rx1657_cur."!cursor_pass"(rx1657_pos, "metachar:sym<:my>")
    if_null rx1657_debug, debug_1158
    rx1657_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1657_pos)
  debug_1158:
    .return (rx1657_cur)
  rx1657_restart:
.annotate 'line', 686
    if_null rx1657_debug, debug_1159
    rx1657_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1159:
  rx1657_fail:
    (rx1657_rep, rx1657_pos, $I10, $P10) = rx1657_cur."!mark_fail"(0)
    lt rx1657_pos, -1, rx1657_done
    eq rx1657_pos, -1, rx1657_fail
    jump $I10
  rx1657_done:
    rx1657_cur."!cursor_fail"()
    if_null rx1657_debug, debug_1160
    rx1657_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1160:
    .return (rx1657_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("381_1299602538.98") :method
.annotate 'line', 686
    new $P1659, "ResizablePMCArray"
    push $P1659, ":"
    .return ($P1659)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1661"  :anon :subid("382_1299602538.98") :method :outer("380_1299602538.98")
.annotate 'line', 688
    .local string rx1663_tgt
    .local int rx1663_pos
    .local int rx1663_off
    .local int rx1663_eos
    .local int rx1663_rep
    .local pmc rx1663_cur
    .local pmc rx1663_debug
    (rx1663_cur, rx1663_pos, rx1663_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1663_cur
    .local pmc match
    .lex "$/", match
    length rx1663_eos, rx1663_tgt
    gt rx1663_pos, rx1663_eos, rx1663_done
    set rx1663_off, 0
    lt rx1663_pos, 2, rx1663_start
    sub rx1663_off, rx1663_pos, 1
    substr rx1663_tgt, rx1663_tgt, rx1663_off
  rx1663_start:
    eq $I10, 1, rx1663_restart
    if_null rx1663_debug, debug_1154
    rx1663_cur."!cursor_debug"("START", "")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1664_done
    goto rxscan1664_scan
  rxscan1664_loop:
    (rx1663_pos) = rx1663_cur."from"()
    inc rx1663_pos
    rx1663_cur."!cursor_from"(rx1663_pos)
    ge rx1663_pos, rx1663_eos, rxscan1664_done
  rxscan1664_scan:
    set_addr $I10, rxscan1664_loop
    rx1663_cur."!mark_push"(0, rx1663_pos, $I10)
  rxscan1664_done:
  # rx literal  "my"
    add $I11, rx1663_pos, 2
    gt $I11, rx1663_eos, rx1663_fail
    sub $I11, rx1663_pos, rx1663_off
    substr $S10, rx1663_tgt, $I11, 2
    ne $S10, "my", rx1663_fail
    add rx1663_pos, 2
  # rx pass
    rx1663_cur."!cursor_pass"(rx1663_pos, "")
    if_null rx1663_debug, debug_1155
    rx1663_cur."!cursor_debug"("PASS", "", " at pos=", rx1663_pos)
  debug_1155:
    .return (rx1663_cur)
  rx1663_restart:
    if_null rx1663_debug, debug_1156
    rx1663_cur."!cursor_debug"("NEXT", "")
  debug_1156:
  rx1663_fail:
    (rx1663_rep, rx1663_pos, $I10, $P10) = rx1663_cur."!mark_fail"(0)
    lt rx1663_pos, -1, rx1663_done
    eq rx1663_pos, -1, rx1663_fail
    jump $I10
  rx1663_done:
    rx1663_cur."!cursor_fail"()
    if_null rx1663_debug, debug_1157
    rx1663_cur."!cursor_debug"("FAIL", "")
  debug_1157:
    .return (rx1663_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("383_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .local string rx1666_tgt
    .local int rx1666_pos
    .local int rx1666_off
    .local int rx1666_eos
    .local int rx1666_rep
    .local pmc rx1666_cur
    .local pmc rx1666_debug
    (rx1666_cur, rx1666_pos, rx1666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1666_cur
    .local pmc match
    .lex "$/", match
    length rx1666_eos, rx1666_tgt
    gt rx1666_pos, rx1666_eos, rx1666_done
    set rx1666_off, 0
    lt rx1666_pos, 2, rx1666_start
    sub rx1666_off, rx1666_pos, 1
    substr rx1666_tgt, rx1666_tgt, rx1666_off
  rx1666_start:
    eq $I10, 1, rx1666_restart
    if_null rx1666_debug, debug_1161
    rx1666_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1669_done
    goto rxscan1669_scan
  rxscan1669_loop:
    (rx1666_pos) = rx1666_cur."from"()
    inc rx1666_pos
    rx1666_cur."!cursor_from"(rx1666_pos)
    ge rx1666_pos, rx1666_eos, rxscan1669_done
  rxscan1669_scan:
    set_addr $I10, rxscan1669_loop
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  rxscan1669_done:
.annotate 'line', 692
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1666_pos, rx1666_off
    substr $S10, rx1666_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1666_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    $P10 = rx1666_cur."codeblock"()
    unless $P10, rx1666_fail
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1666_pos = $P10."pos"()
.annotate 'line', 691
  # rx pass
    rx1666_cur."!cursor_pass"(rx1666_pos, "metachar:sym<{ }>")
    if_null rx1666_debug, debug_1162
    rx1666_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1666_pos)
  debug_1162:
    .return (rx1666_cur)
  rx1666_restart:
.annotate 'line', 686
    if_null rx1666_debug, debug_1163
    rx1666_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1163:
  rx1666_fail:
    (rx1666_rep, rx1666_pos, $I10, $P10) = rx1666_cur."!mark_fail"(0)
    lt rx1666_pos, -1, rx1666_done
    eq rx1666_pos, -1, rx1666_fail
    jump $I10
  rx1666_done:
    rx1666_cur."!cursor_fail"()
    if_null rx1666_debug, debug_1164
    rx1666_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1164:
    .return (rx1666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("384_1299602538.98") :method
.annotate 'line', 686
    new $P1668, "ResizablePMCArray"
    push $P1668, "{"
    .return ($P1668)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("385_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .const 'Sub' $P1676 = "387_1299602538.98" 
    capture_lex $P1676
    .local string rx1671_tgt
    .local int rx1671_pos
    .local int rx1671_off
    .local int rx1671_eos
    .local int rx1671_rep
    .local pmc rx1671_cur
    .local pmc rx1671_debug
    (rx1671_cur, rx1671_pos, rx1671_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1671_cur
    .local pmc match
    .lex "$/", match
    length rx1671_eos, rx1671_tgt
    gt rx1671_pos, rx1671_eos, rx1671_done
    set rx1671_off, 0
    lt rx1671_pos, 2, rx1671_start
    sub rx1671_off, rx1671_pos, 1
    substr rx1671_tgt, rx1671_tgt, rx1671_off
  rx1671_start:
    eq $I10, 1, rx1671_restart
    if_null rx1671_debug, debug_1165
    rx1671_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1165:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1674_done
    goto rxscan1674_scan
  rxscan1674_loop:
    (rx1671_pos) = rx1671_cur."from"()
    inc rx1671_pos
    rx1671_cur."!cursor_from"(rx1671_pos)
    ge rx1671_pos, rx1671_eos, rxscan1674_done
  rxscan1674_scan:
    set_addr $I10, rxscan1674_loop
    rx1671_cur."!mark_push"(0, rx1671_pos, $I10)
  rxscan1674_done:
.annotate 'line', 696
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1671_pos, rx1671_off
    substr $S10, rx1671_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1671_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1671_cur."!cursor_pos"(rx1671_pos)
    .const 'Sub' $P1676 = "387_1299602538.98" 
    capture_lex $P1676
    $P10 = rx1671_cur."before"($P1676)
    unless $P10, rx1671_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1671_cur."!cursor_pos"(rx1671_pos)
    $P10 = rx1671_cur."LANG"("MAIN", "variable")
    unless $P10, rx1671_fail
    rx1671_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1671_pos = $P10."pos"()
.annotate 'line', 695
  # rx pass
    rx1671_cur."!cursor_pass"(rx1671_pos, "metachar:sym<nqpvar>")
    if_null rx1671_debug, debug_1170
    rx1671_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1671_pos)
  debug_1170:
    .return (rx1671_cur)
  rx1671_restart:
.annotate 'line', 686
    if_null rx1671_debug, debug_1171
    rx1671_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1171:
  rx1671_fail:
    (rx1671_rep, rx1671_pos, $I10, $P10) = rx1671_cur."!mark_fail"(0)
    lt rx1671_pos, -1, rx1671_done
    eq rx1671_pos, -1, rx1671_fail
    jump $I10
  rx1671_done:
    rx1671_cur."!cursor_fail"()
    if_null rx1671_debug, debug_1172
    rx1671_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1172:
    .return (rx1671_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("386_1299602538.98") :method
.annotate 'line', 686
    new $P1673, "ResizablePMCArray"
    push $P1673, "$"
    push $P1673, "@"
    .return ($P1673)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1675"  :anon :subid("387_1299602538.98") :method :outer("385_1299602538.98")
.annotate 'line', 696
    .local string rx1677_tgt
    .local int rx1677_pos
    .local int rx1677_off
    .local int rx1677_eos
    .local int rx1677_rep
    .local pmc rx1677_cur
    .local pmc rx1677_debug
    (rx1677_cur, rx1677_pos, rx1677_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1677_cur
    .local pmc match
    .lex "$/", match
    length rx1677_eos, rx1677_tgt
    gt rx1677_pos, rx1677_eos, rx1677_done
    set rx1677_off, 0
    lt rx1677_pos, 2, rx1677_start
    sub rx1677_off, rx1677_pos, 1
    substr rx1677_tgt, rx1677_tgt, rx1677_off
  rx1677_start:
    eq $I10, 1, rx1677_restart
    if_null rx1677_debug, debug_1166
    rx1677_cur."!cursor_debug"("START", "")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1678_done
    goto rxscan1678_scan
  rxscan1678_loop:
    (rx1677_pos) = rx1677_cur."from"()
    inc rx1677_pos
    rx1677_cur."!cursor_from"(rx1677_pos)
    ge rx1677_pos, rx1677_eos, rxscan1678_done
  rxscan1678_scan:
    set_addr $I10, rxscan1678_loop
    rx1677_cur."!mark_push"(0, rx1677_pos, $I10)
  rxscan1678_done:
  # rx charclass .
    ge rx1677_pos, rx1677_eos, rx1677_fail
    inc rx1677_pos
  # rx charclass w
    ge rx1677_pos, rx1677_eos, rx1677_fail
    sub $I10, rx1677_pos, rx1677_off
    is_cclass $I11, 8192, rx1677_tgt, $I10
    unless $I11, rx1677_fail
    inc rx1677_pos
  # rx pass
    rx1677_cur."!cursor_pass"(rx1677_pos, "")
    if_null rx1677_debug, debug_1167
    rx1677_cur."!cursor_debug"("PASS", "", " at pos=", rx1677_pos)
  debug_1167:
    .return (rx1677_cur)
  rx1677_restart:
    if_null rx1677_debug, debug_1168
    rx1677_cur."!cursor_debug"("NEXT", "")
  debug_1168:
  rx1677_fail:
    (rx1677_rep, rx1677_pos, $I10, $P10) = rx1677_cur."!mark_fail"(0)
    lt rx1677_pos, -1, rx1677_done
    eq rx1677_pos, -1, rx1677_fail
    jump $I10
  rx1677_done:
    rx1677_cur."!cursor_fail"()
    if_null rx1677_debug, debug_1169
    rx1677_cur."!cursor_debug"("FAIL", "")
  debug_1169:
    .return (rx1677_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("388_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .local string rx1680_tgt
    .local int rx1680_pos
    .local int rx1680_off
    .local int rx1680_eos
    .local int rx1680_rep
    .local pmc rx1680_cur
    .local pmc rx1680_debug
    (rx1680_cur, rx1680_pos, rx1680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1680_cur
    .local pmc match
    .lex "$/", match
    length rx1680_eos, rx1680_tgt
    gt rx1680_pos, rx1680_eos, rx1680_done
    set rx1680_off, 0
    lt rx1680_pos, 2, rx1680_start
    sub rx1680_off, rx1680_pos, 1
    substr rx1680_tgt, rx1680_tgt, rx1680_off
  rx1680_start:
    eq $I10, 1, rx1680_restart
    if_null rx1680_debug, debug_1173
    rx1680_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1173:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1683_done
    goto rxscan1683_scan
  rxscan1683_loop:
    (rx1680_pos) = rx1680_cur."from"()
    inc rx1680_pos
    rx1680_cur."!cursor_from"(rx1680_pos)
    ge rx1680_pos, rx1680_eos, rxscan1683_done
  rxscan1683_scan:
    set_addr $I10, rxscan1683_loop
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  rxscan1683_done:
.annotate 'line', 700
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1680_pos, rx1680_off
    substr $S10, rx1680_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1680_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    $P10 = rx1680_cur."codeblock"()
    unless $P10, rx1680_fail
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1680_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1680_cur."!cursor_pass"(rx1680_pos, "assertion:sym<{ }>")
    if_null rx1680_debug, debug_1174
    rx1680_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1680_pos)
  debug_1174:
    .return (rx1680_cur)
  rx1680_restart:
.annotate 'line', 686
    if_null rx1680_debug, debug_1175
    rx1680_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1175:
  rx1680_fail:
    (rx1680_rep, rx1680_pos, $I10, $P10) = rx1680_cur."!mark_fail"(0)
    lt rx1680_pos, -1, rx1680_done
    eq rx1680_pos, -1, rx1680_fail
    jump $I10
  rx1680_done:
    rx1680_cur."!cursor_fail"()
    if_null rx1680_debug, debug_1176
    rx1680_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1176:
    .return (rx1680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("389_1299602538.98") :method
.annotate 'line', 686
    new $P1682, "ResizablePMCArray"
    push $P1682, "{"
    .return ($P1682)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("390_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .const 'Sub' $P1690 = "392_1299602538.98" 
    capture_lex $P1690
    .local string rx1685_tgt
    .local int rx1685_pos
    .local int rx1685_off
    .local int rx1685_eos
    .local int rx1685_rep
    .local pmc rx1685_cur
    .local pmc rx1685_debug
    (rx1685_cur, rx1685_pos, rx1685_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1685_cur
    .local pmc match
    .lex "$/", match
    length rx1685_eos, rx1685_tgt
    gt rx1685_pos, rx1685_eos, rx1685_done
    set rx1685_off, 0
    lt rx1685_pos, 2, rx1685_start
    sub rx1685_off, rx1685_pos, 1
    substr rx1685_tgt, rx1685_tgt, rx1685_off
  rx1685_start:
    eq $I10, 1, rx1685_restart
    if_null rx1685_debug, debug_1177
    rx1685_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1177:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1688_done
    goto rxscan1688_scan
  rxscan1688_loop:
    (rx1685_pos) = rx1685_cur."from"()
    inc rx1685_pos
    rx1685_cur."!cursor_from"(rx1685_pos)
    ge rx1685_pos, rx1685_eos, rxscan1688_done
  rxscan1688_scan:
    set_addr $I10, rxscan1688_loop
    rx1685_cur."!mark_push"(0, rx1685_pos, $I10)
  rxscan1688_done:
.annotate 'line', 704
  # rx subcapture "zw"
    set_addr $I10, rxcap_1693_fail
    rx1685_cur."!mark_push"(0, rx1685_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1685_pos, rx1685_eos, rx1685_fail
    sub $I10, rx1685_pos, rx1685_off
    substr $S10, rx1685_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1685_fail
    inc rx1685_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1685_cur."!cursor_pos"(rx1685_pos)
    .const 'Sub' $P1690 = "392_1299602538.98" 
    capture_lex $P1690
    $P10 = rx1685_cur."before"($P1690)
    unless $P10, rx1685_fail
    set_addr $I10, rxcap_1693_fail
    ($I12, $I11) = rx1685_cur."!mark_peek"($I10)
    rx1685_cur."!cursor_pos"($I11)
    ($P10) = rx1685_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1685_pos, "")
    rx1685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1693_done
  rxcap_1693_fail:
    goto rx1685_fail
  rxcap_1693_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1685_cur."!cursor_pos"(rx1685_pos)
    $P10 = rx1685_cur."codeblock"()
    unless $P10, rx1685_fail
    rx1685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1685_pos = $P10."pos"()
.annotate 'line', 703
  # rx pass
    rx1685_cur."!cursor_pass"(rx1685_pos, "assertion:sym<?{ }>")
    if_null rx1685_debug, debug_1182
    rx1685_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1685_pos)
  debug_1182:
    .return (rx1685_cur)
  rx1685_restart:
.annotate 'line', 686
    if_null rx1685_debug, debug_1183
    rx1685_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1183:
  rx1685_fail:
    (rx1685_rep, rx1685_pos, $I10, $P10) = rx1685_cur."!mark_fail"(0)
    lt rx1685_pos, -1, rx1685_done
    eq rx1685_pos, -1, rx1685_fail
    jump $I10
  rx1685_done:
    rx1685_cur."!cursor_fail"()
    if_null rx1685_debug, debug_1184
    rx1685_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1184:
    .return (rx1685_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("391_1299602538.98") :method
.annotate 'line', 686
    new $P1687, "ResizablePMCArray"
    push $P1687, "!"
    push $P1687, "?"
    .return ($P1687)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1689"  :anon :subid("392_1299602538.98") :method :outer("390_1299602538.98")
.annotate 'line', 704
    .local string rx1691_tgt
    .local int rx1691_pos
    .local int rx1691_off
    .local int rx1691_eos
    .local int rx1691_rep
    .local pmc rx1691_cur
    .local pmc rx1691_debug
    (rx1691_cur, rx1691_pos, rx1691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1691_cur
    .local pmc match
    .lex "$/", match
    length rx1691_eos, rx1691_tgt
    gt rx1691_pos, rx1691_eos, rx1691_done
    set rx1691_off, 0
    lt rx1691_pos, 2, rx1691_start
    sub rx1691_off, rx1691_pos, 1
    substr rx1691_tgt, rx1691_tgt, rx1691_off
  rx1691_start:
    eq $I10, 1, rx1691_restart
    if_null rx1691_debug, debug_1178
    rx1691_cur."!cursor_debug"("START", "")
  debug_1178:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1692_done
    goto rxscan1692_scan
  rxscan1692_loop:
    (rx1691_pos) = rx1691_cur."from"()
    inc rx1691_pos
    rx1691_cur."!cursor_from"(rx1691_pos)
    ge rx1691_pos, rx1691_eos, rxscan1692_done
  rxscan1692_scan:
    set_addr $I10, rxscan1692_loop
    rx1691_cur."!mark_push"(0, rx1691_pos, $I10)
  rxscan1692_done:
  # rx literal  "{"
    add $I11, rx1691_pos, 1
    gt $I11, rx1691_eos, rx1691_fail
    sub $I11, rx1691_pos, rx1691_off
    ord $I11, rx1691_tgt, $I11
    ne $I11, 123, rx1691_fail
    add rx1691_pos, 1
  # rx pass
    rx1691_cur."!cursor_pass"(rx1691_pos, "")
    if_null rx1691_debug, debug_1179
    rx1691_cur."!cursor_debug"("PASS", "", " at pos=", rx1691_pos)
  debug_1179:
    .return (rx1691_cur)
  rx1691_restart:
    if_null rx1691_debug, debug_1180
    rx1691_cur."!cursor_debug"("NEXT", "")
  debug_1180:
  rx1691_fail:
    (rx1691_rep, rx1691_pos, $I10, $P10) = rx1691_cur."!mark_fail"(0)
    lt rx1691_pos, -1, rx1691_done
    eq rx1691_pos, -1, rx1691_fail
    jump $I10
  rx1691_done:
    rx1691_cur."!cursor_fail"()
    if_null rx1691_debug, debug_1181
    rx1691_cur."!cursor_debug"("FAIL", "")
  debug_1181:
    .return (rx1691_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("393_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .const 'Sub' $P1703 = "395_1299602538.98" 
    capture_lex $P1703
    .local string rx1695_tgt
    .local int rx1695_pos
    .local int rx1695_off
    .local int rx1695_eos
    .local int rx1695_rep
    .local pmc rx1695_cur
    .local pmc rx1695_debug
    (rx1695_cur, rx1695_pos, rx1695_tgt, $I10) = self."!cursor_start"()
    rx1695_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1695_cur
    .local pmc match
    .lex "$/", match
    length rx1695_eos, rx1695_tgt
    gt rx1695_pos, rx1695_eos, rx1695_done
    set rx1695_off, 0
    lt rx1695_pos, 2, rx1695_start
    sub rx1695_off, rx1695_pos, 1
    substr rx1695_tgt, rx1695_tgt, rx1695_off
  rx1695_start:
    eq $I10, 1, rx1695_restart
    if_null rx1695_debug, debug_1185
    rx1695_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1185:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1699_done
    goto rxscan1699_scan
  rxscan1699_loop:
    (rx1695_pos) = rx1695_cur."from"()
    inc rx1695_pos
    rx1695_cur."!cursor_from"(rx1695_pos)
    ge rx1695_pos, rx1695_eos, rxscan1699_done
  rxscan1699_scan:
    set_addr $I10, rxscan1699_loop
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
  rxscan1699_done:
.annotate 'line', 708
  # rx subrule "identifier" subtype=capture negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."identifier"()
    unless $P10, rx1695_fail
    rx1695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1695_pos = $P10."pos"()
.annotate 'line', 715
  # rx rxquantr1700 ** 0..1
    set_addr $I10, rxquantr1700_done
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
  rxquantr1700_loop:
  alt1701_0:
.annotate 'line', 709
    set_addr $I10, alt1701_1
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
.annotate 'line', 710
  # rx subrule "before" subtype=zerowidth negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    .const 'Sub' $P1703 = "395_1299602538.98" 
    capture_lex $P1703
    $P10 = rx1695_cur."before"($P1703)
    unless $P10, rx1695_fail
    goto alt1701_end
  alt1701_1:
    set_addr $I10, alt1701_2
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
.annotate 'line', 711
  # rx literal  "="
    add $I11, rx1695_pos, 1
    gt $I11, rx1695_eos, rx1695_fail
    sub $I11, rx1695_pos, rx1695_off
    ord $I11, rx1695_tgt, $I11
    ne $I11, 61, rx1695_fail
    add rx1695_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."assertion"()
    unless $P10, rx1695_fail
    rx1695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1695_pos = $P10."pos"()
    goto alt1701_end
  alt1701_2:
    set_addr $I10, alt1701_3
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
.annotate 'line', 712
  # rx literal  ":"
    add $I11, rx1695_pos, 1
    gt $I11, rx1695_eos, rx1695_fail
    sub $I11, rx1695_pos, rx1695_off
    ord $I11, rx1695_tgt, $I11
    ne $I11, 58, rx1695_fail
    add rx1695_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."arglist"()
    unless $P10, rx1695_fail
    rx1695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1695_pos = $P10."pos"()
    goto alt1701_end
  alt1701_3:
    set_addr $I10, alt1701_4
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
.annotate 'line', 713
  # rx literal  "("
    add $I11, rx1695_pos, 1
    gt $I11, rx1695_eos, rx1695_fail
    sub $I11, rx1695_pos, rx1695_off
    ord $I11, rx1695_tgt, $I11
    ne $I11, 40, rx1695_fail
    add rx1695_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1695_fail
    rx1695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1695_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1695_pos, 1
    gt $I11, rx1695_eos, rx1695_fail
    sub $I11, rx1695_pos, rx1695_off
    ord $I11, rx1695_tgt, $I11
    ne $I11, 41, rx1695_fail
    add rx1695_pos, 1
    goto alt1701_end
  alt1701_4:
.annotate 'line', 714
  # rx subrule "normspace" subtype=method negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."normspace"()
    unless $P10, rx1695_fail
    rx1695_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."nibbler"()
    unless $P10, rx1695_fail
    rx1695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1695_pos = $P10."pos"()
  alt1701_end:
.annotate 'line', 715
    set_addr $I10, rxquantr1700_done
    (rx1695_rep) = rx1695_cur."!mark_commit"($I10)
  rxquantr1700_done:
.annotate 'line', 707
  # rx pass
    rx1695_cur."!cursor_pass"(rx1695_pos, "assertion:sym<name>")
    if_null rx1695_debug, debug_1190
    rx1695_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1695_pos)
  debug_1190:
    .return (rx1695_cur)
  rx1695_restart:
.annotate 'line', 686
    if_null rx1695_debug, debug_1191
    rx1695_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1191:
  rx1695_fail:
    (rx1695_rep, rx1695_pos, $I10, $P10) = rx1695_cur."!mark_fail"(0)
    lt rx1695_pos, -1, rx1695_done
    eq rx1695_pos, -1, rx1695_fail
    jump $I10
  rx1695_done:
    rx1695_cur."!cursor_fail"()
    if_null rx1695_debug, debug_1192
    rx1695_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1192:
    .return (rx1695_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("394_1299602538.98") :method
.annotate 'line', 686
    $P1697 = self."!PREFIX__!subrule"("identifier", "")
    new $P1698, "ResizablePMCArray"
    push $P1698, $P1697
    .return ($P1698)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1702"  :anon :subid("395_1299602538.98") :method :outer("393_1299602538.98")
.annotate 'line', 710
    .local string rx1704_tgt
    .local int rx1704_pos
    .local int rx1704_off
    .local int rx1704_eos
    .local int rx1704_rep
    .local pmc rx1704_cur
    .local pmc rx1704_debug
    (rx1704_cur, rx1704_pos, rx1704_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1704_cur
    .local pmc match
    .lex "$/", match
    length rx1704_eos, rx1704_tgt
    gt rx1704_pos, rx1704_eos, rx1704_done
    set rx1704_off, 0
    lt rx1704_pos, 2, rx1704_start
    sub rx1704_off, rx1704_pos, 1
    substr rx1704_tgt, rx1704_tgt, rx1704_off
  rx1704_start:
    eq $I10, 1, rx1704_restart
    if_null rx1704_debug, debug_1186
    rx1704_cur."!cursor_debug"("START", "")
  debug_1186:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1705_done
    goto rxscan1705_scan
  rxscan1705_loop:
    (rx1704_pos) = rx1704_cur."from"()
    inc rx1704_pos
    rx1704_cur."!cursor_from"(rx1704_pos)
    ge rx1704_pos, rx1704_eos, rxscan1705_done
  rxscan1705_scan:
    set_addr $I10, rxscan1705_loop
    rx1704_cur."!mark_push"(0, rx1704_pos, $I10)
  rxscan1705_done:
  # rx literal  ">"
    add $I11, rx1704_pos, 1
    gt $I11, rx1704_eos, rx1704_fail
    sub $I11, rx1704_pos, rx1704_off
    ord $I11, rx1704_tgt, $I11
    ne $I11, 62, rx1704_fail
    add rx1704_pos, 1
  # rx pass
    rx1704_cur."!cursor_pass"(rx1704_pos, "")
    if_null rx1704_debug, debug_1187
    rx1704_cur."!cursor_debug"("PASS", "", " at pos=", rx1704_pos)
  debug_1187:
    .return (rx1704_cur)
  rx1704_restart:
    if_null rx1704_debug, debug_1188
    rx1704_cur."!cursor_debug"("NEXT", "")
  debug_1188:
  rx1704_fail:
    (rx1704_rep, rx1704_pos, $I10, $P10) = rx1704_cur."!mark_fail"(0)
    lt rx1704_pos, -1, rx1704_done
    eq rx1704_pos, -1, rx1704_fail
    jump $I10
  rx1704_done:
    rx1704_cur."!cursor_fail"()
    if_null rx1704_debug, debug_1189
    rx1704_cur."!cursor_debug"("FAIL", "")
  debug_1189:
    .return (rx1704_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("396_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .local string rx1707_tgt
    .local int rx1707_pos
    .local int rx1707_off
    .local int rx1707_eos
    .local int rx1707_rep
    .local pmc rx1707_cur
    .local pmc rx1707_debug
    (rx1707_cur, rx1707_pos, rx1707_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1707_cur
    .local pmc match
    .lex "$/", match
    length rx1707_eos, rx1707_tgt
    gt rx1707_pos, rx1707_eos, rx1707_done
    set rx1707_off, 0
    lt rx1707_pos, 2, rx1707_start
    sub rx1707_off, rx1707_pos, 1
    substr rx1707_tgt, rx1707_tgt, rx1707_off
  rx1707_start:
    eq $I10, 1, rx1707_restart
    if_null rx1707_debug, debug_1193
    rx1707_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1193:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1710_done
    goto rxscan1710_scan
  rxscan1710_loop:
    (rx1707_pos) = rx1707_cur."from"()
    inc rx1707_pos
    rx1707_cur."!cursor_from"(rx1707_pos)
    ge rx1707_pos, rx1707_eos, rxscan1710_done
  rxscan1710_scan:
    set_addr $I10, rxscan1710_loop
    rx1707_cur."!mark_push"(0, rx1707_pos, $I10)
  rxscan1710_done:
.annotate 'line', 719
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1707_pos, rx1707_off
    substr $S10, rx1707_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1707_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1707_cur."!cursor_pos"(rx1707_pos)
    $P10 = rx1707_cur."LANG"("MAIN", "variable")
    unless $P10, rx1707_fail
    rx1707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1707_pos = $P10."pos"()
.annotate 'line', 718
  # rx pass
    rx1707_cur."!cursor_pass"(rx1707_pos, "assertion:sym<var>")
    if_null rx1707_debug, debug_1194
    rx1707_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1707_pos)
  debug_1194:
    .return (rx1707_cur)
  rx1707_restart:
.annotate 'line', 686
    if_null rx1707_debug, debug_1195
    rx1707_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1195:
  rx1707_fail:
    (rx1707_rep, rx1707_pos, $I10, $P10) = rx1707_cur."!mark_fail"(0)
    lt rx1707_pos, -1, rx1707_done
    eq rx1707_pos, -1, rx1707_fail
    jump $I10
  rx1707_done:
    rx1707_cur."!cursor_fail"()
    if_null rx1707_debug, debug_1196
    rx1707_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1196:
    .return (rx1707_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("397_1299602538.98") :method
.annotate 'line', 686
    new $P1709, "ResizablePMCArray"
    push $P1709, "$"
    push $P1709, "@"
    .return ($P1709)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("398_1299602538.98") :method :outer("379_1299602538.98")
.annotate 'line', 686
    .local string rx1712_tgt
    .local int rx1712_pos
    .local int rx1712_off
    .local int rx1712_eos
    .local int rx1712_rep
    .local pmc rx1712_cur
    .local pmc rx1712_debug
    (rx1712_cur, rx1712_pos, rx1712_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1712_cur
    .local pmc match
    .lex "$/", match
    length rx1712_eos, rx1712_tgt
    gt rx1712_pos, rx1712_eos, rx1712_done
    set rx1712_off, 0
    lt rx1712_pos, 2, rx1712_start
    sub rx1712_off, rx1712_pos, 1
    substr rx1712_tgt, rx1712_tgt, rx1712_off
  rx1712_start:
    eq $I10, 1, rx1712_restart
    if_null rx1712_debug, debug_1197
    rx1712_cur."!cursor_debug"("START", "codeblock")
  debug_1197:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1716_done
    goto rxscan1716_scan
  rxscan1716_loop:
    (rx1712_pos) = rx1712_cur."from"()
    inc rx1712_pos
    rx1712_cur."!cursor_from"(rx1712_pos)
    ge rx1712_pos, rx1712_eos, rxscan1716_done
  rxscan1716_scan:
    set_addr $I10, rxscan1716_loop
    rx1712_cur."!mark_push"(0, rx1712_pos, $I10)
  rxscan1716_done:
.annotate 'line', 723
  # rx subrule "LANG" subtype=capture negate=
    rx1712_cur."!cursor_pos"(rx1712_pos)
    $P10 = rx1712_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1712_fail
    rx1712_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1712_pos = $P10."pos"()
.annotate 'line', 722
  # rx pass
    rx1712_cur."!cursor_pass"(rx1712_pos, "codeblock")
    if_null rx1712_debug, debug_1198
    rx1712_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1712_pos)
  debug_1198:
    .return (rx1712_cur)
  rx1712_restart:
.annotate 'line', 686
    if_null rx1712_debug, debug_1199
    rx1712_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1199:
  rx1712_fail:
    (rx1712_rep, rx1712_pos, $I10, $P10) = rx1712_cur."!mark_fail"(0)
    lt rx1712_pos, -1, rx1712_done
    eq rx1712_pos, -1, rx1712_fail
    jump $I10
  rx1712_done:
    rx1712_cur."!cursor_fail"()
    if_null rx1712_debug, debug_1200
    rx1712_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1200:
    .return (rx1712_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("399_1299602538.98") :method
.annotate 'line', 686
    $P1714 = self."!PREFIX__!subrule"("LANG", "")
    new $P1715, "ResizablePMCArray"
    push $P1715, $P1714
    .return ($P1715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1757" :load :anon :subid("401_1299602538.98")
.annotate 'line', 4
    .const 'Sub' $P1759 = "11_1299602538.98" 
    $P1760 = $P1759()
    .return ($P1760)
.end


.HLL "nqp"

.namespace []
.sub "_block2487" :load :anon :subid("403_1299602538.98")
.annotate 'line', 1
    .const 'Sub' $P2489 = "10_1299602538.98" 
    $P2490 = $P2489()
    .return ($P2490)
.end

### .include 'gen/nqp-actions.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299602554.641")
.annotate 'line', 0
    get_hll_global $P18, ["NQP";"Actions"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    get_hll_global $P16, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P18, ["NQP";"Actions"], "_block17" 
    capture_lex $P18
    $P3274 = $P18()
.annotate 'line', 1
    .return ($P3274)
    .const 'Sub' $P3276 = "170_1299602554.641" 
    .return ($P3276)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post171") :outer("10_1299602554.641")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1299602554.641" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P3280, "1299602543.315"
    isnull $I3281, $P3280
    if $I3281, if_3279
    goto if_3279_end
  if_3279:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P3282, "1299602543.315"
    .local pmc cur_sc
    set cur_sc, $P3282
    load_bytecode "SettingManager.pbc"
    get_hll_global $P3283, ["HLL"], "SettingManager"
    $P3284 = $P3283."load_setting"("NQPCORE")
    block."set_outer_ctx"($P3284)
    get_hll_global $P3285, "NQPClassHOW"
    $P3286 = $P3285."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P3286, cur_sc
    nqp_set_sc_object "1299602543.315", 0, $P3286
    get_hll_global $P3287, "NQPClassHOW"
    $P3288 = $P3287."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P3288, cur_sc
    nqp_set_sc_object "1299602543.315", 1, $P3288
  if_3279_end:
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block17"  :subid("11_1299602554.641") :outer("10_1299602554.641")
.annotate 'line', 3
    .const 'Sub' $P3054 = "169_1299602554.641" 
    capture_lex $P3054
    get_hll_global $P2919, ["NQP";"RegexActions"], "_block2918" 
    capture_lex $P2919
    .const 'Sub' $P2910 = "158_1299602554.641" 
    capture_lex $P2910
    .const 'Sub' $P2905 = "157_1299602554.641" 
    capture_lex $P2905
    .const 'Sub' $P2900 = "156_1299602554.641" 
    capture_lex $P2900
    .const 'Sub' $P2895 = "155_1299602554.641" 
    capture_lex $P2895
    .const 'Sub' $P2884 = "154_1299602554.641" 
    capture_lex $P2884
    .const 'Sub' $P2876 = "153_1299602554.641" 
    capture_lex $P2876
    .const 'Sub' $P2868 = "152_1299602554.641" 
    capture_lex $P2868
    .const 'Sub' $P2860 = "151_1299602554.641" 
    capture_lex $P2860
    .const 'Sub' $P2855 = "150_1299602554.641" 
    capture_lex $P2855
    .const 'Sub' $P2843 = "149_1299602554.641" 
    capture_lex $P2843
    .const 'Sub' $P2835 = "148_1299602554.641" 
    capture_lex $P2835
    .const 'Sub' $P2797 = "147_1299602554.641" 
    capture_lex $P2797
    .const 'Sub' $P2785 = "146_1299602554.641" 
    capture_lex $P2785
    .const 'Sub' $P2777 = "145_1299602554.641" 
    capture_lex $P2777
    .const 'Sub' $P2769 = "144_1299602554.641" 
    capture_lex $P2769
    .const 'Sub' $P2761 = "143_1299602554.641" 
    capture_lex $P2761
    .const 'Sub' $P2753 = "142_1299602554.641" 
    capture_lex $P2753
    .const 'Sub' $P2745 = "141_1299602554.641" 
    capture_lex $P2745
    .const 'Sub' $P2719 = "140_1299602554.641" 
    capture_lex $P2719
    .const 'Sub' $P2704 = "139_1299602554.641" 
    capture_lex $P2704
    .const 'Sub' $P2696 = "138_1299602554.641" 
    capture_lex $P2696
    .const 'Sub' $P2685 = "137_1299602554.641" 
    capture_lex $P2685
    .const 'Sub' $P2674 = "136_1299602554.641" 
    capture_lex $P2674
    .const 'Sub' $P2663 = "135_1299602554.641" 
    capture_lex $P2663
    .const 'Sub' $P2655 = "134_1299602554.641" 
    capture_lex $P2655
    .const 'Sub' $P2628 = "133_1299602554.641" 
    capture_lex $P2628
    .const 'Sub' $P2590 = "131_1299602554.641" 
    capture_lex $P2590
    .const 'Sub' $P2582 = "130_1299602554.641" 
    capture_lex $P2582
    .const 'Sub' $P2574 = "129_1299602554.641" 
    capture_lex $P2574
    .const 'Sub' $P2549 = "128_1299602554.641" 
    capture_lex $P2549
    .const 'Sub' $P2533 = "127_1299602554.641" 
    capture_lex $P2533
    .const 'Sub' $P2525 = "126_1299602554.641" 
    capture_lex $P2525
    .const 'Sub' $P2517 = "125_1299602554.641" 
    capture_lex $P2517
    .const 'Sub' $P2415 = "122_1299602554.641" 
    capture_lex $P2415
    .const 'Sub' $P2407 = "121_1299602554.641" 
    capture_lex $P2407
    .const 'Sub' $P2400 = "120_1299602554.641" 
    capture_lex $P2400
    .const 'Sub' $P2373 = "119_1299602554.641" 
    capture_lex $P2373
    .const 'Sub' $P2333 = "118_1299602554.641" 
    capture_lex $P2333
    .const 'Sub' $P2319 = "117_1299602554.641" 
    capture_lex $P2319
    .const 'Sub' $P2312 = "116_1299602554.641" 
    capture_lex $P2312
    .const 'Sub' $P2268 = "115_1299602554.641" 
    capture_lex $P2268
    .const 'Sub' $P2103 = "111_1299602554.641" 
    capture_lex $P2103
    .const 'Sub' $P2040 = "109_1299602554.641" 
    capture_lex $P2040
    .const 'Sub' $P2032 = "108_1299602554.641" 
    capture_lex $P2032
    .const 'Sub' $P2017 = "107_1299602554.641" 
    capture_lex $P2017
    .const 'Sub' $P2002 = "106_1299602554.641" 
    capture_lex $P2002
    .const 'Sub' $P1984 = "105_1299602554.641" 
    capture_lex $P1984
    .const 'Sub' $P1885 = "104_1299602554.641" 
    capture_lex $P1885
    .const 'Sub' $P1841 = "101_1299602554.641" 
    capture_lex $P1841
    .const 'Sub' $P1716 = "98_1299602554.641" 
    capture_lex $P1716
    .const 'Sub' $P1474 = "91_1299602554.641" 
    capture_lex $P1474
    .const 'Sub' $P1466 = "90_1299602554.641" 
    capture_lex $P1466
    .const 'Sub' $P1458 = "89_1299602554.641" 
    capture_lex $P1458
    .const 'Sub' $P1357 = "85_1299602554.641" 
    capture_lex $P1357
    .const 'Sub' $P1349 = "84_1299602554.641" 
    capture_lex $P1349
    .const 'Sub' $P1334 = "83_1299602554.641" 
    capture_lex $P1334
    .const 'Sub' $P1319 = "82_1299602554.641" 
    capture_lex $P1319
    .const 'Sub' $P1304 = "81_1299602554.641" 
    capture_lex $P1304
    .const 'Sub' $P1289 = "80_1299602554.641" 
    capture_lex $P1289
    .const 'Sub' $P1281 = "79_1299602554.641" 
    capture_lex $P1281
    .const 'Sub' $P1273 = "78_1299602554.641" 
    capture_lex $P1273
    .const 'Sub' $P1265 = "77_1299602554.641" 
    capture_lex $P1265
    .const 'Sub' $P1071 = "74_1299602554.641" 
    capture_lex $P1071
    .const 'Sub' $P1063 = "73_1299602554.641" 
    capture_lex $P1063
    .const 'Sub' $P1055 = "72_1299602554.641" 
    capture_lex $P1055
    .const 'Sub' $P1047 = "71_1299602554.641" 
    capture_lex $P1047
    .const 'Sub' $P1039 = "70_1299602554.641" 
    capture_lex $P1039
    .const 'Sub' $P1031 = "69_1299602554.641" 
    capture_lex $P1031
    .const 'Sub' $P1023 = "68_1299602554.641" 
    capture_lex $P1023
    .const 'Sub' $P933 = "66_1299602554.641" 
    capture_lex $P933
    .const 'Sub' $P909 = "65_1299602554.641" 
    capture_lex $P909
    .const 'Sub' $P895 = "64_1299602554.641" 
    capture_lex $P895
    .const 'Sub' $P887 = "63_1299602554.641" 
    capture_lex $P887
    .const 'Sub' $P879 = "62_1299602554.641" 
    capture_lex $P879
    .const 'Sub' $P871 = "61_1299602554.641" 
    capture_lex $P871
    .const 'Sub' $P863 = "60_1299602554.641" 
    capture_lex $P863
    .const 'Sub' $P855 = "59_1299602554.641" 
    capture_lex $P855
    .const 'Sub' $P847 = "58_1299602554.641" 
    capture_lex $P847
    .const 'Sub' $P839 = "57_1299602554.641" 
    capture_lex $P839
    .const 'Sub' $P831 = "56_1299602554.641" 
    capture_lex $P831
    .const 'Sub' $P823 = "55_1299602554.641" 
    capture_lex $P823
    .const 'Sub' $P815 = "54_1299602554.641" 
    capture_lex $P815
    .const 'Sub' $P807 = "53_1299602554.641" 
    capture_lex $P807
    .const 'Sub' $P799 = "52_1299602554.641" 
    capture_lex $P799
    .const 'Sub' $P791 = "51_1299602554.641" 
    capture_lex $P791
    .const 'Sub' $P775 = "50_1299602554.641" 
    capture_lex $P775
    .const 'Sub' $P742 = "49_1299602554.641" 
    capture_lex $P742
    .const 'Sub' $P728 = "48_1299602554.641" 
    capture_lex $P728
    .const 'Sub' $P709 = "47_1299602554.641" 
    capture_lex $P709
    .const 'Sub' $P691 = "46_1299602554.641" 
    capture_lex $P691
    .const 'Sub' $P667 = "45_1299602554.641" 
    capture_lex $P667
    .const 'Sub' $P633 = "44_1299602554.641" 
    capture_lex $P633
    .const 'Sub' $P618 = "43_1299602554.641" 
    capture_lex $P618
    .const 'Sub' $P606 = "42_1299602554.641" 
    capture_lex $P606
    .const 'Sub' $P555 = "40_1299602554.641" 
    capture_lex $P555
    .const 'Sub' $P548 = "39_1299602554.641" 
    capture_lex $P548
    .const 'Sub' $P526 = "38_1299602554.641" 
    capture_lex $P526
    .const 'Sub' $P515 = "37_1299602554.641" 
    capture_lex $P515
    .const 'Sub' $P480 = "35_1299602554.641" 
    capture_lex $P480
    .const 'Sub' $P472 = "34_1299602554.641" 
    capture_lex $P472
    .const 'Sub' $P464 = "33_1299602554.641" 
    capture_lex $P464
    .const 'Sub' $P450 = "32_1299602554.641" 
    capture_lex $P450
    .const 'Sub' $P369 = "30_1299602554.641" 
    capture_lex $P369
    .const 'Sub' $P328 = "28_1299602554.641" 
    capture_lex $P328
    .const 'Sub' $P281 = "27_1299602554.641" 
    capture_lex $P281
    .const 'Sub' $P250 = "26_1299602554.641" 
    capture_lex $P250
    .const 'Sub' $P242 = "25_1299602554.641" 
    capture_lex $P242
    .const 'Sub' $P234 = "23_1299602554.641" 
    capture_lex $P234
    .const 'Sub' $P220 = "22_1299602554.641" 
    capture_lex $P220
    .const 'Sub' $P155 = "20_1299602554.641" 
    capture_lex $P155
    .const 'Sub' $P145 = "19_1299602554.641" 
    capture_lex $P145
    .const 'Sub' $P97 = "18_1299602554.641" 
    capture_lex $P97
    .const 'Sub' $P84 = "17_1299602554.641" 
    capture_lex $P84
    .const 'Sub' $P66 = "16_1299602554.641" 
    capture_lex $P66
    .const 'Sub' $P33 = "13_1299602554.641" 
    capture_lex $P33
    .const 'Sub' $P25 = "12_1299602554.641" 
    capture_lex $P25
    get_global $P19, "$?CLASS"
    getinterp $P20
    get_class $P21, "LexPad"
    get_class $P22, "NQPLexPad"
    $P20."hll_map"($P21, $P22)
    get_hll_global $P23, ["NQP"], "RegexActions"
    get_global $P24, "@BLOCK"
    unless_null $P24, vivify_173
    $P24 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P24
  vivify_173:
.annotate 'line', 9
    .const 'Sub' $P25 = "12_1299602554.641" 
    newclosure $P32, $P25
    .lex "xblock_immediate", $P32
.annotate 'line', 14
    .const 'Sub' $P33 = "13_1299602554.641" 
    newclosure $P65, $P33
    .lex "block_immediate", $P65
.annotate 'line', 24
    .const 'Sub' $P66 = "16_1299602554.641" 
    newclosure $P83, $P66
    .lex "vivitype", $P83
.annotate 'line', 43
    .const 'Sub' $P84 = "17_1299602554.641" 
    newclosure $P96, $P84
    .lex "colonpair_str", $P96
.annotate 'line', 257
    .const 'Sub' $P97 = "18_1299602554.641" 
    newclosure $P144, $P97
    .lex "push_block_handler", $P144
.annotate 'line', 794
    .const 'Sub' $P145 = "19_1299602554.641" 
    newclosure $P154, $P145
    .lex "only_star_block", $P154
.annotate 'line', 803
    .const 'Sub' $P155 = "20_1299602554.641" 
    newclosure $P219, $P155
    .lex "attach_multi_signature", $P219
.annotate 'line', 1279
    .const 'Sub' $P220 = "22_1299602554.641" 
    newclosure $P231, $P220
    .lex "control", $P231
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P232, "@BLOCK"
    .const 'Sub' $P234 = "23_1299602554.641" 
    capture_lex $P234
    $P234()
    find_lex $P239, "xblock_immediate"
    find_lex $P240, "block_immediate"
    find_lex $P241, "vivitype"
.annotate 'line', 35
    find_lex $P280, "colonpair_str"
.annotate 'line', 250
    find_lex $P727, "push_block_handler"
.annotate 'line', 722
    find_lex $P1839, "only_star_block"
    find_lex $P1840, "attach_multi_signature"
.annotate 'line', 1270
    find_lex $P2894, "control"
.annotate 'line', 1297
    get_hll_global $P2919, ["NQP";"RegexActions"], "_block2918" 
    capture_lex $P2919
    $P3038 = $P2919()
.annotate 'line', 3
    .return ($P3038)
    .const 'Sub' $P3040 = "168_1299602554.641" 
    .return ($P3040)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post172") :outer("11_1299602554.641")
.annotate 'line', 3
    get_hll_global $P18, ["NQP";"Actions"], "_block17" 
    .local pmc block
    set block, $P18
    nqp_get_sc $P3044, "1299602543.315"
    isnull $I3045, $P3044
    if $I3045, if_3043
    goto if_3043_end
  if_3043:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P3046, "1299602543.315"
    .local pmc cur_sc
    set cur_sc, $P3046
    load_bytecode "SettingManager.pbc"
    get_hll_global $P3047, ["HLL"], "SettingManager"
    $P3048 = $P3047."load_setting"("NQPCORE")
    block."set_outer_ctx"($P3048)
    get_hll_global $P3049, "NQPClassHOW"
    $P3050 = $P3049."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P3050, cur_sc
    nqp_set_sc_object "1299602543.315", 0, $P3050
    get_hll_global $P3051, "NQPClassHOW"
    $P3052 = $P3051."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P3052, cur_sc
    nqp_set_sc_object "1299602543.315", 1, $P3052
  if_3043_end:
    .const 'Sub' $P3054 = "169_1299602554.641" 
    capture_lex $P3054
    $P3054()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3053"  :anon :subid("169_1299602554.641") :outer("11_1299602554.641")
.annotate 'line', 3
    nqp_get_sc_object $P3055, "1299602543.315", 0
    .local pmc type_obj
    set type_obj, $P3055
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3056, type_obj
    .const 'Sub' $P3057 = "25_1299602554.641" 
    $P3056."add_method"(type_obj, "TOP", $P3057)
    get_how $P3058, type_obj
    .const 'Sub' $P3059 = "26_1299602554.641" 
    $P3058."add_method"(type_obj, "deflongname", $P3059)
    get_how $P3060, type_obj
    .const 'Sub' $P3061 = "27_1299602554.641" 
    $P3060."add_method"(type_obj, "comp_unit", $P3061)
    get_how $P3062, type_obj
    .const 'Sub' $P3063 = "28_1299602554.641" 
    $P3062."add_method"(type_obj, "statementlist", $P3063)
    get_how $P3064, type_obj
    .const 'Sub' $P3065 = "30_1299602554.641" 
    $P3064."add_method"(type_obj, "statement", $P3065)
    get_how $P3066, type_obj
    .const 'Sub' $P3067 = "32_1299602554.641" 
    $P3066."add_method"(type_obj, "xblock", $P3067)
    get_how $P3068, type_obj
    .const 'Sub' $P3069 = "33_1299602554.641" 
    $P3068."add_method"(type_obj, "pblock", $P3069)
    get_how $P3070, type_obj
    .const 'Sub' $P3071 = "34_1299602554.641" 
    $P3070."add_method"(type_obj, "block", $P3071)
    get_how $P3072, type_obj
    .const 'Sub' $P3073 = "35_1299602554.641" 
    $P3072."add_method"(type_obj, "blockoid", $P3073)
    get_how $P3074, type_obj
    .const 'Sub' $P3075 = "37_1299602554.641" 
    $P3074."add_method"(type_obj, "newpad", $P3075)
    get_how $P3076, type_obj
    .const 'Sub' $P3077 = "38_1299602554.641" 
    $P3076."add_method"(type_obj, "outerctx", $P3077)
    get_how $P3078, type_obj
    .const 'Sub' $P3079 = "39_1299602554.641" 
    $P3078."add_method"(type_obj, "you_are_here", $P3079)
    get_how $P3080, type_obj
    .const 'Sub' $P3081 = "40_1299602554.641" 
    $P3080."add_method"(type_obj, "statement_control:sym<if>", $P3081)
    get_how $P3082, type_obj
    .const 'Sub' $P3083 = "42_1299602554.641" 
    $P3082."add_method"(type_obj, "statement_control:sym<unless>", $P3083)
    get_how $P3084, type_obj
    .const 'Sub' $P3085 = "43_1299602554.641" 
    $P3084."add_method"(type_obj, "statement_control:sym<while>", $P3085)
    get_how $P3086, type_obj
    .const 'Sub' $P3087 = "44_1299602554.641" 
    $P3086."add_method"(type_obj, "statement_control:sym<repeat>", $P3087)
    get_how $P3088, type_obj
    .const 'Sub' $P3089 = "45_1299602554.641" 
    $P3088."add_method"(type_obj, "statement_control:sym<for>", $P3089)
    get_how $P3090, type_obj
    .const 'Sub' $P3091 = "46_1299602554.641" 
    $P3090."add_method"(type_obj, "statement_control:sym<CATCH>", $P3091)
    get_how $P3092, type_obj
    .const 'Sub' $P3093 = "47_1299602554.641" 
    $P3092."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3093)
    get_how $P3094, type_obj
    .const 'Sub' $P3095 = "48_1299602554.641" 
    $P3094."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3095)
    get_how $P3096, type_obj
    .const 'Sub' $P3097 = "49_1299602554.641" 
    $P3096."add_method"(type_obj, "statement_prefix:sym<try>", $P3097)
    get_how $P3098, type_obj
    .const 'Sub' $P3099 = "50_1299602554.641" 
    $P3098."add_method"(type_obj, "blorst", $P3099)
    get_how $P3100, type_obj
    .const 'Sub' $P3101 = "51_1299602554.641" 
    $P3100."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3101)
    get_how $P3102, type_obj
    .const 'Sub' $P3103 = "52_1299602554.641" 
    $P3102."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3103)
    get_how $P3104, type_obj
    .const 'Sub' $P3105 = "53_1299602554.641" 
    $P3104."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3105)
    get_how $P3106, type_obj
    .const 'Sub' $P3107 = "54_1299602554.641" 
    $P3106."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3107)
    get_how $P3108, type_obj
    .const 'Sub' $P3109 = "55_1299602554.641" 
    $P3108."add_method"(type_obj, "term:sym<fatarrow>", $P3109)
    get_how $P3110, type_obj
    .const 'Sub' $P3111 = "56_1299602554.641" 
    $P3110."add_method"(type_obj, "term:sym<colonpair>", $P3111)
    get_how $P3112, type_obj
    .const 'Sub' $P3113 = "57_1299602554.641" 
    $P3112."add_method"(type_obj, "term:sym<variable>", $P3113)
    get_how $P3114, type_obj
    .const 'Sub' $P3115 = "58_1299602554.641" 
    $P3114."add_method"(type_obj, "term:sym<package_declarator>", $P3115)
    get_how $P3116, type_obj
    .const 'Sub' $P3117 = "59_1299602554.641" 
    $P3116."add_method"(type_obj, "term:sym<scope_declarator>", $P3117)
    get_how $P3118, type_obj
    .const 'Sub' $P3119 = "60_1299602554.641" 
    $P3118."add_method"(type_obj, "term:sym<routine_declarator>", $P3119)
    get_how $P3120, type_obj
    .const 'Sub' $P3121 = "61_1299602554.641" 
    $P3120."add_method"(type_obj, "term:sym<regex_declarator>", $P3121)
    get_how $P3122, type_obj
    .const 'Sub' $P3123 = "62_1299602554.641" 
    $P3122."add_method"(type_obj, "term:sym<statement_prefix>", $P3123)
    get_how $P3124, type_obj
    .const 'Sub' $P3125 = "63_1299602554.641" 
    $P3124."add_method"(type_obj, "term:sym<lambda>", $P3125)
    get_how $P3126, type_obj
    .const 'Sub' $P3127 = "64_1299602554.641" 
    $P3126."add_method"(type_obj, "fatarrow", $P3127)
    get_how $P3128, type_obj
    .const 'Sub' $P3129 = "65_1299602554.641" 
    $P3128."add_method"(type_obj, "colonpair", $P3129)
    get_how $P3130, type_obj
    .const 'Sub' $P3131 = "66_1299602554.641" 
    $P3130."add_method"(type_obj, "variable", $P3131)
    get_how $P3132, type_obj
    .const 'Sub' $P3133 = "68_1299602554.641" 
    $P3132."add_method"(type_obj, "package_declarator:sym<module>", $P3133)
    get_how $P3134, type_obj
    .const 'Sub' $P3135 = "69_1299602554.641" 
    $P3134."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3135)
    get_how $P3136, type_obj
    .const 'Sub' $P3137 = "70_1299602554.641" 
    $P3136."add_method"(type_obj, "package_declarator:sym<class>", $P3137)
    get_how $P3138, type_obj
    .const 'Sub' $P3139 = "71_1299602554.641" 
    $P3138."add_method"(type_obj, "package_declarator:sym<grammar>", $P3139)
    get_how $P3140, type_obj
    .const 'Sub' $P3141 = "72_1299602554.641" 
    $P3140."add_method"(type_obj, "package_declarator:sym<role>", $P3141)
    get_how $P3142, type_obj
    .const 'Sub' $P3143 = "73_1299602554.641" 
    $P3142."add_method"(type_obj, "package_declarator:sym<native>", $P3143)
    get_how $P3144, type_obj
    .const 'Sub' $P3145 = "74_1299602554.641" 
    $P3144."add_method"(type_obj, "package_def", $P3145)
    get_how $P3146, type_obj
    .const 'Sub' $P3147 = "77_1299602554.641" 
    $P3146."add_method"(type_obj, "scope_declarator:sym<my>", $P3147)
    get_how $P3148, type_obj
    .const 'Sub' $P3149 = "78_1299602554.641" 
    $P3148."add_method"(type_obj, "scope_declarator:sym<our>", $P3149)
    get_how $P3150, type_obj
    .const 'Sub' $P3151 = "79_1299602554.641" 
    $P3150."add_method"(type_obj, "scope_declarator:sym<has>", $P3151)
    get_how $P3152, type_obj
    .const 'Sub' $P3153 = "80_1299602554.641" 
    $P3152."add_method"(type_obj, "scoped", $P3153)
    get_how $P3154, type_obj
    .const 'Sub' $P3155 = "81_1299602554.641" 
    $P3154."add_method"(type_obj, "declarator", $P3155)
    get_how $P3156, type_obj
    .const 'Sub' $P3157 = "82_1299602554.641" 
    $P3156."add_method"(type_obj, "multi_declarator:sym<multi>", $P3157)
    get_how $P3158, type_obj
    .const 'Sub' $P3159 = "83_1299602554.641" 
    $P3158."add_method"(type_obj, "multi_declarator:sym<proto>", $P3159)
    get_how $P3160, type_obj
    .const 'Sub' $P3161 = "84_1299602554.641" 
    $P3160."add_method"(type_obj, "multi_declarator:sym<null>", $P3161)
    get_how $P3162, type_obj
    .const 'Sub' $P3163 = "85_1299602554.641" 
    $P3162."add_method"(type_obj, "variable_declarator", $P3163)
    get_how $P3164, type_obj
    .const 'Sub' $P3165 = "89_1299602554.641" 
    $P3164."add_method"(type_obj, "routine_declarator:sym<sub>", $P3165)
    get_how $P3166, type_obj
    .const 'Sub' $P3167 = "90_1299602554.641" 
    $P3166."add_method"(type_obj, "routine_declarator:sym<method>", $P3167)
    get_how $P3168, type_obj
    .const 'Sub' $P3169 = "91_1299602554.641" 
    $P3168."add_method"(type_obj, "routine_def", $P3169)
    get_how $P3170, type_obj
    .const 'Sub' $P3171 = "98_1299602554.641" 
    $P3170."add_method"(type_obj, "method_def", $P3171)
    get_how $P3172, type_obj
    .const 'Sub' $P3173 = "101_1299602554.641" 
    $P3172."add_method"(type_obj, "signature", $P3173)
    get_how $P3174, type_obj
    .const 'Sub' $P3175 = "104_1299602554.641" 
    $P3174."add_method"(type_obj, "parameter", $P3175)
    get_how $P3176, type_obj
    .const 'Sub' $P3177 = "105_1299602554.641" 
    $P3176."add_method"(type_obj, "param_var", $P3177)
    get_how $P3178, type_obj
    .const 'Sub' $P3179 = "106_1299602554.641" 
    $P3178."add_method"(type_obj, "named_param", $P3179)
    get_how $P3180, type_obj
    .const 'Sub' $P3181 = "107_1299602554.641" 
    $P3180."add_method"(type_obj, "typename", $P3181)
    get_how $P3182, type_obj
    .const 'Sub' $P3183 = "108_1299602554.641" 
    $P3182."add_method"(type_obj, "trait", $P3183)
    get_how $P3184, type_obj
    .const 'Sub' $P3185 = "109_1299602554.641" 
    $P3184."add_method"(type_obj, "trait_mod:sym<is>", $P3185)
    get_how $P3186, type_obj
    .const 'Sub' $P3187 = "111_1299602554.641" 
    $P3186."add_method"(type_obj, "regex_declarator", $P3187)
    get_how $P3188, type_obj
    .const 'Sub' $P3189 = "115_1299602554.641" 
    $P3188."add_method"(type_obj, "dotty", $P3189)
    get_how $P3190, type_obj
    .const 'Sub' $P3191 = "116_1299602554.641" 
    $P3190."add_method"(type_obj, "term:sym<self>", $P3191)
    get_how $P3192, type_obj
    .const 'Sub' $P3193 = "117_1299602554.641" 
    $P3192."add_method"(type_obj, "term:sym<identifier>", $P3193)
    get_how $P3194, type_obj
    .const 'Sub' $P3195 = "118_1299602554.641" 
    $P3194."add_method"(type_obj, "term:sym<name>", $P3195)
    get_how $P3196, type_obj
    .const 'Sub' $P3197 = "119_1299602554.641" 
    $P3196."add_method"(type_obj, "term:sym<pir::op>", $P3197)
    get_how $P3198, type_obj
    .const 'Sub' $P3199 = "120_1299602554.641" 
    $P3198."add_method"(type_obj, "term:sym<onlystar>", $P3199)
    get_how $P3200, type_obj
    .const 'Sub' $P3201 = "121_1299602554.641" 
    $P3200."add_method"(type_obj, "args", $P3201)
    get_how $P3202, type_obj
    .const 'Sub' $P3203 = "122_1299602554.641" 
    $P3202."add_method"(type_obj, "arglist", $P3203)
    get_how $P3204, type_obj
    .const 'Sub' $P3205 = "125_1299602554.641" 
    $P3204."add_method"(type_obj, "term:sym<multi_declarator>", $P3205)
    get_how $P3206, type_obj
    .const 'Sub' $P3207 = "126_1299602554.641" 
    $P3206."add_method"(type_obj, "term:sym<value>", $P3207)
    get_how $P3208, type_obj
    .const 'Sub' $P3209 = "127_1299602554.641" 
    $P3208."add_method"(type_obj, "circumfix:sym<( )>", $P3209)
    get_how $P3210, type_obj
    .const 'Sub' $P3211 = "128_1299602554.641" 
    $P3210."add_method"(type_obj, "circumfix:sym<[ ]>", $P3211)
    get_how $P3212, type_obj
    .const 'Sub' $P3213 = "129_1299602554.641" 
    $P3212."add_method"(type_obj, "circumfix:sym<ang>", $P3213)
    get_how $P3214, type_obj
    .const 'Sub' $P3215 = "130_1299602554.641" 
    $P3214."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3215)
    get_how $P3216, type_obj
    .const 'Sub' $P3217 = "131_1299602554.641" 
    $P3216."add_method"(type_obj, "circumfix:sym<{ }>", $P3217)
    get_how $P3218, type_obj
    .const 'Sub' $P3219 = "133_1299602554.641" 
    $P3218."add_method"(type_obj, "circumfix:sym<sigil>", $P3219)
    get_how $P3220, type_obj
    .const 'Sub' $P3221 = "134_1299602554.641" 
    $P3220."add_method"(type_obj, "semilist", $P3221)
    get_how $P3222, type_obj
    .const 'Sub' $P3223 = "135_1299602554.641" 
    $P3222."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3223)
    get_how $P3224, type_obj
    .const 'Sub' $P3225 = "136_1299602554.641" 
    $P3224."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3225)
    get_how $P3226, type_obj
    .const 'Sub' $P3227 = "137_1299602554.641" 
    $P3226."add_method"(type_obj, "postcircumfix:sym<ang>", $P3227)
    get_how $P3228, type_obj
    .const 'Sub' $P3229 = "138_1299602554.641" 
    $P3228."add_method"(type_obj, "postcircumfix:sym<( )>", $P3229)
    get_how $P3230, type_obj
    .const 'Sub' $P3231 = "139_1299602554.641" 
    $P3230."add_method"(type_obj, "value", $P3231)
    get_how $P3232, type_obj
    .const 'Sub' $P3233 = "140_1299602554.641" 
    $P3232."add_method"(type_obj, "number", $P3233)
    get_how $P3234, type_obj
    .const 'Sub' $P3235 = "141_1299602554.641" 
    $P3234."add_method"(type_obj, "quote:sym<apos>", $P3235)
    get_how $P3236, type_obj
    .const 'Sub' $P3237 = "142_1299602554.641" 
    $P3236."add_method"(type_obj, "quote:sym<dblq>", $P3237)
    get_how $P3238, type_obj
    .const 'Sub' $P3239 = "143_1299602554.641" 
    $P3238."add_method"(type_obj, "quote:sym<qq>", $P3239)
    get_how $P3240, type_obj
    .const 'Sub' $P3241 = "144_1299602554.641" 
    $P3240."add_method"(type_obj, "quote:sym<q>", $P3241)
    get_how $P3242, type_obj
    .const 'Sub' $P3243 = "145_1299602554.641" 
    $P3242."add_method"(type_obj, "quote:sym<Q>", $P3243)
    get_how $P3244, type_obj
    .const 'Sub' $P3245 = "146_1299602554.641" 
    $P3244."add_method"(type_obj, "quote:sym<Q:PIR>", $P3245)
    get_how $P3246, type_obj
    .const 'Sub' $P3247 = "147_1299602554.641" 
    $P3246."add_method"(type_obj, "quote:sym</ />", $P3247)
    get_how $P3248, type_obj
    .const 'Sub' $P3249 = "148_1299602554.641" 
    $P3248."add_method"(type_obj, "quote_escape:sym<$>", $P3249)
    get_how $P3250, type_obj
    .const 'Sub' $P3251 = "149_1299602554.641" 
    $P3250."add_method"(type_obj, "quote_escape:sym<{ }>", $P3251)
    get_how $P3252, type_obj
    .const 'Sub' $P3253 = "150_1299602554.641" 
    $P3252."add_method"(type_obj, "quote_escape:sym<esc>", $P3253)
    get_how $P3254, type_obj
    .const 'Sub' $P3255 = "151_1299602554.641" 
    $P3254."add_method"(type_obj, "postfix:sym<.>", $P3255)
    get_how $P3256, type_obj
    .const 'Sub' $P3257 = "152_1299602554.641" 
    $P3256."add_method"(type_obj, "postfix:sym<++>", $P3257)
    get_how $P3258, type_obj
    .const 'Sub' $P3259 = "153_1299602554.641" 
    $P3258."add_method"(type_obj, "postfix:sym<-->", $P3259)
    get_how $P3260, type_obj
    .const 'Sub' $P3261 = "154_1299602554.641" 
    $P3260."add_method"(type_obj, "prefix:sym<make>", $P3261)
    get_how $P3262, type_obj
    .const 'Sub' $P3263 = "155_1299602554.641" 
    $P3262."add_method"(type_obj, "term:sym<next>", $P3263)
    get_how $P3264, type_obj
    .const 'Sub' $P3265 = "156_1299602554.641" 
    $P3264."add_method"(type_obj, "term:sym<last>", $P3265)
    get_how $P3266, type_obj
    .const 'Sub' $P3267 = "157_1299602554.641" 
    $P3266."add_method"(type_obj, "term:sym<redo>", $P3267)
    get_how $P3268, type_obj
    .const 'Sub' $P3269 = "158_1299602554.641" 
    $P3268."add_method"(type_obj, "infix:sym<~~>", $P3269)
    get_how $P3270, type_obj
    get_hll_global $P3271, ["HLL"], "Actions"
    $P3270."add_parent"(type_obj, $P3271)
    get_how $P3272, type_obj
    $P3273 = $P3272."compose"(type_obj)
    .return ($P3273)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_26
.annotate 'line', 9
    .lex "$xblock", param_26
.annotate 'line', 10
    find_lex $P27, "$xblock"
    unless_null $P27, vivify_174
    $P27 = root_new ['parrot';'ResizablePMCArray']
  vivify_174:
    set $P28, $P27[1]
    unless_null $P28, vivify_175
    new $P28, "Undef"
  vivify_175:
    $P29 = "block_immediate"($P28)
    find_lex $P30, "$xblock"
    unless_null $P30, vivify_176
    $P30 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P30
  vivify_176:
    set $P30[1], $P29
    find_lex $P31, "$xblock"
.annotate 'line', 9
    .return ($P31)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_34
.annotate 'line', 14
    .const 'Sub' $P44 = "14_1299602554.641" 
    capture_lex $P44
    .lex "$block", param_34
.annotate 'line', 15
    find_lex $P35, "$block"
    $P35."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P39, "$block"
    $P40 = $P39."symtable"()
    unless $P40, unless_38
    set $P37, $P40
    goto unless_38_end
  unless_38:
    find_lex $P41, "$block"
    $P42 = $P41."handlers"()
    set $P37, $P42
  unless_38_end:
    if $P37, unless_36_end
    .const 'Sub' $P44 = "14_1299602554.641" 
    capture_lex $P44
    $P44()
  unless_36_end:
    find_lex $P64, "$block"
.annotate 'line', 14
    .return ($P64)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block43"  :anon :subid("14_1299602554.641") :outer("13_1299602554.641")
.annotate 'line', 16
    .const 'Sub' $P55 = "15_1299602554.641" 
    capture_lex $P55
.annotate 'line', 17
    new $P45, "Undef"
    .lex "$stmts", $P45
    get_hll_global $P46, ["PAST"], "Stmts"
    find_lex $P47, "$block"
    $P48 = $P46."new"($P47 :named("node"))
    store_lex "$stmts", $P48
.annotate 'line', 18
    find_lex $P50, "$block"
    $P51 = $P50."list"()
    defined $I52, $P51
    unless $I52, for_undef_177
    iter $P49, $P51
    new $P61, 'ExceptionHandler'
    set_label $P61, loop60_handler
    $P61."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P61
  loop60_test:
    unless $P49, loop60_done
    shift $P53, $P49
  loop60_redo:
    .const 'Sub' $P55 = "15_1299602554.641" 
    capture_lex $P55
    $P55($P53)
  loop60_next:
    goto loop60_test
  loop60_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P62, exception, 'type'
    eq $P62, .CONTROL_LOOP_NEXT, loop60_next
    eq $P62, .CONTROL_LOOP_REDO, loop60_redo
  loop60_done:
    pop_eh 
  for_undef_177:
.annotate 'line', 19
    find_lex $P63, "$stmts"
    store_lex "$block", $P63
.annotate 'line', 16
    .return ($P63)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block54"  :anon :subid("15_1299602554.641") :outer("14_1299602554.641")
    .param pmc param_56
.annotate 'line', 18
    .lex "$_", param_56
    find_lex $P57, "$stmts"
    find_lex $P58, "$_"
    $P59 = $P57."push"($P58)
    .return ($P59)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_67
.annotate 'line', 24
    .lex "$sigil", param_67
.annotate 'line', 25
    find_lex $P70, "$sigil"
    set $S71, $P70
    iseq $I72, $S71, "%"
    if $I72, if_69
.annotate 'line', 27
    find_lex $P77, "$sigil"
    set $S78, $P77
    iseq $I79, $S78, "@"
    if $I79, if_76
    new $P82, "String"
    assign $P82, "Undef"
    set $P75, $P82
    goto if_76_end
  if_76:
.annotate 'line', 28
    get_hll_global $P80, ["PAST"], "Op"
    $P81 = $P80."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P75, $P81
  if_76_end:
    set $P68, $P75
.annotate 'line', 25
    goto if_69_end
  if_69:
.annotate 'line', 26
    get_hll_global $P73, ["PAST"], "Op"
    $P74 = $P73."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P68, $P74
  if_69_end:
.annotate 'line', 24
    .return ($P68)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_85
.annotate 'line', 43
    .lex "$ast", param_85
.annotate 'line', 44
    get_hll_global $P88, ["PAST"], "Op"
    find_lex $P89, "$ast"
    $P90 = $P88."ACCEPTS"($P89)
    if $P90, if_87
.annotate 'line', 46
    find_lex $P94, "$ast"
    $P95 = $P94."value"()
    set $P86, $P95
.annotate 'line', 44
    goto if_87_end
  if_87:
.annotate 'line', 45
    find_lex $P91, "$ast"
    $P92 = $P91."list"()
    join $S93, " ", $P92
    new $P86, 'String'
    set $P86, $S93
  if_87_end:
.annotate 'line', 43
    .return ($P86)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_98
    .param pmc param_99
.annotate 'line', 257
    .lex "$/", param_98
    .lex "$block", param_99
.annotate 'line', 258
    get_global $P101, "@BLOCK"
    unless_null $P101, vivify_178
    $P101 = root_new ['parrot';'ResizablePMCArray']
  vivify_178:
    set $P102, $P101[0]
    unless_null $P102, vivify_179
    new $P102, "Undef"
  vivify_179:
    $P103 = $P102."handlers"()
    if $P103, unless_100_end
.annotate 'line', 259
    get_global $P104, "@BLOCK"
    unless_null $P104, vivify_180
    $P104 = root_new ['parrot';'ResizablePMCArray']
  vivify_180:
    set $P105, $P104[0]
    unless_null $P105, vivify_181
    new $P105, "Undef"
  vivify_181:
    new $P106, "ResizablePMCArray"
    $P105."handlers"($P106)
  unless_100_end:
.annotate 'line', 261
    find_lex $P108, "$block"
    $P109 = $P108."arity"()
    if $P109, unless_107_end
.annotate 'line', 262
    find_lex $P110, "$block"
.annotate 'line', 263
    get_hll_global $P111, ["PAST"], "Op"
.annotate 'line', 264
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 265
    get_hll_global $P114, ["PAST"], "Var"
    $P115 = $P114."new"("lexical" :named("scope"), "$_" :named("name"))
    $P116 = $P111."new"($P113, $P115, "bind" :named("pasttype"))
.annotate 'line', 263
    $P110."unshift"($P116)
.annotate 'line', 268
    find_lex $P117, "$block"
    get_hll_global $P118, ["PAST"], "Var"
    $P119 = $P118."new"("$_" :named("name"), "parameter" :named("scope"))
    $P117."unshift"($P119)
.annotate 'line', 269
    find_lex $P120, "$block"
    $P120."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 270
    find_lex $P121, "$block"
    $P121."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 271
    find_lex $P122, "$block"
    $P122."arity"(1)
  unless_107_end:
.annotate 'line', 273
    find_lex $P123, "$block"
    $P123."blocktype"("declaration")
.annotate 'line', 274
    get_global $P124, "@BLOCK"
    unless_null $P124, vivify_182
    $P124 = root_new ['parrot';'ResizablePMCArray']
  vivify_182:
    set $P125, $P124[0]
    unless_null $P125, vivify_183
    new $P125, "Undef"
  vivify_183:
    $P126 = $P125."handlers"()
.annotate 'line', 275
    get_hll_global $P127, ["PAST"], "Control"
    find_lex $P128, "$/"
.annotate 'line', 277
    get_hll_global $P129, ["PAST"], "Stmts"
.annotate 'line', 278
    get_hll_global $P130, ["PAST"], "Op"
    find_lex $P131, "$block"
.annotate 'line', 280
    get_hll_global $P132, ["PAST"], "Var"
    $P133 = $P132."new"("register" :named("scope"), "exception" :named("name"))
    $P134 = $P130."new"($P131, $P133, "call" :named("pasttype"))
.annotate 'line', 282
    get_hll_global $P135, ["PAST"], "Op"
.annotate 'line', 283
    get_hll_global $P136, ["PAST"], "Var"
.annotate 'line', 284
    get_hll_global $P137, ["PAST"], "Var"
    $P138 = $P137."new"("register" :named("scope"), "exception" :named("name"))
    $P139 = $P136."new"($P138, "handled", "keyed" :named("scope"))
.annotate 'line', 283
    $P140 = $P135."new"($P139, 1, "bind" :named("pasttype"))
.annotate 'line', 282
    $P141 = $P129."new"($P134, $P140)
.annotate 'line', 277
    $P142 = $P127."new"($P141, $P128 :named("node"))
.annotate 'line', 275
    $P143 = $P126."unshift"($P142)
.annotate 'line', 257
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1299602554.641") :outer("11_1299602554.641")
.annotate 'line', 795
    new $P146, "Undef"
    .lex "$past", $P146
    get_global $P147, "@BLOCK"
    $P148 = $P147."shift"()
    store_lex "$past", $P148
.annotate 'line', 796
    find_lex $P149, "$past"
    $P149."closure"(1)
.annotate 'line', 797
    find_lex $P150, "$past"
    get_hll_global $P151, ["PAST"], "Op"
    $P152 = $P151."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P150."push"($P152)
    find_lex $P153, "$past"
.annotate 'line', 794
    .return ($P153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_156
.annotate 'line', 803
    .const 'Sub' $P170 = "21_1299602554.641" 
    capture_lex $P170
    .lex "$routine", param_156
.annotate 'line', 807
    new $P157, "Undef"
    .lex "$types", $P157
.annotate 'line', 808
    new $P158, "Undef"
    .lex "$definednesses", $P158
.annotate 'line', 807
    get_hll_global $P159, ["PAST"], "Op"
    $P160 = $P159."new"("list" :named("pasttype"))
    store_lex "$types", $P160
.annotate 'line', 808
    get_hll_global $P161, ["PAST"], "Op"
    $P162 = $P161."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P162
.annotate 'line', 809
    find_lex $P164, "$routine"
    unless_null $P164, vivify_184
    $P164 = root_new ['parrot';'ResizablePMCArray']
  vivify_184:
    set $P165, $P164[0]
    unless_null $P165, vivify_185
    new $P165, "Undef"
  vivify_185:
    $P166 = $P165."list"()
    defined $I167, $P166
    unless $I167, for_undef_186
    iter $P163, $P166
    new $P208, 'ExceptionHandler'
    set_label $P208, loop207_handler
    $P208."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P208
  loop207_test:
    unless $P163, loop207_done
    shift $P168, $P163
  loop207_redo:
    .const 'Sub' $P170 = "21_1299602554.641" 
    capture_lex $P170
    $P170($P168)
  loop207_next:
    goto loop207_test
  loop207_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P209, exception, 'type'
    eq $P209, .CONTROL_LOOP_NEXT, loop207_next
    eq $P209, .CONTROL_LOOP_REDO, loop207_redo
  loop207_done:
    pop_eh 
  for_undef_186:
.annotate 'line', 816
    find_lex $P210, "$routine"
    $P211 = $P210."loadinit"()
    get_hll_global $P212, ["PAST"], "Op"
.annotate 'line', 817
    get_hll_global $P213, ["PAST"], "Var"
    $P214 = $P213."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P215, "$types"
    find_lex $P216, "$definednesses"
    $P217 = $P212."new"($P214, $P215, $P216, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 816
    $P218 = $P211."push"($P217)
.annotate 'line', 803
    .return ($P218)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block169"  :anon :subid("21_1299602554.641") :outer("20_1299602554.641")
    .param pmc param_171
.annotate 'line', 809
    .lex "$_", param_171
.annotate 'line', 810
    get_hll_global $P176, ["PAST"], "Var"
    find_lex $P177, "$_"
    $P178 = $P176."ACCEPTS"($P177)
    if $P178, if_175
    set $P174, $P178
    goto if_175_end
  if_175:
    find_lex $P179, "$_"
    $S180 = $P179."scope"()
    iseq $I181, $S180, "parameter"
    new $P174, 'Integer'
    set $P174, $I181
  if_175_end:
    if $P174, if_173
    set $P172, $P174
    goto if_173_end
  if_173:
.annotate 'line', 811
    find_lex $P182, "$types"
    find_lex $P184, "$_"
    $P185 = $P184."multitype"()
    set $P183, $P185
    defined $I187, $P183
    if $I187, default_186
    get_hll_global $P188, ["PAST"], "Op"
    $P189 = $P188."new"("null P" :named("pirop"))
    set $P183, $P189
  default_186:
    $P182."push"($P183)
.annotate 'line', 812
    find_lex $P190, "$definednesses"
    find_lex $P193, "$_"
    unless_null $P193, vivify_187
    $P193 = root_new ['parrot';'Hash']
  vivify_187:
    set $P194, $P193["definedness"]
    unless_null $P194, vivify_188
    new $P194, "Undef"
  vivify_188:
    set $S195, $P194
    iseq $I196, $S195, "D"
    if $I196, if_192
.annotate 'line', 813
    find_lex $P200, "$_"
    unless_null $P200, vivify_189
    $P200 = root_new ['parrot';'Hash']
  vivify_189:
    set $P201, $P200["definedness"]
    unless_null $P201, vivify_190
    new $P201, "Undef"
  vivify_190:
    set $S202, $P201
    iseq $I203, $S202, "U"
    if $I203, if_199
    new $P205, "Integer"
    assign $P205, 0
    set $P198, $P205
    goto if_199_end
  if_199:
    new $P204, "Integer"
    assign $P204, 2
    set $P198, $P204
  if_199_end:
    set $P191, $P198
.annotate 'line', 812
    goto if_192_end
  if_192:
    new $P197, "Integer"
    assign $P197, 1
    set $P191, $P197
  if_192_end:
    $P206 = $P190."push"($P191)
.annotate 'line', 810
    set $P172, $P206
  if_173_end:
.annotate 'line', 809
    .return ($P172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("22_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_221
    .param pmc param_222
.annotate 'line', 1279
    .lex "$/", param_221
    .lex "$type", param_222
.annotate 'line', 1280
    find_lex $P223, "$/"
    get_hll_global $P224, ["PAST"], "Op"
    find_lex $P225, "$/"
.annotate 'line', 1284
    get_hll_global $P226, ["PAST"], "Val"
    find_lex $P227, "$type"
    $P228 = $P226."new"($P227 :named("value"), "!except_types" :named("returns"))
    $P229 = $P224."new"(0, $P228, $P225 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1280
    $P230 = $P223."!make"($P229)
.annotate 'line', 1279
    .return ($P230)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block233"  :anon :subid("23_1299602554.641") :outer("11_1299602554.641")
.annotate 'line', 3
    .const 'Sub' $P236 = "24_1299602554.641" 
    capture_lex $P236
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post191") :outer("23_1299602554.641")
.annotate 'line', 3
    .const 'Sub' $P234 = "23_1299602554.641" 
    .local pmc block
    set block, $P234
.annotate 'line', 5
    .const 'Sub' $P236 = "24_1299602554.641" 
    capture_lex $P236
    $P236()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block235"  :anon :subid("24_1299602554.641") :outer("23_1299602554.641")
.annotate 'line', 6
    get_global $P237, "@BLOCK"
    unless_null $P237, vivify_192
    $P237 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P237
  vivify_192:
 $P238 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P238
.annotate 'line', 5
    .return ($P238)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("25_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_243
    .param pmc param_244
.annotate 'line', 33
    .lex "self", param_243
    .lex "$/", param_244
    find_lex $P245, "$/"
    find_lex $P246, "$/"
    unless_null $P246, vivify_193
    $P246 = root_new ['parrot';'Hash']
  vivify_193:
    set $P247, $P246["comp_unit"]
    unless_null $P247, vivify_194
    new $P247, "Undef"
  vivify_194:
    $P248 = $P247."ast"()
    $P249 = $P245."!make"($P248)
    .return ($P249)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("26_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_251
    .param pmc param_252
.annotate 'line', 35
    .lex "self", param_251
    .lex "$/", param_252
.annotate 'line', 36
    find_lex $P253, "$/"
.annotate 'line', 37
    find_lex $P256, "$/"
    unless_null $P256, vivify_195
    $P256 = root_new ['parrot';'Hash']
  vivify_195:
    set $P257, $P256["colonpair"]
    unless_null $P257, vivify_196
    new $P257, "Undef"
  vivify_196:
    if $P257, if_255
.annotate 'line', 39
    find_lex $P277, "$/"
    set $S278, $P277
    new $P254, 'String'
    set $P254, $S278
.annotate 'line', 37
    goto if_255_end
  if_255:
    find_lex $P258, "$/"
    unless_null $P258, vivify_197
    $P258 = root_new ['parrot';'Hash']
  vivify_197:
    set $P259, $P258["identifier"]
    unless_null $P259, vivify_198
    new $P259, "Undef"
  vivify_198:
    set $S260, $P259
    new $P261, 'String'
    set $P261, $S260
    concat $P262, $P261, ":"
    find_lex $P263, "$/"
    unless_null $P263, vivify_199
    $P263 = root_new ['parrot';'Hash']
  vivify_199:
    set $P264, $P263["colonpair"]
    unless_null $P264, vivify_200
    $P264 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P265, $P264[0]
    unless_null $P265, vivify_201
    new $P265, "Undef"
  vivify_201:
    $P266 = $P265."ast"()
    $S267 = $P266."named"()
    concat $P268, $P262, $S267
    concat $P269, $P268, "<"
.annotate 'line', 38
    find_lex $P270, "$/"
    unless_null $P270, vivify_202
    $P270 = root_new ['parrot';'Hash']
  vivify_202:
    set $P271, $P270["colonpair"]
    unless_null $P271, vivify_203
    $P271 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P272, $P271[0]
    unless_null $P272, vivify_204
    new $P272, "Undef"
  vivify_204:
    $P273 = $P272."ast"()
    $S274 = "colonpair_str"($P273)
    concat $P275, $P269, $S274
    concat $P276, $P275, ">"
    set $P254, $P276
  if_255_end:
.annotate 'line', 37
    $P279 = $P253."!make"($P254)
.annotate 'line', 35
    .return ($P279)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("27_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_282
    .param pmc param_283
.annotate 'line', 49
    .lex "self", param_282
    .lex "$/", param_283
.annotate 'line', 50
    new $P284, "Undef"
    .lex "$mainline", $P284
.annotate 'line', 51
    new $P285, "Undef"
    .lex "$unit", $P285
.annotate 'line', 50
    find_lex $P286, "$/"
    unless_null $P286, vivify_205
    $P286 = root_new ['parrot';'Hash']
  vivify_205:
    set $P287, $P286["statementlist"]
    unless_null $P287, vivify_206
    new $P287, "Undef"
  vivify_206:
    $P288 = $P287."ast"()
    store_lex "$mainline", $P288
.annotate 'line', 51
    get_global $P289, "@BLOCK"
    $P290 = $P289."shift"()
    store_lex "$unit", $P290
.annotate 'line', 55
    find_lex $P291, "$unit"
    $P292 = $P291."loadinit"()
    find_dynamic_lex $P293, "$*SC"
    unless_null $P293, vivify_207
    get_hll_global $P293, "$SC"
    unless_null $P293, vivify_208
    die "Contextual $*SC not found"
  vivify_208:
  vivify_207:
    $P294 = $P293."to_past"()
    $P292."push"($P294)
.annotate 'line', 60
    find_dynamic_lex $P296, "$*HAS_YOU_ARE_HERE"
    unless_null $P296, vivify_209
    get_hll_global $P296, "$HAS_YOU_ARE_HERE"
    unless_null $P296, vivify_210
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_210:
  vivify_209:
    if $P296, unless_295_end
.annotate 'line', 61
    find_lex $P297, "$unit"
    find_lex $P298, "self"
    $P299 = $P298."CTXSAVE"()
    $P297."push"($P299)
  unless_295_end:
.annotate 'line', 65
    find_lex $P300, "$unit"
    $P300."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 66
    find_lex $P301, "$unit"
    get_hll_global $P302, ["PAST"], "Op"
.annotate 'line', 68
    get_hll_global $P303, ["PAST"], "Op"
    $P304 = $P303."new"("getinterp P" :named("pirop"))
.annotate 'line', 69
    get_hll_global $P305, ["PAST"], "Op"
    $P306 = $P305."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 70
    get_hll_global $P307, ["PAST"], "Op"
    $P308 = $P307."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P309 = $P302."new"($P304, $P306, $P308, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 66
    $P301."unshift"($P309)
.annotate 'line', 76
    find_lex $P310, "$unit"
.annotate 'line', 77
    get_hll_global $P311, ["PAST"], "Op"
    find_lex $P312, "$mainline"
    $P313 = $P311."new"($P312, "return" :named("pirop"))
    $P310."push"($P313)
.annotate 'line', 82
    find_lex $P314, "$unit"
.annotate 'line', 83
    get_hll_global $P315, ["PAST"], "Block"
.annotate 'line', 85
    get_hll_global $P316, ["PAST"], "Op"
    get_hll_global $P317, ["PAST"], "Val"
    find_lex $P318, "$unit"
    $P319 = $P317."new"($P318 :named("value"))
    $P320 = $P316."new"($P319, "call" :named("pasttype"))
    $P321 = $P315."new"($P320, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 83
    $P314."push"($P321)
.annotate 'line', 88
    find_lex $P322, "$unit"
    find_lex $P323, "$/"
    $P322."node"($P323)
.annotate 'line', 91
    find_lex $P324, "$unit"
    $P324."hll"("nqp")
.annotate 'line', 93
    find_lex $P325, "$/"
    find_lex $P326, "$unit"
    $P327 = $P325."!make"($P326)
.annotate 'line', 49
    .return ($P327)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("28_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_329
    .param pmc param_330
.annotate 'line', 96
    .const 'Sub' $P344 = "29_1299602554.641" 
    capture_lex $P344
    .lex "self", param_329
    .lex "$/", param_330
.annotate 'line', 97
    new $P331, "Undef"
    .lex "$past", $P331
    get_hll_global $P332, ["PAST"], "Stmts"
    find_lex $P333, "$/"
    $P334 = $P332."new"($P333 :named("node"))
    store_lex "$past", $P334
.annotate 'line', 98
    find_lex $P336, "$/"
    unless_null $P336, vivify_211
    $P336 = root_new ['parrot';'Hash']
  vivify_211:
    set $P337, $P336["statement"]
    unless_null $P337, vivify_212
    new $P337, "Undef"
  vivify_212:
    unless $P337, if_335_end
.annotate 'line', 99
    find_lex $P339, "$/"
    unless_null $P339, vivify_213
    $P339 = root_new ['parrot';'Hash']
  vivify_213:
    set $P340, $P339["statement"]
    unless_null $P340, vivify_214
    new $P340, "Undef"
  vivify_214:
    defined $I341, $P340
    unless $I341, for_undef_215
    iter $P338, $P340
    new $P364, 'ExceptionHandler'
    set_label $P364, loop363_handler
    $P364."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P364
  loop363_test:
    unless $P338, loop363_done
    shift $P342, $P338
  loop363_redo:
    .const 'Sub' $P344 = "29_1299602554.641" 
    capture_lex $P344
    $P344($P342)
  loop363_next:
    goto loop363_test
  loop363_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P365, exception, 'type'
    eq $P365, .CONTROL_LOOP_NEXT, loop363_next
    eq $P365, .CONTROL_LOOP_REDO, loop363_redo
  loop363_done:
    pop_eh 
  for_undef_215:
  if_335_end:
.annotate 'line', 106
    find_lex $P366, "$/"
    find_lex $P367, "$past"
    $P368 = $P366."!make"($P367)
.annotate 'line', 96
    .return ($P368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block343"  :anon :subid("29_1299602554.641") :outer("28_1299602554.641")
    .param pmc param_346
.annotate 'line', 100
    new $P345, "Undef"
    .lex "$ast", $P345
    .lex "$_", param_346
    find_lex $P347, "$_"
    $P348 = $P347."ast"()
    store_lex "$ast", $P348
.annotate 'line', 101
    find_lex $P350, "$ast"
    unless_null $P350, vivify_216
    $P350 = root_new ['parrot';'Hash']
  vivify_216:
    set $P351, $P350["sink"]
    unless_null $P351, vivify_217
    new $P351, "Undef"
  vivify_217:
    defined $I352, $P351
    unless $I352, if_349_end
    find_lex $P353, "$ast"
    unless_null $P353, vivify_218
    $P353 = root_new ['parrot';'Hash']
  vivify_218:
    set $P354, $P353["sink"]
    unless_null $P354, vivify_219
    new $P354, "Undef"
  vivify_219:
    store_lex "$ast", $P354
  if_349_end:
.annotate 'line', 102
    find_lex $P356, "$ast"
    unless_null $P356, vivify_220
    $P356 = root_new ['parrot';'Hash']
  vivify_220:
    set $P357, $P356["bareblock"]
    unless_null $P357, vivify_221
    new $P357, "Undef"
  vivify_221:
    unless $P357, if_355_end
    find_lex $P358, "$ast"
    $P359 = "block_immediate"($P358)
    store_lex "$ast", $P359
  if_355_end:
.annotate 'line', 103
    find_lex $P360, "$past"
    find_lex $P361, "$ast"
    $P362 = $P360."push"($P361)
.annotate 'line', 99
    .return ($P362)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("30_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_370
    .param pmc param_371
    .param pmc param_372 :optional
    .param int has_param_372 :opt_flag
.annotate 'line', 109
    .const 'Sub' $P380 = "31_1299602554.641" 
    capture_lex $P380
    .lex "self", param_370
    .lex "$/", param_371
    if has_param_372, optparam_222
    new $P373, "Undef"
    set param_372, $P373
  optparam_222:
    .lex "$key", param_372
.annotate 'line', 110
    new $P374, "Undef"
    .lex "$past", $P374
.annotate 'line', 109
    find_lex $P375, "$past"
.annotate 'line', 111
    find_lex $P377, "$/"
    unless_null $P377, vivify_223
    $P377 = root_new ['parrot';'Hash']
  vivify_223:
    set $P378, $P377["EXPR"]
    unless_null $P378, vivify_224
    new $P378, "Undef"
  vivify_224:
    if $P378, if_376
.annotate 'line', 132
    find_lex $P441, "$/"
    unless_null $P441, vivify_225
    $P441 = root_new ['parrot';'Hash']
  vivify_225:
    set $P442, $P441["statement_control"]
    unless_null $P442, vivify_226
    new $P442, "Undef"
  vivify_226:
    if $P442, if_440
.annotate 'line', 133
    new $P446, "Integer"
    assign $P446, 0
    store_lex "$past", $P446
    goto if_440_end
  if_440:
.annotate 'line', 132
    find_lex $P443, "$/"
    unless_null $P443, vivify_227
    $P443 = root_new ['parrot';'Hash']
  vivify_227:
    set $P444, $P443["statement_control"]
    unless_null $P444, vivify_228
    new $P444, "Undef"
  vivify_228:
    $P445 = $P444."ast"()
    store_lex "$past", $P445
  if_440_end:
    goto if_376_end
  if_376:
.annotate 'line', 111
    .const 'Sub' $P380 = "31_1299602554.641" 
    capture_lex $P380
    $P380()
  if_376_end:
.annotate 'line', 134
    find_lex $P447, "$/"
    find_lex $P448, "$past"
    $P449 = $P447."!make"($P448)
.annotate 'line', 109
    .return ($P449)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block379"  :anon :subid("31_1299602554.641") :outer("30_1299602554.641")
.annotate 'line', 112
    new $P381, "Undef"
    .lex "$mc", $P381
.annotate 'line', 113
    new $P382, "Undef"
    .lex "$ml", $P382
.annotate 'line', 112
    find_lex $P383, "$/"
    unless_null $P383, vivify_229
    $P383 = root_new ['parrot';'Hash']
  vivify_229:
    set $P384, $P383["statement_mod_cond"]
    unless_null $P384, vivify_230
    $P384 = root_new ['parrot';'ResizablePMCArray']
  vivify_230:
    set $P385, $P384[0]
    unless_null $P385, vivify_231
    new $P385, "Undef"
  vivify_231:
    store_lex "$mc", $P385
.annotate 'line', 113
    find_lex $P386, "$/"
    unless_null $P386, vivify_232
    $P386 = root_new ['parrot';'Hash']
  vivify_232:
    set $P387, $P386["statement_mod_loop"]
    unless_null $P387, vivify_233
    $P387 = root_new ['parrot';'ResizablePMCArray']
  vivify_233:
    set $P388, $P387[0]
    unless_null $P388, vivify_234
    new $P388, "Undef"
  vivify_234:
    store_lex "$ml", $P388
.annotate 'line', 114
    find_lex $P389, "$/"
    unless_null $P389, vivify_235
    $P389 = root_new ['parrot';'Hash']
  vivify_235:
    set $P390, $P389["EXPR"]
    unless_null $P390, vivify_236
    new $P390, "Undef"
  vivify_236:
    $P391 = $P390."ast"()
    store_lex "$past", $P391
.annotate 'line', 115
    find_lex $P393, "$mc"
    unless $P393, if_392_end
.annotate 'line', 116
    get_hll_global $P394, ["PAST"], "Op"
    find_lex $P395, "$mc"
    unless_null $P395, vivify_237
    $P395 = root_new ['parrot';'Hash']
  vivify_237:
    set $P396, $P395["cond"]
    unless_null $P396, vivify_238
    new $P396, "Undef"
  vivify_238:
    $P397 = $P396."ast"()
    find_lex $P398, "$past"
    find_lex $P399, "$mc"
    unless_null $P399, vivify_239
    $P399 = root_new ['parrot';'Hash']
  vivify_239:
    set $P400, $P399["sym"]
    unless_null $P400, vivify_240
    new $P400, "Undef"
  vivify_240:
    set $S401, $P400
    find_lex $P402, "$/"
    $P403 = $P394."new"($P397, $P398, $S401 :named("pasttype"), $P402 :named("node"))
    store_lex "$past", $P403
  if_392_end:
.annotate 'line', 118
    find_lex $P406, "$ml"
    if $P406, if_405
    set $P404, $P406
    goto if_405_end
  if_405:
.annotate 'line', 119
    find_lex $P409, "$ml"
    unless_null $P409, vivify_241
    $P409 = root_new ['parrot';'Hash']
  vivify_241:
    set $P410, $P409["sym"]
    unless_null $P410, vivify_242
    new $P410, "Undef"
  vivify_242:
    set $S411, $P410
    iseq $I412, $S411, "for"
    if $I412, if_408
.annotate 'line', 128
    get_hll_global $P430, ["PAST"], "Op"
    find_lex $P431, "$ml"
    unless_null $P431, vivify_243
    $P431 = root_new ['parrot';'Hash']
  vivify_243:
    set $P432, $P431["cond"]
    unless_null $P432, vivify_244
    new $P432, "Undef"
  vivify_244:
    $P433 = $P432."ast"()
    find_lex $P434, "$past"
    find_lex $P435, "$ml"
    unless_null $P435, vivify_245
    $P435 = root_new ['parrot';'Hash']
  vivify_245:
    set $P436, $P435["sym"]
    unless_null $P436, vivify_246
    new $P436, "Undef"
  vivify_246:
    set $S437, $P436
    find_lex $P438, "$/"
    $P439 = $P430."new"($P433, $P434, $S437 :named("pasttype"), $P438 :named("node"))
    store_lex "$past", $P439
.annotate 'line', 127
    set $P407, $P439
.annotate 'line', 119
    goto if_408_end
  if_408:
.annotate 'line', 120
    get_hll_global $P413, ["PAST"], "Block"
.annotate 'line', 121
    get_hll_global $P414, ["PAST"], "Var"
    $P415 = $P414."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P416, "$past"
    $P417 = $P413."new"($P415, $P416, "immediate" :named("blocktype"))
.annotate 'line', 120
    store_lex "$past", $P417
.annotate 'line', 123
    find_lex $P418, "$past"
    $P418."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 124
    find_lex $P419, "$past"
    $P419."arity"(1)
.annotate 'line', 125
    get_hll_global $P420, ["PAST"], "Op"
    find_lex $P421, "$ml"
    unless_null $P421, vivify_247
    $P421 = root_new ['parrot';'Hash']
  vivify_247:
    set $P422, $P421["cond"]
    unless_null $P422, vivify_248
    new $P422, "Undef"
  vivify_248:
    $P423 = $P422."ast"()
    find_lex $P424, "$past"
    find_lex $P425, "$ml"
    unless_null $P425, vivify_249
    $P425 = root_new ['parrot';'Hash']
  vivify_249:
    set $P426, $P425["sym"]
    unless_null $P426, vivify_250
    new $P426, "Undef"
  vivify_250:
    set $S427, $P426
    find_lex $P428, "$/"
    $P429 = $P420."new"($P423, $P424, $S427 :named("pasttype"), $P428 :named("node"))
    store_lex "$past", $P429
.annotate 'line', 119
    set $P407, $P429
  if_408_end:
.annotate 'line', 118
    set $P404, $P407
  if_405_end:
.annotate 'line', 111
    .return ($P404)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("32_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_451
    .param pmc param_452
.annotate 'line', 137
    .lex "self", param_451
    .lex "$/", param_452
.annotate 'line', 138
    find_lex $P453, "$/"
    get_hll_global $P454, ["PAST"], "Op"
    find_lex $P455, "$/"
    unless_null $P455, vivify_251
    $P455 = root_new ['parrot';'Hash']
  vivify_251:
    set $P456, $P455["EXPR"]
    unless_null $P456, vivify_252
    new $P456, "Undef"
  vivify_252:
    $P457 = $P456."ast"()
    find_lex $P458, "$/"
    unless_null $P458, vivify_253
    $P458 = root_new ['parrot';'Hash']
  vivify_253:
    set $P459, $P458["pblock"]
    unless_null $P459, vivify_254
    new $P459, "Undef"
  vivify_254:
    $P460 = $P459."ast"()
    find_lex $P461, "$/"
    $P462 = $P454."new"($P457, $P460, "if" :named("pasttype"), $P461 :named("node"))
    $P463 = $P453."!make"($P462)
.annotate 'line', 137
    .return ($P463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("33_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_465
    .param pmc param_466
.annotate 'line', 141
    .lex "self", param_465
    .lex "$/", param_466
.annotate 'line', 142
    find_lex $P467, "$/"
    find_lex $P468, "$/"
    unless_null $P468, vivify_255
    $P468 = root_new ['parrot';'Hash']
  vivify_255:
    set $P469, $P468["blockoid"]
    unless_null $P469, vivify_256
    new $P469, "Undef"
  vivify_256:
    $P470 = $P469."ast"()
    $P471 = $P467."!make"($P470)
.annotate 'line', 141
    .return ($P471)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("34_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_473
    .param pmc param_474
.annotate 'line', 145
    .lex "self", param_473
    .lex "$/", param_474
.annotate 'line', 146
    find_lex $P475, "$/"
    find_lex $P476, "$/"
    unless_null $P476, vivify_257
    $P476 = root_new ['parrot';'Hash']
  vivify_257:
    set $P477, $P476["blockoid"]
    unless_null $P477, vivify_258
    new $P477, "Undef"
  vivify_258:
    $P478 = $P477."ast"()
    $P479 = $P475."!make"($P478)
.annotate 'line', 145
    .return ($P479)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("35_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_481
    .param pmc param_482
.annotate 'line', 149
    .const 'Sub' $P491 = "36_1299602554.641" 
    capture_lex $P491
    .lex "self", param_481
    .lex "$/", param_482
.annotate 'line', 150
    new $P483, "Undef"
    .lex "$BLOCK", $P483
    get_global $P484, "@BLOCK"
    $P485 = $P484."shift"()
    store_lex "$BLOCK", $P485
.annotate 'line', 151
    find_lex $P488, "$/"
    unless_null $P488, vivify_259
    $P488 = root_new ['parrot';'Hash']
  vivify_259:
    set $P489, $P488["statementlist"]
    unless_null $P489, vivify_260
    new $P489, "Undef"
  vivify_260:
    if $P489, if_487
.annotate 'line', 159
    find_dynamic_lex $P506, "$*HAS_YOU_ARE_HERE"
    unless_null $P506, vivify_261
    get_hll_global $P506, "$HAS_YOU_ARE_HERE"
    unless_null $P506, vivify_262
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_262:
  vivify_261:
    unless $P506, if_505_end
.annotate 'line', 160
    find_lex $P507, "$/"
    $P508 = $P507."CURSOR"()
    $P508."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_505_end:
.annotate 'line', 162
    new $P509, "Integer"
    assign $P509, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P509
.annotate 'line', 163
    find_lex $P510, "$/"
    find_lex $P511, "$/"
    unless_null $P511, vivify_263
    $P511 = root_new ['parrot';'Hash']
  vivify_263:
    set $P512, $P511["you_are_here"]
    unless_null $P512, vivify_264
    new $P512, "Undef"
  vivify_264:
    $P513 = $P512."ast"()
    $P514 = $P510."!make"($P513)
.annotate 'line', 158
    set $P486, $P514
.annotate 'line', 151
    goto if_487_end
  if_487:
    .const 'Sub' $P491 = "36_1299602554.641" 
    capture_lex $P491
    $P504 = $P491()
    set $P486, $P504
  if_487_end:
.annotate 'line', 149
    .return ($P486)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block490"  :anon :subid("36_1299602554.641") :outer("35_1299602554.641")
.annotate 'line', 152
    new $P492, "Undef"
    .lex "$past", $P492
    find_lex $P493, "$/"
    unless_null $P493, vivify_265
    $P493 = root_new ['parrot';'Hash']
  vivify_265:
    set $P494, $P493["statementlist"]
    unless_null $P494, vivify_266
    new $P494, "Undef"
  vivify_266:
    $P495 = $P494."ast"()
    store_lex "$past", $P495
.annotate 'line', 153
    find_lex $P496, "$BLOCK"
    find_lex $P497, "$past"
    $P496."push"($P497)
.annotate 'line', 154
    find_lex $P498, "$BLOCK"
    find_lex $P499, "$/"
    $P498."node"($P499)
.annotate 'line', 155
    find_lex $P500, "$BLOCK"
    $P500."closure"(1)
.annotate 'line', 156
    find_dynamic_lex $P501, "$/"
    find_lex $P502, "$BLOCK"
    $P503 = $P501."!make"($P502)
.annotate 'line', 151
    .return ($P503)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("37_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_516
    .param pmc param_517
.annotate 'line', 167
    .lex "self", param_516
    .lex "$/", param_517
.annotate 'line', 168
    get_global $P518, "@BLOCK"
    unless_null $P518, vivify_267
    $P518 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P518
  vivify_267:
.annotate 'line', 167
    get_global $P519, "@BLOCK"
.annotate 'line', 169
    get_global $P520, "@BLOCK"
    get_hll_global $P521, ["PAST"], "Block"
    get_hll_global $P522, ["PAST"], "Stmts"
    $P523 = $P522."new"()
    $P524 = $P521."new"($P523)
    $P525 = $P520."unshift"($P524)
.annotate 'line', 167
    .return ($P525)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("38_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_527
    .param pmc param_528
.annotate 'line', 172
    .lex "self", param_527
    .lex "$/", param_528
.annotate 'line', 173
    get_global $P529, "@BLOCK"
    unless_null $P529, vivify_268
    $P529 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P529
  vivify_268:
.annotate 'line', 172
    get_global $P530, "@BLOCK"
.annotate 'line', 174
    find_dynamic_lex $P532, "%*COMPILING"
    unless_null $P532, vivify_269
    get_hll_global $P532, "%COMPILING"
    unless_null $P532, vivify_270
    die "Contextual %*COMPILING not found"
  vivify_270:
  vivify_269:
    set $P533, $P532["%?OPTIONS"]
    unless_null $P533, vivify_271
    $P533 = root_new ['parrot';'Hash']
  vivify_271:
    set $P534, $P533["outer_ctx"]
    unless_null $P534, vivify_272
    new $P534, "Undef"
  vivify_272:
    defined $I535, $P534
    if $I535, unless_531_end
.annotate 'line', 177
    find_dynamic_lex $P536, "$*SC"
    unless_null $P536, vivify_273
    get_hll_global $P536, "$SC"
    unless_null $P536, vivify_274
    die "Contextual $*SC not found"
  vivify_274:
  vivify_273:
    find_dynamic_lex $P538, "%*COMPILING"
    unless_null $P538, vivify_275
    get_hll_global $P538, "%COMPILING"
    unless_null $P538, vivify_276
    die "Contextual %*COMPILING not found"
  vivify_276:
  vivify_275:
    set $P539, $P538["%?OPTIONS"]
    unless_null $P539, vivify_277
    $P539 = root_new ['parrot';'Hash']
  vivify_277:
    set $P540, $P539["setting"]
    unless_null $P540, vivify_278
    new $P540, "Undef"
  vivify_278:
    set $P537, $P540
    defined $I542, $P537
    if $I542, default_541
    new $P543, "String"
    assign $P543, "NQPCORE"
    set $P537, $P543
  default_541:
    $P536."load_setting"($P537)
  unless_531_end:
.annotate 'line', 179
    find_lex $P544, "self"
    get_global $P545, "@BLOCK"
    unless_null $P545, vivify_279
    $P545 = root_new ['parrot';'ResizablePMCArray']
  vivify_279:
    set $P546, $P545[0]
    unless_null $P546, vivify_280
    new $P546, "Undef"
  vivify_280:
    $P547 = $P544."SET_BLOCK_OUTER_CTX"($P546)
.annotate 'line', 172
    .return ($P547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("39_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_549
    .param pmc param_550
.annotate 'line', 182
    .lex "self", param_549
    .lex "$/", param_550
.annotate 'line', 183
    find_lex $P551, "$/"
    find_lex $P552, "self"
    $P553 = $P552."CTXSAVE"()
    $P554 = $P551."!make"($P553)
.annotate 'line', 182
    .return ($P554)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("40_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_556
    .param pmc param_557
.annotate 'line', 188
    .const 'Sub' $P585 = "41_1299602554.641" 
    capture_lex $P585
    .lex "self", param_556
    .lex "$/", param_557
.annotate 'line', 189
    new $P558, "Undef"
    .lex "$count", $P558
.annotate 'line', 190
    new $P559, "Undef"
    .lex "$past", $P559
.annotate 'line', 189
    find_lex $P560, "$/"
    unless_null $P560, vivify_281
    $P560 = root_new ['parrot';'Hash']
  vivify_281:
    set $P561, $P560["xblock"]
    unless_null $P561, vivify_282
    new $P561, "Undef"
  vivify_282:
    set $N562, $P561
    new $P563, 'Float'
    set $P563, $N562
    sub $P564, $P563, 1
    store_lex "$count", $P564
.annotate 'line', 190
    find_lex $P565, "$count"
    set $I566, $P565
    find_lex $P567, "$/"
    unless_null $P567, vivify_283
    $P567 = root_new ['parrot';'Hash']
  vivify_283:
    set $P568, $P567["xblock"]
    unless_null $P568, vivify_284
    $P568 = root_new ['parrot';'ResizablePMCArray']
  vivify_284:
    set $P569, $P568[$I566]
    unless_null $P569, vivify_285
    new $P569, "Undef"
  vivify_285:
    $P570 = $P569."ast"()
    $P571 = "xblock_immediate"($P570)
    store_lex "$past", $P571
.annotate 'line', 191
    find_lex $P573, "$/"
    unless_null $P573, vivify_286
    $P573 = root_new ['parrot';'Hash']
  vivify_286:
    set $P574, $P573["else"]
    unless_null $P574, vivify_287
    new $P574, "Undef"
  vivify_287:
    unless $P574, if_572_end
.annotate 'line', 192
    find_lex $P575, "$past"
    find_lex $P576, "$/"
    unless_null $P576, vivify_288
    $P576 = root_new ['parrot';'Hash']
  vivify_288:
    set $P577, $P576["else"]
    unless_null $P577, vivify_289
    $P577 = root_new ['parrot';'ResizablePMCArray']
  vivify_289:
    set $P578, $P577[0]
    unless_null $P578, vivify_290
    new $P578, "Undef"
  vivify_290:
    $P579 = $P578."ast"()
    $P580 = "block_immediate"($P579)
    $P575."push"($P580)
  if_572_end:
.annotate 'line', 195
    new $P601, 'ExceptionHandler'
    set_label $P601, loop600_handler
    $P601."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P601
  loop600_test:
    find_lex $P581, "$count"
    set $N582, $P581
    isgt $I583, $N582, 0.0
    unless $I583, loop600_done
  loop600_redo:
    .const 'Sub' $P585 = "41_1299602554.641" 
    capture_lex $P585
    $P585()
  loop600_next:
    goto loop600_test
  loop600_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P602, exception, 'type'
    eq $P602, .CONTROL_LOOP_NEXT, loop600_next
    eq $P602, .CONTROL_LOOP_REDO, loop600_redo
  loop600_done:
    pop_eh 
.annotate 'line', 201
    find_lex $P603, "$/"
    find_lex $P604, "$past"
    $P605 = $P603."!make"($P604)
.annotate 'line', 188
    .return ($P605)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block584"  :anon :subid("41_1299602554.641") :outer("40_1299602554.641")
.annotate 'line', 197
    new $P586, "Undef"
    .lex "$else", $P586
.annotate 'line', 195
    find_lex $P587, "$count"
    clone $P588, $P587
    dec $P587
.annotate 'line', 197
    find_lex $P589, "$past"
    store_lex "$else", $P589
.annotate 'line', 198
    find_lex $P590, "$count"
    set $I591, $P590
    find_lex $P592, "$/"
    unless_null $P592, vivify_291
    $P592 = root_new ['parrot';'Hash']
  vivify_291:
    set $P593, $P592["xblock"]
    unless_null $P593, vivify_292
    $P593 = root_new ['parrot';'ResizablePMCArray']
  vivify_292:
    set $P594, $P593[$I591]
    unless_null $P594, vivify_293
    new $P594, "Undef"
  vivify_293:
    $P595 = $P594."ast"()
    $P596 = "xblock_immediate"($P595)
    store_lex "$past", $P596
.annotate 'line', 199
    find_lex $P597, "$past"
    find_lex $P598, "$else"
    $P599 = $P597."push"($P598)
.annotate 'line', 195
    .return ($P599)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("42_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_607
    .param pmc param_608
.annotate 'line', 204
    .lex "self", param_607
    .lex "$/", param_608
.annotate 'line', 205
    new $P609, "Undef"
    .lex "$past", $P609
    find_lex $P610, "$/"
    unless_null $P610, vivify_294
    $P610 = root_new ['parrot';'Hash']
  vivify_294:
    set $P611, $P610["xblock"]
    unless_null $P611, vivify_295
    new $P611, "Undef"
  vivify_295:
    $P612 = $P611."ast"()
    $P613 = "xblock_immediate"($P612)
    store_lex "$past", $P613
.annotate 'line', 206
    find_lex $P614, "$past"
    $P614."pasttype"("unless")
.annotate 'line', 207
    find_lex $P615, "$/"
    find_lex $P616, "$past"
    $P617 = $P615."!make"($P616)
.annotate 'line', 204
    .return ($P617)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("43_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_619
    .param pmc param_620
.annotate 'line', 210
    .lex "self", param_619
    .lex "$/", param_620
.annotate 'line', 211
    new $P621, "Undef"
    .lex "$past", $P621
    find_lex $P622, "$/"
    unless_null $P622, vivify_296
    $P622 = root_new ['parrot';'Hash']
  vivify_296:
    set $P623, $P622["xblock"]
    unless_null $P623, vivify_297
    new $P623, "Undef"
  vivify_297:
    $P624 = $P623."ast"()
    $P625 = "xblock_immediate"($P624)
    store_lex "$past", $P625
.annotate 'line', 212
    find_lex $P626, "$past"
    find_lex $P627, "$/"
    unless_null $P627, vivify_298
    $P627 = root_new ['parrot';'Hash']
  vivify_298:
    set $P628, $P627["sym"]
    unless_null $P628, vivify_299
    new $P628, "Undef"
  vivify_299:
    set $S629, $P628
    $P626."pasttype"($S629)
.annotate 'line', 213
    find_lex $P630, "$/"
    find_lex $P631, "$past"
    $P632 = $P630."!make"($P631)
.annotate 'line', 210
    .return ($P632)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("44_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_634
    .param pmc param_635
.annotate 'line', 216
    .lex "self", param_634
    .lex "$/", param_635
.annotate 'line', 217
    new $P636, "Undef"
    .lex "$pasttype", $P636
.annotate 'line', 218
    new $P637, "Undef"
    .lex "$past", $P637
.annotate 'line', 217
    new $P638, "String"
    assign $P638, "repeat_"
    find_lex $P639, "$/"
    unless_null $P639, vivify_300
    $P639 = root_new ['parrot';'Hash']
  vivify_300:
    set $P640, $P639["wu"]
    unless_null $P640, vivify_301
    new $P640, "Undef"
  vivify_301:
    set $S641, $P640
    concat $P642, $P638, $S641
    store_lex "$pasttype", $P642
    find_lex $P643, "$past"
.annotate 'line', 219
    find_lex $P645, "$/"
    unless_null $P645, vivify_302
    $P645 = root_new ['parrot';'Hash']
  vivify_302:
    set $P646, $P645["xblock"]
    unless_null $P646, vivify_303
    new $P646, "Undef"
  vivify_303:
    if $P646, if_644
.annotate 'line', 224
    get_hll_global $P653, ["PAST"], "Op"
    find_lex $P654, "$/"
    unless_null $P654, vivify_304
    $P654 = root_new ['parrot';'Hash']
  vivify_304:
    set $P655, $P654["EXPR"]
    unless_null $P655, vivify_305
    new $P655, "Undef"
  vivify_305:
    $P656 = $P655."ast"()
    find_lex $P657, "$/"
    unless_null $P657, vivify_306
    $P657 = root_new ['parrot';'Hash']
  vivify_306:
    set $P658, $P657["pblock"]
    unless_null $P658, vivify_307
    new $P658, "Undef"
  vivify_307:
    $P659 = $P658."ast"()
    $P660 = "block_immediate"($P659)
    find_lex $P661, "$pasttype"
    find_lex $P662, "$/"
    $P663 = $P653."new"($P656, $P660, $P661 :named("pasttype"), $P662 :named("node"))
    store_lex "$past", $P663
.annotate 'line', 223
    goto if_644_end
  if_644:
.annotate 'line', 220
    find_lex $P647, "$/"
    unless_null $P647, vivify_308
    $P647 = root_new ['parrot';'Hash']
  vivify_308:
    set $P648, $P647["xblock"]
    unless_null $P648, vivify_309
    new $P648, "Undef"
  vivify_309:
    $P649 = $P648."ast"()
    $P650 = "xblock_immediate"($P649)
    store_lex "$past", $P650
.annotate 'line', 221
    find_lex $P651, "$past"
    find_lex $P652, "$pasttype"
    $P651."pasttype"($P652)
  if_644_end:
.annotate 'line', 227
    find_lex $P664, "$/"
    find_lex $P665, "$past"
    $P666 = $P664."!make"($P665)
.annotate 'line', 216
    .return ($P666)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("45_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_668
    .param pmc param_669
.annotate 'line', 230
    .lex "self", param_668
    .lex "$/", param_669
.annotate 'line', 231
    new $P670, "Undef"
    .lex "$past", $P670
.annotate 'line', 233
    new $P671, "Undef"
    .lex "$block", $P671
.annotate 'line', 231
    find_lex $P672, "$/"
    unless_null $P672, vivify_310
    $P672 = root_new ['parrot';'Hash']
  vivify_310:
    set $P673, $P672["xblock"]
    unless_null $P673, vivify_311
    new $P673, "Undef"
  vivify_311:
    $P674 = $P673."ast"()
    store_lex "$past", $P674
.annotate 'line', 232
    find_lex $P675, "$past"
    $P675."pasttype"("for")
.annotate 'line', 233
    find_lex $P676, "$past"
    unless_null $P676, vivify_312
    $P676 = root_new ['parrot';'ResizablePMCArray']
  vivify_312:
    set $P677, $P676[1]
    unless_null $P677, vivify_313
    new $P677, "Undef"
  vivify_313:
    store_lex "$block", $P677
.annotate 'line', 234
    find_lex $P679, "$block"
    $P680 = $P679."arity"()
    if $P680, unless_678_end
.annotate 'line', 235
    find_lex $P681, "$block"
    unless_null $P681, vivify_314
    $P681 = root_new ['parrot';'ResizablePMCArray']
  vivify_314:
    set $P682, $P681[0]
    unless_null $P682, vivify_315
    new $P682, "Undef"
  vivify_315:
    get_hll_global $P683, ["PAST"], "Var"
    $P684 = $P683."new"("$_" :named("name"), "parameter" :named("scope"))
    $P682."push"($P684)
.annotate 'line', 236
    find_lex $P685, "$block"
    $P685."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 237
    find_lex $P686, "$block"
    $P686."arity"(1)
  unless_678_end:
.annotate 'line', 239
    find_lex $P687, "$block"
    $P687."blocktype"("immediate")
.annotate 'line', 240
    find_lex $P688, "$/"
    find_lex $P689, "$past"
    $P690 = $P688."!make"($P689)
.annotate 'line', 230
    .return ($P690)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("46_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_692
    .param pmc param_693
.annotate 'line', 243
    .lex "self", param_692
    .lex "$/", param_693
.annotate 'line', 244
    new $P694, "Undef"
    .lex "$block", $P694
    find_lex $P695, "$/"
    unless_null $P695, vivify_316
    $P695 = root_new ['parrot';'Hash']
  vivify_316:
    set $P696, $P695["block"]
    unless_null $P696, vivify_317
    new $P696, "Undef"
  vivify_317:
    $P697 = $P696."ast"()
    store_lex "$block", $P697
.annotate 'line', 245
    find_lex $P698, "$/"
    find_lex $P699, "$block"
    "push_block_handler"($P698, $P699)
.annotate 'line', 246
    get_global $P700, "@BLOCK"
    unless_null $P700, vivify_318
    $P700 = root_new ['parrot';'ResizablePMCArray']
  vivify_318:
    set $P701, $P700[0]
    unless_null $P701, vivify_319
    new $P701, "Undef"
  vivify_319:
    $P702 = $P701."handlers"()
    set $P703, $P702[0]
    unless_null $P703, vivify_320
    new $P703, "Undef"
  vivify_320:
    $P703."handle_types_except"("CONTROL")
.annotate 'line', 247
    find_lex $P704, "$/"
    get_hll_global $P705, ["PAST"], "Stmts"
    find_lex $P706, "$/"
    $P707 = $P705."new"($P706 :named("node"))
    $P708 = $P704."!make"($P707)
.annotate 'line', 243
    .return ($P708)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("47_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_710
    .param pmc param_711
.annotate 'line', 250
    .lex "self", param_710
    .lex "$/", param_711
.annotate 'line', 251
    new $P712, "Undef"
    .lex "$block", $P712
    find_lex $P713, "$/"
    unless_null $P713, vivify_321
    $P713 = root_new ['parrot';'Hash']
  vivify_321:
    set $P714, $P713["block"]
    unless_null $P714, vivify_322
    new $P714, "Undef"
  vivify_322:
    $P715 = $P714."ast"()
    store_lex "$block", $P715
.annotate 'line', 252
    find_lex $P716, "$/"
    find_lex $P717, "$block"
    "push_block_handler"($P716, $P717)
.annotate 'line', 253
    get_global $P718, "@BLOCK"
    unless_null $P718, vivify_323
    $P718 = root_new ['parrot';'ResizablePMCArray']
  vivify_323:
    set $P719, $P718[0]
    unless_null $P719, vivify_324
    new $P719, "Undef"
  vivify_324:
    $P720 = $P719."handlers"()
    set $P721, $P720[0]
    unless_null $P721, vivify_325
    new $P721, "Undef"
  vivify_325:
    $P721."handle_types"("CONTROL")
.annotate 'line', 254
    find_lex $P722, "$/"
    get_hll_global $P723, ["PAST"], "Stmts"
    find_lex $P724, "$/"
    $P725 = $P723."new"($P724 :named("node"))
    $P726 = $P722."!make"($P725)
.annotate 'line', 250
    .return ($P726)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("48_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_729
    .param pmc param_730
.annotate 'line', 294
    .lex "self", param_729
    .lex "$/", param_730
.annotate 'line', 295
    new $P731, "Undef"
    .lex "$init_block", $P731
    get_hll_global $P732, ["PAST"], "Block"
    $P733 = $P732."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P733
.annotate 'line', 296
    find_lex $P734, "$init_block"
    $P735 = $P734."loadinit"()
    find_lex $P736, "$/"
    unless_null $P736, vivify_326
    $P736 = root_new ['parrot';'Hash']
  vivify_326:
    set $P737, $P736["blorst"]
    unless_null $P737, vivify_327
    new $P737, "Undef"
  vivify_327:
    $P738 = $P737."ast"()
    $P735."push"($P738)
.annotate 'line', 297
    find_lex $P739, "$/"
    find_lex $P740, "$init_block"
    $P741 = $P739."!make"($P740)
.annotate 'line', 294
    .return ($P741)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("49_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_743
    .param pmc param_744
.annotate 'line', 300
    .lex "self", param_743
    .lex "$/", param_744
.annotate 'line', 301
    new $P745, "Undef"
    .lex "$past", $P745
    find_lex $P746, "$/"
    unless_null $P746, vivify_328
    $P746 = root_new ['parrot';'Hash']
  vivify_328:
    set $P747, $P746["blorst"]
    unless_null $P747, vivify_329
    new $P747, "Undef"
  vivify_329:
    $P748 = $P747."ast"()
    store_lex "$past", $P748
.annotate 'line', 302
    get_hll_global $P750, ["PAST"], "Block"
    find_lex $P751, "$past"
    $P752 = $P750."ACCEPTS"($P751)
    if $P752, unless_749_end
.annotate 'line', 303
    get_hll_global $P753, ["PAST"], "Block"
    find_lex $P754, "$past"
    find_lex $P755, "$/"
    $P756 = $P753."new"($P754, "immediate" :named("blocktype"), $P755 :named("node"))
    store_lex "$past", $P756
  unless_749_end:
.annotate 'line', 305
    find_lex $P758, "$past"
    $P759 = $P758."handlers"()
    if $P759, unless_757_end
.annotate 'line', 306
    find_lex $P760, "$past"
    get_hll_global $P761, ["PAST"], "Control"
.annotate 'line', 308
    get_hll_global $P762, ["PAST"], "Stmts"
.annotate 'line', 309
    get_hll_global $P763, ["PAST"], "Op"
.annotate 'line', 310
    get_hll_global $P764, ["PAST"], "Var"
.annotate 'line', 311
    get_hll_global $P765, ["PAST"], "Var"
    $P766 = $P765."new"("register" :named("scope"), "exception" :named("name"))
    $P767 = $P764."new"($P766, "handled", "keyed" :named("scope"))
.annotate 'line', 310
    $P768 = $P763."new"($P767, 1, "bind" :named("pasttype"))
.annotate 'line', 309
    $P769 = $P762."new"($P768)
.annotate 'line', 308
    $P770 = $P761."new"($P769, "CONTROL" :named("handle_types_except"))
.annotate 'line', 306
    new $P771, "ResizablePMCArray"
    push $P771, $P770
    $P760."handlers"($P771)
  unless_757_end:
.annotate 'line', 320
    find_lex $P772, "$/"
    find_lex $P773, "$past"
    $P774 = $P772."!make"($P773)
.annotate 'line', 300
    .return ($P774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("50_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_776
    .param pmc param_777
.annotate 'line', 323
    .lex "self", param_776
    .lex "$/", param_777
.annotate 'line', 324
    find_lex $P778, "$/"
.annotate 'line', 325
    find_lex $P781, "$/"
    unless_null $P781, vivify_330
    $P781 = root_new ['parrot';'Hash']
  vivify_330:
    set $P782, $P781["block"]
    unless_null $P782, vivify_331
    new $P782, "Undef"
  vivify_331:
    if $P782, if_780
.annotate 'line', 326
    find_lex $P787, "$/"
    unless_null $P787, vivify_332
    $P787 = root_new ['parrot';'Hash']
  vivify_332:
    set $P788, $P787["statement"]
    unless_null $P788, vivify_333
    new $P788, "Undef"
  vivify_333:
    $P789 = $P788."ast"()
    set $P779, $P789
.annotate 'line', 325
    goto if_780_end
  if_780:
    find_lex $P783, "$/"
    unless_null $P783, vivify_334
    $P783 = root_new ['parrot';'Hash']
  vivify_334:
    set $P784, $P783["block"]
    unless_null $P784, vivify_335
    new $P784, "Undef"
  vivify_335:
    $P785 = $P784."ast"()
    $P786 = "block_immediate"($P785)
    set $P779, $P786
  if_780_end:
    $P790 = $P778."!make"($P779)
.annotate 'line', 323
    .return ($P790)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("51_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_792
    .param pmc param_793
.annotate 'line', 331
    .lex "self", param_792
    .lex "$/", param_793
    find_lex $P794, "$/"
    find_lex $P795, "$/"
    unless_null $P795, vivify_336
    $P795 = root_new ['parrot';'Hash']
  vivify_336:
    set $P796, $P795["cond"]
    unless_null $P796, vivify_337
    new $P796, "Undef"
  vivify_337:
    $P797 = $P796."ast"()
    $P798 = $P794."!make"($P797)
    .return ($P798)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("52_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_800
    .param pmc param_801
.annotate 'line', 332
    .lex "self", param_800
    .lex "$/", param_801
    find_lex $P802, "$/"
    find_lex $P803, "$/"
    unless_null $P803, vivify_338
    $P803 = root_new ['parrot';'Hash']
  vivify_338:
    set $P804, $P803["cond"]
    unless_null $P804, vivify_339
    new $P804, "Undef"
  vivify_339:
    $P805 = $P804."ast"()
    $P806 = $P802."!make"($P805)
    .return ($P806)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("53_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_808
    .param pmc param_809
.annotate 'line', 334
    .lex "self", param_808
    .lex "$/", param_809
    find_lex $P810, "$/"
    find_lex $P811, "$/"
    unless_null $P811, vivify_340
    $P811 = root_new ['parrot';'Hash']
  vivify_340:
    set $P812, $P811["cond"]
    unless_null $P812, vivify_341
    new $P812, "Undef"
  vivify_341:
    $P813 = $P812."ast"()
    $P814 = $P810."!make"($P813)
    .return ($P814)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("54_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_816
    .param pmc param_817
.annotate 'line', 335
    .lex "self", param_816
    .lex "$/", param_817
    find_lex $P818, "$/"
    find_lex $P819, "$/"
    unless_null $P819, vivify_342
    $P819 = root_new ['parrot';'Hash']
  vivify_342:
    set $P820, $P819["cond"]
    unless_null $P820, vivify_343
    new $P820, "Undef"
  vivify_343:
    $P821 = $P820."ast"()
    $P822 = $P818."!make"($P821)
    .return ($P822)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("55_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_824
    .param pmc param_825
.annotate 'line', 339
    .lex "self", param_824
    .lex "$/", param_825
    find_lex $P826, "$/"
    find_lex $P827, "$/"
    unless_null $P827, vivify_344
    $P827 = root_new ['parrot';'Hash']
  vivify_344:
    set $P828, $P827["fatarrow"]
    unless_null $P828, vivify_345
    new $P828, "Undef"
  vivify_345:
    $P829 = $P828."ast"()
    $P830 = $P826."!make"($P829)
    .return ($P830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("56_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_832
    .param pmc param_833
.annotate 'line', 340
    .lex "self", param_832
    .lex "$/", param_833
    find_lex $P834, "$/"
    find_lex $P835, "$/"
    unless_null $P835, vivify_346
    $P835 = root_new ['parrot';'Hash']
  vivify_346:
    set $P836, $P835["colonpair"]
    unless_null $P836, vivify_347
    new $P836, "Undef"
  vivify_347:
    $P837 = $P836."ast"()
    $P838 = $P834."!make"($P837)
    .return ($P838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("57_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_840
    .param pmc param_841
.annotate 'line', 341
    .lex "self", param_840
    .lex "$/", param_841
    find_lex $P842, "$/"
    find_lex $P843, "$/"
    unless_null $P843, vivify_348
    $P843 = root_new ['parrot';'Hash']
  vivify_348:
    set $P844, $P843["variable"]
    unless_null $P844, vivify_349
    new $P844, "Undef"
  vivify_349:
    $P845 = $P844."ast"()
    $P846 = $P842."!make"($P845)
    .return ($P846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("58_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_848
    .param pmc param_849
.annotate 'line', 342
    .lex "self", param_848
    .lex "$/", param_849
    find_lex $P850, "$/"
    find_lex $P851, "$/"
    unless_null $P851, vivify_350
    $P851 = root_new ['parrot';'Hash']
  vivify_350:
    set $P852, $P851["package_declarator"]
    unless_null $P852, vivify_351
    new $P852, "Undef"
  vivify_351:
    $P853 = $P852."ast"()
    $P854 = $P850."!make"($P853)
    .return ($P854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("59_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_856
    .param pmc param_857
.annotate 'line', 343
    .lex "self", param_856
    .lex "$/", param_857
    find_lex $P858, "$/"
    find_lex $P859, "$/"
    unless_null $P859, vivify_352
    $P859 = root_new ['parrot';'Hash']
  vivify_352:
    set $P860, $P859["scope_declarator"]
    unless_null $P860, vivify_353
    new $P860, "Undef"
  vivify_353:
    $P861 = $P860."ast"()
    $P862 = $P858."!make"($P861)
    .return ($P862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("60_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_864
    .param pmc param_865
.annotate 'line', 344
    .lex "self", param_864
    .lex "$/", param_865
    find_lex $P866, "$/"
    find_lex $P867, "$/"
    unless_null $P867, vivify_354
    $P867 = root_new ['parrot';'Hash']
  vivify_354:
    set $P868, $P867["routine_declarator"]
    unless_null $P868, vivify_355
    new $P868, "Undef"
  vivify_355:
    $P869 = $P868."ast"()
    $P870 = $P866."!make"($P869)
    .return ($P870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("61_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_872
    .param pmc param_873
.annotate 'line', 345
    .lex "self", param_872
    .lex "$/", param_873
    find_lex $P874, "$/"
    find_lex $P875, "$/"
    unless_null $P875, vivify_356
    $P875 = root_new ['parrot';'Hash']
  vivify_356:
    set $P876, $P875["regex_declarator"]
    unless_null $P876, vivify_357
    new $P876, "Undef"
  vivify_357:
    $P877 = $P876."ast"()
    $P878 = $P874."!make"($P877)
    .return ($P878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("62_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_880
    .param pmc param_881
.annotate 'line', 346
    .lex "self", param_880
    .lex "$/", param_881
    find_lex $P882, "$/"
    find_lex $P883, "$/"
    unless_null $P883, vivify_358
    $P883 = root_new ['parrot';'Hash']
  vivify_358:
    set $P884, $P883["statement_prefix"]
    unless_null $P884, vivify_359
    new $P884, "Undef"
  vivify_359:
    $P885 = $P884."ast"()
    $P886 = $P882."!make"($P885)
    .return ($P886)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("63_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_888
    .param pmc param_889
.annotate 'line', 347
    .lex "self", param_888
    .lex "$/", param_889
    find_lex $P890, "$/"
    find_lex $P891, "$/"
    unless_null $P891, vivify_360
    $P891 = root_new ['parrot';'Hash']
  vivify_360:
    set $P892, $P891["pblock"]
    unless_null $P892, vivify_361
    new $P892, "Undef"
  vivify_361:
    $P893 = $P892."ast"()
    $P894 = $P890."!make"($P893)
    .return ($P894)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("64_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_896
    .param pmc param_897
.annotate 'line', 349
    .lex "self", param_896
    .lex "$/", param_897
.annotate 'line', 350
    new $P898, "Undef"
    .lex "$past", $P898
    find_lex $P899, "$/"
    unless_null $P899, vivify_362
    $P899 = root_new ['parrot';'Hash']
  vivify_362:
    set $P900, $P899["val"]
    unless_null $P900, vivify_363
    new $P900, "Undef"
  vivify_363:
    $P901 = $P900."ast"()
    store_lex "$past", $P901
.annotate 'line', 351
    find_lex $P902, "$past"
    find_lex $P903, "$/"
    unless_null $P903, vivify_364
    $P903 = root_new ['parrot';'Hash']
  vivify_364:
    set $P904, $P903["key"]
    unless_null $P904, vivify_365
    new $P904, "Undef"
  vivify_365:
    $P905 = $P904."Str"()
    $P902."named"($P905)
.annotate 'line', 352
    find_lex $P906, "$/"
    find_lex $P907, "$past"
    $P908 = $P906."!make"($P907)
.annotate 'line', 349
    .return ($P908)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("65_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_910
    .param pmc param_911
.annotate 'line', 355
    .lex "self", param_910
    .lex "$/", param_911
.annotate 'line', 356
    new $P912, "Undef"
    .lex "$past", $P912
.annotate 'line', 357
    find_lex $P915, "$/"
    unless_null $P915, vivify_366
    $P915 = root_new ['parrot';'Hash']
  vivify_366:
    set $P916, $P915["circumfix"]
    unless_null $P916, vivify_367
    new $P916, "Undef"
  vivify_367:
    if $P916, if_914
.annotate 'line', 358
    get_hll_global $P921, ["PAST"], "Val"
    find_lex $P922, "$/"
    unless_null $P922, vivify_368
    $P922 = root_new ['parrot';'Hash']
  vivify_368:
    set $P923, $P922["not"]
    unless_null $P923, vivify_369
    new $P923, "Undef"
  vivify_369:
    isfalse $I924, $P923
    $P925 = $P921."new"($I924 :named("value"))
    set $P913, $P925
.annotate 'line', 357
    goto if_914_end
  if_914:
    find_lex $P917, "$/"
    unless_null $P917, vivify_370
    $P917 = root_new ['parrot';'Hash']
  vivify_370:
    set $P918, $P917["circumfix"]
    unless_null $P918, vivify_371
    $P918 = root_new ['parrot';'ResizablePMCArray']
  vivify_371:
    set $P919, $P918[0]
    unless_null $P919, vivify_372
    new $P919, "Undef"
  vivify_372:
    $P920 = $P919."ast"()
    set $P913, $P920
  if_914_end:
    store_lex "$past", $P913
.annotate 'line', 359
    find_lex $P926, "$past"
    find_lex $P927, "$/"
    unless_null $P927, vivify_373
    $P927 = root_new ['parrot';'Hash']
  vivify_373:
    set $P928, $P927["identifier"]
    unless_null $P928, vivify_374
    new $P928, "Undef"
  vivify_374:
    set $S929, $P928
    $P926."named"($S929)
.annotate 'line', 360
    find_lex $P930, "$/"
    find_lex $P931, "$past"
    $P932 = $P930."!make"($P931)
.annotate 'line', 355
    .return ($P932)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("66_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_934
    .param pmc param_935
.annotate 'line', 363
    .const 'Sub' $P948 = "67_1299602554.641" 
    capture_lex $P948
    .lex "self", param_934
    .lex "$/", param_935
.annotate 'line', 364
    new $P936, "Undef"
    .lex "$past", $P936
.annotate 'line', 363
    find_lex $P937, "$past"
.annotate 'line', 365
    find_lex $P939, "$/"
    unless_null $P939, vivify_375
    $P939 = root_new ['parrot';'Hash']
  vivify_375:
    set $P940, $P939["postcircumfix"]
    unless_null $P940, vivify_376
    new $P940, "Undef"
  vivify_376:
    if $P940, if_938
.annotate 'line', 369
    .const 'Sub' $P948 = "67_1299602554.641" 
    capture_lex $P948
    $P948()
    goto if_938_end
  if_938:
.annotate 'line', 366
    find_lex $P941, "$/"
    unless_null $P941, vivify_393
    $P941 = root_new ['parrot';'Hash']
  vivify_393:
    set $P942, $P941["postcircumfix"]
    unless_null $P942, vivify_394
    new $P942, "Undef"
  vivify_394:
    $P943 = $P942."ast"()
    store_lex "$past", $P943
.annotate 'line', 367
    find_lex $P944, "$past"
    get_hll_global $P945, ["PAST"], "Var"
    $P946 = $P945."new"("$/" :named("name"))
    $P944."unshift"($P946)
  if_938_end:
.annotate 'line', 399
    find_lex $P1020, "$/"
    find_lex $P1021, "$past"
    $P1022 = $P1020."!make"($P1021)
.annotate 'line', 363
    .return ($P1022)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block947"  :anon :subid("67_1299602554.641") :outer("66_1299602554.641")
.annotate 'line', 370
    $P949 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P949
    get_hll_global $P950, ["NQP"], "Compiler"
    find_lex $P951, "$/"
    set $S952, $P951
    $P953 = $P950."parse_name"($S952)
    store_lex "@name", $P953
.annotate 'line', 371
    get_hll_global $P954, ["PAST"], "Var"
    find_lex $P955, "@name"
    $P956 = $P955."pop"()
    set $S957, $P956
    $P958 = $P954."new"($S957 :named("name"))
    store_lex "$past", $P958
.annotate 'line', 372
    find_lex $P960, "@name"
    unless $P960, if_959_end
.annotate 'line', 373
    find_lex $P962, "@name"
    unless_null $P962, vivify_377
    $P962 = root_new ['parrot';'ResizablePMCArray']
  vivify_377:
    set $P963, $P962[0]
    unless_null $P963, vivify_378
    new $P963, "Undef"
  vivify_378:
    set $S964, $P963
    iseq $I965, $S964, "GLOBAL"
    unless $I965, if_961_end
    find_lex $P966, "@name"
    $P966."shift"()
  if_961_end:
.annotate 'line', 374
    find_lex $P967, "$past"
    find_lex $P968, "@name"
    $P967."namespace"($P968)
.annotate 'line', 375
    find_lex $P969, "$past"
    $P969."scope"("package")
.annotate 'line', 376
    find_lex $P970, "$past"
    find_lex $P971, "$/"
    unless_null $P971, vivify_379
    $P971 = root_new ['parrot';'Hash']
  vivify_379:
    set $P972, $P971["sigil"]
    unless_null $P972, vivify_380
    new $P972, "Undef"
  vivify_380:
    $P973 = "vivitype"($P972)
    $P970."viviself"($P973)
.annotate 'line', 377
    find_lex $P974, "$past"
    $P974."lvalue"(1)
  if_959_end:
.annotate 'line', 379
    find_lex $P977, "$/"
    unless_null $P977, vivify_381
    $P977 = root_new ['parrot';'Hash']
  vivify_381:
    set $P978, $P977["twigil"]
    unless_null $P978, vivify_382
    $P978 = root_new ['parrot';'ResizablePMCArray']
  vivify_382:
    set $P979, $P978[0]
    unless_null $P979, vivify_383
    new $P979, "Undef"
  vivify_383:
    set $S980, $P979
    iseq $I981, $S980, "*"
    if $I981, if_976
.annotate 'line', 392
    find_lex $P1003, "$/"
    unless_null $P1003, vivify_384
    $P1003 = root_new ['parrot';'Hash']
  vivify_384:
    set $P1004, $P1003["twigil"]
    unless_null $P1004, vivify_385
    $P1004 = root_new ['parrot';'ResizablePMCArray']
  vivify_385:
    set $P1005, $P1004[0]
    unless_null $P1005, vivify_386
    new $P1005, "Undef"
  vivify_386:
    set $S1006, $P1005
    iseq $I1007, $S1006, "!"
    if $I1007, if_1002
    new $P1001, 'Integer'
    set $P1001, $I1007
    goto if_1002_end
  if_1002:
.annotate 'line', 393
    find_lex $P1008, "$past"
    get_hll_global $P1009, ["PAST"], "Var"
    $P1010 = $P1009."new"("self" :named("name"))
    $P1008."push"($P1010)
.annotate 'line', 394
    find_lex $P1011, "$past"
    $P1011."scope"("attribute")
.annotate 'line', 395
    find_lex $P1012, "$past"
    find_lex $P1013, "$/"
    unless_null $P1013, vivify_387
    $P1013 = root_new ['parrot';'Hash']
  vivify_387:
    set $P1014, $P1013["sigil"]
    unless_null $P1014, vivify_388
    new $P1014, "Undef"
  vivify_388:
    $P1015 = "vivitype"($P1014)
    $P1012."viviself"($P1015)
.annotate 'line', 396
    find_lex $P1016, "$past"
    get_hll_global $P1017, ["PAST"], "Var"
    $P1018 = $P1017."new"("$?CLASS" :named("name"))
    $P1019 = $P1016."push"($P1018)
.annotate 'line', 392
    set $P1001, $P1019
  if_1002_end:
    set $P975, $P1001
.annotate 'line', 379
    goto if_976_end
  if_976:
.annotate 'line', 380
    find_lex $P982, "$past"
    $P982."scope"("contextual")
.annotate 'line', 381
    find_lex $P983, "$past"
.annotate 'line', 382
    get_hll_global $P984, ["PAST"], "Var"
.annotate 'line', 384
    find_lex $P985, "$/"
    unless_null $P985, vivify_389
    $P985 = root_new ['parrot';'Hash']
  vivify_389:
    set $P986, $P985["sigil"]
    unless_null $P986, vivify_390
    new $P986, "Undef"
  vivify_390:
    set $S987, $P986
    new $P988, 'String'
    set $P988, $S987
    find_lex $P989, "$/"
    unless_null $P989, vivify_391
    $P989 = root_new ['parrot';'Hash']
  vivify_391:
    set $P990, $P989["desigilname"]
    unless_null $P990, vivify_392
    new $P990, "Undef"
  vivify_392:
    concat $P991, $P988, $P990
.annotate 'line', 386
    get_hll_global $P992, ["PAST"], "Op"
    new $P993, "String"
    assign $P993, "Contextual "
    find_lex $P994, "$/"
    set $S995, $P994
    concat $P996, $P993, $S995
    concat $P997, $P996, " not found"
    $P998 = $P992."new"($P997, "die" :named("pirop"))
    $P999 = $P984."new"("package" :named("scope"), "" :named("namespace"), $P991 :named("name"), $P998 :named("viviself"))
.annotate 'line', 382
    $P1000 = $P983."viviself"($P999)
.annotate 'line', 379
    set $P975, $P1000
  if_976_end:
.annotate 'line', 369
    .return ($P975)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("68_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1024
    .param pmc param_1025
.annotate 'line', 402
    .lex "self", param_1024
    .lex "$/", param_1025
    find_lex $P1026, "$/"
    find_lex $P1027, "$/"
    unless_null $P1027, vivify_395
    $P1027 = root_new ['parrot';'Hash']
  vivify_395:
    set $P1028, $P1027["package_def"]
    unless_null $P1028, vivify_396
    new $P1028, "Undef"
  vivify_396:
    $P1029 = $P1028."ast"()
    $P1030 = $P1026."!make"($P1029)
    .return ($P1030)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("69_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1032
    .param pmc param_1033
.annotate 'line', 403
    .lex "self", param_1032
    .lex "$/", param_1033
    find_lex $P1034, "$/"
    find_lex $P1035, "$/"
    unless_null $P1035, vivify_397
    $P1035 = root_new ['parrot';'Hash']
  vivify_397:
    set $P1036, $P1035["package_def"]
    unless_null $P1036, vivify_398
    new $P1036, "Undef"
  vivify_398:
    $P1037 = $P1036."ast"()
    $P1038 = $P1034."!make"($P1037)
    .return ($P1038)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("70_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1040
    .param pmc param_1041
.annotate 'line', 404
    .lex "self", param_1040
    .lex "$/", param_1041
    find_lex $P1042, "$/"
    find_lex $P1043, "$/"
    unless_null $P1043, vivify_399
    $P1043 = root_new ['parrot';'Hash']
  vivify_399:
    set $P1044, $P1043["package_def"]
    unless_null $P1044, vivify_400
    new $P1044, "Undef"
  vivify_400:
    $P1045 = $P1044."ast"()
    $P1046 = $P1042."!make"($P1045)
    .return ($P1046)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("71_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1048
    .param pmc param_1049
.annotate 'line', 405
    .lex "self", param_1048
    .lex "$/", param_1049
    find_lex $P1050, "$/"
    find_lex $P1051, "$/"
    unless_null $P1051, vivify_401
    $P1051 = root_new ['parrot';'Hash']
  vivify_401:
    set $P1052, $P1051["package_def"]
    unless_null $P1052, vivify_402
    new $P1052, "Undef"
  vivify_402:
    $P1053 = $P1052."ast"()
    $P1054 = $P1050."!make"($P1053)
    .return ($P1054)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("72_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1056
    .param pmc param_1057
.annotate 'line', 406
    .lex "self", param_1056
    .lex "$/", param_1057
    find_lex $P1058, "$/"
    find_lex $P1059, "$/"
    unless_null $P1059, vivify_403
    $P1059 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1060, $P1059["package_def"]
    unless_null $P1060, vivify_404
    new $P1060, "Undef"
  vivify_404:
    $P1061 = $P1060."ast"()
    $P1062 = $P1058."!make"($P1061)
    .return ($P1062)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("73_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1064
    .param pmc param_1065
.annotate 'line', 407
    .lex "self", param_1064
    .lex "$/", param_1065
    find_lex $P1066, "$/"
    find_lex $P1067, "$/"
    unless_null $P1067, vivify_405
    $P1067 = root_new ['parrot';'Hash']
  vivify_405:
    set $P1068, $P1067["package_def"]
    unless_null $P1068, vivify_406
    new $P1068, "Undef"
  vivify_406:
    $P1069 = $P1068."ast"()
    $P1070 = $P1066."!make"($P1069)
    .return ($P1070)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("74_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1072
    .param pmc param_1073
.annotate 'line', 409
    .const 'Sub' $P1212 = "76_1299602554.641" 
    capture_lex $P1212
    .const 'Sub' $P1161 = "75_1299602554.641" 
    capture_lex $P1161
    .lex "self", param_1072
    .lex "$/", param_1073
.annotate 'line', 411
    $P1074 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1074
.annotate 'line', 412
    new $P1075, "Undef"
    .lex "$name", $P1075
.annotate 'line', 413
    new $P1076, "Undef"
    .lex "$how", $P1076
.annotate 'line', 416
    new $P1077, "Undef"
    .lex "$past", $P1077
.annotate 'line', 411
    find_lex $P1078, "$/"
    unless_null $P1078, vivify_407
    $P1078 = root_new ['parrot';'Hash']
  vivify_407:
    set $P1079, $P1078["name"]
    unless_null $P1079, vivify_408
    $P1079 = root_new ['parrot';'Hash']
  vivify_408:
    set $P1080, $P1079["identifier"]
    unless_null $P1080, vivify_409
    new $P1080, "Undef"
  vivify_409:
    clone $P1081, $P1080
    store_lex "@ns", $P1081
.annotate 'line', 412
    find_lex $P1082, "@ns"
    $P1083 = $P1082."pop"()
    set $S1084, $P1083
    new $P1085, 'String'
    set $P1085, $S1084
    store_lex "$name", $P1085
.annotate 'line', 413
    find_dynamic_lex $P1086, "$*PKGDECL"
    unless_null $P1086, vivify_410
    get_hll_global $P1086, "$PKGDECL"
    unless_null $P1086, vivify_411
    die "Contextual $*PKGDECL not found"
  vivify_411:
  vivify_410:
    find_dynamic_lex $P1087, "%*HOW"
    unless_null $P1087, vivify_412
    get_hll_global $P1087, "%HOW"
    unless_null $P1087, vivify_413
    die "Contextual %*HOW not found"
  vivify_413:
  vivify_412:
    set $P1088, $P1087[$P1086]
    unless_null $P1088, vivify_414
    new $P1088, "Undef"
  vivify_414:
    store_lex "$how", $P1088
.annotate 'line', 416
    find_lex $P1091, "$/"
    unless_null $P1091, vivify_415
    $P1091 = root_new ['parrot';'Hash']
  vivify_415:
    set $P1092, $P1091["block"]
    unless_null $P1092, vivify_416
    new $P1092, "Undef"
  vivify_416:
    if $P1092, if_1090
    find_lex $P1096, "$/"
    unless_null $P1096, vivify_417
    $P1096 = root_new ['parrot';'Hash']
  vivify_417:
    set $P1097, $P1096["comp_unit"]
    unless_null $P1097, vivify_418
    new $P1097, "Undef"
  vivify_418:
    $P1098 = $P1097."ast"()
    set $P1089, $P1098
    goto if_1090_end
  if_1090:
    find_lex $P1093, "$/"
    unless_null $P1093, vivify_419
    $P1093 = root_new ['parrot';'Hash']
  vivify_419:
    set $P1094, $P1093["block"]
    unless_null $P1094, vivify_420
    new $P1094, "Undef"
  vivify_420:
    $P1095 = $P1094."ast"()
    set $P1089, $P1095
  if_1090_end:
    store_lex "$past", $P1089
.annotate 'line', 417
    find_lex $P1099, "$past"
    find_lex $P1100, "$/"
    unless_null $P1100, vivify_421
    $P1100 = root_new ['parrot';'Hash']
  vivify_421:
    set $P1101, $P1100["name"]
    unless_null $P1101, vivify_422
    $P1101 = root_new ['parrot';'Hash']
  vivify_422:
    set $P1102, $P1101["identifier"]
    unless_null $P1102, vivify_423
    new $P1102, "Undef"
  vivify_423:
    $P1099."namespace"($P1102)
.annotate 'line', 421
    find_dynamic_lex $P1103, "$*PACKAGE-SETUP"
    unless_null $P1103, vivify_424
    get_hll_global $P1103, "$PACKAGE-SETUP"
    unless_null $P1103, vivify_425
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_425:
  vivify_424:
    get_hll_global $P1104, ["PAST"], "Stmts"
.annotate 'line', 422
    get_hll_global $P1105, ["PAST"], "Op"
.annotate 'line', 423
    get_hll_global $P1106, ["PAST"], "Var"
    $P1107 = $P1106."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 424
    find_dynamic_lex $P1108, "$*SC"
    unless_null $P1108, vivify_426
    get_hll_global $P1108, "$SC"
    unless_null $P1108, vivify_427
    die "Contextual $*SC not found"
  vivify_427:
  vivify_426:
    find_dynamic_lex $P1109, "$*PKGMETA"
    unless_null $P1109, vivify_428
    get_hll_global $P1109, "$PKGMETA"
    unless_null $P1109, vivify_429
    die "Contextual $*PKGMETA not found"
  vivify_429:
  vivify_428:
    $P1110 = $P1108."get_slot_past_for_object"($P1109)
    $P1111 = $P1105."new"($P1107, $P1110, "bind" :named("pasttype"))
.annotate 'line', 426
    get_hll_global $P1112, ["PAST"], "Op"
.annotate 'line', 427
    get_hll_global $P1113, ["PAST"], "Var"
    find_lex $P1114, "$name"
    find_lex $P1115, "@ns"
    $P1116 = $P1113."new"($P1114 :named("name"), $P1115 :named("namespace"), "package" :named("scope"))
.annotate 'line', 428
    get_hll_global $P1117, ["PAST"], "Var"
    $P1118 = $P1117."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1119 = $P1112."new"($P1116, $P1118, "bind" :named("pasttype"))
.annotate 'line', 430
    get_hll_global $P1120, ["PAST"], "Op"
.annotate 'line', 431
    get_hll_global $P1121, ["PAST"], "Var"
    $P1122 = $P1121."new"("$?CLASS" :named("name"))
.annotate 'line', 432
    get_hll_global $P1123, ["PAST"], "Var"
    $P1124 = $P1123."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1125 = $P1120."new"($P1122, $P1124, "bind" :named("pasttype"))
.annotate 'line', 430
    $P1126 = $P1104."new"($P1111, $P1119, $P1125)
.annotate 'line', 421
    $P1103."unshift"($P1126)
.annotate 'line', 441
    find_lex $P1130, "$how"
    can $I1131, $P1130, "parametric"
    if $I1131, if_1129
    new $P1128, 'Integer'
    set $P1128, $I1131
    goto if_1129_end
  if_1129:
    find_lex $P1132, "$how"
    find_lex $P1133, "$how"
    $P1134 = $P1132."parametric"($P1133)
    set $P1128, $P1134
  if_1129_end:
    if $P1128, if_1127
.annotate 'line', 457
    find_lex $P1152, "$past"
    $P1152."blocktype"("immediate")
.annotate 'line', 458
    find_lex $P1153, "$past"
    get_hll_global $P1154, ["PAST"], "Var"
    $P1155 = $P1154."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1153."unshift"($P1155)
.annotate 'line', 459
    find_lex $P1156, "$past"
    $P1156."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 456
    goto if_1127_end
  if_1127:
.annotate 'line', 442
    find_lex $P1135, "$past"
    $P1135."blocktype"("declaration")
.annotate 'line', 443
    find_lex $P1136, "$past"
    get_hll_global $P1137, ["PAST"], "Var"
    $P1138 = $P1137."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1136."unshift"($P1138)
.annotate 'line', 444
    find_lex $P1139, "$past"
    $P1139."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 445
    find_dynamic_lex $P1140, "$*PACKAGE-SETUP"
    unless_null $P1140, vivify_430
    get_hll_global $P1140, "$PACKAGE-SETUP"
    unless_null $P1140, vivify_431
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_431:
  vivify_430:
    get_hll_global $P1141, ["PAST"], "Op"
.annotate 'line', 447
    get_hll_global $P1142, ["PAST"], "Op"
.annotate 'line', 450
    get_hll_global $P1143, ["PAST"], "Var"
    $P1144 = $P1143."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1145 = $P1142."new"($P1144, "get_how PP" :named("pirop"))
.annotate 'line', 452
    get_hll_global $P1146, ["PAST"], "Var"
    $P1147 = $P1146."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 453
    get_hll_global $P1148, ["PAST"], "Val"
    find_lex $P1149, "$past"
    $P1150 = $P1148."new"($P1149 :named("value"))
    $P1151 = $P1141."new"($P1145, $P1147, $P1150, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 445
    $P1140."push"($P1151)
  if_1127_end:
.annotate 'line', 464
    find_lex $P1158, "$/"
    unless_null $P1158, vivify_432
    $P1158 = root_new ['parrot';'Hash']
  vivify_432:
    set $P1159, $P1158["parent"]
    unless_null $P1159, vivify_433
    new $P1159, "Undef"
  vivify_433:
    if $P1159, if_1157
.annotate 'line', 478
    find_dynamic_lex $P1189, "$*PKGDECL"
    unless_null $P1189, vivify_434
    get_hll_global $P1189, "$PKGDECL"
    unless_null $P1189, vivify_435
    die "Contextual $*PKGDECL not found"
  vivify_435:
  vivify_434:
    set $S1190, $P1189
    iseq $I1191, $S1190, "grammar"
    unless $I1191, if_1188_end
.annotate 'line', 479
    find_dynamic_lex $P1192, "$*PACKAGE-SETUP"
    unless_null $P1192, vivify_436
    get_hll_global $P1192, "$PACKAGE-SETUP"
    unless_null $P1192, vivify_437
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_437:
  vivify_436:
    get_hll_global $P1193, ["PAST"], "Op"
.annotate 'line', 481
    get_hll_global $P1194, ["PAST"], "Op"
.annotate 'line', 484
    get_hll_global $P1195, ["PAST"], "Var"
    $P1196 = $P1195."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1197 = $P1194."new"($P1196, "get_how PP" :named("pirop"))
.annotate 'line', 486
    get_hll_global $P1198, ["PAST"], "Var"
    $P1199 = $P1198."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 487
    get_hll_global $P1200, ["PAST"], "Var"
    $P1201 = $P1200."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1202 = $P1193."new"($P1197, $P1199, $P1201, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 479
    $P1192."push"($P1202)
  if_1188_end:
.annotate 'line', 478
    goto if_1157_end
  if_1157:
.annotate 'line', 464
    .const 'Sub' $P1161 = "75_1299602554.641" 
    capture_lex $P1161
    $P1161()
  if_1157_end:
.annotate 'line', 492
    find_lex $P1204, "$/"
    unless_null $P1204, vivify_444
    $P1204 = root_new ['parrot';'Hash']
  vivify_444:
    set $P1205, $P1204["role"]
    unless_null $P1205, vivify_445
    new $P1205, "Undef"
  vivify_445:
    unless $P1205, if_1203_end
.annotate 'line', 493
    find_lex $P1207, "$/"
    unless_null $P1207, vivify_446
    $P1207 = root_new ['parrot';'Hash']
  vivify_446:
    set $P1208, $P1207["role"]
    unless_null $P1208, vivify_447
    new $P1208, "Undef"
  vivify_447:
    defined $I1209, $P1208
    unless $I1209, for_undef_448
    iter $P1206, $P1208
    new $P1239, 'ExceptionHandler'
    set_label $P1239, loop1238_handler
    $P1239."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1239
  loop1238_test:
    unless $P1206, loop1238_done
    shift $P1210, $P1206
  loop1238_redo:
    .const 'Sub' $P1212 = "76_1299602554.641" 
    capture_lex $P1212
    $P1212($P1210)
  loop1238_next:
    goto loop1238_test
  loop1238_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1240, exception, 'type'
    eq $P1240, .CONTROL_LOOP_NEXT, loop1238_next
    eq $P1240, .CONTROL_LOOP_REDO, loop1238_redo
  loop1238_done:
    pop_eh 
  for_undef_448:
  if_1203_end:
.annotate 'line', 510
    find_dynamic_lex $P1241, "$*PACKAGE-SETUP"
    unless_null $P1241, vivify_453
    get_hll_global $P1241, "$PACKAGE-SETUP"
    unless_null $P1241, vivify_454
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_454:
  vivify_453:
    get_hll_global $P1242, ["PAST"], "Op"
.annotate 'line', 512
    get_hll_global $P1243, ["PAST"], "Op"
.annotate 'line', 515
    get_hll_global $P1244, ["PAST"], "Var"
    $P1245 = $P1244."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1246 = $P1243."new"($P1245, "get_how PP" :named("pirop"))
.annotate 'line', 517
    get_hll_global $P1247, ["PAST"], "Var"
    $P1248 = $P1247."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1249 = $P1242."new"($P1246, $P1248, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 510
    $P1241."push"($P1249)
.annotate 'line', 521
    get_global $P1250, "@BLOCK"
    unless_null $P1250, vivify_455
    $P1250 = root_new ['parrot';'ResizablePMCArray']
  vivify_455:
    set $P1251, $P1250[0]
    unless_null $P1251, vivify_456
    $P1251 = root_new ['parrot';'ResizablePMCArray']
  vivify_456:
    set $P1252, $P1251[0]
    unless_null $P1252, vivify_457
    new $P1252, "Undef"
  vivify_457:
    get_hll_global $P1253, ["PAST"], "Var"
    find_lex $P1254, "$name"
    find_lex $P1255, "@ns"
    $P1256 = $P1253."new"($P1254 :named("name"), $P1255 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P1252."unshift"($P1256)
.annotate 'line', 524
    find_lex $P1257, "$past"
    $P1258 = $P1257."loadinit"()
    get_hll_global $P1259, ["PAST"], "Block"
    find_dynamic_lex $P1260, "$*PACKAGE-SETUP"
    unless_null $P1260, vivify_458
    get_hll_global $P1260, "$PACKAGE-SETUP"
    unless_null $P1260, vivify_459
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_459:
  vivify_458:
    $P1261 = $P1259."new"($P1260, "immediate" :named("blocktype"))
    $P1258."push"($P1261)
.annotate 'line', 526
    find_lex $P1262, "$/"
    find_lex $P1263, "$past"
    $P1264 = $P1262."!make"($P1263)
.annotate 'line', 409
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1160"  :anon :subid("75_1299602554.641") :outer("74_1299602554.641")
.annotate 'line', 465
    $P1162 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1162
.annotate 'line', 466
    new $P1163, "Undef"
    .lex "$name", $P1163
.annotate 'line', 465
    find_lex $P1164, "$/"
    unless_null $P1164, vivify_438
    $P1164 = root_new ['parrot';'Hash']
  vivify_438:
    set $P1165, $P1164["parent"]
    unless_null $P1165, vivify_439
    $P1165 = root_new ['parrot';'ResizablePMCArray']
  vivify_439:
    set $P1166, $P1165[0]
    unless_null $P1166, vivify_440
    $P1166 = root_new ['parrot';'Hash']
  vivify_440:
    set $P1167, $P1166["identifier"]
    unless_null $P1167, vivify_441
    new $P1167, "Undef"
  vivify_441:
    clone $P1168, $P1167
    store_lex "@ns", $P1168
.annotate 'line', 466
    find_lex $P1169, "@ns"
    $P1170 = $P1169."pop"()
    set $S1171, $P1170
    new $P1172, 'String'
    set $P1172, $S1171
    store_lex "$name", $P1172
.annotate 'line', 467
    find_dynamic_lex $P1173, "$*PACKAGE-SETUP"
    unless_null $P1173, vivify_442
    get_hll_global $P1173, "$PACKAGE-SETUP"
    unless_null $P1173, vivify_443
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_443:
  vivify_442:
    get_hll_global $P1174, ["PAST"], "Op"
.annotate 'line', 469
    get_hll_global $P1175, ["PAST"], "Op"
.annotate 'line', 472
    get_hll_global $P1176, ["PAST"], "Var"
    $P1177 = $P1176."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1178 = $P1175."new"($P1177, "get_how PP" :named("pirop"))
.annotate 'line', 474
    get_hll_global $P1179, ["PAST"], "Var"
    $P1180 = $P1179."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 475
    get_hll_global $P1181, ["PAST"], "Var"
    find_lex $P1182, "$name"
    set $S1183, $P1182
    find_lex $P1184, "@ns"
    $P1185 = $P1181."new"($S1183 :named("name"), $P1184 :named("namespace"), "package" :named("scope"))
    $P1186 = $P1174."new"($P1178, $P1180, $P1185, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 467
    $P1187 = $P1173."push"($P1186)
.annotate 'line', 464
    .return ($P1187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1211"  :anon :subid("76_1299602554.641") :outer("74_1299602554.641")
    .param pmc param_1215
.annotate 'line', 494
    $P1213 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1213
.annotate 'line', 495
    new $P1214, "Undef"
    .lex "$name", $P1214
    .lex "$_", param_1215
.annotate 'line', 494
    find_lex $P1216, "$_"
    unless_null $P1216, vivify_449
    $P1216 = root_new ['parrot';'Hash']
  vivify_449:
    set $P1217, $P1216["identifier"]
    unless_null $P1217, vivify_450
    new $P1217, "Undef"
  vivify_450:
    clone $P1218, $P1217
    store_lex "@ns", $P1218
.annotate 'line', 495
    find_lex $P1219, "@ns"
    $P1220 = $P1219."pop"()
    set $S1221, $P1220
    new $P1222, 'String'
    set $P1222, $S1221
    store_lex "$name", $P1222
.annotate 'line', 496
    find_dynamic_lex $P1223, "$*PACKAGE-SETUP"
    unless_null $P1223, vivify_451
    get_hll_global $P1223, "$PACKAGE-SETUP"
    unless_null $P1223, vivify_452
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_452:
  vivify_451:
    get_hll_global $P1224, ["PAST"], "Op"
.annotate 'line', 498
    get_hll_global $P1225, ["PAST"], "Op"
.annotate 'line', 501
    get_hll_global $P1226, ["PAST"], "Var"
    $P1227 = $P1226."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1228 = $P1225."new"($P1227, "get_how PP" :named("pirop"))
.annotate 'line', 503
    get_hll_global $P1229, ["PAST"], "Var"
    $P1230 = $P1229."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 504
    get_hll_global $P1231, ["PAST"], "Var"
    find_lex $P1232, "$name"
    set $S1233, $P1232
    find_lex $P1234, "@ns"
    $P1235 = $P1231."new"($S1233 :named("name"), $P1234 :named("namespace"), "package" :named("scope"))
    $P1236 = $P1224."new"($P1228, $P1230, $P1235, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 496
    $P1237 = $P1223."push"($P1236)
.annotate 'line', 493
    .return ($P1237)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("77_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1266
    .param pmc param_1267
.annotate 'line', 529
    .lex "self", param_1266
    .lex "$/", param_1267
    find_lex $P1268, "$/"
    find_lex $P1269, "$/"
    unless_null $P1269, vivify_460
    $P1269 = root_new ['parrot';'Hash']
  vivify_460:
    set $P1270, $P1269["scoped"]
    unless_null $P1270, vivify_461
    new $P1270, "Undef"
  vivify_461:
    $P1271 = $P1270."ast"()
    $P1272 = $P1268."!make"($P1271)
    .return ($P1272)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("78_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1274
    .param pmc param_1275
.annotate 'line', 530
    .lex "self", param_1274
    .lex "$/", param_1275
    find_lex $P1276, "$/"
    find_lex $P1277, "$/"
    unless_null $P1277, vivify_462
    $P1277 = root_new ['parrot';'Hash']
  vivify_462:
    set $P1278, $P1277["scoped"]
    unless_null $P1278, vivify_463
    new $P1278, "Undef"
  vivify_463:
    $P1279 = $P1278."ast"()
    $P1280 = $P1276."!make"($P1279)
    .return ($P1280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("79_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1282
    .param pmc param_1283
.annotate 'line', 531
    .lex "self", param_1282
    .lex "$/", param_1283
    find_lex $P1284, "$/"
    find_lex $P1285, "$/"
    unless_null $P1285, vivify_464
    $P1285 = root_new ['parrot';'Hash']
  vivify_464:
    set $P1286, $P1285["scoped"]
    unless_null $P1286, vivify_465
    new $P1286, "Undef"
  vivify_465:
    $P1287 = $P1286."ast"()
    $P1288 = $P1284."!make"($P1287)
    .return ($P1288)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("80_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1290
    .param pmc param_1291
.annotate 'line', 533
    .lex "self", param_1290
    .lex "$/", param_1291
.annotate 'line', 534
    find_lex $P1292, "$/"
.annotate 'line', 535
    find_lex $P1295, "$/"
    unless_null $P1295, vivify_466
    $P1295 = root_new ['parrot';'Hash']
  vivify_466:
    set $P1296, $P1295["declarator"]
    unless_null $P1296, vivify_467
    new $P1296, "Undef"
  vivify_467:
    if $P1296, if_1294
.annotate 'line', 536
    find_lex $P1300, "$/"
    unless_null $P1300, vivify_468
    $P1300 = root_new ['parrot';'Hash']
  vivify_468:
    set $P1301, $P1300["multi_declarator"]
    unless_null $P1301, vivify_469
    new $P1301, "Undef"
  vivify_469:
    $P1302 = $P1301."ast"()
    set $P1293, $P1302
.annotate 'line', 535
    goto if_1294_end
  if_1294:
    find_lex $P1297, "$/"
    unless_null $P1297, vivify_470
    $P1297 = root_new ['parrot';'Hash']
  vivify_470:
    set $P1298, $P1297["declarator"]
    unless_null $P1298, vivify_471
    new $P1298, "Undef"
  vivify_471:
    $P1299 = $P1298."ast"()
    set $P1293, $P1299
  if_1294_end:
    $P1303 = $P1292."!make"($P1293)
.annotate 'line', 533
    .return ($P1303)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("81_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1305
    .param pmc param_1306
.annotate 'line', 539
    .lex "self", param_1305
    .lex "$/", param_1306
.annotate 'line', 540
    find_lex $P1307, "$/"
.annotate 'line', 541
    find_lex $P1310, "$/"
    unless_null $P1310, vivify_472
    $P1310 = root_new ['parrot';'Hash']
  vivify_472:
    set $P1311, $P1310["routine_declarator"]
    unless_null $P1311, vivify_473
    new $P1311, "Undef"
  vivify_473:
    if $P1311, if_1309
.annotate 'line', 542
    find_lex $P1315, "$/"
    unless_null $P1315, vivify_474
    $P1315 = root_new ['parrot';'Hash']
  vivify_474:
    set $P1316, $P1315["variable_declarator"]
    unless_null $P1316, vivify_475
    new $P1316, "Undef"
  vivify_475:
    $P1317 = $P1316."ast"()
    set $P1308, $P1317
.annotate 'line', 541
    goto if_1309_end
  if_1309:
    find_lex $P1312, "$/"
    unless_null $P1312, vivify_476
    $P1312 = root_new ['parrot';'Hash']
  vivify_476:
    set $P1313, $P1312["routine_declarator"]
    unless_null $P1313, vivify_477
    new $P1313, "Undef"
  vivify_477:
    $P1314 = $P1313."ast"()
    set $P1308, $P1314
  if_1309_end:
    $P1318 = $P1307."!make"($P1308)
.annotate 'line', 539
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("82_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1320
    .param pmc param_1321
.annotate 'line', 545
    .lex "self", param_1320
    .lex "$/", param_1321
    find_lex $P1322, "$/"
    find_lex $P1325, "$/"
    unless_null $P1325, vivify_478
    $P1325 = root_new ['parrot';'Hash']
  vivify_478:
    set $P1326, $P1325["declarator"]
    unless_null $P1326, vivify_479
    new $P1326, "Undef"
  vivify_479:
    if $P1326, if_1324
    find_lex $P1330, "$/"
    unless_null $P1330, vivify_480
    $P1330 = root_new ['parrot';'Hash']
  vivify_480:
    set $P1331, $P1330["routine_def"]
    unless_null $P1331, vivify_481
    new $P1331, "Undef"
  vivify_481:
    $P1332 = $P1331."ast"()
    set $P1323, $P1332
    goto if_1324_end
  if_1324:
    find_lex $P1327, "$/"
    unless_null $P1327, vivify_482
    $P1327 = root_new ['parrot';'Hash']
  vivify_482:
    set $P1328, $P1327["declarator"]
    unless_null $P1328, vivify_483
    new $P1328, "Undef"
  vivify_483:
    $P1329 = $P1328."ast"()
    set $P1323, $P1329
  if_1324_end:
    $P1333 = $P1322."!make"($P1323)
    .return ($P1333)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("83_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1335
    .param pmc param_1336
.annotate 'line', 546
    .lex "self", param_1335
    .lex "$/", param_1336
    find_lex $P1337, "$/"
    find_lex $P1340, "$/"
    unless_null $P1340, vivify_484
    $P1340 = root_new ['parrot';'Hash']
  vivify_484:
    set $P1341, $P1340["declarator"]
    unless_null $P1341, vivify_485
    new $P1341, "Undef"
  vivify_485:
    if $P1341, if_1339
    find_lex $P1345, "$/"
    unless_null $P1345, vivify_486
    $P1345 = root_new ['parrot';'Hash']
  vivify_486:
    set $P1346, $P1345["routine_def"]
    unless_null $P1346, vivify_487
    new $P1346, "Undef"
  vivify_487:
    $P1347 = $P1346."ast"()
    set $P1338, $P1347
    goto if_1339_end
  if_1339:
    find_lex $P1342, "$/"
    unless_null $P1342, vivify_488
    $P1342 = root_new ['parrot';'Hash']
  vivify_488:
    set $P1343, $P1342["declarator"]
    unless_null $P1343, vivify_489
    new $P1343, "Undef"
  vivify_489:
    $P1344 = $P1343."ast"()
    set $P1338, $P1344
  if_1339_end:
    $P1348 = $P1337."!make"($P1338)
    .return ($P1348)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("84_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1350
    .param pmc param_1351
.annotate 'line', 547
    .lex "self", param_1350
    .lex "$/", param_1351
    find_lex $P1352, "$/"
    find_lex $P1353, "$/"
    unless_null $P1353, vivify_490
    $P1353 = root_new ['parrot';'Hash']
  vivify_490:
    set $P1354, $P1353["declarator"]
    unless_null $P1354, vivify_491
    new $P1354, "Undef"
  vivify_491:
    $P1355 = $P1354."ast"()
    $P1356 = $P1352."!make"($P1355)
    .return ($P1356)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("85_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1358
    .param pmc param_1359
.annotate 'line', 550
    .const 'Sub' $P1431 = "88_1299602554.641" 
    capture_lex $P1431
    .const 'Sub' $P1386 = "86_1299602554.641" 
    capture_lex $P1386
    .lex "self", param_1358
    .lex "$/", param_1359
.annotate 'line', 551
    new $P1360, "Undef"
    .lex "$past", $P1360
.annotate 'line', 552
    new $P1361, "Undef"
    .lex "$sigil", $P1361
.annotate 'line', 553
    new $P1362, "Undef"
    .lex "$name", $P1362
.annotate 'line', 554
    new $P1363, "Undef"
    .lex "$BLOCK", $P1363
.annotate 'line', 551
    find_lex $P1364, "$/"
    unless_null $P1364, vivify_492
    $P1364 = root_new ['parrot';'Hash']
  vivify_492:
    set $P1365, $P1364["variable"]
    unless_null $P1365, vivify_493
    new $P1365, "Undef"
  vivify_493:
    $P1366 = $P1365."ast"()
    store_lex "$past", $P1366
.annotate 'line', 552
    find_lex $P1367, "$/"
    unless_null $P1367, vivify_494
    $P1367 = root_new ['parrot';'Hash']
  vivify_494:
    set $P1368, $P1367["variable"]
    unless_null $P1368, vivify_495
    $P1368 = root_new ['parrot';'Hash']
  vivify_495:
    set $P1369, $P1368["sigil"]
    unless_null $P1369, vivify_496
    new $P1369, "Undef"
  vivify_496:
    store_lex "$sigil", $P1369
.annotate 'line', 553
    find_lex $P1370, "$past"
    $P1371 = $P1370."name"()
    store_lex "$name", $P1371
.annotate 'line', 554
    get_global $P1372, "@BLOCK"
    unless_null $P1372, vivify_497
    $P1372 = root_new ['parrot';'ResizablePMCArray']
  vivify_497:
    set $P1373, $P1372[0]
    unless_null $P1373, vivify_498
    new $P1373, "Undef"
  vivify_498:
    store_lex "$BLOCK", $P1373
.annotate 'line', 555
    find_lex $P1375, "$BLOCK"
    find_lex $P1376, "$name"
    $P1377 = $P1375."symbol"($P1376)
    unless $P1377, if_1374_end
.annotate 'line', 556
    find_lex $P1378, "$/"
    $P1379 = $P1378."CURSOR"()
    find_lex $P1380, "$name"
    $P1379."panic"("Redeclaration of symbol ", $P1380)
  if_1374_end:
.annotate 'line', 558
    find_dynamic_lex $P1382, "$*SCOPE"
    unless_null $P1382, vivify_499
    get_hll_global $P1382, "$SCOPE"
    unless_null $P1382, vivify_500
    die "Contextual $*SCOPE not found"
  vivify_500:
  vivify_499:
    set $S1383, $P1382
    iseq $I1384, $S1383, "has"
    if $I1384, if_1381
.annotate 'line', 583
    .const 'Sub' $P1431 = "88_1299602554.641" 
    capture_lex $P1431
    $P1431()
    goto if_1381_end
  if_1381:
.annotate 'line', 558
    .const 'Sub' $P1386 = "86_1299602554.641" 
    capture_lex $P1386
    $P1386()
  if_1381_end:
.annotate 'line', 591
    find_lex $P1455, "$/"
    find_lex $P1456, "$past"
    $P1457 = $P1455."!make"($P1456)
.annotate 'line', 550
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1430"  :anon :subid("88_1299602554.641") :outer("85_1299602554.641")
.annotate 'line', 584
    new $P1432, "Undef"
    .lex "$scope", $P1432
.annotate 'line', 585
    new $P1433, "Undef"
    .lex "$decl", $P1433
.annotate 'line', 584
    find_dynamic_lex $P1436, "$*SCOPE"
    unless_null $P1436, vivify_501
    get_hll_global $P1436, "$SCOPE"
    unless_null $P1436, vivify_502
    die "Contextual $*SCOPE not found"
  vivify_502:
  vivify_501:
    set $S1437, $P1436
    iseq $I1438, $S1437, "our"
    if $I1438, if_1435
    new $P1440, "String"
    assign $P1440, "lexical"
    set $P1434, $P1440
    goto if_1435_end
  if_1435:
    new $P1439, "String"
    assign $P1439, "package"
    set $P1434, $P1439
  if_1435_end:
    store_lex "$scope", $P1434
.annotate 'line', 585
    get_hll_global $P1441, ["PAST"], "Var"
    find_lex $P1442, "$name"
    find_lex $P1443, "$scope"
.annotate 'line', 586
    find_lex $P1444, "$sigil"
    $P1445 = "vivitype"($P1444)
    find_lex $P1446, "$/"
    $P1447 = $P1441."new"($P1442 :named("name"), $P1443 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1445 :named("viviself"), $P1446 :named("node"))
.annotate 'line', 585
    store_lex "$decl", $P1447
.annotate 'line', 588
    find_lex $P1448, "$BLOCK"
    find_lex $P1449, "$name"
    find_lex $P1450, "$scope"
    $P1448."symbol"($P1449, $P1450 :named("scope"))
.annotate 'line', 589
    find_lex $P1451, "$BLOCK"
    unless_null $P1451, vivify_503
    $P1451 = root_new ['parrot';'ResizablePMCArray']
  vivify_503:
    set $P1452, $P1451[0]
    unless_null $P1452, vivify_504
    new $P1452, "Undef"
  vivify_504:
    find_lex $P1453, "$decl"
    $P1454 = $P1452."push"($P1453)
.annotate 'line', 583
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1385"  :anon :subid("86_1299602554.641") :outer("85_1299602554.641")
.annotate 'line', 558
    .const 'Sub' $P1416 = "87_1299602554.641" 
    capture_lex $P1416
.annotate 'line', 560
    new $P1387, "Undef"
    .lex "$meta-attr-type", $P1387
.annotate 'line', 568
    new $P1388, "Undef"
    .lex "$meta_args", $P1388
.annotate 'line', 560
    find_dynamic_lex $P1391, "$*PKGDECL"
    unless_null $P1391, vivify_505
    get_hll_global $P1391, "$PKGDECL"
    unless_null $P1391, vivify_506
    die "Contextual $*PKGDECL not found"
  vivify_506:
  vivify_505:
    find_dynamic_lex $P1392, "%*HOW-METAATTR"
    unless_null $P1392, vivify_507
    get_hll_global $P1392, "%HOW-METAATTR"
    unless_null $P1392, vivify_508
    die "Contextual %*HOW-METAATTR not found"
  vivify_508:
  vivify_507:
    set $P1393, $P1392[$P1391]
    unless_null $P1393, vivify_509
    new $P1393, "Undef"
  vivify_509:
    unless $P1393, unless_1390
    set $P1389, $P1393
    goto unless_1390_end
  unless_1390:
    find_dynamic_lex $P1394, "$*DEFAULT-METAATTR"
    unless_null $P1394, vivify_510
    get_hll_global $P1394, "$DEFAULT-METAATTR"
    unless_null $P1394, vivify_511
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_511:
  vivify_510:
    set $P1389, $P1394
  unless_1390_end:
    store_lex "$meta-attr-type", $P1389
.annotate 'line', 561
    find_dynamic_lex $P1395, "$*PACKAGE-SETUP"
    unless_null $P1395, vivify_512
    get_hll_global $P1395, "$PACKAGE-SETUP"
    unless_null $P1395, vivify_513
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_513:
  vivify_512:
    get_hll_global $P1396, ["PAST"], "Op"
.annotate 'line', 563
    get_hll_global $P1397, ["PAST"], "Op"
.annotate 'line', 565
    get_hll_global $P1398, ["PAST"], "Var"
    $P1399 = $P1398."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1400 = $P1397."new"($P1399, "get_how PP" :named("pirop"))
.annotate 'line', 567
    get_hll_global $P1401, ["PAST"], "Var"
    $P1402 = $P1401."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 568
    get_hll_global $P1403, ["PAST"], "Op"
.annotate 'line', 570
    get_hll_global $P1404, ["PAST"], "Var"
    find_lex $P1405, "$meta-attr-type"
    $P1406 = $P1404."new"($P1405 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 571
    get_hll_global $P1407, ["PAST"], "Val"
    find_lex $P1408, "$name"
    $P1409 = $P1407."new"($P1408 :named("value"), "name" :named("named"))
    $P1410 = $P1403."new"($P1406, $P1409, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 568
    store_lex "$meta_args", $P1410
    $P1411 = $P1396."new"($P1400, $P1402, $P1410, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 561
    $P1395."push"($P1411)
.annotate 'line', 574
    find_lex $P1413, "$/"
    unless_null $P1413, vivify_514
    $P1413 = root_new ['parrot';'Hash']
  vivify_514:
    set $P1414, $P1413["typename"]
    unless_null $P1414, vivify_515
    new $P1414, "Undef"
  vivify_515:
    unless $P1414, if_1412_end
    .const 'Sub' $P1416 = "87_1299602554.641" 
    capture_lex $P1416
    $P1416()
  if_1412_end:
.annotate 'line', 580
    find_lex $P1426, "$BLOCK"
    find_lex $P1427, "$name"
    $P1426."symbol"($P1427, "attribute" :named("scope"))
.annotate 'line', 581
    get_hll_global $P1428, ["PAST"], "Stmts"
    $P1429 = $P1428."new"()
    store_lex "$past", $P1429
.annotate 'line', 558
    .return ($P1429)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1415"  :anon :subid("87_1299602554.641") :outer("86_1299602554.641")
.annotate 'line', 575
    new $P1417, "Undef"
    .lex "$type", $P1417
    find_lex $P1418, "$/"
    unless_null $P1418, vivify_516
    $P1418 = root_new ['parrot';'Hash']
  vivify_516:
    set $P1419, $P1418["typename"]
    unless_null $P1419, vivify_517
    $P1419 = root_new ['parrot';'ResizablePMCArray']
  vivify_517:
    set $P1420, $P1419[0]
    unless_null $P1420, vivify_518
    new $P1420, "Undef"
  vivify_518:
    $P1421 = $P1420."ast"()
    store_lex "$type", $P1421
.annotate 'line', 576
    find_lex $P1422, "$type"
    $P1422."named"("type")
.annotate 'line', 577
    find_lex $P1423, "$meta_args"
    find_lex $P1424, "$type"
    $P1425 = $P1423."push"($P1424)
.annotate 'line', 574
    .return ($P1425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("89_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1459
    .param pmc param_1460
.annotate 'line', 594
    .lex "self", param_1459
    .lex "$/", param_1460
    find_lex $P1461, "$/"
    find_lex $P1462, "$/"
    unless_null $P1462, vivify_519
    $P1462 = root_new ['parrot';'Hash']
  vivify_519:
    set $P1463, $P1462["routine_def"]
    unless_null $P1463, vivify_520
    new $P1463, "Undef"
  vivify_520:
    $P1464 = $P1463."ast"()
    $P1465 = $P1461."!make"($P1464)
    .return ($P1465)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("90_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1467
    .param pmc param_1468
.annotate 'line', 595
    .lex "self", param_1467
    .lex "$/", param_1468
    find_lex $P1469, "$/"
    find_lex $P1470, "$/"
    unless_null $P1470, vivify_521
    $P1470 = root_new ['parrot';'Hash']
  vivify_521:
    set $P1471, $P1470["method_def"]
    unless_null $P1471, vivify_522
    new $P1471, "Undef"
  vivify_522:
    $P1472 = $P1471."ast"()
    $P1473 = $P1469."!make"($P1472)
    .return ($P1473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("91_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1475
    .param pmc param_1476
.annotate 'line', 597
    .const 'Sub' $P1704 = "97_1299602554.641" 
    capture_lex $P1704
    .const 'Sub' $P1496 = "92_1299602554.641" 
    capture_lex $P1496
    .lex "self", param_1475
    .lex "$/", param_1476
.annotate 'line', 600
    new $P1477, "Undef"
    .lex "$past", $P1477
.annotate 'line', 611
    new $P1478, "Undef"
    .lex "$block", $P1478
.annotate 'line', 597
    find_lex $P1479, "$past"
.annotate 'line', 601
    find_lex $P1481, "$/"
    unless_null $P1481, vivify_523
    $P1481 = root_new ['parrot';'Hash']
  vivify_523:
    set $P1482, $P1481["onlystar"]
    unless_null $P1482, vivify_524
    new $P1482, "Undef"
  vivify_524:
    if $P1482, if_1480
.annotate 'line', 605
    find_lex $P1484, "$/"
    unless_null $P1484, vivify_525
    $P1484 = root_new ['parrot';'Hash']
  vivify_525:
    set $P1485, $P1484["blockoid"]
    unless_null $P1485, vivify_526
    new $P1485, "Undef"
  vivify_526:
    $P1486 = $P1485."ast"()
    store_lex "$past", $P1486
.annotate 'line', 606
    find_lex $P1487, "$past"
    $P1487."blocktype"("declaration")
.annotate 'line', 607
    find_dynamic_lex $P1489, "$*RETURN_USED"
    unless_null $P1489, vivify_527
    get_hll_global $P1489, "$RETURN_USED"
    unless_null $P1489, vivify_528
    die "Contextual $*RETURN_USED not found"
  vivify_528:
  vivify_527:
    unless $P1489, if_1488_end
.annotate 'line', 608
    find_lex $P1490, "$past"
    $P1490."control"("return_pir")
  if_1488_end:
.annotate 'line', 604
    goto if_1480_end
  if_1480:
.annotate 'line', 602
    $P1483 = "only_star_block"()
    store_lex "$past", $P1483
  if_1480_end:
.annotate 'line', 611
    find_lex $P1491, "$past"
    store_lex "$block", $P1491
.annotate 'line', 613
    find_lex $P1493, "$/"
    unless_null $P1493, vivify_529
    $P1493 = root_new ['parrot';'Hash']
  vivify_529:
    set $P1494, $P1493["deflongname"]
    unless_null $P1494, vivify_530
    new $P1494, "Undef"
  vivify_530:
    unless $P1494, if_1492_end
    .const 'Sub' $P1496 = "92_1299602554.641" 
    capture_lex $P1496
    $P1496()
  if_1492_end:
.annotate 'line', 713
    find_lex $P1693, "$block"
    find_lex $P1694, "$past"
    unless_null $P1694, vivify_591
    $P1694 = root_new ['parrot';'Hash']
    store_lex "$past", $P1694
  vivify_591:
    set $P1694["block_past"], $P1693
.annotate 'line', 714
    find_lex $P1696, "$/"
    unless_null $P1696, vivify_592
    $P1696 = root_new ['parrot';'Hash']
  vivify_592:
    set $P1697, $P1696["trait"]
    unless_null $P1697, vivify_593
    new $P1697, "Undef"
  vivify_593:
    unless $P1697, if_1695_end
.annotate 'line', 715
    find_lex $P1699, "$/"
    unless_null $P1699, vivify_594
    $P1699 = root_new ['parrot';'Hash']
  vivify_594:
    set $P1700, $P1699["trait"]
    unless_null $P1700, vivify_595
    new $P1700, "Undef"
  vivify_595:
    defined $I1701, $P1700
    unless $I1701, for_undef_596
    iter $P1698, $P1700
    new $P1711, 'ExceptionHandler'
    set_label $P1711, loop1710_handler
    $P1711."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1711
  loop1710_test:
    unless $P1698, loop1710_done
    shift $P1702, $P1698
  loop1710_redo:
    .const 'Sub' $P1704 = "97_1299602554.641" 
    capture_lex $P1704
    $P1704($P1702)
  loop1710_next:
    goto loop1710_test
  loop1710_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1712, exception, 'type'
    eq $P1712, .CONTROL_LOOP_NEXT, loop1710_next
    eq $P1712, .CONTROL_LOOP_REDO, loop1710_redo
  loop1710_done:
    pop_eh 
  for_undef_596:
  if_1695_end:
.annotate 'line', 718
    find_lex $P1713, "$/"
    find_lex $P1714, "$past"
    $P1715 = $P1713."!make"($P1714)
.annotate 'line', 597
    .return ($P1715)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1495"  :anon :subid("92_1299602554.641") :outer("91_1299602554.641")
.annotate 'line', 613
    .const 'Sub' $P1619 = "96_1299602554.641" 
    capture_lex $P1619
    .const 'Sub' $P1530 = "93_1299602554.641" 
    capture_lex $P1530
.annotate 'line', 614
    new $P1497, "Undef"
    .lex "$name", $P1497
    find_lex $P1498, "$/"
    unless_null $P1498, vivify_531
    $P1498 = root_new ['parrot';'Hash']
  vivify_531:
    set $P1499, $P1498["sigil"]
    unless_null $P1499, vivify_532
    $P1499 = root_new ['parrot';'ResizablePMCArray']
  vivify_532:
    set $P1500, $P1499[0]
    unless_null $P1500, vivify_533
    new $P1500, "Undef"
  vivify_533:
    set $S1501, $P1500
    new $P1502, 'String'
    set $P1502, $S1501
    find_lex $P1503, "$/"
    unless_null $P1503, vivify_534
    $P1503 = root_new ['parrot';'Hash']
  vivify_534:
    set $P1504, $P1503["deflongname"]
    unless_null $P1504, vivify_535
    $P1504 = root_new ['parrot';'ResizablePMCArray']
  vivify_535:
    set $P1505, $P1504[0]
    unless_null $P1505, vivify_536
    new $P1505, "Undef"
  vivify_536:
    $S1506 = $P1505."ast"()
    concat $P1507, $P1502, $S1506
    store_lex "$name", $P1507
.annotate 'line', 615
    find_lex $P1508, "$past"
    find_lex $P1509, "$name"
    $P1508."name"($P1509)
.annotate 'line', 616
    find_dynamic_lex $P1516, "$*SCOPE"
    unless_null $P1516, vivify_537
    get_hll_global $P1516, "$SCOPE"
    unless_null $P1516, vivify_538
    die "Contextual $*SCOPE not found"
  vivify_538:
  vivify_537:
    set $S1517, $P1516
    iseq $I1518, $S1517, ""
    unless $I1518, unless_1515
    new $P1514, 'Integer'
    set $P1514, $I1518
    goto unless_1515_end
  unless_1515:
    find_dynamic_lex $P1519, "$*SCOPE"
    unless_null $P1519, vivify_539
    get_hll_global $P1519, "$SCOPE"
    unless_null $P1519, vivify_540
    die "Contextual $*SCOPE not found"
  vivify_540:
  vivify_539:
    set $S1520, $P1519
    iseq $I1521, $S1520, "my"
    new $P1514, 'Integer'
    set $P1514, $I1521
  unless_1515_end:
    unless $P1514, unless_1513
    set $P1512, $P1514
    goto unless_1513_end
  unless_1513:
    find_dynamic_lex $P1522, "$*SCOPE"
    unless_null $P1522, vivify_541
    get_hll_global $P1522, "$SCOPE"
    unless_null $P1522, vivify_542
    die "Contextual $*SCOPE not found"
  vivify_542:
  vivify_541:
    set $S1523, $P1522
    iseq $I1524, $S1523, "our"
    new $P1512, 'Integer'
    set $P1512, $I1524
  unless_1513_end:
    if $P1512, if_1511
.annotate 'line', 708
    find_lex $P1688, "$/"
    $P1689 = $P1688."CURSOR"()
    find_dynamic_lex $P1690, "$*SCOPE"
    unless_null $P1690, vivify_543
    get_hll_global $P1690, "$SCOPE"
    unless_null $P1690, vivify_544
    die "Contextual $*SCOPE not found"
  vivify_544:
  vivify_543:
    concat $P1691, $P1690, " scoped routines are not supported yet"
    $P1692 = $P1689."panic"($P1691)
.annotate 'line', 707
    set $P1510, $P1692
.annotate 'line', 616
    goto if_1511_end
  if_1511:
.annotate 'line', 617
    find_dynamic_lex $P1526, "$*MULTINESS"
    unless_null $P1526, vivify_545
    get_hll_global $P1526, "$MULTINESS"
    unless_null $P1526, vivify_546
    die "Contextual $*MULTINESS not found"
  vivify_546:
  vivify_545:
    set $S1527, $P1526
    iseq $I1528, $S1527, "multi"
    if $I1528, if_1525
.annotate 'line', 668
    find_dynamic_lex $P1615, "$*MULTINESS"
    unless_null $P1615, vivify_547
    get_hll_global $P1615, "$MULTINESS"
    unless_null $P1615, vivify_548
    die "Contextual $*MULTINESS not found"
  vivify_548:
  vivify_547:
    set $S1616, $P1615
    iseq $I1617, $S1616, "proto"
    if $I1617, if_1614
.annotate 'line', 687
    get_global $P1649, "@BLOCK"
    unless_null $P1649, vivify_549
    $P1649 = root_new ['parrot';'ResizablePMCArray']
  vivify_549:
    set $P1650, $P1649[0]
    unless_null $P1650, vivify_550
    $P1650 = root_new ['parrot';'ResizablePMCArray']
  vivify_550:
    set $P1651, $P1650[0]
    unless_null $P1651, vivify_551
    new $P1651, "Undef"
  vivify_551:
    get_hll_global $P1652, ["PAST"], "Var"
    find_lex $P1653, "$name"
    find_lex $P1654, "$past"
    $P1655 = $P1652."new"($P1653 :named("name"), 1 :named("isdecl"), $P1654 :named("viviself"), "lexical" :named("scope"))
    $P1651."push"($P1655)
.annotate 'line', 689
    get_global $P1656, "@BLOCK"
    unless_null $P1656, vivify_552
    $P1656 = root_new ['parrot';'ResizablePMCArray']
  vivify_552:
    set $P1657, $P1656[0]
    unless_null $P1657, vivify_553
    new $P1657, "Undef"
  vivify_553:
    find_lex $P1658, "$name"
    $P1657."symbol"($P1658, "lexical" :named("scope"))
.annotate 'line', 690
    find_dynamic_lex $P1660, "$*SCOPE"
    unless_null $P1660, vivify_554
    get_hll_global $P1660, "$SCOPE"
    unless_null $P1660, vivify_555
    die "Contextual $*SCOPE not found"
  vivify_555:
  vivify_554:
    set $S1661, $P1660
    iseq $I1662, $S1661, "our"
    unless $I1662, if_1659_end
.annotate 'line', 693
    get_global $P1663, "@BLOCK"
    unless_null $P1663, vivify_556
    $P1663 = root_new ['parrot';'ResizablePMCArray']
  vivify_556:
    set $P1664, $P1663[0]
    unless_null $P1664, vivify_557
    $P1664 = root_new ['parrot';'ResizablePMCArray']
  vivify_557:
    set $P1665, $P1664[0]
    unless_null $P1665, vivify_558
    new $P1665, "Undef"
  vivify_558:
    get_hll_global $P1666, ["PAST"], "Op"
.annotate 'line', 695
    get_hll_global $P1667, ["PAST"], "Var"
    find_lex $P1668, "$name"
    $P1669 = $P1667."new"($P1668 :named("name"), "package" :named("scope"))
.annotate 'line', 696
    get_hll_global $P1670, ["PAST"], "Var"
    find_lex $P1671, "$name"
    $P1672 = $P1670."new"($P1671 :named("name"), "lexical" :named("scope"))
    $P1673 = $P1666."new"($P1669, $P1672, "bind" :named("pasttype"))
.annotate 'line', 693
    $P1665."push"($P1673)
.annotate 'line', 698
    get_global $P1674, "@BLOCK"
    unless_null $P1674, vivify_559
    $P1674 = root_new ['parrot';'ResizablePMCArray']
  vivify_559:
    set $P1675, $P1674[0]
    unless_null $P1675, vivify_560
    new $P1675, "Undef"
  vivify_560:
    $P1676 = $P1675."loadinit"()
    get_hll_global $P1677, ["PAST"], "Op"
.annotate 'line', 700
    get_hll_global $P1678, ["PAST"], "Var"
    find_lex $P1679, "$name"
    $P1680 = $P1678."new"($P1679 :named("name"), "package" :named("scope"))
.annotate 'line', 701
    get_hll_global $P1681, ["PAST"], "Val"
    find_lex $P1682, "$past"
    $P1683 = $P1681."new"($P1682 :named("value"))
    $P1684 = $P1677."new"($P1680, $P1683, "bind" :named("pasttype"))
.annotate 'line', 698
    $P1676."push"($P1684)
  if_1659_end:
.annotate 'line', 686
    goto if_1614_end
  if_1614:
.annotate 'line', 668
    .const 'Sub' $P1619 = "96_1299602554.641" 
    capture_lex $P1619
    $P1619()
  if_1614_end:
    goto if_1525_end
  if_1525:
.annotate 'line', 617
    .const 'Sub' $P1530 = "93_1299602554.641" 
    capture_lex $P1530
    $P1530()
  if_1525_end:
.annotate 'line', 705
    get_hll_global $P1685, ["PAST"], "Var"
    find_lex $P1686, "$name"
    $P1687 = $P1685."new"($P1686 :named("name"))
    store_lex "$past", $P1687
.annotate 'line', 616
    set $P1510, $P1687
  if_1511_end:
.annotate 'line', 613
    .return ($P1510)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1618"  :anon :subid("96_1299602554.641") :outer("92_1299602554.641")
.annotate 'line', 673
    new $P1620, "Undef"
    .lex "$cholder", $P1620
.annotate 'line', 672
    find_dynamic_lex $P1622, "$*SCOPE"
    unless_null $P1622, vivify_561
    get_hll_global $P1622, "$SCOPE"
    unless_null $P1622, vivify_562
    die "Contextual $*SCOPE not found"
  vivify_562:
  vivify_561:
    set $S1623, $P1622
    iseq $I1624, $S1623, "our"
    unless $I1624, if_1621_end
    die "our-scoped protos not yet implemented"
  if_1621_end:
.annotate 'line', 673
    get_hll_global $P1625, ["PAST"], "Op"
    $P1626 = $P1625."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1626
.annotate 'line', 674
    get_global $P1627, "@BLOCK"
    unless_null $P1627, vivify_563
    $P1627 = root_new ['parrot';'ResizablePMCArray']
  vivify_563:
    set $P1628, $P1627[0]
    unless_null $P1628, vivify_564
    $P1628 = root_new ['parrot';'ResizablePMCArray']
  vivify_564:
    set $P1629, $P1628[0]
    unless_null $P1629, vivify_565
    new $P1629, "Undef"
  vivify_565:
    get_hll_global $P1630, ["PAST"], "Var"
    find_lex $P1631, "$name"
    find_lex $P1632, "$past"
    $P1633 = $P1630."new"($P1631 :named("name"), 1 :named("isdecl"), $P1632 :named("viviself"), "lexical" :named("scope"))
    $P1629."push"($P1633)
.annotate 'line', 676
    get_global $P1634, "@BLOCK"
    unless_null $P1634, vivify_566
    $P1634 = root_new ['parrot';'ResizablePMCArray']
  vivify_566:
    set $P1635, $P1634[0]
    unless_null $P1635, vivify_567
    $P1635 = root_new ['parrot';'ResizablePMCArray']
  vivify_567:
    set $P1636, $P1635[0]
    unless_null $P1636, vivify_568
    new $P1636, "Undef"
  vivify_568:
    get_hll_global $P1637, ["PAST"], "Op"
.annotate 'line', 678
    get_hll_global $P1638, ["PAST"], "Var"
    find_lex $P1639, "$name"
    $P1640 = $P1638."new"($P1639 :named("name"))
    find_lex $P1641, "$cholder"
    $P1642 = $P1637."new"($P1640, $P1641, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 676
    $P1636."push"($P1642)
.annotate 'line', 681
    get_global $P1643, "@BLOCK"
    unless_null $P1643, vivify_569
    $P1643 = root_new ['parrot';'ResizablePMCArray']
  vivify_569:
    set $P1644, $P1643[0]
    unless_null $P1644, vivify_570
    new $P1644, "Undef"
  vivify_570:
    find_lex $P1645, "$name"
    find_lex $P1646, "$cholder"
    $P1644."symbol"($P1645, "lexical" :named("scope"), 1 :named("proto"), $P1646 :named("cholder"))
.annotate 'line', 684
    find_lex $P1647, "$past"
    $P1648 = $P1647."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 668
    .return ($P1648)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1529"  :anon :subid("93_1299602554.641") :outer("92_1299602554.641")
.annotate 'line', 617
    .const 'Sub' $P1548 = "94_1299602554.641" 
    capture_lex $P1548
.annotate 'line', 620
    new $P1531, "Undef"
    .lex "$cholder", $P1531
.annotate 'line', 621
    $P1532 = root_new ['parrot';'Hash']
    .lex "%sym", $P1532
.annotate 'line', 619
    find_dynamic_lex $P1534, "$*SCOPE"
    unless_null $P1534, vivify_571
    get_hll_global $P1534, "$SCOPE"
    unless_null $P1534, vivify_572
    die "Contextual $*SCOPE not found"
  vivify_572:
  vivify_571:
    set $S1535, $P1534
    iseq $I1536, $S1535, "our"
    unless $I1536, if_1533_end
    die "our-scoped multis not yet implemented"
  if_1533_end:
    find_lex $P1537, "$cholder"
.annotate 'line', 621
    get_global $P1538, "@BLOCK"
    unless_null $P1538, vivify_573
    $P1538 = root_new ['parrot';'ResizablePMCArray']
  vivify_573:
    set $P1539, $P1538[0]
    unless_null $P1539, vivify_574
    new $P1539, "Undef"
  vivify_574:
    find_lex $P1540, "$name"
    $P1541 = $P1539."symbol"($P1540)
    store_lex "%sym", $P1541
.annotate 'line', 622
    find_lex $P1543, "%sym"
    unless_null $P1543, vivify_575
    $P1543 = root_new ['parrot';'Hash']
  vivify_575:
    set $P1544, $P1543["cholder"]
    unless_null $P1544, vivify_576
    new $P1544, "Undef"
  vivify_576:
    if $P1544, if_1542
.annotate 'line', 627
    .const 'Sub' $P1548 = "94_1299602554.641" 
    capture_lex $P1548
    $P1548()
    goto if_1542_end
  if_1542:
.annotate 'line', 623
    find_lex $P1545, "%sym"
    unless_null $P1545, vivify_589
    $P1545 = root_new ['parrot';'Hash']
  vivify_589:
    set $P1546, $P1545["cholder"]
    unless_null $P1546, vivify_590
    new $P1546, "Undef"
  vivify_590:
    store_lex "$cholder", $P1546
  if_1542_end:
.annotate 'line', 663
    find_lex $P1610, "$cholder"
    find_lex $P1611, "$past"
    $P1610."push"($P1611)
.annotate 'line', 666
    find_lex $P1612, "$past"
    $P1613 = "attach_multi_signature"($P1612)
.annotate 'line', 617
    .return ($P1613)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1547"  :anon :subid("94_1299602554.641") :outer("93_1299602554.641")
.annotate 'line', 627
    .const 'Sub' $P1562 = "95_1299602554.641" 
    capture_lex $P1562
.annotate 'line', 634
    new $P1549, "Undef"
    .lex "$found_proto", $P1549
.annotate 'line', 652
    new $P1550, "Undef"
    .lex "$dispatch_setup", $P1550
.annotate 'line', 629
    find_lex $P1552, "%sym"
    unless_null $P1552, vivify_577
    $P1552 = root_new ['parrot';'Hash']
  vivify_577:
    set $P1553, $P1552["proto"]
    unless_null $P1553, vivify_578
    new $P1553, "Undef"
  vivify_578:
    unless $P1553, if_1551_end
.annotate 'line', 632
    find_lex $P1554, "$/"
    $P1555 = $P1554."CURSOR"()
    $P1555."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1551_end:
.annotate 'line', 629
    find_lex $P1556, "$found_proto"
.annotate 'line', 635
    get_global $P1558, "@BLOCK"
    defined $I1559, $P1558
    unless $I1559, for_undef_579
    iter $P1557, $P1558
    new $P1584, 'ExceptionHandler'
    set_label $P1584, loop1583_handler
    $P1584."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1584
  loop1583_test:
    unless $P1557, loop1583_done
    shift $P1560, $P1557
  loop1583_redo:
    .const 'Sub' $P1562 = "95_1299602554.641" 
    capture_lex $P1562
    $P1562($P1560)
  loop1583_next:
    goto loop1583_test
  loop1583_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1585, exception, 'type'
    eq $P1585, .CONTROL_LOOP_NEXT, loop1583_next
    eq $P1585, .CONTROL_LOOP_REDO, loop1583_redo
  loop1583_done:
    pop_eh 
  for_undef_579:
.annotate 'line', 646
    find_lex $P1587, "$found_proto"
    if $P1587, unless_1586_end
.annotate 'line', 647
    find_lex $P1588, "$/"
    $P1589 = $P1588."CURSOR"()
    $P1589."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1586_end:
.annotate 'line', 651
    get_hll_global $P1590, ["PAST"], "Op"
    $P1591 = $P1590."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1591
.annotate 'line', 652
    get_hll_global $P1592, ["PAST"], "Op"
.annotate 'line', 654
    get_hll_global $P1593, ["PAST"], "Var"
    find_lex $P1594, "$name"
    $P1595 = $P1593."new"($P1594 :named("name"), "outer" :named("scope"))
    find_lex $P1596, "$cholder"
    $P1597 = $P1592."new"($P1595, $P1596, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 652
    store_lex "$dispatch_setup", $P1597
.annotate 'line', 657
    get_global $P1598, "@BLOCK"
    unless_null $P1598, vivify_584
    $P1598 = root_new ['parrot';'ResizablePMCArray']
  vivify_584:
    set $P1599, $P1598[0]
    unless_null $P1599, vivify_585
    $P1599 = root_new ['parrot';'ResizablePMCArray']
  vivify_585:
    set $P1600, $P1599[0]
    unless_null $P1600, vivify_586
    new $P1600, "Undef"
  vivify_586:
    get_hll_global $P1601, ["PAST"], "Var"
    find_lex $P1602, "$name"
    find_lex $P1603, "$dispatch_setup"
    $P1604 = $P1601."new"($P1602 :named("name"), 1 :named("isdecl"), $P1603 :named("viviself"), "lexical" :named("scope"))
    $P1600."push"($P1604)
.annotate 'line', 659
    get_global $P1605, "@BLOCK"
    unless_null $P1605, vivify_587
    $P1605 = root_new ['parrot';'ResizablePMCArray']
  vivify_587:
    set $P1606, $P1605[0]
    unless_null $P1606, vivify_588
    new $P1606, "Undef"
  vivify_588:
    find_lex $P1607, "$name"
    find_lex $P1608, "$cholder"
    $P1609 = $P1606."symbol"($P1607, "lexical" :named("scope"), $P1608 :named("cholder"))
.annotate 'line', 627
    .return ($P1609)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1561"  :anon :subid("95_1299602554.641") :outer("94_1299602554.641")
    .param pmc param_1564
.annotate 'line', 636
    $P1563 = root_new ['parrot';'Hash']
    .lex "%sym", $P1563
    .lex "$_", param_1564
    find_lex $P1565, "$_"
    find_lex $P1566, "$name"
    $P1567 = $P1565."symbol"($P1566)
    store_lex "%sym", $P1567
.annotate 'line', 637
    find_lex $P1572, "%sym"
    unless_null $P1572, vivify_580
    $P1572 = root_new ['parrot';'Hash']
  vivify_580:
    set $P1573, $P1572["proto"]
    unless_null $P1573, vivify_581
    new $P1573, "Undef"
  vivify_581:
    unless $P1573, unless_1571
    set $P1570, $P1573
    goto unless_1571_end
  unless_1571:
    find_lex $P1574, "%sym"
    unless_null $P1574, vivify_582
    $P1574 = root_new ['parrot';'Hash']
  vivify_582:
    set $P1575, $P1574["cholder"]
    unless_null $P1575, vivify_583
    new $P1575, "Undef"
  vivify_583:
    set $P1570, $P1575
  unless_1571_end:
    if $P1570, if_1569
.annotate 'line', 640
    find_lex $P1579, "%sym"
    if $P1579, if_1578
    set $P1577, $P1579
    goto if_1578_end
  if_1578:
.annotate 'line', 641
    find_lex $P1580, "$/"
    $P1581 = $P1580."CURSOR"()
    $P1582 = $P1581."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 640
    set $P1577, $P1582
  if_1578_end:
    set $P1568, $P1577
.annotate 'line', 637
    goto if_1569_end
  if_1569:
.annotate 'line', 638
    new $P1576, "Integer"
    assign $P1576, 1
    store_lex "$found_proto", $P1576
.annotate 'line', 637
    set $P1568, $P1576
  if_1569_end:
.annotate 'line', 635
    .return ($P1568)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1703"  :anon :subid("97_1299602554.641") :outer("91_1299602554.641")
    .param pmc param_1705
.annotate 'line', 715
    .lex "$_", param_1705
    find_lex $P1706, "$_"
    $P1707 = $P1706."ast"()
    find_lex $P1708, "$/"
    $P1709 = $P1707($P1708)
    .return ($P1709)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("98_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1717
    .param pmc param_1718
.annotate 'line', 722
    .const 'Sub' $P1830 = "100_1299602554.641" 
    capture_lex $P1830
    .const 'Sub' $P1746 = "99_1299602554.641" 
    capture_lex $P1746
    .lex "self", param_1717
    .lex "$/", param_1718
.annotate 'line', 725
    new $P1719, "Undef"
    .lex "$past", $P1719
.annotate 'line', 722
    find_lex $P1720, "$past"
.annotate 'line', 726
    find_lex $P1722, "$/"
    unless_null $P1722, vivify_597
    $P1722 = root_new ['parrot';'Hash']
  vivify_597:
    set $P1723, $P1722["onlystar"]
    unless_null $P1723, vivify_598
    new $P1723, "Undef"
  vivify_598:
    if $P1723, if_1721
.annotate 'line', 730
    find_lex $P1725, "$/"
    unless_null $P1725, vivify_599
    $P1725 = root_new ['parrot';'Hash']
  vivify_599:
    set $P1726, $P1725["blockoid"]
    unless_null $P1726, vivify_600
    new $P1726, "Undef"
  vivify_600:
    $P1727 = $P1726."ast"()
    store_lex "$past", $P1727
.annotate 'line', 731
    find_lex $P1728, "$past"
    $P1728."blocktype"("declaration")
.annotate 'line', 732
    find_dynamic_lex $P1730, "$*RETURN_USED"
    unless_null $P1730, vivify_601
    get_hll_global $P1730, "$RETURN_USED"
    unless_null $P1730, vivify_602
    die "Contextual $*RETURN_USED not found"
  vivify_602:
  vivify_601:
    unless $P1730, if_1729_end
.annotate 'line', 733
    find_lex $P1731, "$past"
    $P1731."control"("return_pir")
  if_1729_end:
.annotate 'line', 729
    goto if_1721_end
  if_1721:
.annotate 'line', 727
    $P1724 = "only_star_block"()
    store_lex "$past", $P1724
  if_1721_end:
.annotate 'line', 738
    find_lex $P1733, "$past"
    unless_null $P1733, vivify_603
    $P1733 = root_new ['parrot';'Hash']
  vivify_603:
    set $P1734, $P1733["signature_has_invocant"]
    unless_null $P1734, vivify_604
    new $P1734, "Undef"
  vivify_604:
    if $P1734, unless_1732_end
.annotate 'line', 739
    find_lex $P1735, "$past"
    unless_null $P1735, vivify_605
    $P1735 = root_new ['parrot';'ResizablePMCArray']
  vivify_605:
    set $P1736, $P1735[0]
    unless_null $P1736, vivify_606
    new $P1736, "Undef"
  vivify_606:
    get_hll_global $P1737, ["PAST"], "Var"
.annotate 'line', 741
    get_hll_global $P1738, ["PAST"], "Var"
    $P1739 = $P1738."new"("$?CLASS" :named("name"))
    $P1740 = $P1737."new"("self" :named("name"), "parameter" :named("scope"), $P1739 :named("multitype"))
.annotate 'line', 739
    $P1736."unshift"($P1740)
  unless_1732_end:
.annotate 'line', 744
    find_lex $P1741, "$past"
    $P1741."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 747
    find_lex $P1743, "$/"
    unless_null $P1743, vivify_607
    $P1743 = root_new ['parrot';'Hash']
  vivify_607:
    set $P1744, $P1743["deflongname"]
    unless_null $P1744, vivify_608
    new $P1744, "Undef"
  vivify_608:
    unless $P1744, if_1742_end
    .const 'Sub' $P1746 = "99_1299602554.641" 
    capture_lex $P1746
    $P1746()
  if_1742_end:
.annotate 'line', 782
    find_dynamic_lex $P1812, "$*SCOPE"
    unless_null $P1812, vivify_626
    get_hll_global $P1812, "$SCOPE"
    unless_null $P1812, vivify_627
    die "Contextual $*SCOPE not found"
  vivify_627:
  vivify_626:
    set $S1813, $P1812
    iseq $I1814, $S1813, "our"
    unless $I1814, if_1811_end
.annotate 'line', 783
    find_lex $P1815, "$past"
    $P1815."pirflags"(":nsentry")
  if_1811_end:
.annotate 'line', 787
    find_lex $P1816, "$/"
    find_lex $P1817, "$past"
    $P1816."!make"($P1817)
.annotate 'line', 788
    find_lex $P1818, "$past"
    find_lex $P1819, "$past"
    unless_null $P1819, vivify_628
    $P1819 = root_new ['parrot';'Hash']
    store_lex "$past", $P1819
  vivify_628:
    set $P1819["block_past"], $P1818
.annotate 'line', 789
    find_lex $P1822, "$/"
    unless_null $P1822, vivify_629
    $P1822 = root_new ['parrot';'Hash']
  vivify_629:
    set $P1823, $P1822["trait"]
    unless_null $P1823, vivify_630
    new $P1823, "Undef"
  vivify_630:
    if $P1823, if_1821
    set $P1820, $P1823
    goto if_1821_end
  if_1821:
.annotate 'line', 790
    find_lex $P1825, "$/"
    unless_null $P1825, vivify_631
    $P1825 = root_new ['parrot';'Hash']
  vivify_631:
    set $P1826, $P1825["trait"]
    unless_null $P1826, vivify_632
    new $P1826, "Undef"
  vivify_632:
    defined $I1827, $P1826
    unless $I1827, for_undef_633
    iter $P1824, $P1826
    new $P1837, 'ExceptionHandler'
    set_label $P1837, loop1836_handler
    $P1837."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1837
  loop1836_test:
    unless $P1824, loop1836_done
    shift $P1828, $P1824
  loop1836_redo:
    .const 'Sub' $P1830 = "100_1299602554.641" 
    capture_lex $P1830
    $P1830($P1828)
  loop1836_next:
    goto loop1836_test
  loop1836_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1838, exception, 'type'
    eq $P1838, .CONTROL_LOOP_NEXT, loop1836_next
    eq $P1838, .CONTROL_LOOP_REDO, loop1836_redo
  loop1836_done:
    pop_eh 
  for_undef_633:
.annotate 'line', 789
    set $P1820, $P1824
  if_1821_end:
.annotate 'line', 722
    .return ($P1820)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1745"  :anon :subid("99_1299602554.641") :outer("98_1299602554.641")
.annotate 'line', 749
    new $P1747, "Undef"
    .lex "$name", $P1747
.annotate 'line', 754
    new $P1748, "Undef"
    .lex "$to_add", $P1748
.annotate 'line', 749
    find_lex $P1749, "$/"
    unless_null $P1749, vivify_609
    $P1749 = root_new ['parrot';'Hash']
  vivify_609:
    set $P1750, $P1749["private"]
    unless_null $P1750, vivify_610
    new $P1750, "Undef"
  vivify_610:
    set $S1751, $P1750
    new $P1752, 'String'
    set $P1752, $S1751
    find_lex $P1753, "$/"
    unless_null $P1753, vivify_611
    $P1753 = root_new ['parrot';'Hash']
  vivify_611:
    set $P1754, $P1753["deflongname"]
    unless_null $P1754, vivify_612
    $P1754 = root_new ['parrot';'ResizablePMCArray']
  vivify_612:
    set $P1755, $P1754[0]
    unless_null $P1755, vivify_613
    new $P1755, "Undef"
  vivify_613:
    $P1756 = $P1755."ast"()
    set $S1757, $P1756
    concat $P1758, $P1752, $S1757
    store_lex "$name", $P1758
.annotate 'line', 750
    find_lex $P1759, "$past"
    find_lex $P1760, "$name"
    $P1759."name"($P1760)
.annotate 'line', 754
    find_dynamic_lex $P1763, "$*MULTINESS"
    unless_null $P1763, vivify_614
    get_hll_global $P1763, "$MULTINESS"
    unless_null $P1763, vivify_615
    die "Contextual $*MULTINESS not found"
  vivify_615:
  vivify_614:
    set $S1764, $P1763
    isne $I1765, $S1764, "proto"
    if $I1765, if_1762
.annotate 'line', 756
    get_hll_global $P1769, ["PAST"], "Op"
.annotate 'line', 758
    get_hll_global $P1770, ["PAST"], "Val"
    find_lex $P1771, "$past"
    $P1772 = $P1770."new"($P1771 :named("value"))
.annotate 'line', 759
    get_hll_global $P1773, ["PAST"], "Op"
    $P1774 = $P1773."new"("list" :named("pasttype"))
    $P1775 = $P1769."new"($P1772, $P1774, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 756
    set $P1761, $P1775
.annotate 'line', 754
    goto if_1762_end
  if_1762:
.annotate 'line', 755
    get_hll_global $P1766, ["PAST"], "Val"
    find_lex $P1767, "$past"
    $P1768 = $P1766."new"($P1767 :named("value"))
    set $P1761, $P1768
  if_1762_end:
.annotate 'line', 754
    store_lex "$to_add", $P1761
.annotate 'line', 761
    find_dynamic_lex $P1777, "$*MULTINESS"
    unless_null $P1777, vivify_616
    get_hll_global $P1777, "$MULTINESS"
    unless_null $P1777, vivify_617
    die "Contextual $*MULTINESS not found"
  vivify_617:
  vivify_616:
    set $S1778, $P1777
    iseq $I1779, $S1778, "proto"
    unless $I1779, if_1776_end
    find_lex $P1780, "$past"
    $P1780."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1776_end:
.annotate 'line', 765
    find_dynamic_lex $P1782, "$*MULTINESS"
    unless_null $P1782, vivify_618
    get_hll_global $P1782, "$MULTINESS"
    unless_null $P1782, vivify_619
    die "Contextual $*MULTINESS not found"
  vivify_619:
  vivify_618:
    set $S1783, $P1782
    iseq $I1784, $S1783, "multi"
    unless $I1784, if_1781_end
    find_lex $P1785, "$past"
    "attach_multi_signature"($P1785)
  if_1781_end:
.annotate 'line', 768
    find_dynamic_lex $P1788, "$*PACKAGE-SETUP"
    unless_null $P1788, vivify_620
    get_hll_global $P1788, "$PACKAGE-SETUP"
    unless_null $P1788, vivify_621
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_621:
  vivify_620:
    defined $I1789, $P1788
    if $I1789, if_1787
    new $P1786, 'Integer'
    set $P1786, $I1789
    goto if_1787_end
  if_1787:
.annotate 'line', 769
    find_dynamic_lex $P1790, "$*PACKAGE-SETUP"
    unless_null $P1790, vivify_622
    get_hll_global $P1790, "$PACKAGE-SETUP"
    unless_null $P1790, vivify_623
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_623:
  vivify_622:
    get_hll_global $P1791, ["PAST"], "Op"
.annotate 'line', 770
    find_dynamic_lex $P1794, "$*MULTINESS"
    unless_null $P1794, vivify_624
    get_hll_global $P1794, "$MULTINESS"
    unless_null $P1794, vivify_625
    die "Contextual $*MULTINESS not found"
  vivify_625:
  vivify_624:
    set $S1795, $P1794
    iseq $I1796, $S1795, "multi"
    if $I1796, if_1793
    new $P1798, "String"
    assign $P1798, "add_method"
    set $P1792, $P1798
    goto if_1793_end
  if_1793:
    new $P1797, "String"
    assign $P1797, "add_multi_method"
    set $P1792, $P1797
  if_1793_end:
.annotate 'line', 771
    get_hll_global $P1799, ["PAST"], "Op"
.annotate 'line', 774
    get_hll_global $P1800, ["PAST"], "Var"
    $P1801 = $P1800."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1802 = $P1799."new"($P1801, "get_how PP" :named("pirop"))
.annotate 'line', 776
    get_hll_global $P1803, ["PAST"], "Var"
    $P1804 = $P1803."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 777
    get_hll_global $P1805, ["PAST"], "Val"
    find_lex $P1806, "$name"
    $P1807 = $P1805."new"($P1806 :named("value"))
    find_lex $P1808, "$to_add"
    $P1809 = $P1791."new"($P1802, $P1804, $P1807, $P1808, "callmethod" :named("pasttype"), $P1792 :named("name"))
.annotate 'line', 769
    $P1810 = $P1790."push"($P1809)
.annotate 'line', 768
    set $P1786, $P1810
  if_1787_end:
.annotate 'line', 747
    .return ($P1786)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1829"  :anon :subid("100_1299602554.641") :outer("98_1299602554.641")
    .param pmc param_1831
.annotate 'line', 790
    .lex "$_", param_1831
    find_lex $P1832, "$_"
    $P1833 = $P1832."ast"()
    find_lex $P1834, "$/"
    $P1835 = $P1833($P1834)
    .return ($P1835)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("101_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1842
    .param pmc param_1843
.annotate 'line', 822
    .const 'Sub' $P1876 = "103_1299602554.641" 
    capture_lex $P1876
    .const 'Sub' $P1852 = "102_1299602554.641" 
    capture_lex $P1852
    .lex "self", param_1842
    .lex "$/", param_1843
.annotate 'line', 823
    new $P1844, "Undef"
    .lex "$BLOCKINIT", $P1844
    get_global $P1845, "@BLOCK"
    unless_null $P1845, vivify_634
    $P1845 = root_new ['parrot';'ResizablePMCArray']
  vivify_634:
    set $P1846, $P1845[0]
    unless_null $P1846, vivify_635
    $P1846 = root_new ['parrot';'ResizablePMCArray']
  vivify_635:
    set $P1847, $P1846[0]
    unless_null $P1847, vivify_636
    new $P1847, "Undef"
  vivify_636:
    store_lex "$BLOCKINIT", $P1847
.annotate 'line', 824
    find_lex $P1849, "$/"
    unless_null $P1849, vivify_637
    $P1849 = root_new ['parrot';'Hash']
  vivify_637:
    set $P1850, $P1849["invocant"]
    unless_null $P1850, vivify_638
    new $P1850, "Undef"
  vivify_638:
    unless $P1850, if_1848_end
    .const 'Sub' $P1852 = "102_1299602554.641" 
    capture_lex $P1852
    $P1852()
  if_1848_end:
.annotate 'line', 833
    find_lex $P1871, "$/"
    unless_null $P1871, vivify_644
    $P1871 = root_new ['parrot';'Hash']
  vivify_644:
    set $P1872, $P1871["parameter"]
    unless_null $P1872, vivify_645
    new $P1872, "Undef"
  vivify_645:
    defined $I1873, $P1872
    unless $I1873, for_undef_646
    iter $P1870, $P1872
    new $P1883, 'ExceptionHandler'
    set_label $P1883, loop1882_handler
    $P1883."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1883
  loop1882_test:
    unless $P1870, loop1882_done
    shift $P1874, $P1870
  loop1882_redo:
    .const 'Sub' $P1876 = "103_1299602554.641" 
    capture_lex $P1876
    $P1876($P1874)
  loop1882_next:
    goto loop1882_test
  loop1882_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1884, exception, 'type'
    eq $P1884, .CONTROL_LOOP_NEXT, loop1882_next
    eq $P1884, .CONTROL_LOOP_REDO, loop1882_redo
  loop1882_done:
    pop_eh 
  for_undef_646:
.annotate 'line', 822
    .return ($P1870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1851"  :anon :subid("102_1299602554.641") :outer("101_1299602554.641")
.annotate 'line', 825
    new $P1853, "Undef"
    .lex "$inv", $P1853
    find_lex $P1854, "$/"
    unless_null $P1854, vivify_639
    $P1854 = root_new ['parrot';'Hash']
  vivify_639:
    set $P1855, $P1854["invocant"]
    unless_null $P1855, vivify_640
    $P1855 = root_new ['parrot';'ResizablePMCArray']
  vivify_640:
    set $P1856, $P1855[0]
    unless_null $P1856, vivify_641
    new $P1856, "Undef"
  vivify_641:
    $P1857 = $P1856."ast"()
    store_lex "$inv", $P1857
.annotate 'line', 826
    find_lex $P1858, "$BLOCKINIT"
    find_lex $P1859, "$inv"
    $P1858."push"($P1859)
.annotate 'line', 827
    find_lex $P1860, "$BLOCKINIT"
    get_hll_global $P1861, ["PAST"], "Var"
.annotate 'line', 829
    get_hll_global $P1862, ["PAST"], "Var"
    find_lex $P1863, "$inv"
    $P1864 = $P1863."name"()
    $P1865 = $P1862."new"("lexical" :named("scope"), $P1864 :named("name"))
    $P1866 = $P1861."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1865 :named("viviself"))
.annotate 'line', 827
    $P1860."push"($P1866)
.annotate 'line', 831
    new $P1867, "Integer"
    assign $P1867, 1
    get_global $P1868, "@BLOCK"
    unless_null $P1868, vivify_642
    $P1868 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1868
  vivify_642:
    set $P1869, $P1868[0]
    unless_null $P1869, vivify_643
    $P1869 = root_new ['parrot';'Hash']
    set $P1868[0], $P1869
  vivify_643:
    set $P1869["signature_has_invocant"], $P1867
.annotate 'line', 824
    .return ($P1867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1875"  :anon :subid("103_1299602554.641") :outer("101_1299602554.641")
    .param pmc param_1877
.annotate 'line', 833
    .lex "$_", param_1877
    find_lex $P1878, "$BLOCKINIT"
    find_lex $P1879, "$_"
    $P1880 = $P1879."ast"()
    $P1881 = $P1878."push"($P1880)
    .return ($P1881)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("104_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1886
    .param pmc param_1887
.annotate 'line', 836
    .lex "self", param_1886
    .lex "$/", param_1887
.annotate 'line', 837
    new $P1888, "Undef"
    .lex "$quant", $P1888
.annotate 'line', 838
    new $P1889, "Undef"
    .lex "$past", $P1889
.annotate 'line', 837
    find_lex $P1890, "$/"
    unless_null $P1890, vivify_647
    $P1890 = root_new ['parrot';'Hash']
  vivify_647:
    set $P1891, $P1890["quant"]
    unless_null $P1891, vivify_648
    new $P1891, "Undef"
  vivify_648:
    store_lex "$quant", $P1891
    find_lex $P1892, "$past"
.annotate 'line', 839
    find_lex $P1894, "$/"
    unless_null $P1894, vivify_649
    $P1894 = root_new ['parrot';'Hash']
  vivify_649:
    set $P1895, $P1894["named_param"]
    unless_null $P1895, vivify_650
    new $P1895, "Undef"
  vivify_650:
    if $P1895, if_1893
.annotate 'line', 846
    find_lex $P1909, "$/"
    unless_null $P1909, vivify_651
    $P1909 = root_new ['parrot';'Hash']
  vivify_651:
    set $P1910, $P1909["param_var"]
    unless_null $P1910, vivify_652
    new $P1910, "Undef"
  vivify_652:
    $P1911 = $P1910."ast"()
    store_lex "$past", $P1911
.annotate 'line', 847
    find_lex $P1913, "$quant"
    set $S1914, $P1913
    iseq $I1915, $S1914, "*"
    if $I1915, if_1912
.annotate 'line', 851
    find_lex $P1924, "$quant"
    set $S1925, $P1924
    iseq $I1926, $S1925, "?"
    unless $I1926, if_1923_end
.annotate 'line', 852
    find_lex $P1927, "$past"
    find_lex $P1928, "$/"
    unless_null $P1928, vivify_653
    $P1928 = root_new ['parrot';'Hash']
  vivify_653:
    set $P1929, $P1928["param_var"]
    unless_null $P1929, vivify_654
    $P1929 = root_new ['parrot';'Hash']
  vivify_654:
    set $P1930, $P1929["sigil"]
    unless_null $P1930, vivify_655
    new $P1930, "Undef"
  vivify_655:
    $P1931 = "vivitype"($P1930)
    $P1927."viviself"($P1931)
  if_1923_end:
.annotate 'line', 851
    goto if_1912_end
  if_1912:
.annotate 'line', 848
    find_lex $P1916, "$past"
    $P1916."slurpy"(1)
.annotate 'line', 849
    find_lex $P1917, "$past"
    find_lex $P1918, "$/"
    unless_null $P1918, vivify_656
    $P1918 = root_new ['parrot';'Hash']
  vivify_656:
    set $P1919, $P1918["param_var"]
    unless_null $P1919, vivify_657
    $P1919 = root_new ['parrot';'Hash']
  vivify_657:
    set $P1920, $P1919["sigil"]
    unless_null $P1920, vivify_658
    new $P1920, "Undef"
  vivify_658:
    set $S1921, $P1920
    iseq $I1922, $S1921, "%"
    $P1917."named"($I1922)
  if_1912_end:
.annotate 'line', 845
    goto if_1893_end
  if_1893:
.annotate 'line', 840
    find_lex $P1896, "$/"
    unless_null $P1896, vivify_659
    $P1896 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1897, $P1896["named_param"]
    unless_null $P1897, vivify_660
    new $P1897, "Undef"
  vivify_660:
    $P1898 = $P1897."ast"()
    store_lex "$past", $P1898
.annotate 'line', 841
    find_lex $P1900, "$quant"
    set $S1901, $P1900
    isne $I1902, $S1901, "!"
    unless $I1902, if_1899_end
.annotate 'line', 842
    find_lex $P1903, "$past"
    find_lex $P1904, "$/"
    unless_null $P1904, vivify_661
    $P1904 = root_new ['parrot';'Hash']
  vivify_661:
    set $P1905, $P1904["named_param"]
    unless_null $P1905, vivify_662
    $P1905 = root_new ['parrot';'Hash']
  vivify_662:
    set $P1906, $P1905["param_var"]
    unless_null $P1906, vivify_663
    $P1906 = root_new ['parrot';'Hash']
  vivify_663:
    set $P1907, $P1906["sigil"]
    unless_null $P1907, vivify_664
    new $P1907, "Undef"
  vivify_664:
    $P1908 = "vivitype"($P1907)
    $P1903."viviself"($P1908)
  if_1899_end:
  if_1893_end:
.annotate 'line', 855
    find_lex $P1933, "$/"
    unless_null $P1933, vivify_665
    $P1933 = root_new ['parrot';'Hash']
  vivify_665:
    set $P1934, $P1933["default_value"]
    unless_null $P1934, vivify_666
    new $P1934, "Undef"
  vivify_666:
    unless $P1934, if_1932_end
.annotate 'line', 856
    find_lex $P1936, "$quant"
    set $S1937, $P1936
    iseq $I1938, $S1937, "*"
    unless $I1938, if_1935_end
.annotate 'line', 857
    find_lex $P1939, "$/"
    $P1940 = $P1939."CURSOR"()
    $P1940."panic"("Can't put default on slurpy parameter")
  if_1935_end:
.annotate 'line', 859
    find_lex $P1942, "$quant"
    set $S1943, $P1942
    iseq $I1944, $S1943, "!"
    unless $I1944, if_1941_end
.annotate 'line', 860
    find_lex $P1945, "$/"
    $P1946 = $P1945."CURSOR"()
    $P1946."panic"("Can't put default on required parameter")
  if_1941_end:
.annotate 'line', 862
    find_lex $P1947, "$past"
    find_lex $P1948, "$/"
    unless_null $P1948, vivify_667
    $P1948 = root_new ['parrot';'Hash']
  vivify_667:
    set $P1949, $P1948["default_value"]
    unless_null $P1949, vivify_668
    $P1949 = root_new ['parrot';'ResizablePMCArray']
  vivify_668:
    set $P1950, $P1949[0]
    unless_null $P1950, vivify_669
    $P1950 = root_new ['parrot';'Hash']
  vivify_669:
    set $P1951, $P1950["EXPR"]
    unless_null $P1951, vivify_670
    new $P1951, "Undef"
  vivify_670:
    $P1952 = $P1951."ast"()
    $P1947."viviself"($P1952)
  if_1932_end:
.annotate 'line', 864
    find_lex $P1954, "$past"
    $P1955 = $P1954."viviself"()
    if $P1955, unless_1953_end
    get_global $P1956, "@BLOCK"
    unless_null $P1956, vivify_671
    $P1956 = root_new ['parrot';'ResizablePMCArray']
  vivify_671:
    set $P1957, $P1956[0]
    unless_null $P1957, vivify_672
    new $P1957, "Undef"
  vivify_672:
    get_global $P1958, "@BLOCK"
    unless_null $P1958, vivify_673
    $P1958 = root_new ['parrot';'ResizablePMCArray']
  vivify_673:
    set $P1959, $P1958[0]
    unless_null $P1959, vivify_674
    new $P1959, "Undef"
  vivify_674:
    $P1960 = $P1959."arity"()
    set $N1961, $P1960
    new $P1962, 'Float'
    set $P1962, $N1961
    add $P1963, $P1962, 1
    $P1957."arity"($P1963)
  unless_1953_end:
.annotate 'line', 868
    find_lex $P1965, "$/"
    unless_null $P1965, vivify_675
    $P1965 = root_new ['parrot';'Hash']
  vivify_675:
    set $P1966, $P1965["typename"]
    unless_null $P1966, vivify_676
    new $P1966, "Undef"
  vivify_676:
    unless $P1966, if_1964_end
.annotate 'line', 869
    find_lex $P1967, "$past"
    find_lex $P1968, "$/"
    unless_null $P1968, vivify_677
    $P1968 = root_new ['parrot';'Hash']
  vivify_677:
    set $P1969, $P1968["typename"]
    unless_null $P1969, vivify_678
    $P1969 = root_new ['parrot';'ResizablePMCArray']
  vivify_678:
    set $P1970, $P1969[0]
    unless_null $P1970, vivify_679
    new $P1970, "Undef"
  vivify_679:
    $P1971 = $P1970."ast"()
    $P1967."multitype"($P1971)
  if_1964_end:
.annotate 'line', 873
    find_lex $P1973, "$/"
    unless_null $P1973, vivify_680
    $P1973 = root_new ['parrot';'Hash']
  vivify_680:
    set $P1974, $P1973["definedness"]
    unless_null $P1974, vivify_681
    new $P1974, "Undef"
  vivify_681:
    unless $P1974, if_1972_end
.annotate 'line', 874
    find_lex $P1975, "$/"
    unless_null $P1975, vivify_682
    $P1975 = root_new ['parrot';'Hash']
  vivify_682:
    set $P1976, $P1975["definedness"]
    unless_null $P1976, vivify_683
    $P1976 = root_new ['parrot';'ResizablePMCArray']
  vivify_683:
    set $P1977, $P1976[0]
    unless_null $P1977, vivify_684
    new $P1977, "Undef"
  vivify_684:
    set $S1978, $P1977
    new $P1979, 'String'
    set $P1979, $S1978
    find_lex $P1980, "$past"
    unless_null $P1980, vivify_685
    $P1980 = root_new ['parrot';'Hash']
    store_lex "$past", $P1980
  vivify_685:
    set $P1980["definedness"], $P1979
  if_1972_end:
.annotate 'line', 877
    find_lex $P1981, "$/"
    find_lex $P1982, "$past"
    $P1983 = $P1981."!make"($P1982)
.annotate 'line', 836
    .return ($P1983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("105_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_1985
    .param pmc param_1986
.annotate 'line', 880
    .lex "self", param_1985
    .lex "$/", param_1986
.annotate 'line', 881
    new $P1987, "Undef"
    .lex "$name", $P1987
.annotate 'line', 882
    new $P1988, "Undef"
    .lex "$past", $P1988
.annotate 'line', 881
    find_lex $P1989, "$/"
    set $S1990, $P1989
    new $P1991, 'String'
    set $P1991, $S1990
    store_lex "$name", $P1991
.annotate 'line', 882
    get_hll_global $P1992, ["PAST"], "Var"
    find_lex $P1993, "$name"
    find_lex $P1994, "$/"
    $P1995 = $P1992."new"($P1993 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1994 :named("node"))
    store_lex "$past", $P1995
.annotate 'line', 884
    get_global $P1996, "@BLOCK"
    unless_null $P1996, vivify_686
    $P1996 = root_new ['parrot';'ResizablePMCArray']
  vivify_686:
    set $P1997, $P1996[0]
    unless_null $P1997, vivify_687
    new $P1997, "Undef"
  vivify_687:
    find_lex $P1998, "$name"
    $P1997."symbol"($P1998, "lexical" :named("scope"))
.annotate 'line', 885
    find_lex $P1999, "$/"
    find_lex $P2000, "$past"
    $P2001 = $P1999."!make"($P2000)
.annotate 'line', 880
    .return ($P2001)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("106_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2003
    .param pmc param_2004
.annotate 'line', 888
    .lex "self", param_2003
    .lex "$/", param_2004
.annotate 'line', 889
    new $P2005, "Undef"
    .lex "$past", $P2005
    find_lex $P2006, "$/"
    unless_null $P2006, vivify_688
    $P2006 = root_new ['parrot';'Hash']
  vivify_688:
    set $P2007, $P2006["param_var"]
    unless_null $P2007, vivify_689
    new $P2007, "Undef"
  vivify_689:
    $P2008 = $P2007."ast"()
    store_lex "$past", $P2008
.annotate 'line', 890
    find_lex $P2009, "$past"
    find_lex $P2010, "$/"
    unless_null $P2010, vivify_690
    $P2010 = root_new ['parrot';'Hash']
  vivify_690:
    set $P2011, $P2010["param_var"]
    unless_null $P2011, vivify_691
    $P2011 = root_new ['parrot';'Hash']
  vivify_691:
    set $P2012, $P2011["name"]
    unless_null $P2012, vivify_692
    new $P2012, "Undef"
  vivify_692:
    set $S2013, $P2012
    $P2009."named"($S2013)
.annotate 'line', 891
    find_lex $P2014, "$/"
    find_lex $P2015, "$past"
    $P2016 = $P2014."!make"($P2015)
.annotate 'line', 888
    .return ($P2016)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("107_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2018
    .param pmc param_2019
.annotate 'line', 894
    .lex "self", param_2018
    .lex "$/", param_2019
.annotate 'line', 895
    $P2020 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2020
    get_hll_global $P2021, ["HLL"], "Compiler"
    find_lex $P2022, "$/"
    set $S2023, $P2022
    $P2024 = $P2021."parse_name"($S2023)
    store_lex "@name", $P2024
.annotate 'line', 896
    find_lex $P2025, "$/"
    get_hll_global $P2026, ["PAST"], "Var"
.annotate 'line', 897
    find_lex $P2027, "@name"
    $P2028 = $P2027."pop"()
    find_lex $P2029, "@name"
    $P2030 = $P2026."new"($P2028 :named("name"), $P2029 :named("namespace"), "package" :named("scope"))
.annotate 'line', 896
    $P2031 = $P2025."!make"($P2030)
.annotate 'line', 894
    .return ($P2031)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("108_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2033
    .param pmc param_2034
.annotate 'line', 903
    .lex "self", param_2033
    .lex "$/", param_2034
.annotate 'line', 904
    find_lex $P2035, "$/"
    find_lex $P2036, "$/"
    unless_null $P2036, vivify_693
    $P2036 = root_new ['parrot';'Hash']
  vivify_693:
    set $P2037, $P2036["trait_mod"]
    unless_null $P2037, vivify_694
    new $P2037, "Undef"
  vivify_694:
    $P2038 = $P2037."ast"()
    $P2039 = $P2035."!make"($P2038)
.annotate 'line', 903
    .return ($P2039)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("109_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2041
    .param pmc param_2042
.annotate 'line', 907
    .const 'Sub' $P2062 = "110_1299602554.641" 
    capture_lex $P2062
    .lex "self", param_2041
    .lex "$/", param_2042
.annotate 'line', 908
    new $P2043, "Undef"
    .lex "$cpast", $P2043
    find_lex $P2044, "$/"
    unless_null $P2044, vivify_695
    $P2044 = root_new ['parrot';'Hash']
  vivify_695:
    set $P2045, $P2044["circumfix"]
    unless_null $P2045, vivify_696
    $P2045 = root_new ['parrot';'ResizablePMCArray']
  vivify_696:
    set $P2046, $P2045[0]
    unless_null $P2046, vivify_697
    new $P2046, "Undef"
  vivify_697:
    $P2047 = $P2046."ast"()
    store_lex "$cpast", $P2047
.annotate 'line', 909
    find_lex $P2050, "$/"
    unless_null $P2050, vivify_698
    $P2050 = root_new ['parrot';'Hash']
  vivify_698:
    set $P2051, $P2050["longname"]
    unless_null $P2051, vivify_699
    new $P2051, "Undef"
  vivify_699:
    set $S2052, $P2051
    iseq $I2053, $S2052, "parrot_vtable"
    if $I2053, if_2049
.annotate 'line', 929
    find_lex $P2088, "$/"
    unless_null $P2088, vivify_700
    $P2088 = root_new ['parrot';'Hash']
  vivify_700:
    set $P2089, $P2088["longname"]
    unless_null $P2089, vivify_701
    new $P2089, "Undef"
  vivify_701:
    set $S2090, $P2089
    iseq $I2091, $S2090, "pirflags"
    if $I2091, if_2087
.annotate 'line', 933
    find_lex $P2095, "$/"
    $P2096 = $P2095."CURSOR"()
    new $P2097, 'String'
    set $P2097, "Trait '"
    find_lex $P2098, "$/"
    unless_null $P2098, vivify_702
    $P2098 = root_new ['parrot';'Hash']
  vivify_702:
    set $P2099, $P2098["longname"]
    unless_null $P2099, vivify_703
    new $P2099, "Undef"
  vivify_703:
    concat $P2100, $P2097, $P2099
    concat $P2101, $P2100, "' not implemented"
    $P2102 = $P2096."panic"($P2101)
.annotate 'line', 932
    set $P2086, $P2102
.annotate 'line', 929
    goto if_2087_end
  if_2087:
.annotate 'line', 930
    find_lex $P2092, "$/"
    $P2093 = $P2092."CURSOR"()
    $P2094 = $P2093."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 929
    set $P2086, $P2094
  if_2087_end:
    set $P2048, $P2086
.annotate 'line', 909
    goto if_2049_end
  if_2049:
.annotate 'line', 912
    get_hll_global $P2055, ["PAST"], "Val"
    find_lex $P2056, "$cpast"
    $P2057 = $P2055."ACCEPTS"($P2056)
    if $P2057, unless_2054_end
.annotate 'line', 911
    find_lex $P2058, "$/"
    $P2059 = $P2058."CURSOR"()
    $P2059."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2054_end:
.annotate 'line', 913
    find_lex $P2060, "$/"
    .const 'Sub' $P2062 = "110_1299602554.641" 
    newclosure $P2084, $P2062
    $P2085 = $P2060."!make"($P2084)
.annotate 'line', 909
    set $P2048, $P2085
  if_2049_end:
.annotate 'line', 907
    .return ($P2048)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2061"  :anon :subid("110_1299602554.641") :outer("109_1299602554.641")
    .param pmc param_2063
.annotate 'line', 913
    .lex "$match", param_2063
.annotate 'line', 914
    new $P2064, "Undef"
    .lex "$meth", $P2064
    find_lex $P2065, "$match"
    $P2066 = $P2065."ast"()
    set $P2067, $P2066["block_past"]
    unless_null $P2067, vivify_704
    new $P2067, "Undef"
  vivify_704:
    store_lex "$meth", $P2067
.annotate 'line', 915
    find_dynamic_lex $P2070, "$*PACKAGE-SETUP"
    unless_null $P2070, vivify_705
    get_hll_global $P2070, "$PACKAGE-SETUP"
    unless_null $P2070, vivify_706
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_706:
  vivify_705:
    defined $I2071, $P2070
    if $I2071, if_2069
    new $P2068, 'Integer'
    set $P2068, $I2071
    goto if_2069_end
  if_2069:
.annotate 'line', 916
    find_dynamic_lex $P2072, "$*PACKAGE-SETUP"
    unless_null $P2072, vivify_707
    get_hll_global $P2072, "$PACKAGE-SETUP"
    unless_null $P2072, vivify_708
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_708:
  vivify_707:
    get_hll_global $P2073, ["PAST"], "Op"
.annotate 'line', 918
    get_hll_global $P2074, ["PAST"], "Op"
.annotate 'line', 921
    get_hll_global $P2075, ["PAST"], "Var"
    $P2076 = $P2075."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2077 = $P2074."new"($P2076, "get_how PP" :named("pirop"))
.annotate 'line', 923
    get_hll_global $P2078, ["PAST"], "Var"
    $P2079 = $P2078."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2080, "$cpast"
    find_lex $P2081, "$meth"
    $P2082 = $P2073."new"($P2077, $P2079, $P2080, $P2081, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 916
    $P2083 = $P2072."push"($P2082)
.annotate 'line', 915
    set $P2068, $P2083
  if_2069_end:
.annotate 'line', 913
    .return ($P2068)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("111_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2106
    .param pmc param_2107
    .param pmc param_2108 :optional
    .param int has_param_2108 :opt_flag
.annotate 'line', 937
    .const 'Sub' $P2206 = "114_1299602554.641" 
    capture_lex $P2206
    .const 'Sub' $P2178 = "113_1299602554.641" 
    capture_lex $P2178
    .const 'Sub' $P2151 = "112_1299602554.641" 
    capture_lex $P2151
    new $P2105, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2105, control_2104
    push_eh $P2105
    .lex "self", param_2106
    .lex "$/", param_2107
    if has_param_2108, optparam_709
    new $P2109, "Undef"
    set param_2108, $P2109
  optparam_709:
    .lex "$key", param_2108
.annotate 'line', 938
    $P2110 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2110
.annotate 'line', 941
    new $P2111, "Undef"
    .lex "$name", $P2111
.annotate 'line', 942
    new $P2112, "Undef"
    .lex "$past", $P2112
.annotate 'line', 938

        $P2113 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2113
.annotate 'line', 941
    find_lex $P2114, "$/"
    unless_null $P2114, vivify_710
    $P2114 = root_new ['parrot';'Hash']
  vivify_710:
    set $P2115, $P2114["deflongname"]
    unless_null $P2115, vivify_711
    new $P2115, "Undef"
  vivify_711:
    $P2116 = $P2115."ast"()
    set $S2117, $P2116
    new $P2118, 'String'
    set $P2118, $S2117
    store_lex "$name", $P2118
    find_lex $P2119, "$past"
.annotate 'line', 943
    find_lex $P2121, "$/"
    unless_null $P2121, vivify_712
    $P2121 = root_new ['parrot';'Hash']
  vivify_712:
    set $P2122, $P2121["proto"]
    unless_null $P2122, vivify_713
    new $P2122, "Undef"
  vivify_713:
    if $P2122, if_2120
.annotate 'line', 982
    find_lex $P2174, "$key"
    set $S2175, $P2174
    iseq $I2176, $S2175, "open"
    if $I2176, if_2173
.annotate 'line', 995
    .const 'Sub' $P2206 = "114_1299602554.641" 
    capture_lex $P2206
    $P2206()
    goto if_2173_end
  if_2173:
.annotate 'line', 982
    .const 'Sub' $P2178 = "113_1299602554.641" 
    capture_lex $P2178
    $P2178()
  if_2173_end:
    goto if_2120_end
  if_2120:
.annotate 'line', 945
    get_hll_global $P2123, ["PAST"], "Stmts"
.annotate 'line', 946
    get_hll_global $P2124, ["PAST"], "Block"
    find_lex $P2125, "$name"
.annotate 'line', 947
    get_hll_global $P2126, ["PAST"], "Op"
.annotate 'line', 948
    get_hll_global $P2127, ["PAST"], "Var"
    $P2128 = $P2127."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2129, "$name"
    $P2130 = $P2126."new"($P2128, $P2129, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 947
    find_lex $P2131, "$/"
    $P2132 = $P2124."new"($P2130, $P2125 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2131 :named("node"))
.annotate 'line', 957
    get_hll_global $P2133, ["PAST"], "Block"
    new $P2134, "String"
    assign $P2134, "!PREFIX__"
    find_lex $P2135, "$name"
    concat $P2136, $P2134, $P2135
.annotate 'line', 958
    get_hll_global $P2137, ["PAST"], "Op"
.annotate 'line', 959
    get_hll_global $P2138, ["PAST"], "Var"
    $P2139 = $P2138."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2140, "$name"
    $P2141 = $P2137."new"($P2139, $P2140, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 958
    find_lex $P2142, "$/"
    $P2143 = $P2133."new"($P2141, $P2136 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2142 :named("node"))
.annotate 'line', 957
    $P2144 = $P2123."new"($P2132, $P2143)
.annotate 'line', 945
    store_lex "$past", $P2144
.annotate 'line', 969
    find_lex $P2146, "$past"
    $P2147 = $P2146."list"()
    defined $I2148, $P2147
    unless $I2148, for_undef_734
    iter $P2145, $P2147
    new $P2171, 'ExceptionHandler'
    set_label $P2171, loop2170_handler
    $P2171."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2171
  loop2170_test:
    unless $P2145, loop2170_done
    shift $P2149, $P2145
  loop2170_redo:
    .const 'Sub' $P2151 = "112_1299602554.641" 
    capture_lex $P2151
    $P2151($P2149)
  loop2170_next:
    goto loop2170_test
  loop2170_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2172, exception, 'type'
    eq $P2172, .CONTROL_LOOP_NEXT, loop2170_next
    eq $P2172, .CONTROL_LOOP_REDO, loop2170_redo
  loop2170_done:
    pop_eh 
  for_undef_734:
  if_2120_end:
.annotate 'line', 1031
    find_lex $P2264, "$/"
    find_lex $P2265, "$past"
    $P2266 = $P2264."!make"($P2265)
.annotate 'line', 937
    .return ($P2266)
  control_2104:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2267, exception, "payload"
    .return ($P2267)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2205"  :anon :subid("114_1299602554.641") :outer("111_1299602554.641")
.annotate 'line', 996
    new $P2207, "Undef"
    .lex "$regex", $P2207
.annotate 'line', 997
    get_hll_global $P2208, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2209, "$/"
    unless_null $P2209, vivify_714
    $P2209 = root_new ['parrot';'Hash']
  vivify_714:
    set $P2210, $P2209["p6regex"]
    unless_null $P2210, vivify_715
    new $P2210, "Undef"
  vivify_715:
    $P2211 = $P2210."ast"()
    get_global $P2212, "@BLOCK"
    $P2213 = $P2212."shift"()
    $P2214 = $P2208($P2211, $P2213)
    store_lex "$regex", $P2214
.annotate 'line', 998
    find_lex $P2215, "$regex"
    find_lex $P2216, "$name"
    $P2215."name"($P2216)
.annotate 'line', 1000
    get_hll_global $P2217, ["PAST"], "Op"
.annotate 'line', 1002
    get_hll_global $P2218, ["PAST"], "Var"
    new $P2219, "ResizablePMCArray"
    push $P2219, "Regex"
    $P2220 = $P2218."new"("Method" :named("name"), $P2219 :named("namespace"), "package" :named("scope"))
    find_lex $P2221, "$regex"
    $P2222 = $P2217."new"($P2220, $P2221, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1000
    store_lex "$past", $P2222
.annotate 'line', 1005
    find_dynamic_lex $P2224, "$*PACKAGE-SETUP"
    unless_null $P2224, vivify_716
    get_hll_global $P2224, "$PACKAGE-SETUP"
    unless_null $P2224, vivify_717
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_717:
  vivify_716:
    defined $I2225, $P2224
    unless $I2225, if_2223_end
.annotate 'line', 1006
    find_dynamic_lex $P2226, "$*PACKAGE-SETUP"
    unless_null $P2226, vivify_718
    get_hll_global $P2226, "$PACKAGE-SETUP"
    unless_null $P2226, vivify_719
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_719:
  vivify_718:
    get_hll_global $P2227, ["PAST"], "Op"
.annotate 'line', 1008
    get_hll_global $P2228, ["PAST"], "Op"
.annotate 'line', 1010
    get_hll_global $P2229, ["PAST"], "Var"
    $P2230 = $P2229."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2231 = $P2228."new"($P2230, "get_how PP" :named("pirop"))
.annotate 'line', 1012
    get_hll_global $P2232, ["PAST"], "Var"
    $P2233 = $P2232."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1013
    get_hll_global $P2234, ["PAST"], "Val"
    find_lex $P2235, "$name"
    $P2236 = $P2234."new"($P2235 :named("value"))
.annotate 'line', 1014
    get_hll_global $P2237, ["PAST"], "Val"
    find_lex $P2238, "$regex"
    $P2239 = $P2237."new"($P2238 :named("value"))
    $P2240 = $P2227."new"($P2231, $P2233, $P2236, $P2239, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1006
    $P2226."push"($P2240)
.annotate 'line', 1016
    find_dynamic_lex $P2241, "$*PACKAGE-SETUP"
    unless_null $P2241, vivify_720
    get_hll_global $P2241, "$PACKAGE-SETUP"
    unless_null $P2241, vivify_721
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_721:
  vivify_720:
    get_hll_global $P2242, ["PAST"], "Op"
.annotate 'line', 1018
    get_hll_global $P2243, ["PAST"], "Op"
.annotate 'line', 1020
    get_hll_global $P2244, ["PAST"], "Var"
    $P2245 = $P2244."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2246 = $P2243."new"($P2245, "get_how PP" :named("pirop"))
.annotate 'line', 1022
    get_hll_global $P2247, ["PAST"], "Var"
    $P2248 = $P2247."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1023
    get_hll_global $P2249, ["PAST"], "Val"
    new $P2250, "String"
    assign $P2250, "!PREFIX__"
    find_lex $P2251, "$name"
    concat $P2252, $P2250, $P2251
    $P2253 = $P2249."new"($P2252 :named("value"))
.annotate 'line', 1024
    get_hll_global $P2254, ["PAST"], "Var"
    new $P2255, "String"
    assign $P2255, "!PREFIX__"
    find_lex $P2256, "$name"
    concat $P2257, $P2255, $P2256
    $P2258 = $P2254."new"($P2257 :named("name"), "package" :named("scope"))
    $P2259 = $P2242."new"($P2246, $P2248, $P2253, $P2258, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1016
    $P2241."push"($P2259)
  if_2223_end:
.annotate 'line', 1028
    find_lex $P2260, "$regex"
    find_lex $P2261, "$past"
    unless_null $P2261, vivify_722
    $P2261 = root_new ['parrot';'Hash']
    store_lex "$past", $P2261
  vivify_722:
    set $P2261["sink"], $P2260
.annotate 'line', 1029
    find_lex $P2262, "@MODIFIERS"
    $P2263 = $P2262."shift"()
.annotate 'line', 995
    .return ($P2263)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2177"  :anon :subid("113_1299602554.641") :outer("111_1299602554.641")
.annotate 'line', 983
    $P2179 = root_new ['parrot';'Hash']
    .lex "%h", $P2179
.annotate 'line', 982
    find_lex $P2180, "%h"
.annotate 'line', 984
    find_lex $P2182, "$/"
    unless_null $P2182, vivify_723
    $P2182 = root_new ['parrot';'Hash']
  vivify_723:
    set $P2183, $P2182["sym"]
    unless_null $P2183, vivify_724
    new $P2183, "Undef"
  vivify_724:
    set $S2184, $P2183
    iseq $I2185, $S2184, "token"
    unless $I2185, if_2181_end
    new $P2186, "Integer"
    assign $P2186, 1
    find_lex $P2187, "%h"
    unless_null $P2187, vivify_725
    $P2187 = root_new ['parrot';'Hash']
    store_lex "%h", $P2187
  vivify_725:
    set $P2187["r"], $P2186
  if_2181_end:
.annotate 'line', 985
    find_lex $P2189, "$/"
    unless_null $P2189, vivify_726
    $P2189 = root_new ['parrot';'Hash']
  vivify_726:
    set $P2190, $P2189["sym"]
    unless_null $P2190, vivify_727
    new $P2190, "Undef"
  vivify_727:
    set $S2191, $P2190
    iseq $I2192, $S2191, "rule"
    unless $I2192, if_2188_end
    new $P2193, "Integer"
    assign $P2193, 1
    find_lex $P2194, "%h"
    unless_null $P2194, vivify_728
    $P2194 = root_new ['parrot';'Hash']
    store_lex "%h", $P2194
  vivify_728:
    set $P2194["r"], $P2193
    new $P2195, "Integer"
    assign $P2195, 1
    find_lex $P2196, "%h"
    unless_null $P2196, vivify_729
    $P2196 = root_new ['parrot';'Hash']
    store_lex "%h", $P2196
  vivify_729:
    set $P2196["s"], $P2195
  if_2188_end:
.annotate 'line', 986
    find_lex $P2197, "@MODIFIERS"
    find_lex $P2198, "%h"
    $P2197."unshift"($P2198)
.annotate 'line', 987

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 991
    get_global $P2199, "@BLOCK"
    unless_null $P2199, vivify_730
    $P2199 = root_new ['parrot';'ResizablePMCArray']
  vivify_730:
    set $P2200, $P2199[0]
    unless_null $P2200, vivify_731
    new $P2200, "Undef"
  vivify_731:
    $P2200."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 992
    get_global $P2201, "@BLOCK"
    unless_null $P2201, vivify_732
    $P2201 = root_new ['parrot';'ResizablePMCArray']
  vivify_732:
    set $P2202, $P2201[0]
    unless_null $P2202, vivify_733
    new $P2202, "Undef"
  vivify_733:
    $P2202."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 993
    new $P2203, "Exception"
    set $P2203['type'], .CONTROL_RETURN
    new $P2204, "Integer"
    assign $P2204, 0
    setattribute $P2203, 'payload', $P2204
    throw $P2203
.annotate 'line', 982
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2150"  :anon :subid("112_1299602554.641") :outer("111_1299602554.641")
    .param pmc param_2152
.annotate 'line', 969
    .lex "$_", param_2152
.annotate 'line', 970
    find_dynamic_lex $P2153, "$*PACKAGE-SETUP"
    unless_null $P2153, vivify_735
    get_hll_global $P2153, "$PACKAGE-SETUP"
    unless_null $P2153, vivify_736
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_736:
  vivify_735:
    get_hll_global $P2154, ["PAST"], "Op"
.annotate 'line', 972
    get_hll_global $P2155, ["PAST"], "Op"
.annotate 'line', 974
    get_hll_global $P2156, ["PAST"], "Var"
    $P2157 = $P2156."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2158 = $P2155."new"($P2157, "get_how PP" :named("pirop"))
.annotate 'line', 976
    get_hll_global $P2159, ["PAST"], "Var"
    $P2160 = $P2159."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 977
    get_hll_global $P2161, ["PAST"], "Val"
    find_lex $P2162, "$_"
    $P2163 = $P2162."name"()
    $P2164 = $P2161."new"($P2163 :named("value"))
.annotate 'line', 978
    get_hll_global $P2165, ["PAST"], "Val"
    find_lex $P2166, "$_"
    $P2167 = $P2165."new"($P2166 :named("value"))
    $P2168 = $P2154."new"($P2158, $P2160, $P2164, $P2167, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 970
    $P2169 = $P2153."push"($P2168)
.annotate 'line', 969
    .return ($P2169)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("115_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2269
    .param pmc param_2270
.annotate 'line', 1035
    .lex "self", param_2269
    .lex "$/", param_2270
.annotate 'line', 1036
    new $P2271, "Undef"
    .lex "$past", $P2271
    find_lex $P2274, "$/"
    unless_null $P2274, vivify_737
    $P2274 = root_new ['parrot';'Hash']
  vivify_737:
    set $P2275, $P2274["args"]
    unless_null $P2275, vivify_738
    new $P2275, "Undef"
  vivify_738:
    if $P2275, if_2273
    get_hll_global $P2280, ["PAST"], "Op"
    find_lex $P2281, "$/"
    $P2282 = $P2280."new"($P2281 :named("node"))
    set $P2272, $P2282
    goto if_2273_end
  if_2273:
    find_lex $P2276, "$/"
    unless_null $P2276, vivify_739
    $P2276 = root_new ['parrot';'Hash']
  vivify_739:
    set $P2277, $P2276["args"]
    unless_null $P2277, vivify_740
    $P2277 = root_new ['parrot';'ResizablePMCArray']
  vivify_740:
    set $P2278, $P2277[0]
    unless_null $P2278, vivify_741
    new $P2278, "Undef"
  vivify_741:
    $P2279 = $P2278."ast"()
    set $P2272, $P2279
  if_2273_end:
    store_lex "$past", $P2272
.annotate 'line', 1037
    find_lex $P2284, "$/"
    unless_null $P2284, vivify_742
    $P2284 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2285, $P2284["quote"]
    unless_null $P2285, vivify_743
    new $P2285, "Undef"
  vivify_743:
    if $P2285, if_2283
.annotate 'line', 1041
    find_lex $P2292, "$/"
    unless_null $P2292, vivify_744
    $P2292 = root_new ['parrot';'Hash']
  vivify_744:
    set $P2293, $P2292["longname"]
    unless_null $P2293, vivify_745
    new $P2293, "Undef"
  vivify_745:
    set $S2294, $P2293
    iseq $I2295, $S2294, "HOW"
    if $I2295, if_2291
.annotate 'line', 1045
    find_lex $P2299, "$/"
    unless_null $P2299, vivify_746
    $P2299 = root_new ['parrot';'Hash']
  vivify_746:
    set $P2300, $P2299["longname"]
    unless_null $P2300, vivify_747
    new $P2300, "Undef"
  vivify_747:
    set $S2301, $P2300
    iseq $I2302, $S2301, "WHAT"
    if $I2302, if_2298
.annotate 'line', 1049
    find_lex $P2304, "$past"
    find_lex $P2305, "$/"
    unless_null $P2305, vivify_748
    $P2305 = root_new ['parrot';'Hash']
  vivify_748:
    set $P2306, $P2305["longname"]
    unless_null $P2306, vivify_749
    new $P2306, "Undef"
  vivify_749:
    set $S2307, $P2306
    $P2304."name"($S2307)
.annotate 'line', 1050
    find_lex $P2308, "$past"
    $P2308."pasttype"("callmethod")
.annotate 'line', 1048
    goto if_2298_end
  if_2298:
.annotate 'line', 1046
    find_lex $P2303, "$past"
    $P2303."pirop"("get_what PP")
  if_2298_end:
.annotate 'line', 1045
    goto if_2291_end
  if_2291:
.annotate 'line', 1042
    find_lex $P2296, "$past"
    $P2296."pirop"("get_how PP")
.annotate 'line', 1043
    find_lex $P2297, "$past"
    $P2297."pasttype"("pirop")
  if_2291_end:
.annotate 'line', 1041
    goto if_2283_end
  if_2283:
.annotate 'line', 1038
    find_lex $P2286, "$past"
    find_lex $P2287, "$/"
    unless_null $P2287, vivify_750
    $P2287 = root_new ['parrot';'Hash']
  vivify_750:
    set $P2288, $P2287["quote"]
    unless_null $P2288, vivify_751
    new $P2288, "Undef"
  vivify_751:
    $P2289 = $P2288."ast"()
    $P2286."name"($P2289)
.annotate 'line', 1039
    find_lex $P2290, "$past"
    $P2290."pasttype"("callmethod")
  if_2283_end:
.annotate 'line', 1052
    find_lex $P2309, "$/"
    find_lex $P2310, "$past"
    $P2311 = $P2309."!make"($P2310)
.annotate 'line', 1035
    .return ($P2311)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("116_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2313
    .param pmc param_2314
.annotate 'line', 1057
    .lex "self", param_2313
    .lex "$/", param_2314
.annotate 'line', 1058
    find_lex $P2315, "$/"
    get_hll_global $P2316, ["PAST"], "Var"
    $P2317 = $P2316."new"("self" :named("name"))
    $P2318 = $P2315."!make"($P2317)
.annotate 'line', 1057
    .return ($P2318)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("117_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2320
    .param pmc param_2321
.annotate 'line', 1061
    .lex "self", param_2320
    .lex "$/", param_2321
.annotate 'line', 1062
    new $P2322, "Undef"
    .lex "$past", $P2322
    find_lex $P2323, "$/"
    unless_null $P2323, vivify_752
    $P2323 = root_new ['parrot';'Hash']
  vivify_752:
    set $P2324, $P2323["args"]
    unless_null $P2324, vivify_753
    new $P2324, "Undef"
  vivify_753:
    $P2325 = $P2324."ast"()
    store_lex "$past", $P2325
.annotate 'line', 1063
    find_lex $P2326, "$past"
    find_lex $P2327, "$/"
    unless_null $P2327, vivify_754
    $P2327 = root_new ['parrot';'Hash']
  vivify_754:
    set $P2328, $P2327["deflongname"]
    unless_null $P2328, vivify_755
    new $P2328, "Undef"
  vivify_755:
    set $S2329, $P2328
    $P2326."name"($S2329)
.annotate 'line', 1064
    find_lex $P2330, "$/"
    find_lex $P2331, "$past"
    $P2332 = $P2330."!make"($P2331)
.annotate 'line', 1061
    .return ($P2332)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("118_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2334
    .param pmc param_2335
.annotate 'line', 1067
    .lex "self", param_2334
    .lex "$/", param_2335
.annotate 'line', 1068
    $P2336 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2336
.annotate 'line', 1069
    new $P2337, "Undef"
    .lex "$name", $P2337
.annotate 'line', 1071
    new $P2338, "Undef"
    .lex "$var", $P2338
.annotate 'line', 1073
    new $P2339, "Undef"
    .lex "$past", $P2339
.annotate 'line', 1068
    find_lex $P2340, "$/"
    unless_null $P2340, vivify_756
    $P2340 = root_new ['parrot';'Hash']
  vivify_756:
    set $P2341, $P2340["name"]
    unless_null $P2341, vivify_757
    $P2341 = root_new ['parrot';'Hash']
  vivify_757:
    set $P2342, $P2341["identifier"]
    unless_null $P2342, vivify_758
    new $P2342, "Undef"
  vivify_758:
    clone $P2343, $P2342
    store_lex "@ns", $P2343
.annotate 'line', 1069
    find_lex $P2344, "@ns"
    $P2345 = $P2344."pop"()
    store_lex "$name", $P2345
.annotate 'line', 1070
    find_lex $P2349, "@ns"
    if $P2349, if_2348
    set $P2347, $P2349
    goto if_2348_end
  if_2348:
    find_lex $P2350, "@ns"
    unless_null $P2350, vivify_759
    $P2350 = root_new ['parrot';'ResizablePMCArray']
  vivify_759:
    set $P2351, $P2350[0]
    unless_null $P2351, vivify_760
    new $P2351, "Undef"
  vivify_760:
    set $S2352, $P2351
    iseq $I2353, $S2352, "GLOBAL"
    new $P2347, 'Integer'
    set $P2347, $I2353
  if_2348_end:
    unless $P2347, if_2346_end
    find_lex $P2354, "@ns"
    $P2354."shift"()
  if_2346_end:
.annotate 'line', 1072
    get_hll_global $P2355, ["PAST"], "Var"
    find_lex $P2356, "$name"
    set $S2357, $P2356
    find_lex $P2358, "@ns"
    $P2359 = $P2355."new"($S2357 :named("name"), $P2358 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2359
.annotate 'line', 1073
    find_lex $P2360, "$var"
    store_lex "$past", $P2360
.annotate 'line', 1074
    find_lex $P2362, "$/"
    unless_null $P2362, vivify_761
    $P2362 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2363, $P2362["args"]
    unless_null $P2363, vivify_762
    new $P2363, "Undef"
  vivify_762:
    unless $P2363, if_2361_end
.annotate 'line', 1075
    find_lex $P2364, "$/"
    unless_null $P2364, vivify_763
    $P2364 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2365, $P2364["args"]
    unless_null $P2365, vivify_764
    $P2365 = root_new ['parrot';'ResizablePMCArray']
  vivify_764:
    set $P2366, $P2365[0]
    unless_null $P2366, vivify_765
    new $P2366, "Undef"
  vivify_765:
    $P2367 = $P2366."ast"()
    store_lex "$past", $P2367
.annotate 'line', 1076
    find_lex $P2368, "$past"
    find_lex $P2369, "$var"
    $P2368."unshift"($P2369)
  if_2361_end:
.annotate 'line', 1078
    find_lex $P2370, "$/"
    find_lex $P2371, "$past"
    $P2372 = $P2370."!make"($P2371)
.annotate 'line', 1067
    .return ($P2372)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("119_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2374
    .param pmc param_2375
.annotate 'line', 1081
    .lex "self", param_2374
    .lex "$/", param_2375
.annotate 'line', 1082
    new $P2376, "Undef"
    .lex "$past", $P2376
.annotate 'line', 1083
    new $P2377, "Undef"
    .lex "$pirop", $P2377
.annotate 'line', 1082
    find_lex $P2380, "$/"
    unless_null $P2380, vivify_766
    $P2380 = root_new ['parrot';'Hash']
  vivify_766:
    set $P2381, $P2380["args"]
    unless_null $P2381, vivify_767
    new $P2381, "Undef"
  vivify_767:
    if $P2381, if_2379
    get_hll_global $P2386, ["PAST"], "Op"
    find_lex $P2387, "$/"
    $P2388 = $P2386."new"($P2387 :named("node"))
    set $P2378, $P2388
    goto if_2379_end
  if_2379:
    find_lex $P2382, "$/"
    unless_null $P2382, vivify_768
    $P2382 = root_new ['parrot';'Hash']
  vivify_768:
    set $P2383, $P2382["args"]
    unless_null $P2383, vivify_769
    $P2383 = root_new ['parrot';'ResizablePMCArray']
  vivify_769:
    set $P2384, $P2383[0]
    unless_null $P2384, vivify_770
    new $P2384, "Undef"
  vivify_770:
    $P2385 = $P2384."ast"()
    set $P2378, $P2385
  if_2379_end:
    store_lex "$past", $P2378
.annotate 'line', 1083
    find_lex $P2389, "$/"
    unless_null $P2389, vivify_771
    $P2389 = root_new ['parrot';'Hash']
  vivify_771:
    set $P2390, $P2389["op"]
    unless_null $P2390, vivify_772
    new $P2390, "Undef"
  vivify_772:
    set $S2391, $P2390
    new $P2392, 'String'
    set $P2392, $S2391
    store_lex "$pirop", $P2392
.annotate 'line', 1084

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2393 = box $S0
    
    store_lex "$pirop", $P2393
.annotate 'line', 1091
    find_lex $P2394, "$past"
    find_lex $P2395, "$pirop"
    $P2394."pirop"($P2395)
.annotate 'line', 1092
    find_lex $P2396, "$past"
    $P2396."pasttype"("pirop")
.annotate 'line', 1093
    find_lex $P2397, "$/"
    find_lex $P2398, "$past"
    $P2399 = $P2397."!make"($P2398)
.annotate 'line', 1081
    .return ($P2399)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("120_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2401
    .param pmc param_2402
.annotate 'line', 1096
    .lex "self", param_2401
    .lex "$/", param_2402
.annotate 'line', 1097
    find_lex $P2403, "$/"
    get_hll_global $P2404, ["PAST"], "Op"
    $P2405 = $P2404."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2406 = $P2403."!make"($P2405)
.annotate 'line', 1096
    .return ($P2406)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("121_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2408
    .param pmc param_2409
.annotate 'line', 1102
    .lex "self", param_2408
    .lex "$/", param_2409
    find_lex $P2410, "$/"
    find_lex $P2411, "$/"
    unless_null $P2411, vivify_773
    $P2411 = root_new ['parrot';'Hash']
  vivify_773:
    set $P2412, $P2411["arglist"]
    unless_null $P2412, vivify_774
    new $P2412, "Undef"
  vivify_774:
    $P2413 = $P2412."ast"()
    $P2414 = $P2410."!make"($P2413)
    .return ($P2414)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("122_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2416
    .param pmc param_2417
.annotate 'line', 1104
    .const 'Sub' $P2428 = "123_1299602554.641" 
    capture_lex $P2428
    .lex "self", param_2416
    .lex "$/", param_2417
.annotate 'line', 1105
    new $P2418, "Undef"
    .lex "$past", $P2418
.annotate 'line', 1113
    new $P2419, "Undef"
    .lex "$i", $P2419
.annotate 'line', 1114
    new $P2420, "Undef"
    .lex "$n", $P2420
.annotate 'line', 1105
    get_hll_global $P2421, ["PAST"], "Op"
    find_lex $P2422, "$/"
    $P2423 = $P2421."new"("call" :named("pasttype"), $P2422 :named("node"))
    store_lex "$past", $P2423
.annotate 'line', 1106
    find_lex $P2425, "$/"
    unless_null $P2425, vivify_775
    $P2425 = root_new ['parrot';'Hash']
  vivify_775:
    set $P2426, $P2425["EXPR"]
    unless_null $P2426, vivify_776
    new $P2426, "Undef"
  vivify_776:
    unless $P2426, if_2424_end
    .const 'Sub' $P2428 = "123_1299602554.641" 
    capture_lex $P2428
    $P2428()
  if_2424_end:
.annotate 'line', 1113
    new $P2460, "Integer"
    assign $P2460, 0
    store_lex "$i", $P2460
.annotate 'line', 1114
    find_lex $P2461, "$past"
    $P2462 = $P2461."list"()
    set $N2463, $P2462
    new $P2464, 'Float'
    set $P2464, $N2463
    store_lex "$n", $P2464
.annotate 'line', 1115
    new $P2512, 'ExceptionHandler'
    set_label $P2512, loop2511_handler
    $P2512."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2512
  loop2511_test:
    find_lex $P2465, "$i"
    set $N2466, $P2465
    find_lex $P2467, "$n"
    set $N2468, $P2467
    islt $I2469, $N2466, $N2468
    unless $I2469, loop2511_done
  loop2511_redo:
.annotate 'line', 1116
    find_lex $P2471, "$i"
    set $I2472, $P2471
    find_lex $P2473, "$past"
    unless_null $P2473, vivify_780
    $P2473 = root_new ['parrot';'ResizablePMCArray']
  vivify_780:
    set $P2474, $P2473[$I2472]
    unless_null $P2474, vivify_781
    new $P2474, "Undef"
  vivify_781:
    $S2475 = $P2474."name"()
    iseq $I2476, $S2475, "&prefix:<|>"
    unless $I2476, if_2470_end
.annotate 'line', 1117
    find_lex $P2477, "$i"
    set $I2478, $P2477
    find_lex $P2479, "$past"
    unless_null $P2479, vivify_782
    $P2479 = root_new ['parrot';'ResizablePMCArray']
  vivify_782:
    set $P2480, $P2479[$I2478]
    unless_null $P2480, vivify_783
    $P2480 = root_new ['parrot';'ResizablePMCArray']
  vivify_783:
    set $P2481, $P2480[0]
    unless_null $P2481, vivify_784
    new $P2481, "Undef"
  vivify_784:
    find_lex $P2482, "$i"
    set $I2483, $P2482
    find_lex $P2484, "$past"
    unless_null $P2484, vivify_785
    $P2484 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2484
  vivify_785:
    set $P2484[$I2483], $P2481
.annotate 'line', 1118
    find_lex $P2485, "$i"
    set $I2486, $P2485
    find_lex $P2487, "$past"
    unless_null $P2487, vivify_786
    $P2487 = root_new ['parrot';'ResizablePMCArray']
  vivify_786:
    set $P2488, $P2487[$I2486]
    unless_null $P2488, vivify_787
    new $P2488, "Undef"
  vivify_787:
    $P2488."flat"(1)
.annotate 'line', 1119
    find_lex $P2492, "$i"
    set $I2493, $P2492
    find_lex $P2494, "$past"
    unless_null $P2494, vivify_788
    $P2494 = root_new ['parrot';'ResizablePMCArray']
  vivify_788:
    set $P2495, $P2494[$I2493]
    unless_null $P2495, vivify_789
    new $P2495, "Undef"
  vivify_789:
    get_hll_global $P2496, ["PAST"], "Val"
    $P2497 = $P2495."isa"($P2496)
    if $P2497, if_2491
    set $P2490, $P2497
    goto if_2491_end
  if_2491:
.annotate 'line', 1120
    find_lex $P2498, "$i"
    set $I2499, $P2498
    find_lex $P2500, "$past"
    unless_null $P2500, vivify_790
    $P2500 = root_new ['parrot';'ResizablePMCArray']
  vivify_790:
    set $P2501, $P2500[$I2499]
    unless_null $P2501, vivify_791
    new $P2501, "Undef"
  vivify_791:
    $S2502 = $P2501."name"()
    substr $S2503, $S2502, 0, 1
    iseq $I2504, $S2503, "%"
    new $P2490, 'Integer'
    set $P2490, $I2504
  if_2491_end:
    unless $P2490, if_2489_end
.annotate 'line', 1121
    find_lex $P2505, "$i"
    set $I2506, $P2505
    find_lex $P2507, "$past"
    unless_null $P2507, vivify_792
    $P2507 = root_new ['parrot';'ResizablePMCArray']
  vivify_792:
    set $P2508, $P2507[$I2506]
    unless_null $P2508, vivify_793
    new $P2508, "Undef"
  vivify_793:
    $P2508."named"(1)
  if_2489_end:
  if_2470_end:
.annotate 'line', 1116
    find_lex $P2509, "$i"
    clone $P2510, $P2509
    inc $P2509
  loop2511_next:
.annotate 'line', 1115
    goto loop2511_test
  loop2511_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2513, exception, 'type'
    eq $P2513, .CONTROL_LOOP_NEXT, loop2511_next
    eq $P2513, .CONTROL_LOOP_REDO, loop2511_redo
  loop2511_done:
    pop_eh 
.annotate 'line', 1126
    find_lex $P2514, "$/"
    find_lex $P2515, "$past"
    $P2516 = $P2514."!make"($P2515)
.annotate 'line', 1104
    .return ($P2516)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2427"  :anon :subid("123_1299602554.641") :outer("122_1299602554.641")
.annotate 'line', 1106
    .const 'Sub' $P2449 = "124_1299602554.641" 
    capture_lex $P2449
.annotate 'line', 1107
    new $P2429, "Undef"
    .lex "$expr", $P2429
    find_lex $P2430, "$/"
    unless_null $P2430, vivify_777
    $P2430 = root_new ['parrot';'Hash']
  vivify_777:
    set $P2431, $P2430["EXPR"]
    unless_null $P2431, vivify_778
    new $P2431, "Undef"
  vivify_778:
    $P2432 = $P2431."ast"()
    store_lex "$expr", $P2432
.annotate 'line', 1108
    find_lex $P2437, "$expr"
    $S2438 = $P2437."name"()
    iseq $I2439, $S2438, "&infix:<,>"
    if $I2439, if_2436
    new $P2435, 'Integer'
    set $P2435, $I2439
    goto if_2436_end
  if_2436:
    find_lex $P2440, "$expr"
    $P2441 = $P2440."named"()
    isfalse $I2442, $P2441
    new $P2435, 'Integer'
    set $P2435, $I2442
  if_2436_end:
    if $P2435, if_2434
.annotate 'line', 1111
    find_lex $P2457, "$past"
    find_lex $P2458, "$expr"
    $P2459 = $P2457."push"($P2458)
    set $P2433, $P2459
.annotate 'line', 1108
    goto if_2434_end
  if_2434:
.annotate 'line', 1109
    find_lex $P2444, "$expr"
    $P2445 = $P2444."list"()
    defined $I2446, $P2445
    unless $I2446, for_undef_779
    iter $P2443, $P2445
    new $P2455, 'ExceptionHandler'
    set_label $P2455, loop2454_handler
    $P2455."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2455
  loop2454_test:
    unless $P2443, loop2454_done
    shift $P2447, $P2443
  loop2454_redo:
    .const 'Sub' $P2449 = "124_1299602554.641" 
    capture_lex $P2449
    $P2449($P2447)
  loop2454_next:
    goto loop2454_test
  loop2454_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2456, exception, 'type'
    eq $P2456, .CONTROL_LOOP_NEXT, loop2454_next
    eq $P2456, .CONTROL_LOOP_REDO, loop2454_redo
  loop2454_done:
    pop_eh 
  for_undef_779:
.annotate 'line', 1108
    set $P2433, $P2443
  if_2434_end:
.annotate 'line', 1106
    .return ($P2433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2448"  :anon :subid("124_1299602554.641") :outer("123_1299602554.641")
    .param pmc param_2450
.annotate 'line', 1109
    .lex "$_", param_2450
    find_lex $P2451, "$past"
    find_lex $P2452, "$_"
    $P2453 = $P2451."push"($P2452)
    .return ($P2453)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("125_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2518
    .param pmc param_2519
.annotate 'line', 1129
    .lex "self", param_2518
    .lex "$/", param_2519
    find_lex $P2520, "$/"
    find_lex $P2521, "$/"
    unless_null $P2521, vivify_794
    $P2521 = root_new ['parrot';'Hash']
  vivify_794:
    set $P2522, $P2521["multi_declarator"]
    unless_null $P2522, vivify_795
    new $P2522, "Undef"
  vivify_795:
    $P2523 = $P2522."ast"()
    $P2524 = $P2520."!make"($P2523)
    .return ($P2524)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("126_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2526
    .param pmc param_2527
.annotate 'line', 1131
    .lex "self", param_2526
    .lex "$/", param_2527
    find_lex $P2528, "$/"
    find_lex $P2529, "$/"
    unless_null $P2529, vivify_796
    $P2529 = root_new ['parrot';'Hash']
  vivify_796:
    set $P2530, $P2529["value"]
    unless_null $P2530, vivify_797
    new $P2530, "Undef"
  vivify_797:
    $P2531 = $P2530."ast"()
    $P2532 = $P2528."!make"($P2531)
    .return ($P2532)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("127_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2534
    .param pmc param_2535
.annotate 'line', 1133
    .lex "self", param_2534
    .lex "$/", param_2535
.annotate 'line', 1134
    find_lex $P2536, "$/"
.annotate 'line', 1135
    find_lex $P2539, "$/"
    unless_null $P2539, vivify_798
    $P2539 = root_new ['parrot';'Hash']
  vivify_798:
    set $P2540, $P2539["EXPR"]
    unless_null $P2540, vivify_799
    new $P2540, "Undef"
  vivify_799:
    if $P2540, if_2538
.annotate 'line', 1136
    get_hll_global $P2545, ["PAST"], "Op"
    find_lex $P2546, "$/"
    $P2547 = $P2545."new"("list" :named("pasttype"), $P2546 :named("node"))
    set $P2537, $P2547
.annotate 'line', 1135
    goto if_2538_end
  if_2538:
    find_lex $P2541, "$/"
    unless_null $P2541, vivify_800
    $P2541 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2542, $P2541["EXPR"]
    unless_null $P2542, vivify_801
    $P2542 = root_new ['parrot';'ResizablePMCArray']
  vivify_801:
    set $P2543, $P2542[0]
    unless_null $P2543, vivify_802
    new $P2543, "Undef"
  vivify_802:
    $P2544 = $P2543."ast"()
    set $P2537, $P2544
  if_2538_end:
    $P2548 = $P2536."!make"($P2537)
.annotate 'line', 1133
    .return ($P2548)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("128_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2550
    .param pmc param_2551
.annotate 'line', 1139
    .lex "self", param_2550
    .lex "$/", param_2551
.annotate 'line', 1140
    new $P2552, "Undef"
    .lex "$past", $P2552
.annotate 'line', 1139
    find_lex $P2553, "$past"
.annotate 'line', 1141
    find_lex $P2555, "$/"
    unless_null $P2555, vivify_803
    $P2555 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2556, $P2555["EXPR"]
    unless_null $P2556, vivify_804
    new $P2556, "Undef"
  vivify_804:
    if $P2556, if_2554
.annotate 'line', 1148
    get_hll_global $P2568, ["PAST"], "Op"
    $P2569 = $P2568."new"("list" :named("pasttype"))
    store_lex "$past", $P2569
.annotate 'line', 1147
    goto if_2554_end
  if_2554:
.annotate 'line', 1142
    find_lex $P2557, "$/"
    unless_null $P2557, vivify_805
    $P2557 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2558, $P2557["EXPR"]
    unless_null $P2558, vivify_806
    $P2558 = root_new ['parrot';'ResizablePMCArray']
  vivify_806:
    set $P2559, $P2558[0]
    unless_null $P2559, vivify_807
    new $P2559, "Undef"
  vivify_807:
    $P2560 = $P2559."ast"()
    store_lex "$past", $P2560
.annotate 'line', 1143
    find_lex $P2562, "$past"
    $S2563 = $P2562."name"()
    isne $I2564, $S2563, "&infix:<,>"
    unless $I2564, if_2561_end
.annotate 'line', 1144
    get_hll_global $P2565, ["PAST"], "Op"
    find_lex $P2566, "$past"
    $P2567 = $P2565."new"($P2566, "list" :named("pasttype"))
    store_lex "$past", $P2567
  if_2561_end:
  if_2554_end:
.annotate 'line', 1150
    find_lex $P2570, "$past"
    $P2570."name"("&circumfix:<[ ]>")
.annotate 'line', 1151
    find_lex $P2571, "$/"
    find_lex $P2572, "$past"
    $P2573 = $P2571."!make"($P2572)
.annotate 'line', 1139
    .return ($P2573)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("129_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2575
    .param pmc param_2576
.annotate 'line', 1154
    .lex "self", param_2575
    .lex "$/", param_2576
    find_lex $P2577, "$/"
    find_lex $P2578, "$/"
    unless_null $P2578, vivify_808
    $P2578 = root_new ['parrot';'Hash']
  vivify_808:
    set $P2579, $P2578["quote_EXPR"]
    unless_null $P2579, vivify_809
    new $P2579, "Undef"
  vivify_809:
    $P2580 = $P2579."ast"()
    $P2581 = $P2577."!make"($P2580)
    .return ($P2581)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("130_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2583
    .param pmc param_2584
.annotate 'line', 1155
    .lex "self", param_2583
    .lex "$/", param_2584
    find_lex $P2585, "$/"
    find_lex $P2586, "$/"
    unless_null $P2586, vivify_810
    $P2586 = root_new ['parrot';'Hash']
  vivify_810:
    set $P2587, $P2586["quote_EXPR"]
    unless_null $P2587, vivify_811
    new $P2587, "Undef"
  vivify_811:
    $P2588 = $P2587."ast"()
    $P2589 = $P2585."!make"($P2588)
    .return ($P2589)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("131_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2591
    .param pmc param_2592
.annotate 'line', 1157
    .const 'Sub' $P2603 = "132_1299602554.641" 
    capture_lex $P2603
    .lex "self", param_2591
    .lex "$/", param_2592
.annotate 'line', 1158
    find_lex $P2595, "$/"
    unless_null $P2595, vivify_812
    $P2595 = root_new ['parrot';'Hash']
  vivify_812:
    set $P2596, $P2595["pblock"]
    unless_null $P2596, vivify_813
    $P2596 = root_new ['parrot';'Hash']
  vivify_813:
    set $P2597, $P2596["blockoid"]
    unless_null $P2597, vivify_814
    $P2597 = root_new ['parrot';'Hash']
  vivify_814:
    set $P2598, $P2597["statementlist"]
    unless_null $P2598, vivify_815
    $P2598 = root_new ['parrot';'Hash']
  vivify_815:
    set $P2599, $P2598["statement"]
    unless_null $P2599, vivify_816
    new $P2599, "Undef"
  vivify_816:
    set $N2600, $P2599
    isgt $I2601, $N2600, 0.0
    if $I2601, if_2594
.annotate 'line', 1163
    find_lex $P2616, "$/"
    unless_null $P2616, vivify_817
    $P2616 = root_new ['parrot';'Hash']
  vivify_817:
    set $P2617, $P2616["pblock"]
    unless_null $P2617, vivify_818
    $P2617 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2618, $P2617["blockoid"]
    unless_null $P2618, vivify_819
    $P2618 = root_new ['parrot';'Hash']
  vivify_819:
    set $P2619, $P2618["you_are_here"]
    unless_null $P2619, vivify_820
    new $P2619, "Undef"
  vivify_820:
    if $P2619, if_2615
.annotate 'line', 1167
    find_lex $P2625, "$/"
    $P2626 = "vivitype"("%")
    $P2627 = $P2625."!make"($P2626)
.annotate 'line', 1166
    set $P2614, $P2627
.annotate 'line', 1163
    goto if_2615_end
  if_2615:
.annotate 'line', 1164
    find_lex $P2620, "$/"
    find_lex $P2621, "$/"
    unless_null $P2621, vivify_821
    $P2621 = root_new ['parrot';'Hash']
  vivify_821:
    set $P2622, $P2621["pblock"]
    unless_null $P2622, vivify_822
    new $P2622, "Undef"
  vivify_822:
    $P2623 = $P2622."ast"()
    $P2624 = $P2620."!make"($P2623)
.annotate 'line', 1163
    set $P2614, $P2624
  if_2615_end:
    set $P2593, $P2614
.annotate 'line', 1158
    goto if_2594_end
  if_2594:
    .const 'Sub' $P2603 = "132_1299602554.641" 
    capture_lex $P2603
    $P2613 = $P2603()
    set $P2593, $P2613
  if_2594_end:
.annotate 'line', 1157
    .return ($P2593)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2602"  :anon :subid("132_1299602554.641") :outer("131_1299602554.641")
.annotate 'line', 1159
    new $P2604, "Undef"
    .lex "$past", $P2604
    find_lex $P2605, "$/"
    unless_null $P2605, vivify_823
    $P2605 = root_new ['parrot';'Hash']
  vivify_823:
    set $P2606, $P2605["pblock"]
    unless_null $P2606, vivify_824
    new $P2606, "Undef"
  vivify_824:
    $P2607 = $P2606."ast"()
    store_lex "$past", $P2607
.annotate 'line', 1160
    new $P2608, "Integer"
    assign $P2608, 1
    find_lex $P2609, "$past"
    unless_null $P2609, vivify_825
    $P2609 = root_new ['parrot';'Hash']
    store_lex "$past", $P2609
  vivify_825:
    set $P2609["bareblock"], $P2608
.annotate 'line', 1161
    find_dynamic_lex $P2610, "$/"
    find_lex $P2611, "$past"
    $P2612 = $P2610."!make"($P2611)
.annotate 'line', 1158
    .return ($P2612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("133_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2629
    .param pmc param_2630
.annotate 'line', 1171
    .lex "self", param_2629
    .lex "$/", param_2630
.annotate 'line', 1172
    new $P2631, "Undef"
    .lex "$name", $P2631
    find_lex $P2634, "$/"
    unless_null $P2634, vivify_826
    $P2634 = root_new ['parrot';'Hash']
  vivify_826:
    set $P2635, $P2634["sigil"]
    unless_null $P2635, vivify_827
    new $P2635, "Undef"
  vivify_827:
    set $S2636, $P2635
    iseq $I2637, $S2636, "@"
    if $I2637, if_2633
.annotate 'line', 1173
    find_lex $P2641, "$/"
    unless_null $P2641, vivify_828
    $P2641 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2642, $P2641["sigil"]
    unless_null $P2642, vivify_829
    new $P2642, "Undef"
  vivify_829:
    set $S2643, $P2642
    iseq $I2644, $S2643, "%"
    if $I2644, if_2640
    new $P2646, "String"
    assign $P2646, "item"
    set $P2639, $P2646
    goto if_2640_end
  if_2640:
    new $P2645, "String"
    assign $P2645, "hash"
    set $P2639, $P2645
  if_2640_end:
    set $P2632, $P2639
.annotate 'line', 1172
    goto if_2633_end
  if_2633:
    new $P2638, "String"
    assign $P2638, "list"
    set $P2632, $P2638
  if_2633_end:
    store_lex "$name", $P2632
.annotate 'line', 1175
    find_lex $P2647, "$/"
    get_hll_global $P2648, ["PAST"], "Op"
    find_lex $P2649, "$name"
    find_lex $P2650, "$/"
    unless_null $P2650, vivify_830
    $P2650 = root_new ['parrot';'Hash']
  vivify_830:
    set $P2651, $P2650["semilist"]
    unless_null $P2651, vivify_831
    new $P2651, "Undef"
  vivify_831:
    $P2652 = $P2651."ast"()
    $P2653 = $P2648."new"($P2652, "callmethod" :named("pasttype"), $P2649 :named("name"))
    $P2654 = $P2647."!make"($P2653)
.annotate 'line', 1171
    .return ($P2654)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("134_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2656
    .param pmc param_2657
.annotate 'line', 1178
    .lex "self", param_2656
    .lex "$/", param_2657
    find_lex $P2658, "$/"
    find_lex $P2659, "$/"
    unless_null $P2659, vivify_832
    $P2659 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2660, $P2659["statement"]
    unless_null $P2660, vivify_833
    new $P2660, "Undef"
  vivify_833:
    $P2661 = $P2660."ast"()
    $P2662 = $P2658."!make"($P2661)
    .return ($P2662)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("135_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2664
    .param pmc param_2665
.annotate 'line', 1180
    .lex "self", param_2664
    .lex "$/", param_2665
.annotate 'line', 1181
    find_lex $P2666, "$/"
    get_hll_global $P2667, ["PAST"], "Var"
    find_lex $P2668, "$/"
    unless_null $P2668, vivify_834
    $P2668 = root_new ['parrot';'Hash']
  vivify_834:
    set $P2669, $P2668["EXPR"]
    unless_null $P2669, vivify_835
    new $P2669, "Undef"
  vivify_835:
    $P2670 = $P2669."ast"()
.annotate 'line', 1183
    $P2671 = "vivitype"("@")
    $P2672 = $P2667."new"($P2670, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2671 :named("vivibase"))
.annotate 'line', 1181
    $P2673 = $P2666."!make"($P2672)
.annotate 'line', 1180
    .return ($P2673)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("136_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2675
    .param pmc param_2676
.annotate 'line', 1186
    .lex "self", param_2675
    .lex "$/", param_2676
.annotate 'line', 1187
    find_lex $P2677, "$/"
    get_hll_global $P2678, ["PAST"], "Var"
    find_lex $P2679, "$/"
    unless_null $P2679, vivify_836
    $P2679 = root_new ['parrot';'Hash']
  vivify_836:
    set $P2680, $P2679["EXPR"]
    unless_null $P2680, vivify_837
    new $P2680, "Undef"
  vivify_837:
    $P2681 = $P2680."ast"()
.annotate 'line', 1189
    $P2682 = "vivitype"("%")
    $P2683 = $P2678."new"($P2681, "keyed" :named("scope"), "Undef" :named("viviself"), $P2682 :named("vivibase"))
.annotate 'line', 1187
    $P2684 = $P2677."!make"($P2683)
.annotate 'line', 1186
    .return ($P2684)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("137_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2686
    .param pmc param_2687
.annotate 'line', 1192
    .lex "self", param_2686
    .lex "$/", param_2687
.annotate 'line', 1193
    find_lex $P2688, "$/"
    get_hll_global $P2689, ["PAST"], "Var"
    find_lex $P2690, "$/"
    unless_null $P2690, vivify_838
    $P2690 = root_new ['parrot';'Hash']
  vivify_838:
    set $P2691, $P2690["quote_EXPR"]
    unless_null $P2691, vivify_839
    new $P2691, "Undef"
  vivify_839:
    $P2692 = $P2691."ast"()
.annotate 'line', 1195
    $P2693 = "vivitype"("%")
    $P2694 = $P2689."new"($P2692, "keyed" :named("scope"), "Undef" :named("viviself"), $P2693 :named("vivibase"))
.annotate 'line', 1193
    $P2695 = $P2688."!make"($P2694)
.annotate 'line', 1192
    .return ($P2695)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("138_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2697
    .param pmc param_2698
.annotate 'line', 1198
    .lex "self", param_2697
    .lex "$/", param_2698
.annotate 'line', 1199
    find_lex $P2699, "$/"
    find_lex $P2700, "$/"
    unless_null $P2700, vivify_840
    $P2700 = root_new ['parrot';'Hash']
  vivify_840:
    set $P2701, $P2700["arglist"]
    unless_null $P2701, vivify_841
    new $P2701, "Undef"
  vivify_841:
    $P2702 = $P2701."ast"()
    $P2703 = $P2699."!make"($P2702)
.annotate 'line', 1198
    .return ($P2703)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("139_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2705
    .param pmc param_2706
.annotate 'line', 1202
    .lex "self", param_2705
    .lex "$/", param_2706
.annotate 'line', 1203
    find_lex $P2707, "$/"
    find_lex $P2710, "$/"
    unless_null $P2710, vivify_842
    $P2710 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2711, $P2710["quote"]
    unless_null $P2711, vivify_843
    new $P2711, "Undef"
  vivify_843:
    if $P2711, if_2709
    find_lex $P2715, "$/"
    unless_null $P2715, vivify_844
    $P2715 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2716, $P2715["number"]
    unless_null $P2716, vivify_845
    new $P2716, "Undef"
  vivify_845:
    $P2717 = $P2716."ast"()
    set $P2708, $P2717
    goto if_2709_end
  if_2709:
    find_lex $P2712, "$/"
    unless_null $P2712, vivify_846
    $P2712 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2713, $P2712["quote"]
    unless_null $P2713, vivify_847
    new $P2713, "Undef"
  vivify_847:
    $P2714 = $P2713."ast"()
    set $P2708, $P2714
  if_2709_end:
    $P2718 = $P2707."!make"($P2708)
.annotate 'line', 1202
    .return ($P2718)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("140_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2720
    .param pmc param_2721
.annotate 'line', 1206
    .lex "self", param_2720
    .lex "$/", param_2721
.annotate 'line', 1207
    new $P2722, "Undef"
    .lex "$value", $P2722
    find_lex $P2725, "$/"
    unless_null $P2725, vivify_848
    $P2725 = root_new ['parrot';'Hash']
  vivify_848:
    set $P2726, $P2725["dec_number"]
    unless_null $P2726, vivify_849
    new $P2726, "Undef"
  vivify_849:
    if $P2726, if_2724
    find_lex $P2730, "$/"
    unless_null $P2730, vivify_850
    $P2730 = root_new ['parrot';'Hash']
  vivify_850:
    set $P2731, $P2730["integer"]
    unless_null $P2731, vivify_851
    new $P2731, "Undef"
  vivify_851:
    $P2732 = $P2731."ast"()
    set $P2723, $P2732
    goto if_2724_end
  if_2724:
    find_lex $P2727, "$/"
    unless_null $P2727, vivify_852
    $P2727 = root_new ['parrot';'Hash']
  vivify_852:
    set $P2728, $P2727["dec_number"]
    unless_null $P2728, vivify_853
    new $P2728, "Undef"
  vivify_853:
    $P2729 = $P2728."ast"()
    set $P2723, $P2729
  if_2724_end:
    store_lex "$value", $P2723
.annotate 'line', 1208
    find_lex $P2734, "$/"
    unless_null $P2734, vivify_854
    $P2734 = root_new ['parrot';'Hash']
  vivify_854:
    set $P2735, $P2734["sign"]
    unless_null $P2735, vivify_855
    new $P2735, "Undef"
  vivify_855:
    set $S2736, $P2735
    iseq $I2737, $S2736, "-"
    unless $I2737, if_2733_end
    find_lex $P2738, "$value"
    neg $P2739, $P2738
    store_lex "$value", $P2739
  if_2733_end:
.annotate 'line', 1209
    find_lex $P2740, "$/"
    get_hll_global $P2741, ["PAST"], "Val"
    find_lex $P2742, "$value"
    $P2743 = $P2741."new"($P2742 :named("value"))
    $P2744 = $P2740."!make"($P2743)
.annotate 'line', 1206
    .return ($P2744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("141_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2746
    .param pmc param_2747
.annotate 'line', 1212
    .lex "self", param_2746
    .lex "$/", param_2747
    find_lex $P2748, "$/"
    find_lex $P2749, "$/"
    unless_null $P2749, vivify_856
    $P2749 = root_new ['parrot';'Hash']
  vivify_856:
    set $P2750, $P2749["quote_EXPR"]
    unless_null $P2750, vivify_857
    new $P2750, "Undef"
  vivify_857:
    $P2751 = $P2750."ast"()
    $P2752 = $P2748."!make"($P2751)
    .return ($P2752)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("142_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2754
    .param pmc param_2755
.annotate 'line', 1213
    .lex "self", param_2754
    .lex "$/", param_2755
    find_lex $P2756, "$/"
    find_lex $P2757, "$/"
    unless_null $P2757, vivify_858
    $P2757 = root_new ['parrot';'Hash']
  vivify_858:
    set $P2758, $P2757["quote_EXPR"]
    unless_null $P2758, vivify_859
    new $P2758, "Undef"
  vivify_859:
    $P2759 = $P2758."ast"()
    $P2760 = $P2756."!make"($P2759)
    .return ($P2760)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("143_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2762
    .param pmc param_2763
.annotate 'line', 1214
    .lex "self", param_2762
    .lex "$/", param_2763
    find_lex $P2764, "$/"
    find_lex $P2765, "$/"
    unless_null $P2765, vivify_860
    $P2765 = root_new ['parrot';'Hash']
  vivify_860:
    set $P2766, $P2765["quote_EXPR"]
    unless_null $P2766, vivify_861
    new $P2766, "Undef"
  vivify_861:
    $P2767 = $P2766."ast"()
    $P2768 = $P2764."!make"($P2767)
    .return ($P2768)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("144_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2770
    .param pmc param_2771
.annotate 'line', 1215
    .lex "self", param_2770
    .lex "$/", param_2771
    find_lex $P2772, "$/"
    find_lex $P2773, "$/"
    unless_null $P2773, vivify_862
    $P2773 = root_new ['parrot';'Hash']
  vivify_862:
    set $P2774, $P2773["quote_EXPR"]
    unless_null $P2774, vivify_863
    new $P2774, "Undef"
  vivify_863:
    $P2775 = $P2774."ast"()
    $P2776 = $P2772."!make"($P2775)
    .return ($P2776)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("145_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2778
    .param pmc param_2779
.annotate 'line', 1216
    .lex "self", param_2778
    .lex "$/", param_2779
    find_lex $P2780, "$/"
    find_lex $P2781, "$/"
    unless_null $P2781, vivify_864
    $P2781 = root_new ['parrot';'Hash']
  vivify_864:
    set $P2782, $P2781["quote_EXPR"]
    unless_null $P2782, vivify_865
    new $P2782, "Undef"
  vivify_865:
    $P2783 = $P2782."ast"()
    $P2784 = $P2780."!make"($P2783)
    .return ($P2784)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("146_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2786
    .param pmc param_2787
.annotate 'line', 1217
    .lex "self", param_2786
    .lex "$/", param_2787
.annotate 'line', 1218
    find_lex $P2788, "$/"
    get_hll_global $P2789, ["PAST"], "Op"
    find_lex $P2790, "$/"
    unless_null $P2790, vivify_866
    $P2790 = root_new ['parrot';'Hash']
  vivify_866:
    set $P2791, $P2790["quote_EXPR"]
    unless_null $P2791, vivify_867
    new $P2791, "Undef"
  vivify_867:
    $P2792 = $P2791."ast"()
    $P2793 = $P2792."value"()
    find_lex $P2794, "$/"
    $P2795 = $P2789."new"($P2793 :named("inline"), "inline" :named("pasttype"), $P2794 :named("node"))
    $P2796 = $P2788."!make"($P2795)
.annotate 'line', 1217
    .return ($P2796)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("147_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2800
    .param pmc param_2801
    .param pmc param_2802 :optional
    .param int has_param_2802 :opt_flag
.annotate 'line', 1223
    new $P2799, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2799, control_2798
    push_eh $P2799
    .lex "self", param_2800
    .lex "$/", param_2801
    if has_param_2802, optparam_868
    new $P2803, "Undef"
    set param_2802, $P2803
  optparam_868:
    .lex "$key", param_2802
.annotate 'line', 1233
    new $P2804, "Undef"
    .lex "$regex", $P2804
.annotate 'line', 1235
    new $P2805, "Undef"
    .lex "$past", $P2805
.annotate 'line', 1224
    find_lex $P2807, "$key"
    set $S2808, $P2807
    iseq $I2809, $S2808, "open"
    unless $I2809, if_2806_end
.annotate 'line', 1225

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1229
    get_global $P2810, "@BLOCK"
    unless_null $P2810, vivify_869
    $P2810 = root_new ['parrot';'ResizablePMCArray']
  vivify_869:
    set $P2811, $P2810[0]
    unless_null $P2811, vivify_870
    new $P2811, "Undef"
  vivify_870:
    $P2811."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1230
    get_global $P2812, "@BLOCK"
    unless_null $P2812, vivify_871
    $P2812 = root_new ['parrot';'ResizablePMCArray']
  vivify_871:
    set $P2813, $P2812[0]
    unless_null $P2813, vivify_872
    new $P2813, "Undef"
  vivify_872:
    $P2813."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1231
    new $P2814, "Exception"
    set $P2814['type'], .CONTROL_RETURN
    new $P2815, "Integer"
    assign $P2815, 0
    setattribute $P2814, 'payload', $P2815
    throw $P2814
  if_2806_end:
.annotate 'line', 1234
    get_hll_global $P2816, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2817, "$/"
    unless_null $P2817, vivify_873
    $P2817 = root_new ['parrot';'Hash']
  vivify_873:
    set $P2818, $P2817["p6regex"]
    unless_null $P2818, vivify_874
    new $P2818, "Undef"
  vivify_874:
    $P2819 = $P2818."ast"()
    get_global $P2820, "@BLOCK"
    $P2821 = $P2820."shift"()
    $P2822 = $P2816($P2819, $P2821)
    store_lex "$regex", $P2822
.annotate 'line', 1236
    get_hll_global $P2823, ["PAST"], "Op"
.annotate 'line', 1238
    get_hll_global $P2824, ["PAST"], "Var"
    new $P2825, "ResizablePMCArray"
    push $P2825, "Regex"
    $P2826 = $P2824."new"("Regex" :named("name"), $P2825 :named("namespace"), "package" :named("scope"))
    find_lex $P2827, "$regex"
    $P2828 = $P2823."new"($P2826, $P2827, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1236
    store_lex "$past", $P2828
.annotate 'line', 1242
    find_lex $P2829, "$regex"
    find_lex $P2830, "$past"
    unless_null $P2830, vivify_875
    $P2830 = root_new ['parrot';'Hash']
    store_lex "$past", $P2830
  vivify_875:
    set $P2830["sink"], $P2829
.annotate 'line', 1243
    find_lex $P2831, "$/"
    find_lex $P2832, "$past"
    $P2833 = $P2831."!make"($P2832)
.annotate 'line', 1223
    .return ($P2833)
  control_2798:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2834, exception, "payload"
    .return ($P2834)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("148_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2836
    .param pmc param_2837
.annotate 'line', 1246
    .lex "self", param_2836
    .lex "$/", param_2837
    find_lex $P2838, "$/"
    find_lex $P2839, "$/"
    unless_null $P2839, vivify_876
    $P2839 = root_new ['parrot';'Hash']
  vivify_876:
    set $P2840, $P2839["variable"]
    unless_null $P2840, vivify_877
    new $P2840, "Undef"
  vivify_877:
    $P2841 = $P2840."ast"()
    $P2842 = $P2838."!make"($P2841)
    .return ($P2842)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("149_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2844
    .param pmc param_2845
.annotate 'line', 1247
    .lex "self", param_2844
    .lex "$/", param_2845
.annotate 'line', 1248
    find_lex $P2846, "$/"
    get_hll_global $P2847, ["PAST"], "Op"
.annotate 'line', 1249
    find_lex $P2848, "$/"
    unless_null $P2848, vivify_878
    $P2848 = root_new ['parrot';'Hash']
  vivify_878:
    set $P2849, $P2848["block"]
    unless_null $P2849, vivify_879
    new $P2849, "Undef"
  vivify_879:
    $P2850 = $P2849."ast"()
    $P2851 = "block_immediate"($P2850)
    find_lex $P2852, "$/"
    $P2853 = $P2847."new"($P2851, "set S*" :named("pirop"), $P2852 :named("node"))
.annotate 'line', 1248
    $P2854 = $P2846."!make"($P2853)
.annotate 'line', 1247
    .return ($P2854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("150_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2856
    .param pmc param_2857
.annotate 'line', 1252
    .lex "self", param_2856
    .lex "$/", param_2857
    find_lex $P2858, "$/"
    $P2859 = $P2858."!make"("\e")
    .return ($P2859)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("151_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2861
    .param pmc param_2862
.annotate 'line', 1256
    .lex "self", param_2861
    .lex "$/", param_2862
    find_lex $P2863, "$/"
    find_lex $P2864, "$/"
    unless_null $P2864, vivify_880
    $P2864 = root_new ['parrot';'Hash']
  vivify_880:
    set $P2865, $P2864["dotty"]
    unless_null $P2865, vivify_881
    new $P2865, "Undef"
  vivify_881:
    $P2866 = $P2865."ast"()
    $P2867 = $P2863."!make"($P2866)
    .return ($P2867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("152_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2869
    .param pmc param_2870
.annotate 'line', 1258
    .lex "self", param_2869
    .lex "$/", param_2870
.annotate 'line', 1259
    find_lex $P2871, "$/"
    get_hll_global $P2872, ["PAST"], "Op"
.annotate 'line', 1260
    new $P2873, "ResizablePMCArray"
    push $P2873, "    clone %r, %0"
    push $P2873, "    inc %0"
    $P2874 = $P2872."new"("postfix:<++>" :named("name"), $P2873 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1259
    $P2875 = $P2871."!make"($P2874)
.annotate 'line', 1258
    .return ($P2875)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("153_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2877
    .param pmc param_2878
.annotate 'line', 1264
    .lex "self", param_2877
    .lex "$/", param_2878
.annotate 'line', 1265
    find_lex $P2879, "$/"
    get_hll_global $P2880, ["PAST"], "Op"
.annotate 'line', 1266
    new $P2881, "ResizablePMCArray"
    push $P2881, "    clone %r, %0"
    push $P2881, "    dec %0"
    $P2882 = $P2880."new"("postfix:<-->" :named("name"), $P2881 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1265
    $P2883 = $P2879."!make"($P2882)
.annotate 'line', 1264
    .return ($P2883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("154_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2885
    .param pmc param_2886
.annotate 'line', 1270
    .lex "self", param_2885
    .lex "$/", param_2886
.annotate 'line', 1271
    find_lex $P2887, "$/"
    get_hll_global $P2888, ["PAST"], "Op"
.annotate 'line', 1272
    get_hll_global $P2889, ["PAST"], "Var"
    $P2890 = $P2889."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2891, "$/"
    $P2892 = $P2888."new"($P2890, "callmethod" :named("pasttype"), "!make" :named("name"), $P2891 :named("node"))
.annotate 'line', 1271
    $P2893 = $P2887."!make"($P2892)
.annotate 'line', 1270
    .return ($P2893)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("155_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2896
    .param pmc param_2897
.annotate 'line', 1288
    .lex "self", param_2896
    .lex "$/", param_2897
    find_lex $P2898, "$/"
    $P2899 = "control"($P2898, "CONTROL_LOOP_NEXT")
    .return ($P2899)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("156_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2901
    .param pmc param_2902
.annotate 'line', 1289
    .lex "self", param_2901
    .lex "$/", param_2902
    find_lex $P2903, "$/"
    $P2904 = "control"($P2903, "CONTROL_LOOP_LAST")
    .return ($P2904)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("157_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2906
    .param pmc param_2907
.annotate 'line', 1290
    .lex "self", param_2906
    .lex "$/", param_2907
    find_lex $P2908, "$/"
    $P2909 = "control"($P2908, "CONTROL_LOOP_REDO")
    .return ($P2909)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("158_1299602554.641") :outer("11_1299602554.641")
    .param pmc param_2911
    .param pmc param_2912
.annotate 'line', 1292
    .lex "self", param_2911
    .lex "$/", param_2912
.annotate 'line', 1293
    find_lex $P2913, "$/"
    get_hll_global $P2914, ["PAST"], "Op"
    find_lex $P2915, "$/"
    $P2916 = $P2914."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2915 :named("node"))
    $P2917 = $P2913."!make"($P2916)
.annotate 'line', 1292
    .return ($P2917)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block2918"  :subid("159_1299602554.641") :outer("11_1299602554.641")
.annotate 'line', 1297
    .const 'Sub' $P3018 = "167_1299602554.641" 
    capture_lex $P3018
    .const 'Sub' $P2993 = "166_1299602554.641" 
    capture_lex $P2993
    .const 'Sub' $P2982 = "165_1299602554.641" 
    capture_lex $P2982
    .const 'Sub' $P2967 = "164_1299602554.641" 
    capture_lex $P2967
    .const 'Sub' $P2956 = "163_1299602554.641" 
    capture_lex $P2956
    .const 'Sub' $P2945 = "162_1299602554.641" 
    capture_lex $P2945
    .const 'Sub' $P2934 = "161_1299602554.641" 
    capture_lex $P2934
    .const 'Sub' $P2921 = "160_1299602554.641" 
    capture_lex $P2921
    get_global $P2920, "$?CLASS"
.annotate 'line', 1331
    .const 'Sub' $P2993 = "166_1299602554.641" 
    newclosure $P3016, $P2993
.annotate 'line', 1297
    .return ($P3016)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post882") :outer("159_1299602554.641")
.annotate 'line', 1297
    get_hll_global $P2919, ["NQP";"RegexActions"], "_block2918" 
    .local pmc block
    set block, $P2919
    .const 'Sub' $P3018 = "167_1299602554.641" 
    capture_lex $P3018
    $P3018()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3017"  :anon :subid("167_1299602554.641") :outer("159_1299602554.641")
.annotate 'line', 1297
    nqp_get_sc_object $P3019, "1299602543.315", 1
    .local pmc type_obj
    set type_obj, $P3019
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3020, type_obj
    .const 'Sub' $P3021 = "160_1299602554.641" 
    $P3020."add_method"(type_obj, "metachar:sym<:my>", $P3021)
    get_how $P3022, type_obj
    .const 'Sub' $P3023 = "161_1299602554.641" 
    $P3022."add_method"(type_obj, "metachar:sym<{ }>", $P3023)
    get_how $P3024, type_obj
    .const 'Sub' $P3025 = "162_1299602554.641" 
    $P3024."add_method"(type_obj, "metachar:sym<nqpvar>", $P3025)
    get_how $P3026, type_obj
    .const 'Sub' $P3027 = "163_1299602554.641" 
    $P3026."add_method"(type_obj, "assertion:sym<{ }>", $P3027)
    get_how $P3028, type_obj
    .const 'Sub' $P3029 = "164_1299602554.641" 
    $P3028."add_method"(type_obj, "assertion:sym<?{ }>", $P3029)
    get_how $P3030, type_obj
    .const 'Sub' $P3031 = "165_1299602554.641" 
    $P3030."add_method"(type_obj, "assertion:sym<var>", $P3031)
    get_how $P3032, type_obj
    .const 'Sub' $P3033 = "166_1299602554.641" 
    $P3032."add_method"(type_obj, "codeblock", $P3033)
    get_how $P3034, type_obj
    get_hll_global $P3035, ["Regex";"P6Regex"], "Actions"
    $P3034."add_parent"(type_obj, $P3035)
    get_how $P3036, type_obj
    $P3037 = $P3036."compose"(type_obj)
    .return ($P3037)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("160_1299602554.641") :outer("159_1299602554.641")
    .param pmc param_2922
    .param pmc param_2923
.annotate 'line', 1299
    .lex "self", param_2922
    .lex "$/", param_2923
.annotate 'line', 1300
    new $P2924, "Undef"
    .lex "$past", $P2924
    find_lex $P2925, "$/"
    unless_null $P2925, vivify_883
    $P2925 = root_new ['parrot';'Hash']
  vivify_883:
    set $P2926, $P2925["statement"]
    unless_null $P2926, vivify_884
    new $P2926, "Undef"
  vivify_884:
    $P2927 = $P2926."ast"()
    store_lex "$past", $P2927
.annotate 'line', 1301
    find_lex $P2928, "$/"
    get_hll_global $P2929, ["PAST"], "Regex"
    find_lex $P2930, "$past"
    find_lex $P2931, "$/"
    $P2932 = $P2929."new"($P2930, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2931 :named("node"))
    $P2933 = $P2928."!make"($P2932)
.annotate 'line', 1299
    .return ($P2933)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("161_1299602554.641") :outer("159_1299602554.641")
    .param pmc param_2935
    .param pmc param_2936
.annotate 'line', 1305
    .lex "self", param_2935
    .lex "$/", param_2936
.annotate 'line', 1306
    find_lex $P2937, "$/"
    get_hll_global $P2938, ["PAST"], "Regex"
    find_lex $P2939, "$/"
    unless_null $P2939, vivify_885
    $P2939 = root_new ['parrot';'Hash']
  vivify_885:
    set $P2940, $P2939["codeblock"]
    unless_null $P2940, vivify_886
    new $P2940, "Undef"
  vivify_886:
    $P2941 = $P2940."ast"()
    find_lex $P2942, "$/"
    $P2943 = $P2938."new"($P2941, "pastnode" :named("pasttype"), $P2942 :named("node"))
    $P2944 = $P2937."!make"($P2943)
.annotate 'line', 1305
    .return ($P2944)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("162_1299602554.641") :outer("159_1299602554.641")
    .param pmc param_2946
    .param pmc param_2947
.annotate 'line', 1310
    .lex "self", param_2946
    .lex "$/", param_2947
.annotate 'line', 1311
    find_lex $P2948, "$/"
    get_hll_global $P2949, ["PAST"], "Regex"
    find_lex $P2950, "$/"
    unless_null $P2950, vivify_887
    $P2950 = root_new ['parrot';'Hash']
  vivify_887:
    set $P2951, $P2950["var"]
    unless_null $P2951, vivify_888
    new $P2951, "Undef"
  vivify_888:
    $P2952 = $P2951."ast"()
    find_lex $P2953, "$/"
    $P2954 = $P2949."new"("!INTERPOLATE", $P2952, "subrule" :named("pasttype"), "method" :named("subtype"), $P2953 :named("node"))
    $P2955 = $P2948."!make"($P2954)
.annotate 'line', 1310
    .return ($P2955)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("163_1299602554.641") :outer("159_1299602554.641")
    .param pmc param_2957
    .param pmc param_2958
.annotate 'line', 1315
    .lex "self", param_2957
    .lex "$/", param_2958
.annotate 'line', 1316
    find_lex $P2959, "$/"
    get_hll_global $P2960, ["PAST"], "Regex"
    find_lex $P2961, "$/"
    unless_null $P2961, vivify_889
    $P2961 = root_new ['parrot';'Hash']
  vivify_889:
    set $P2962, $P2961["codeblock"]
    unless_null $P2962, vivify_890
    new $P2962, "Undef"
  vivify_890:
    $P2963 = $P2962."ast"()
    find_lex $P2964, "$/"
    $P2965 = $P2960."new"("!INTERPOLATE_REGEX", $P2963, "subrule" :named("pasttype"), "method" :named("subtype"), $P2964 :named("node"))
    $P2966 = $P2959."!make"($P2965)
.annotate 'line', 1315
    .return ($P2966)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("164_1299602554.641") :outer("159_1299602554.641")
    .param pmc param_2968
    .param pmc param_2969
.annotate 'line', 1320
    .lex "self", param_2968
    .lex "$/", param_2969
.annotate 'line', 1321
    find_lex $P2970, "$/"
    get_hll_global $P2971, ["PAST"], "Regex"
    find_lex $P2972, "$/"
    unless_null $P2972, vivify_891
    $P2972 = root_new ['parrot';'Hash']
  vivify_891:
    set $P2973, $P2972["codeblock"]
    unless_null $P2973, vivify_892
    new $P2973, "Undef"
  vivify_892:
    $P2974 = $P2973."ast"()
.annotate 'line', 1322
    find_lex $P2975, "$/"
    unless_null $P2975, vivify_893
    $P2975 = root_new ['parrot';'Hash']
  vivify_893:
    set $P2976, $P2975["zw"]
    unless_null $P2976, vivify_894
    new $P2976, "Undef"
  vivify_894:
    set $S2977, $P2976
    iseq $I2978, $S2977, "!"
    find_lex $P2979, "$/"
    $P2980 = $P2971."new"($P2974, "zerowidth" :named("subtype"), $I2978 :named("negate"), "pastnode" :named("pasttype"), $P2979 :named("node"))
.annotate 'line', 1321
    $P2981 = $P2970."!make"($P2980)
.annotate 'line', 1320
    .return ($P2981)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("165_1299602554.641") :outer("159_1299602554.641")
    .param pmc param_2983
    .param pmc param_2984
.annotate 'line', 1326
    .lex "self", param_2983
    .lex "$/", param_2984
.annotate 'line', 1327
    find_lex $P2985, "$/"
    get_hll_global $P2986, ["PAST"], "Regex"
    find_lex $P2987, "$/"
    unless_null $P2987, vivify_895
    $P2987 = root_new ['parrot';'Hash']
  vivify_895:
    set $P2988, $P2987["var"]
    unless_null $P2988, vivify_896
    new $P2988, "Undef"
  vivify_896:
    $P2989 = $P2988."ast"()
    find_lex $P2990, "$/"
    $P2991 = $P2986."new"("!INTERPOLATE_REGEX", $P2989, "subrule" :named("pasttype"), "method" :named("subtype"), $P2990 :named("node"))
    $P2992 = $P2985."!make"($P2991)
.annotate 'line', 1326
    .return ($P2992)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("166_1299602554.641") :outer("159_1299602554.641")
    .param pmc param_2994
    .param pmc param_2995
.annotate 'line', 1331
    .lex "self", param_2994
    .lex "$/", param_2995
.annotate 'line', 1332
    new $P2996, "Undef"
    .lex "$block", $P2996
.annotate 'line', 1334
    new $P2997, "Undef"
    .lex "$past", $P2997
.annotate 'line', 1332
    find_lex $P2998, "$/"
    unless_null $P2998, vivify_897
    $P2998 = root_new ['parrot';'Hash']
  vivify_897:
    set $P2999, $P2998["block"]
    unless_null $P2999, vivify_898
    new $P2999, "Undef"
  vivify_898:
    $P3000 = $P2999."ast"()
    store_lex "$block", $P3000
.annotate 'line', 1333
    find_lex $P3001, "$block"
    $P3001."blocktype"("immediate")
.annotate 'line', 1335
    get_hll_global $P3002, ["PAST"], "Stmts"
.annotate 'line', 1336
    get_hll_global $P3003, ["PAST"], "Op"
.annotate 'line', 1337
    get_hll_global $P3004, ["PAST"], "Var"
    $P3005 = $P3004."new"("$/" :named("name"))
.annotate 'line', 1338
    get_hll_global $P3006, ["PAST"], "Op"
.annotate 'line', 1339
    get_hll_global $P3007, ["PAST"], "Var"
    $P3008 = $P3007."new"(unicode:"$\x{a2}" :named("name"))
    $P3009 = $P3006."new"($P3008, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1338
    $P3010 = $P3003."new"($P3005, $P3009, "bind" :named("pasttype"))
.annotate 'line', 1336
    find_lex $P3011, "$block"
    $P3012 = $P3002."new"($P3010, $P3011)
.annotate 'line', 1335
    store_lex "$past", $P3012
.annotate 'line', 1347
    find_lex $P3013, "$/"
    find_lex $P3014, "$past"
    $P3015 = $P3013."!make"($P3014)
.annotate 'line', 1331
    .return ($P3015)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3039" :load :anon :subid("168_1299602554.641")
.annotate 'line', 3
    .const 'Sub' $P3041 = "11_1299602554.641" 
    $P3042 = $P3041()
    .return ($P3042)
.end


.HLL "nqp"

.namespace []
.sub "_block3275" :load :anon :subid("170_1299602554.641")
.annotate 'line', 1
    .const 'Sub' $P3277 = "10_1299602554.641" 
    $P3278 = $P3277()
    .return ($P3278)
.end

### .include 'gen/nqp-compiler.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299602557.266")
.annotate 'line', 0
    get_hll_global $P18, ["NQP";"Compiler"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    getinterp $P13
    get_class $P14, "LexPad"
    get_class $P15, "NQPLexPad"
    $P13."hll_map"($P14, $P15)
    get_hll_global $P16, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P18, ["NQP";"Compiler"], "_block17" 
    capture_lex $P18
    $P27 = $P18()
    .return ($P27)
    .const 'Sub' $P29 = "13_1299602557.266" 
    .return ($P29)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post14") :outer("10_1299602557.266")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1299602557.266" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P33, "1299602557.254"
    isnull $I34, $P33
    if $I34, if_32
    goto if_32_end
  if_32:
    nqp_dynop_setup 
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P35, "1299602557.254"
    .local pmc cur_sc
    set cur_sc, $P35
    load_bytecode "SettingManager.pbc"
    get_hll_global $P36, ["HLL"], "SettingManager"
    $P37 = $P36."load_setting"("NQPCORE")
    block."set_outer_ctx"($P37)
    get_hll_global $P38, "NQPClassHOW"
    $P39 = $P38."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P39, cur_sc
    nqp_set_sc_object "1299602557.254", 0, $P39
  if_32_end:
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block17"  :subid("11_1299602557.266") :outer("10_1299602557.266")
.annotate 'line', 1
    .const 'Sub' $P21 = "12_1299602557.266" 
    capture_lex $P21
    get_global $P19, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post15") :outer("11_1299602557.266")
.annotate 'line', 1
    get_hll_global $P18, ["NQP";"Compiler"], "_block17" 
    .local pmc block
    set block, $P18
    .const 'Sub' $P21 = "12_1299602557.266" 
    capture_lex $P21
    $P21()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block20"  :anon :subid("12_1299602557.266") :outer("11_1299602557.266")
.annotate 'line', 1
    nqp_get_sc_object $P22, "1299602557.254", 0
    .local pmc type_obj
    set type_obj, $P22
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P23, type_obj
    get_hll_global $P24, ["HLL"], "Compiler"
    $P23."add_parent"(type_obj, $P24)
    get_how $P25, type_obj
    $P26 = $P25."compose"(type_obj)
    .return ($P26)
.end


.HLL "nqp"

.namespace []
.sub "_block28" :load :anon :subid("13_1299602557.266")
.annotate 'line', 1
    .const 'Sub' $P30 = "10_1299602557.266" 
    $P31 = $P30()
    .return ($P31)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('nqp')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
    push $P0, 'setting=s'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'nqp'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
