
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1305640955.436")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7287 = "622_1305640955.436" 
    capture_lex $P7287
    .const 'Sub' $P7154 = "614_1305640955.436" 
    capture_lex $P7154
    .const 'Sub' $P2925 = "435_1305640955.436" 
    capture_lex $P2925
    .const 'Sub' $P2860 = "414_1305640955.436" 
    capture_lex $P2860
    .const 'Sub' $P976 = "39_1305640955.436" 
    capture_lex $P976
    .const 'Sub' $P47 = "12_1305640955.436" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1305640955.436" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2754
    .const 'Sub' $P16 = "11_1305640955.436" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 11
    .const 'Sub' $P47 = "12_1305640955.436" 
    capture_lex $P47
    $P47()
.annotate 'line', 437
    .const 'Sub' $P976 = "39_1305640955.436" 
    capture_lex $P976
    $P976()
.annotate 'line', 1160
    .const 'Sub' $P2860 = "414_1305640955.436" 
    capture_lex $P2860
    $P2860()
.annotate 'line', 1203
    .const 'Sub' $P2925 = "435_1305640955.436" 
    capture_lex $P2925
    $P2925()
.annotate 'line', 2696
    .const 'Sub' $P7154 = "614_1305640955.436" 
    capture_lex $P7154
    $P7154()
.annotate 'line', 2751
    .const 'Sub' $P7287 = "622_1305640955.436" 
    capture_lex $P7287
    $P7287()
    find_lex $P7290, "MAIN"
    find_lex $P7293, "@ARGS"
    if $P7293, if_7292
    set $P7291, $P7293
    goto if_7292_end
  if_7292:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7294, "ModuleLoader"
    getinterp $P7295
    set $P7296, $P7295["context"]
    $P7294."set_mainline_module"($P7296)
    .const 'Sub' $P7297 = "11_1305640955.436" 
    find_lex $P7298, "@ARGS"
    $P7299 = $P7297($P7298 :flat)
    set $P7291, $P7299
  if_7292_end:
.annotate 'line', 1
    .return ($P7291)
    .const 'Sub' $P7301 = "623_1305640955.436" 
    .return ($P7301)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post624") :outer("10_1305640955.436")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1305640955.436" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7305, "1305640934.989"
    isnull $I7306, $P7305
    if $I7306, if_7304
    .const 'Sub' $P9499 = "10_1305640955.436" 
    $P9500 = $P9499."get_lexinfo"()
    nqp_get_sc_object $P9501, "1305640934.989", 0
    $P9500."set_static_lexpad_value"("GLOBALish", $P9501)
    .const 'Sub' $P9502 = "10_1305640955.436" 
    $P9503 = $P9502."get_lexinfo"()
    $P9503."finish_static_lexpad"()
    .const 'Sub' $P9504 = "10_1305640955.436" 
    $P9505 = $P9504."get_lexinfo"()
    nqp_get_sc_object $P9506, "1305640934.989", 0
    $P9505."set_static_lexpad_value"("$?PACKAGE", $P9506)
    .const 'Sub' $P9507 = "10_1305640955.436" 
    $P9508 = $P9507."get_lexinfo"()
    $P9508."finish_static_lexpad"()
    nqp_get_sc_object $P9509, "1305640934.989", 2
    .const 'Sub' $P9510 = "13_1305640955.436" 
    assign $P9509, $P9510
    nqp_get_sc_object $P9511, "1305640934.989", 3
    .const 'Sub' $P9512 = "15_1305640955.436" 
    assign $P9511, $P9512
    nqp_get_sc_object $P9513, "1305640934.989", 4
    .const 'Sub' $P9514 = "16_1305640955.436" 
    assign $P9513, $P9514
    nqp_get_sc_object $P9515, "1305640934.989", 5
    .const 'Sub' $P9516 = "19_1305640955.436" 
    assign $P9515, $P9516
    nqp_get_sc_object $P9517, "1305640934.989", 6
    .const 'Sub' $P9518 = "20_1305640955.436" 
    assign $P9517, $P9518
    nqp_get_sc_object $P9519, "1305640934.989", 7
    .const 'Sub' $P9520 = "21_1305640955.436" 
    assign $P9519, $P9520
    nqp_get_sc_object $P9521, "1305640934.989", 8
    .const 'Sub' $P9522 = "22_1305640955.436" 
    assign $P9521, $P9522
    nqp_get_sc_object $P9523, "1305640934.989", 9
    .const 'Sub' $P9524 = "25_1305640955.436" 
    assign $P9523, $P9524
    nqp_get_sc_object $P9525, "1305640934.989", 10
    .const 'Sub' $P9526 = "28_1305640955.436" 
    assign $P9525, $P9526
    nqp_get_sc_object $P9527, "1305640934.989", 11
    .const 'Sub' $P9528 = "29_1305640955.436" 
    assign $P9527, $P9528
    nqp_get_sc_object $P9529, "1305640934.989", 12
    .const 'Sub' $P9530 = "34_1305640955.436" 
    assign $P9529, $P9530
    nqp_get_sc_object $P9531, "1305640934.989", 13
    .const 'Sub' $P9532 = "35_1305640955.436" 
    assign $P9531, $P9532
    nqp_get_sc_object $P9533, "1305640934.989", 14
    .const 'Sub' $P9534 = "36_1305640955.436" 
    assign $P9533, $P9534
    nqp_get_sc_object $P9535, "1305640934.989", 15
    .const 'Sub' $P9536 = "37_1305640955.436" 
    assign $P9535, $P9536
    .const 'Sub' $P9537 = "12_1305640955.436" 
    $P9538 = $P9537."get_lexinfo"()
    nqp_get_sc_object $P9539, "1305640934.989", 1
    $P9538."set_static_lexpad_value"("$?PACKAGE", $P9539)
    .const 'Sub' $P9540 = "12_1305640955.436" 
    $P9541 = $P9540."get_lexinfo"()
    $P9541."finish_static_lexpad"()
    .const 'Sub' $P9542 = "12_1305640955.436" 
    $P9543 = $P9542."get_lexinfo"()
    nqp_get_sc_object $P9544, "1305640934.989", 1
    $P9543."set_static_lexpad_value"("$?CLASS", $P9544)
    .const 'Sub' $P9545 = "12_1305640955.436" 
    $P9546 = $P9545."get_lexinfo"()
    $P9546."finish_static_lexpad"()
    nqp_get_sc_object $P9547, "1305640934.989", 17
    .const 'Sub' $P9548 = "40_1305640955.436" 
    assign $P9547, $P9548
    nqp_get_sc_object $P9549, "1305640934.989", 18
    .const 'Sub' $P9550 = "41_1305640955.436" 
    assign $P9549, $P9550
    nqp_get_sc_object $P9551, "1305640934.989", 19
    .const 'Sub' $P9552 = "42_1305640955.436" 
    assign $P9551, $P9552
    nqp_get_sc_object $P9553, "1305640934.989", 20
    .const 'Sub' $P9554 = "43_1305640955.436" 
    assign $P9553, $P9554
    nqp_get_sc_object $P9555, "1305640934.989", 21
    .const 'Sub' $P9556 = "44_1305640955.436" 
    assign $P9555, $P9556
    nqp_get_sc_object $P9557, "1305640934.989", 22
    .const 'Sub' $P9558 = "45_1305640955.436" 
    assign $P9557, $P9558
    nqp_get_sc_object $P9559, "1305640934.989", 23
    .const 'Sub' $P9560 = "46_1305640955.436" 
    assign $P9559, $P9560
    nqp_get_sc_object $P9561, "1305640934.989", 24
    .const 'Sub' $P9562 = "47_1305640955.436" 
    assign $P9561, $P9562
    nqp_get_sc_object $P9563, "1305640934.989", 25
    .const 'Sub' $P9564 = "48_1305640955.436" 
    assign $P9563, $P9564
    nqp_get_sc_object $P9565, "1305640934.989", 26
    .const 'Sub' $P9566 = "49_1305640955.436" 
    assign $P9565, $P9566
    nqp_get_sc_object $P9567, "1305640934.989", 27
    .const 'Sub' $P9568 = "50_1305640955.436" 
    assign $P9567, $P9568
    nqp_get_sc_object $P9569, "1305640934.989", 28
    .const 'Sub' $P9570 = "51_1305640955.436" 
    assign $P9569, $P9570
    nqp_get_sc_object $P9571, "1305640934.989", 29
    .const 'Sub' $P9572 = "53_1305640955.436" 
    assign $P9571, $P9572
    nqp_get_sc_object $P9573, "1305640934.989", 30
    .const 'Sub' $P9574 = "54_1305640955.436" 
    assign $P9573, $P9574
    nqp_get_sc_object $P9575, "1305640934.989", 31
    .const 'Sub' $P9576 = "56_1305640955.436" 
    assign $P9575, $P9576
    nqp_get_sc_object $P9577, "1305640934.989", 32
    .const 'Sub' $P9578 = "57_1305640955.436" 
    assign $P9577, $P9578
    nqp_get_sc_object $P9579, "1305640934.989", 33
    .const 'Sub' $P9580 = "58_1305640955.436" 
    assign $P9579, $P9580
    nqp_get_sc_object $P9581, "1305640934.989", 34
    .const 'Sub' $P9582 = "59_1305640955.436" 
    assign $P9581, $P9582
    nqp_get_sc_object $P9583, "1305640934.989", 35
    .const 'Sub' $P9584 = "60_1305640955.436" 
    assign $P9583, $P9584
    nqp_get_sc_object $P9585, "1305640934.989", 36
    .const 'Sub' $P9586 = "61_1305640955.436" 
    assign $P9585, $P9586
    nqp_get_sc_object $P9587, "1305640934.989", 37
    .const 'Sub' $P9588 = "63_1305640955.436" 
    assign $P9587, $P9588
    nqp_get_sc_object $P9589, "1305640934.989", 38
    .const 'Sub' $P9590 = "64_1305640955.436" 
    assign $P9589, $P9590
    nqp_get_sc_object $P9591, "1305640934.989", 39
    .const 'Sub' $P9592 = "65_1305640955.436" 
    assign $P9591, $P9592
    nqp_get_sc_object $P9593, "1305640934.989", 40
    .const 'Sub' $P9594 = "66_1305640955.436" 
    assign $P9593, $P9594
    nqp_get_sc_object $P9595, "1305640934.989", 41
    .const 'Sub' $P9596 = "67_1305640955.436" 
    assign $P9595, $P9596
    nqp_get_sc_object $P9597, "1305640934.989", 42
    .const 'Sub' $P9598 = "68_1305640955.436" 
    assign $P9597, $P9598
    nqp_get_sc_object $P9599, "1305640934.989", 43
    .const 'Sub' $P9600 = "69_1305640955.436" 
    assign $P9599, $P9600
    nqp_get_sc_object $P9601, "1305640934.989", 44
    .const 'Sub' $P9602 = "70_1305640955.436" 
    assign $P9601, $P9602
    nqp_get_sc_object $P9603, "1305640934.989", 45
    .const 'Sub' $P9604 = "71_1305640955.436" 
    assign $P9603, $P9604
    nqp_get_sc_object $P9605, "1305640934.989", 46
    .const 'Sub' $P9606 = "72_1305640955.436" 
    assign $P9605, $P9606
    nqp_get_sc_object $P9607, "1305640934.989", 47
    .const 'Sub' $P9608 = "73_1305640955.436" 
    assign $P9607, $P9608
    nqp_get_sc_object $P9609, "1305640934.989", 48
    .const 'Sub' $P9610 = "74_1305640955.436" 
    assign $P9609, $P9610
    nqp_get_sc_object $P9611, "1305640934.989", 49
    .const 'Sub' $P9612 = "75_1305640955.436" 
    assign $P9611, $P9612
    nqp_get_sc_object $P9613, "1305640934.989", 50
    .const 'Sub' $P9614 = "76_1305640955.436" 
    assign $P9613, $P9614
    nqp_get_sc_object $P9615, "1305640934.989", 51
    .const 'Sub' $P9616 = "77_1305640955.436" 
    assign $P9615, $P9616
    nqp_get_sc_object $P9617, "1305640934.989", 52
    .const 'Sub' $P9618 = "78_1305640955.436" 
    assign $P9617, $P9618
    nqp_get_sc_object $P9619, "1305640934.989", 53
    .const 'Sub' $P9620 = "79_1305640955.436" 
    assign $P9619, $P9620
    nqp_get_sc_object $P9621, "1305640934.989", 54
    .const 'Sub' $P9622 = "80_1305640955.436" 
    assign $P9621, $P9622
    nqp_get_sc_object $P9623, "1305640934.989", 55
    .const 'Sub' $P9624 = "81_1305640955.436" 
    assign $P9623, $P9624
    nqp_get_sc_object $P9625, "1305640934.989", 56
    .const 'Sub' $P9626 = "82_1305640955.436" 
    assign $P9625, $P9626
    nqp_get_sc_object $P9627, "1305640934.989", 57
    .const 'Sub' $P9628 = "83_1305640955.436" 
    assign $P9627, $P9628
    nqp_get_sc_object $P9629, "1305640934.989", 58
    .const 'Sub' $P9630 = "84_1305640955.436" 
    assign $P9629, $P9630
    nqp_get_sc_object $P9631, "1305640934.989", 59
    .const 'Sub' $P9632 = "85_1305640955.436" 
    assign $P9631, $P9632
    nqp_get_sc_object $P9633, "1305640934.989", 60
    .const 'Sub' $P9634 = "86_1305640955.436" 
    assign $P9633, $P9634
    nqp_get_sc_object $P9635, "1305640934.989", 61
    .const 'Sub' $P9636 = "87_1305640955.436" 
    assign $P9635, $P9636
    nqp_get_sc_object $P9637, "1305640934.989", 62
    .const 'Sub' $P9638 = "88_1305640955.436" 
    assign $P9637, $P9638
    nqp_get_sc_object $P9639, "1305640934.989", 63
    .const 'Sub' $P9640 = "89_1305640955.436" 
    assign $P9639, $P9640
    nqp_get_sc_object $P9641, "1305640934.989", 64
    .const 'Sub' $P9642 = "90_1305640955.436" 
    assign $P9641, $P9642
    nqp_get_sc_object $P9643, "1305640934.989", 65
    .const 'Sub' $P9644 = "91_1305640955.436" 
    assign $P9643, $P9644
    nqp_get_sc_object $P9645, "1305640934.989", 66
    .const 'Sub' $P9646 = "92_1305640955.436" 
    assign $P9645, $P9646
    nqp_get_sc_object $P9647, "1305640934.989", 67
    .const 'Sub' $P9648 = "93_1305640955.436" 
    assign $P9647, $P9648
    nqp_get_sc_object $P9649, "1305640934.989", 68
    .const 'Sub' $P9650 = "94_1305640955.436" 
    assign $P9649, $P9650
    nqp_get_sc_object $P9651, "1305640934.989", 69
    .const 'Sub' $P9652 = "95_1305640955.436" 
    assign $P9651, $P9652
    nqp_get_sc_object $P9653, "1305640934.989", 70
    .const 'Sub' $P9654 = "96_1305640955.436" 
    assign $P9653, $P9654
    nqp_get_sc_object $P9655, "1305640934.989", 71
    .const 'Sub' $P9656 = "97_1305640955.436" 
    assign $P9655, $P9656
    nqp_get_sc_object $P9657, "1305640934.989", 72
    .const 'Sub' $P9658 = "98_1305640955.436" 
    assign $P9657, $P9658
    nqp_get_sc_object $P9659, "1305640934.989", 73
    .const 'Sub' $P9660 = "100_1305640955.436" 
    assign $P9659, $P9660
    nqp_get_sc_object $P9661, "1305640934.989", 74
    .const 'Sub' $P9662 = "101_1305640955.436" 
    assign $P9661, $P9662
    nqp_get_sc_object $P9663, "1305640934.989", 75
    .const 'Sub' $P9664 = "102_1305640955.436" 
    assign $P9663, $P9664
    nqp_get_sc_object $P9665, "1305640934.989", 76
    .const 'Sub' $P9666 = "103_1305640955.436" 
    assign $P9665, $P9666
    nqp_get_sc_object $P9667, "1305640934.989", 77
    .const 'Sub' $P9668 = "104_1305640955.436" 
    assign $P9667, $P9668
    nqp_get_sc_object $P9669, "1305640934.989", 78
    .const 'Sub' $P9670 = "105_1305640955.436" 
    assign $P9669, $P9670
    nqp_get_sc_object $P9671, "1305640934.989", 79
    .const 'Sub' $P9672 = "106_1305640955.436" 
    assign $P9671, $P9672
    nqp_get_sc_object $P9673, "1305640934.989", 80
    .const 'Sub' $P9674 = "107_1305640955.436" 
    assign $P9673, $P9674
    nqp_get_sc_object $P9675, "1305640934.989", 81
    .const 'Sub' $P9676 = "108_1305640955.436" 
    assign $P9675, $P9676
    nqp_get_sc_object $P9677, "1305640934.989", 82
    .const 'Sub' $P9678 = "109_1305640955.436" 
    assign $P9677, $P9678
    nqp_get_sc_object $P9679, "1305640934.989", 83
    .const 'Sub' $P9680 = "110_1305640955.436" 
    assign $P9679, $P9680
    nqp_get_sc_object $P9681, "1305640934.989", 84
    .const 'Sub' $P9682 = "111_1305640955.436" 
    assign $P9681, $P9682
    nqp_get_sc_object $P9683, "1305640934.989", 85
    .const 'Sub' $P9684 = "112_1305640955.436" 
    assign $P9683, $P9684
    nqp_get_sc_object $P9685, "1305640934.989", 86
    .const 'Sub' $P9686 = "113_1305640955.436" 
    assign $P9685, $P9686
    nqp_get_sc_object $P9687, "1305640934.989", 87
    .const 'Sub' $P9688 = "114_1305640955.436" 
    assign $P9687, $P9688
    nqp_get_sc_object $P9689, "1305640934.989", 88
    .const 'Sub' $P9690 = "115_1305640955.436" 
    assign $P9689, $P9690
    nqp_get_sc_object $P9691, "1305640934.989", 89
    .const 'Sub' $P9692 = "116_1305640955.436" 
    assign $P9691, $P9692
    nqp_get_sc_object $P9693, "1305640934.989", 90
    .const 'Sub' $P9694 = "117_1305640955.436" 
    assign $P9693, $P9694
    nqp_get_sc_object $P9695, "1305640934.989", 91
    .const 'Sub' $P9696 = "118_1305640955.436" 
    assign $P9695, $P9696
    nqp_get_sc_object $P9697, "1305640934.989", 92
    .const 'Sub' $P9698 = "119_1305640955.436" 
    assign $P9697, $P9698
    nqp_get_sc_object $P9699, "1305640934.989", 93
    .const 'Sub' $P9700 = "120_1305640955.436" 
    assign $P9699, $P9700
    nqp_get_sc_object $P9701, "1305640934.989", 94
    .const 'Sub' $P9702 = "121_1305640955.436" 
    assign $P9701, $P9702
    nqp_get_sc_object $P9703, "1305640934.989", 95
    .const 'Sub' $P9704 = "122_1305640955.436" 
    assign $P9703, $P9704
    nqp_get_sc_object $P9705, "1305640934.989", 96
    .const 'Sub' $P9706 = "123_1305640955.436" 
    assign $P9705, $P9706
    nqp_get_sc_object $P9707, "1305640934.989", 97
    .const 'Sub' $P9708 = "124_1305640955.436" 
    assign $P9707, $P9708
    nqp_get_sc_object $P9709, "1305640934.989", 98
    .const 'Sub' $P9710 = "125_1305640955.436" 
    assign $P9709, $P9710
    nqp_get_sc_object $P9711, "1305640934.989", 99
    .const 'Sub' $P9712 = "126_1305640955.436" 
    assign $P9711, $P9712
    nqp_get_sc_object $P9713, "1305640934.989", 100
    .const 'Sub' $P9714 = "127_1305640955.436" 
    assign $P9713, $P9714
    nqp_get_sc_object $P9715, "1305640934.989", 101
    .const 'Sub' $P9716 = "128_1305640955.436" 
    assign $P9715, $P9716
    nqp_get_sc_object $P9717, "1305640934.989", 102
    .const 'Sub' $P9718 = "129_1305640955.436" 
    assign $P9717, $P9718
    nqp_get_sc_object $P9719, "1305640934.989", 103
    .const 'Sub' $P9720 = "130_1305640955.436" 
    assign $P9719, $P9720
    nqp_get_sc_object $P9721, "1305640934.989", 104
    .const 'Sub' $P9722 = "131_1305640955.436" 
    assign $P9721, $P9722
    nqp_get_sc_object $P9723, "1305640934.989", 105
    .const 'Sub' $P9724 = "132_1305640955.436" 
    assign $P9723, $P9724
    nqp_get_sc_object $P9725, "1305640934.989", 106
    .const 'Sub' $P9726 = "133_1305640955.436" 
    assign $P9725, $P9726
    nqp_get_sc_object $P9727, "1305640934.989", 107
    .const 'Sub' $P9728 = "134_1305640955.436" 
    assign $P9727, $P9728
    nqp_get_sc_object $P9729, "1305640934.989", 108
    .const 'Sub' $P9730 = "135_1305640955.436" 
    assign $P9729, $P9730
    nqp_get_sc_object $P9731, "1305640934.989", 109
    .const 'Sub' $P9732 = "136_1305640955.436" 
    assign $P9731, $P9732
    nqp_get_sc_object $P9733, "1305640934.989", 110
    .const 'Sub' $P9734 = "137_1305640955.436" 
    assign $P9733, $P9734
    nqp_get_sc_object $P9735, "1305640934.989", 111
    .const 'Sub' $P9736 = "138_1305640955.436" 
    assign $P9735, $P9736
    nqp_get_sc_object $P9737, "1305640934.989", 112
    .const 'Sub' $P9738 = "139_1305640955.436" 
    assign $P9737, $P9738
    nqp_get_sc_object $P9739, "1305640934.989", 113
    .const 'Sub' $P9740 = "140_1305640955.436" 
    assign $P9739, $P9740
    nqp_get_sc_object $P9741, "1305640934.989", 114
    .const 'Sub' $P9742 = "141_1305640955.436" 
    assign $P9741, $P9742
    nqp_get_sc_object $P9743, "1305640934.989", 115
    .const 'Sub' $P9744 = "142_1305640955.436" 
    assign $P9743, $P9744
    nqp_get_sc_object $P9745, "1305640934.989", 116
    .const 'Sub' $P9746 = "143_1305640955.436" 
    assign $P9745, $P9746
    nqp_get_sc_object $P9747, "1305640934.989", 117
    .const 'Sub' $P9748 = "144_1305640955.436" 
    assign $P9747, $P9748
    nqp_get_sc_object $P9749, "1305640934.989", 118
    .const 'Sub' $P9750 = "145_1305640955.436" 
    assign $P9749, $P9750
    nqp_get_sc_object $P9751, "1305640934.989", 119
    .const 'Sub' $P9752 = "148_1305640955.436" 
    assign $P9751, $P9752
    nqp_get_sc_object $P9753, "1305640934.989", 120
    .const 'Sub' $P9754 = "149_1305640955.436" 
    assign $P9753, $P9754
    nqp_get_sc_object $P9755, "1305640934.989", 121
    .const 'Sub' $P9756 = "150_1305640955.436" 
    assign $P9755, $P9756
    nqp_get_sc_object $P9757, "1305640934.989", 122
    .const 'Sub' $P9758 = "151_1305640955.436" 
    assign $P9757, $P9758
    nqp_get_sc_object $P9759, "1305640934.989", 123
    .const 'Sub' $P9760 = "152_1305640955.436" 
    assign $P9759, $P9760
    nqp_get_sc_object $P9761, "1305640934.989", 124
    .const 'Sub' $P9762 = "153_1305640955.436" 
    assign $P9761, $P9762
    nqp_get_sc_object $P9763, "1305640934.989", 125
    .const 'Sub' $P9764 = "154_1305640955.436" 
    assign $P9763, $P9764
    nqp_get_sc_object $P9765, "1305640934.989", 126
    .const 'Sub' $P9766 = "155_1305640955.436" 
    assign $P9765, $P9766
    nqp_get_sc_object $P9767, "1305640934.989", 127
    .const 'Sub' $P9768 = "156_1305640955.436" 
    assign $P9767, $P9768
    nqp_get_sc_object $P9769, "1305640934.989", 128
    .const 'Sub' $P9770 = "157_1305640955.436" 
    assign $P9769, $P9770
    nqp_get_sc_object $P9771, "1305640934.989", 129
    .const 'Sub' $P9772 = "158_1305640955.436" 
    assign $P9771, $P9772
    nqp_get_sc_object $P9773, "1305640934.989", 130
    .const 'Sub' $P9774 = "159_1305640955.436" 
    assign $P9773, $P9774
    nqp_get_sc_object $P9775, "1305640934.989", 131
    .const 'Sub' $P9776 = "160_1305640955.436" 
    assign $P9775, $P9776
    nqp_get_sc_object $P9777, "1305640934.989", 132
    .const 'Sub' $P9778 = "161_1305640955.436" 
    assign $P9777, $P9778
    nqp_get_sc_object $P9779, "1305640934.989", 133
    .const 'Sub' $P9780 = "162_1305640955.436" 
    assign $P9779, $P9780
    nqp_get_sc_object $P9781, "1305640934.989", 134
    .const 'Sub' $P9782 = "163_1305640955.436" 
    assign $P9781, $P9782
    nqp_get_sc_object $P9783, "1305640934.989", 135
    .const 'Sub' $P9784 = "164_1305640955.436" 
    assign $P9783, $P9784
    nqp_get_sc_object $P9785, "1305640934.989", 136
    .const 'Sub' $P9786 = "165_1305640955.436" 
    assign $P9785, $P9786
    nqp_get_sc_object $P9787, "1305640934.989", 137
    .const 'Sub' $P9788 = "166_1305640955.436" 
    assign $P9787, $P9788
    nqp_get_sc_object $P9789, "1305640934.989", 138
    .const 'Sub' $P9790 = "167_1305640955.436" 
    assign $P9789, $P9790
    nqp_get_sc_object $P9791, "1305640934.989", 139
    .const 'Sub' $P9792 = "168_1305640955.436" 
    assign $P9791, $P9792
    nqp_get_sc_object $P9793, "1305640934.989", 140
    .const 'Sub' $P9794 = "169_1305640955.436" 
    assign $P9793, $P9794
    nqp_get_sc_object $P9795, "1305640934.989", 141
    .const 'Sub' $P9796 = "170_1305640955.436" 
    assign $P9795, $P9796
    nqp_get_sc_object $P9797, "1305640934.989", 142
    .const 'Sub' $P9798 = "171_1305640955.436" 
    assign $P9797, $P9798
    nqp_get_sc_object $P9799, "1305640934.989", 143
    .const 'Sub' $P9800 = "172_1305640955.436" 
    assign $P9799, $P9800
    nqp_get_sc_object $P9801, "1305640934.989", 144
    .const 'Sub' $P9802 = "173_1305640955.436" 
    assign $P9801, $P9802
    nqp_get_sc_object $P9803, "1305640934.989", 145
    .const 'Sub' $P9804 = "174_1305640955.436" 
    assign $P9803, $P9804
    nqp_get_sc_object $P9805, "1305640934.989", 146
    .const 'Sub' $P9806 = "175_1305640955.436" 
    assign $P9805, $P9806
    nqp_get_sc_object $P9807, "1305640934.989", 147
    .const 'Sub' $P9808 = "176_1305640955.436" 
    assign $P9807, $P9808
    nqp_get_sc_object $P9809, "1305640934.989", 148
    .const 'Sub' $P9810 = "177_1305640955.436" 
    assign $P9809, $P9810
    nqp_get_sc_object $P9811, "1305640934.989", 149
    .const 'Sub' $P9812 = "178_1305640955.436" 
    assign $P9811, $P9812
    nqp_get_sc_object $P9813, "1305640934.989", 150
    .const 'Sub' $P9814 = "179_1305640955.436" 
    assign $P9813, $P9814
    nqp_get_sc_object $P9815, "1305640934.989", 151
    .const 'Sub' $P9816 = "180_1305640955.436" 
    assign $P9815, $P9816
    nqp_get_sc_object $P9817, "1305640934.989", 152
    .const 'Sub' $P9818 = "181_1305640955.436" 
    assign $P9817, $P9818
    nqp_get_sc_object $P9819, "1305640934.989", 153
    .const 'Sub' $P9820 = "183_1305640955.436" 
    assign $P9819, $P9820
    nqp_get_sc_object $P9821, "1305640934.989", 154
    .const 'Sub' $P9822 = "184_1305640955.436" 
    assign $P9821, $P9822
    nqp_get_sc_object $P9823, "1305640934.989", 155
    .const 'Sub' $P9824 = "185_1305640955.436" 
    assign $P9823, $P9824
    nqp_get_sc_object $P9825, "1305640934.989", 156
    .const 'Sub' $P9826 = "186_1305640955.436" 
    assign $P9825, $P9826
    nqp_get_sc_object $P9827, "1305640934.989", 157
    .const 'Sub' $P9828 = "187_1305640955.436" 
    assign $P9827, $P9828
    nqp_get_sc_object $P9829, "1305640934.989", 158
    .const 'Sub' $P9830 = "188_1305640955.436" 
    assign $P9829, $P9830
    nqp_get_sc_object $P9831, "1305640934.989", 159
    .const 'Sub' $P9832 = "189_1305640955.436" 
    assign $P9831, $P9832
    nqp_get_sc_object $P9833, "1305640934.989", 160
    .const 'Sub' $P9834 = "190_1305640955.436" 
    assign $P9833, $P9834
    nqp_get_sc_object $P9835, "1305640934.989", 161
    .const 'Sub' $P9836 = "191_1305640955.436" 
    assign $P9835, $P9836
    nqp_get_sc_object $P9837, "1305640934.989", 162
    .const 'Sub' $P9838 = "192_1305640955.436" 
    assign $P9837, $P9838
    nqp_get_sc_object $P9839, "1305640934.989", 163
    .const 'Sub' $P9840 = "193_1305640955.436" 
    assign $P9839, $P9840
    nqp_get_sc_object $P9841, "1305640934.989", 164
    .const 'Sub' $P9842 = "194_1305640955.436" 
    assign $P9841, $P9842
    nqp_get_sc_object $P9843, "1305640934.989", 165
    .const 'Sub' $P9844 = "196_1305640955.436" 
    assign $P9843, $P9844
    nqp_get_sc_object $P9845, "1305640934.989", 166
    .const 'Sub' $P9846 = "197_1305640955.436" 
    assign $P9845, $P9846
    nqp_get_sc_object $P9847, "1305640934.989", 167
    .const 'Sub' $P9848 = "198_1305640955.436" 
    assign $P9847, $P9848
    nqp_get_sc_object $P9849, "1305640934.989", 168
    .const 'Sub' $P9850 = "199_1305640955.436" 
    assign $P9849, $P9850
    nqp_get_sc_object $P9851, "1305640934.989", 169
    .const 'Sub' $P9852 = "201_1305640955.436" 
    assign $P9851, $P9852
    nqp_get_sc_object $P9853, "1305640934.989", 170
    .const 'Sub' $P9854 = "202_1305640955.436" 
    assign $P9853, $P9854
    nqp_get_sc_object $P9855, "1305640934.989", 171
    .const 'Sub' $P9856 = "203_1305640955.436" 
    assign $P9855, $P9856
    nqp_get_sc_object $P9857, "1305640934.989", 172
    .const 'Sub' $P9858 = "204_1305640955.436" 
    assign $P9857, $P9858
    nqp_get_sc_object $P9859, "1305640934.989", 173
    .const 'Sub' $P9860 = "205_1305640955.436" 
    assign $P9859, $P9860
    nqp_get_sc_object $P9861, "1305640934.989", 174
    .const 'Sub' $P9862 = "206_1305640955.436" 
    assign $P9861, $P9862
    nqp_get_sc_object $P9863, "1305640934.989", 175
    .const 'Sub' $P9864 = "207_1305640955.436" 
    assign $P9863, $P9864
    nqp_get_sc_object $P9865, "1305640934.989", 176
    .const 'Sub' $P9866 = "208_1305640955.436" 
    assign $P9865, $P9866
    nqp_get_sc_object $P9867, "1305640934.989", 177
    .const 'Sub' $P9868 = "209_1305640955.436" 
    assign $P9867, $P9868
    nqp_get_sc_object $P9869, "1305640934.989", 178
    .const 'Sub' $P9870 = "210_1305640955.436" 
    assign $P9869, $P9870
    nqp_get_sc_object $P9871, "1305640934.989", 179
    .const 'Sub' $P9872 = "212_1305640955.436" 
    assign $P9871, $P9872
    nqp_get_sc_object $P9873, "1305640934.989", 180
    .const 'Sub' $P9874 = "213_1305640955.436" 
    assign $P9873, $P9874
    nqp_get_sc_object $P9875, "1305640934.989", 181
    .const 'Sub' $P9876 = "215_1305640955.436" 
    assign $P9875, $P9876
    nqp_get_sc_object $P9877, "1305640934.989", 182
    .const 'Sub' $P9878 = "216_1305640955.436" 
    assign $P9877, $P9878
    nqp_get_sc_object $P9879, "1305640934.989", 183
    .const 'Sub' $P9880 = "217_1305640955.436" 
    assign $P9879, $P9880
    nqp_get_sc_object $P9881, "1305640934.989", 184
    .const 'Sub' $P9882 = "218_1305640955.436" 
    assign $P9881, $P9882
    nqp_get_sc_object $P9883, "1305640934.989", 185
    .const 'Sub' $P9884 = "219_1305640955.436" 
    assign $P9883, $P9884
    nqp_get_sc_object $P9885, "1305640934.989", 186
    .const 'Sub' $P9886 = "220_1305640955.436" 
    assign $P9885, $P9886
    nqp_get_sc_object $P9887, "1305640934.989", 187
    .const 'Sub' $P9888 = "221_1305640955.436" 
    assign $P9887, $P9888
    nqp_get_sc_object $P9889, "1305640934.989", 188
    .const 'Sub' $P9890 = "222_1305640955.436" 
    assign $P9889, $P9890
    nqp_get_sc_object $P9891, "1305640934.989", 189
    .const 'Sub' $P9892 = "223_1305640955.436" 
    assign $P9891, $P9892
    nqp_get_sc_object $P9893, "1305640934.989", 190
    .const 'Sub' $P9894 = "224_1305640955.436" 
    assign $P9893, $P9894
    nqp_get_sc_object $P9895, "1305640934.989", 191
    .const 'Sub' $P9896 = "226_1305640955.436" 
    assign $P9895, $P9896
    nqp_get_sc_object $P9897, "1305640934.989", 192
    .const 'Sub' $P9898 = "227_1305640955.436" 
    assign $P9897, $P9898
    nqp_get_sc_object $P9899, "1305640934.989", 193
    .const 'Sub' $P9900 = "228_1305640955.436" 
    assign $P9899, $P9900
    nqp_get_sc_object $P9901, "1305640934.989", 194
    .const 'Sub' $P9902 = "229_1305640955.436" 
    assign $P9901, $P9902
    nqp_get_sc_object $P9903, "1305640934.989", 195
    .const 'Sub' $P9904 = "230_1305640955.436" 
    assign $P9903, $P9904
    nqp_get_sc_object $P9905, "1305640934.989", 196
    .const 'Sub' $P9906 = "231_1305640955.436" 
    assign $P9905, $P9906
    nqp_get_sc_object $P9907, "1305640934.989", 197
    .const 'Sub' $P9908 = "232_1305640955.436" 
    assign $P9907, $P9908
    nqp_get_sc_object $P9909, "1305640934.989", 198
    .const 'Sub' $P9910 = "233_1305640955.436" 
    assign $P9909, $P9910
    nqp_get_sc_object $P9911, "1305640934.989", 199
    .const 'Sub' $P9912 = "234_1305640955.436" 
    assign $P9911, $P9912
    nqp_get_sc_object $P9913, "1305640934.989", 200
    .const 'Sub' $P9914 = "235_1305640955.436" 
    assign $P9913, $P9914
    nqp_get_sc_object $P9915, "1305640934.989", 201
    .const 'Sub' $P9916 = "236_1305640955.436" 
    assign $P9915, $P9916
    nqp_get_sc_object $P9917, "1305640934.989", 202
    .const 'Sub' $P9918 = "237_1305640955.436" 
    assign $P9917, $P9918
    nqp_get_sc_object $P9919, "1305640934.989", 203
    .const 'Sub' $P9920 = "238_1305640955.436" 
    assign $P9919, $P9920
    nqp_get_sc_object $P9921, "1305640934.989", 204
    .const 'Sub' $P9922 = "239_1305640955.436" 
    assign $P9921, $P9922
    nqp_get_sc_object $P9923, "1305640934.989", 205
    .const 'Sub' $P9924 = "240_1305640955.436" 
    assign $P9923, $P9924
    nqp_get_sc_object $P9925, "1305640934.989", 206
    .const 'Sub' $P9926 = "241_1305640955.436" 
    assign $P9925, $P9926
    nqp_get_sc_object $P9927, "1305640934.989", 207
    .const 'Sub' $P9928 = "242_1305640955.436" 
    assign $P9927, $P9928
    nqp_get_sc_object $P9929, "1305640934.989", 208
    .const 'Sub' $P9930 = "243_1305640955.436" 
    assign $P9929, $P9930
    nqp_get_sc_object $P9931, "1305640934.989", 209
    .const 'Sub' $P9932 = "244_1305640955.436" 
    assign $P9931, $P9932
    nqp_get_sc_object $P9933, "1305640934.989", 210
    .const 'Sub' $P9934 = "245_1305640955.436" 
    assign $P9933, $P9934
    nqp_get_sc_object $P9935, "1305640934.989", 211
    .const 'Sub' $P9936 = "246_1305640955.436" 
    assign $P9935, $P9936
    nqp_get_sc_object $P9937, "1305640934.989", 212
    .const 'Sub' $P9938 = "247_1305640955.436" 
    assign $P9937, $P9938
    nqp_get_sc_object $P9939, "1305640934.989", 213
    .const 'Sub' $P9940 = "248_1305640955.436" 
    assign $P9939, $P9940
    nqp_get_sc_object $P9941, "1305640934.989", 214
    .const 'Sub' $P9942 = "249_1305640955.436" 
    assign $P9941, $P9942
    nqp_get_sc_object $P9943, "1305640934.989", 215
    .const 'Sub' $P9944 = "250_1305640955.436" 
    assign $P9943, $P9944
    nqp_get_sc_object $P9945, "1305640934.989", 216
    .const 'Sub' $P9946 = "251_1305640955.436" 
    assign $P9945, $P9946
    nqp_get_sc_object $P9947, "1305640934.989", 217
    .const 'Sub' $P9948 = "252_1305640955.436" 
    assign $P9947, $P9948
    nqp_get_sc_object $P9949, "1305640934.989", 218
    .const 'Sub' $P9950 = "253_1305640955.436" 
    assign $P9949, $P9950
    nqp_get_sc_object $P9951, "1305640934.989", 219
    .const 'Sub' $P9952 = "254_1305640955.436" 
    assign $P9951, $P9952
    nqp_get_sc_object $P9953, "1305640934.989", 220
    .const 'Sub' $P9954 = "255_1305640955.436" 
    assign $P9953, $P9954
    nqp_get_sc_object $P9955, "1305640934.989", 221
    .const 'Sub' $P9956 = "257_1305640955.436" 
    assign $P9955, $P9956
    nqp_get_sc_object $P9957, "1305640934.989", 222
    .const 'Sub' $P9958 = "258_1305640955.436" 
    assign $P9957, $P9958
    nqp_get_sc_object $P9959, "1305640934.989", 223
    .const 'Sub' $P9960 = "259_1305640955.436" 
    assign $P9959, $P9960
    nqp_get_sc_object $P9961, "1305640934.989", 224
    .const 'Sub' $P9962 = "260_1305640955.436" 
    assign $P9961, $P9962
    nqp_get_sc_object $P9963, "1305640934.989", 225
    .const 'Sub' $P9964 = "261_1305640955.436" 
    assign $P9963, $P9964
    nqp_get_sc_object $P9965, "1305640934.989", 226
    .const 'Sub' $P9966 = "262_1305640955.436" 
    assign $P9965, $P9966
    nqp_get_sc_object $P9967, "1305640934.989", 227
    .const 'Sub' $P9968 = "263_1305640955.436" 
    assign $P9967, $P9968
    nqp_get_sc_object $P9969, "1305640934.989", 228
    .const 'Sub' $P9970 = "264_1305640955.436" 
    assign $P9969, $P9970
    nqp_get_sc_object $P9971, "1305640934.989", 229
    .const 'Sub' $P9972 = "265_1305640955.436" 
    assign $P9971, $P9972
    nqp_get_sc_object $P9973, "1305640934.989", 230
    .const 'Sub' $P9974 = "266_1305640955.436" 
    assign $P9973, $P9974
    nqp_get_sc_object $P9975, "1305640934.989", 231
    .const 'Sub' $P9976 = "267_1305640955.436" 
    assign $P9975, $P9976
    nqp_get_sc_object $P9977, "1305640934.989", 232
    .const 'Sub' $P9978 = "268_1305640955.436" 
    assign $P9977, $P9978
    nqp_get_sc_object $P9979, "1305640934.989", 233
    .const 'Sub' $P9980 = "269_1305640955.436" 
    assign $P9979, $P9980
    nqp_get_sc_object $P9981, "1305640934.989", 234
    .const 'Sub' $P9982 = "270_1305640955.436" 
    assign $P9981, $P9982
    nqp_get_sc_object $P9983, "1305640934.989", 235
    .const 'Sub' $P9984 = "271_1305640955.436" 
    assign $P9983, $P9984
    nqp_get_sc_object $P9985, "1305640934.989", 236
    .const 'Sub' $P9986 = "272_1305640955.436" 
    assign $P9985, $P9986
    nqp_get_sc_object $P9987, "1305640934.989", 237
    .const 'Sub' $P9988 = "273_1305640955.436" 
    assign $P9987, $P9988
    nqp_get_sc_object $P9989, "1305640934.989", 238
    .const 'Sub' $P9990 = "274_1305640955.436" 
    assign $P9989, $P9990
    nqp_get_sc_object $P9991, "1305640934.989", 239
    .const 'Sub' $P9992 = "275_1305640955.436" 
    assign $P9991, $P9992
    nqp_get_sc_object $P9993, "1305640934.989", 240
    .const 'Sub' $P9994 = "276_1305640955.436" 
    assign $P9993, $P9994
    nqp_get_sc_object $P9995, "1305640934.989", 241
    .const 'Sub' $P9996 = "277_1305640955.436" 
    assign $P9995, $P9996
    nqp_get_sc_object $P9997, "1305640934.989", 242
    .const 'Sub' $P9998 = "278_1305640955.436" 
    assign $P9997, $P9998
    nqp_get_sc_object $P9999, "1305640934.989", 243
    .const 'Sub' $P10000 = "279_1305640955.436" 
    assign $P9999, $P10000
    nqp_get_sc_object $P10001, "1305640934.989", 244
    .const 'Sub' $P10002 = "280_1305640955.436" 
    assign $P10001, $P10002
    nqp_get_sc_object $P10003, "1305640934.989", 245
    .const 'Sub' $P10004 = "281_1305640955.436" 
    assign $P10003, $P10004
    nqp_get_sc_object $P10005, "1305640934.989", 246
    .const 'Sub' $P10006 = "282_1305640955.436" 
    assign $P10005, $P10006
    nqp_get_sc_object $P10007, "1305640934.989", 247
    .const 'Sub' $P10008 = "283_1305640955.436" 
    assign $P10007, $P10008
    nqp_get_sc_object $P10009, "1305640934.989", 248
    .const 'Sub' $P10010 = "284_1305640955.436" 
    assign $P10009, $P10010
    nqp_get_sc_object $P10011, "1305640934.989", 249
    .const 'Sub' $P10012 = "285_1305640955.436" 
    assign $P10011, $P10012
    nqp_get_sc_object $P10013, "1305640934.989", 250
    .const 'Sub' $P10014 = "286_1305640955.436" 
    assign $P10013, $P10014
    nqp_get_sc_object $P10015, "1305640934.989", 251
    .const 'Sub' $P10016 = "287_1305640955.436" 
    assign $P10015, $P10016
    nqp_get_sc_object $P10017, "1305640934.989", 252
    .const 'Sub' $P10018 = "288_1305640955.436" 
    assign $P10017, $P10018
    nqp_get_sc_object $P10019, "1305640934.989", 253
    .const 'Sub' $P10020 = "289_1305640955.436" 
    assign $P10019, $P10020
    nqp_get_sc_object $P10021, "1305640934.989", 254
    .const 'Sub' $P10022 = "290_1305640955.436" 
    assign $P10021, $P10022
    nqp_get_sc_object $P10023, "1305640934.989", 255
    .const 'Sub' $P10024 = "291_1305640955.436" 
    assign $P10023, $P10024
    nqp_get_sc_object $P10025, "1305640934.989", 256
    .const 'Sub' $P10026 = "292_1305640955.436" 
    assign $P10025, $P10026
    nqp_get_sc_object $P10027, "1305640934.989", 257
    .const 'Sub' $P10028 = "293_1305640955.436" 
    assign $P10027, $P10028
    nqp_get_sc_object $P10029, "1305640934.989", 258
    .const 'Sub' $P10030 = "294_1305640955.436" 
    assign $P10029, $P10030
    nqp_get_sc_object $P10031, "1305640934.989", 259
    .const 'Sub' $P10032 = "295_1305640955.436" 
    assign $P10031, $P10032
    nqp_get_sc_object $P10033, "1305640934.989", 260
    .const 'Sub' $P10034 = "296_1305640955.436" 
    assign $P10033, $P10034
    nqp_get_sc_object $P10035, "1305640934.989", 261
    .const 'Sub' $P10036 = "297_1305640955.436" 
    assign $P10035, $P10036
    nqp_get_sc_object $P10037, "1305640934.989", 262
    .const 'Sub' $P10038 = "298_1305640955.436" 
    assign $P10037, $P10038
    nqp_get_sc_object $P10039, "1305640934.989", 263
    .const 'Sub' $P10040 = "299_1305640955.436" 
    assign $P10039, $P10040
    nqp_get_sc_object $P10041, "1305640934.989", 264
    .const 'Sub' $P10042 = "300_1305640955.436" 
    assign $P10041, $P10042
    nqp_get_sc_object $P10043, "1305640934.989", 265
    .const 'Sub' $P10044 = "301_1305640955.436" 
    assign $P10043, $P10044
    nqp_get_sc_object $P10045, "1305640934.989", 266
    .const 'Sub' $P10046 = "302_1305640955.436" 
    assign $P10045, $P10046
    nqp_get_sc_object $P10047, "1305640934.989", 267
    .const 'Sub' $P10048 = "303_1305640955.436" 
    assign $P10047, $P10048
    nqp_get_sc_object $P10049, "1305640934.989", 268
    .const 'Sub' $P10050 = "304_1305640955.436" 
    assign $P10049, $P10050
    nqp_get_sc_object $P10051, "1305640934.989", 269
    .const 'Sub' $P10052 = "305_1305640955.436" 
    assign $P10051, $P10052
    nqp_get_sc_object $P10053, "1305640934.989", 270
    .const 'Sub' $P10054 = "306_1305640955.436" 
    assign $P10053, $P10054
    nqp_get_sc_object $P10055, "1305640934.989", 271
    .const 'Sub' $P10056 = "307_1305640955.436" 
    assign $P10055, $P10056
    nqp_get_sc_object $P10057, "1305640934.989", 272
    .const 'Sub' $P10058 = "308_1305640955.436" 
    assign $P10057, $P10058
    nqp_get_sc_object $P10059, "1305640934.989", 273
    .const 'Sub' $P10060 = "309_1305640955.436" 
    assign $P10059, $P10060
    nqp_get_sc_object $P10061, "1305640934.989", 274
    .const 'Sub' $P10062 = "310_1305640955.436" 
    assign $P10061, $P10062
    nqp_get_sc_object $P10063, "1305640934.989", 275
    .const 'Sub' $P10064 = "311_1305640955.436" 
    assign $P10063, $P10064
    nqp_get_sc_object $P10065, "1305640934.989", 276
    .const 'Sub' $P10066 = "312_1305640955.436" 
    assign $P10065, $P10066
    nqp_get_sc_object $P10067, "1305640934.989", 277
    .const 'Sub' $P10068 = "313_1305640955.436" 
    assign $P10067, $P10068
    nqp_get_sc_object $P10069, "1305640934.989", 278
    .const 'Sub' $P10070 = "314_1305640955.436" 
    assign $P10069, $P10070
    nqp_get_sc_object $P10071, "1305640934.989", 279
    .const 'Sub' $P10072 = "315_1305640955.436" 
    assign $P10071, $P10072
    nqp_get_sc_object $P10073, "1305640934.989", 280
    .const 'Sub' $P10074 = "316_1305640955.436" 
    assign $P10073, $P10074
    nqp_get_sc_object $P10075, "1305640934.989", 281
    .const 'Sub' $P10076 = "317_1305640955.436" 
    assign $P10075, $P10076
    nqp_get_sc_object $P10077, "1305640934.989", 282
    .const 'Sub' $P10078 = "318_1305640955.436" 
    assign $P10077, $P10078
    nqp_get_sc_object $P10079, "1305640934.989", 283
    .const 'Sub' $P10080 = "319_1305640955.436" 
    assign $P10079, $P10080
    nqp_get_sc_object $P10081, "1305640934.989", 284
    .const 'Sub' $P10082 = "320_1305640955.436" 
    assign $P10081, $P10082
    nqp_get_sc_object $P10083, "1305640934.989", 285
    .const 'Sub' $P10084 = "321_1305640955.436" 
    assign $P10083, $P10084
    nqp_get_sc_object $P10085, "1305640934.989", 286
    .const 'Sub' $P10086 = "322_1305640955.436" 
    assign $P10085, $P10086
    nqp_get_sc_object $P10087, "1305640934.989", 287
    .const 'Sub' $P10088 = "323_1305640955.436" 
    assign $P10087, $P10088
    nqp_get_sc_object $P10089, "1305640934.989", 288
    .const 'Sub' $P10090 = "324_1305640955.436" 
    assign $P10089, $P10090
    nqp_get_sc_object $P10091, "1305640934.989", 289
    .const 'Sub' $P10092 = "325_1305640955.436" 
    assign $P10091, $P10092
    nqp_get_sc_object $P10093, "1305640934.989", 290
    .const 'Sub' $P10094 = "326_1305640955.436" 
    assign $P10093, $P10094
    nqp_get_sc_object $P10095, "1305640934.989", 291
    .const 'Sub' $P10096 = "327_1305640955.436" 
    assign $P10095, $P10096
    nqp_get_sc_object $P10097, "1305640934.989", 292
    .const 'Sub' $P10098 = "328_1305640955.436" 
    assign $P10097, $P10098
    nqp_get_sc_object $P10099, "1305640934.989", 293
    .const 'Sub' $P10100 = "329_1305640955.436" 
    assign $P10099, $P10100
    nqp_get_sc_object $P10101, "1305640934.989", 294
    .const 'Sub' $P10102 = "330_1305640955.436" 
    assign $P10101, $P10102
    nqp_get_sc_object $P10103, "1305640934.989", 295
    .const 'Sub' $P10104 = "331_1305640955.436" 
    assign $P10103, $P10104
    nqp_get_sc_object $P10105, "1305640934.989", 296
    .const 'Sub' $P10106 = "332_1305640955.436" 
    assign $P10105, $P10106
    nqp_get_sc_object $P10107, "1305640934.989", 297
    .const 'Sub' $P10108 = "333_1305640955.436" 
    assign $P10107, $P10108
    nqp_get_sc_object $P10109, "1305640934.989", 298
    .const 'Sub' $P10110 = "334_1305640955.436" 
    assign $P10109, $P10110
    nqp_get_sc_object $P10111, "1305640934.989", 299
    .const 'Sub' $P10112 = "335_1305640955.436" 
    assign $P10111, $P10112
    nqp_get_sc_object $P10113, "1305640934.989", 300
    .const 'Sub' $P10114 = "336_1305640955.436" 
    assign $P10113, $P10114
    nqp_get_sc_object $P10115, "1305640934.989", 301
    .const 'Sub' $P10116 = "337_1305640955.436" 
    assign $P10115, $P10116
    nqp_get_sc_object $P10117, "1305640934.989", 302
    .const 'Sub' $P10118 = "338_1305640955.436" 
    assign $P10117, $P10118
    nqp_get_sc_object $P10119, "1305640934.989", 303
    .const 'Sub' $P10120 = "339_1305640955.436" 
    assign $P10119, $P10120
    nqp_get_sc_object $P10121, "1305640934.989", 304
    .const 'Sub' $P10122 = "340_1305640955.436" 
    assign $P10121, $P10122
    nqp_get_sc_object $P10123, "1305640934.989", 305
    .const 'Sub' $P10124 = "341_1305640955.436" 
    assign $P10123, $P10124
    nqp_get_sc_object $P10125, "1305640934.989", 306
    .const 'Sub' $P10126 = "342_1305640955.436" 
    assign $P10125, $P10126
    nqp_get_sc_object $P10127, "1305640934.989", 307
    .const 'Sub' $P10128 = "343_1305640955.436" 
    assign $P10127, $P10128
    nqp_get_sc_object $P10129, "1305640934.989", 308
    .const 'Sub' $P10130 = "344_1305640955.436" 
    assign $P10129, $P10130
    nqp_get_sc_object $P10131, "1305640934.989", 309
    .const 'Sub' $P10132 = "345_1305640955.436" 
    assign $P10131, $P10132
    nqp_get_sc_object $P10133, "1305640934.989", 310
    .const 'Sub' $P10134 = "346_1305640955.436" 
    assign $P10133, $P10134
    nqp_get_sc_object $P10135, "1305640934.989", 311
    .const 'Sub' $P10136 = "347_1305640955.436" 
    assign $P10135, $P10136
    nqp_get_sc_object $P10137, "1305640934.989", 312
    .const 'Sub' $P10138 = "348_1305640955.436" 
    assign $P10137, $P10138
    nqp_get_sc_object $P10139, "1305640934.989", 313
    .const 'Sub' $P10140 = "349_1305640955.436" 
    assign $P10139, $P10140
    nqp_get_sc_object $P10141, "1305640934.989", 314
    .const 'Sub' $P10142 = "350_1305640955.436" 
    assign $P10141, $P10142
    nqp_get_sc_object $P10143, "1305640934.989", 315
    .const 'Sub' $P10144 = "351_1305640955.436" 
    assign $P10143, $P10144
    nqp_get_sc_object $P10145, "1305640934.989", 316
    .const 'Sub' $P10146 = "352_1305640955.436" 
    assign $P10145, $P10146
    nqp_get_sc_object $P10147, "1305640934.989", 317
    .const 'Sub' $P10148 = "353_1305640955.436" 
    assign $P10147, $P10148
    nqp_get_sc_object $P10149, "1305640934.989", 318
    .const 'Sub' $P10150 = "354_1305640955.436" 
    assign $P10149, $P10150
    nqp_get_sc_object $P10151, "1305640934.989", 319
    .const 'Sub' $P10152 = "355_1305640955.436" 
    assign $P10151, $P10152
    nqp_get_sc_object $P10153, "1305640934.989", 320
    .const 'Sub' $P10154 = "356_1305640955.436" 
    assign $P10153, $P10154
    nqp_get_sc_object $P10155, "1305640934.989", 321
    .const 'Sub' $P10156 = "357_1305640955.436" 
    assign $P10155, $P10156
    nqp_get_sc_object $P10157, "1305640934.989", 322
    .const 'Sub' $P10158 = "358_1305640955.436" 
    assign $P10157, $P10158
    nqp_get_sc_object $P10159, "1305640934.989", 323
    .const 'Sub' $P10160 = "359_1305640955.436" 
    assign $P10159, $P10160
    nqp_get_sc_object $P10161, "1305640934.989", 324
    .const 'Sub' $P10162 = "360_1305640955.436" 
    assign $P10161, $P10162
    nqp_get_sc_object $P10163, "1305640934.989", 325
    .const 'Sub' $P10164 = "361_1305640955.436" 
    assign $P10163, $P10164
    nqp_get_sc_object $P10165, "1305640934.989", 326
    .const 'Sub' $P10166 = "362_1305640955.436" 
    assign $P10165, $P10166
    nqp_get_sc_object $P10167, "1305640934.989", 327
    .const 'Sub' $P10168 = "363_1305640955.436" 
    assign $P10167, $P10168
    nqp_get_sc_object $P10169, "1305640934.989", 328
    .const 'Sub' $P10170 = "364_1305640955.436" 
    assign $P10169, $P10170
    nqp_get_sc_object $P10171, "1305640934.989", 329
    .const 'Sub' $P10172 = "365_1305640955.436" 
    assign $P10171, $P10172
    nqp_get_sc_object $P10173, "1305640934.989", 330
    .const 'Sub' $P10174 = "366_1305640955.436" 
    assign $P10173, $P10174
    nqp_get_sc_object $P10175, "1305640934.989", 331
    .const 'Sub' $P10176 = "367_1305640955.436" 
    assign $P10175, $P10176
    nqp_get_sc_object $P10177, "1305640934.989", 332
    .const 'Sub' $P10178 = "368_1305640955.436" 
    assign $P10177, $P10178
    nqp_get_sc_object $P10179, "1305640934.989", 333
    .const 'Sub' $P10180 = "369_1305640955.436" 
    assign $P10179, $P10180
    nqp_get_sc_object $P10181, "1305640934.989", 334
    .const 'Sub' $P10182 = "370_1305640955.436" 
    assign $P10181, $P10182
    nqp_get_sc_object $P10183, "1305640934.989", 335
    .const 'Sub' $P10184 = "371_1305640955.436" 
    assign $P10183, $P10184
    nqp_get_sc_object $P10185, "1305640934.989", 336
    .const 'Sub' $P10186 = "372_1305640955.436" 
    assign $P10185, $P10186
    nqp_get_sc_object $P10187, "1305640934.989", 337
    .const 'Sub' $P10188 = "373_1305640955.436" 
    assign $P10187, $P10188
    nqp_get_sc_object $P10189, "1305640934.989", 338
    .const 'Sub' $P10190 = "374_1305640955.436" 
    assign $P10189, $P10190
    nqp_get_sc_object $P10191, "1305640934.989", 339
    .const 'Sub' $P10192 = "375_1305640955.436" 
    assign $P10191, $P10192
    nqp_get_sc_object $P10193, "1305640934.989", 340
    .const 'Sub' $P10194 = "376_1305640955.436" 
    assign $P10193, $P10194
    nqp_get_sc_object $P10195, "1305640934.989", 341
    .const 'Sub' $P10196 = "377_1305640955.436" 
    assign $P10195, $P10196
    nqp_get_sc_object $P10197, "1305640934.989", 342
    .const 'Sub' $P10198 = "378_1305640955.436" 
    assign $P10197, $P10198
    nqp_get_sc_object $P10199, "1305640934.989", 343
    .const 'Sub' $P10200 = "379_1305640955.436" 
    assign $P10199, $P10200
    nqp_get_sc_object $P10201, "1305640934.989", 344
    .const 'Sub' $P10202 = "380_1305640955.436" 
    assign $P10201, $P10202
    nqp_get_sc_object $P10203, "1305640934.989", 345
    .const 'Sub' $P10204 = "381_1305640955.436" 
    assign $P10203, $P10204
    nqp_get_sc_object $P10205, "1305640934.989", 346
    .const 'Sub' $P10206 = "382_1305640955.436" 
    assign $P10205, $P10206
    nqp_get_sc_object $P10207, "1305640934.989", 347
    .const 'Sub' $P10208 = "383_1305640955.436" 
    assign $P10207, $P10208
    nqp_get_sc_object $P10209, "1305640934.989", 348
    .const 'Sub' $P10210 = "384_1305640955.436" 
    assign $P10209, $P10210
    nqp_get_sc_object $P10211, "1305640934.989", 349
    .const 'Sub' $P10212 = "385_1305640955.436" 
    assign $P10211, $P10212
    nqp_get_sc_object $P10213, "1305640934.989", 350
    .const 'Sub' $P10214 = "386_1305640955.436" 
    assign $P10213, $P10214
    nqp_get_sc_object $P10215, "1305640934.989", 351
    .const 'Sub' $P10216 = "387_1305640955.436" 
    assign $P10215, $P10216
    nqp_get_sc_object $P10217, "1305640934.989", 352
    .const 'Sub' $P10218 = "388_1305640955.436" 
    assign $P10217, $P10218
    nqp_get_sc_object $P10219, "1305640934.989", 353
    .const 'Sub' $P10220 = "389_1305640955.436" 
    assign $P10219, $P10220
    nqp_get_sc_object $P10221, "1305640934.989", 354
    .const 'Sub' $P10222 = "390_1305640955.436" 
    assign $P10221, $P10222
    nqp_get_sc_object $P10223, "1305640934.989", 355
    .const 'Sub' $P10224 = "391_1305640955.436" 
    assign $P10223, $P10224
    nqp_get_sc_object $P10225, "1305640934.989", 356
    .const 'Sub' $P10226 = "392_1305640955.436" 
    assign $P10225, $P10226
    nqp_get_sc_object $P10227, "1305640934.989", 357
    .const 'Sub' $P10228 = "393_1305640955.436" 
    assign $P10227, $P10228
    nqp_get_sc_object $P10229, "1305640934.989", 358
    .const 'Sub' $P10230 = "394_1305640955.436" 
    assign $P10229, $P10230
    nqp_get_sc_object $P10231, "1305640934.989", 359
    .const 'Sub' $P10232 = "395_1305640955.436" 
    assign $P10231, $P10232
    nqp_get_sc_object $P10233, "1305640934.989", 360
    .const 'Sub' $P10234 = "396_1305640955.436" 
    assign $P10233, $P10234
    nqp_get_sc_object $P10235, "1305640934.989", 361
    .const 'Sub' $P10236 = "397_1305640955.436" 
    assign $P10235, $P10236
    nqp_get_sc_object $P10237, "1305640934.989", 362
    .const 'Sub' $P10238 = "398_1305640955.436" 
    assign $P10237, $P10238
    nqp_get_sc_object $P10239, "1305640934.989", 363
    .const 'Sub' $P10240 = "399_1305640955.436" 
    assign $P10239, $P10240
    nqp_get_sc_object $P10241, "1305640934.989", 364
    .const 'Sub' $P10242 = "400_1305640955.436" 
    assign $P10241, $P10242
    nqp_get_sc_object $P10243, "1305640934.989", 365
    .const 'Sub' $P10244 = "401_1305640955.436" 
    assign $P10243, $P10244
    nqp_get_sc_object $P10245, "1305640934.989", 366
    .const 'Sub' $P10246 = "402_1305640955.436" 
    assign $P10245, $P10246
    nqp_get_sc_object $P10247, "1305640934.989", 367
    .const 'Sub' $P10248 = "404_1305640955.436" 
    assign $P10247, $P10248
    nqp_get_sc_object $P10249, "1305640934.989", 368
    .const 'Sub' $P10250 = "405_1305640955.436" 
    assign $P10249, $P10250
    nqp_get_sc_object $P10251, "1305640934.989", 369
    .const 'Sub' $P10252 = "406_1305640955.436" 
    assign $P10251, $P10252
    nqp_get_sc_object $P10253, "1305640934.989", 370
    .const 'Sub' $P10254 = "407_1305640955.436" 
    assign $P10253, $P10254
    nqp_get_sc_object $P10255, "1305640934.989", 371
    .const 'Sub' $P10256 = "408_1305640955.436" 
    assign $P10255, $P10256
    nqp_get_sc_object $P10257, "1305640934.989", 372
    .const 'Sub' $P10258 = "409_1305640955.436" 
    assign $P10257, $P10258
    nqp_get_sc_object $P10259, "1305640934.989", 373
    .const 'Sub' $P10260 = "410_1305640955.436" 
    assign $P10259, $P10260
    nqp_get_sc_object $P10261, "1305640934.989", 374
    .const 'Sub' $P10262 = "411_1305640955.436" 
    assign $P10261, $P10262
    nqp_get_sc_object $P10263, "1305640934.989", 375
    .const 'Sub' $P10264 = "412_1305640955.436" 
    assign $P10263, $P10264
    nqp_get_sc_object $P10265, "1305640934.989", 376
    .const 'Sub' $P10266 = "413_1305640955.436" 
    assign $P10265, $P10266
    .const 'Sub' $P10267 = "39_1305640955.436" 
    $P10268 = $P10267."get_lexinfo"()
    nqp_get_sc_object $P10269, "1305640934.989", 16
    $P10268."set_static_lexpad_value"("$?PACKAGE", $P10269)
    .const 'Sub' $P10270 = "39_1305640955.436" 
    $P10271 = $P10270."get_lexinfo"()
    $P10271."finish_static_lexpad"()
    .const 'Sub' $P10272 = "39_1305640955.436" 
    $P10273 = $P10272."get_lexinfo"()
    nqp_get_sc_object $P10274, "1305640934.989", 16
    $P10273."set_static_lexpad_value"("$?CLASS", $P10274)
    .const 'Sub' $P10275 = "39_1305640955.436" 
    $P10276 = $P10275."get_lexinfo"()
    $P10276."finish_static_lexpad"()
    nqp_get_sc_object $P10277, "1305640934.989", 378
    .const 'Sub' $P10278 = "415_1305640955.436" 
    assign $P10277, $P10278
    nqp_get_sc_object $P10279, "1305640934.989", 379
    .const 'Sub' $P10280 = "417_1305640955.436" 
    assign $P10279, $P10280
    nqp_get_sc_object $P10281, "1305640934.989", 380
    .const 'Sub' $P10282 = "418_1305640955.436" 
    assign $P10281, $P10282
    nqp_get_sc_object $P10283, "1305640934.989", 381
    .const 'Sub' $P10284 = "419_1305640955.436" 
    assign $P10283, $P10284
    nqp_get_sc_object $P10285, "1305640934.989", 382
    .const 'Sub' $P10286 = "420_1305640955.436" 
    assign $P10285, $P10286
    nqp_get_sc_object $P10287, "1305640934.989", 383
    .const 'Sub' $P10288 = "422_1305640955.436" 
    assign $P10287, $P10288
    nqp_get_sc_object $P10289, "1305640934.989", 384
    .const 'Sub' $P10290 = "423_1305640955.436" 
    assign $P10289, $P10290
    nqp_get_sc_object $P10291, "1305640934.989", 385
    .const 'Sub' $P10292 = "424_1305640955.436" 
    assign $P10291, $P10292
    nqp_get_sc_object $P10293, "1305640934.989", 386
    .const 'Sub' $P10294 = "425_1305640955.436" 
    assign $P10293, $P10294
    nqp_get_sc_object $P10295, "1305640934.989", 387
    .const 'Sub' $P10296 = "427_1305640955.436" 
    assign $P10295, $P10296
    nqp_get_sc_object $P10297, "1305640934.989", 388
    .const 'Sub' $P10298 = "428_1305640955.436" 
    assign $P10297, $P10298
    nqp_get_sc_object $P10299, "1305640934.989", 389
    .const 'Sub' $P10300 = "430_1305640955.436" 
    assign $P10299, $P10300
    nqp_get_sc_object $P10301, "1305640934.989", 390
    .const 'Sub' $P10302 = "431_1305640955.436" 
    assign $P10301, $P10302
    nqp_get_sc_object $P10303, "1305640934.989", 391
    .const 'Sub' $P10304 = "432_1305640955.436" 
    assign $P10303, $P10304
    nqp_get_sc_object $P10305, "1305640934.989", 392
    .const 'Sub' $P10306 = "433_1305640955.436" 
    assign $P10305, $P10306
    nqp_get_sc_object $P10307, "1305640934.989", 393
    .const 'Sub' $P10308 = "434_1305640955.436" 
    assign $P10307, $P10308
    .const 'Sub' $P10309 = "414_1305640955.436" 
    $P10310 = $P10309."get_lexinfo"()
    nqp_get_sc_object $P10311, "1305640934.989", 377
    $P10310."set_static_lexpad_value"("$?PACKAGE", $P10311)
    .const 'Sub' $P10312 = "414_1305640955.436" 
    $P10313 = $P10312."get_lexinfo"()
    $P10313."finish_static_lexpad"()
    .const 'Sub' $P10314 = "414_1305640955.436" 
    $P10315 = $P10314."get_lexinfo"()
    nqp_get_sc_object $P10316, "1305640934.989", 377
    $P10315."set_static_lexpad_value"("$?CLASS", $P10316)
    .const 'Sub' $P10317 = "414_1305640955.436" 
    $P10318 = $P10317."get_lexinfo"()
    $P10318."finish_static_lexpad"()
    nqp_get_sc_object $P10319, "1305640934.989", 395
    .const 'Sub' $P10320 = "462_1305640955.436" 
    assign $P10319, $P10320
    nqp_get_sc_object $P10321, "1305640934.989", 396
    .const 'Sub' $P10322 = "463_1305640955.436" 
    assign $P10321, $P10322
    nqp_get_sc_object $P10323, "1305640934.989", 397
    .const 'Sub' $P10324 = "464_1305640955.436" 
    assign $P10323, $P10324
    nqp_get_sc_object $P10325, "1305640934.989", 398
    .const 'Sub' $P10326 = "465_1305640955.436" 
    assign $P10325, $P10326
    nqp_get_sc_object $P10327, "1305640934.989", 399
    .const 'Sub' $P10328 = "467_1305640955.436" 
    assign $P10327, $P10328
    nqp_get_sc_object $P10329, "1305640934.989", 400
    .const 'Sub' $P10330 = "469_1305640955.436" 
    assign $P10329, $P10330
    nqp_get_sc_object $P10331, "1305640934.989", 401
    .const 'Sub' $P10332 = "470_1305640955.436" 
    assign $P10331, $P10332
    nqp_get_sc_object $P10333, "1305640934.989", 402
    .const 'Sub' $P10334 = "471_1305640955.436" 
    assign $P10333, $P10334
    nqp_get_sc_object $P10335, "1305640934.989", 403
    .const 'Sub' $P10336 = "472_1305640955.436" 
    assign $P10335, $P10336
    nqp_get_sc_object $P10337, "1305640934.989", 404
    .const 'Sub' $P10338 = "474_1305640955.436" 
    assign $P10337, $P10338
    nqp_get_sc_object $P10339, "1305640934.989", 405
    .const 'Sub' $P10340 = "475_1305640955.436" 
    assign $P10339, $P10340
    nqp_get_sc_object $P10341, "1305640934.989", 406
    .const 'Sub' $P10342 = "477_1305640955.436" 
    assign $P10341, $P10342
    nqp_get_sc_object $P10343, "1305640934.989", 407
    .const 'Sub' $P10344 = "478_1305640955.436" 
    assign $P10343, $P10344
    nqp_get_sc_object $P10345, "1305640934.989", 408
    .const 'Sub' $P10346 = "479_1305640955.436" 
    assign $P10345, $P10346
    nqp_get_sc_object $P10347, "1305640934.989", 409
    .const 'Sub' $P10348 = "480_1305640955.436" 
    assign $P10347, $P10348
    nqp_get_sc_object $P10349, "1305640934.989", 410
    .const 'Sub' $P10350 = "482_1305640955.436" 
    assign $P10349, $P10350
    nqp_get_sc_object $P10351, "1305640934.989", 411
    .const 'Sub' $P10352 = "483_1305640955.436" 
    assign $P10351, $P10352
    nqp_get_sc_object $P10353, "1305640934.989", 412
    .const 'Sub' $P10354 = "484_1305640955.436" 
    assign $P10353, $P10354
    nqp_get_sc_object $P10355, "1305640934.989", 413
    .const 'Sub' $P10356 = "485_1305640955.436" 
    assign $P10355, $P10356
    nqp_get_sc_object $P10357, "1305640934.989", 414
    .const 'Sub' $P10358 = "486_1305640955.436" 
    assign $P10357, $P10358
    nqp_get_sc_object $P10359, "1305640934.989", 415
    .const 'Sub' $P10360 = "487_1305640955.436" 
    assign $P10359, $P10360
    nqp_get_sc_object $P10361, "1305640934.989", 416
    .const 'Sub' $P10362 = "488_1305640955.436" 
    assign $P10361, $P10362
    nqp_get_sc_object $P10363, "1305640934.989", 417
    .const 'Sub' $P10364 = "489_1305640955.436" 
    assign $P10363, $P10364
    nqp_get_sc_object $P10365, "1305640934.989", 418
    .const 'Sub' $P10366 = "490_1305640955.436" 
    assign $P10365, $P10366
    nqp_get_sc_object $P10367, "1305640934.989", 419
    .const 'Sub' $P10368 = "491_1305640955.436" 
    assign $P10367, $P10368
    nqp_get_sc_object $P10369, "1305640934.989", 420
    .const 'Sub' $P10370 = "492_1305640955.436" 
    assign $P10369, $P10370
    nqp_get_sc_object $P10371, "1305640934.989", 421
    .const 'Sub' $P10372 = "493_1305640955.436" 
    assign $P10371, $P10372
    nqp_get_sc_object $P10373, "1305640934.989", 422
    .const 'Sub' $P10374 = "494_1305640955.436" 
    assign $P10373, $P10374
    nqp_get_sc_object $P10375, "1305640934.989", 423
    .const 'Sub' $P10376 = "495_1305640955.436" 
    assign $P10375, $P10376
    nqp_get_sc_object $P10377, "1305640934.989", 424
    .const 'Sub' $P10378 = "496_1305640955.436" 
    assign $P10377, $P10378
    nqp_get_sc_object $P10379, "1305640934.989", 425
    .const 'Sub' $P10380 = "497_1305640955.436" 
    assign $P10379, $P10380
    nqp_get_sc_object $P10381, "1305640934.989", 426
    .const 'Sub' $P10382 = "498_1305640955.436" 
    assign $P10381, $P10382
    nqp_get_sc_object $P10383, "1305640934.989", 427
    .const 'Sub' $P10384 = "499_1305640955.436" 
    assign $P10383, $P10384
    nqp_get_sc_object $P10385, "1305640934.989", 428
    .const 'Sub' $P10386 = "500_1305640955.436" 
    assign $P10385, $P10386
    nqp_get_sc_object $P10387, "1305640934.989", 429
    .const 'Sub' $P10388 = "501_1305640955.436" 
    assign $P10387, $P10388
    nqp_get_sc_object $P10389, "1305640934.989", 430
    .const 'Sub' $P10390 = "502_1305640955.436" 
    assign $P10389, $P10390
    nqp_get_sc_object $P10391, "1305640934.989", 431
    .const 'Sub' $P10392 = "503_1305640955.436" 
    assign $P10391, $P10392
    nqp_get_sc_object $P10393, "1305640934.989", 432
    .const 'Sub' $P10394 = "504_1305640955.436" 
    assign $P10393, $P10394
    nqp_get_sc_object $P10395, "1305640934.989", 433
    .const 'Sub' $P10396 = "505_1305640955.436" 
    assign $P10395, $P10396
    nqp_get_sc_object $P10397, "1305640934.989", 434
    .const 'Sub' $P10398 = "506_1305640955.436" 
    assign $P10397, $P10398
    nqp_get_sc_object $P10399, "1305640934.989", 435
    .const 'Sub' $P10400 = "512_1305640955.436" 
    assign $P10399, $P10400
    nqp_get_sc_object $P10401, "1305640934.989", 436
    .const 'Sub' $P10402 = "513_1305640955.436" 
    assign $P10401, $P10402
    nqp_get_sc_object $P10403, "1305640934.989", 437
    .const 'Sub' $P10404 = "514_1305640955.436" 
    assign $P10403, $P10404
    nqp_get_sc_object $P10405, "1305640934.989", 438
    .const 'Sub' $P10406 = "515_1305640955.436" 
    assign $P10405, $P10406
    nqp_get_sc_object $P10407, "1305640934.989", 439
    .const 'Sub' $P10408 = "516_1305640955.436" 
    assign $P10407, $P10408
    nqp_get_sc_object $P10409, "1305640934.989", 440
    .const 'Sub' $P10410 = "517_1305640955.436" 
    assign $P10409, $P10410
    nqp_get_sc_object $P10411, "1305640934.989", 441
    .const 'Sub' $P10412 = "518_1305640955.436" 
    assign $P10411, $P10412
    nqp_get_sc_object $P10413, "1305640934.989", 442
    .const 'Sub' $P10414 = "519_1305640955.436" 
    assign $P10413, $P10414
    nqp_get_sc_object $P10415, "1305640934.989", 443
    .const 'Sub' $P10416 = "525_1305640955.436" 
    assign $P10415, $P10416
    nqp_get_sc_object $P10417, "1305640934.989", 444
    .const 'Sub' $P10418 = "526_1305640955.436" 
    assign $P10417, $P10418
    nqp_get_sc_object $P10419, "1305640934.989", 445
    .const 'Sub' $P10420 = "527_1305640955.436" 
    assign $P10419, $P10420
    nqp_get_sc_object $P10421, "1305640934.989", 446
    .const 'Sub' $P10422 = "528_1305640955.436" 
    assign $P10421, $P10422
    nqp_get_sc_object $P10423, "1305640934.989", 447
    .const 'Sub' $P10424 = "529_1305640955.436" 
    assign $P10423, $P10424
    nqp_get_sc_object $P10425, "1305640934.989", 448
    .const 'Sub' $P10426 = "530_1305640955.436" 
    assign $P10425, $P10426
    nqp_get_sc_object $P10427, "1305640934.989", 449
    .const 'Sub' $P10428 = "531_1305640955.436" 
    assign $P10427, $P10428
    nqp_get_sc_object $P10429, "1305640934.989", 450
    .const 'Sub' $P10430 = "532_1305640955.436" 
    assign $P10429, $P10430
    nqp_get_sc_object $P10431, "1305640934.989", 451
    .const 'Sub' $P10432 = "533_1305640955.436" 
    assign $P10431, $P10432
    nqp_get_sc_object $P10433, "1305640934.989", 452
    .const 'Sub' $P10434 = "536_1305640955.436" 
    assign $P10433, $P10434
    nqp_get_sc_object $P10435, "1305640934.989", 453
    .const 'Sub' $P10436 = "537_1305640955.436" 
    assign $P10435, $P10436
    nqp_get_sc_object $P10437, "1305640934.989", 454
    .const 'Sub' $P10438 = "538_1305640955.436" 
    assign $P10437, $P10438
    nqp_get_sc_object $P10439, "1305640934.989", 455
    .const 'Sub' $P10440 = "545_1305640955.436" 
    assign $P10439, $P10440
    nqp_get_sc_object $P10441, "1305640934.989", 456
    .const 'Sub' $P10442 = "548_1305640955.436" 
    assign $P10441, $P10442
    nqp_get_sc_object $P10443, "1305640934.989", 457
    .const 'Sub' $P10444 = "551_1305640955.436" 
    assign $P10443, $P10444
    nqp_get_sc_object $P10445, "1305640934.989", 458
    .const 'Sub' $P10446 = "552_1305640955.436" 
    assign $P10445, $P10446
    nqp_get_sc_object $P10447, "1305640934.989", 459
    .const 'Sub' $P10448 = "553_1305640955.436" 
    assign $P10447, $P10448
    nqp_get_sc_object $P10449, "1305640934.989", 460
    .const 'Sub' $P10450 = "554_1305640955.436" 
    assign $P10449, $P10450
    nqp_get_sc_object $P10451, "1305640934.989", 461
    .const 'Sub' $P10452 = "556_1305640955.436" 
    assign $P10451, $P10452
    nqp_get_sc_object $P10453, "1305640934.989", 462
    .const 'Sub' $P10454 = "557_1305640955.436" 
    assign $P10453, $P10454
    nqp_get_sc_object $P10455, "1305640934.989", 463
    .const 'Sub' $P10456 = "562_1305640955.436" 
    assign $P10455, $P10456
    nqp_get_sc_object $P10457, "1305640934.989", 464
    .const 'Sub' $P10458 = "567_1305640955.436" 
    assign $P10457, $P10458
    nqp_get_sc_object $P10459, "1305640934.989", 465
    .const 'Sub' $P10460 = "568_1305640955.436" 
    assign $P10459, $P10460
    nqp_get_sc_object $P10461, "1305640934.989", 466
    .const 'Sub' $P10462 = "569_1305640955.436" 
    assign $P10461, $P10462
    nqp_get_sc_object $P10463, "1305640934.989", 467
    .const 'Sub' $P10464 = "570_1305640955.436" 
    assign $P10463, $P10464
    nqp_get_sc_object $P10465, "1305640934.989", 468
    .const 'Sub' $P10466 = "572_1305640955.436" 
    assign $P10465, $P10466
    nqp_get_sc_object $P10467, "1305640934.989", 469
    .const 'Sub' $P10468 = "573_1305640955.436" 
    assign $P10467, $P10468
    nqp_get_sc_object $P10469, "1305640934.989", 470
    .const 'Sub' $P10470 = "574_1305640955.436" 
    assign $P10469, $P10470
    nqp_get_sc_object $P10471, "1305640934.989", 471
    .const 'Sub' $P10472 = "575_1305640955.436" 
    assign $P10471, $P10472
    nqp_get_sc_object $P10473, "1305640934.989", 472
    .const 'Sub' $P10474 = "578_1305640955.436" 
    assign $P10473, $P10474
    nqp_get_sc_object $P10475, "1305640934.989", 473
    .const 'Sub' $P10476 = "579_1305640955.436" 
    assign $P10475, $P10476
    nqp_get_sc_object $P10477, "1305640934.989", 474
    .const 'Sub' $P10478 = "580_1305640955.436" 
    assign $P10477, $P10478
    nqp_get_sc_object $P10479, "1305640934.989", 475
    .const 'Sub' $P10480 = "581_1305640955.436" 
    assign $P10479, $P10480
    nqp_get_sc_object $P10481, "1305640934.989", 476
    .const 'Sub' $P10482 = "582_1305640955.436" 
    assign $P10481, $P10482
    nqp_get_sc_object $P10483, "1305640934.989", 477
    .const 'Sub' $P10484 = "583_1305640955.436" 
    assign $P10483, $P10484
    nqp_get_sc_object $P10485, "1305640934.989", 478
    .const 'Sub' $P10486 = "584_1305640955.436" 
    assign $P10485, $P10486
    nqp_get_sc_object $P10487, "1305640934.989", 479
    .const 'Sub' $P10488 = "586_1305640955.436" 
    assign $P10487, $P10488
    nqp_get_sc_object $P10489, "1305640934.989", 480
    .const 'Sub' $P10490 = "587_1305640955.436" 
    assign $P10489, $P10490
    nqp_get_sc_object $P10491, "1305640934.989", 481
    .const 'Sub' $P10492 = "588_1305640955.436" 
    assign $P10491, $P10492
    nqp_get_sc_object $P10493, "1305640934.989", 482
    .const 'Sub' $P10494 = "589_1305640955.436" 
    assign $P10493, $P10494
    nqp_get_sc_object $P10495, "1305640934.989", 483
    .const 'Sub' $P10496 = "590_1305640955.436" 
    assign $P10495, $P10496
    nqp_get_sc_object $P10497, "1305640934.989", 484
    .const 'Sub' $P10498 = "591_1305640955.436" 
    assign $P10497, $P10498
    nqp_get_sc_object $P10499, "1305640934.989", 485
    .const 'Sub' $P10500 = "592_1305640955.436" 
    assign $P10499, $P10500
    nqp_get_sc_object $P10501, "1305640934.989", 486
    .const 'Sub' $P10502 = "593_1305640955.436" 
    assign $P10501, $P10502
    nqp_get_sc_object $P10503, "1305640934.989", 487
    .const 'Sub' $P10504 = "594_1305640955.436" 
    assign $P10503, $P10504
    nqp_get_sc_object $P10505, "1305640934.989", 488
    .const 'Sub' $P10506 = "595_1305640955.436" 
    assign $P10505, $P10506
    nqp_get_sc_object $P10507, "1305640934.989", 489
    .const 'Sub' $P10508 = "596_1305640955.436" 
    assign $P10507, $P10508
    nqp_get_sc_object $P10509, "1305640934.989", 490
    .const 'Sub' $P10510 = "597_1305640955.436" 
    assign $P10509, $P10510
    nqp_get_sc_object $P10511, "1305640934.989", 491
    .const 'Sub' $P10512 = "598_1305640955.436" 
    assign $P10511, $P10512
    nqp_get_sc_object $P10513, "1305640934.989", 492
    .const 'Sub' $P10514 = "599_1305640955.436" 
    assign $P10513, $P10514
    nqp_get_sc_object $P10515, "1305640934.989", 493
    .const 'Sub' $P10516 = "600_1305640955.436" 
    assign $P10515, $P10516
    nqp_get_sc_object $P10517, "1305640934.989", 494
    .const 'Sub' $P10518 = "601_1305640955.436" 
    assign $P10517, $P10518
    nqp_get_sc_object $P10519, "1305640934.989", 495
    .const 'Sub' $P10520 = "602_1305640955.436" 
    assign $P10519, $P10520
    nqp_get_sc_object $P10521, "1305640934.989", 496
    .const 'Sub' $P10522 = "603_1305640955.436" 
    assign $P10521, $P10522
    nqp_get_sc_object $P10523, "1305640934.989", 497
    .const 'Sub' $P10524 = "604_1305640955.436" 
    assign $P10523, $P10524
    nqp_get_sc_object $P10525, "1305640934.989", 498
    .const 'Sub' $P10526 = "605_1305640955.436" 
    assign $P10525, $P10526
    nqp_get_sc_object $P10527, "1305640934.989", 499
    .const 'Sub' $P10528 = "606_1305640955.436" 
    assign $P10527, $P10528
    nqp_get_sc_object $P10529, "1305640934.989", 500
    .const 'Sub' $P10530 = "607_1305640955.436" 
    assign $P10529, $P10530
    nqp_get_sc_object $P10531, "1305640934.989", 501
    .const 'Sub' $P10532 = "608_1305640955.436" 
    assign $P10531, $P10532
    nqp_get_sc_object $P10533, "1305640934.989", 502
    .const 'Sub' $P10534 = "609_1305640955.436" 
    assign $P10533, $P10534
    nqp_get_sc_object $P10535, "1305640934.989", 503
    .const 'Sub' $P10536 = "610_1305640955.436" 
    assign $P10535, $P10536
    nqp_get_sc_object $P10537, "1305640934.989", 504
    .const 'Sub' $P10538 = "611_1305640955.436" 
    assign $P10537, $P10538
    nqp_get_sc_object $P10539, "1305640934.989", 505
    .const 'Sub' $P10540 = "612_1305640955.436" 
    assign $P10539, $P10540
    .const 'Sub' $P10541 = "435_1305640955.436" 
    $P10542 = $P10541."get_lexinfo"()
    nqp_get_sc_object $P10543, "1305640934.989", 394
    $P10542."set_static_lexpad_value"("$?PACKAGE", $P10543)
    .const 'Sub' $P10544 = "435_1305640955.436" 
    $P10545 = $P10544."get_lexinfo"()
    $P10545."finish_static_lexpad"()
    .const 'Sub' $P10546 = "435_1305640955.436" 
    $P10547 = $P10546."get_lexinfo"()
    nqp_get_sc_object $P10548, "1305640934.989", 394
    $P10547."set_static_lexpad_value"("$?CLASS", $P10548)
    .const 'Sub' $P10549 = "435_1305640955.436" 
    $P10550 = $P10549."get_lexinfo"()
    $P10550."finish_static_lexpad"()
    nqp_get_sc_object $P10551, "1305640934.989", 507
    .const 'Sub' $P10552 = "615_1305640955.436" 
    assign $P10551, $P10552
    nqp_get_sc_object $P10553, "1305640934.989", 508
    .const 'Sub' $P10554 = "616_1305640955.436" 
    assign $P10553, $P10554
    nqp_get_sc_object $P10555, "1305640934.989", 509
    .const 'Sub' $P10556 = "617_1305640955.436" 
    assign $P10555, $P10556
    nqp_get_sc_object $P10557, "1305640934.989", 510
    .const 'Sub' $P10558 = "618_1305640955.436" 
    assign $P10557, $P10558
    nqp_get_sc_object $P10559, "1305640934.989", 511
    .const 'Sub' $P10560 = "619_1305640955.436" 
    assign $P10559, $P10560
    nqp_get_sc_object $P10561, "1305640934.989", 512
    .const 'Sub' $P10562 = "620_1305640955.436" 
    assign $P10561, $P10562
    nqp_get_sc_object $P10563, "1305640934.989", 513
    .const 'Sub' $P10564 = "621_1305640955.436" 
    assign $P10563, $P10564
    .const 'Sub' $P10565 = "614_1305640955.436" 
    $P10566 = $P10565."get_lexinfo"()
    nqp_get_sc_object $P10567, "1305640934.989", 506
    $P10566."set_static_lexpad_value"("$?PACKAGE", $P10567)
    .const 'Sub' $P10568 = "614_1305640955.436" 
    $P10569 = $P10568."get_lexinfo"()
    $P10569."finish_static_lexpad"()
    .const 'Sub' $P10570 = "614_1305640955.436" 
    $P10571 = $P10570."get_lexinfo"()
    nqp_get_sc_object $P10572, "1305640934.989", 506
    $P10571."set_static_lexpad_value"("$?CLASS", $P10572)
    .const 'Sub' $P10573 = "614_1305640955.436" 
    $P10574 = $P10573."get_lexinfo"()
    $P10574."finish_static_lexpad"()
    .const 'Sub' $P10575 = "622_1305640955.436" 
    $P10576 = $P10575."get_lexinfo"()
    nqp_get_sc_object $P10577, "1305640934.989", 514
    $P10576."set_static_lexpad_value"("$?PACKAGE", $P10577)
    .const 'Sub' $P10578 = "622_1305640955.436" 
    $P10579 = $P10578."get_lexinfo"()
    $P10579."finish_static_lexpad"()
    .const 'Sub' $P10580 = "622_1305640955.436" 
    $P10581 = $P10580."get_lexinfo"()
    nqp_get_sc_object $P10582, "1305640934.989", 514
    $P10581."set_static_lexpad_value"("$?CLASS", $P10582)
    .const 'Sub' $P10583 = "622_1305640955.436" 
    $P10584 = $P10583."get_lexinfo"()
    $P10584."finish_static_lexpad"()
    goto if_7304_end
  if_7304:
    nqp_dynop_setup 
    getinterp $P7307
    get_class $P7308, "LexPad"
    get_class $P7309, "NQPLexPad"
    $P7307."hll_map"($P7308, $P7309)
    nqp_create_sc $P7310, "1305640934.989"
    .local pmc cur_sc
    set cur_sc, $P7310
    nqp_get_sc_object $P7311, "__6MODEL_CORE__", 0
    $P7312 = $P7311."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7312, cur_sc
    nqp_set_sc_object "1305640934.989", 0, $P7312
    .const 'Sub' $P7313 = "10_1305640955.436" 
    $P7314 = $P7313."get_lexinfo"()
    nqp_get_sc_object $P7315, "1305640934.989", 0
    $P7314."set_static_lexpad_value"("GLOBALish", $P7315)
    .const 'Sub' $P7316 = "10_1305640955.436" 
    $P7317 = $P7316."get_lexinfo"()
    $P7317."finish_static_lexpad"()
    .const 'Sub' $P7318 = "10_1305640955.436" 
    $P7319 = $P7318."get_lexinfo"()
    nqp_get_sc_object $P7320, "1305640934.989", 0
    $P7319."set_static_lexpad_value"("$?PACKAGE", $P7320)
    .const 'Sub' $P7321 = "10_1305640955.436" 
    $P7322 = $P7321."get_lexinfo"()
    $P7322."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7323, "ModuleLoader"
    $P7324 = $P7323."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7324)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7325, "ModuleLoader"
    nqp_get_sc_object $P7326, "1305640934.989", 0
    $P7325."load_module"("NQPRegex", $P7326)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7327, "ModuleLoader"
    nqp_get_sc_object $P7328, "1305640934.989", 0
    $P7327."load_module"("NQPP6Regex", $P7328)
    nqp_get_sc_object $P7329, "1305640898.961", 41
    $P7330 = $P7329."new_type"("NQP::SymbolTable" :named("name"))
    nqp_set_sc_for_object $P7330, cur_sc
    nqp_set_sc_object "1305640934.989", 1, $P7330
    nqp_get_sc_object $P7331, "1305640934.989", 1
    nqp_get_sc_object $P7332, "1305640934.989", 0
    nqp_get_package_through_who $P7333, $P7332, "NQP"
    get_who $P7334, $P7333
    set $P7334["SymbolTable"], $P7331
    nqp_get_sc_object $P7335, "1305640934.989", 1
    get_how $P7336, $P7335
    nqp_get_sc_object $P7337, "1305640934.989", 1
    .const 'Sub' $P7338 = "13_1305640955.436" 
    $P7336."add_method"($P7337, "load_setting", $P7338)
    nqp_get_sc_object $P7339, "1305640934.989", 1
    get_how $P7340, $P7339
    nqp_get_sc_object $P7341, "1305640934.989", 1
    .const 'Sub' $P7342 = "15_1305640955.436" 
    $P7340."add_method"($P7341, "load_module", $P7342)
    nqp_get_sc_object $P7343, "1305640934.989", 1
    get_how $P7344, $P7343
    nqp_get_sc_object $P7345, "1305640934.989", 1
    .const 'Sub' $P7346 = "16_1305640955.436" 
    $P7344."add_method"($P7345, "install_package_symbol", $P7346)
    nqp_get_sc_object $P7347, "1305640934.989", 1
    get_how $P7348, $P7347
    nqp_get_sc_object $P7349, "1305640934.989", 1
    .const 'Sub' $P7350 = "19_1305640955.436" 
    $P7348."add_method"($P7349, "install_lexical_symbol", $P7350)
    nqp_get_sc_object $P7351, "1305640934.989", 1
    get_how $P7352, $P7351
    nqp_get_sc_object $P7353, "1305640934.989", 1
    .const 'Sub' $P7354 = "20_1305640955.436" 
    $P7352."add_method"($P7353, "install_package_routine", $P7354)
    nqp_get_sc_object $P7355, "1305640934.989", 1
    get_how $P7356, $P7355
    nqp_get_sc_object $P7357, "1305640934.989", 1
    .const 'Sub' $P7358 = "21_1305640955.436" 
    $P7356."add_method"($P7357, "pkg_create_mo", $P7358)
    nqp_get_sc_object $P7359, "1305640934.989", 1
    get_how $P7360, $P7359
    nqp_get_sc_object $P7361, "1305640934.989", 1
    .const 'Sub' $P7362 = "22_1305640955.436" 
    $P7360."add_method"($P7361, "pkg_add_attribute", $P7362)
    nqp_get_sc_object $P7363, "1305640934.989", 1
    get_how $P7364, $P7363
    nqp_get_sc_object $P7365, "1305640934.989", 1
    .const 'Sub' $P7366 = "25_1305640955.436" 
    $P7364."add_method"($P7365, "pkg_add_method", $P7366)
    nqp_get_sc_object $P7367, "1305640934.989", 1
    get_how $P7368, $P7367
    nqp_get_sc_object $P7369, "1305640934.989", 1
    .const 'Sub' $P7370 = "28_1305640955.436" 
    $P7368."add_method"($P7369, "set_routine_signature", $P7370)
    nqp_get_sc_object $P7371, "1305640934.989", 1
    get_how $P7372, $P7371
    nqp_get_sc_object $P7373, "1305640934.989", 1
    .const 'Sub' $P7374 = "29_1305640955.436" 
    $P7372."add_method"($P7373, "pkg_set_body_block", $P7374)
    nqp_get_sc_object $P7375, "1305640934.989", 1
    get_how $P7376, $P7375
    nqp_get_sc_object $P7377, "1305640934.989", 1
    .const 'Sub' $P7378 = "34_1305640955.436" 
    $P7376."add_method"($P7377, "pkg_add_parent_or_role", $P7378)
    nqp_get_sc_object $P7379, "1305640934.989", 1
    get_how $P7380, $P7379
    nqp_get_sc_object $P7381, "1305640934.989", 1
    .const 'Sub' $P7382 = "35_1305640955.436" 
    $P7380."add_method"($P7381, "pkg_add_parrot_vtable_handler_mapping", $P7382)
    nqp_get_sc_object $P7383, "1305640934.989", 1
    get_how $P7384, $P7383
    nqp_get_sc_object $P7385, "1305640934.989", 1
    .const 'Sub' $P7386 = "36_1305640955.436" 
    $P7384."add_method"($P7385, "pkg_compose", $P7386)
    nqp_get_sc_object $P7387, "1305640934.989", 1
    get_how $P7388, $P7387
    nqp_get_sc_object $P7389, "1305640934.989", 1
    .const 'Sub' $P7390 = "37_1305640955.436" 
    $P7388."add_method"($P7389, "to_past", $P7390)
    .const 'Sub' $P7391 = "12_1305640955.436" 
    $P7392 = $P7391."get_lexinfo"()
    nqp_get_sc_object $P7393, "1305640934.989", 1
    $P7392."set_static_lexpad_value"("$?PACKAGE", $P7393)
    .const 'Sub' $P7394 = "12_1305640955.436" 
    $P7395 = $P7394."get_lexinfo"()
    $P7395."finish_static_lexpad"()
    .const 'Sub' $P7396 = "12_1305640955.436" 
    $P7397 = $P7396."get_lexinfo"()
    nqp_get_sc_object $P7398, "1305640934.989", 1
    $P7397."set_static_lexpad_value"("$?CLASS", $P7398)
    .const 'Sub' $P7399 = "12_1305640955.436" 
    $P7400 = $P7399."get_lexinfo"()
    $P7400."finish_static_lexpad"()
    nqp_get_sc_object $P7401, "1305640934.989", 1
    get_how $P7402, $P7401
    nqp_get_sc_object $P7403, "1305640934.989", 1
    nqp_get_sc_object $P7404, "1305640910.362", 191
    $P7402."add_parent"($P7403, $P7404)
    nqp_get_sc_object $P7405, "1305640934.989", 1
    get_how $P7406, $P7405
    nqp_get_sc_object $P7407, "1305640934.989", 1
    $P7406."compose"($P7407)
    nqp_get_sc_object $P7408, "1305640898.961", 41
    $P7409 = $P7408."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7409, cur_sc
    nqp_set_sc_object "1305640934.989", 16, $P7409
    nqp_get_sc_object $P7410, "1305640934.989", 16
    nqp_get_sc_object $P7411, "1305640934.989", 0
    nqp_get_package_through_who $P7412, $P7411, "NQP"
    get_who $P7413, $P7412
    set $P7413["Grammar"], $P7410
    nqp_get_sc_object $P7414, "1305640934.989", 16
    get_how $P7415, $P7414
    nqp_get_sc_object $P7416, "1305640934.989", 16
    .const 'Sub' $P7417 = "40_1305640955.436" 
    $P7415."add_method"($P7416, "TOP", $P7417)
    nqp_get_sc_object $P7418, "1305640934.989", 16
    get_how $P7419, $P7418
    nqp_get_sc_object $P7420, "1305640934.989", 16
    .const 'Sub' $P7421 = "41_1305640955.436" 
    $P7419."add_method"($P7420, "identifier", $P7421)
    nqp_get_sc_object $P7422, "1305640934.989", 16
    get_how $P7423, $P7422
    nqp_get_sc_object $P7424, "1305640934.989", 16
    .const 'Sub' $P7425 = "42_1305640955.436" 
    $P7423."add_method"($P7424, "!PREFIX__identifier", $P7425)
    nqp_get_sc_object $P7426, "1305640934.989", 16
    get_how $P7427, $P7426
    nqp_get_sc_object $P7428, "1305640934.989", 16
    .const 'Sub' $P7429 = "43_1305640955.436" 
    $P7427."add_method"($P7428, "name", $P7429)
    nqp_get_sc_object $P7430, "1305640934.989", 16
    get_how $P7431, $P7430
    nqp_get_sc_object $P7432, "1305640934.989", 16
    .const 'Sub' $P7433 = "44_1305640955.436" 
    $P7431."add_method"($P7432, "!PREFIX__name", $P7433)
    nqp_get_sc_object $P7434, "1305640934.989", 16
    get_how $P7435, $P7434
    nqp_get_sc_object $P7436, "1305640934.989", 16
    .const 'Sub' $P7437 = "45_1305640955.436" 
    $P7435."add_method"($P7436, "deflongname", $P7437)
    nqp_get_sc_object $P7438, "1305640934.989", 16
    get_how $P7439, $P7438
    nqp_get_sc_object $P7440, "1305640934.989", 16
    .const 'Sub' $P7441 = "46_1305640955.436" 
    $P7439."add_method"($P7440, "!PREFIX__deflongname", $P7441)
    nqp_get_sc_object $P7442, "1305640934.989", 16
    get_how $P7443, $P7442
    nqp_get_sc_object $P7444, "1305640934.989", 16
    .const 'Sub' $P7445 = "47_1305640955.436" 
    $P7443."add_method"($P7444, "ENDSTMT", $P7445)
    nqp_get_sc_object $P7446, "1305640934.989", 16
    get_how $P7447, $P7446
    nqp_get_sc_object $P7448, "1305640934.989", 16
    .const 'Sub' $P7449 = "48_1305640955.436" 
    $P7447."add_method"($P7448, "!PREFIX__ENDSTMT", $P7449)
    nqp_get_sc_object $P7450, "1305640934.989", 16
    get_how $P7451, $P7450
    nqp_get_sc_object $P7452, "1305640934.989", 16
    .const 'Sub' $P7453 = "49_1305640955.436" 
    $P7451."add_method"($P7452, "ws", $P7453)
    nqp_get_sc_object $P7454, "1305640934.989", 16
    get_how $P7455, $P7454
    nqp_get_sc_object $P7456, "1305640934.989", 16
    .const 'Sub' $P7457 = "50_1305640955.436" 
    $P7455."add_method"($P7456, "!PREFIX__ws", $P7457)
    nqp_get_sc_object $P7458, "1305640934.989", 16
    get_how $P7459, $P7458
    nqp_get_sc_object $P7460, "1305640934.989", 16
    .const 'Sub' $P7461 = "51_1305640955.436" 
    $P7459."add_method"($P7460, "unv", $P7461)
    nqp_get_sc_object $P7462, "1305640934.989", 16
    get_how $P7463, $P7462
    nqp_get_sc_object $P7464, "1305640934.989", 16
    .const 'Sub' $P7465 = "53_1305640955.436" 
    $P7463."add_method"($P7464, "!PREFIX__unv", $P7465)
    nqp_get_sc_object $P7466, "1305640934.989", 16
    get_how $P7467, $P7466
    nqp_get_sc_object $P7468, "1305640934.989", 16
    .const 'Sub' $P7469 = "54_1305640955.436" 
    $P7467."add_method"($P7468, "pod_comment", $P7469)
    nqp_get_sc_object $P7470, "1305640934.989", 16
    get_how $P7471, $P7470
    nqp_get_sc_object $P7472, "1305640934.989", 16
    .const 'Sub' $P7473 = "56_1305640955.436" 
    $P7471."add_method"($P7472, "!PREFIX__pod_comment", $P7473)
    nqp_get_sc_object $P7474, "1305640934.989", 16
    get_how $P7475, $P7474
    nqp_get_sc_object $P7476, "1305640934.989", 16
    .const 'Sub' $P7477 = "57_1305640955.436" 
    $P7475."add_method"($P7476, "comp_unit", $P7477)
    nqp_get_sc_object $P7478, "1305640934.989", 16
    get_how $P7479, $P7478
    nqp_get_sc_object $P7480, "1305640934.989", 16
    .const 'Sub' $P7481 = "58_1305640955.436" 
    $P7479."add_method"($P7480, "!PREFIX__comp_unit", $P7481)
    nqp_get_sc_object $P7482, "1305640934.989", 16
    get_how $P7483, $P7482
    nqp_get_sc_object $P7484, "1305640934.989", 16
    .const 'Sub' $P7485 = "59_1305640955.436" 
    $P7483."add_method"($P7484, "statementlist", $P7485)
    nqp_get_sc_object $P7486, "1305640934.989", 16
    get_how $P7487, $P7486
    nqp_get_sc_object $P7488, "1305640934.989", 16
    .const 'Sub' $P7489 = "60_1305640955.436" 
    $P7487."add_method"($P7488, "!PREFIX__statementlist", $P7489)
    nqp_get_sc_object $P7490, "1305640934.989", 16
    get_how $P7491, $P7490
    nqp_get_sc_object $P7492, "1305640934.989", 16
    .const 'Sub' $P7493 = "61_1305640955.436" 
    $P7491."add_method"($P7492, "statement", $P7493)
    nqp_get_sc_object $P7494, "1305640934.989", 16
    get_how $P7495, $P7494
    nqp_get_sc_object $P7496, "1305640934.989", 16
    .const 'Sub' $P7497 = "63_1305640955.436" 
    $P7495."add_method"($P7496, "!PREFIX__statement", $P7497)
    nqp_get_sc_object $P7498, "1305640934.989", 16
    get_how $P7499, $P7498
    nqp_get_sc_object $P7500, "1305640934.989", 16
    .const 'Sub' $P7501 = "64_1305640955.436" 
    $P7499."add_method"($P7500, "eat_terminator", $P7501)
    nqp_get_sc_object $P7502, "1305640934.989", 16
    get_how $P7503, $P7502
    nqp_get_sc_object $P7504, "1305640934.989", 16
    .const 'Sub' $P7505 = "65_1305640955.436" 
    $P7503."add_method"($P7504, "!PREFIX__eat_terminator", $P7505)
    nqp_get_sc_object $P7506, "1305640934.989", 16
    get_how $P7507, $P7506
    nqp_get_sc_object $P7508, "1305640934.989", 16
    .const 'Sub' $P7509 = "66_1305640955.436" 
    $P7507."add_method"($P7508, "xblock", $P7509)
    nqp_get_sc_object $P7510, "1305640934.989", 16
    get_how $P7511, $P7510
    nqp_get_sc_object $P7512, "1305640934.989", 16
    .const 'Sub' $P7513 = "67_1305640955.436" 
    $P7511."add_method"($P7512, "!PREFIX__xblock", $P7513)
    nqp_get_sc_object $P7514, "1305640934.989", 16
    get_how $P7515, $P7514
    nqp_get_sc_object $P7516, "1305640934.989", 16
    .const 'Sub' $P7517 = "68_1305640955.436" 
    $P7515."add_method"($P7516, "pblock", $P7517)
    nqp_get_sc_object $P7518, "1305640934.989", 16
    get_how $P7519, $P7518
    nqp_get_sc_object $P7520, "1305640934.989", 16
    .const 'Sub' $P7521 = "69_1305640955.436" 
    $P7519."add_method"($P7520, "!PREFIX__pblock", $P7521)
    nqp_get_sc_object $P7522, "1305640934.989", 16
    get_how $P7523, $P7522
    nqp_get_sc_object $P7524, "1305640934.989", 16
    .const 'Sub' $P7525 = "70_1305640955.436" 
    $P7523."add_method"($P7524, "lambda", $P7525)
    nqp_get_sc_object $P7526, "1305640934.989", 16
    get_how $P7527, $P7526
    nqp_get_sc_object $P7528, "1305640934.989", 16
    .const 'Sub' $P7529 = "71_1305640955.436" 
    $P7527."add_method"($P7528, "!PREFIX__lambda", $P7529)
    nqp_get_sc_object $P7530, "1305640934.989", 16
    get_how $P7531, $P7530
    nqp_get_sc_object $P7532, "1305640934.989", 16
    .const 'Sub' $P7533 = "72_1305640955.436" 
    $P7531."add_method"($P7532, "block", $P7533)
    nqp_get_sc_object $P7534, "1305640934.989", 16
    get_how $P7535, $P7534
    nqp_get_sc_object $P7536, "1305640934.989", 16
    .const 'Sub' $P7537 = "73_1305640955.436" 
    $P7535."add_method"($P7536, "!PREFIX__block", $P7537)
    nqp_get_sc_object $P7538, "1305640934.989", 16
    get_how $P7539, $P7538
    nqp_get_sc_object $P7540, "1305640934.989", 16
    .const 'Sub' $P7541 = "74_1305640955.436" 
    $P7539."add_method"($P7540, "blockoid", $P7541)
    nqp_get_sc_object $P7542, "1305640934.989", 16
    get_how $P7543, $P7542
    nqp_get_sc_object $P7544, "1305640934.989", 16
    .const 'Sub' $P7545 = "75_1305640955.436" 
    $P7543."add_method"($P7544, "!PREFIX__blockoid", $P7545)
    nqp_get_sc_object $P7546, "1305640934.989", 16
    get_how $P7547, $P7546
    nqp_get_sc_object $P7548, "1305640934.989", 16
    .const 'Sub' $P7549 = "76_1305640955.436" 
    $P7547."add_method"($P7548, "newpad", $P7549)
    nqp_get_sc_object $P7550, "1305640934.989", 16
    get_how $P7551, $P7550
    nqp_get_sc_object $P7552, "1305640934.989", 16
    .const 'Sub' $P7553 = "77_1305640955.436" 
    $P7551."add_method"($P7552, "!PREFIX__newpad", $P7553)
    nqp_get_sc_object $P7554, "1305640934.989", 16
    get_how $P7555, $P7554
    nqp_get_sc_object $P7556, "1305640934.989", 16
    .const 'Sub' $P7557 = "78_1305640955.436" 
    $P7555."add_method"($P7556, "outerctx", $P7557)
    nqp_get_sc_object $P7558, "1305640934.989", 16
    get_how $P7559, $P7558
    nqp_get_sc_object $P7560, "1305640934.989", 16
    .const 'Sub' $P7561 = "79_1305640955.436" 
    $P7559."add_method"($P7560, "!PREFIX__outerctx", $P7561)
    nqp_get_sc_object $P7562, "1305640934.989", 16
    get_how $P7563, $P7562
    nqp_get_sc_object $P7564, "1305640934.989", 16
    .const 'Sub' $P7565 = "80_1305640955.436" 
    $P7563."add_method"($P7564, "GLOBALish", $P7565)
    nqp_get_sc_object $P7566, "1305640934.989", 16
    get_how $P7567, $P7566
    nqp_get_sc_object $P7568, "1305640934.989", 16
    .const 'Sub' $P7569 = "81_1305640955.436" 
    $P7567."add_method"($P7568, "!PREFIX__GLOBALish", $P7569)
    nqp_get_sc_object $P7570, "1305640934.989", 16
    get_how $P7571, $P7570
    nqp_get_sc_object $P7572, "1305640934.989", 16
    .const 'Sub' $P7573 = "82_1305640955.436" 
    $P7571."add_method"($P7572, "finishpad", $P7573)
    nqp_get_sc_object $P7574, "1305640934.989", 16
    get_how $P7575, $P7574
    nqp_get_sc_object $P7576, "1305640934.989", 16
    .const 'Sub' $P7577 = "83_1305640955.436" 
    $P7575."add_method"($P7576, "!PREFIX__finishpad", $P7577)
    nqp_get_sc_object $P7578, "1305640934.989", 16
    get_how $P7579, $P7578
    nqp_get_sc_object $P7580, "1305640934.989", 16
    .const 'Sub' $P7581 = "84_1305640955.436" 
    $P7579."add_method"($P7580, "you_are_here", $P7581)
    nqp_get_sc_object $P7582, "1305640934.989", 16
    get_how $P7583, $P7582
    nqp_get_sc_object $P7584, "1305640934.989", 16
    .const 'Sub' $P7585 = "85_1305640955.436" 
    $P7583."add_method"($P7584, "!PREFIX__you_are_here", $P7585)
    nqp_get_sc_object $P7586, "1305640934.989", 16
    get_how $P7587, $P7586
    nqp_get_sc_object $P7588, "1305640934.989", 16
    .const 'Sub' $P7589 = "86_1305640955.436" 
    $P7587."add_method"($P7588, "terminator", $P7589)
    nqp_get_sc_object $P7590, "1305640934.989", 16
    get_how $P7591, $P7590
    nqp_get_sc_object $P7592, "1305640934.989", 16
    .const 'Sub' $P7593 = "87_1305640955.436" 
    $P7591."add_method"($P7592, "!PREFIX__terminator", $P7593)
    nqp_get_sc_object $P7594, "1305640934.989", 16
    get_how $P7595, $P7594
    nqp_get_sc_object $P7596, "1305640934.989", 16
    .const 'Sub' $P7597 = "88_1305640955.436" 
    $P7595."add_method"($P7596, "terminator:sym<;>", $P7597)
    nqp_get_sc_object $P7598, "1305640934.989", 16
    get_how $P7599, $P7598
    nqp_get_sc_object $P7600, "1305640934.989", 16
    .const 'Sub' $P7601 = "89_1305640955.436" 
    $P7599."add_method"($P7600, "!PREFIX__terminator:sym<;>", $P7601)
    nqp_get_sc_object $P7602, "1305640934.989", 16
    get_how $P7603, $P7602
    nqp_get_sc_object $P7604, "1305640934.989", 16
    .const 'Sub' $P7605 = "90_1305640955.436" 
    $P7603."add_method"($P7604, "terminator:sym<}>", $P7605)
    nqp_get_sc_object $P7606, "1305640934.989", 16
    get_how $P7607, $P7606
    nqp_get_sc_object $P7608, "1305640934.989", 16
    .const 'Sub' $P7609 = "91_1305640955.436" 
    $P7607."add_method"($P7608, "!PREFIX__terminator:sym<}>", $P7609)
    nqp_get_sc_object $P7610, "1305640934.989", 16
    get_how $P7611, $P7610
    nqp_get_sc_object $P7612, "1305640934.989", 16
    .const 'Sub' $P7613 = "92_1305640955.436" 
    $P7611."add_method"($P7612, "statement_control", $P7613)
    nqp_get_sc_object $P7614, "1305640934.989", 16
    get_how $P7615, $P7614
    nqp_get_sc_object $P7616, "1305640934.989", 16
    .const 'Sub' $P7617 = "93_1305640955.436" 
    $P7615."add_method"($P7616, "!PREFIX__statement_control", $P7617)
    nqp_get_sc_object $P7618, "1305640934.989", 16
    get_how $P7619, $P7618
    nqp_get_sc_object $P7620, "1305640934.989", 16
    .const 'Sub' $P7621 = "94_1305640955.436" 
    $P7619."add_method"($P7620, "statement_control:sym<use>", $P7621)
    nqp_get_sc_object $P7622, "1305640934.989", 16
    get_how $P7623, $P7622
    nqp_get_sc_object $P7624, "1305640934.989", 16
    .const 'Sub' $P7625 = "95_1305640955.436" 
    $P7623."add_method"($P7624, "!PREFIX__statement_control:sym<use>", $P7625)
    nqp_get_sc_object $P7626, "1305640934.989", 16
    get_how $P7627, $P7626
    nqp_get_sc_object $P7628, "1305640934.989", 16
    .const 'Sub' $P7629 = "96_1305640955.436" 
    $P7627."add_method"($P7628, "statement_control:sym<if>", $P7629)
    nqp_get_sc_object $P7630, "1305640934.989", 16
    get_how $P7631, $P7630
    nqp_get_sc_object $P7632, "1305640934.989", 16
    .const 'Sub' $P7633 = "97_1305640955.436" 
    $P7631."add_method"($P7632, "!PREFIX__statement_control:sym<if>", $P7633)
    nqp_get_sc_object $P7634, "1305640934.989", 16
    get_how $P7635, $P7634
    nqp_get_sc_object $P7636, "1305640934.989", 16
    .const 'Sub' $P7637 = "98_1305640955.436" 
    $P7635."add_method"($P7636, "statement_control:sym<unless>", $P7637)
    nqp_get_sc_object $P7638, "1305640934.989", 16
    get_how $P7639, $P7638
    nqp_get_sc_object $P7640, "1305640934.989", 16
    .const 'Sub' $P7641 = "100_1305640955.436" 
    $P7639."add_method"($P7640, "!PREFIX__statement_control:sym<unless>", $P7641)
    nqp_get_sc_object $P7642, "1305640934.989", 16
    get_how $P7643, $P7642
    nqp_get_sc_object $P7644, "1305640934.989", 16
    .const 'Sub' $P7645 = "101_1305640955.436" 
    $P7643."add_method"($P7644, "statement_control:sym<while>", $P7645)
    nqp_get_sc_object $P7646, "1305640934.989", 16
    get_how $P7647, $P7646
    nqp_get_sc_object $P7648, "1305640934.989", 16
    .const 'Sub' $P7649 = "102_1305640955.436" 
    $P7647."add_method"($P7648, "!PREFIX__statement_control:sym<while>", $P7649)
    nqp_get_sc_object $P7650, "1305640934.989", 16
    get_how $P7651, $P7650
    nqp_get_sc_object $P7652, "1305640934.989", 16
    .const 'Sub' $P7653 = "103_1305640955.436" 
    $P7651."add_method"($P7652, "statement_control:sym<repeat>", $P7653)
    nqp_get_sc_object $P7654, "1305640934.989", 16
    get_how $P7655, $P7654
    nqp_get_sc_object $P7656, "1305640934.989", 16
    .const 'Sub' $P7657 = "104_1305640955.436" 
    $P7655."add_method"($P7656, "!PREFIX__statement_control:sym<repeat>", $P7657)
    nqp_get_sc_object $P7658, "1305640934.989", 16
    get_how $P7659, $P7658
    nqp_get_sc_object $P7660, "1305640934.989", 16
    .const 'Sub' $P7661 = "105_1305640955.436" 
    $P7659."add_method"($P7660, "statement_control:sym<for>", $P7661)
    nqp_get_sc_object $P7662, "1305640934.989", 16
    get_how $P7663, $P7662
    nqp_get_sc_object $P7664, "1305640934.989", 16
    .const 'Sub' $P7665 = "106_1305640955.436" 
    $P7663."add_method"($P7664, "!PREFIX__statement_control:sym<for>", $P7665)
    nqp_get_sc_object $P7666, "1305640934.989", 16
    get_how $P7667, $P7666
    nqp_get_sc_object $P7668, "1305640934.989", 16
    .const 'Sub' $P7669 = "107_1305640955.436" 
    $P7667."add_method"($P7668, "statement_control:sym<CATCH>", $P7669)
    nqp_get_sc_object $P7670, "1305640934.989", 16
    get_how $P7671, $P7670
    nqp_get_sc_object $P7672, "1305640934.989", 16
    .const 'Sub' $P7673 = "108_1305640955.436" 
    $P7671."add_method"($P7672, "!PREFIX__statement_control:sym<CATCH>", $P7673)
    nqp_get_sc_object $P7674, "1305640934.989", 16
    get_how $P7675, $P7674
    nqp_get_sc_object $P7676, "1305640934.989", 16
    .const 'Sub' $P7677 = "109_1305640955.436" 
    $P7675."add_method"($P7676, "statement_control:sym<CONTROL>", $P7677)
    nqp_get_sc_object $P7678, "1305640934.989", 16
    get_how $P7679, $P7678
    nqp_get_sc_object $P7680, "1305640934.989", 16
    .const 'Sub' $P7681 = "110_1305640955.436" 
    $P7679."add_method"($P7680, "!PREFIX__statement_control:sym<CONTROL>", $P7681)
    nqp_get_sc_object $P7682, "1305640934.989", 16
    get_how $P7683, $P7682
    nqp_get_sc_object $P7684, "1305640934.989", 16
    .const 'Sub' $P7685 = "111_1305640955.436" 
    $P7683."add_method"($P7684, "statement_prefix", $P7685)
    nqp_get_sc_object $P7686, "1305640934.989", 16
    get_how $P7687, $P7686
    nqp_get_sc_object $P7688, "1305640934.989", 16
    .const 'Sub' $P7689 = "112_1305640955.436" 
    $P7687."add_method"($P7688, "!PREFIX__statement_prefix", $P7689)
    nqp_get_sc_object $P7690, "1305640934.989", 16
    get_how $P7691, $P7690
    nqp_get_sc_object $P7692, "1305640934.989", 16
    .const 'Sub' $P7693 = "113_1305640955.436" 
    $P7691."add_method"($P7692, "statement_prefix:sym<INIT>", $P7693)
    nqp_get_sc_object $P7694, "1305640934.989", 16
    get_how $P7695, $P7694
    nqp_get_sc_object $P7696, "1305640934.989", 16
    .const 'Sub' $P7697 = "114_1305640955.436" 
    $P7695."add_method"($P7696, "!PREFIX__statement_prefix:sym<INIT>", $P7697)
    nqp_get_sc_object $P7698, "1305640934.989", 16
    get_how $P7699, $P7698
    nqp_get_sc_object $P7700, "1305640934.989", 16
    .const 'Sub' $P7701 = "115_1305640955.436" 
    $P7699."add_method"($P7700, "statement_prefix:sym<try>", $P7701)
    nqp_get_sc_object $P7702, "1305640934.989", 16
    get_how $P7703, $P7702
    nqp_get_sc_object $P7704, "1305640934.989", 16
    .const 'Sub' $P7705 = "116_1305640955.436" 
    $P7703."add_method"($P7704, "!PREFIX__statement_prefix:sym<try>", $P7705)
    nqp_get_sc_object $P7706, "1305640934.989", 16
    get_how $P7707, $P7706
    nqp_get_sc_object $P7708, "1305640934.989", 16
    .const 'Sub' $P7709 = "117_1305640955.436" 
    $P7707."add_method"($P7708, "blorst", $P7709)
    nqp_get_sc_object $P7710, "1305640934.989", 16
    get_how $P7711, $P7710
    nqp_get_sc_object $P7712, "1305640934.989", 16
    .const 'Sub' $P7713 = "118_1305640955.436" 
    $P7711."add_method"($P7712, "!PREFIX__blorst", $P7713)
    nqp_get_sc_object $P7714, "1305640934.989", 16
    get_how $P7715, $P7714
    nqp_get_sc_object $P7716, "1305640934.989", 16
    .const 'Sub' $P7717 = "119_1305640955.436" 
    $P7715."add_method"($P7716, "statement_mod_cond", $P7717)
    nqp_get_sc_object $P7718, "1305640934.989", 16
    get_how $P7719, $P7718
    nqp_get_sc_object $P7720, "1305640934.989", 16
    .const 'Sub' $P7721 = "120_1305640955.436" 
    $P7719."add_method"($P7720, "!PREFIX__statement_mod_cond", $P7721)
    nqp_get_sc_object $P7722, "1305640934.989", 16
    get_how $P7723, $P7722
    nqp_get_sc_object $P7724, "1305640934.989", 16
    .const 'Sub' $P7725 = "121_1305640955.436" 
    $P7723."add_method"($P7724, "statement_mod_cond:sym<if>", $P7725)
    nqp_get_sc_object $P7726, "1305640934.989", 16
    get_how $P7727, $P7726
    nqp_get_sc_object $P7728, "1305640934.989", 16
    .const 'Sub' $P7729 = "122_1305640955.436" 
    $P7727."add_method"($P7728, "!PREFIX__statement_mod_cond:sym<if>", $P7729)
    nqp_get_sc_object $P7730, "1305640934.989", 16
    get_how $P7731, $P7730
    nqp_get_sc_object $P7732, "1305640934.989", 16
    .const 'Sub' $P7733 = "123_1305640955.436" 
    $P7731."add_method"($P7732, "statement_mod_cond:sym<unless>", $P7733)
    nqp_get_sc_object $P7734, "1305640934.989", 16
    get_how $P7735, $P7734
    nqp_get_sc_object $P7736, "1305640934.989", 16
    .const 'Sub' $P7737 = "124_1305640955.436" 
    $P7735."add_method"($P7736, "!PREFIX__statement_mod_cond:sym<unless>", $P7737)
    nqp_get_sc_object $P7738, "1305640934.989", 16
    get_how $P7739, $P7738
    nqp_get_sc_object $P7740, "1305640934.989", 16
    .const 'Sub' $P7741 = "125_1305640955.436" 
    $P7739."add_method"($P7740, "statement_mod_loop", $P7741)
    nqp_get_sc_object $P7742, "1305640934.989", 16
    get_how $P7743, $P7742
    nqp_get_sc_object $P7744, "1305640934.989", 16
    .const 'Sub' $P7745 = "126_1305640955.436" 
    $P7743."add_method"($P7744, "!PREFIX__statement_mod_loop", $P7745)
    nqp_get_sc_object $P7746, "1305640934.989", 16
    get_how $P7747, $P7746
    nqp_get_sc_object $P7748, "1305640934.989", 16
    .const 'Sub' $P7749 = "127_1305640955.436" 
    $P7747."add_method"($P7748, "statement_mod_loop:sym<while>", $P7749)
    nqp_get_sc_object $P7750, "1305640934.989", 16
    get_how $P7751, $P7750
    nqp_get_sc_object $P7752, "1305640934.989", 16
    .const 'Sub' $P7753 = "128_1305640955.436" 
    $P7751."add_method"($P7752, "!PREFIX__statement_mod_loop:sym<while>", $P7753)
    nqp_get_sc_object $P7754, "1305640934.989", 16
    get_how $P7755, $P7754
    nqp_get_sc_object $P7756, "1305640934.989", 16
    .const 'Sub' $P7757 = "129_1305640955.436" 
    $P7755."add_method"($P7756, "statement_mod_loop:sym<until>", $P7757)
    nqp_get_sc_object $P7758, "1305640934.989", 16
    get_how $P7759, $P7758
    nqp_get_sc_object $P7760, "1305640934.989", 16
    .const 'Sub' $P7761 = "130_1305640955.436" 
    $P7759."add_method"($P7760, "!PREFIX__statement_mod_loop:sym<until>", $P7761)
    nqp_get_sc_object $P7762, "1305640934.989", 16
    get_how $P7763, $P7762
    nqp_get_sc_object $P7764, "1305640934.989", 16
    .const 'Sub' $P7765 = "131_1305640955.436" 
    $P7763."add_method"($P7764, "statement_mod_loop:sym<for>", $P7765)
    nqp_get_sc_object $P7766, "1305640934.989", 16
    get_how $P7767, $P7766
    nqp_get_sc_object $P7768, "1305640934.989", 16
    .const 'Sub' $P7769 = "132_1305640955.436" 
    $P7767."add_method"($P7768, "!PREFIX__statement_mod_loop:sym<for>", $P7769)
    nqp_get_sc_object $P7770, "1305640934.989", 16
    get_how $P7771, $P7770
    nqp_get_sc_object $P7772, "1305640934.989", 16
    .const 'Sub' $P7773 = "133_1305640955.436" 
    $P7771."add_method"($P7772, "term:sym<fatarrow>", $P7773)
    nqp_get_sc_object $P7774, "1305640934.989", 16
    get_how $P7775, $P7774
    nqp_get_sc_object $P7776, "1305640934.989", 16
    .const 'Sub' $P7777 = "134_1305640955.436" 
    $P7775."add_method"($P7776, "!PREFIX__term:sym<fatarrow>", $P7777)
    nqp_get_sc_object $P7778, "1305640934.989", 16
    get_how $P7779, $P7778
    nqp_get_sc_object $P7780, "1305640934.989", 16
    .const 'Sub' $P7781 = "135_1305640955.436" 
    $P7779."add_method"($P7780, "term:sym<colonpair>", $P7781)
    nqp_get_sc_object $P7782, "1305640934.989", 16
    get_how $P7783, $P7782
    nqp_get_sc_object $P7784, "1305640934.989", 16
    .const 'Sub' $P7785 = "136_1305640955.436" 
    $P7783."add_method"($P7784, "!PREFIX__term:sym<colonpair>", $P7785)
    nqp_get_sc_object $P7786, "1305640934.989", 16
    get_how $P7787, $P7786
    nqp_get_sc_object $P7788, "1305640934.989", 16
    .const 'Sub' $P7789 = "137_1305640955.436" 
    $P7787."add_method"($P7788, "term:sym<variable>", $P7789)
    nqp_get_sc_object $P7790, "1305640934.989", 16
    get_how $P7791, $P7790
    nqp_get_sc_object $P7792, "1305640934.989", 16
    .const 'Sub' $P7793 = "138_1305640955.436" 
    $P7791."add_method"($P7792, "!PREFIX__term:sym<variable>", $P7793)
    nqp_get_sc_object $P7794, "1305640934.989", 16
    get_how $P7795, $P7794
    nqp_get_sc_object $P7796, "1305640934.989", 16
    .const 'Sub' $P7797 = "139_1305640955.436" 
    $P7795."add_method"($P7796, "term:sym<package_declarator>", $P7797)
    nqp_get_sc_object $P7798, "1305640934.989", 16
    get_how $P7799, $P7798
    nqp_get_sc_object $P7800, "1305640934.989", 16
    .const 'Sub' $P7801 = "140_1305640955.436" 
    $P7799."add_method"($P7800, "!PREFIX__term:sym<package_declarator>", $P7801)
    nqp_get_sc_object $P7802, "1305640934.989", 16
    get_how $P7803, $P7802
    nqp_get_sc_object $P7804, "1305640934.989", 16
    .const 'Sub' $P7805 = "141_1305640955.436" 
    $P7803."add_method"($P7804, "term:sym<scope_declarator>", $P7805)
    nqp_get_sc_object $P7806, "1305640934.989", 16
    get_how $P7807, $P7806
    nqp_get_sc_object $P7808, "1305640934.989", 16
    .const 'Sub' $P7809 = "142_1305640955.436" 
    $P7807."add_method"($P7808, "!PREFIX__term:sym<scope_declarator>", $P7809)
    nqp_get_sc_object $P7810, "1305640934.989", 16
    get_how $P7811, $P7810
    nqp_get_sc_object $P7812, "1305640934.989", 16
    .const 'Sub' $P7813 = "143_1305640955.436" 
    $P7811."add_method"($P7812, "term:sym<routine_declarator>", $P7813)
    nqp_get_sc_object $P7814, "1305640934.989", 16
    get_how $P7815, $P7814
    nqp_get_sc_object $P7816, "1305640934.989", 16
    .const 'Sub' $P7817 = "144_1305640955.436" 
    $P7815."add_method"($P7816, "!PREFIX__term:sym<routine_declarator>", $P7817)
    nqp_get_sc_object $P7818, "1305640934.989", 16
    get_how $P7819, $P7818
    nqp_get_sc_object $P7820, "1305640934.989", 16
    .const 'Sub' $P7821 = "145_1305640955.436" 
    $P7819."add_method"($P7820, "term:sym<multi_declarator>", $P7821)
    nqp_get_sc_object $P7822, "1305640934.989", 16
    get_how $P7823, $P7822
    nqp_get_sc_object $P7824, "1305640934.989", 16
    .const 'Sub' $P7825 = "148_1305640955.436" 
    $P7823."add_method"($P7824, "!PREFIX__term:sym<multi_declarator>", $P7825)
    nqp_get_sc_object $P7826, "1305640934.989", 16
    get_how $P7827, $P7826
    nqp_get_sc_object $P7828, "1305640934.989", 16
    .const 'Sub' $P7829 = "149_1305640955.436" 
    $P7827."add_method"($P7828, "term:sym<regex_declarator>", $P7829)
    nqp_get_sc_object $P7830, "1305640934.989", 16
    get_how $P7831, $P7830
    nqp_get_sc_object $P7832, "1305640934.989", 16
    .const 'Sub' $P7833 = "150_1305640955.436" 
    $P7831."add_method"($P7832, "!PREFIX__term:sym<regex_declarator>", $P7833)
    nqp_get_sc_object $P7834, "1305640934.989", 16
    get_how $P7835, $P7834
    nqp_get_sc_object $P7836, "1305640934.989", 16
    .const 'Sub' $P7837 = "151_1305640955.436" 
    $P7835."add_method"($P7836, "term:sym<statement_prefix>", $P7837)
    nqp_get_sc_object $P7838, "1305640934.989", 16
    get_how $P7839, $P7838
    nqp_get_sc_object $P7840, "1305640934.989", 16
    .const 'Sub' $P7841 = "152_1305640955.436" 
    $P7839."add_method"($P7840, "!PREFIX__term:sym<statement_prefix>", $P7841)
    nqp_get_sc_object $P7842, "1305640934.989", 16
    get_how $P7843, $P7842
    nqp_get_sc_object $P7844, "1305640934.989", 16
    .const 'Sub' $P7845 = "153_1305640955.436" 
    $P7843."add_method"($P7844, "term:sym<lambda>", $P7845)
    nqp_get_sc_object $P7846, "1305640934.989", 16
    get_how $P7847, $P7846
    nqp_get_sc_object $P7848, "1305640934.989", 16
    .const 'Sub' $P7849 = "154_1305640955.436" 
    $P7847."add_method"($P7848, "!PREFIX__term:sym<lambda>", $P7849)
    nqp_get_sc_object $P7850, "1305640934.989", 16
    get_how $P7851, $P7850
    nqp_get_sc_object $P7852, "1305640934.989", 16
    .const 'Sub' $P7853 = "155_1305640955.436" 
    $P7851."add_method"($P7852, "fatarrow", $P7853)
    nqp_get_sc_object $P7854, "1305640934.989", 16
    get_how $P7855, $P7854
    nqp_get_sc_object $P7856, "1305640934.989", 16
    .const 'Sub' $P7857 = "156_1305640955.436" 
    $P7855."add_method"($P7856, "!PREFIX__fatarrow", $P7857)
    nqp_get_sc_object $P7858, "1305640934.989", 16
    get_how $P7859, $P7858
    nqp_get_sc_object $P7860, "1305640934.989", 16
    .const 'Sub' $P7861 = "157_1305640955.436" 
    $P7859."add_method"($P7860, "colonpair", $P7861)
    nqp_get_sc_object $P7862, "1305640934.989", 16
    get_how $P7863, $P7862
    nqp_get_sc_object $P7864, "1305640934.989", 16
    .const 'Sub' $P7865 = "158_1305640955.436" 
    $P7863."add_method"($P7864, "!PREFIX__colonpair", $P7865)
    nqp_get_sc_object $P7866, "1305640934.989", 16
    get_how $P7867, $P7866
    nqp_get_sc_object $P7868, "1305640934.989", 16
    .const 'Sub' $P7869 = "159_1305640955.436" 
    $P7867."add_method"($P7868, "variable", $P7869)
    nqp_get_sc_object $P7870, "1305640934.989", 16
    get_how $P7871, $P7870
    nqp_get_sc_object $P7872, "1305640934.989", 16
    .const 'Sub' $P7873 = "160_1305640955.436" 
    $P7871."add_method"($P7872, "!PREFIX__variable", $P7873)
    nqp_get_sc_object $P7874, "1305640934.989", 16
    get_how $P7875, $P7874
    nqp_get_sc_object $P7876, "1305640934.989", 16
    .const 'Sub' $P7877 = "161_1305640955.436" 
    $P7875."add_method"($P7876, "sigil", $P7877)
    nqp_get_sc_object $P7878, "1305640934.989", 16
    get_how $P7879, $P7878
    nqp_get_sc_object $P7880, "1305640934.989", 16
    .const 'Sub' $P7881 = "162_1305640955.436" 
    $P7879."add_method"($P7880, "!PREFIX__sigil", $P7881)
    nqp_get_sc_object $P7882, "1305640934.989", 16
    get_how $P7883, $P7882
    nqp_get_sc_object $P7884, "1305640934.989", 16
    .const 'Sub' $P7885 = "163_1305640955.436" 
    $P7883."add_method"($P7884, "twigil", $P7885)
    nqp_get_sc_object $P7886, "1305640934.989", 16
    get_how $P7887, $P7886
    nqp_get_sc_object $P7888, "1305640934.989", 16
    .const 'Sub' $P7889 = "164_1305640955.436" 
    $P7887."add_method"($P7888, "!PREFIX__twigil", $P7889)
    nqp_get_sc_object $P7890, "1305640934.989", 16
    get_how $P7891, $P7890
    nqp_get_sc_object $P7892, "1305640934.989", 16
    .const 'Sub' $P7893 = "165_1305640955.436" 
    $P7891."add_method"($P7892, "package_declarator", $P7893)
    nqp_get_sc_object $P7894, "1305640934.989", 16
    get_how $P7895, $P7894
    nqp_get_sc_object $P7896, "1305640934.989", 16
    .const 'Sub' $P7897 = "166_1305640955.436" 
    $P7895."add_method"($P7896, "!PREFIX__package_declarator", $P7897)
    nqp_get_sc_object $P7898, "1305640934.989", 16
    get_how $P7899, $P7898
    nqp_get_sc_object $P7900, "1305640934.989", 16
    .const 'Sub' $P7901 = "167_1305640955.436" 
    $P7899."add_method"($P7900, "package_declarator:sym<module>", $P7901)
    nqp_get_sc_object $P7902, "1305640934.989", 16
    get_how $P7903, $P7902
    nqp_get_sc_object $P7904, "1305640934.989", 16
    .const 'Sub' $P7905 = "168_1305640955.436" 
    $P7903."add_method"($P7904, "!PREFIX__package_declarator:sym<module>", $P7905)
    nqp_get_sc_object $P7906, "1305640934.989", 16
    get_how $P7907, $P7906
    nqp_get_sc_object $P7908, "1305640934.989", 16
    .const 'Sub' $P7909 = "169_1305640955.436" 
    $P7907."add_method"($P7908, "package_declarator:sym<knowhow>", $P7909)
    nqp_get_sc_object $P7910, "1305640934.989", 16
    get_how $P7911, $P7910
    nqp_get_sc_object $P7912, "1305640934.989", 16
    .const 'Sub' $P7913 = "170_1305640955.436" 
    $P7911."add_method"($P7912, "!PREFIX__package_declarator:sym<knowhow>", $P7913)
    nqp_get_sc_object $P7914, "1305640934.989", 16
    get_how $P7915, $P7914
    nqp_get_sc_object $P7916, "1305640934.989", 16
    .const 'Sub' $P7917 = "171_1305640955.436" 
    $P7915."add_method"($P7916, "package_declarator:sym<class>", $P7917)
    nqp_get_sc_object $P7918, "1305640934.989", 16
    get_how $P7919, $P7918
    nqp_get_sc_object $P7920, "1305640934.989", 16
    .const 'Sub' $P7921 = "172_1305640955.436" 
    $P7919."add_method"($P7920, "!PREFIX__package_declarator:sym<class>", $P7921)
    nqp_get_sc_object $P7922, "1305640934.989", 16
    get_how $P7923, $P7922
    nqp_get_sc_object $P7924, "1305640934.989", 16
    .const 'Sub' $P7925 = "173_1305640955.436" 
    $P7923."add_method"($P7924, "package_declarator:sym<grammar>", $P7925)
    nqp_get_sc_object $P7926, "1305640934.989", 16
    get_how $P7927, $P7926
    nqp_get_sc_object $P7928, "1305640934.989", 16
    .const 'Sub' $P7929 = "174_1305640955.436" 
    $P7927."add_method"($P7928, "!PREFIX__package_declarator:sym<grammar>", $P7929)
    nqp_get_sc_object $P7930, "1305640934.989", 16
    get_how $P7931, $P7930
    nqp_get_sc_object $P7932, "1305640934.989", 16
    .const 'Sub' $P7933 = "175_1305640955.436" 
    $P7931."add_method"($P7932, "package_declarator:sym<role>", $P7933)
    nqp_get_sc_object $P7934, "1305640934.989", 16
    get_how $P7935, $P7934
    nqp_get_sc_object $P7936, "1305640934.989", 16
    .const 'Sub' $P7937 = "176_1305640955.436" 
    $P7935."add_method"($P7936, "!PREFIX__package_declarator:sym<role>", $P7937)
    nqp_get_sc_object $P7938, "1305640934.989", 16
    get_how $P7939, $P7938
    nqp_get_sc_object $P7940, "1305640934.989", 16
    .const 'Sub' $P7941 = "177_1305640955.436" 
    $P7939."add_method"($P7940, "package_declarator:sym<native>", $P7941)
    nqp_get_sc_object $P7942, "1305640934.989", 16
    get_how $P7943, $P7942
    nqp_get_sc_object $P7944, "1305640934.989", 16
    .const 'Sub' $P7945 = "178_1305640955.436" 
    $P7943."add_method"($P7944, "!PREFIX__package_declarator:sym<native>", $P7945)
    nqp_get_sc_object $P7946, "1305640934.989", 16
    get_how $P7947, $P7946
    nqp_get_sc_object $P7948, "1305640934.989", 16
    .const 'Sub' $P7949 = "179_1305640955.436" 
    $P7947."add_method"($P7948, "package_declarator:sym<stub>", $P7949)
    nqp_get_sc_object $P7950, "1305640934.989", 16
    get_how $P7951, $P7950
    nqp_get_sc_object $P7952, "1305640934.989", 16
    .const 'Sub' $P7953 = "180_1305640955.436" 
    $P7951."add_method"($P7952, "!PREFIX__package_declarator:sym<stub>", $P7953)
    nqp_get_sc_object $P7954, "1305640934.989", 16
    get_how $P7955, $P7954
    nqp_get_sc_object $P7956, "1305640934.989", 16
    .const 'Sub' $P7957 = "181_1305640955.436" 
    $P7955."add_method"($P7956, "package_def", $P7957)
    nqp_get_sc_object $P7958, "1305640934.989", 16
    get_how $P7959, $P7958
    nqp_get_sc_object $P7960, "1305640934.989", 16
    .const 'Sub' $P7961 = "183_1305640955.436" 
    $P7959."add_method"($P7960, "!PREFIX__package_def", $P7961)
    nqp_get_sc_object $P7962, "1305640934.989", 16
    get_how $P7963, $P7962
    nqp_get_sc_object $P7964, "1305640934.989", 16
    .const 'Sub' $P7965 = "184_1305640955.436" 
    $P7963."add_method"($P7964, "scope_declarator", $P7965)
    nqp_get_sc_object $P7966, "1305640934.989", 16
    get_how $P7967, $P7966
    nqp_get_sc_object $P7968, "1305640934.989", 16
    .const 'Sub' $P7969 = "185_1305640955.436" 
    $P7967."add_method"($P7968, "!PREFIX__scope_declarator", $P7969)
    nqp_get_sc_object $P7970, "1305640934.989", 16
    get_how $P7971, $P7970
    nqp_get_sc_object $P7972, "1305640934.989", 16
    .const 'Sub' $P7973 = "186_1305640955.436" 
    $P7971."add_method"($P7972, "scope_declarator:sym<my>", $P7973)
    nqp_get_sc_object $P7974, "1305640934.989", 16
    get_how $P7975, $P7974
    nqp_get_sc_object $P7976, "1305640934.989", 16
    .const 'Sub' $P7977 = "187_1305640955.436" 
    $P7975."add_method"($P7976, "!PREFIX__scope_declarator:sym<my>", $P7977)
    nqp_get_sc_object $P7978, "1305640934.989", 16
    get_how $P7979, $P7978
    nqp_get_sc_object $P7980, "1305640934.989", 16
    .const 'Sub' $P7981 = "188_1305640955.436" 
    $P7979."add_method"($P7980, "scope_declarator:sym<our>", $P7981)
    nqp_get_sc_object $P7982, "1305640934.989", 16
    get_how $P7983, $P7982
    nqp_get_sc_object $P7984, "1305640934.989", 16
    .const 'Sub' $P7985 = "189_1305640955.436" 
    $P7983."add_method"($P7984, "!PREFIX__scope_declarator:sym<our>", $P7985)
    nqp_get_sc_object $P7986, "1305640934.989", 16
    get_how $P7987, $P7986
    nqp_get_sc_object $P7988, "1305640934.989", 16
    .const 'Sub' $P7989 = "190_1305640955.436" 
    $P7987."add_method"($P7988, "scope_declarator:sym<has>", $P7989)
    nqp_get_sc_object $P7990, "1305640934.989", 16
    get_how $P7991, $P7990
    nqp_get_sc_object $P7992, "1305640934.989", 16
    .const 'Sub' $P7993 = "191_1305640955.436" 
    $P7991."add_method"($P7992, "!PREFIX__scope_declarator:sym<has>", $P7993)
    nqp_get_sc_object $P7994, "1305640934.989", 16
    get_how $P7995, $P7994
    nqp_get_sc_object $P7996, "1305640934.989", 16
    .const 'Sub' $P7997 = "192_1305640955.436" 
    $P7995."add_method"($P7996, "scoped", $P7997)
    nqp_get_sc_object $P7998, "1305640934.989", 16
    get_how $P7999, $P7998
    nqp_get_sc_object $P8000, "1305640934.989", 16
    .const 'Sub' $P8001 = "193_1305640955.436" 
    $P7999."add_method"($P8000, "!PREFIX__scoped", $P8001)
    nqp_get_sc_object $P8002, "1305640934.989", 16
    get_how $P8003, $P8002
    nqp_get_sc_object $P8004, "1305640934.989", 16
    .const 'Sub' $P8005 = "194_1305640955.436" 
    $P8003."add_method"($P8004, "typename", $P8005)
    nqp_get_sc_object $P8006, "1305640934.989", 16
    get_how $P8007, $P8006
    nqp_get_sc_object $P8008, "1305640934.989", 16
    .const 'Sub' $P8009 = "196_1305640955.436" 
    $P8007."add_method"($P8008, "!PREFIX__typename", $P8009)
    nqp_get_sc_object $P8010, "1305640934.989", 16
    get_how $P8011, $P8010
    nqp_get_sc_object $P8012, "1305640934.989", 16
    .const 'Sub' $P8013 = "197_1305640955.436" 
    $P8011."add_method"($P8012, "declarator", $P8013)
    nqp_get_sc_object $P8014, "1305640934.989", 16
    get_how $P8015, $P8014
    nqp_get_sc_object $P8016, "1305640934.989", 16
    .const 'Sub' $P8017 = "198_1305640955.436" 
    $P8015."add_method"($P8016, "!PREFIX__declarator", $P8017)
    nqp_get_sc_object $P8018, "1305640934.989", 16
    get_how $P8019, $P8018
    nqp_get_sc_object $P8020, "1305640934.989", 16
    .const 'Sub' $P8021 = "199_1305640955.436" 
    $P8019."add_method"($P8020, "variable_declarator", $P8021)
    nqp_get_sc_object $P8022, "1305640934.989", 16
    get_how $P8023, $P8022
    nqp_get_sc_object $P8024, "1305640934.989", 16
    .const 'Sub' $P8025 = "201_1305640955.436" 
    $P8023."add_method"($P8024, "!PREFIX__variable_declarator", $P8025)
    nqp_get_sc_object $P8026, "1305640934.989", 16
    get_how $P8027, $P8026
    nqp_get_sc_object $P8028, "1305640934.989", 16
    .const 'Sub' $P8029 = "202_1305640955.436" 
    $P8027."add_method"($P8028, "routine_declarator", $P8029)
    nqp_get_sc_object $P8030, "1305640934.989", 16
    get_how $P8031, $P8030
    nqp_get_sc_object $P8032, "1305640934.989", 16
    .const 'Sub' $P8033 = "203_1305640955.436" 
    $P8031."add_method"($P8032, "!PREFIX__routine_declarator", $P8033)
    nqp_get_sc_object $P8034, "1305640934.989", 16
    get_how $P8035, $P8034
    nqp_get_sc_object $P8036, "1305640934.989", 16
    .const 'Sub' $P8037 = "204_1305640955.436" 
    $P8035."add_method"($P8036, "routine_declarator:sym<sub>", $P8037)
    nqp_get_sc_object $P8038, "1305640934.989", 16
    get_how $P8039, $P8038
    nqp_get_sc_object $P8040, "1305640934.989", 16
    .const 'Sub' $P8041 = "205_1305640955.436" 
    $P8039."add_method"($P8040, "!PREFIX__routine_declarator:sym<sub>", $P8041)
    nqp_get_sc_object $P8042, "1305640934.989", 16
    get_how $P8043, $P8042
    nqp_get_sc_object $P8044, "1305640934.989", 16
    .const 'Sub' $P8045 = "206_1305640955.436" 
    $P8043."add_method"($P8044, "routine_declarator:sym<method>", $P8045)
    nqp_get_sc_object $P8046, "1305640934.989", 16
    get_how $P8047, $P8046
    nqp_get_sc_object $P8048, "1305640934.989", 16
    .const 'Sub' $P8049 = "207_1305640955.436" 
    $P8047."add_method"($P8048, "!PREFIX__routine_declarator:sym<method>", $P8049)
    nqp_get_sc_object $P8050, "1305640934.989", 16
    get_how $P8051, $P8050
    nqp_get_sc_object $P8052, "1305640934.989", 16
    .const 'Sub' $P8053 = "208_1305640955.436" 
    $P8051."add_method"($P8052, "routine_def", $P8053)
    nqp_get_sc_object $P8054, "1305640934.989", 16
    get_how $P8055, $P8054
    nqp_get_sc_object $P8056, "1305640934.989", 16
    .const 'Sub' $P8057 = "209_1305640955.436" 
    $P8055."add_method"($P8056, "!PREFIX__routine_def", $P8057)
    nqp_get_sc_object $P8058, "1305640934.989", 16
    get_how $P8059, $P8058
    nqp_get_sc_object $P8060, "1305640934.989", 16
    .const 'Sub' $P8061 = "210_1305640955.436" 
    $P8059."add_method"($P8060, "method_def", $P8061)
    nqp_get_sc_object $P8062, "1305640934.989", 16
    get_how $P8063, $P8062
    nqp_get_sc_object $P8064, "1305640934.989", 16
    .const 'Sub' $P8065 = "212_1305640955.436" 
    $P8063."add_method"($P8064, "!PREFIX__method_def", $P8065)
    nqp_get_sc_object $P8066, "1305640934.989", 16
    get_how $P8067, $P8066
    nqp_get_sc_object $P8068, "1305640934.989", 16
    .const 'Sub' $P8069 = "213_1305640955.436" 
    $P8067."add_method"($P8068, "onlystar", $P8069)
    nqp_get_sc_object $P8070, "1305640934.989", 16
    get_how $P8071, $P8070
    nqp_get_sc_object $P8072, "1305640934.989", 16
    .const 'Sub' $P8073 = "215_1305640955.436" 
    $P8071."add_method"($P8072, "!PREFIX__onlystar", $P8073)
    nqp_get_sc_object $P8074, "1305640934.989", 16
    get_how $P8075, $P8074
    nqp_get_sc_object $P8076, "1305640934.989", 16
    .const 'Sub' $P8077 = "216_1305640955.436" 
    $P8075."add_method"($P8076, "multi_declarator", $P8077)
    nqp_get_sc_object $P8078, "1305640934.989", 16
    get_how $P8079, $P8078
    nqp_get_sc_object $P8080, "1305640934.989", 16
    .const 'Sub' $P8081 = "217_1305640955.436" 
    $P8079."add_method"($P8080, "!PREFIX__multi_declarator", $P8081)
    nqp_get_sc_object $P8082, "1305640934.989", 16
    get_how $P8083, $P8082
    nqp_get_sc_object $P8084, "1305640934.989", 16
    .const 'Sub' $P8085 = "218_1305640955.436" 
    $P8083."add_method"($P8084, "multi_declarator:sym<multi>", $P8085)
    nqp_get_sc_object $P8086, "1305640934.989", 16
    get_how $P8087, $P8086
    nqp_get_sc_object $P8088, "1305640934.989", 16
    .const 'Sub' $P8089 = "219_1305640955.436" 
    $P8087."add_method"($P8088, "!PREFIX__multi_declarator:sym<multi>", $P8089)
    nqp_get_sc_object $P8090, "1305640934.989", 16
    get_how $P8091, $P8090
    nqp_get_sc_object $P8092, "1305640934.989", 16
    .const 'Sub' $P8093 = "220_1305640955.436" 
    $P8091."add_method"($P8092, "multi_declarator:sym<proto>", $P8093)
    nqp_get_sc_object $P8094, "1305640934.989", 16
    get_how $P8095, $P8094
    nqp_get_sc_object $P8096, "1305640934.989", 16
    .const 'Sub' $P8097 = "221_1305640955.436" 
    $P8095."add_method"($P8096, "!PREFIX__multi_declarator:sym<proto>", $P8097)
    nqp_get_sc_object $P8098, "1305640934.989", 16
    get_how $P8099, $P8098
    nqp_get_sc_object $P8100, "1305640934.989", 16
    .const 'Sub' $P8101 = "222_1305640955.436" 
    $P8099."add_method"($P8100, "multi_declarator:sym<null>", $P8101)
    nqp_get_sc_object $P8102, "1305640934.989", 16
    get_how $P8103, $P8102
    nqp_get_sc_object $P8104, "1305640934.989", 16
    .const 'Sub' $P8105 = "223_1305640955.436" 
    $P8103."add_method"($P8104, "!PREFIX__multi_declarator:sym<null>", $P8105)
    nqp_get_sc_object $P8106, "1305640934.989", 16
    get_how $P8107, $P8106
    nqp_get_sc_object $P8108, "1305640934.989", 16
    .const 'Sub' $P8109 = "224_1305640955.436" 
    $P8107."add_method"($P8108, "signature", $P8109)
    nqp_get_sc_object $P8110, "1305640934.989", 16
    get_how $P8111, $P8110
    nqp_get_sc_object $P8112, "1305640934.989", 16
    .const 'Sub' $P8113 = "226_1305640955.436" 
    $P8111."add_method"($P8112, "!PREFIX__signature", $P8113)
    nqp_get_sc_object $P8114, "1305640934.989", 16
    get_how $P8115, $P8114
    nqp_get_sc_object $P8116, "1305640934.989", 16
    .const 'Sub' $P8117 = "227_1305640955.436" 
    $P8115."add_method"($P8116, "parameter", $P8117)
    nqp_get_sc_object $P8118, "1305640934.989", 16
    get_how $P8119, $P8118
    nqp_get_sc_object $P8120, "1305640934.989", 16
    .const 'Sub' $P8121 = "228_1305640955.436" 
    $P8119."add_method"($P8120, "!PREFIX__parameter", $P8121)
    nqp_get_sc_object $P8122, "1305640934.989", 16
    get_how $P8123, $P8122
    nqp_get_sc_object $P8124, "1305640934.989", 16
    .const 'Sub' $P8125 = "229_1305640955.436" 
    $P8123."add_method"($P8124, "param_var", $P8125)
    nqp_get_sc_object $P8126, "1305640934.989", 16
    get_how $P8127, $P8126
    nqp_get_sc_object $P8128, "1305640934.989", 16
    .const 'Sub' $P8129 = "230_1305640955.436" 
    $P8127."add_method"($P8128, "!PREFIX__param_var", $P8129)
    nqp_get_sc_object $P8130, "1305640934.989", 16
    get_how $P8131, $P8130
    nqp_get_sc_object $P8132, "1305640934.989", 16
    .const 'Sub' $P8133 = "231_1305640955.436" 
    $P8131."add_method"($P8132, "named_param", $P8133)
    nqp_get_sc_object $P8134, "1305640934.989", 16
    get_how $P8135, $P8134
    nqp_get_sc_object $P8136, "1305640934.989", 16
    .const 'Sub' $P8137 = "232_1305640955.436" 
    $P8135."add_method"($P8136, "!PREFIX__named_param", $P8137)
    nqp_get_sc_object $P8138, "1305640934.989", 16
    get_how $P8139, $P8138
    nqp_get_sc_object $P8140, "1305640934.989", 16
    .const 'Sub' $P8141 = "233_1305640955.436" 
    $P8139."add_method"($P8140, "default_value", $P8141)
    nqp_get_sc_object $P8142, "1305640934.989", 16
    get_how $P8143, $P8142
    nqp_get_sc_object $P8144, "1305640934.989", 16
    .const 'Sub' $P8145 = "234_1305640955.436" 
    $P8143."add_method"($P8144, "!PREFIX__default_value", $P8145)
    nqp_get_sc_object $P8146, "1305640934.989", 16
    get_how $P8147, $P8146
    nqp_get_sc_object $P8148, "1305640934.989", 16
    .const 'Sub' $P8149 = "235_1305640955.436" 
    $P8147."add_method"($P8148, "trait", $P8149)
    nqp_get_sc_object $P8150, "1305640934.989", 16
    get_how $P8151, $P8150
    nqp_get_sc_object $P8152, "1305640934.989", 16
    .const 'Sub' $P8153 = "236_1305640955.436" 
    $P8151."add_method"($P8152, "!PREFIX__trait", $P8153)
    nqp_get_sc_object $P8154, "1305640934.989", 16
    get_how $P8155, $P8154
    nqp_get_sc_object $P8156, "1305640934.989", 16
    .const 'Sub' $P8157 = "237_1305640955.436" 
    $P8155."add_method"($P8156, "trait_mod", $P8157)
    nqp_get_sc_object $P8158, "1305640934.989", 16
    get_how $P8159, $P8158
    nqp_get_sc_object $P8160, "1305640934.989", 16
    .const 'Sub' $P8161 = "238_1305640955.436" 
    $P8159."add_method"($P8160, "!PREFIX__trait_mod", $P8161)
    nqp_get_sc_object $P8162, "1305640934.989", 16
    get_how $P8163, $P8162
    nqp_get_sc_object $P8164, "1305640934.989", 16
    .const 'Sub' $P8165 = "239_1305640955.436" 
    $P8163."add_method"($P8164, "trait_mod:sym<is>", $P8165)
    nqp_get_sc_object $P8166, "1305640934.989", 16
    get_how $P8167, $P8166
    nqp_get_sc_object $P8168, "1305640934.989", 16
    .const 'Sub' $P8169 = "240_1305640955.436" 
    $P8167."add_method"($P8168, "!PREFIX__trait_mod:sym<is>", $P8169)
    nqp_get_sc_object $P8170, "1305640934.989", 16
    get_how $P8171, $P8170
    nqp_get_sc_object $P8172, "1305640934.989", 16
    .const 'Sub' $P8173 = "241_1305640955.436" 
    $P8171."add_method"($P8172, "regex_declarator", $P8173)
    nqp_get_sc_object $P8174, "1305640934.989", 16
    get_how $P8175, $P8174
    nqp_get_sc_object $P8176, "1305640934.989", 16
    .const 'Sub' $P8177 = "242_1305640955.436" 
    $P8175."add_method"($P8176, "!PREFIX__regex_declarator", $P8177)
    nqp_get_sc_object $P8178, "1305640934.989", 16
    get_how $P8179, $P8178
    nqp_get_sc_object $P8180, "1305640934.989", 16
    .const 'Sub' $P8181 = "243_1305640955.436" 
    $P8179."add_method"($P8180, "dotty", $P8181)
    nqp_get_sc_object $P8182, "1305640934.989", 16
    get_how $P8183, $P8182
    nqp_get_sc_object $P8184, "1305640934.989", 16
    .const 'Sub' $P8185 = "244_1305640955.436" 
    $P8183."add_method"($P8184, "!PREFIX__dotty", $P8185)
    nqp_get_sc_object $P8186, "1305640934.989", 16
    get_how $P8187, $P8186
    nqp_get_sc_object $P8188, "1305640934.989", 16
    .const 'Sub' $P8189 = "245_1305640955.436" 
    $P8187."add_method"($P8188, "term", $P8189)
    nqp_get_sc_object $P8190, "1305640934.989", 16
    get_how $P8191, $P8190
    nqp_get_sc_object $P8192, "1305640934.989", 16
    .const 'Sub' $P8193 = "246_1305640955.436" 
    $P8191."add_method"($P8192, "!PREFIX__term", $P8193)
    nqp_get_sc_object $P8194, "1305640934.989", 16
    get_how $P8195, $P8194
    nqp_get_sc_object $P8196, "1305640934.989", 16
    .const 'Sub' $P8197 = "247_1305640955.436" 
    $P8195."add_method"($P8196, "term:sym<self>", $P8197)
    nqp_get_sc_object $P8198, "1305640934.989", 16
    get_how $P8199, $P8198
    nqp_get_sc_object $P8200, "1305640934.989", 16
    .const 'Sub' $P8201 = "248_1305640955.436" 
    $P8199."add_method"($P8200, "!PREFIX__term:sym<self>", $P8201)
    nqp_get_sc_object $P8202, "1305640934.989", 16
    get_how $P8203, $P8202
    nqp_get_sc_object $P8204, "1305640934.989", 16
    .const 'Sub' $P8205 = "249_1305640955.436" 
    $P8203."add_method"($P8204, "term:sym<identifier>", $P8205)
    nqp_get_sc_object $P8206, "1305640934.989", 16
    get_how $P8207, $P8206
    nqp_get_sc_object $P8208, "1305640934.989", 16
    .const 'Sub' $P8209 = "250_1305640955.436" 
    $P8207."add_method"($P8208, "!PREFIX__term:sym<identifier>", $P8209)
    nqp_get_sc_object $P8210, "1305640934.989", 16
    get_how $P8211, $P8210
    nqp_get_sc_object $P8212, "1305640934.989", 16
    .const 'Sub' $P8213 = "251_1305640955.436" 
    $P8211."add_method"($P8212, "term:sym<name>", $P8213)
    nqp_get_sc_object $P8214, "1305640934.989", 16
    get_how $P8215, $P8214
    nqp_get_sc_object $P8216, "1305640934.989", 16
    .const 'Sub' $P8217 = "252_1305640955.436" 
    $P8215."add_method"($P8216, "!PREFIX__term:sym<name>", $P8217)
    nqp_get_sc_object $P8218, "1305640934.989", 16
    get_how $P8219, $P8218
    nqp_get_sc_object $P8220, "1305640934.989", 16
    .const 'Sub' $P8221 = "253_1305640955.436" 
    $P8219."add_method"($P8220, "term:sym<pir::op>", $P8221)
    nqp_get_sc_object $P8222, "1305640934.989", 16
    get_how $P8223, $P8222
    nqp_get_sc_object $P8224, "1305640934.989", 16
    .const 'Sub' $P8225 = "254_1305640955.436" 
    $P8223."add_method"($P8224, "!PREFIX__term:sym<pir::op>", $P8225)
    nqp_get_sc_object $P8226, "1305640934.989", 16
    get_how $P8227, $P8226
    nqp_get_sc_object $P8228, "1305640934.989", 16
    .const 'Sub' $P8229 = "255_1305640955.436" 
    $P8227."add_method"($P8228, "term:sym<onlystar>", $P8229)
    nqp_get_sc_object $P8230, "1305640934.989", 16
    get_how $P8231, $P8230
    nqp_get_sc_object $P8232, "1305640934.989", 16
    .const 'Sub' $P8233 = "257_1305640955.436" 
    $P8231."add_method"($P8232, "!PREFIX__term:sym<onlystar>", $P8233)
    nqp_get_sc_object $P8234, "1305640934.989", 16
    get_how $P8235, $P8234
    nqp_get_sc_object $P8236, "1305640934.989", 16
    .const 'Sub' $P8237 = "258_1305640955.436" 
    $P8235."add_method"($P8236, "args", $P8237)
    nqp_get_sc_object $P8238, "1305640934.989", 16
    get_how $P8239, $P8238
    nqp_get_sc_object $P8240, "1305640934.989", 16
    .const 'Sub' $P8241 = "259_1305640955.436" 
    $P8239."add_method"($P8240, "!PREFIX__args", $P8241)
    nqp_get_sc_object $P8242, "1305640934.989", 16
    get_how $P8243, $P8242
    nqp_get_sc_object $P8244, "1305640934.989", 16
    .const 'Sub' $P8245 = "260_1305640955.436" 
    $P8243."add_method"($P8244, "arglist", $P8245)
    nqp_get_sc_object $P8246, "1305640934.989", 16
    get_how $P8247, $P8246
    nqp_get_sc_object $P8248, "1305640934.989", 16
    .const 'Sub' $P8249 = "261_1305640955.436" 
    $P8247."add_method"($P8248, "!PREFIX__arglist", $P8249)
    nqp_get_sc_object $P8250, "1305640934.989", 16
    get_how $P8251, $P8250
    nqp_get_sc_object $P8252, "1305640934.989", 16
    .const 'Sub' $P8253 = "262_1305640955.436" 
    $P8251."add_method"($P8252, "term:sym<value>", $P8253)
    nqp_get_sc_object $P8254, "1305640934.989", 16
    get_how $P8255, $P8254
    nqp_get_sc_object $P8256, "1305640934.989", 16
    .const 'Sub' $P8257 = "263_1305640955.436" 
    $P8255."add_method"($P8256, "!PREFIX__term:sym<value>", $P8257)
    nqp_get_sc_object $P8258, "1305640934.989", 16
    get_how $P8259, $P8258
    nqp_get_sc_object $P8260, "1305640934.989", 16
    .const 'Sub' $P8261 = "264_1305640955.436" 
    $P8259."add_method"($P8260, "value", $P8261)
    nqp_get_sc_object $P8262, "1305640934.989", 16
    get_how $P8263, $P8262
    nqp_get_sc_object $P8264, "1305640934.989", 16
    .const 'Sub' $P8265 = "265_1305640955.436" 
    $P8263."add_method"($P8264, "!PREFIX__value", $P8265)
    nqp_get_sc_object $P8266, "1305640934.989", 16
    get_how $P8267, $P8266
    nqp_get_sc_object $P8268, "1305640934.989", 16
    .const 'Sub' $P8269 = "266_1305640955.436" 
    $P8267."add_method"($P8268, "number", $P8269)
    nqp_get_sc_object $P8270, "1305640934.989", 16
    get_how $P8271, $P8270
    nqp_get_sc_object $P8272, "1305640934.989", 16
    .const 'Sub' $P8273 = "267_1305640955.436" 
    $P8271."add_method"($P8272, "!PREFIX__number", $P8273)
    nqp_get_sc_object $P8274, "1305640934.989", 16
    get_how $P8275, $P8274
    nqp_get_sc_object $P8276, "1305640934.989", 16
    .const 'Sub' $P8277 = "268_1305640955.436" 
    $P8275."add_method"($P8276, "quote", $P8277)
    nqp_get_sc_object $P8278, "1305640934.989", 16
    get_how $P8279, $P8278
    nqp_get_sc_object $P8280, "1305640934.989", 16
    .const 'Sub' $P8281 = "269_1305640955.436" 
    $P8279."add_method"($P8280, "!PREFIX__quote", $P8281)
    nqp_get_sc_object $P8282, "1305640934.989", 16
    get_how $P8283, $P8282
    nqp_get_sc_object $P8284, "1305640934.989", 16
    .const 'Sub' $P8285 = "270_1305640955.436" 
    $P8283."add_method"($P8284, "quote:sym<apos>", $P8285)
    nqp_get_sc_object $P8286, "1305640934.989", 16
    get_how $P8287, $P8286
    nqp_get_sc_object $P8288, "1305640934.989", 16
    .const 'Sub' $P8289 = "271_1305640955.436" 
    $P8287."add_method"($P8288, "!PREFIX__quote:sym<apos>", $P8289)
    nqp_get_sc_object $P8290, "1305640934.989", 16
    get_how $P8291, $P8290
    nqp_get_sc_object $P8292, "1305640934.989", 16
    .const 'Sub' $P8293 = "272_1305640955.436" 
    $P8291."add_method"($P8292, "quote:sym<dblq>", $P8293)
    nqp_get_sc_object $P8294, "1305640934.989", 16
    get_how $P8295, $P8294
    nqp_get_sc_object $P8296, "1305640934.989", 16
    .const 'Sub' $P8297 = "273_1305640955.436" 
    $P8295."add_method"($P8296, "!PREFIX__quote:sym<dblq>", $P8297)
    nqp_get_sc_object $P8298, "1305640934.989", 16
    get_how $P8299, $P8298
    nqp_get_sc_object $P8300, "1305640934.989", 16
    .const 'Sub' $P8301 = "274_1305640955.436" 
    $P8299."add_method"($P8300, "quote:sym<q>", $P8301)
    nqp_get_sc_object $P8302, "1305640934.989", 16
    get_how $P8303, $P8302
    nqp_get_sc_object $P8304, "1305640934.989", 16
    .const 'Sub' $P8305 = "275_1305640955.436" 
    $P8303."add_method"($P8304, "!PREFIX__quote:sym<q>", $P8305)
    nqp_get_sc_object $P8306, "1305640934.989", 16
    get_how $P8307, $P8306
    nqp_get_sc_object $P8308, "1305640934.989", 16
    .const 'Sub' $P8309 = "276_1305640955.436" 
    $P8307."add_method"($P8308, "quote:sym<qq>", $P8309)
    nqp_get_sc_object $P8310, "1305640934.989", 16
    get_how $P8311, $P8310
    nqp_get_sc_object $P8312, "1305640934.989", 16
    .const 'Sub' $P8313 = "277_1305640955.436" 
    $P8311."add_method"($P8312, "!PREFIX__quote:sym<qq>", $P8313)
    nqp_get_sc_object $P8314, "1305640934.989", 16
    get_how $P8315, $P8314
    nqp_get_sc_object $P8316, "1305640934.989", 16
    .const 'Sub' $P8317 = "278_1305640955.436" 
    $P8315."add_method"($P8316, "quote:sym<Q>", $P8317)
    nqp_get_sc_object $P8318, "1305640934.989", 16
    get_how $P8319, $P8318
    nqp_get_sc_object $P8320, "1305640934.989", 16
    .const 'Sub' $P8321 = "279_1305640955.436" 
    $P8319."add_method"($P8320, "!PREFIX__quote:sym<Q>", $P8321)
    nqp_get_sc_object $P8322, "1305640934.989", 16
    get_how $P8323, $P8322
    nqp_get_sc_object $P8324, "1305640934.989", 16
    .const 'Sub' $P8325 = "280_1305640955.436" 
    $P8323."add_method"($P8324, "quote:sym<Q:PIR>", $P8325)
    nqp_get_sc_object $P8326, "1305640934.989", 16
    get_how $P8327, $P8326
    nqp_get_sc_object $P8328, "1305640934.989", 16
    .const 'Sub' $P8329 = "281_1305640955.436" 
    $P8327."add_method"($P8328, "!PREFIX__quote:sym<Q:PIR>", $P8329)
    nqp_get_sc_object $P8330, "1305640934.989", 16
    get_how $P8331, $P8330
    nqp_get_sc_object $P8332, "1305640934.989", 16
    .const 'Sub' $P8333 = "282_1305640955.436" 
    $P8331."add_method"($P8332, "quote:sym</ />", $P8333)
    nqp_get_sc_object $P8334, "1305640934.989", 16
    get_how $P8335, $P8334
    nqp_get_sc_object $P8336, "1305640934.989", 16
    .const 'Sub' $P8337 = "283_1305640955.436" 
    $P8335."add_method"($P8336, "!PREFIX__quote:sym</ />", $P8337)
    nqp_get_sc_object $P8338, "1305640934.989", 16
    get_how $P8339, $P8338
    nqp_get_sc_object $P8340, "1305640934.989", 16
    .const 'Sub' $P8341 = "284_1305640955.436" 
    $P8339."add_method"($P8340, "quote_escape:sym<$>", $P8341)
    nqp_get_sc_object $P8342, "1305640934.989", 16
    get_how $P8343, $P8342
    nqp_get_sc_object $P8344, "1305640934.989", 16
    .const 'Sub' $P8345 = "285_1305640955.436" 
    $P8343."add_method"($P8344, "!PREFIX__quote_escape:sym<$>", $P8345)
    nqp_get_sc_object $P8346, "1305640934.989", 16
    get_how $P8347, $P8346
    nqp_get_sc_object $P8348, "1305640934.989", 16
    .const 'Sub' $P8349 = "286_1305640955.436" 
    $P8347."add_method"($P8348, "quote_escape:sym<{ }>", $P8349)
    nqp_get_sc_object $P8350, "1305640934.989", 16
    get_how $P8351, $P8350
    nqp_get_sc_object $P8352, "1305640934.989", 16
    .const 'Sub' $P8353 = "287_1305640955.436" 
    $P8351."add_method"($P8352, "!PREFIX__quote_escape:sym<{ }>", $P8353)
    nqp_get_sc_object $P8354, "1305640934.989", 16
    get_how $P8355, $P8354
    nqp_get_sc_object $P8356, "1305640934.989", 16
    .const 'Sub' $P8357 = "288_1305640955.436" 
    $P8355."add_method"($P8356, "quote_escape:sym<esc>", $P8357)
    nqp_get_sc_object $P8358, "1305640934.989", 16
    get_how $P8359, $P8358
    nqp_get_sc_object $P8360, "1305640934.989", 16
    .const 'Sub' $P8361 = "289_1305640955.436" 
    $P8359."add_method"($P8360, "!PREFIX__quote_escape:sym<esc>", $P8361)
    nqp_get_sc_object $P8362, "1305640934.989", 16
    get_how $P8363, $P8362
    nqp_get_sc_object $P8364, "1305640934.989", 16
    .const 'Sub' $P8365 = "290_1305640955.436" 
    $P8363."add_method"($P8364, "circumfix:sym<( )>", $P8365)
    nqp_get_sc_object $P8366, "1305640934.989", 16
    get_how $P8367, $P8366
    nqp_get_sc_object $P8368, "1305640934.989", 16
    .const 'Sub' $P8369 = "291_1305640955.436" 
    $P8367."add_method"($P8368, "!PREFIX__circumfix:sym<( )>", $P8369)
    nqp_get_sc_object $P8370, "1305640934.989", 16
    get_how $P8371, $P8370
    nqp_get_sc_object $P8372, "1305640934.989", 16
    .const 'Sub' $P8373 = "292_1305640955.436" 
    $P8371."add_method"($P8372, "circumfix:sym<[ ]>", $P8373)
    nqp_get_sc_object $P8374, "1305640934.989", 16
    get_how $P8375, $P8374
    nqp_get_sc_object $P8376, "1305640934.989", 16
    .const 'Sub' $P8377 = "293_1305640955.436" 
    $P8375."add_method"($P8376, "!PREFIX__circumfix:sym<[ ]>", $P8377)
    nqp_get_sc_object $P8378, "1305640934.989", 16
    get_how $P8379, $P8378
    nqp_get_sc_object $P8380, "1305640934.989", 16
    .const 'Sub' $P8381 = "294_1305640955.436" 
    $P8379."add_method"($P8380, "circumfix:sym<ang>", $P8381)
    nqp_get_sc_object $P8382, "1305640934.989", 16
    get_how $P8383, $P8382
    nqp_get_sc_object $P8384, "1305640934.989", 16
    .const 'Sub' $P8385 = "295_1305640955.436" 
    $P8383."add_method"($P8384, "!PREFIX__circumfix:sym<ang>", $P8385)
    nqp_get_sc_object $P8386, "1305640934.989", 16
    get_how $P8387, $P8386
    nqp_get_sc_object $P8388, "1305640934.989", 16
    .const 'Sub' $P8389 = "296_1305640955.436" 
    $P8387."add_method"($P8388, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P8389)
    nqp_get_sc_object $P8390, "1305640934.989", 16
    get_how $P8391, $P8390
    nqp_get_sc_object $P8392, "1305640934.989", 16
    .const 'Sub' $P8393 = "297_1305640955.436" 
    $P8391."add_method"($P8392, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P8393)
    nqp_get_sc_object $P8394, "1305640934.989", 16
    get_how $P8395, $P8394
    nqp_get_sc_object $P8396, "1305640934.989", 16
    .const 'Sub' $P8397 = "298_1305640955.436" 
    $P8395."add_method"($P8396, "circumfix:sym<{ }>", $P8397)
    nqp_get_sc_object $P8398, "1305640934.989", 16
    get_how $P8399, $P8398
    nqp_get_sc_object $P8400, "1305640934.989", 16
    .const 'Sub' $P8401 = "299_1305640955.436" 
    $P8399."add_method"($P8400, "!PREFIX__circumfix:sym<{ }>", $P8401)
    nqp_get_sc_object $P8402, "1305640934.989", 16
    get_how $P8403, $P8402
    nqp_get_sc_object $P8404, "1305640934.989", 16
    .const 'Sub' $P8405 = "300_1305640955.436" 
    $P8403."add_method"($P8404, "circumfix:sym<sigil>", $P8405)
    nqp_get_sc_object $P8406, "1305640934.989", 16
    get_how $P8407, $P8406
    nqp_get_sc_object $P8408, "1305640934.989", 16
    .const 'Sub' $P8409 = "301_1305640955.436" 
    $P8407."add_method"($P8408, "!PREFIX__circumfix:sym<sigil>", $P8409)
    nqp_get_sc_object $P8410, "1305640934.989", 16
    get_how $P8411, $P8410
    nqp_get_sc_object $P8412, "1305640934.989", 16
    .const 'Sub' $P8413 = "302_1305640955.436" 
    $P8411."add_method"($P8412, "semilist", $P8413)
    nqp_get_sc_object $P8414, "1305640934.989", 16
    get_how $P8415, $P8414
    nqp_get_sc_object $P8416, "1305640934.989", 16
    .const 'Sub' $P8417 = "303_1305640955.436" 
    $P8415."add_method"($P8416, "!PREFIX__semilist", $P8417)
    nqp_get_sc_object $P8418, "1305640934.989", 16
    get_how $P8419, $P8418
    nqp_get_sc_object $P8420, "1305640934.989", 16
    .const 'Sub' $P8421 = "304_1305640955.436" 
    $P8419."add_method"($P8420, "infixish", $P8421)
    nqp_get_sc_object $P8422, "1305640934.989", 16
    get_how $P8423, $P8422
    nqp_get_sc_object $P8424, "1305640934.989", 16
    .const 'Sub' $P8425 = "305_1305640955.436" 
    $P8423."add_method"($P8424, "!PREFIX__infixish", $P8425)
    nqp_get_sc_object $P8426, "1305640934.989", 16
    get_how $P8427, $P8426
    nqp_get_sc_object $P8428, "1305640934.989", 16
    .const 'Sub' $P8429 = "306_1305640955.436" 
    $P8427."add_method"($P8428, "infixstopper", $P8429)
    nqp_get_sc_object $P8430, "1305640934.989", 16
    get_how $P8431, $P8430
    nqp_get_sc_object $P8432, "1305640934.989", 16
    .const 'Sub' $P8433 = "307_1305640955.436" 
    $P8431."add_method"($P8432, "!PREFIX__infixstopper", $P8433)
    nqp_get_sc_object $P8434, "1305640934.989", 16
    get_how $P8435, $P8434
    nqp_get_sc_object $P8436, "1305640934.989", 16
    .const 'Sub' $P8437 = "308_1305640955.436" 
    $P8435."add_method"($P8436, "postcircumfix:sym<[ ]>", $P8437)
    nqp_get_sc_object $P8438, "1305640934.989", 16
    get_how $P8439, $P8438
    nqp_get_sc_object $P8440, "1305640934.989", 16
    .const 'Sub' $P8441 = "309_1305640955.436" 
    $P8439."add_method"($P8440, "!PREFIX__postcircumfix:sym<[ ]>", $P8441)
    nqp_get_sc_object $P8442, "1305640934.989", 16
    get_how $P8443, $P8442
    nqp_get_sc_object $P8444, "1305640934.989", 16
    .const 'Sub' $P8445 = "310_1305640955.436" 
    $P8443."add_method"($P8444, "postcircumfix:sym<{ }>", $P8445)
    nqp_get_sc_object $P8446, "1305640934.989", 16
    get_how $P8447, $P8446
    nqp_get_sc_object $P8448, "1305640934.989", 16
    .const 'Sub' $P8449 = "311_1305640955.436" 
    $P8447."add_method"($P8448, "!PREFIX__postcircumfix:sym<{ }>", $P8449)
    nqp_get_sc_object $P8450, "1305640934.989", 16
    get_how $P8451, $P8450
    nqp_get_sc_object $P8452, "1305640934.989", 16
    .const 'Sub' $P8453 = "312_1305640955.436" 
    $P8451."add_method"($P8452, "postcircumfix:sym<ang>", $P8453)
    nqp_get_sc_object $P8454, "1305640934.989", 16
    get_how $P8455, $P8454
    nqp_get_sc_object $P8456, "1305640934.989", 16
    .const 'Sub' $P8457 = "313_1305640955.436" 
    $P8455."add_method"($P8456, "!PREFIX__postcircumfix:sym<ang>", $P8457)
    nqp_get_sc_object $P8458, "1305640934.989", 16
    get_how $P8459, $P8458
    nqp_get_sc_object $P8460, "1305640934.989", 16
    .const 'Sub' $P8461 = "314_1305640955.436" 
    $P8459."add_method"($P8460, "postcircumfix:sym<( )>", $P8461)
    nqp_get_sc_object $P8462, "1305640934.989", 16
    get_how $P8463, $P8462
    nqp_get_sc_object $P8464, "1305640934.989", 16
    .const 'Sub' $P8465 = "315_1305640955.436" 
    $P8463."add_method"($P8464, "!PREFIX__postcircumfix:sym<( )>", $P8465)
    nqp_get_sc_object $P8466, "1305640934.989", 16
    get_how $P8467, $P8466
    nqp_get_sc_object $P8468, "1305640934.989", 16
    .const 'Sub' $P8469 = "316_1305640955.436" 
    $P8467."add_method"($P8468, "postfix:sym<.>", $P8469)
    nqp_get_sc_object $P8470, "1305640934.989", 16
    get_how $P8471, $P8470
    nqp_get_sc_object $P8472, "1305640934.989", 16
    .const 'Sub' $P8473 = "317_1305640955.436" 
    $P8471."add_method"($P8472, "!PREFIX__postfix:sym<.>", $P8473)
    nqp_get_sc_object $P8474, "1305640934.989", 16
    get_how $P8475, $P8474
    nqp_get_sc_object $P8476, "1305640934.989", 16
    .const 'Sub' $P8477 = "318_1305640955.436" 
    $P8475."add_method"($P8476, "prefix:sym<++>", $P8477)
    nqp_get_sc_object $P8478, "1305640934.989", 16
    get_how $P8479, $P8478
    nqp_get_sc_object $P8480, "1305640934.989", 16
    .const 'Sub' $P8481 = "319_1305640955.436" 
    $P8479."add_method"($P8480, "!PREFIX__prefix:sym<++>", $P8481)
    nqp_get_sc_object $P8482, "1305640934.989", 16
    get_how $P8483, $P8482
    nqp_get_sc_object $P8484, "1305640934.989", 16
    .const 'Sub' $P8485 = "320_1305640955.436" 
    $P8483."add_method"($P8484, "prefix:sym<-->", $P8485)
    nqp_get_sc_object $P8486, "1305640934.989", 16
    get_how $P8487, $P8486
    nqp_get_sc_object $P8488, "1305640934.989", 16
    .const 'Sub' $P8489 = "321_1305640955.436" 
    $P8487."add_method"($P8488, "!PREFIX__prefix:sym<-->", $P8489)
    nqp_get_sc_object $P8490, "1305640934.989", 16
    get_how $P8491, $P8490
    nqp_get_sc_object $P8492, "1305640934.989", 16
    .const 'Sub' $P8493 = "322_1305640955.436" 
    $P8491."add_method"($P8492, "postfix:sym<++>", $P8493)
    nqp_get_sc_object $P8494, "1305640934.989", 16
    get_how $P8495, $P8494
    nqp_get_sc_object $P8496, "1305640934.989", 16
    .const 'Sub' $P8497 = "323_1305640955.436" 
    $P8495."add_method"($P8496, "!PREFIX__postfix:sym<++>", $P8497)
    nqp_get_sc_object $P8498, "1305640934.989", 16
    get_how $P8499, $P8498
    nqp_get_sc_object $P8500, "1305640934.989", 16
    .const 'Sub' $P8501 = "324_1305640955.436" 
    $P8499."add_method"($P8500, "postfix:sym<-->", $P8501)
    nqp_get_sc_object $P8502, "1305640934.989", 16
    get_how $P8503, $P8502
    nqp_get_sc_object $P8504, "1305640934.989", 16
    .const 'Sub' $P8505 = "325_1305640955.436" 
    $P8503."add_method"($P8504, "!PREFIX__postfix:sym<-->", $P8505)
    nqp_get_sc_object $P8506, "1305640934.989", 16
    get_how $P8507, $P8506
    nqp_get_sc_object $P8508, "1305640934.989", 16
    .const 'Sub' $P8509 = "326_1305640955.436" 
    $P8507."add_method"($P8508, "infix:sym<**>", $P8509)
    nqp_get_sc_object $P8510, "1305640934.989", 16
    get_how $P8511, $P8510
    nqp_get_sc_object $P8512, "1305640934.989", 16
    .const 'Sub' $P8513 = "327_1305640955.436" 
    $P8511."add_method"($P8512, "!PREFIX__infix:sym<**>", $P8513)
    nqp_get_sc_object $P8514, "1305640934.989", 16
    get_how $P8515, $P8514
    nqp_get_sc_object $P8516, "1305640934.989", 16
    .const 'Sub' $P8517 = "328_1305640955.436" 
    $P8515."add_method"($P8516, "prefix:sym<+>", $P8517)
    nqp_get_sc_object $P8518, "1305640934.989", 16
    get_how $P8519, $P8518
    nqp_get_sc_object $P8520, "1305640934.989", 16
    .const 'Sub' $P8521 = "329_1305640955.436" 
    $P8519."add_method"($P8520, "!PREFIX__prefix:sym<+>", $P8521)
    nqp_get_sc_object $P8522, "1305640934.989", 16
    get_how $P8523, $P8522
    nqp_get_sc_object $P8524, "1305640934.989", 16
    .const 'Sub' $P8525 = "330_1305640955.436" 
    $P8523."add_method"($P8524, "prefix:sym<~>", $P8525)
    nqp_get_sc_object $P8526, "1305640934.989", 16
    get_how $P8527, $P8526
    nqp_get_sc_object $P8528, "1305640934.989", 16
    .const 'Sub' $P8529 = "331_1305640955.436" 
    $P8527."add_method"($P8528, "!PREFIX__prefix:sym<~>", $P8529)
    nqp_get_sc_object $P8530, "1305640934.989", 16
    get_how $P8531, $P8530
    nqp_get_sc_object $P8532, "1305640934.989", 16
    .const 'Sub' $P8533 = "332_1305640955.436" 
    $P8531."add_method"($P8532, "prefix:sym<->", $P8533)
    nqp_get_sc_object $P8534, "1305640934.989", 16
    get_how $P8535, $P8534
    nqp_get_sc_object $P8536, "1305640934.989", 16
    .const 'Sub' $P8537 = "333_1305640955.436" 
    $P8535."add_method"($P8536, "!PREFIX__prefix:sym<->", $P8537)
    nqp_get_sc_object $P8538, "1305640934.989", 16
    get_how $P8539, $P8538
    nqp_get_sc_object $P8540, "1305640934.989", 16
    .const 'Sub' $P8541 = "334_1305640955.436" 
    $P8539."add_method"($P8540, "prefix:sym<?>", $P8541)
    nqp_get_sc_object $P8542, "1305640934.989", 16
    get_how $P8543, $P8542
    nqp_get_sc_object $P8544, "1305640934.989", 16
    .const 'Sub' $P8545 = "335_1305640955.436" 
    $P8543."add_method"($P8544, "!PREFIX__prefix:sym<?>", $P8545)
    nqp_get_sc_object $P8546, "1305640934.989", 16
    get_how $P8547, $P8546
    nqp_get_sc_object $P8548, "1305640934.989", 16
    .const 'Sub' $P8549 = "336_1305640955.436" 
    $P8547."add_method"($P8548, "prefix:sym<!>", $P8549)
    nqp_get_sc_object $P8550, "1305640934.989", 16
    get_how $P8551, $P8550
    nqp_get_sc_object $P8552, "1305640934.989", 16
    .const 'Sub' $P8553 = "337_1305640955.436" 
    $P8551."add_method"($P8552, "!PREFIX__prefix:sym<!>", $P8553)
    nqp_get_sc_object $P8554, "1305640934.989", 16
    get_how $P8555, $P8554
    nqp_get_sc_object $P8556, "1305640934.989", 16
    .const 'Sub' $P8557 = "338_1305640955.436" 
    $P8555."add_method"($P8556, "prefix:sym<|>", $P8557)
    nqp_get_sc_object $P8558, "1305640934.989", 16
    get_how $P8559, $P8558
    nqp_get_sc_object $P8560, "1305640934.989", 16
    .const 'Sub' $P8561 = "339_1305640955.436" 
    $P8559."add_method"($P8560, "!PREFIX__prefix:sym<|>", $P8561)
    nqp_get_sc_object $P8562, "1305640934.989", 16
    get_how $P8563, $P8562
    nqp_get_sc_object $P8564, "1305640934.989", 16
    .const 'Sub' $P8565 = "340_1305640955.436" 
    $P8563."add_method"($P8564, "infix:sym<*>", $P8565)
    nqp_get_sc_object $P8566, "1305640934.989", 16
    get_how $P8567, $P8566
    nqp_get_sc_object $P8568, "1305640934.989", 16
    .const 'Sub' $P8569 = "341_1305640955.436" 
    $P8567."add_method"($P8568, "!PREFIX__infix:sym<*>", $P8569)
    nqp_get_sc_object $P8570, "1305640934.989", 16
    get_how $P8571, $P8570
    nqp_get_sc_object $P8572, "1305640934.989", 16
    .const 'Sub' $P8573 = "342_1305640955.436" 
    $P8571."add_method"($P8572, "infix:sym</>", $P8573)
    nqp_get_sc_object $P8574, "1305640934.989", 16
    get_how $P8575, $P8574
    nqp_get_sc_object $P8576, "1305640934.989", 16
    .const 'Sub' $P8577 = "343_1305640955.436" 
    $P8575."add_method"($P8576, "!PREFIX__infix:sym</>", $P8577)
    nqp_get_sc_object $P8578, "1305640934.989", 16
    get_how $P8579, $P8578
    nqp_get_sc_object $P8580, "1305640934.989", 16
    .const 'Sub' $P8581 = "344_1305640955.436" 
    $P8579."add_method"($P8580, "infix:sym<%>", $P8581)
    nqp_get_sc_object $P8582, "1305640934.989", 16
    get_how $P8583, $P8582
    nqp_get_sc_object $P8584, "1305640934.989", 16
    .const 'Sub' $P8585 = "345_1305640955.436" 
    $P8583."add_method"($P8584, "!PREFIX__infix:sym<%>", $P8585)
    nqp_get_sc_object $P8586, "1305640934.989", 16
    get_how $P8587, $P8586
    nqp_get_sc_object $P8588, "1305640934.989", 16
    .const 'Sub' $P8589 = "346_1305640955.436" 
    $P8587."add_method"($P8588, "infix:sym<+&>", $P8589)
    nqp_get_sc_object $P8590, "1305640934.989", 16
    get_how $P8591, $P8590
    nqp_get_sc_object $P8592, "1305640934.989", 16
    .const 'Sub' $P8593 = "347_1305640955.436" 
    $P8591."add_method"($P8592, "!PREFIX__infix:sym<+&>", $P8593)
    nqp_get_sc_object $P8594, "1305640934.989", 16
    get_how $P8595, $P8594
    nqp_get_sc_object $P8596, "1305640934.989", 16
    .const 'Sub' $P8597 = "348_1305640955.436" 
    $P8595."add_method"($P8596, "infix:sym<+>", $P8597)
    nqp_get_sc_object $P8598, "1305640934.989", 16
    get_how $P8599, $P8598
    nqp_get_sc_object $P8600, "1305640934.989", 16
    .const 'Sub' $P8601 = "349_1305640955.436" 
    $P8599."add_method"($P8600, "!PREFIX__infix:sym<+>", $P8601)
    nqp_get_sc_object $P8602, "1305640934.989", 16
    get_how $P8603, $P8602
    nqp_get_sc_object $P8604, "1305640934.989", 16
    .const 'Sub' $P8605 = "350_1305640955.436" 
    $P8603."add_method"($P8604, "infix:sym<->", $P8605)
    nqp_get_sc_object $P8606, "1305640934.989", 16
    get_how $P8607, $P8606
    nqp_get_sc_object $P8608, "1305640934.989", 16
    .const 'Sub' $P8609 = "351_1305640955.436" 
    $P8607."add_method"($P8608, "!PREFIX__infix:sym<->", $P8609)
    nqp_get_sc_object $P8610, "1305640934.989", 16
    get_how $P8611, $P8610
    nqp_get_sc_object $P8612, "1305640934.989", 16
    .const 'Sub' $P8613 = "352_1305640955.436" 
    $P8611."add_method"($P8612, "infix:sym<+|>", $P8613)
    nqp_get_sc_object $P8614, "1305640934.989", 16
    get_how $P8615, $P8614
    nqp_get_sc_object $P8616, "1305640934.989", 16
    .const 'Sub' $P8617 = "353_1305640955.436" 
    $P8615."add_method"($P8616, "!PREFIX__infix:sym<+|>", $P8617)
    nqp_get_sc_object $P8618, "1305640934.989", 16
    get_how $P8619, $P8618
    nqp_get_sc_object $P8620, "1305640934.989", 16
    .const 'Sub' $P8621 = "354_1305640955.436" 
    $P8619."add_method"($P8620, "infix:sym<+^>", $P8621)
    nqp_get_sc_object $P8622, "1305640934.989", 16
    get_how $P8623, $P8622
    nqp_get_sc_object $P8624, "1305640934.989", 16
    .const 'Sub' $P8625 = "355_1305640955.436" 
    $P8623."add_method"($P8624, "!PREFIX__infix:sym<+^>", $P8625)
    nqp_get_sc_object $P8626, "1305640934.989", 16
    get_how $P8627, $P8626
    nqp_get_sc_object $P8628, "1305640934.989", 16
    .const 'Sub' $P8629 = "356_1305640955.436" 
    $P8627."add_method"($P8628, "infix:sym<~>", $P8629)
    nqp_get_sc_object $P8630, "1305640934.989", 16
    get_how $P8631, $P8630
    nqp_get_sc_object $P8632, "1305640934.989", 16
    .const 'Sub' $P8633 = "357_1305640955.436" 
    $P8631."add_method"($P8632, "!PREFIX__infix:sym<~>", $P8633)
    nqp_get_sc_object $P8634, "1305640934.989", 16
    get_how $P8635, $P8634
    nqp_get_sc_object $P8636, "1305640934.989", 16
    .const 'Sub' $P8637 = "358_1305640955.436" 
    $P8635."add_method"($P8636, "infix:sym<==>", $P8637)
    nqp_get_sc_object $P8638, "1305640934.989", 16
    get_how $P8639, $P8638
    nqp_get_sc_object $P8640, "1305640934.989", 16
    .const 'Sub' $P8641 = "359_1305640955.436" 
    $P8639."add_method"($P8640, "!PREFIX__infix:sym<==>", $P8641)
    nqp_get_sc_object $P8642, "1305640934.989", 16
    get_how $P8643, $P8642
    nqp_get_sc_object $P8644, "1305640934.989", 16
    .const 'Sub' $P8645 = "360_1305640955.436" 
    $P8643."add_method"($P8644, "infix:sym<!=>", $P8645)
    nqp_get_sc_object $P8646, "1305640934.989", 16
    get_how $P8647, $P8646
    nqp_get_sc_object $P8648, "1305640934.989", 16
    .const 'Sub' $P8649 = "361_1305640955.436" 
    $P8647."add_method"($P8648, "!PREFIX__infix:sym<!=>", $P8649)
    nqp_get_sc_object $P8650, "1305640934.989", 16
    get_how $P8651, $P8650
    nqp_get_sc_object $P8652, "1305640934.989", 16
    .const 'Sub' $P8653 = "362_1305640955.436" 
    $P8651."add_method"($P8652, "infix:sym<<=>", $P8653)
    nqp_get_sc_object $P8654, "1305640934.989", 16
    get_how $P8655, $P8654
    nqp_get_sc_object $P8656, "1305640934.989", 16
    .const 'Sub' $P8657 = "363_1305640955.436" 
    $P8655."add_method"($P8656, "!PREFIX__infix:sym<<=>", $P8657)
    nqp_get_sc_object $P8658, "1305640934.989", 16
    get_how $P8659, $P8658
    nqp_get_sc_object $P8660, "1305640934.989", 16
    .const 'Sub' $P8661 = "364_1305640955.436" 
    $P8659."add_method"($P8660, "infix:sym<>=>", $P8661)
    nqp_get_sc_object $P8662, "1305640934.989", 16
    get_how $P8663, $P8662
    nqp_get_sc_object $P8664, "1305640934.989", 16
    .const 'Sub' $P8665 = "365_1305640955.436" 
    $P8663."add_method"($P8664, "!PREFIX__infix:sym<>=>", $P8665)
    nqp_get_sc_object $P8666, "1305640934.989", 16
    get_how $P8667, $P8666
    nqp_get_sc_object $P8668, "1305640934.989", 16
    .const 'Sub' $P8669 = "366_1305640955.436" 
    $P8667."add_method"($P8668, "infix:sym<<>", $P8669)
    nqp_get_sc_object $P8670, "1305640934.989", 16
    get_how $P8671, $P8670
    nqp_get_sc_object $P8672, "1305640934.989", 16
    .const 'Sub' $P8673 = "367_1305640955.436" 
    $P8671."add_method"($P8672, "!PREFIX__infix:sym<<>", $P8673)
    nqp_get_sc_object $P8674, "1305640934.989", 16
    get_how $P8675, $P8674
    nqp_get_sc_object $P8676, "1305640934.989", 16
    .const 'Sub' $P8677 = "368_1305640955.436" 
    $P8675."add_method"($P8676, "infix:sym<>>", $P8677)
    nqp_get_sc_object $P8678, "1305640934.989", 16
    get_how $P8679, $P8678
    nqp_get_sc_object $P8680, "1305640934.989", 16
    .const 'Sub' $P8681 = "369_1305640955.436" 
    $P8679."add_method"($P8680, "!PREFIX__infix:sym<>>", $P8681)
    nqp_get_sc_object $P8682, "1305640934.989", 16
    get_how $P8683, $P8682
    nqp_get_sc_object $P8684, "1305640934.989", 16
    .const 'Sub' $P8685 = "370_1305640955.436" 
    $P8683."add_method"($P8684, "infix:sym<eq>", $P8685)
    nqp_get_sc_object $P8686, "1305640934.989", 16
    get_how $P8687, $P8686
    nqp_get_sc_object $P8688, "1305640934.989", 16
    .const 'Sub' $P8689 = "371_1305640955.436" 
    $P8687."add_method"($P8688, "!PREFIX__infix:sym<eq>", $P8689)
    nqp_get_sc_object $P8690, "1305640934.989", 16
    get_how $P8691, $P8690
    nqp_get_sc_object $P8692, "1305640934.989", 16
    .const 'Sub' $P8693 = "372_1305640955.436" 
    $P8691."add_method"($P8692, "infix:sym<ne>", $P8693)
    nqp_get_sc_object $P8694, "1305640934.989", 16
    get_how $P8695, $P8694
    nqp_get_sc_object $P8696, "1305640934.989", 16
    .const 'Sub' $P8697 = "373_1305640955.436" 
    $P8695."add_method"($P8696, "!PREFIX__infix:sym<ne>", $P8697)
    nqp_get_sc_object $P8698, "1305640934.989", 16
    get_how $P8699, $P8698
    nqp_get_sc_object $P8700, "1305640934.989", 16
    .const 'Sub' $P8701 = "374_1305640955.436" 
    $P8699."add_method"($P8700, "infix:sym<le>", $P8701)
    nqp_get_sc_object $P8702, "1305640934.989", 16
    get_how $P8703, $P8702
    nqp_get_sc_object $P8704, "1305640934.989", 16
    .const 'Sub' $P8705 = "375_1305640955.436" 
    $P8703."add_method"($P8704, "!PREFIX__infix:sym<le>", $P8705)
    nqp_get_sc_object $P8706, "1305640934.989", 16
    get_how $P8707, $P8706
    nqp_get_sc_object $P8708, "1305640934.989", 16
    .const 'Sub' $P8709 = "376_1305640955.436" 
    $P8707."add_method"($P8708, "infix:sym<ge>", $P8709)
    nqp_get_sc_object $P8710, "1305640934.989", 16
    get_how $P8711, $P8710
    nqp_get_sc_object $P8712, "1305640934.989", 16
    .const 'Sub' $P8713 = "377_1305640955.436" 
    $P8711."add_method"($P8712, "!PREFIX__infix:sym<ge>", $P8713)
    nqp_get_sc_object $P8714, "1305640934.989", 16
    get_how $P8715, $P8714
    nqp_get_sc_object $P8716, "1305640934.989", 16
    .const 'Sub' $P8717 = "378_1305640955.436" 
    $P8715."add_method"($P8716, "infix:sym<lt>", $P8717)
    nqp_get_sc_object $P8718, "1305640934.989", 16
    get_how $P8719, $P8718
    nqp_get_sc_object $P8720, "1305640934.989", 16
    .const 'Sub' $P8721 = "379_1305640955.436" 
    $P8719."add_method"($P8720, "!PREFIX__infix:sym<lt>", $P8721)
    nqp_get_sc_object $P8722, "1305640934.989", 16
    get_how $P8723, $P8722
    nqp_get_sc_object $P8724, "1305640934.989", 16
    .const 'Sub' $P8725 = "380_1305640955.436" 
    $P8723."add_method"($P8724, "infix:sym<gt>", $P8725)
    nqp_get_sc_object $P8726, "1305640934.989", 16
    get_how $P8727, $P8726
    nqp_get_sc_object $P8728, "1305640934.989", 16
    .const 'Sub' $P8729 = "381_1305640955.436" 
    $P8727."add_method"($P8728, "!PREFIX__infix:sym<gt>", $P8729)
    nqp_get_sc_object $P8730, "1305640934.989", 16
    get_how $P8731, $P8730
    nqp_get_sc_object $P8732, "1305640934.989", 16
    .const 'Sub' $P8733 = "382_1305640955.436" 
    $P8731."add_method"($P8732, "infix:sym<=:=>", $P8733)
    nqp_get_sc_object $P8734, "1305640934.989", 16
    get_how $P8735, $P8734
    nqp_get_sc_object $P8736, "1305640934.989", 16
    .const 'Sub' $P8737 = "383_1305640955.436" 
    $P8735."add_method"($P8736, "!PREFIX__infix:sym<=:=>", $P8737)
    nqp_get_sc_object $P8738, "1305640934.989", 16
    get_how $P8739, $P8738
    nqp_get_sc_object $P8740, "1305640934.989", 16
    .const 'Sub' $P8741 = "384_1305640955.436" 
    $P8739."add_method"($P8740, "infix:sym<~~>", $P8741)
    nqp_get_sc_object $P8742, "1305640934.989", 16
    get_how $P8743, $P8742
    nqp_get_sc_object $P8744, "1305640934.989", 16
    .const 'Sub' $P8745 = "385_1305640955.436" 
    $P8743."add_method"($P8744, "!PREFIX__infix:sym<~~>", $P8745)
    nqp_get_sc_object $P8746, "1305640934.989", 16
    get_how $P8747, $P8746
    nqp_get_sc_object $P8748, "1305640934.989", 16
    .const 'Sub' $P8749 = "386_1305640955.436" 
    $P8747."add_method"($P8748, "infix:sym<&&>", $P8749)
    nqp_get_sc_object $P8750, "1305640934.989", 16
    get_how $P8751, $P8750
    nqp_get_sc_object $P8752, "1305640934.989", 16
    .const 'Sub' $P8753 = "387_1305640955.436" 
    $P8751."add_method"($P8752, "!PREFIX__infix:sym<&&>", $P8753)
    nqp_get_sc_object $P8754, "1305640934.989", 16
    get_how $P8755, $P8754
    nqp_get_sc_object $P8756, "1305640934.989", 16
    .const 'Sub' $P8757 = "388_1305640955.436" 
    $P8755."add_method"($P8756, "infix:sym<||>", $P8757)
    nqp_get_sc_object $P8758, "1305640934.989", 16
    get_how $P8759, $P8758
    nqp_get_sc_object $P8760, "1305640934.989", 16
    .const 'Sub' $P8761 = "389_1305640955.436" 
    $P8759."add_method"($P8760, "!PREFIX__infix:sym<||>", $P8761)
    nqp_get_sc_object $P8762, "1305640934.989", 16
    get_how $P8763, $P8762
    nqp_get_sc_object $P8764, "1305640934.989", 16
    .const 'Sub' $P8765 = "390_1305640955.436" 
    $P8763."add_method"($P8764, "infix:sym<//>", $P8765)
    nqp_get_sc_object $P8766, "1305640934.989", 16
    get_how $P8767, $P8766
    nqp_get_sc_object $P8768, "1305640934.989", 16
    .const 'Sub' $P8769 = "391_1305640955.436" 
    $P8767."add_method"($P8768, "!PREFIX__infix:sym<//>", $P8769)
    nqp_get_sc_object $P8770, "1305640934.989", 16
    get_how $P8771, $P8770
    nqp_get_sc_object $P8772, "1305640934.989", 16
    .const 'Sub' $P8773 = "392_1305640955.436" 
    $P8771."add_method"($P8772, "infix:sym<?? !!>", $P8773)
    nqp_get_sc_object $P8774, "1305640934.989", 16
    get_how $P8775, $P8774
    nqp_get_sc_object $P8776, "1305640934.989", 16
    .const 'Sub' $P8777 = "393_1305640955.436" 
    $P8775."add_method"($P8776, "!PREFIX__infix:sym<?? !!>", $P8777)
    nqp_get_sc_object $P8778, "1305640934.989", 16
    get_how $P8779, $P8778
    nqp_get_sc_object $P8780, "1305640934.989", 16
    .const 'Sub' $P8781 = "394_1305640955.436" 
    $P8779."add_method"($P8780, "infix:sym<=>", $P8781)
    nqp_get_sc_object $P8782, "1305640934.989", 16
    get_how $P8783, $P8782
    nqp_get_sc_object $P8784, "1305640934.989", 16
    .const 'Sub' $P8785 = "395_1305640955.436" 
    $P8783."add_method"($P8784, "!PREFIX__infix:sym<=>", $P8785)
    nqp_get_sc_object $P8786, "1305640934.989", 16
    get_how $P8787, $P8786
    nqp_get_sc_object $P8788, "1305640934.989", 16
    .const 'Sub' $P8789 = "396_1305640955.436" 
    $P8787."add_method"($P8788, "infix:sym<:=>", $P8789)
    nqp_get_sc_object $P8790, "1305640934.989", 16
    get_how $P8791, $P8790
    nqp_get_sc_object $P8792, "1305640934.989", 16
    .const 'Sub' $P8793 = "397_1305640955.436" 
    $P8791."add_method"($P8792, "!PREFIX__infix:sym<:=>", $P8793)
    nqp_get_sc_object $P8794, "1305640934.989", 16
    get_how $P8795, $P8794
    nqp_get_sc_object $P8796, "1305640934.989", 16
    .const 'Sub' $P8797 = "398_1305640955.436" 
    $P8795."add_method"($P8796, "infix:sym<::=>", $P8797)
    nqp_get_sc_object $P8798, "1305640934.989", 16
    get_how $P8799, $P8798
    nqp_get_sc_object $P8800, "1305640934.989", 16
    .const 'Sub' $P8801 = "399_1305640955.436" 
    $P8799."add_method"($P8800, "!PREFIX__infix:sym<::=>", $P8801)
    nqp_get_sc_object $P8802, "1305640934.989", 16
    get_how $P8803, $P8802
    nqp_get_sc_object $P8804, "1305640934.989", 16
    .const 'Sub' $P8805 = "400_1305640955.436" 
    $P8803."add_method"($P8804, "infix:sym<,>", $P8805)
    nqp_get_sc_object $P8806, "1305640934.989", 16
    get_how $P8807, $P8806
    nqp_get_sc_object $P8808, "1305640934.989", 16
    .const 'Sub' $P8809 = "401_1305640955.436" 
    $P8807."add_method"($P8808, "!PREFIX__infix:sym<,>", $P8809)
    nqp_get_sc_object $P8810, "1305640934.989", 16
    get_how $P8811, $P8810
    nqp_get_sc_object $P8812, "1305640934.989", 16
    .const 'Sub' $P8813 = "402_1305640955.436" 
    $P8811."add_method"($P8812, "prefix:sym<return>", $P8813)
    nqp_get_sc_object $P8814, "1305640934.989", 16
    get_how $P8815, $P8814
    nqp_get_sc_object $P8816, "1305640934.989", 16
    .const 'Sub' $P8817 = "404_1305640955.436" 
    $P8815."add_method"($P8816, "!PREFIX__prefix:sym<return>", $P8817)
    nqp_get_sc_object $P8818, "1305640934.989", 16
    get_how $P8819, $P8818
    nqp_get_sc_object $P8820, "1305640934.989", 16
    .const 'Sub' $P8821 = "405_1305640955.436" 
    $P8819."add_method"($P8820, "prefix:sym<make>", $P8821)
    nqp_get_sc_object $P8822, "1305640934.989", 16
    get_how $P8823, $P8822
    nqp_get_sc_object $P8824, "1305640934.989", 16
    .const 'Sub' $P8825 = "406_1305640955.436" 
    $P8823."add_method"($P8824, "!PREFIX__prefix:sym<make>", $P8825)
    nqp_get_sc_object $P8826, "1305640934.989", 16
    get_how $P8827, $P8826
    nqp_get_sc_object $P8828, "1305640934.989", 16
    .const 'Sub' $P8829 = "407_1305640955.436" 
    $P8827."add_method"($P8828, "term:sym<last>", $P8829)
    nqp_get_sc_object $P8830, "1305640934.989", 16
    get_how $P8831, $P8830
    nqp_get_sc_object $P8832, "1305640934.989", 16
    .const 'Sub' $P8833 = "408_1305640955.436" 
    $P8831."add_method"($P8832, "!PREFIX__term:sym<last>", $P8833)
    nqp_get_sc_object $P8834, "1305640934.989", 16
    get_how $P8835, $P8834
    nqp_get_sc_object $P8836, "1305640934.989", 16
    .const 'Sub' $P8837 = "409_1305640955.436" 
    $P8835."add_method"($P8836, "term:sym<next>", $P8837)
    nqp_get_sc_object $P8838, "1305640934.989", 16
    get_how $P8839, $P8838
    nqp_get_sc_object $P8840, "1305640934.989", 16
    .const 'Sub' $P8841 = "410_1305640955.436" 
    $P8839."add_method"($P8840, "!PREFIX__term:sym<next>", $P8841)
    nqp_get_sc_object $P8842, "1305640934.989", 16
    get_how $P8843, $P8842
    nqp_get_sc_object $P8844, "1305640934.989", 16
    .const 'Sub' $P8845 = "411_1305640955.436" 
    $P8843."add_method"($P8844, "term:sym<redo>", $P8845)
    nqp_get_sc_object $P8846, "1305640934.989", 16
    get_how $P8847, $P8846
    nqp_get_sc_object $P8848, "1305640934.989", 16
    .const 'Sub' $P8849 = "412_1305640955.436" 
    $P8847."add_method"($P8848, "!PREFIX__term:sym<redo>", $P8849)
    nqp_get_sc_object $P8850, "1305640934.989", 16
    get_how $P8851, $P8850
    nqp_get_sc_object $P8852, "1305640934.989", 16
    .const 'Sub' $P8853 = "413_1305640955.436" 
    $P8851."add_method"($P8852, "smartmatch", $P8853)
    .const 'Sub' $P8854 = "39_1305640955.436" 
    $P8855 = $P8854."get_lexinfo"()
    nqp_get_sc_object $P8856, "1305640934.989", 16
    $P8855."set_static_lexpad_value"("$?PACKAGE", $P8856)
    .const 'Sub' $P8857 = "39_1305640955.436" 
    $P8858 = $P8857."get_lexinfo"()
    $P8858."finish_static_lexpad"()
    .const 'Sub' $P8859 = "39_1305640955.436" 
    $P8860 = $P8859."get_lexinfo"()
    nqp_get_sc_object $P8861, "1305640934.989", 16
    $P8860."set_static_lexpad_value"("$?CLASS", $P8861)
    .const 'Sub' $P8862 = "39_1305640955.436" 
    $P8863 = $P8862."get_lexinfo"()
    $P8863."finish_static_lexpad"()
    nqp_get_sc_object $P8864, "1305640934.989", 16
    get_how $P8865, $P8864
    nqp_get_sc_object $P8866, "1305640934.989", 16
    nqp_get_sc_object $P8867, "1305640910.362", 1
    $P8865."add_parent"($P8866, $P8867)
    nqp_get_sc_object $P8868, "1305640934.989", 16
    get_how $P8869, $P8868
    nqp_get_sc_object $P8870, "1305640934.989", 16
    $P8869."compose"($P8870)
    nqp_get_sc_object $P8871, "1305640898.961", 41
    $P8872 = $P8871."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P8872, cur_sc
    nqp_set_sc_object "1305640934.989", 377, $P8872
    nqp_get_sc_object $P8873, "1305640934.989", 377
    nqp_get_sc_object $P8874, "1305640934.989", 0
    nqp_get_package_through_who $P8875, $P8874, "NQP"
    get_who $P8876, $P8875
    set $P8876["Regex"], $P8873
    nqp_get_sc_object $P8877, "1305640934.989", 377
    get_how $P8878, $P8877
    nqp_get_sc_object $P8879, "1305640934.989", 377
    .const 'Sub' $P8880 = "415_1305640955.436" 
    $P8878."add_method"($P8879, "metachar:sym<:my>", $P8880)
    nqp_get_sc_object $P8881, "1305640934.989", 377
    get_how $P8882, $P8881
    nqp_get_sc_object $P8883, "1305640934.989", 377
    .const 'Sub' $P8884 = "417_1305640955.436" 
    $P8882."add_method"($P8883, "!PREFIX__metachar:sym<:my>", $P8884)
    nqp_get_sc_object $P8885, "1305640934.989", 377
    get_how $P8886, $P8885
    nqp_get_sc_object $P8887, "1305640934.989", 377
    .const 'Sub' $P8888 = "418_1305640955.436" 
    $P8886."add_method"($P8887, "metachar:sym<{ }>", $P8888)
    nqp_get_sc_object $P8889, "1305640934.989", 377
    get_how $P8890, $P8889
    nqp_get_sc_object $P8891, "1305640934.989", 377
    .const 'Sub' $P8892 = "419_1305640955.436" 
    $P8890."add_method"($P8891, "!PREFIX__metachar:sym<{ }>", $P8892)
    nqp_get_sc_object $P8893, "1305640934.989", 377
    get_how $P8894, $P8893
    nqp_get_sc_object $P8895, "1305640934.989", 377
    .const 'Sub' $P8896 = "420_1305640955.436" 
    $P8894."add_method"($P8895, "metachar:sym<nqpvar>", $P8896)
    nqp_get_sc_object $P8897, "1305640934.989", 377
    get_how $P8898, $P8897
    nqp_get_sc_object $P8899, "1305640934.989", 377
    .const 'Sub' $P8900 = "422_1305640955.436" 
    $P8898."add_method"($P8899, "!PREFIX__metachar:sym<nqpvar>", $P8900)
    nqp_get_sc_object $P8901, "1305640934.989", 377
    get_how $P8902, $P8901
    nqp_get_sc_object $P8903, "1305640934.989", 377
    .const 'Sub' $P8904 = "423_1305640955.436" 
    $P8902."add_method"($P8903, "assertion:sym<{ }>", $P8904)
    nqp_get_sc_object $P8905, "1305640934.989", 377
    get_how $P8906, $P8905
    nqp_get_sc_object $P8907, "1305640934.989", 377
    .const 'Sub' $P8908 = "424_1305640955.436" 
    $P8906."add_method"($P8907, "!PREFIX__assertion:sym<{ }>", $P8908)
    nqp_get_sc_object $P8909, "1305640934.989", 377
    get_how $P8910, $P8909
    nqp_get_sc_object $P8911, "1305640934.989", 377
    .const 'Sub' $P8912 = "425_1305640955.436" 
    $P8910."add_method"($P8911, "assertion:sym<?{ }>", $P8912)
    nqp_get_sc_object $P8913, "1305640934.989", 377
    get_how $P8914, $P8913
    nqp_get_sc_object $P8915, "1305640934.989", 377
    .const 'Sub' $P8916 = "427_1305640955.436" 
    $P8914."add_method"($P8915, "!PREFIX__assertion:sym<?{ }>", $P8916)
    nqp_get_sc_object $P8917, "1305640934.989", 377
    get_how $P8918, $P8917
    nqp_get_sc_object $P8919, "1305640934.989", 377
    .const 'Sub' $P8920 = "428_1305640955.436" 
    $P8918."add_method"($P8919, "assertion:sym<name>", $P8920)
    nqp_get_sc_object $P8921, "1305640934.989", 377
    get_how $P8922, $P8921
    nqp_get_sc_object $P8923, "1305640934.989", 377
    .const 'Sub' $P8924 = "430_1305640955.436" 
    $P8922."add_method"($P8923, "!PREFIX__assertion:sym<name>", $P8924)
    nqp_get_sc_object $P8925, "1305640934.989", 377
    get_how $P8926, $P8925
    nqp_get_sc_object $P8927, "1305640934.989", 377
    .const 'Sub' $P8928 = "431_1305640955.436" 
    $P8926."add_method"($P8927, "assertion:sym<var>", $P8928)
    nqp_get_sc_object $P8929, "1305640934.989", 377
    get_how $P8930, $P8929
    nqp_get_sc_object $P8931, "1305640934.989", 377
    .const 'Sub' $P8932 = "432_1305640955.436" 
    $P8930."add_method"($P8931, "!PREFIX__assertion:sym<var>", $P8932)
    nqp_get_sc_object $P8933, "1305640934.989", 377
    get_how $P8934, $P8933
    nqp_get_sc_object $P8935, "1305640934.989", 377
    .const 'Sub' $P8936 = "433_1305640955.436" 
    $P8934."add_method"($P8935, "codeblock", $P8936)
    nqp_get_sc_object $P8937, "1305640934.989", 377
    get_how $P8938, $P8937
    nqp_get_sc_object $P8939, "1305640934.989", 377
    .const 'Sub' $P8940 = "434_1305640955.436" 
    $P8938."add_method"($P8939, "!PREFIX__codeblock", $P8940)
    .const 'Sub' $P8941 = "414_1305640955.436" 
    $P8942 = $P8941."get_lexinfo"()
    nqp_get_sc_object $P8943, "1305640934.989", 377
    $P8942."set_static_lexpad_value"("$?PACKAGE", $P8943)
    .const 'Sub' $P8944 = "414_1305640955.436" 
    $P8945 = $P8944."get_lexinfo"()
    $P8945."finish_static_lexpad"()
    .const 'Sub' $P8946 = "414_1305640955.436" 
    $P8947 = $P8946."get_lexinfo"()
    nqp_get_sc_object $P8948, "1305640934.989", 377
    $P8947."set_static_lexpad_value"("$?CLASS", $P8948)
    .const 'Sub' $P8949 = "414_1305640955.436" 
    $P8950 = $P8949."get_lexinfo"()
    $P8950."finish_static_lexpad"()
    nqp_get_sc_object $P8951, "1305640934.989", 377
    get_how $P8952, $P8951
    nqp_get_sc_object $P8953, "1305640934.989", 377
    nqp_get_sc_object $P8954, "1305640924.811", 1
    $P8952."add_parent"($P8953, $P8954)
    nqp_get_sc_object $P8955, "1305640934.989", 377
    get_how $P8956, $P8955
    nqp_get_sc_object $P8957, "1305640934.989", 377
    $P8956."compose"($P8957)
    nqp_get_sc_object $P8958, "1305640898.961", 41
    $P8959 = $P8958."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P8959, cur_sc
    nqp_set_sc_object "1305640934.989", 394, $P8959
    nqp_get_sc_object $P8960, "1305640934.989", 394
    nqp_get_sc_object $P8961, "1305640934.989", 0
    nqp_get_package_through_who $P8962, $P8961, "NQP"
    get_who $P8963, $P8962
    set $P8963["Actions"], $P8960
    nqp_get_sc_object $P8964, "1305640934.989", 394
    get_how $P8965, $P8964
    nqp_get_sc_object $P8966, "1305640934.989", 394
    .const 'Sub' $P8967 = "462_1305640955.436" 
    $P8965."add_method"($P8966, "TOP", $P8967)
    nqp_get_sc_object $P8968, "1305640934.989", 394
    get_how $P8969, $P8968
    nqp_get_sc_object $P8970, "1305640934.989", 394
    .const 'Sub' $P8971 = "463_1305640955.436" 
    $P8969."add_method"($P8970, "deflongname", $P8971)
    nqp_get_sc_object $P8972, "1305640934.989", 394
    get_how $P8973, $P8972
    nqp_get_sc_object $P8974, "1305640934.989", 394
    .const 'Sub' $P8975 = "464_1305640955.436" 
    $P8973."add_method"($P8974, "comp_unit", $P8975)
    nqp_get_sc_object $P8976, "1305640934.989", 394
    get_how $P8977, $P8976
    nqp_get_sc_object $P8978, "1305640934.989", 394
    .const 'Sub' $P8979 = "465_1305640955.436" 
    $P8977."add_method"($P8978, "statementlist", $P8979)
    nqp_get_sc_object $P8980, "1305640934.989", 394
    get_how $P8981, $P8980
    nqp_get_sc_object $P8982, "1305640934.989", 394
    .const 'Sub' $P8983 = "467_1305640955.436" 
    $P8981."add_method"($P8982, "statement", $P8983)
    nqp_get_sc_object $P8984, "1305640934.989", 394
    get_how $P8985, $P8984
    nqp_get_sc_object $P8986, "1305640934.989", 394
    .const 'Sub' $P8987 = "469_1305640955.436" 
    $P8985."add_method"($P8986, "xblock", $P8987)
    nqp_get_sc_object $P8988, "1305640934.989", 394
    get_how $P8989, $P8988
    nqp_get_sc_object $P8990, "1305640934.989", 394
    .const 'Sub' $P8991 = "470_1305640955.436" 
    $P8989."add_method"($P8990, "pblock", $P8991)
    nqp_get_sc_object $P8992, "1305640934.989", 394
    get_how $P8993, $P8992
    nqp_get_sc_object $P8994, "1305640934.989", 394
    .const 'Sub' $P8995 = "471_1305640955.436" 
    $P8993."add_method"($P8994, "block", $P8995)
    nqp_get_sc_object $P8996, "1305640934.989", 394
    get_how $P8997, $P8996
    nqp_get_sc_object $P8998, "1305640934.989", 394
    .const 'Sub' $P8999 = "472_1305640955.436" 
    $P8997."add_method"($P8998, "blockoid", $P8999)
    nqp_get_sc_object $P9000, "1305640934.989", 394
    get_how $P9001, $P9000
    nqp_get_sc_object $P9002, "1305640934.989", 394
    .const 'Sub' $P9003 = "474_1305640955.436" 
    $P9001."add_method"($P9002, "newpad", $P9003)
    nqp_get_sc_object $P9004, "1305640934.989", 394
    get_how $P9005, $P9004
    nqp_get_sc_object $P9006, "1305640934.989", 394
    .const 'Sub' $P9007 = "475_1305640955.436" 
    $P9005."add_method"($P9006, "outerctx", $P9007)
    nqp_get_sc_object $P9008, "1305640934.989", 394
    get_how $P9009, $P9008
    nqp_get_sc_object $P9010, "1305640934.989", 394
    .const 'Sub' $P9011 = "477_1305640955.436" 
    $P9009."add_method"($P9010, "GLOBALish", $P9011)
    nqp_get_sc_object $P9012, "1305640934.989", 394
    get_how $P9013, $P9012
    nqp_get_sc_object $P9014, "1305640934.989", 394
    .const 'Sub' $P9015 = "478_1305640955.436" 
    $P9013."add_method"($P9014, "you_are_here", $P9015)
    nqp_get_sc_object $P9016, "1305640934.989", 394
    get_how $P9017, $P9016
    nqp_get_sc_object $P9018, "1305640934.989", 394
    .const 'Sub' $P9019 = "479_1305640955.436" 
    $P9017."add_method"($P9018, "statement_control:sym<use>", $P9019)
    nqp_get_sc_object $P9020, "1305640934.989", 394
    get_how $P9021, $P9020
    nqp_get_sc_object $P9022, "1305640934.989", 394
    .const 'Sub' $P9023 = "480_1305640955.436" 
    $P9021."add_method"($P9022, "statement_control:sym<if>", $P9023)
    nqp_get_sc_object $P9024, "1305640934.989", 394
    get_how $P9025, $P9024
    nqp_get_sc_object $P9026, "1305640934.989", 394
    .const 'Sub' $P9027 = "482_1305640955.436" 
    $P9025."add_method"($P9026, "statement_control:sym<unless>", $P9027)
    nqp_get_sc_object $P9028, "1305640934.989", 394
    get_how $P9029, $P9028
    nqp_get_sc_object $P9030, "1305640934.989", 394
    .const 'Sub' $P9031 = "483_1305640955.436" 
    $P9029."add_method"($P9030, "statement_control:sym<while>", $P9031)
    nqp_get_sc_object $P9032, "1305640934.989", 394
    get_how $P9033, $P9032
    nqp_get_sc_object $P9034, "1305640934.989", 394
    .const 'Sub' $P9035 = "484_1305640955.436" 
    $P9033."add_method"($P9034, "statement_control:sym<repeat>", $P9035)
    nqp_get_sc_object $P9036, "1305640934.989", 394
    get_how $P9037, $P9036
    nqp_get_sc_object $P9038, "1305640934.989", 394
    .const 'Sub' $P9039 = "485_1305640955.436" 
    $P9037."add_method"($P9038, "statement_control:sym<for>", $P9039)
    nqp_get_sc_object $P9040, "1305640934.989", 394
    get_how $P9041, $P9040
    nqp_get_sc_object $P9042, "1305640934.989", 394
    .const 'Sub' $P9043 = "486_1305640955.436" 
    $P9041."add_method"($P9042, "statement_control:sym<CATCH>", $P9043)
    nqp_get_sc_object $P9044, "1305640934.989", 394
    get_how $P9045, $P9044
    nqp_get_sc_object $P9046, "1305640934.989", 394
    .const 'Sub' $P9047 = "487_1305640955.436" 
    $P9045."add_method"($P9046, "statement_control:sym<CONTROL>", $P9047)
    nqp_get_sc_object $P9048, "1305640934.989", 394
    get_how $P9049, $P9048
    nqp_get_sc_object $P9050, "1305640934.989", 394
    .const 'Sub' $P9051 = "488_1305640955.436" 
    $P9049."add_method"($P9050, "statement_prefix:sym<INIT>", $P9051)
    nqp_get_sc_object $P9052, "1305640934.989", 394
    get_how $P9053, $P9052
    nqp_get_sc_object $P9054, "1305640934.989", 394
    .const 'Sub' $P9055 = "489_1305640955.436" 
    $P9053."add_method"($P9054, "statement_prefix:sym<try>", $P9055)
    nqp_get_sc_object $P9056, "1305640934.989", 394
    get_how $P9057, $P9056
    nqp_get_sc_object $P9058, "1305640934.989", 394
    .const 'Sub' $P9059 = "490_1305640955.436" 
    $P9057."add_method"($P9058, "blorst", $P9059)
    nqp_get_sc_object $P9060, "1305640934.989", 394
    get_how $P9061, $P9060
    nqp_get_sc_object $P9062, "1305640934.989", 394
    .const 'Sub' $P9063 = "491_1305640955.436" 
    $P9061."add_method"($P9062, "statement_mod_cond:sym<if>", $P9063)
    nqp_get_sc_object $P9064, "1305640934.989", 394
    get_how $P9065, $P9064
    nqp_get_sc_object $P9066, "1305640934.989", 394
    .const 'Sub' $P9067 = "492_1305640955.436" 
    $P9065."add_method"($P9066, "statement_mod_cond:sym<unless>", $P9067)
    nqp_get_sc_object $P9068, "1305640934.989", 394
    get_how $P9069, $P9068
    nqp_get_sc_object $P9070, "1305640934.989", 394
    .const 'Sub' $P9071 = "493_1305640955.436" 
    $P9069."add_method"($P9070, "statement_mod_loop:sym<while>", $P9071)
    nqp_get_sc_object $P9072, "1305640934.989", 394
    get_how $P9073, $P9072
    nqp_get_sc_object $P9074, "1305640934.989", 394
    .const 'Sub' $P9075 = "494_1305640955.436" 
    $P9073."add_method"($P9074, "statement_mod_loop:sym<until>", $P9075)
    nqp_get_sc_object $P9076, "1305640934.989", 394
    get_how $P9077, $P9076
    nqp_get_sc_object $P9078, "1305640934.989", 394
    .const 'Sub' $P9079 = "495_1305640955.436" 
    $P9077."add_method"($P9078, "term:sym<fatarrow>", $P9079)
    nqp_get_sc_object $P9080, "1305640934.989", 394
    get_how $P9081, $P9080
    nqp_get_sc_object $P9082, "1305640934.989", 394
    .const 'Sub' $P9083 = "496_1305640955.436" 
    $P9081."add_method"($P9082, "term:sym<colonpair>", $P9083)
    nqp_get_sc_object $P9084, "1305640934.989", 394
    get_how $P9085, $P9084
    nqp_get_sc_object $P9086, "1305640934.989", 394
    .const 'Sub' $P9087 = "497_1305640955.436" 
    $P9085."add_method"($P9086, "term:sym<variable>", $P9087)
    nqp_get_sc_object $P9088, "1305640934.989", 394
    get_how $P9089, $P9088
    nqp_get_sc_object $P9090, "1305640934.989", 394
    .const 'Sub' $P9091 = "498_1305640955.436" 
    $P9089."add_method"($P9090, "term:sym<package_declarator>", $P9091)
    nqp_get_sc_object $P9092, "1305640934.989", 394
    get_how $P9093, $P9092
    nqp_get_sc_object $P9094, "1305640934.989", 394
    .const 'Sub' $P9095 = "499_1305640955.436" 
    $P9093."add_method"($P9094, "term:sym<scope_declarator>", $P9095)
    nqp_get_sc_object $P9096, "1305640934.989", 394
    get_how $P9097, $P9096
    nqp_get_sc_object $P9098, "1305640934.989", 394
    .const 'Sub' $P9099 = "500_1305640955.436" 
    $P9097."add_method"($P9098, "term:sym<routine_declarator>", $P9099)
    nqp_get_sc_object $P9100, "1305640934.989", 394
    get_how $P9101, $P9100
    nqp_get_sc_object $P9102, "1305640934.989", 394
    .const 'Sub' $P9103 = "501_1305640955.436" 
    $P9101."add_method"($P9102, "term:sym<regex_declarator>", $P9103)
    nqp_get_sc_object $P9104, "1305640934.989", 394
    get_how $P9105, $P9104
    nqp_get_sc_object $P9106, "1305640934.989", 394
    .const 'Sub' $P9107 = "502_1305640955.436" 
    $P9105."add_method"($P9106, "term:sym<statement_prefix>", $P9107)
    nqp_get_sc_object $P9108, "1305640934.989", 394
    get_how $P9109, $P9108
    nqp_get_sc_object $P9110, "1305640934.989", 394
    .const 'Sub' $P9111 = "503_1305640955.436" 
    $P9109."add_method"($P9110, "term:sym<lambda>", $P9111)
    nqp_get_sc_object $P9112, "1305640934.989", 394
    get_how $P9113, $P9112
    nqp_get_sc_object $P9114, "1305640934.989", 394
    .const 'Sub' $P9115 = "504_1305640955.436" 
    $P9113."add_method"($P9114, "fatarrow", $P9115)
    nqp_get_sc_object $P9116, "1305640934.989", 394
    get_how $P9117, $P9116
    nqp_get_sc_object $P9118, "1305640934.989", 394
    .const 'Sub' $P9119 = "505_1305640955.436" 
    $P9117."add_method"($P9118, "colonpair", $P9119)
    nqp_get_sc_object $P9120, "1305640934.989", 394
    get_how $P9121, $P9120
    nqp_get_sc_object $P9122, "1305640934.989", 394
    .const 'Sub' $P9123 = "506_1305640955.436" 
    $P9121."add_method"($P9122, "variable", $P9123)
    nqp_get_sc_object $P9124, "1305640934.989", 394
    get_how $P9125, $P9124
    nqp_get_sc_object $P9126, "1305640934.989", 394
    .const 'Sub' $P9127 = "512_1305640955.436" 
    $P9125."add_method"($P9126, "package_declarator:sym<module>", $P9127)
    nqp_get_sc_object $P9128, "1305640934.989", 394
    get_how $P9129, $P9128
    nqp_get_sc_object $P9130, "1305640934.989", 394
    .const 'Sub' $P9131 = "513_1305640955.436" 
    $P9129."add_method"($P9130, "package_declarator:sym<knowhow>", $P9131)
    nqp_get_sc_object $P9132, "1305640934.989", 394
    get_how $P9133, $P9132
    nqp_get_sc_object $P9134, "1305640934.989", 394
    .const 'Sub' $P9135 = "514_1305640955.436" 
    $P9133."add_method"($P9134, "package_declarator:sym<class>", $P9135)
    nqp_get_sc_object $P9136, "1305640934.989", 394
    get_how $P9137, $P9136
    nqp_get_sc_object $P9138, "1305640934.989", 394
    .const 'Sub' $P9139 = "515_1305640955.436" 
    $P9137."add_method"($P9138, "package_declarator:sym<grammar>", $P9139)
    nqp_get_sc_object $P9140, "1305640934.989", 394
    get_how $P9141, $P9140
    nqp_get_sc_object $P9142, "1305640934.989", 394
    .const 'Sub' $P9143 = "516_1305640955.436" 
    $P9141."add_method"($P9142, "package_declarator:sym<role>", $P9143)
    nqp_get_sc_object $P9144, "1305640934.989", 394
    get_how $P9145, $P9144
    nqp_get_sc_object $P9146, "1305640934.989", 394
    .const 'Sub' $P9147 = "517_1305640955.436" 
    $P9145."add_method"($P9146, "package_declarator:sym<native>", $P9147)
    nqp_get_sc_object $P9148, "1305640934.989", 394
    get_how $P9149, $P9148
    nqp_get_sc_object $P9150, "1305640934.989", 394
    .const 'Sub' $P9151 = "518_1305640955.436" 
    $P9149."add_method"($P9150, "package_declarator:sym<stub>", $P9151)
    nqp_get_sc_object $P9152, "1305640934.989", 394
    get_how $P9153, $P9152
    nqp_get_sc_object $P9154, "1305640934.989", 394
    .const 'Sub' $P9155 = "519_1305640955.436" 
    $P9153."add_method"($P9154, "package_def", $P9155)
    nqp_get_sc_object $P9156, "1305640934.989", 394
    get_how $P9157, $P9156
    nqp_get_sc_object $P9158, "1305640934.989", 394
    .const 'Sub' $P9159 = "525_1305640955.436" 
    $P9157."add_method"($P9158, "scope_declarator:sym<my>", $P9159)
    nqp_get_sc_object $P9160, "1305640934.989", 394
    get_how $P9161, $P9160
    nqp_get_sc_object $P9162, "1305640934.989", 394
    .const 'Sub' $P9163 = "526_1305640955.436" 
    $P9161."add_method"($P9162, "scope_declarator:sym<our>", $P9163)
    nqp_get_sc_object $P9164, "1305640934.989", 394
    get_how $P9165, $P9164
    nqp_get_sc_object $P9166, "1305640934.989", 394
    .const 'Sub' $P9167 = "527_1305640955.436" 
    $P9165."add_method"($P9166, "scope_declarator:sym<has>", $P9167)
    nqp_get_sc_object $P9168, "1305640934.989", 394
    get_how $P9169, $P9168
    nqp_get_sc_object $P9170, "1305640934.989", 394
    .const 'Sub' $P9171 = "528_1305640955.436" 
    $P9169."add_method"($P9170, "scoped", $P9171)
    nqp_get_sc_object $P9172, "1305640934.989", 394
    get_how $P9173, $P9172
    nqp_get_sc_object $P9174, "1305640934.989", 394
    .const 'Sub' $P9175 = "529_1305640955.436" 
    $P9173."add_method"($P9174, "declarator", $P9175)
    nqp_get_sc_object $P9176, "1305640934.989", 394
    get_how $P9177, $P9176
    nqp_get_sc_object $P9178, "1305640934.989", 394
    .const 'Sub' $P9179 = "530_1305640955.436" 
    $P9177."add_method"($P9178, "multi_declarator:sym<multi>", $P9179)
    nqp_get_sc_object $P9180, "1305640934.989", 394
    get_how $P9181, $P9180
    nqp_get_sc_object $P9182, "1305640934.989", 394
    .const 'Sub' $P9183 = "531_1305640955.436" 
    $P9181."add_method"($P9182, "multi_declarator:sym<proto>", $P9183)
    nqp_get_sc_object $P9184, "1305640934.989", 394
    get_how $P9185, $P9184
    nqp_get_sc_object $P9186, "1305640934.989", 394
    .const 'Sub' $P9187 = "532_1305640955.436" 
    $P9185."add_method"($P9186, "multi_declarator:sym<null>", $P9187)
    nqp_get_sc_object $P9188, "1305640934.989", 394
    get_how $P9189, $P9188
    nqp_get_sc_object $P9190, "1305640934.989", 394
    .const 'Sub' $P9191 = "533_1305640955.436" 
    $P9189."add_method"($P9190, "variable_declarator", $P9191)
    nqp_get_sc_object $P9192, "1305640934.989", 394
    get_how $P9193, $P9192
    nqp_get_sc_object $P9194, "1305640934.989", 394
    .const 'Sub' $P9195 = "536_1305640955.436" 
    $P9193."add_method"($P9194, "routine_declarator:sym<sub>", $P9195)
    nqp_get_sc_object $P9196, "1305640934.989", 394
    get_how $P9197, $P9196
    nqp_get_sc_object $P9198, "1305640934.989", 394
    .const 'Sub' $P9199 = "537_1305640955.436" 
    $P9197."add_method"($P9198, "routine_declarator:sym<method>", $P9199)
    nqp_get_sc_object $P9200, "1305640934.989", 394
    get_how $P9201, $P9200
    nqp_get_sc_object $P9202, "1305640934.989", 394
    .const 'Sub' $P9203 = "538_1305640955.436" 
    $P9201."add_method"($P9202, "routine_def", $P9203)
    nqp_get_sc_object $P9204, "1305640934.989", 394
    get_how $P9205, $P9204
    nqp_get_sc_object $P9206, "1305640934.989", 394
    .const 'Sub' $P9207 = "545_1305640955.436" 
    $P9205."add_method"($P9206, "method_def", $P9207)
    nqp_get_sc_object $P9208, "1305640934.989", 394
    get_how $P9209, $P9208
    nqp_get_sc_object $P9210, "1305640934.989", 394
    .const 'Sub' $P9211 = "548_1305640955.436" 
    $P9209."add_method"($P9210, "signature", $P9211)
    nqp_get_sc_object $P9212, "1305640934.989", 394
    get_how $P9213, $P9212
    nqp_get_sc_object $P9214, "1305640934.989", 394
    .const 'Sub' $P9215 = "551_1305640955.436" 
    $P9213."add_method"($P9214, "parameter", $P9215)
    nqp_get_sc_object $P9216, "1305640934.989", 394
    get_how $P9217, $P9216
    nqp_get_sc_object $P9218, "1305640934.989", 394
    .const 'Sub' $P9219 = "552_1305640955.436" 
    $P9217."add_method"($P9218, "param_var", $P9219)
    nqp_get_sc_object $P9220, "1305640934.989", 394
    get_how $P9221, $P9220
    nqp_get_sc_object $P9222, "1305640934.989", 394
    .const 'Sub' $P9223 = "553_1305640955.436" 
    $P9221."add_method"($P9222, "named_param", $P9223)
    nqp_get_sc_object $P9224, "1305640934.989", 394
    get_how $P9225, $P9224
    nqp_get_sc_object $P9226, "1305640934.989", 394
    .const 'Sub' $P9227 = "554_1305640955.436" 
    $P9225."add_method"($P9226, "typename", $P9227)
    nqp_get_sc_object $P9228, "1305640934.989", 394
    get_how $P9229, $P9228
    nqp_get_sc_object $P9230, "1305640934.989", 394
    .const 'Sub' $P9231 = "556_1305640955.436" 
    $P9229."add_method"($P9230, "trait", $P9231)
    nqp_get_sc_object $P9232, "1305640934.989", 394
    get_how $P9233, $P9232
    nqp_get_sc_object $P9234, "1305640934.989", 394
    .const 'Sub' $P9235 = "557_1305640955.436" 
    $P9233."add_method"($P9234, "trait_mod:sym<is>", $P9235)
    nqp_get_sc_object $P9236, "1305640934.989", 394
    get_how $P9237, $P9236
    nqp_get_sc_object $P9238, "1305640934.989", 394
    .const 'Sub' $P9239 = "562_1305640955.436" 
    $P9237."add_method"($P9238, "regex_declarator", $P9239)
    nqp_get_sc_object $P9240, "1305640934.989", 394
    get_how $P9241, $P9240
    nqp_get_sc_object $P9242, "1305640934.989", 394
    .const 'Sub' $P9243 = "567_1305640955.436" 
    $P9241."add_method"($P9242, "dotty", $P9243)
    nqp_get_sc_object $P9244, "1305640934.989", 394
    get_how $P9245, $P9244
    nqp_get_sc_object $P9246, "1305640934.989", 394
    .const 'Sub' $P9247 = "568_1305640955.436" 
    $P9245."add_method"($P9246, "term:sym<self>", $P9247)
    nqp_get_sc_object $P9248, "1305640934.989", 394
    get_how $P9249, $P9248
    nqp_get_sc_object $P9250, "1305640934.989", 394
    .const 'Sub' $P9251 = "569_1305640955.436" 
    $P9249."add_method"($P9250, "term:sym<identifier>", $P9251)
    nqp_get_sc_object $P9252, "1305640934.989", 394
    get_how $P9253, $P9252
    nqp_get_sc_object $P9254, "1305640934.989", 394
    .const 'Sub' $P9255 = "570_1305640955.436" 
    $P9253."add_method"($P9254, "term:sym<name>", $P9255)
    nqp_get_sc_object $P9256, "1305640934.989", 394
    get_how $P9257, $P9256
    nqp_get_sc_object $P9258, "1305640934.989", 394
    .const 'Sub' $P9259 = "572_1305640955.436" 
    $P9257."add_method"($P9258, "term:sym<pir::op>", $P9259)
    nqp_get_sc_object $P9260, "1305640934.989", 394
    get_how $P9261, $P9260
    nqp_get_sc_object $P9262, "1305640934.989", 394
    .const 'Sub' $P9263 = "573_1305640955.436" 
    $P9261."add_method"($P9262, "term:sym<onlystar>", $P9263)
    nqp_get_sc_object $P9264, "1305640934.989", 394
    get_how $P9265, $P9264
    nqp_get_sc_object $P9266, "1305640934.989", 394
    .const 'Sub' $P9267 = "574_1305640955.436" 
    $P9265."add_method"($P9266, "args", $P9267)
    nqp_get_sc_object $P9268, "1305640934.989", 394
    get_how $P9269, $P9268
    nqp_get_sc_object $P9270, "1305640934.989", 394
    .const 'Sub' $P9271 = "575_1305640955.436" 
    $P9269."add_method"($P9270, "arglist", $P9271)
    nqp_get_sc_object $P9272, "1305640934.989", 394
    get_how $P9273, $P9272
    nqp_get_sc_object $P9274, "1305640934.989", 394
    .const 'Sub' $P9275 = "578_1305640955.436" 
    $P9273."add_method"($P9274, "term:sym<multi_declarator>", $P9275)
    nqp_get_sc_object $P9276, "1305640934.989", 394
    get_how $P9277, $P9276
    nqp_get_sc_object $P9278, "1305640934.989", 394
    .const 'Sub' $P9279 = "579_1305640955.436" 
    $P9277."add_method"($P9278, "term:sym<value>", $P9279)
    nqp_get_sc_object $P9280, "1305640934.989", 394
    get_how $P9281, $P9280
    nqp_get_sc_object $P9282, "1305640934.989", 394
    .const 'Sub' $P9283 = "580_1305640955.436" 
    $P9281."add_method"($P9282, "circumfix:sym<( )>", $P9283)
    nqp_get_sc_object $P9284, "1305640934.989", 394
    get_how $P9285, $P9284
    nqp_get_sc_object $P9286, "1305640934.989", 394
    .const 'Sub' $P9287 = "581_1305640955.436" 
    $P9285."add_method"($P9286, "circumfix:sym<[ ]>", $P9287)
    nqp_get_sc_object $P9288, "1305640934.989", 394
    get_how $P9289, $P9288
    nqp_get_sc_object $P9290, "1305640934.989", 394
    .const 'Sub' $P9291 = "582_1305640955.436" 
    $P9289."add_method"($P9290, "circumfix:sym<ang>", $P9291)
    nqp_get_sc_object $P9292, "1305640934.989", 394
    get_how $P9293, $P9292
    nqp_get_sc_object $P9294, "1305640934.989", 394
    .const 'Sub' $P9295 = "583_1305640955.436" 
    $P9293."add_method"($P9294, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P9295)
    nqp_get_sc_object $P9296, "1305640934.989", 394
    get_how $P9297, $P9296
    nqp_get_sc_object $P9298, "1305640934.989", 394
    .const 'Sub' $P9299 = "584_1305640955.436" 
    $P9297."add_method"($P9298, "circumfix:sym<{ }>", $P9299)
    nqp_get_sc_object $P9300, "1305640934.989", 394
    get_how $P9301, $P9300
    nqp_get_sc_object $P9302, "1305640934.989", 394
    .const 'Sub' $P9303 = "586_1305640955.436" 
    $P9301."add_method"($P9302, "circumfix:sym<sigil>", $P9303)
    nqp_get_sc_object $P9304, "1305640934.989", 394
    get_how $P9305, $P9304
    nqp_get_sc_object $P9306, "1305640934.989", 394
    .const 'Sub' $P9307 = "587_1305640955.436" 
    $P9305."add_method"($P9306, "semilist", $P9307)
    nqp_get_sc_object $P9308, "1305640934.989", 394
    get_how $P9309, $P9308
    nqp_get_sc_object $P9310, "1305640934.989", 394
    .const 'Sub' $P9311 = "588_1305640955.436" 
    $P9309."add_method"($P9310, "postcircumfix:sym<[ ]>", $P9311)
    nqp_get_sc_object $P9312, "1305640934.989", 394
    get_how $P9313, $P9312
    nqp_get_sc_object $P9314, "1305640934.989", 394
    .const 'Sub' $P9315 = "589_1305640955.436" 
    $P9313."add_method"($P9314, "postcircumfix:sym<{ }>", $P9315)
    nqp_get_sc_object $P9316, "1305640934.989", 394
    get_how $P9317, $P9316
    nqp_get_sc_object $P9318, "1305640934.989", 394
    .const 'Sub' $P9319 = "590_1305640955.436" 
    $P9317."add_method"($P9318, "postcircumfix:sym<ang>", $P9319)
    nqp_get_sc_object $P9320, "1305640934.989", 394
    get_how $P9321, $P9320
    nqp_get_sc_object $P9322, "1305640934.989", 394
    .const 'Sub' $P9323 = "591_1305640955.436" 
    $P9321."add_method"($P9322, "postcircumfix:sym<( )>", $P9323)
    nqp_get_sc_object $P9324, "1305640934.989", 394
    get_how $P9325, $P9324
    nqp_get_sc_object $P9326, "1305640934.989", 394
    .const 'Sub' $P9327 = "592_1305640955.436" 
    $P9325."add_method"($P9326, "value", $P9327)
    nqp_get_sc_object $P9328, "1305640934.989", 394
    get_how $P9329, $P9328
    nqp_get_sc_object $P9330, "1305640934.989", 394
    .const 'Sub' $P9331 = "593_1305640955.436" 
    $P9329."add_method"($P9330, "number", $P9331)
    nqp_get_sc_object $P9332, "1305640934.989", 394
    get_how $P9333, $P9332
    nqp_get_sc_object $P9334, "1305640934.989", 394
    .const 'Sub' $P9335 = "594_1305640955.436" 
    $P9333."add_method"($P9334, "quote:sym<apos>", $P9335)
    nqp_get_sc_object $P9336, "1305640934.989", 394
    get_how $P9337, $P9336
    nqp_get_sc_object $P9338, "1305640934.989", 394
    .const 'Sub' $P9339 = "595_1305640955.436" 
    $P9337."add_method"($P9338, "quote:sym<dblq>", $P9339)
    nqp_get_sc_object $P9340, "1305640934.989", 394
    get_how $P9341, $P9340
    nqp_get_sc_object $P9342, "1305640934.989", 394
    .const 'Sub' $P9343 = "596_1305640955.436" 
    $P9341."add_method"($P9342, "quote:sym<qq>", $P9343)
    nqp_get_sc_object $P9344, "1305640934.989", 394
    get_how $P9345, $P9344
    nqp_get_sc_object $P9346, "1305640934.989", 394
    .const 'Sub' $P9347 = "597_1305640955.436" 
    $P9345."add_method"($P9346, "quote:sym<q>", $P9347)
    nqp_get_sc_object $P9348, "1305640934.989", 394
    get_how $P9349, $P9348
    nqp_get_sc_object $P9350, "1305640934.989", 394
    .const 'Sub' $P9351 = "598_1305640955.436" 
    $P9349."add_method"($P9350, "quote:sym<Q>", $P9351)
    nqp_get_sc_object $P9352, "1305640934.989", 394
    get_how $P9353, $P9352
    nqp_get_sc_object $P9354, "1305640934.989", 394
    .const 'Sub' $P9355 = "599_1305640955.436" 
    $P9353."add_method"($P9354, "quote:sym<Q:PIR>", $P9355)
    nqp_get_sc_object $P9356, "1305640934.989", 394
    get_how $P9357, $P9356
    nqp_get_sc_object $P9358, "1305640934.989", 394
    .const 'Sub' $P9359 = "600_1305640955.436" 
    $P9357."add_method"($P9358, "quote:sym</ />", $P9359)
    nqp_get_sc_object $P9360, "1305640934.989", 394
    get_how $P9361, $P9360
    nqp_get_sc_object $P9362, "1305640934.989", 394
    .const 'Sub' $P9363 = "601_1305640955.436" 
    $P9361."add_method"($P9362, "quote_escape:sym<$>", $P9363)
    nqp_get_sc_object $P9364, "1305640934.989", 394
    get_how $P9365, $P9364
    nqp_get_sc_object $P9366, "1305640934.989", 394
    .const 'Sub' $P9367 = "602_1305640955.436" 
    $P9365."add_method"($P9366, "quote_escape:sym<{ }>", $P9367)
    nqp_get_sc_object $P9368, "1305640934.989", 394
    get_how $P9369, $P9368
    nqp_get_sc_object $P9370, "1305640934.989", 394
    .const 'Sub' $P9371 = "603_1305640955.436" 
    $P9369."add_method"($P9370, "quote_escape:sym<esc>", $P9371)
    nqp_get_sc_object $P9372, "1305640934.989", 394
    get_how $P9373, $P9372
    nqp_get_sc_object $P9374, "1305640934.989", 394
    .const 'Sub' $P9375 = "604_1305640955.436" 
    $P9373."add_method"($P9374, "postfix:sym<.>", $P9375)
    nqp_get_sc_object $P9376, "1305640934.989", 394
    get_how $P9377, $P9376
    nqp_get_sc_object $P9378, "1305640934.989", 394
    .const 'Sub' $P9379 = "605_1305640955.436" 
    $P9377."add_method"($P9378, "postfix:sym<++>", $P9379)
    nqp_get_sc_object $P9380, "1305640934.989", 394
    get_how $P9381, $P9380
    nqp_get_sc_object $P9382, "1305640934.989", 394
    .const 'Sub' $P9383 = "606_1305640955.436" 
    $P9381."add_method"($P9382, "postfix:sym<-->", $P9383)
    nqp_get_sc_object $P9384, "1305640934.989", 394
    get_how $P9385, $P9384
    nqp_get_sc_object $P9386, "1305640934.989", 394
    .const 'Sub' $P9387 = "607_1305640955.436" 
    $P9385."add_method"($P9386, "prefix:sym<make>", $P9387)
    nqp_get_sc_object $P9388, "1305640934.989", 394
    get_how $P9389, $P9388
    nqp_get_sc_object $P9390, "1305640934.989", 394
    .const 'Sub' $P9391 = "608_1305640955.436" 
    $P9389."add_method"($P9390, "term:sym<next>", $P9391)
    nqp_get_sc_object $P9392, "1305640934.989", 394
    get_how $P9393, $P9392
    nqp_get_sc_object $P9394, "1305640934.989", 394
    .const 'Sub' $P9395 = "609_1305640955.436" 
    $P9393."add_method"($P9394, "term:sym<last>", $P9395)
    nqp_get_sc_object $P9396, "1305640934.989", 394
    get_how $P9397, $P9396
    nqp_get_sc_object $P9398, "1305640934.989", 394
    .const 'Sub' $P9399 = "610_1305640955.436" 
    $P9397."add_method"($P9398, "term:sym<redo>", $P9399)
    nqp_get_sc_object $P9400, "1305640934.989", 394
    get_how $P9401, $P9400
    nqp_get_sc_object $P9402, "1305640934.989", 394
    .const 'Sub' $P9403 = "611_1305640955.436" 
    $P9401."add_method"($P9402, "infix:sym<~~>", $P9403)
    nqp_get_sc_object $P9404, "1305640934.989", 394
    get_how $P9405, $P9404
    nqp_get_sc_object $P9406, "1305640934.989", 394
    .const 'Sub' $P9407 = "612_1305640955.436" 
    $P9405."add_method"($P9406, "known_sym", $P9407)
    .const 'Sub' $P9408 = "435_1305640955.436" 
    $P9409 = $P9408."get_lexinfo"()
    nqp_get_sc_object $P9410, "1305640934.989", 394
    $P9409."set_static_lexpad_value"("$?PACKAGE", $P9410)
    .const 'Sub' $P9411 = "435_1305640955.436" 
    $P9412 = $P9411."get_lexinfo"()
    $P9412."finish_static_lexpad"()
    .const 'Sub' $P9413 = "435_1305640955.436" 
    $P9414 = $P9413."get_lexinfo"()
    nqp_get_sc_object $P9415, "1305640934.989", 394
    $P9414."set_static_lexpad_value"("$?CLASS", $P9415)
    .const 'Sub' $P9416 = "435_1305640955.436" 
    $P9417 = $P9416."get_lexinfo"()
    $P9417."finish_static_lexpad"()
    nqp_get_sc_object $P9418, "1305640934.989", 394
    get_how $P9419, $P9418
    nqp_get_sc_object $P9420, "1305640934.989", 394
    nqp_get_sc_object $P9421, "1305640910.362", 105
    $P9419."add_parent"($P9420, $P9421)
    nqp_get_sc_object $P9422, "1305640934.989", 394
    get_how $P9423, $P9422
    nqp_get_sc_object $P9424, "1305640934.989", 394
    $P9423."compose"($P9424)
    nqp_get_sc_object $P9425, "1305640898.961", 41
    $P9426 = $P9425."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P9426, cur_sc
    nqp_set_sc_object "1305640934.989", 506, $P9426
    nqp_get_sc_object $P9427, "1305640934.989", 506
    nqp_get_sc_object $P9428, "1305640934.989", 0
    nqp_get_package_through_who $P9429, $P9428, "NQP"
    get_who $P9430, $P9429
    set $P9430["RegexActions"], $P9427
    nqp_get_sc_object $P9431, "1305640934.989", 506
    get_how $P9432, $P9431
    nqp_get_sc_object $P9433, "1305640934.989", 506
    .const 'Sub' $P9434 = "615_1305640955.436" 
    $P9432."add_method"($P9433, "metachar:sym<:my>", $P9434)
    nqp_get_sc_object $P9435, "1305640934.989", 506
    get_how $P9436, $P9435
    nqp_get_sc_object $P9437, "1305640934.989", 506
    .const 'Sub' $P9438 = "616_1305640955.436" 
    $P9436."add_method"($P9437, "metachar:sym<{ }>", $P9438)
    nqp_get_sc_object $P9439, "1305640934.989", 506
    get_how $P9440, $P9439
    nqp_get_sc_object $P9441, "1305640934.989", 506
    .const 'Sub' $P9442 = "617_1305640955.436" 
    $P9440."add_method"($P9441, "metachar:sym<nqpvar>", $P9442)
    nqp_get_sc_object $P9443, "1305640934.989", 506
    get_how $P9444, $P9443
    nqp_get_sc_object $P9445, "1305640934.989", 506
    .const 'Sub' $P9446 = "618_1305640955.436" 
    $P9444."add_method"($P9445, "assertion:sym<{ }>", $P9446)
    nqp_get_sc_object $P9447, "1305640934.989", 506
    get_how $P9448, $P9447
    nqp_get_sc_object $P9449, "1305640934.989", 506
    .const 'Sub' $P9450 = "619_1305640955.436" 
    $P9448."add_method"($P9449, "assertion:sym<?{ }>", $P9450)
    nqp_get_sc_object $P9451, "1305640934.989", 506
    get_how $P9452, $P9451
    nqp_get_sc_object $P9453, "1305640934.989", 506
    .const 'Sub' $P9454 = "620_1305640955.436" 
    $P9452."add_method"($P9453, "assertion:sym<var>", $P9454)
    nqp_get_sc_object $P9455, "1305640934.989", 506
    get_how $P9456, $P9455
    nqp_get_sc_object $P9457, "1305640934.989", 506
    .const 'Sub' $P9458 = "621_1305640955.436" 
    $P9456."add_method"($P9457, "codeblock", $P9458)
    .const 'Sub' $P9459 = "614_1305640955.436" 
    $P9460 = $P9459."get_lexinfo"()
    nqp_get_sc_object $P9461, "1305640934.989", 506
    $P9460."set_static_lexpad_value"("$?PACKAGE", $P9461)
    .const 'Sub' $P9462 = "614_1305640955.436" 
    $P9463 = $P9462."get_lexinfo"()
    $P9463."finish_static_lexpad"()
    .const 'Sub' $P9464 = "614_1305640955.436" 
    $P9465 = $P9464."get_lexinfo"()
    nqp_get_sc_object $P9466, "1305640934.989", 506
    $P9465."set_static_lexpad_value"("$?CLASS", $P9466)
    .const 'Sub' $P9467 = "614_1305640955.436" 
    $P9468 = $P9467."get_lexinfo"()
    $P9468."finish_static_lexpad"()
    nqp_get_sc_object $P9469, "1305640934.989", 506
    get_how $P9470, $P9469
    nqp_get_sc_object $P9471, "1305640934.989", 506
    nqp_get_sc_object $P9472, "1305640924.811", 145
    $P9470."add_parent"($P9471, $P9472)
    nqp_get_sc_object $P9473, "1305640934.989", 506
    get_how $P9474, $P9473
    nqp_get_sc_object $P9475, "1305640934.989", 506
    $P9474."compose"($P9475)
    nqp_get_sc_object $P9476, "1305640898.961", 41
    $P9477 = $P9476."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P9477, cur_sc
    nqp_set_sc_object "1305640934.989", 514, $P9477
    nqp_get_sc_object $P9478, "1305640934.989", 514
    nqp_get_sc_object $P9479, "1305640934.989", 0
    nqp_get_package_through_who $P9480, $P9479, "NQP"
    get_who $P9481, $P9480
    set $P9481["Compiler"], $P9478
    .const 'Sub' $P9482 = "622_1305640955.436" 
    $P9483 = $P9482."get_lexinfo"()
    nqp_get_sc_object $P9484, "1305640934.989", 514
    $P9483."set_static_lexpad_value"("$?PACKAGE", $P9484)
    .const 'Sub' $P9485 = "622_1305640955.436" 
    $P9486 = $P9485."get_lexinfo"()
    $P9486."finish_static_lexpad"()
    .const 'Sub' $P9487 = "622_1305640955.436" 
    $P9488 = $P9487."get_lexinfo"()
    nqp_get_sc_object $P9489, "1305640934.989", 514
    $P9488."set_static_lexpad_value"("$?CLASS", $P9489)
    .const 'Sub' $P9490 = "622_1305640955.436" 
    $P9491 = $P9490."get_lexinfo"()
    $P9491."finish_static_lexpad"()
    nqp_get_sc_object $P9492, "1305640934.989", 514
    get_how $P9493, $P9492
    nqp_get_sc_object $P9494, "1305640934.989", 514
    nqp_get_sc_object $P9495, "1305640910.362", 138
    $P9493."add_parent"($P9494, $P9495)
    nqp_get_sc_object $P9496, "1305640934.989", 514
    get_how $P9497, $P9496
    nqp_get_sc_object $P9498, "1305640934.989", 514
    $P9497."compose"($P9498)
  if_7304_end:
    nqp_get_sc_object $P10585, "1305640934.989", 0
    set_hll_global "GLOBAL", $P10585
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1305640955.436") :outer("10_1305640955.436")
    .param pmc param_17
.annotate 'line', 2754
    .lex "@ARGS", param_17
.annotate 'line', 2756
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2762
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2756
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2757
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_625
    new $P25, "Undef"
  vivify_625:
    $P25."language"("nqp")
.annotate 'line', 2758
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_626
    new $P26, "Undef"
  vivify_626:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2759
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_627
    new $P31, "Undef"
  vivify_627:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2762
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_628
    new $P36, "Undef"
  vivify_628:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2763
    find_lex $P38, "@clo"
    unless_null $P38, vivify_629
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_629:
    $P38."push"("parsetrace")
.annotate 'line', 2764
    find_lex $P39, "@clo"
    unless_null $P39, vivify_630
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_630:
    $P39."push"("setting=s")
.annotate 'line', 2765
    find_lex $P40, "@clo"
    unless_null $P40, vivify_631
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_631:
    $P40."push"("setting-path=s")
.annotate 'line', 2766
    find_lex $P41, "@clo"
    unless_null $P41, vivify_632
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_632:
    $P41."push"("module-path=s")
.annotate 'line', 2769
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_633
    new $P42, "Undef"
  vivify_633:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_634
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_634:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2754
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block46"  :subid("12_1305640955.436") :outer("10_1305640955.436")
.annotate 'line', 11
    .const 'Sub' $P865 = "37_1305640955.436" 
    capture_lex $P865
    .const 'Sub' $P841 = "36_1305640955.436" 
    capture_lex $P841
    .const 'Sub' $P811 = "35_1305640955.436" 
    capture_lex $P811
    .const 'Sub' $P778 = "34_1305640955.436" 
    capture_lex $P778
    .const 'Sub' $P663 = "29_1305640955.436" 
    capture_lex $P663
    .const 'Sub' $P616 = "28_1305640955.436" 
    capture_lex $P616
    .const 'Sub' $P488 = "25_1305640955.436" 
    capture_lex $P488
    .const 'Sub' $P403 = "22_1305640955.436" 
    capture_lex $P403
    .const 'Sub' $P326 = "21_1305640955.436" 
    capture_lex $P326
    .const 'Sub' $P290 = "20_1305640955.436" 
    capture_lex $P290
    .const 'Sub' $P227 = "19_1305640955.436" 
    capture_lex $P227
    .const 'Sub' $P151 = "16_1305640955.436" 
    capture_lex $P151
    .const 'Sub' $P110 = "15_1305640955.436" 
    capture_lex $P110
    .const 'Sub' $P52 = "13_1305640955.436" 
    capture_lex $P52
.annotate 'line', 16
    new $P48, "Undef"
    .lex "$loader", $P48
    .lex "$?PACKAGE", $P49
    .lex "$?CLASS", $P50
    get_hll_global $P51, "ModuleLoader"
    store_lex "$loader", $P51
.annotate 'line', 403
    .const 'Sub' $P865 = "37_1305640955.436" 
    newclosure $P974, $P865
.annotate 'line', 11
    .return ($P974)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_setting" :anon :subid("13_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_55
    .param pmc param_56
.annotate 'line', 19
    .const 'Sub' $P63 = "14_1305640955.436" 
    capture_lex $P63
    new $P54, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P54, control_53
    push_eh $P54
    .lex "self", param_55
    .lex "$setting_name", param_56
.annotate 'line', 21
    find_lex $P59, "$setting_name"
    unless_null $P59, vivify_635
    new $P59, "Undef"
  vivify_635:
    set $S60, $P59
    isne $I61, $S60, "NULL"
    if $I61, if_58
    new $P57, 'Integer'
    set $P57, $I61
    goto if_58_end
  if_58:
    .const 'Sub' $P63 = "14_1305640955.436" 
    capture_lex $P63
    $P108 = $P63()
    set $P57, $P108
  if_58_end:
.annotate 'line', 19
    .return ($P57)
  control_53:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P109, exception, "payload"
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block62"  :anon :subid("14_1305640955.436") :outer("13_1305640955.436")
.annotate 'line', 25
    new $P64, "Undef"
    .lex "$setting", $P64
.annotate 'line', 26
    find_lex $P65, "$loader"
    unless_null $P65, vivify_636
    new $P65, "Undef"
  vivify_636:
    find_lex $P66, "$setting_name"
    unless_null $P66, vivify_637
    new $P66, "Undef"
  vivify_637:
    $P67 = $P65."load_setting"($P66)
    find_dynamic_lex $P70, "%*COMPILING"
    unless_null $P70, vivify_638
    get_hll_global $P68, "GLOBAL"
    get_who $P69, $P68
    set $P70, $P69["%COMPILING"]
    unless_null $P70, vivify_639
    die "Contextual %*COMPILING not found"
  vivify_639:
    store_dynamic_lex "%*COMPILING", $P70
  vivify_638:
    set $P71, $P70["%?OPTIONS"]
    unless_null $P71, vivify_640
    $P71 = root_new ['parrot';'Hash']
    set $P70["%?OPTIONS"], $P71
  vivify_640:
    set $P71["outer_ctx"], $P67
    store_lex "$setting", $P67
.annotate 'line', 29
    find_lex $P72, "self"
    get_hll_global $P73, "GLOBAL"
    nqp_get_package_through_who $P74, $P73, "PAST"
    get_who $P75, $P74
    set $P76, $P75["Stmts"]
.annotate 'line', 30
    get_hll_global $P77, "GLOBAL"
    nqp_get_package_through_who $P78, $P77, "PAST"
    get_who $P79, $P78
    set $P80, $P79["Op"]
    $P81 = $P80."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 33
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "PAST"
    get_who $P84, $P83
    set $P85, $P84["Op"]
.annotate 'line', 35
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "PAST"
    get_who $P88, $P87
    set $P89, $P88["Var"]
    $P90 = $P89."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 36
    get_hll_global $P91, "GLOBAL"
    nqp_get_package_through_who $P92, $P91, "PAST"
    get_who $P93, $P92
    set $P94, $P93["Op"]
.annotate 'line', 38
    get_hll_global $P95, "GLOBAL"
    nqp_get_package_through_who $P96, $P95, "PAST"
    get_who $P97, $P96
    set $P98, $P97["Var"]
    new $P99, "ResizablePMCArray"
    $P100 = $P98."new"("ModuleLoader" :named("name"), $P99 :named("namespace"), "package" :named("scope"))
    find_lex $P101, "$setting_name"
    unless_null $P101, vivify_641
    new $P101, "Undef"
  vivify_641:
    $P102 = $P94."new"($P100, $P101, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 36
    $P103 = $P85."new"($P90, $P102, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 33
    $P104 = $P76."new"($P81, $P103)
.annotate 'line', 29
    $P72."add_event"($P104 :named("deserialize_past"))
.annotate 'line', 44
    new $P105, "Exception"
    set $P105['type'], .CONTROL_RETURN
    find_lex $P106, "$setting"
    unless_null $P106, vivify_642
    new $P106, "Undef"
  vivify_642:
    getattribute $P107, $P106, "lex_pad"
    setattribute $P105, 'payload', $P107
    throw $P105
.annotate 'line', 21
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_module" :anon :subid("15_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_113
    .param pmc param_114
    .param pmc param_115
.annotate 'line', 50
    new $P112, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P112, control_111
    push_eh $P112
    .lex "self", param_113
    .lex "$module_name", param_114
    .lex "$cur_GLOBALish", param_115
.annotate 'line', 52
    new $P116, "Undef"
    .lex "$module", $P116
    find_lex $P117, "$loader"
    unless_null $P117, vivify_643
    new $P117, "Undef"
  vivify_643:
    find_lex $P118, "$module_name"
    unless_null $P118, vivify_644
    new $P118, "Undef"
  vivify_644:
    find_lex $P119, "$cur_GLOBALish"
    unless_null $P119, vivify_645
    new $P119, "Undef"
  vivify_645:
    $P120 = $P117."load_module"($P118, $P119)
    store_lex "$module", $P120
.annotate 'line', 55
    find_lex $P121, "self"
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Stmts"]
.annotate 'line', 56
    get_hll_global $P126, "GLOBAL"
    nqp_get_package_through_who $P127, $P126, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    $P130 = $P129."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 59
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Op"]
.annotate 'line', 61
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Var"]
    new $P139, "ResizablePMCArray"
    $P140 = $P138."new"("ModuleLoader" :named("name"), $P139 :named("namespace"), "package" :named("scope"))
    find_lex $P141, "$module_name"
    unless_null $P141, vivify_646
    new $P141, "Undef"
  vivify_646:
.annotate 'line', 63
    find_lex $P142, "self"
    find_lex $P143, "$cur_GLOBALish"
    unless_null $P143, vivify_647
    new $P143, "Undef"
  vivify_647:
    $P144 = $P142."get_slot_past_for_object"($P143)
    $P145 = $P134."new"($P140, $P141, $P144, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 59
    $P146 = $P125."new"($P130, $P145)
.annotate 'line', 55
    $P121."add_event"($P146 :named("deserialize_past"))
.annotate 'line', 66
    new $P147, "Exception"
    set $P147['type'], .CONTROL_RETURN
    find_lex $P148, "$module"
    unless_null $P148, vivify_648
    new $P148, "Undef"
  vivify_648:
    getattribute $P149, $P148, "lex_pad"
    setattribute $P147, 'payload', $P149
    throw $P147
.annotate 'line', 50
    .return ()
  control_111:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P150, exception, "payload"
    .return ($P150)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "install_package_symbol" :anon :subid("16_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_152
    .param pmc param_153
    .param pmc param_154
    .param pmc param_155
.annotate 'line', 71
    .const 'Sub' $P192 = "18_1305640955.436" 
    capture_lex $P192
    .const 'Sub' $P171 = "17_1305640955.436" 
    capture_lex $P171
    .lex "self", param_152
    .lex "$package", param_153
    .lex "@sym", param_154
    .lex "$obj", param_155
.annotate 'line', 73
    new $P156, "Undef"
    .lex "$name", $P156
.annotate 'line', 76
    new $P157, "Undef"
    .lex "$target", $P157
.annotate 'line', 83
    new $P158, "Undef"
    .lex "$path", $P158
.annotate 'line', 72
    find_lex $P159, "@sym"
    unless_null $P159, vivify_649
    $P159 = root_new ['parrot';'ResizablePMCArray']
  vivify_649:
    clone $P160, $P159
    store_lex "@sym", $P160
.annotate 'line', 73
    find_lex $P161, "@sym"
    unless_null $P161, vivify_650
    $P161 = root_new ['parrot';'ResizablePMCArray']
  vivify_650:
    $P162 = $P161."pop"()
    set $S163, $P162
    new $P164, 'String'
    set $P164, $S163
    store_lex "$name", $P164
.annotate 'line', 76
    find_lex $P165, "$package"
    unless_null $P165, vivify_651
    new $P165, "Undef"
  vivify_651:
    store_lex "$target", $P165
.annotate 'line', 77
    find_lex $P167, "@sym"
    unless_null $P167, vivify_652
    $P167 = root_new ['parrot';'ResizablePMCArray']
  vivify_652:
    defined $I168, $P167
    unless $I168, for_undef_653
    iter $P166, $P167
    new $P178, 'ExceptionHandler'
    set_label $P178, loop177_handler
    $P178."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P178
  loop177_test:
    unless $P166, loop177_done
    shift $P169, $P166
  loop177_redo:
    .const 'Sub' $P171 = "17_1305640955.436" 
    capture_lex $P171
    $P171($P169)
  loop177_next:
    goto loop177_test
  loop177_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P179, exception, 'type'
    eq $P179, .CONTROL_LOOP_NEXT, loop177_next
    eq $P179, .CONTROL_LOOP_REDO, loop177_redo
  loop177_done:
    pop_eh 
  for_undef_653:
.annotate 'line', 80
    find_lex $P180, "$obj"
    unless_null $P180, vivify_656
    new $P180, "Undef"
  vivify_656:
    find_lex $P181, "$name"
    unless_null $P181, vivify_657
    new $P181, "Undef"
  vivify_657:
    find_lex $P182, "$target"
    unless_null $P182, vivify_658
    new $P182, "Undef"
    store_lex "$target", $P182
  vivify_658:
    get_who $P183, $P182
    set $P183[$P181], $P180
.annotate 'line', 83
    find_lex $P184, "self"
    find_lex $P185, "$package"
    unless_null $P185, vivify_659
    new $P185, "Undef"
  vivify_659:
    $P186 = $P184."get_slot_past_for_object"($P185)
    store_lex "$path", $P186
.annotate 'line', 84
    find_lex $P188, "@sym"
    unless_null $P188, vivify_660
    $P188 = root_new ['parrot';'ResizablePMCArray']
  vivify_660:
    defined $I189, $P188
    unless $I189, for_undef_661
    iter $P187, $P188
    new $P203, 'ExceptionHandler'
    set_label $P203, loop202_handler
    $P203."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P203
  loop202_test:
    unless $P187, loop202_done
    shift $P190, $P187
  loop202_redo:
    .const 'Sub' $P192 = "18_1305640955.436" 
    capture_lex $P192
    $P192($P190)
  loop202_next:
    goto loop202_test
  loop202_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P204, exception, 'type'
    eq $P204, .CONTROL_LOOP_NEXT, loop202_next
    eq $P204, .CONTROL_LOOP_REDO, loop202_redo
  loop202_done:
    pop_eh 
  for_undef_661:
.annotate 'line', 87
    find_lex $P205, "self"
    get_hll_global $P206, "GLOBAL"
    nqp_get_package_through_who $P207, $P206, "PAST"
    get_who $P208, $P207
    set $P209, $P208["Op"]
.annotate 'line', 89
    get_hll_global $P210, "GLOBAL"
    nqp_get_package_through_who $P211, $P210, "PAST"
    get_who $P212, $P211
    set $P213, $P212["Var"]
.annotate 'line', 91
    get_hll_global $P214, "GLOBAL"
    nqp_get_package_through_who $P215, $P214, "PAST"
    get_who $P216, $P215
    set $P217, $P216["Op"]
    find_lex $P218, "$path"
    unless_null $P218, vivify_664
    new $P218, "Undef"
  vivify_664:
    $P219 = $P217."new"($P218, "get_who PP" :named("pirop"))
    find_lex $P220, "$name"
    unless_null $P220, vivify_665
    new $P220, "Undef"
  vivify_665:
    $P221 = $P213."new"($P219, $P220, "keyed" :named("scope"))
.annotate 'line', 94
    find_lex $P222, "self"
    find_lex $P223, "$obj"
    unless_null $P223, vivify_666
    new $P223, "Undef"
  vivify_666:
    $P224 = $P222."get_slot_past_for_object"($P223)
    $P225 = $P209."new"($P221, $P224, "bind" :named("pasttype"))
.annotate 'line', 87
    $P226 = $P205."add_event"($P225 :named("deserialize_past"))
.annotate 'line', 71
    .return ($P226)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block170"  :anon :subid("17_1305640955.436") :outer("16_1305640955.436")
    .param pmc param_172
.annotate 'line', 77
    .lex "$_", param_172
.annotate 'line', 78
    find_lex $P173, "$target"
    unless_null $P173, vivify_654
    new $P173, "Undef"
  vivify_654:
    find_lex $P174, "$_"
    unless_null $P174, vivify_655
    new $P174, "Undef"
  vivify_655:
    set $S175, $P174
    nqp_get_package_through_who $P176, $P173, $S175
    store_lex "$target", $P176
.annotate 'line', 77
    .return ($P176)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block191"  :anon :subid("18_1305640955.436") :outer("16_1305640955.436")
    .param pmc param_193
.annotate 'line', 84
    .lex "$_", param_193
.annotate 'line', 85
    get_hll_global $P194, "GLOBAL"
    nqp_get_package_through_who $P195, $P194, "PAST"
    get_who $P196, $P195
    set $P197, $P196["Op"]
    find_lex $P198, "$path"
    unless_null $P198, vivify_662
    new $P198, "Undef"
  vivify_662:
    find_lex $P199, "$_"
    unless_null $P199, vivify_663
    new $P199, "Undef"
  vivify_663:
    set $S200, $P199
    $P201 = $P197."new"($P198, $S200, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P201
.annotate 'line', 84
    .return ($P201)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_lexical_symbol" :anon :subid("19_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_228
    .param pmc param_229
    .param pmc param_230
    .param pmc param_231
.annotate 'line', 102
    .lex "self", param_228
    .lex "$block", param_229
    .lex "$name", param_230
    .lex "$obj", param_231
.annotate 'line', 108
    new $P232, "Undef"
    .lex "$fixup", $P232
.annotate 'line', 104
    find_lex $P233, "$block"
    unless_null $P233, vivify_667
    new $P233, "Undef"
  vivify_667:
    find_lex $P234, "$name"
    unless_null $P234, vivify_668
    new $P234, "Undef"
  vivify_668:
    find_lex $P235, "$obj"
    unless_null $P235, vivify_669
    new $P235, "Undef"
  vivify_669:
    $P233."symbol"($P234, "lexical" :named("scope"), $P235 :named("value"))
.annotate 'line', 105
    find_lex $P236, "$block"
    unless_null $P236, vivify_670
    $P236 = root_new ['parrot';'ResizablePMCArray']
  vivify_670:
    set $P237, $P236[0]
    unless_null $P237, vivify_671
    new $P237, "Undef"
  vivify_671:
    get_hll_global $P238, "GLOBAL"
    nqp_get_package_through_who $P239, $P238, "PAST"
    get_who $P240, $P239
    set $P241, $P240["Var"]
    find_lex $P242, "$name"
    unless_null $P242, vivify_672
    new $P242, "Undef"
  vivify_672:
    $P243 = $P241."new"("lexical" :named("scope"), $P242 :named("name"), 1 :named("isdecl"))
    $P237."push"($P243)
.annotate 'line', 108
    get_hll_global $P244, "GLOBAL"
    nqp_get_package_through_who $P245, $P244, "PAST"
    get_who $P246, $P245
    set $P247, $P246["Stmts"]
.annotate 'line', 109
    get_hll_global $P248, "GLOBAL"
    nqp_get_package_through_who $P249, $P248, "PAST"
    get_who $P250, $P249
    set $P251, $P250["Op"]
.annotate 'line', 111
    get_hll_global $P252, "GLOBAL"
    nqp_get_package_through_who $P253, $P252, "PAST"
    get_who $P254, $P253
    set $P255, $P254["Op"]
.annotate 'line', 113
    get_hll_global $P256, "GLOBAL"
    nqp_get_package_through_who $P257, $P256, "PAST"
    get_who $P258, $P257
    set $P259, $P258["Val"]
    find_lex $P260, "$block"
    unless_null $P260, vivify_673
    new $P260, "Undef"
  vivify_673:
    $P261 = $P259."new"($P260 :named("value"))
    $P262 = $P255."new"($P261, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 115
    find_lex $P263, "$name"
    unless_null $P263, vivify_674
    new $P263, "Undef"
  vivify_674:
    set $S264, $P263
    find_lex $P265, "self"
    find_lex $P266, "$obj"
    unless_null $P266, vivify_675
    new $P266, "Undef"
  vivify_675:
    $P267 = $P265."get_slot_past_for_object"($P266)
    $P268 = $P251."new"($P262, $S264, $P267, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 119
    get_hll_global $P269, "GLOBAL"
    nqp_get_package_through_who $P270, $P269, "PAST"
    get_who $P271, $P270
    set $P272, $P271["Op"]
.annotate 'line', 121
    get_hll_global $P273, "GLOBAL"
    nqp_get_package_through_who $P274, $P273, "PAST"
    get_who $P275, $P274
    set $P276, $P275["Op"]
.annotate 'line', 123
    get_hll_global $P277, "GLOBAL"
    nqp_get_package_through_who $P278, $P277, "PAST"
    get_who $P279, $P278
    set $P280, $P279["Val"]
    find_lex $P281, "$block"
    unless_null $P281, vivify_676
    new $P281, "Undef"
  vivify_676:
    $P282 = $P280."new"($P281 :named("value"))
    $P283 = $P276."new"($P282, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 121
    $P284 = $P272."new"($P283, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 119
    $P285 = $P247."new"($P268, $P284)
.annotate 'line', 108
    store_lex "$fixup", $P285
.annotate 'line', 127
    find_lex $P286, "self"
    find_lex $P287, "$fixup"
    unless_null $P287, vivify_677
    new $P287, "Undef"
  vivify_677:
    find_lex $P288, "$fixup"
    unless_null $P288, vivify_678
    new $P288, "Undef"
  vivify_678:
    $P289 = $P286."add_event"($P287 :named("deserialize_past"), $P288 :named("fixup_past"))
.annotate 'line', 102
    .return ($P289)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_package_routine" :anon :subid("20_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_291
    .param pmc param_292
    .param pmc param_293
    .param pmc param_294
.annotate 'line', 132
    .lex "self", param_291
    .lex "$package", param_292
    .lex "$name", param_293
    .lex "$past_block", param_294
.annotate 'line', 133
    new $P295, "Undef"
    .lex "$fixup", $P295
    get_hll_global $P296, "GLOBAL"
    nqp_get_package_through_who $P297, $P296, "PAST"
    get_who $P298, $P297
    set $P299, $P298["Op"]
.annotate 'line', 135
    get_hll_global $P300, "GLOBAL"
    nqp_get_package_through_who $P301, $P300, "PAST"
    get_who $P302, $P301
    set $P303, $P302["Var"]
.annotate 'line', 137
    get_hll_global $P304, "GLOBAL"
    nqp_get_package_through_who $P305, $P304, "PAST"
    get_who $P306, $P305
    set $P307, $P306["Op"]
    find_lex $P308, "self"
    find_lex $P309, "$package"
    unless_null $P309, vivify_679
    new $P309, "Undef"
  vivify_679:
    $P310 = $P308."get_slot_past_for_object"($P309)
    $P311 = $P307."new"($P310, "get_who PP" :named("pirop"))
.annotate 'line', 138
    find_lex $P312, "$name"
    unless_null $P312, vivify_680
    new $P312, "Undef"
  vivify_680:
    set $S313, $P312
    $P314 = $P303."new"($P311, $S313, "keyed" :named("scope"))
.annotate 'line', 140
    get_hll_global $P315, "GLOBAL"
    nqp_get_package_through_who $P316, $P315, "PAST"
    get_who $P317, $P316
    set $P318, $P317["Val"]
    find_lex $P319, "$past_block"
    unless_null $P319, vivify_681
    new $P319, "Undef"
  vivify_681:
    $P320 = $P318."new"($P319 :named("value"))
    $P321 = $P299."new"($P314, $P320, "bind" :named("pasttype"))
.annotate 'line', 133
    store_lex "$fixup", $P321
.annotate 'line', 142
    find_lex $P322, "self"
    find_lex $P323, "$fixup"
    unless_null $P323, vivify_682
    new $P323, "Undef"
  vivify_682:
    find_lex $P324, "$fixup"
    unless_null $P324, vivify_683
    new $P324, "Undef"
  vivify_683:
    $P325 = $P322."add_event"($P323 :named("deserialize_past"), $P324 :named("fixup_past"))
.annotate 'line', 132
    .return ($P325)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_create_mo" :anon :subid("21_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_329
    .param pmc param_330
    .param pmc param_331 :optional :named("name")
    .param int has_param_331 :opt_flag
    .param pmc param_333 :optional :named("repr")
    .param int has_param_333 :opt_flag
.annotate 'line', 147
    new $P328, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P328, control_327
    push_eh $P328
    .lex "self", param_329
    .lex "$how", param_330
    if has_param_331, optparam_684
    new $P332, "Undef"
    set param_331, $P332
  optparam_684:
    .lex "$name", param_331
    if has_param_333, optparam_685
    new $P334, "Undef"
    set param_333, $P334
  optparam_685:
    .lex "$repr", param_333
.annotate 'line', 149
    $P335 = root_new ['parrot';'Hash']
    .lex "%args", $P335
.annotate 'line', 152
    new $P336, "Undef"
    .lex "$mo", $P336
.annotate 'line', 153
    new $P337, "Undef"
    .lex "$slot", $P337
.annotate 'line', 157
    $P338 = root_new ['parrot';'ResizablePMCArray']
    .lex "@how_ns", $P338
.annotate 'line', 158
    new $P339, "Undef"
    .lex "$how_name", $P339
.annotate 'line', 159
    new $P340, "Undef"
    .lex "$setup_call", $P340
.annotate 'line', 147
    find_lex $P341, "%args"
    unless_null $P341, vivify_686
    $P341 = root_new ['parrot';'Hash']
  vivify_686:
.annotate 'line', 150
    find_lex $P343, "$name"
    unless_null $P343, vivify_687
    new $P343, "Undef"
  vivify_687:
    defined $I344, $P343
    unless $I344, if_342_end
    find_lex $P345, "$name"
    unless_null $P345, vivify_688
    new $P345, "Undef"
  vivify_688:
    find_lex $P346, "%args"
    unless_null $P346, vivify_689
    $P346 = root_new ['parrot';'Hash']
    store_lex "%args", $P346
  vivify_689:
    set $P346["name"], $P345
  if_342_end:
.annotate 'line', 151
    find_lex $P348, "$repr"
    unless_null $P348, vivify_690
    new $P348, "Undef"
  vivify_690:
    defined $I349, $P348
    unless $I349, if_347_end
    find_lex $P350, "$repr"
    unless_null $P350, vivify_691
    new $P350, "Undef"
  vivify_691:
    find_lex $P351, "%args"
    unless_null $P351, vivify_692
    $P351 = root_new ['parrot';'Hash']
    store_lex "%args", $P351
  vivify_692:
    set $P351["repr"], $P350
  if_347_end:
.annotate 'line', 152
    find_lex $P352, "$how"
    unless_null $P352, vivify_693
    new $P352, "Undef"
  vivify_693:
    find_lex $P353, "%args"
    unless_null $P353, vivify_694
    $P353 = root_new ['parrot';'Hash']
  vivify_694:
    $P354 = $P352."new_type"($P353 :flat)
    store_lex "$mo", $P354
.annotate 'line', 153
    find_lex $P355, "self"
    find_lex $P356, "$mo"
    unless_null $P356, vivify_695
    new $P356, "Undef"
  vivify_695:
    $P357 = $P355."add_object"($P356)
    store_lex "$slot", $P357
.annotate 'line', 157
    find_lex $P358, "$how"
    unless_null $P358, vivify_696
    new $P358, "Undef"
  vivify_696:
    get_how $P359, $P358
    find_lex $P360, "$how"
    unless_null $P360, vivify_697
    new $P360, "Undef"
  vivify_697:
    $S361 = $P359."name"($P360)
    split $P362, "::", $S361
    store_lex "@how_ns", $P362
.annotate 'line', 158
    find_lex $P363, "@how_ns"
    unless_null $P363, vivify_698
    $P363 = root_new ['parrot';'ResizablePMCArray']
  vivify_698:
    $P364 = $P363."pop"()
    store_lex "$how_name", $P364
.annotate 'line', 159
    get_hll_global $P365, "GLOBAL"
    nqp_get_package_through_who $P366, $P365, "PAST"
    get_who $P367, $P366
    set $P368, $P367["Op"]
.annotate 'line', 161
    find_lex $P369, "self"
    find_lex $P370, "$how"
    unless_null $P370, vivify_699
    new $P370, "Undef"
  vivify_699:
    $P371 = $P369."get_object_sc_ref_past"($P370)
    $P372 = $P368."new"($P371, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 159
    store_lex "$setup_call", $P372
.annotate 'line', 163
    find_lex $P374, "$name"
    unless_null $P374, vivify_700
    new $P374, "Undef"
  vivify_700:
    defined $I375, $P374
    unless $I375, if_373_end
.annotate 'line', 164
    find_lex $P376, "$setup_call"
    unless_null $P376, vivify_701
    new $P376, "Undef"
  vivify_701:
    get_hll_global $P377, "GLOBAL"
    nqp_get_package_through_who $P378, $P377, "PAST"
    get_who $P379, $P378
    set $P380, $P379["Val"]
    find_lex $P381, "$name"
    unless_null $P381, vivify_702
    new $P381, "Undef"
  vivify_702:
    $P382 = $P380."new"($P381 :named("value"), "name" :named("named"))
    $P376."push"($P382)
  if_373_end:
.annotate 'line', 166
    find_lex $P384, "$repr"
    unless_null $P384, vivify_703
    new $P384, "Undef"
  vivify_703:
    defined $I385, $P384
    unless $I385, if_383_end
.annotate 'line', 167
    find_lex $P386, "$setup_call"
    unless_null $P386, vivify_704
    new $P386, "Undef"
  vivify_704:
    get_hll_global $P387, "GLOBAL"
    nqp_get_package_through_who $P388, $P387, "PAST"
    get_who $P389, $P388
    set $P390, $P389["Val"]
    find_lex $P391, "$repr"
    unless_null $P391, vivify_705
    new $P391, "Undef"
  vivify_705:
    $P392 = $P390."new"($P391 :named("value"), "repr" :named("named"))
    $P386."push"($P392)
  if_383_end:
.annotate 'line', 169
    find_lex $P393, "self"
.annotate 'line', 170
    find_lex $P394, "self"
    find_lex $P395, "$slot"
    unless_null $P395, vivify_706
    new $P395, "Undef"
  vivify_706:
    find_lex $P396, "self"
    find_lex $P397, "$setup_call"
    unless_null $P397, vivify_707
    new $P397, "Undef"
  vivify_707:
    $P398 = $P396."set_cur_sc"($P397)
    $P399 = $P394."set_slot_past"($P395, $P398)
    $P393."add_event"($P399 :named("deserialize_past"))
.annotate 'line', 173
    new $P400, "Exception"
    set $P400['type'], .CONTROL_RETURN
    find_lex $P401, "$mo"
    unless_null $P401, vivify_708
    new $P401, "Undef"
  vivify_708:
    setattribute $P400, 'payload', $P401
    throw $P400
.annotate 'line', 147
    .return ()
  control_327:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P402, exception, "payload"
    .return ($P402)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_add_attribute" :anon :subid("22_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_404
    .param pmc param_405
    .param pmc param_406
    .param pmc param_407
    .param pmc param_408
.annotate 'line', 181
    .const 'Sub' $P454 = "24_1305640955.436" 
    capture_lex $P454
    .const 'Sub' $P433 = "23_1305640955.436" 
    capture_lex $P433
    .lex "self", param_404
    .lex "$obj", param_405
    .lex "$meta_attr", param_406
    .lex "%lit_args", param_407
    .lex "%obj_args", param_408
.annotate 'line', 183
    new $P409, "Undef"
    .lex "$attr", $P409
.annotate 'line', 187
    new $P410, "Undef"
    .lex "$create_call", $P410
.annotate 'line', 199
    new $P411, "Undef"
    .lex "$obj_slot_past", $P411
.annotate 'line', 183
    find_lex $P412, "$meta_attr"
    unless_null $P412, vivify_709
    new $P412, "Undef"
  vivify_709:
    find_lex $P413, "%lit_args"
    unless_null $P413, vivify_710
    $P413 = root_new ['parrot';'Hash']
  vivify_710:
    find_lex $P414, "%obj_args"
    unless_null $P414, vivify_711
    $P414 = root_new ['parrot';'Hash']
  vivify_711:
    $P415 = $P412."new"($P413 :flat, $P414 :flat)
    store_lex "$attr", $P415
.annotate 'line', 184
    find_lex $P416, "$obj"
    unless_null $P416, vivify_712
    new $P416, "Undef"
  vivify_712:
    get_how $P417, $P416
    find_lex $P418, "$obj"
    unless_null $P418, vivify_713
    new $P418, "Undef"
  vivify_713:
    find_lex $P419, "$attr"
    unless_null $P419, vivify_714
    new $P419, "Undef"
  vivify_714:
    $P417."add_attribute"($P418, $P419)
.annotate 'line', 187
    get_hll_global $P420, "GLOBAL"
    nqp_get_package_through_who $P421, $P420, "PAST"
    get_who $P422, $P421
    set $P423, $P422["Op"]
.annotate 'line', 189
    find_lex $P424, "self"
    find_lex $P425, "$meta_attr"
    unless_null $P425, vivify_715
    new $P425, "Undef"
  vivify_715:
    $P426 = $P424."get_object_sc_ref_past"($P425)
    $P427 = $P423."new"($P426, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 187
    store_lex "$create_call", $P427
.annotate 'line', 191
    find_lex $P429, "%lit_args"
    unless_null $P429, vivify_716
    $P429 = root_new ['parrot';'Hash']
  vivify_716:
    defined $I430, $P429
    unless $I430, for_undef_717
    iter $P428, $P429
    new $P447, 'ExceptionHandler'
    set_label $P447, loop446_handler
    $P447."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P447
  loop446_test:
    unless $P428, loop446_done
    shift $P431, $P428
  loop446_redo:
    .const 'Sub' $P433 = "23_1305640955.436" 
    capture_lex $P433
    $P433($P431)
  loop446_next:
    goto loop446_test
  loop446_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P448, exception, 'type'
    eq $P448, .CONTROL_LOOP_NEXT, loop446_next
    eq $P448, .CONTROL_LOOP_REDO, loop446_redo
  loop446_done:
    pop_eh 
  for_undef_717:
.annotate 'line', 194
    find_lex $P450, "%obj_args"
    unless_null $P450, vivify_721
    $P450 = root_new ['parrot';'Hash']
  vivify_721:
    defined $I451, $P450
    unless $I451, for_undef_722
    iter $P449, $P450
    new $P468, 'ExceptionHandler'
    set_label $P468, loop467_handler
    $P468."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P468
  loop467_test:
    unless $P449, loop467_done
    shift $P452, $P449
  loop467_redo:
    .const 'Sub' $P454 = "24_1305640955.436" 
    capture_lex $P454
    $P454($P452)
  loop467_next:
    goto loop467_test
  loop467_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P469, exception, 'type'
    eq $P469, .CONTROL_LOOP_NEXT, loop467_next
    eq $P469, .CONTROL_LOOP_REDO, loop467_redo
  loop467_done:
    pop_eh 
  for_undef_722:
.annotate 'line', 199
    find_lex $P470, "self"
    find_lex $P471, "$obj"
    unless_null $P471, vivify_728
    new $P471, "Undef"
  vivify_728:
    $P472 = $P470."get_slot_past_for_object"($P471)
    store_lex "$obj_slot_past", $P472
.annotate 'line', 200
    find_lex $P473, "self"
    get_hll_global $P474, "GLOBAL"
    nqp_get_package_through_who $P475, $P474, "PAST"
    get_who $P476, $P475
    set $P477, $P476["Op"]
.annotate 'line', 202
    get_hll_global $P478, "GLOBAL"
    nqp_get_package_through_who $P479, $P478, "PAST"
    get_who $P480, $P479
    set $P481, $P480["Op"]
    find_lex $P482, "$obj_slot_past"
    unless_null $P482, vivify_729
    new $P482, "Undef"
  vivify_729:
    $P483 = $P481."new"($P482, "get_how PP" :named("pirop"))
    find_lex $P484, "$obj_slot_past"
    unless_null $P484, vivify_730
    new $P484, "Undef"
  vivify_730:
    find_lex $P485, "$create_call"
    unless_null $P485, vivify_731
    new $P485, "Undef"
  vivify_731:
    $P486 = $P477."new"($P483, $P484, $P485, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 200
    $P487 = $P473."add_event"($P486 :named("deserialize_past"))
.annotate 'line', 181
    .return ($P487)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block432"  :anon :subid("23_1305640955.436") :outer("22_1305640955.436")
    .param pmc param_434
.annotate 'line', 191
    .lex "$_", param_434
.annotate 'line', 192
    find_lex $P435, "$create_call"
    unless_null $P435, vivify_718
    new $P435, "Undef"
  vivify_718:
    get_hll_global $P436, "GLOBAL"
    nqp_get_package_through_who $P437, $P436, "PAST"
    get_who $P438, $P437
    set $P439, $P438["Val"]
    find_lex $P440, "$_"
    unless_null $P440, vivify_719
    new $P440, "Undef"
  vivify_719:
    $P441 = $P440."value"()
    find_lex $P442, "$_"
    unless_null $P442, vivify_720
    new $P442, "Undef"
  vivify_720:
    $P443 = $P442."key"()
    $P444 = $P439."new"($P441 :named("value"), $P443 :named("named"))
    $P445 = $P435."push"($P444)
.annotate 'line', 191
    .return ($P445)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block453"  :anon :subid("24_1305640955.436") :outer("22_1305640955.436")
    .param pmc param_456
.annotate 'line', 195
    new $P455, "Undef"
    .lex "$lookup", $P455
    .lex "$_", param_456
    find_lex $P457, "self"
    find_lex $P458, "$_"
    unless_null $P458, vivify_723
    new $P458, "Undef"
  vivify_723:
    $P459 = $P458."value"()
    $P460 = $P457."get_object_sc_ref_past"($P459)
    store_lex "$lookup", $P460
.annotate 'line', 196
    find_lex $P461, "$lookup"
    unless_null $P461, vivify_724
    new $P461, "Undef"
  vivify_724:
    find_lex $P462, "$_"
    unless_null $P462, vivify_725
    new $P462, "Undef"
  vivify_725:
    $P463 = $P462."key"()
    $P461."named"($P463)
.annotate 'line', 197
    find_lex $P464, "$create_call"
    unless_null $P464, vivify_726
    new $P464, "Undef"
  vivify_726:
    find_lex $P465, "$lookup"
    unless_null $P465, vivify_727
    new $P465, "Undef"
  vivify_727:
    $P466 = $P464."push"($P465)
.annotate 'line', 194
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_method" :anon :subid("25_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_489
    .param pmc param_490
    .param pmc param_491
    .param pmc param_492
    .param pmc param_493
    .param pmc param_494
.annotate 'line', 211
    .const 'Sub' $P534 = "27_1305640955.436" 
    capture_lex $P534
    .const 'Sub' $P500 = "26_1305640955.436" 
    capture_lex $P500
    .lex "self", param_489
    .lex "$obj", param_490
    .lex "$meta_method_name", param_491
    .lex "$name", param_492
    .lex "$method_past", param_493
    .lex "$is_dispatcher", param_494
.annotate 'line', 217
    new $P495, "Undef"
    .lex "$stub_code", $P495
.annotate 'line', 223
    new $P496, "Undef"
    .lex "$fixups", $P496
.annotate 'line', 224
    new $P497, "Undef"
    .lex "$dummy", $P497
.annotate 'line', 269
    new $P498, "Undef"
    .lex "$slot_past", $P498
.annotate 'line', 217
    .const 'Sub' $P500 = "26_1305640955.436" 
    newclosure $P514, $P500
    store_lex "$stub_code", $P514
.annotate 'line', 223
    get_hll_global $P515, "GLOBAL"
    nqp_get_package_through_who $P516, $P515, "PAST"
    get_who $P517, $P516
    set $P518, $P517["Stmts"]
    $P519 = $P518."new"()
    store_lex "$fixups", $P519
    find_lex $P520, "$dummy"
    unless_null $P520, vivify_736
    new $P520, "Undef"
  vivify_736:
.annotate 'line', 225
    find_lex $P522, "$method_past"
    unless_null $P522, vivify_737
    $P522 = root_new ['parrot';'Hash']
  vivify_737:
    set $P523, $P522["compile_time_dummy"]
    unless_null $P523, vivify_738
    new $P523, "Undef"
  vivify_738:
    defined $I524, $P523
    if $I524, if_521
.annotate 'line', 232
    find_lex $P528, "$is_dispatcher"
    unless_null $P528, vivify_739
    new $P528, "Undef"
  vivify_739:
    if $P528, if_527
.annotate 'line', 248
    find_lex $P557, "$stub_code"
    unless_null $P557, vivify_740
    new $P557, "Undef"
  vivify_740:
    clone $P558, $P557
    store_lex "$dummy", $P558
.annotate 'line', 247
    goto if_527_end
  if_527:
.annotate 'line', 233
    find_lex $P529, "$method_past"
    unless_null $P529, vivify_741
    new $P529, "Undef"
  vivify_741:
    $P529."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 234
    new $P530, "DispatcherSub"
    find_lex $P531, "$stub_code"
    unless_null $P531, vivify_742
    new $P531, "Undef"
  vivify_742:
    assign $P530, $P531
    store_lex "$dummy", $P530
.annotate 'line', 238
    find_lex $P532, "$dummy"
    unless_null $P532, vivify_743
    new $P532, "Undef"
  vivify_743:
    .const 'Sub' $P534 = "27_1305640955.436" 
    newclosure $P556, $P534
    setprop $P532, "CLONE_CALLBACK", $P556
  if_527_end:
.annotate 'line', 250
    find_lex $P559, "$dummy"
    unless_null $P559, vivify_748
    new $P559, "Undef"
  vivify_748:
    find_lex $P560, "$name"
    unless_null $P560, vivify_749
    new $P560, "Undef"
  vivify_749:
    set $S561, $P560
    assign $P559, $S561
.annotate 'line', 251
    find_lex $P562, "self"
    find_lex $P563, "$dummy"
    unless_null $P563, vivify_750
    new $P563, "Undef"
  vivify_750:
    $P562."add_code"($P563)
.annotate 'line', 252
    find_lex $P564, "$dummy"
    unless_null $P564, vivify_751
    new $P564, "Undef"
  vivify_751:
    find_lex $P565, "$method_past"
    unless_null $P565, vivify_752
    $P565 = root_new ['parrot';'Hash']
    store_lex "$method_past", $P565
  vivify_752:
    set $P565["compile_time_dummy"], $P564
.annotate 'line', 228
    goto if_521_end
  if_521:
.annotate 'line', 226
    find_lex $P525, "$method_past"
    unless_null $P525, vivify_753
    $P525 = root_new ['parrot';'Hash']
  vivify_753:
    set $P526, $P525["compile_time_dummy"]
    unless_null $P526, vivify_754
    new $P526, "Undef"
  vivify_754:
    store_lex "$dummy", $P526
  if_521_end:
.annotate 'line', 256
    find_lex $P566, "$dummy"
    unless_null $P566, vivify_755
    new $P566, "Undef"
  vivify_755:
    find_lex $P567, "$method_past"
    unless_null $P567, vivify_756
    new $P567, "Undef"
  vivify_756:
    setprop $P566, "PAST", $P567
.annotate 'line', 259
    find_lex $P568, "$obj"
    unless_null $P568, vivify_757
    new $P568, "Undef"
  vivify_757:
    get_how $P569, $P568
    find_lex $P570, "$obj"
    unless_null $P570, vivify_758
    new $P570, "Undef"
  vivify_758:
    find_lex $P571, "$name"
    unless_null $P571, vivify_759
    new $P571, "Undef"
  vivify_759:
    find_lex $P572, "$dummy"
    unless_null $P572, vivify_760
    new $P572, "Undef"
  vivify_760:
    find_lex $P573, "$meta_method_name"
    unless_null $P573, vivify_761
    new $P573, "Undef"
  vivify_761:
    set $S574, $P573
    $P569.$S574($P570, $P571, $P572)
.annotate 'line', 264
    find_lex $P575, "$fixups"
    unless_null $P575, vivify_762
    new $P575, "Undef"
  vivify_762:
    get_hll_global $P576, "GLOBAL"
    nqp_get_package_through_who $P577, $P576, "PAST"
    get_who $P578, $P577
    set $P579, $P578["Op"]
.annotate 'line', 266
    find_lex $P580, "self"
    find_lex $P581, "$dummy"
    unless_null $P581, vivify_763
    new $P581, "Undef"
  vivify_763:
    $P582 = $P580."get_slot_past_for_object"($P581)
.annotate 'line', 267
    get_hll_global $P583, "GLOBAL"
    nqp_get_package_through_who $P584, $P583, "PAST"
    get_who $P585, $P584
    set $P586, $P585["Val"]
    find_lex $P587, "$method_past"
    unless_null $P587, vivify_764
    new $P587, "Undef"
  vivify_764:
    $P588 = $P586."new"($P587 :named("value"))
    $P589 = $P579."new"($P582, $P588, "assign vPP" :named("pirop"))
.annotate 'line', 264
    $P575."push"($P589)
.annotate 'line', 269
    find_lex $P590, "self"
    find_lex $P591, "$obj"
    unless_null $P591, vivify_765
    new $P591, "Undef"
  vivify_765:
    $P592 = $P590."get_slot_past_for_object"($P591)
    store_lex "$slot_past", $P592
.annotate 'line', 270
    find_lex $P593, "self"
.annotate 'line', 271
    get_hll_global $P594, "GLOBAL"
    nqp_get_package_through_who $P595, $P594, "PAST"
    get_who $P596, $P595
    set $P597, $P596["Op"]
    find_lex $P598, "$meta_method_name"
    unless_null $P598, vivify_766
    new $P598, "Undef"
  vivify_766:
.annotate 'line', 273
    get_hll_global $P599, "GLOBAL"
    nqp_get_package_through_who $P600, $P599, "PAST"
    get_who $P601, $P600
    set $P602, $P601["Op"]
    find_lex $P603, "$slot_past"
    unless_null $P603, vivify_767
    new $P603, "Undef"
  vivify_767:
    $P604 = $P602."new"($P603, "get_how PP" :named("pirop"))
    find_lex $P605, "$slot_past"
    unless_null $P605, vivify_768
    new $P605, "Undef"
  vivify_768:
    find_lex $P606, "$name"
    unless_null $P606, vivify_769
    new $P606, "Undef"
  vivify_769:
.annotate 'line', 276
    get_hll_global $P607, "GLOBAL"
    nqp_get_package_through_who $P608, $P607, "PAST"
    get_who $P609, $P608
    set $P610, $P609["Val"]
    find_lex $P611, "$method_past"
    unless_null $P611, vivify_770
    new $P611, "Undef"
  vivify_770:
    $P612 = $P610."new"($P611 :named("value"))
    $P613 = $P597."new"($P604, $P605, $P606, $P612, "callmethod" :named("pasttype"), $P598 :named("name"))
.annotate 'line', 271
    find_lex $P614, "$fixups"
    unless_null $P614, vivify_771
    new $P614, "Undef"
  vivify_771:
    $P615 = $P593."add_event"($P613 :named("deserialize_past"), $P614 :named("fixup_past"))
.annotate 'line', 211
    .return ($P615)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block499"  :anon :subid("26_1305640955.436") :outer("25_1305640955.436")
    .param pmc param_501 :slurpy
    .param pmc param_502 :slurpy :named
.annotate 'line', 217
    .lex "@args", param_501
    .lex "%named", param_502
.annotate 'line', 218
    new $P503, "Undef"
    .lex "$compiled", $P503
    get_hll_global $P504, "GLOBAL"
    nqp_get_package_through_who $P505, $P504, "PAST"
    get_who $P506, $P505
    set $P507, $P506["Compiler"]
    find_lex $P508, "$method_past"
    unless_null $P508, vivify_732
    new $P508, "Undef"
  vivify_732:
    $P509 = $P507."compile"($P508)
    store_lex "$compiled", $P509
.annotate 'line', 219
    find_lex $P510, "$compiled"
    unless_null $P510, vivify_733
    new $P510, "Undef"
  vivify_733:
    find_lex $P511, "@args"
    unless_null $P511, vivify_734
    $P511 = root_new ['parrot';'ResizablePMCArray']
  vivify_734:
    find_lex $P512, "%named"
    unless_null $P512, vivify_735
    $P512 = root_new ['parrot';'Hash']
  vivify_735:
    $P513 = $P510($P511 :flat, $P512 :flat)
.annotate 'line', 217
    .return ($P513)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block533"  :anon :subid("27_1305640955.436") :outer("25_1305640955.436")
    .param pmc param_535
    .param pmc param_536
.annotate 'line', 238
    .lex "$orig", param_535
    .lex "$clone", param_536
.annotate 'line', 239
    find_lex $P537, "self"
    find_lex $P538, "$clone"
    unless_null $P538, vivify_744
    new $P538, "Undef"
  vivify_744:
    $P537."add_code"($P538)
.annotate 'line', 240
    find_lex $P539, "$fixups"
    unless_null $P539, vivify_745
    new $P539, "Undef"
  vivify_745:
    get_hll_global $P540, "GLOBAL"
    nqp_get_package_through_who $P541, $P540, "PAST"
    get_who $P542, $P541
    set $P543, $P542["Op"]
.annotate 'line', 242
    find_lex $P544, "self"
    find_lex $P545, "$clone"
    unless_null $P545, vivify_746
    new $P545, "Undef"
  vivify_746:
    $P546 = $P544."get_slot_past_for_object"($P545)
.annotate 'line', 243
    get_hll_global $P547, "GLOBAL"
    nqp_get_package_through_who $P548, $P547, "PAST"
    get_who $P549, $P548
    set $P550, $P549["Val"]
    find_lex $P551, "$orig"
    unless_null $P551, vivify_747
    new $P551, "Undef"
  vivify_747:
    getprop $P552, "PAST", $P551
    $P553 = $P550."new"($P552 :named("value"))
    $P554 = $P543."new"($P546, $P553, "assign vPP" :named("pirop"))
.annotate 'line', 240
    $P555 = $P539."push"($P554)
.annotate 'line', 238
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "set_routine_signature" :anon :subid("28_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_617
    .param pmc param_618
    .param pmc param_619
    .param pmc param_620
.annotate 'line', 282
    .lex "self", param_617
    .lex "$routine", param_618
    .lex "$types", param_619
    .lex "$definednesses", param_620
.annotate 'line', 285
    new $P621, "Undef"
    .lex "$fixup", $P621
.annotate 'line', 292
    new $P622, "Undef"
    .lex "$des", $P622
.annotate 'line', 285
    get_hll_global $P623, "GLOBAL"
    nqp_get_package_through_who $P624, $P623, "PAST"
    get_who $P625, $P624
    set $P626, $P625["Op"]
    find_lex $P627, "$types"
    unless_null $P627, vivify_772
    new $P627, "Undef"
  vivify_772:
    find_lex $P628, "$definednesses"
    unless_null $P628, vivify_773
    new $P628, "Undef"
  vivify_773:
    $P629 = $P626."new"($P627, $P628, "set_sub_multisig vPPP" :named("pirop"))
    store_lex "$fixup", $P629
.annotate 'line', 286
    find_lex $P631, "$routine"
    unless_null $P631, vivify_774
    $P631 = root_new ['parrot';'Hash']
  vivify_774:
    set $P632, $P631["compile_time_dummy"]
    unless_null $P632, vivify_775
    new $P632, "Undef"
  vivify_775:
    defined $I633, $P632
    if $I633, if_630
.annotate 'line', 290
    find_lex $P639, "$fixup"
    unless_null $P639, vivify_776
    new $P639, "Undef"
  vivify_776:
    get_hll_global $P640, "GLOBAL"
    nqp_get_package_through_who $P641, $P640, "PAST"
    get_who $P642, $P641
    set $P643, $P642["Val"]
    find_lex $P644, "$routine"
    unless_null $P644, vivify_777
    new $P644, "Undef"
  vivify_777:
    $P645 = $P643."new"($P644 :named("value"))
    $P639."unshift"($P645)
.annotate 'line', 289
    goto if_630_end
  if_630:
.annotate 'line', 287
    find_lex $P634, "$fixup"
    unless_null $P634, vivify_778
    new $P634, "Undef"
  vivify_778:
    find_lex $P635, "self"
    find_lex $P636, "$routine"
    unless_null $P636, vivify_779
    $P636 = root_new ['parrot';'Hash']
  vivify_779:
    set $P637, $P636["compile_time_dummy"]
    unless_null $P637, vivify_780
    new $P637, "Undef"
  vivify_780:
    $P638 = $P635."get_slot_past_for_object"($P637)
    $P634."unshift"($P638)
  if_630_end:
.annotate 'line', 292
    get_hll_global $P646, "GLOBAL"
    nqp_get_package_through_who $P647, $P646, "PAST"
    get_who $P648, $P647
    set $P649, $P648["Op"]
.annotate 'line', 293
    get_hll_global $P650, "GLOBAL"
    nqp_get_package_through_who $P651, $P650, "PAST"
    get_who $P652, $P651
    set $P653, $P652["Val"]
    find_lex $P654, "$routine"
    unless_null $P654, vivify_781
    new $P654, "Undef"
  vivify_781:
    $P655 = $P653."new"($P654 :named("value"))
    find_lex $P656, "$types"
    unless_null $P656, vivify_782
    new $P656, "Undef"
  vivify_782:
    find_lex $P657, "$definednesses"
    unless_null $P657, vivify_783
    new $P657, "Undef"
  vivify_783:
    $P658 = $P649."new"($P655, $P656, $P657, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 292
    store_lex "$des", $P658
.annotate 'line', 295
    find_lex $P659, "self"
    find_lex $P660, "$des"
    unless_null $P660, vivify_784
    new $P660, "Undef"
  vivify_784:
    find_lex $P661, "$fixup"
    unless_null $P661, vivify_785
    new $P661, "Undef"
  vivify_785:
    $P662 = $P659."add_event"($P660 :named("deserialize_past"), $P661 :named("fixup_past"))
.annotate 'line', 282
    .return ($P662)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_set_body_block" :anon :subid("29_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_664
    .param pmc param_665
    .param pmc param_666
.annotate 'line', 299
    .const 'Sub' $P677 = "30_1305640955.436" 
    capture_lex $P677
    .lex "self", param_664
    .lex "$obj", param_665
    .lex "$body_past", param_666
.annotate 'line', 310
    new $P667, "Undef"
    .lex "$fixups", $P667
.annotate 'line', 311
    new $P668, "Undef"
    .lex "$dummy", $P668
.annotate 'line', 346
    new $P669, "Undef"
    .lex "$slot_past", $P669
.annotate 'line', 347
    new $P670, "Undef"
    .lex "$des", $P670
.annotate 'line', 310
    get_hll_global $P671, "GLOBAL"
    nqp_get_package_through_who $P672, $P671, "PAST"
    get_who $P673, $P672
    set $P674, $P673["Stmts"]
    $P675 = $P674."new"()
    store_lex "$fixups", $P675
.annotate 'line', 311
    .const 'Sub' $P677 = "30_1305640955.436" 
    newclosure $P748, $P677
    store_lex "$dummy", $P748
.annotate 'line', 343
    find_lex $P749, "$obj"
    unless_null $P749, vivify_803
    new $P749, "Undef"
  vivify_803:
    get_how $P750, $P749
    find_lex $P751, "$obj"
    unless_null $P751, vivify_804
    new $P751, "Undef"
  vivify_804:
    find_lex $P752, "$dummy"
    unless_null $P752, vivify_805
    new $P752, "Undef"
  vivify_805:
    $P750."set_body_block"($P751, $P752)
.annotate 'line', 346
    find_lex $P753, "self"
    find_lex $P754, "$obj"
    unless_null $P754, vivify_806
    new $P754, "Undef"
  vivify_806:
    $P755 = $P753."get_slot_past_for_object"($P754)
    store_lex "$slot_past", $P755
.annotate 'line', 347
    get_hll_global $P756, "GLOBAL"
    nqp_get_package_through_who $P757, $P756, "PAST"
    get_who $P758, $P757
    set $P759, $P758["Op"]
.annotate 'line', 349
    get_hll_global $P760, "GLOBAL"
    nqp_get_package_through_who $P761, $P760, "PAST"
    get_who $P762, $P761
    set $P763, $P762["Op"]
    find_lex $P764, "$slot_past"
    unless_null $P764, vivify_807
    new $P764, "Undef"
  vivify_807:
    $P765 = $P763."new"($P764, "get_how PP" :named("pirop"))
    find_lex $P766, "$slot_past"
    unless_null $P766, vivify_808
    new $P766, "Undef"
  vivify_808:
.annotate 'line', 351
    get_hll_global $P767, "GLOBAL"
    nqp_get_package_through_who $P768, $P767, "PAST"
    get_who $P769, $P768
    set $P770, $P769["Val"]
    find_lex $P771, "$body_past"
    unless_null $P771, vivify_809
    new $P771, "Undef"
  vivify_809:
    $P772 = $P770."new"($P771 :named("value"))
    $P773 = $P759."new"($P765, $P766, $P772, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 347
    store_lex "$des", $P773
.annotate 'line', 354
    find_lex $P774, "self"
    find_lex $P775, "$des"
    unless_null $P775, vivify_810
    new $P775, "Undef"
  vivify_810:
    find_lex $P776, "$fixups"
    unless_null $P776, vivify_811
    new $P776, "Undef"
  vivify_811:
    $P777 = $P774."add_event"($P775 :named("deserialize_past"), $P776 :named("fixup_past"))
.annotate 'line', 299
    .return ($P777)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block676"  :anon :subid("30_1305640955.436") :outer("29_1305640955.436")
    .param pmc param_678 :slurpy
.annotate 'line', 311
    .const 'Sub' $P716 = "32_1305640955.436" 
    capture_lex $P716
    .const 'Sub' $P696 = "31_1305640955.436" 
    capture_lex $P696
    .lex "@type_args", param_678
.annotate 'line', 313
    new $P679, "Undef"
    .lex "$invoke_body", $P679
    get_hll_global $P680, "GLOBAL"
    nqp_get_package_through_who $P681, $P680, "PAST"
    get_who $P682, $P681
    set $P683, $P682["Op"]
.annotate 'line', 315
    get_hll_global $P684, "GLOBAL"
    nqp_get_package_through_who $P685, $P684, "PAST"
    get_who $P686, $P685
    set $P687, $P686["Val"]
    find_lex $P688, "$body_past"
    unless_null $P688, vivify_786
    new $P688, "Undef"
  vivify_786:
    $P689 = $P687."new"($P688 :named("value"))
    $P690 = $P683."new"($P689, "call" :named("pasttype"))
.annotate 'line', 313
    store_lex "$invoke_body", $P690
.annotate 'line', 317
    find_lex $P692, "@type_args"
    unless_null $P692, vivify_787
    $P692 = root_new ['parrot';'ResizablePMCArray']
  vivify_787:
    defined $I693, $P692
    unless $I693, for_undef_788
    iter $P691, $P692
    new $P704, 'ExceptionHandler'
    set_label $P704, loop703_handler
    $P704."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P704
  loop703_test:
    unless $P691, loop703_done
    shift $P694, $P691
  loop703_redo:
    .const 'Sub' $P696 = "31_1305640955.436" 
    capture_lex $P696
    $P696($P694)
  loop703_next:
    goto loop703_test
  loop703_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P705, exception, 'type'
    eq $P705, .CONTROL_LOOP_NEXT, loop703_next
    eq $P705, .CONTROL_LOOP_REDO, loop703_redo
  loop703_done:
    pop_eh 
  for_undef_788:
.annotate 'line', 320
    find_lex $P706, "$fixups"
    unless_null $P706, vivify_791
    new $P706, "Undef"
  vivify_791:
    find_lex $P707, "$invoke_body"
    unless_null $P707, vivify_792
    new $P707, "Undef"
  vivify_792:
    $P706."push"($P707)
.annotate 'line', 323
    find_lex $P709, "$obj"
    unless_null $P709, vivify_793
    new $P709, "Undef"
  vivify_793:
    get_how $P710, $P709
    find_lex $P711, "$obj"
    unless_null $P711, vivify_794
    new $P711, "Undef"
  vivify_794:
    $P712 = $P710."methods"($P711, 1 :named("local"))
    defined $I713, $P712
    unless $I713, for_undef_795
    iter $P708, $P712
    new $P746, 'ExceptionHandler'
    set_label $P746, loop745_handler
    $P746."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P746
  loop745_test:
    unless $P708, loop745_done
    shift $P714, $P708
  loop745_redo:
    .const 'Sub' $P716 = "32_1305640955.436" 
    capture_lex $P716
    $P716($P714)
  loop745_next:
    goto loop745_test
  loop745_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P747, exception, 'type'
    eq $P747, .CONTROL_LOOP_NEXT, loop745_next
    eq $P747, .CONTROL_LOOP_REDO, loop745_redo
  loop745_done:
    pop_eh 
  for_undef_795:
.annotate 'line', 311
    .return ($P708)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block695"  :anon :subid("31_1305640955.436") :outer("30_1305640955.436")
    .param pmc param_697
.annotate 'line', 317
    .lex "$_", param_697
.annotate 'line', 318
    find_lex $P698, "$invoke_body"
    unless_null $P698, vivify_789
    new $P698, "Undef"
  vivify_789:
    find_lex $P699, "self"
    find_lex $P700, "$_"
    unless_null $P700, vivify_790
    new $P700, "Undef"
  vivify_790:
    $P701 = $P699."get_slot_past_for_object"($P700)
    $P702 = $P698."push"($P701)
.annotate 'line', 317
    .return ($P702)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block715"  :anon :subid("32_1305640955.436") :outer("30_1305640955.436")
    .param pmc param_717
.annotate 'line', 323
    .const 'Sub' $P720 = "33_1305640955.436" 
    capture_lex $P720
    .lex "$_", param_717
.annotate 'line', 324
    find_lex $P718, "$_"
    unless_null $P718, vivify_796
    new $P718, "Undef"
  vivify_796:
    .const 'Sub' $P720 = "33_1305640955.436" 
    newclosure $P744, $P720
    setprop $P718, "REIFY_CALLBACK", $P744
.annotate 'line', 323
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block719"  :anon :subid("33_1305640955.436") :outer("32_1305640955.436")
    .param pmc param_721
.annotate 'line', 324
    .lex "$meth", param_721
.annotate 'line', 326
    new $P722, "Undef"
    .lex "$clone", $P722
    find_lex $P723, "$meth"
    unless_null $P723, vivify_797
    new $P723, "Undef"
  vivify_797:
    clone $P724, $P723
    store_lex "$clone", $P724
.annotate 'line', 327
    find_lex $P725, "self"
    find_lex $P726, "$clone"
    unless_null $P726, vivify_798
    new $P726, "Undef"
  vivify_798:
    $P725."add_code"($P726)
.annotate 'line', 330
    find_lex $P727, "$fixups"
    unless_null $P727, vivify_799
    new $P727, "Undef"
  vivify_799:
    get_hll_global $P728, "GLOBAL"
    nqp_get_package_through_who $P729, $P728, "PAST"
    get_who $P730, $P729
    set $P731, $P730["Op"]
.annotate 'line', 332
    find_lex $P732, "self"
    find_lex $P733, "$clone"
    unless_null $P733, vivify_800
    new $P733, "Undef"
  vivify_800:
    $P734 = $P732."get_slot_past_for_object"($P733)
.annotate 'line', 333
    get_hll_global $P735, "GLOBAL"
    nqp_get_package_through_who $P736, $P735, "PAST"
    get_who $P737, $P736
    set $P738, $P737["Val"]
    find_lex $P739, "$meth"
    unless_null $P739, vivify_801
    new $P739, "Undef"
  vivify_801:
    getprop $P740, "PAST", $P739
    $P741 = $P738."new"($P740 :named("value"))
    $P742 = $P731."new"($P734, $P741, "assign vPP" :named("pirop"))
.annotate 'line', 330
    $P727."push"($P742)
    find_lex $P743, "$clone"
    unless_null $P743, vivify_802
    new $P743, "Undef"
  vivify_802:
.annotate 'line', 324
    .return ($P743)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parent_or_role" :anon :subid("34_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_779
    .param pmc param_780
    .param pmc param_781
    .param pmc param_782
.annotate 'line', 359
    .lex "self", param_779
    .lex "$obj", param_780
    .lex "$meta_method_name", param_781
    .lex "$to_add", param_782
.annotate 'line', 364
    new $P783, "Undef"
    .lex "$slot_past", $P783
.annotate 'line', 361
    find_lex $P784, "$obj"
    unless_null $P784, vivify_812
    new $P784, "Undef"
  vivify_812:
    get_how $P785, $P784
    find_lex $P786, "$obj"
    unless_null $P786, vivify_813
    new $P786, "Undef"
  vivify_813:
    find_lex $P787, "$to_add"
    unless_null $P787, vivify_814
    new $P787, "Undef"
  vivify_814:
    find_lex $P788, "$meta_method_name"
    unless_null $P788, vivify_815
    new $P788, "Undef"
  vivify_815:
    set $S789, $P788
    $P785.$S789($P786, $P787)
.annotate 'line', 364
    find_lex $P790, "self"
    find_lex $P791, "$obj"
    unless_null $P791, vivify_816
    new $P791, "Undef"
  vivify_816:
    $P792 = $P790."get_slot_past_for_object"($P791)
    store_lex "$slot_past", $P792
.annotate 'line', 365
    find_lex $P793, "self"
    get_hll_global $P794, "GLOBAL"
    nqp_get_package_through_who $P795, $P794, "PAST"
    get_who $P796, $P795
    set $P797, $P796["Op"]
    find_lex $P798, "$meta_method_name"
    unless_null $P798, vivify_817
    new $P798, "Undef"
  vivify_817:
.annotate 'line', 367
    get_hll_global $P799, "GLOBAL"
    nqp_get_package_through_who $P800, $P799, "PAST"
    get_who $P801, $P800
    set $P802, $P801["Op"]
    find_lex $P803, "$slot_past"
    unless_null $P803, vivify_818
    new $P803, "Undef"
  vivify_818:
    $P804 = $P802."new"($P803, "get_how PP" :named("pirop"))
    find_lex $P805, "$slot_past"
    unless_null $P805, vivify_819
    new $P805, "Undef"
  vivify_819:
.annotate 'line', 369
    find_lex $P806, "self"
    find_lex $P807, "$to_add"
    unless_null $P807, vivify_820
    new $P807, "Undef"
  vivify_820:
    $P808 = $P806."get_object_sc_ref_past"($P807)
    $P809 = $P797."new"($P804, $P805, $P808, "callmethod" :named("pasttype"), $P798 :named("name"))
.annotate 'line', 365
    $P810 = $P793."add_event"($P809 :named("deserialize_past"))
.annotate 'line', 359
    .return ($P810)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parrot_vtable_handler_mapping" :anon :subid("35_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_812
    .param pmc param_813
    .param pmc param_814
    .param pmc param_815
.annotate 'line', 373
    .lex "self", param_812
    .lex "$obj", param_813
    .lex "$name", param_814
    .lex "$att_name", param_815
.annotate 'line', 378
    new $P816, "Undef"
    .lex "$slot_past", $P816
.annotate 'line', 375
    find_lex $P817, "$obj"
    unless_null $P817, vivify_821
    new $P817, "Undef"
  vivify_821:
    get_how $P818, $P817
    find_lex $P819, "$obj"
    unless_null $P819, vivify_822
    new $P819, "Undef"
  vivify_822:
    find_lex $P820, "$name"
    unless_null $P820, vivify_823
    new $P820, "Undef"
  vivify_823:
    find_lex $P821, "$att_name"
    unless_null $P821, vivify_824
    new $P821, "Undef"
  vivify_824:
    $P818."add_parrot_vtable_handler_mapping"($P819, $P820, $P821)
.annotate 'line', 378
    find_lex $P822, "self"
    find_lex $P823, "$obj"
    unless_null $P823, vivify_825
    new $P823, "Undef"
  vivify_825:
    $P824 = $P822."get_slot_past_for_object"($P823)
    store_lex "$slot_past", $P824
.annotate 'line', 379
    find_lex $P825, "self"
    get_hll_global $P826, "GLOBAL"
    nqp_get_package_through_who $P827, $P826, "PAST"
    get_who $P828, $P827
    set $P829, $P828["Op"]
.annotate 'line', 381
    get_hll_global $P830, "GLOBAL"
    nqp_get_package_through_who $P831, $P830, "PAST"
    get_who $P832, $P831
    set $P833, $P832["Op"]
    find_lex $P834, "$slot_past"
    unless_null $P834, vivify_826
    new $P834, "Undef"
  vivify_826:
    $P835 = $P833."new"($P834, "get_how PP" :named("pirop"))
    find_lex $P836, "$slot_past"
    unless_null $P836, vivify_827
    new $P836, "Undef"
  vivify_827:
    find_lex $P837, "$name"
    unless_null $P837, vivify_828
    new $P837, "Undef"
  vivify_828:
    find_lex $P838, "$att_name"
    unless_null $P838, vivify_829
    new $P838, "Undef"
  vivify_829:
    $P839 = $P829."new"($P835, $P836, $P837, $P838, "callmethod" :named("pasttype"), "add_parrot_vtable_handler_mapping" :named("name"))
.annotate 'line', 379
    $P840 = $P825."add_event"($P839 :named("deserialize_past"))
.annotate 'line', 373
    .return ($P840)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_compose" :anon :subid("36_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_842
    .param pmc param_843
.annotate 'line', 388
    .lex "self", param_842
    .lex "$obj", param_843
.annotate 'line', 393
    new $P844, "Undef"
    .lex "$slot_past", $P844
.annotate 'line', 390
    find_lex $P845, "$obj"
    unless_null $P845, vivify_830
    new $P845, "Undef"
  vivify_830:
    get_how $P846, $P845
    find_lex $P847, "$obj"
    unless_null $P847, vivify_831
    new $P847, "Undef"
  vivify_831:
    $P846."compose"($P847)
.annotate 'line', 393
    find_lex $P848, "self"
    find_lex $P849, "$obj"
    unless_null $P849, vivify_832
    new $P849, "Undef"
  vivify_832:
    $P850 = $P848."get_slot_past_for_object"($P849)
    store_lex "$slot_past", $P850
.annotate 'line', 394
    find_lex $P851, "self"
    get_hll_global $P852, "GLOBAL"
    nqp_get_package_through_who $P853, $P852, "PAST"
    get_who $P854, $P853
    set $P855, $P854["Op"]
.annotate 'line', 396
    get_hll_global $P856, "GLOBAL"
    nqp_get_package_through_who $P857, $P856, "PAST"
    get_who $P858, $P857
    set $P859, $P858["Op"]
    find_lex $P860, "$slot_past"
    unless_null $P860, vivify_833
    new $P860, "Undef"
  vivify_833:
    $P861 = $P859."new"($P860, "get_how PP" :named("pirop"))
    find_lex $P862, "$slot_past"
    unless_null $P862, vivify_834
    new $P862, "Undef"
  vivify_834:
    $P863 = $P855."new"($P861, $P862, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 394
    $P864 = $P851."add_event"($P863 :named("deserialize_past"))
.annotate 'line', 388
    .return ($P864)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "to_past" :anon :subid("37_1305640955.436") :outer("12_1305640955.436")
    .param pmc param_866
.annotate 'line', 403
    .const 'Sub' $P885 = "38_1305640955.436" 
    capture_lex $P885
    .lex "self", param_866
.annotate 'line', 404
    new $P867, "Undef"
    .lex "$des", $P867
.annotate 'line', 405
    new $P868, "Undef"
    .lex "$fix", $P868
.annotate 'line', 404
    get_hll_global $P869, "GLOBAL"
    nqp_get_package_through_who $P870, $P869, "PAST"
    get_who $P871, $P870
    set $P872, $P871["Stmts"]
    $P873 = $P872."new"()
    store_lex "$des", $P873
.annotate 'line', 405
    get_hll_global $P874, "GLOBAL"
    nqp_get_package_through_who $P875, $P874, "PAST"
    get_who $P876, $P875
    set $P877, $P876["Stmts"]
    $P878 = $P877."new"()
    store_lex "$fix", $P878
.annotate 'line', 406
    find_lex $P880, "self"
    $P881 = $P880."event_stream"()
    defined $I882, $P881
    unless $I882, for_undef_835
    iter $P879, $P881
    new $P904, 'ExceptionHandler'
    set_label $P904, loop903_handler
    $P904."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P904
  loop903_test:
    unless $P879, loop903_done
    shift $P883, $P879
  loop903_redo:
    .const 'Sub' $P885 = "38_1305640955.436" 
    capture_lex $P885
    $P885($P883)
  loop903_next:
    goto loop903_test
  loop903_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P905, exception, 'type'
    eq $P905, .CONTROL_LOOP_NEXT, loop903_next
    eq $P905, .CONTROL_LOOP_REDO, loop903_redo
  loop903_done:
    pop_eh 
  for_undef_835:
.annotate 'line', 410
    find_dynamic_lex $P906, "$/"
    get_hll_global $P907, "GLOBAL"
    nqp_get_package_through_who $P908, $P907, "PAST"
    get_who $P909, $P908
    set $P910, $P909["Op"]
.annotate 'line', 412
    get_hll_global $P911, "GLOBAL"
    nqp_get_package_through_who $P912, $P911, "PAST"
    get_who $P913, $P912
    set $P914, $P913["Op"]
.annotate 'line', 414
    get_hll_global $P915, "GLOBAL"
    nqp_get_package_through_who $P916, $P915, "PAST"
    get_who $P917, $P916
    set $P918, $P917["Op"]
    find_lex $P919, "self"
    $P920 = $P919."handle"()
    $P921 = $P918."new"($P920, "nqp_get_sc Ps" :named("pirop"))
    $P922 = $P914."new"($P921, "isnull IP" :named("pirop"))
.annotate 'line', 416
    get_hll_global $P923, "GLOBAL"
    nqp_get_package_through_who $P924, $P923, "PAST"
    get_who $P925, $P924
    set $P926, $P925["Stmts"]
.annotate 'line', 417
    get_hll_global $P927, "GLOBAL"
    nqp_get_package_through_who $P928, $P927, "PAST"
    get_who $P929, $P928
    set $P930, $P929["Op"]
    $P931 = $P930."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 418
    get_hll_global $P932, "GLOBAL"
    nqp_get_package_through_who $P933, $P932, "PAST"
    get_who $P934, $P933
    set $P935, $P934["Op"]
.annotate 'line', 420
    get_hll_global $P936, "GLOBAL"
    nqp_get_package_through_who $P937, $P936, "PAST"
    get_who $P938, $P937
    set $P939, $P938["Op"]
    $P940 = $P939."new"("getinterp P" :named("pirop"))
.annotate 'line', 421
    get_hll_global $P941, "GLOBAL"
    nqp_get_package_through_who $P942, $P941, "PAST"
    get_who $P943, $P942
    set $P944, $P943["Op"]
    $P945 = $P944."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 422
    get_hll_global $P946, "GLOBAL"
    nqp_get_package_through_who $P947, $P946, "PAST"
    get_who $P948, $P947
    set $P949, $P948["Op"]
    $P950 = $P949."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P951 = $P935."new"($P940, $P945, $P950, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 424
    get_hll_global $P952, "GLOBAL"
    nqp_get_package_through_who $P953, $P952, "PAST"
    get_who $P954, $P953
    set $P955, $P954["Op"]
.annotate 'line', 426
    get_hll_global $P956, "GLOBAL"
    nqp_get_package_through_who $P957, $P956, "PAST"
    get_who $P958, $P957
    set $P959, $P958["Var"]
    $P960 = $P959."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 427
    get_hll_global $P961, "GLOBAL"
    nqp_get_package_through_who $P962, $P961, "PAST"
    get_who $P963, $P962
    set $P964, $P963["Op"]
    find_lex $P965, "self"
    $P966 = $P965."handle"()
    $P967 = $P964."new"($P966, "nqp_create_sc Ps" :named("pirop"))
    $P968 = $P955."new"($P960, $P967, "bind" :named("pasttype"))
.annotate 'line', 424
    find_lex $P969, "$des"
    unless_null $P969, vivify_842
    new $P969, "Undef"
  vivify_842:
    $P970 = $P926."new"($P931, $P951, $P968, $P969)
.annotate 'line', 416
    find_lex $P971, "$fix"
    unless_null $P971, vivify_843
    new $P971, "Undef"
  vivify_843:
    $P972 = $P910."new"($P922, $P970, $P971, "if" :named("pasttype"))
.annotate 'line', 410
    $P973 = $P906."!make"($P972)
.annotate 'line', 403
    .return ($P973)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block884"  :anon :subid("38_1305640955.436") :outer("37_1305640955.436")
    .param pmc param_886
.annotate 'line', 406
    .lex "$_", param_886
.annotate 'line', 407
    find_lex $P888, "$_"
    unless_null $P888, vivify_836
    new $P888, "Undef"
  vivify_836:
    $P889 = $P888."deserialize_past"()
    defined $I890, $P889
    unless $I890, if_887_end
    find_lex $P891, "$des"
    unless_null $P891, vivify_837
    new $P891, "Undef"
  vivify_837:
    find_lex $P892, "$_"
    unless_null $P892, vivify_838
    new $P892, "Undef"
  vivify_838:
    $P893 = $P892."deserialize_past"()
    $P891."push"($P893)
  if_887_end:
.annotate 'line', 408
    find_lex $P896, "$_"
    unless_null $P896, vivify_839
    new $P896, "Undef"
  vivify_839:
    $P897 = $P896."fixup_past"()
    defined $I898, $P897
    if $I898, if_895
    new $P894, 'Integer'
    set $P894, $I898
    goto if_895_end
  if_895:
    find_lex $P899, "$fix"
    unless_null $P899, vivify_840
    new $P899, "Undef"
  vivify_840:
    find_lex $P900, "$_"
    unless_null $P900, vivify_841
    new $P900, "Undef"
  vivify_841:
    $P901 = $P900."fixup_past"()
    $P902 = $P899."push"($P901)
    set $P894, $P902
  if_895_end:
.annotate 'line', 406
    .return ($P894)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block975"  :subid("39_1305640955.436") :outer("10_1305640955.436")
.annotate 'line', 437
    .const 'Sub' $P2847 = "413_1305640955.436" 
    capture_lex $P2847
    .const 'Sub' $P2845 = "412_1305640955.436" 
    capture_lex $P2845
    .const 'Sub' $P2841 = "411_1305640955.436" 
    capture_lex $P2841
    .const 'Sub' $P2839 = "410_1305640955.436" 
    capture_lex $P2839
    .const 'Sub' $P2835 = "409_1305640955.436" 
    capture_lex $P2835
    .const 'Sub' $P2833 = "408_1305640955.436" 
    capture_lex $P2833
    .const 'Sub' $P2829 = "407_1305640955.436" 
    capture_lex $P2829
    .const 'Sub' $P2827 = "406_1305640955.436" 
    capture_lex $P2827
    .const 'Sub' $P2823 = "405_1305640955.436" 
    capture_lex $P2823
    .const 'Sub' $P2821 = "404_1305640955.436" 
    capture_lex $P2821
    .const 'Sub' $P2811 = "402_1305640955.436" 
    capture_lex $P2811
    .const 'Sub' $P2808 = "401_1305640955.436" 
    capture_lex $P2808
    .const 'Sub' $P2804 = "400_1305640955.436" 
    capture_lex $P2804
    .const 'Sub' $P2801 = "399_1305640955.436" 
    capture_lex $P2801
    .const 'Sub' $P2797 = "398_1305640955.436" 
    capture_lex $P2797
    .const 'Sub' $P2794 = "397_1305640955.436" 
    capture_lex $P2794
    .const 'Sub' $P2790 = "396_1305640955.436" 
    capture_lex $P2790
    .const 'Sub' $P2787 = "395_1305640955.436" 
    capture_lex $P2787
    .const 'Sub' $P2783 = "394_1305640955.436" 
    capture_lex $P2783
    .const 'Sub' $P2780 = "393_1305640955.436" 
    capture_lex $P2780
    .const 'Sub' $P2777 = "392_1305640955.436" 
    capture_lex $P2777
    .const 'Sub' $P2774 = "391_1305640955.436" 
    capture_lex $P2774
    .const 'Sub' $P2770 = "390_1305640955.436" 
    capture_lex $P2770
    .const 'Sub' $P2767 = "389_1305640955.436" 
    capture_lex $P2767
    .const 'Sub' $P2763 = "388_1305640955.436" 
    capture_lex $P2763
    .const 'Sub' $P2760 = "387_1305640955.436" 
    capture_lex $P2760
    .const 'Sub' $P2756 = "386_1305640955.436" 
    capture_lex $P2756
    .const 'Sub' $P2753 = "385_1305640955.436" 
    capture_lex $P2753
    .const 'Sub' $P2749 = "384_1305640955.436" 
    capture_lex $P2749
    .const 'Sub' $P2746 = "383_1305640955.436" 
    capture_lex $P2746
    .const 'Sub' $P2742 = "382_1305640955.436" 
    capture_lex $P2742
    .const 'Sub' $P2739 = "381_1305640955.436" 
    capture_lex $P2739
    .const 'Sub' $P2735 = "380_1305640955.436" 
    capture_lex $P2735
    .const 'Sub' $P2732 = "379_1305640955.436" 
    capture_lex $P2732
    .const 'Sub' $P2728 = "378_1305640955.436" 
    capture_lex $P2728
    .const 'Sub' $P2725 = "377_1305640955.436" 
    capture_lex $P2725
    .const 'Sub' $P2721 = "376_1305640955.436" 
    capture_lex $P2721
    .const 'Sub' $P2718 = "375_1305640955.436" 
    capture_lex $P2718
    .const 'Sub' $P2714 = "374_1305640955.436" 
    capture_lex $P2714
    .const 'Sub' $P2711 = "373_1305640955.436" 
    capture_lex $P2711
    .const 'Sub' $P2707 = "372_1305640955.436" 
    capture_lex $P2707
    .const 'Sub' $P2704 = "371_1305640955.436" 
    capture_lex $P2704
    .const 'Sub' $P2700 = "370_1305640955.436" 
    capture_lex $P2700
    .const 'Sub' $P2697 = "369_1305640955.436" 
    capture_lex $P2697
    .const 'Sub' $P2693 = "368_1305640955.436" 
    capture_lex $P2693
    .const 'Sub' $P2690 = "367_1305640955.436" 
    capture_lex $P2690
    .const 'Sub' $P2686 = "366_1305640955.436" 
    capture_lex $P2686
    .const 'Sub' $P2683 = "365_1305640955.436" 
    capture_lex $P2683
    .const 'Sub' $P2679 = "364_1305640955.436" 
    capture_lex $P2679
    .const 'Sub' $P2676 = "363_1305640955.436" 
    capture_lex $P2676
    .const 'Sub' $P2672 = "362_1305640955.436" 
    capture_lex $P2672
    .const 'Sub' $P2669 = "361_1305640955.436" 
    capture_lex $P2669
    .const 'Sub' $P2665 = "360_1305640955.436" 
    capture_lex $P2665
    .const 'Sub' $P2662 = "359_1305640955.436" 
    capture_lex $P2662
    .const 'Sub' $P2658 = "358_1305640955.436" 
    capture_lex $P2658
    .const 'Sub' $P2655 = "357_1305640955.436" 
    capture_lex $P2655
    .const 'Sub' $P2651 = "356_1305640955.436" 
    capture_lex $P2651
    .const 'Sub' $P2648 = "355_1305640955.436" 
    capture_lex $P2648
    .const 'Sub' $P2644 = "354_1305640955.436" 
    capture_lex $P2644
    .const 'Sub' $P2641 = "353_1305640955.436" 
    capture_lex $P2641
    .const 'Sub' $P2637 = "352_1305640955.436" 
    capture_lex $P2637
    .const 'Sub' $P2634 = "351_1305640955.436" 
    capture_lex $P2634
    .const 'Sub' $P2630 = "350_1305640955.436" 
    capture_lex $P2630
    .const 'Sub' $P2627 = "349_1305640955.436" 
    capture_lex $P2627
    .const 'Sub' $P2623 = "348_1305640955.436" 
    capture_lex $P2623
    .const 'Sub' $P2620 = "347_1305640955.436" 
    capture_lex $P2620
    .const 'Sub' $P2616 = "346_1305640955.436" 
    capture_lex $P2616
    .const 'Sub' $P2613 = "345_1305640955.436" 
    capture_lex $P2613
    .const 'Sub' $P2609 = "344_1305640955.436" 
    capture_lex $P2609
    .const 'Sub' $P2606 = "343_1305640955.436" 
    capture_lex $P2606
    .const 'Sub' $P2602 = "342_1305640955.436" 
    capture_lex $P2602
    .const 'Sub' $P2599 = "341_1305640955.436" 
    capture_lex $P2599
    .const 'Sub' $P2595 = "340_1305640955.436" 
    capture_lex $P2595
    .const 'Sub' $P2592 = "339_1305640955.436" 
    capture_lex $P2592
    .const 'Sub' $P2588 = "338_1305640955.436" 
    capture_lex $P2588
    .const 'Sub' $P2585 = "337_1305640955.436" 
    capture_lex $P2585
    .const 'Sub' $P2581 = "336_1305640955.436" 
    capture_lex $P2581
    .const 'Sub' $P2578 = "335_1305640955.436" 
    capture_lex $P2578
    .const 'Sub' $P2574 = "334_1305640955.436" 
    capture_lex $P2574
    .const 'Sub' $P2572 = "333_1305640955.436" 
    capture_lex $P2572
    .const 'Sub' $P2568 = "332_1305640955.436" 
    capture_lex $P2568
    .const 'Sub' $P2565 = "331_1305640955.436" 
    capture_lex $P2565
    .const 'Sub' $P2561 = "330_1305640955.436" 
    capture_lex $P2561
    .const 'Sub' $P2558 = "329_1305640955.436" 
    capture_lex $P2558
    .const 'Sub' $P2554 = "328_1305640955.436" 
    capture_lex $P2554
    .const 'Sub' $P2551 = "327_1305640955.436" 
    capture_lex $P2551
    .const 'Sub' $P2547 = "326_1305640955.436" 
    capture_lex $P2547
    .const 'Sub' $P2544 = "325_1305640955.436" 
    capture_lex $P2544
    .const 'Sub' $P2540 = "324_1305640955.436" 
    capture_lex $P2540
    .const 'Sub' $P2537 = "323_1305640955.436" 
    capture_lex $P2537
    .const 'Sub' $P2533 = "322_1305640955.436" 
    capture_lex $P2533
    .const 'Sub' $P2530 = "321_1305640955.436" 
    capture_lex $P2530
    .const 'Sub' $P2526 = "320_1305640955.436" 
    capture_lex $P2526
    .const 'Sub' $P2523 = "319_1305640955.436" 
    capture_lex $P2523
    .const 'Sub' $P2519 = "318_1305640955.436" 
    capture_lex $P2519
    .const 'Sub' $P2516 = "317_1305640955.436" 
    capture_lex $P2516
    .const 'Sub' $P2513 = "316_1305640955.436" 
    capture_lex $P2513
    .const 'Sub' $P2510 = "315_1305640955.436" 
    capture_lex $P2510
    .const 'Sub' $P2507 = "314_1305640955.436" 
    capture_lex $P2507
    .const 'Sub' $P2505 = "313_1305640955.436" 
    capture_lex $P2505
    .const 'Sub' $P2502 = "312_1305640955.436" 
    capture_lex $P2502
    .const 'Sub' $P2499 = "311_1305640955.436" 
    capture_lex $P2499
    .const 'Sub' $P2496 = "310_1305640955.436" 
    capture_lex $P2496
    .const 'Sub' $P2493 = "309_1305640955.436" 
    capture_lex $P2493
    .const 'Sub' $P2490 = "308_1305640955.436" 
    capture_lex $P2490
    .const 'Sub' $P2488 = "307_1305640955.436" 
    capture_lex $P2488
    .const 'Sub' $P2485 = "306_1305640955.436" 
    capture_lex $P2485
    .const 'Sub' $P2483 = "305_1305640955.436" 
    capture_lex $P2483
    .const 'Sub' $P2480 = "304_1305640955.436" 
    capture_lex $P2480
    .const 'Sub' $P2477 = "303_1305640955.436" 
    capture_lex $P2477
    .const 'Sub' $P2472 = "302_1305640955.436" 
    capture_lex $P2472
    .const 'Sub' $P2469 = "301_1305640955.436" 
    capture_lex $P2469
    .const 'Sub' $P2463 = "300_1305640955.436" 
    capture_lex $P2463
    .const 'Sub' $P2461 = "299_1305640955.436" 
    capture_lex $P2461
    .const 'Sub' $P2458 = "298_1305640955.436" 
    capture_lex $P2458
    .const 'Sub' $P2456 = "297_1305640955.436" 
    capture_lex $P2456
    .const 'Sub' $P2453 = "296_1305640955.436" 
    capture_lex $P2453
    .const 'Sub' $P2451 = "295_1305640955.436" 
    capture_lex $P2451
    .const 'Sub' $P2448 = "294_1305640955.436" 
    capture_lex $P2448
    .const 'Sub' $P2445 = "293_1305640955.436" 
    capture_lex $P2445
    .const 'Sub' $P2440 = "292_1305640955.436" 
    capture_lex $P2440
    .const 'Sub' $P2437 = "291_1305640955.436" 
    capture_lex $P2437
    .const 'Sub' $P2432 = "290_1305640955.436" 
    capture_lex $P2432
    .const 'Sub' $P2430 = "289_1305640955.436" 
    capture_lex $P2430
    .const 'Sub' $P2427 = "288_1305640955.436" 
    capture_lex $P2427
    .const 'Sub' $P2425 = "287_1305640955.436" 
    capture_lex $P2425
    .const 'Sub' $P2422 = "286_1305640955.436" 
    capture_lex $P2422
    .const 'Sub' $P2420 = "285_1305640955.436" 
    capture_lex $P2420
    .const 'Sub' $P2417 = "284_1305640955.436" 
    capture_lex $P2417
    .const 'Sub' $P2414 = "283_1305640955.436" 
    capture_lex $P2414
    .const 'Sub' $P2411 = "282_1305640955.436" 
    capture_lex $P2411
    .const 'Sub' $P2408 = "281_1305640955.436" 
    capture_lex $P2408
    .const 'Sub' $P2404 = "280_1305640955.436" 
    capture_lex $P2404
    .const 'Sub' $P2401 = "279_1305640955.436" 
    capture_lex $P2401
    .const 'Sub' $P2397 = "278_1305640955.436" 
    capture_lex $P2397
    .const 'Sub' $P2394 = "277_1305640955.436" 
    capture_lex $P2394
    .const 'Sub' $P2390 = "276_1305640955.436" 
    capture_lex $P2390
    .const 'Sub' $P2387 = "275_1305640955.436" 
    capture_lex $P2387
    .const 'Sub' $P2383 = "274_1305640955.436" 
    capture_lex $P2383
    .const 'Sub' $P2381 = "273_1305640955.436" 
    capture_lex $P2381
    .const 'Sub' $P2378 = "272_1305640955.436" 
    capture_lex $P2378
    .const 'Sub' $P2376 = "271_1305640955.436" 
    capture_lex $P2376
    .const 'Sub' $P2373 = "270_1305640955.436" 
    capture_lex $P2373
    .const 'Sub' $P2365 = "267_1305640955.436" 
    capture_lex $P2365
    .const 'Sub' $P2359 = "266_1305640955.436" 
    capture_lex $P2359
    .const 'Sub' $P2355 = "265_1305640955.436" 
    capture_lex $P2355
    .const 'Sub' $P2351 = "264_1305640955.436" 
    capture_lex $P2351
    .const 'Sub' $P2348 = "263_1305640955.436" 
    capture_lex $P2348
    .const 'Sub' $P2345 = "262_1305640955.436" 
    capture_lex $P2345
    .const 'Sub' $P2342 = "261_1305640955.436" 
    capture_lex $P2342
    .const 'Sub' $P2338 = "260_1305640955.436" 
    capture_lex $P2338
    .const 'Sub' $P2335 = "259_1305640955.436" 
    capture_lex $P2335
    .const 'Sub' $P2332 = "258_1305640955.436" 
    capture_lex $P2332
    .const 'Sub' $P2330 = "257_1305640955.436" 
    capture_lex $P2330
    .const 'Sub' $P2316 = "255_1305640955.436" 
    capture_lex $P2316
    .const 'Sub' $P2314 = "254_1305640955.436" 
    capture_lex $P2314
    .const 'Sub' $P2308 = "253_1305640955.436" 
    capture_lex $P2308
    .const 'Sub' $P2305 = "252_1305640955.436" 
    capture_lex $P2305
    .const 'Sub' $P2300 = "251_1305640955.436" 
    capture_lex $P2300
    .const 'Sub' $P2297 = "250_1305640955.436" 
    capture_lex $P2297
    .const 'Sub' $P2294 = "249_1305640955.436" 
    capture_lex $P2294
    .const 'Sub' $P2292 = "248_1305640955.436" 
    capture_lex $P2292
    .const 'Sub' $P2288 = "247_1305640955.436" 
    capture_lex $P2288
    .const 'Sub' $P2279 = "244_1305640955.436" 
    capture_lex $P2279
    .const 'Sub' $P2272 = "243_1305640955.436" 
    capture_lex $P2272
    .const 'Sub' $P2269 = "242_1305640955.436" 
    capture_lex $P2269
    .const 'Sub' $P2231 = "241_1305640955.436" 
    capture_lex $P2231
    .const 'Sub' $P2228 = "240_1305640955.436" 
    capture_lex $P2228
    .const 'Sub' $P2220 = "239_1305640955.436" 
    capture_lex $P2220
    .const 'Sub' $P2211 = "236_1305640955.436" 
    capture_lex $P2211
    .const 'Sub' $P2206 = "235_1305640955.436" 
    capture_lex $P2206
    .const 'Sub' $P2203 = "234_1305640955.436" 
    capture_lex $P2203
    .const 'Sub' $P2197 = "233_1305640955.436" 
    capture_lex $P2197
    .const 'Sub' $P2194 = "232_1305640955.436" 
    capture_lex $P2194
    .const 'Sub' $P2191 = "231_1305640955.436" 
    capture_lex $P2191
    .const 'Sub' $P2188 = "230_1305640955.436" 
    capture_lex $P2188
    .const 'Sub' $P2181 = "229_1305640955.436" 
    capture_lex $P2181
    .const 'Sub' $P2179 = "228_1305640955.436" 
    capture_lex $P2179
    .const 'Sub' $P2166 = "227_1305640955.436" 
    capture_lex $P2166
    .const 'Sub' $P2164 = "226_1305640955.436" 
    capture_lex $P2164
    .const 'Sub' $P2150 = "224_1305640955.436" 
    capture_lex $P2150
    .const 'Sub' $P2147 = "223_1305640955.436" 
    capture_lex $P2147
    .const 'Sub' $P2142 = "222_1305640955.436" 
    capture_lex $P2142
    .const 'Sub' $P2139 = "221_1305640955.436" 
    capture_lex $P2139
    .const 'Sub' $P2132 = "220_1305640955.436" 
    capture_lex $P2132
    .const 'Sub' $P2129 = "219_1305640955.436" 
    capture_lex $P2129
    .const 'Sub' $P2122 = "218_1305640955.436" 
    capture_lex $P2122
    .const 'Sub' $P2114 = "215_1305640955.436" 
    capture_lex $P2114
    .const 'Sub' $P2101 = "213_1305640955.436" 
    capture_lex $P2101
    .const 'Sub' $P2098 = "212_1305640955.436" 
    capture_lex $P2098
    .const 'Sub' $P2057 = "210_1305640955.436" 
    capture_lex $P2057
    .const 'Sub' $P2054 = "209_1305640955.436" 
    capture_lex $P2054
    .const 'Sub' $P2023 = "208_1305640955.436" 
    capture_lex $P2023
    .const 'Sub' $P2020 = "207_1305640955.436" 
    capture_lex $P2020
    .const 'Sub' $P2016 = "206_1305640955.436" 
    capture_lex $P2016
    .const 'Sub' $P2013 = "205_1305640955.436" 
    capture_lex $P2013
    .const 'Sub' $P2009 = "204_1305640955.436" 
    capture_lex $P2009
    .const 'Sub' $P2000 = "201_1305640955.436" 
    capture_lex $P2000
    .const 'Sub' $P1979 = "199_1305640955.436" 
    capture_lex $P1979
    .const 'Sub' $P1975 = "198_1305640955.436" 
    capture_lex $P1975
    .const 'Sub' $P1971 = "197_1305640955.436" 
    capture_lex $P1971
    .const 'Sub' $P1968 = "196_1305640955.436" 
    capture_lex $P1968
    .const 'Sub' $P1952 = "194_1305640955.436" 
    capture_lex $P1952
    .const 'Sub' $P1947 = "193_1305640955.436" 
    capture_lex $P1947
    .const 'Sub' $P1936 = "192_1305640955.436" 
    capture_lex $P1936
    .const 'Sub' $P1933 = "191_1305640955.436" 
    capture_lex $P1933
    .const 'Sub' $P1929 = "190_1305640955.436" 
    capture_lex $P1929
    .const 'Sub' $P1926 = "189_1305640955.436" 
    capture_lex $P1926
    .const 'Sub' $P1922 = "188_1305640955.436" 
    capture_lex $P1922
    .const 'Sub' $P1919 = "187_1305640955.436" 
    capture_lex $P1919
    .const 'Sub' $P1915 = "186_1305640955.436" 
    capture_lex $P1915
    .const 'Sub' $P1906 = "183_1305640955.436" 
    capture_lex $P1906
    .const 'Sub' $P1742 = "181_1305640955.436" 
    capture_lex $P1742
    .const 'Sub' $P1739 = "180_1305640955.436" 
    capture_lex $P1739
    .const 'Sub' $P1719 = "179_1305640955.436" 
    capture_lex $P1719
    .const 'Sub' $P1716 = "178_1305640955.436" 
    capture_lex $P1716
    .const 'Sub' $P1706 = "177_1305640955.436" 
    capture_lex $P1706
    .const 'Sub' $P1703 = "176_1305640955.436" 
    capture_lex $P1703
    .const 'Sub' $P1693 = "175_1305640955.436" 
    capture_lex $P1693
    .const 'Sub' $P1690 = "174_1305640955.436" 
    capture_lex $P1690
    .const 'Sub' $P1680 = "173_1305640955.436" 
    capture_lex $P1680
    .const 'Sub' $P1677 = "172_1305640955.436" 
    capture_lex $P1677
    .const 'Sub' $P1667 = "171_1305640955.436" 
    capture_lex $P1667
    .const 'Sub' $P1664 = "170_1305640955.436" 
    capture_lex $P1664
    .const 'Sub' $P1654 = "169_1305640955.436" 
    capture_lex $P1654
    .const 'Sub' $P1651 = "168_1305640955.436" 
    capture_lex $P1651
    .const 'Sub' $P1641 = "167_1305640955.436" 
    capture_lex $P1641
    .const 'Sub' $P1633 = "164_1305640955.436" 
    capture_lex $P1633
    .const 'Sub' $P1630 = "163_1305640955.436" 
    capture_lex $P1630
    .const 'Sub' $P1628 = "162_1305640955.436" 
    capture_lex $P1628
    .const 'Sub' $P1625 = "161_1305640955.436" 
    capture_lex $P1625
    .const 'Sub' $P1621 = "160_1305640955.436" 
    capture_lex $P1621
    .const 'Sub' $P1613 = "159_1305640955.436" 
    capture_lex $P1613
    .const 'Sub' $P1608 = "158_1305640955.436" 
    capture_lex $P1608
    .const 'Sub' $P1601 = "157_1305640955.436" 
    capture_lex $P1601
    .const 'Sub' $P1598 = "156_1305640955.436" 
    capture_lex $P1598
    .const 'Sub' $P1594 = "155_1305640955.436" 
    capture_lex $P1594
    .const 'Sub' $P1592 = "154_1305640955.436" 
    capture_lex $P1592
    .const 'Sub' $P1589 = "153_1305640955.436" 
    capture_lex $P1589
    .const 'Sub' $P1586 = "152_1305640955.436" 
    capture_lex $P1586
    .const 'Sub' $P1583 = "151_1305640955.436" 
    capture_lex $P1583
    .const 'Sub' $P1580 = "150_1305640955.436" 
    capture_lex $P1580
    .const 'Sub' $P1577 = "149_1305640955.436" 
    capture_lex $P1577
    .const 'Sub' $P1575 = "148_1305640955.436" 
    capture_lex $P1575
    .const 'Sub' $P1562 = "145_1305640955.436" 
    capture_lex $P1562
    .const 'Sub' $P1559 = "144_1305640955.436" 
    capture_lex $P1559
    .const 'Sub' $P1556 = "143_1305640955.436" 
    capture_lex $P1556
    .const 'Sub' $P1553 = "142_1305640955.436" 
    capture_lex $P1553
    .const 'Sub' $P1550 = "141_1305640955.436" 
    capture_lex $P1550
    .const 'Sub' $P1547 = "140_1305640955.436" 
    capture_lex $P1547
    .const 'Sub' $P1544 = "139_1305640955.436" 
    capture_lex $P1544
    .const 'Sub' $P1541 = "138_1305640955.436" 
    capture_lex $P1541
    .const 'Sub' $P1538 = "137_1305640955.436" 
    capture_lex $P1538
    .const 'Sub' $P1535 = "136_1305640955.436" 
    capture_lex $P1535
    .const 'Sub' $P1532 = "135_1305640955.436" 
    capture_lex $P1532
    .const 'Sub' $P1529 = "134_1305640955.436" 
    capture_lex $P1529
    .const 'Sub' $P1526 = "133_1305640955.436" 
    capture_lex $P1526
    .const 'Sub' $P1523 = "132_1305640955.436" 
    capture_lex $P1523
    .const 'Sub' $P1517 = "131_1305640955.436" 
    capture_lex $P1517
    .const 'Sub' $P1514 = "130_1305640955.436" 
    capture_lex $P1514
    .const 'Sub' $P1508 = "129_1305640955.436" 
    capture_lex $P1508
    .const 'Sub' $P1505 = "128_1305640955.436" 
    capture_lex $P1505
    .const 'Sub' $P1499 = "127_1305640955.436" 
    capture_lex $P1499
    .const 'Sub' $P1490 = "124_1305640955.436" 
    capture_lex $P1490
    .const 'Sub' $P1484 = "123_1305640955.436" 
    capture_lex $P1484
    .const 'Sub' $P1481 = "122_1305640955.436" 
    capture_lex $P1481
    .const 'Sub' $P1475 = "121_1305640955.436" 
    capture_lex $P1475
    .const 'Sub' $P1467 = "118_1305640955.436" 
    capture_lex $P1467
    .const 'Sub' $P1463 = "117_1305640955.436" 
    capture_lex $P1463
    .const 'Sub' $P1460 = "116_1305640955.436" 
    capture_lex $P1460
    .const 'Sub' $P1456 = "115_1305640955.436" 
    capture_lex $P1456
    .const 'Sub' $P1453 = "114_1305640955.436" 
    capture_lex $P1453
    .const 'Sub' $P1449 = "113_1305640955.436" 
    capture_lex $P1449
    .const 'Sub' $P1441 = "110_1305640955.436" 
    capture_lex $P1441
    .const 'Sub' $P1435 = "109_1305640955.436" 
    capture_lex $P1435
    .const 'Sub' $P1433 = "108_1305640955.436" 
    capture_lex $P1433
    .const 'Sub' $P1427 = "107_1305640955.436" 
    capture_lex $P1427
    .const 'Sub' $P1425 = "106_1305640955.436" 
    capture_lex $P1425
    .const 'Sub' $P1419 = "105_1305640955.436" 
    capture_lex $P1419
    .const 'Sub' $P1417 = "104_1305640955.436" 
    capture_lex $P1417
    .const 'Sub' $P1399 = "103_1305640955.436" 
    capture_lex $P1399
    .const 'Sub' $P1397 = "102_1305640955.436" 
    capture_lex $P1397
    .const 'Sub' $P1390 = "101_1305640955.436" 
    capture_lex $P1390
    .const 'Sub' $P1388 = "100_1305640955.436" 
    capture_lex $P1388
    .const 'Sub' $P1372 = "98_1305640955.436" 
    capture_lex $P1372
    .const 'Sub' $P1370 = "97_1305640955.436" 
    capture_lex $P1370
    .const 'Sub' $P1354 = "96_1305640955.436" 
    capture_lex $P1354
    .const 'Sub' $P1352 = "95_1305640955.436" 
    capture_lex $P1352
    .const 'Sub' $P1346 = "94_1305640955.436" 
    capture_lex $P1346
    .const 'Sub' $P1338 = "91_1305640955.436" 
    capture_lex $P1338
    .const 'Sub' $P1335 = "90_1305640955.436" 
    capture_lex $P1335
    .const 'Sub' $P1333 = "89_1305640955.436" 
    capture_lex $P1333
    .const 'Sub' $P1330 = "88_1305640955.436" 
    capture_lex $P1330
    .const 'Sub' $P1322 = "85_1305640955.436" 
    capture_lex $P1322
    .const 'Sub' $P1319 = "84_1305640955.436" 
    capture_lex $P1319
    .const 'Sub' $P1317 = "83_1305640955.436" 
    capture_lex $P1317
    .const 'Sub' $P1314 = "82_1305640955.436" 
    capture_lex $P1314
    .const 'Sub' $P1312 = "81_1305640955.436" 
    capture_lex $P1312
    .const 'Sub' $P1309 = "80_1305640955.436" 
    capture_lex $P1309
    .const 'Sub' $P1307 = "79_1305640955.436" 
    capture_lex $P1307
    .const 'Sub' $P1304 = "78_1305640955.436" 
    capture_lex $P1304
    .const 'Sub' $P1302 = "77_1305640955.436" 
    capture_lex $P1302
    .const 'Sub' $P1299 = "76_1305640955.436" 
    capture_lex $P1299
    .const 'Sub' $P1296 = "75_1305640955.436" 
    capture_lex $P1296
    .const 'Sub' $P1289 = "74_1305640955.436" 
    capture_lex $P1289
    .const 'Sub' $P1286 = "73_1305640955.436" 
    capture_lex $P1286
    .const 'Sub' $P1282 = "72_1305640955.436" 
    capture_lex $P1282
    .const 'Sub' $P1280 = "71_1305640955.436" 
    capture_lex $P1280
    .const 'Sub' $P1276 = "70_1305640955.436" 
    capture_lex $P1276
    .const 'Sub' $P1272 = "69_1305640955.436" 
    capture_lex $P1272
    .const 'Sub' $P1268 = "68_1305640955.436" 
    capture_lex $P1268
    .const 'Sub' $P1265 = "67_1305640955.436" 
    capture_lex $P1265
    .const 'Sub' $P1262 = "66_1305640955.436" 
    capture_lex $P1262
    .const 'Sub' $P1260 = "65_1305640955.436" 
    capture_lex $P1260
    .const 'Sub' $P1256 = "64_1305640955.436" 
    capture_lex $P1256
    .const 'Sub' $P1254 = "63_1305640955.436" 
    capture_lex $P1254
    .const 'Sub' $P1241 = "61_1305640955.436" 
    capture_lex $P1241
    .const 'Sub' $P1237 = "60_1305640955.436" 
    capture_lex $P1237
    .const 'Sub' $P1227 = "59_1305640955.436" 
    capture_lex $P1227
    .const 'Sub' $P1224 = "58_1305640955.436" 
    capture_lex $P1224
    .const 'Sub' $P1204 = "57_1305640955.436" 
    capture_lex $P1204
    .const 'Sub' $P1202 = "56_1305640955.436" 
    capture_lex $P1202
    .const 'Sub' $P1165 = "54_1305640955.436" 
    capture_lex $P1165
    .const 'Sub' $P1163 = "53_1305640955.436" 
    capture_lex $P1163
    .const 'Sub' $P1150 = "51_1305640955.436" 
    capture_lex $P1150
    .const 'Sub' $P1148 = "50_1305640955.436" 
    capture_lex $P1148
    .const 'Sub' $P1139 = "49_1305640955.436" 
    capture_lex $P1139
    .const 'Sub' $P1137 = "48_1305640955.436" 
    capture_lex $P1137
    .const 'Sub' $P1127 = "47_1305640955.436" 
    capture_lex $P1127
    .const 'Sub' $P1124 = "46_1305640955.436" 
    capture_lex $P1124
    .const 'Sub' $P1119 = "45_1305640955.436" 
    capture_lex $P1119
    .const 'Sub' $P1117 = "44_1305640955.436" 
    capture_lex $P1117
    .const 'Sub' $P1112 = "43_1305640955.436" 
    capture_lex $P1112
    .const 'Sub' $P1109 = "42_1305640955.436" 
    capture_lex $P1109
    .const 'Sub' $P1105 = "41_1305640955.436" 
    capture_lex $P1105
    .const 'Sub' $P1039 = "40_1305640955.436" 
    capture_lex $P1039
    .lex "$?PACKAGE", $P977
    .lex "$?CLASS", $P978
.annotate 'line', 1041
    get_hll_global $P979, "GLOBAL"
    nqp_get_package_through_who $P980, $P979, "NQP"
    get_who $P981, $P980
    set $P982, $P981["Grammar"]
    $P982."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1042
    get_hll_global $P983, "GLOBAL"
    nqp_get_package_through_who $P984, $P983, "NQP"
    get_who $P985, $P984
    set $P986, $P985["Grammar"]
    $P986."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1043
    get_hll_global $P987, "GLOBAL"
    nqp_get_package_through_who $P988, $P987, "NQP"
    get_who $P989, $P988
    set $P990, $P989["Grammar"]
    $P990."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1044
    get_hll_global $P991, "GLOBAL"
    nqp_get_package_through_who $P992, $P991, "NQP"
    get_who $P993, $P992
    set $P994, $P993["Grammar"]
    $P994."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1045
    get_hll_global $P995, "GLOBAL"
    nqp_get_package_through_who $P996, $P995, "NQP"
    get_who $P997, $P996
    set $P998, $P997["Grammar"]
    $P998."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1046
    get_hll_global $P999, "GLOBAL"
    nqp_get_package_through_who $P1000, $P999, "NQP"
    get_who $P1001, $P1000
    set $P1002, $P1001["Grammar"]
    $P1002."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1047
    get_hll_global $P1003, "GLOBAL"
    nqp_get_package_through_who $P1004, $P1003, "NQP"
    get_who $P1005, $P1004
    set $P1006, $P1005["Grammar"]
    $P1006."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1048
    get_hll_global $P1007, "GLOBAL"
    nqp_get_package_through_who $P1008, $P1007, "NQP"
    get_who $P1009, $P1008
    set $P1010, $P1009["Grammar"]
    $P1010."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1049
    get_hll_global $P1011, "GLOBAL"
    nqp_get_package_through_who $P1012, $P1011, "NQP"
    get_who $P1013, $P1012
    set $P1014, $P1013["Grammar"]
    $P1014."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1050
    get_hll_global $P1015, "GLOBAL"
    nqp_get_package_through_who $P1016, $P1015, "NQP"
    get_who $P1017, $P1016
    set $P1018, $P1017["Grammar"]
    $P1018."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1051
    get_hll_global $P1019, "GLOBAL"
    nqp_get_package_through_who $P1020, $P1019, "NQP"
    get_who $P1021, $P1020
    set $P1022, $P1021["Grammar"]
    $P1022."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1052
    get_hll_global $P1023, "GLOBAL"
    nqp_get_package_through_who $P1024, $P1023, "NQP"
    get_who $P1025, $P1024
    set $P1026, $P1025["Grammar"]
    $P1026."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1053
    get_hll_global $P1027, "GLOBAL"
    nqp_get_package_through_who $P1028, $P1027, "NQP"
    get_who $P1029, $P1028
    set $P1030, $P1029["Grammar"]
    $P1030."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1054
    get_hll_global $P1031, "GLOBAL"
    nqp_get_package_through_who $P1032, $P1031, "NQP"
    get_who $P1033, $P1032
    set $P1034, $P1033["Grammar"]
    $P1034."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1055
    get_hll_global $P1035, "GLOBAL"
    nqp_get_package_through_who $P1036, $P1035, "NQP"
    get_who $P1037, $P1036
    set $P1038, $P1037["Grammar"]
    $P1038."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1154
    .const 'Sub' $P2847 = "413_1305640955.436" 
    newclosure $P2858, $P2847
.annotate 'line', 437
    .return ($P2858)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP" :anon :subid("40_1305640955.436") :outer("39_1305640955.436")
    .param pmc param_1040
.annotate 'line', 438
    .lex "self", param_1040
.annotate 'line', 440
    $P1041 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P1041
.annotate 'line', 449
    $P1042 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P1042
.annotate 'line', 456
    new $P1043, "Undef"
    .lex "$*SC", $P1043
.annotate 'line', 460
    new $P1044, "Undef"
    .lex "$*SCOPE", $P1044
.annotate 'line', 461
    new $P1045, "Undef"
    .lex "$*MULTINESS", $P1045
.annotate 'line', 462
    new $P1046, "Undef"
    .lex "$*PKGDECL", $P1046
.annotate 'line', 463
    new $P1047, "Undef"
    .lex "$*INVOCANT_OK", $P1047
.annotate 'line', 464
    new $P1048, "Undef"
    .lex "$*RETURN_USED", $P1048
.annotate 'line', 438
    find_lex $P1051, "%*LANG"
    unless_null $P1051, vivify_844
    get_hll_global $P1049, "GLOBAL"
    get_who $P1050, $P1049
    set $P1051, $P1050["%LANG"]
    unless_null $P1051, vivify_845
    die "Contextual %*LANG not found"
  vivify_845:
  vivify_844:
.annotate 'line', 441
    get_hll_global $P1052, "GLOBAL"
    nqp_get_package_through_who $P1053, $P1052, "NQP"
    get_who $P1054, $P1053
    set $P1055, $P1054["Regex"]
    find_lex $P1058, "%*LANG"
    unless_null $P1058, vivify_846
    get_hll_global $P1056, "GLOBAL"
    get_who $P1057, $P1056
    set $P1058, $P1057["%LANG"]
    unless_null $P1058, vivify_847
    die "Contextual %*LANG not found"
  vivify_847:
    store_lex "%*LANG", $P1058
  vivify_846:
    set $P1058["Regex"], $P1055
.annotate 'line', 442
    get_hll_global $P1059, "GLOBAL"
    nqp_get_package_through_who $P1060, $P1059, "NQP"
    get_who $P1061, $P1060
    set $P1062, $P1061["RegexActions"]
    find_lex $P1065, "%*LANG"
    unless_null $P1065, vivify_848
    get_hll_global $P1063, "GLOBAL"
    get_who $P1064, $P1063
    set $P1065, $P1064["%LANG"]
    unless_null $P1065, vivify_849
    die "Contextual %*LANG not found"
  vivify_849:
    store_lex "%*LANG", $P1065
  vivify_848:
    set $P1065["Regex-actions"], $P1062
.annotate 'line', 443
    get_hll_global $P1066, "GLOBAL"
    nqp_get_package_through_who $P1067, $P1066, "NQP"
    get_who $P1068, $P1067
    set $P1069, $P1068["Grammar"]
    find_lex $P1072, "%*LANG"
    unless_null $P1072, vivify_850
    get_hll_global $P1070, "GLOBAL"
    get_who $P1071, $P1070
    set $P1072, $P1071["%LANG"]
    unless_null $P1072, vivify_851
    die "Contextual %*LANG not found"
  vivify_851:
    store_lex "%*LANG", $P1072
  vivify_850:
    set $P1072["MAIN"], $P1069
.annotate 'line', 444
    get_hll_global $P1073, "GLOBAL"
    nqp_get_package_through_who $P1074, $P1073, "NQP"
    get_who $P1075, $P1074
    set $P1076, $P1075["Actions"]
    find_lex $P1079, "%*LANG"
    unless_null $P1079, vivify_852
    get_hll_global $P1077, "GLOBAL"
    get_who $P1078, $P1077
    set $P1079, $P1078["%LANG"]
    unless_null $P1079, vivify_853
    die "Contextual %*LANG not found"
  vivify_853:
    store_lex "%*LANG", $P1079
  vivify_852:
    set $P1079["MAIN-actions"], $P1076
    find_lex $P1082, "%*HOW"
    unless_null $P1082, vivify_854
    get_hll_global $P1080, "GLOBAL"
    get_who $P1081, $P1080
    set $P1082, $P1081["%HOW"]
    unless_null $P1082, vivify_855
    die "Contextual %*HOW not found"
  vivify_855:
  vivify_854:
.annotate 'line', 450
    get_knowhow $P1083
    find_lex $P1086, "%*HOW"
    unless_null $P1086, vivify_856
    get_hll_global $P1084, "GLOBAL"
    get_who $P1085, $P1084
    set $P1086, $P1085["%HOW"]
    unless_null $P1086, vivify_857
    die "Contextual %*HOW not found"
  vivify_857:
    store_lex "%*HOW", $P1086
  vivify_856:
    set $P1086["knowhow"], $P1083
.annotate 'line', 451
    get_knowhow_attribute $P1087
    find_lex $P1090, "%*HOW"
    unless_null $P1090, vivify_858
    get_hll_global $P1088, "GLOBAL"
    get_who $P1089, $P1088
    set $P1090, $P1089["%HOW"]
    unless_null $P1090, vivify_859
    die "Contextual %*HOW not found"
  vivify_859:
    store_lex "%*HOW", $P1090
  vivify_858:
    set $P1090["knowhow-attr"], $P1087
.annotate 'line', 456
    get_hll_global $P1091, "GLOBAL"
    nqp_get_package_through_who $P1092, $P1091, "NQP"
    get_who $P1093, $P1092
    set $P1094, $P1093["SymbolTable"]
.annotate 'line', 458
    time $N1095
    set $S1096, $N1095
    $P1097 = $P1094."new"($S1096 :named("handle"))
.annotate 'line', 456
    store_lex "$*SC", $P1097
.annotate 'line', 460
    new $P1098, "String"
    assign $P1098, ""
    store_lex "$*SCOPE", $P1098
.annotate 'line', 461
    new $P1099, "String"
    assign $P1099, ""
    store_lex "$*MULTINESS", $P1099
.annotate 'line', 462
    new $P1100, "String"
    assign $P1100, ""
    store_lex "$*PKGDECL", $P1100
.annotate 'line', 463
    new $P1101, "Integer"
    assign $P1101, 0
    store_lex "$*INVOCANT_OK", $P1101
.annotate 'line', 464
    new $P1102, "Integer"
    assign $P1102, 0
    store_lex "$*RETURN_USED", $P1102
.annotate 'line', 465
    find_lex $P1103, "self"
    $P1104 = $P1103."comp_unit"()
.annotate 'line', 438
    .return ($P1104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("41_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1106_tgt
    .local int rx1106_pos
    .local int rx1106_off
    .local int rx1106_eos
    .local int rx1106_rep
    .local pmc rx1106_cur
    .local pmc rx1106_debug
    (rx1106_cur, rx1106_pos, rx1106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1106_cur
    .local pmc match
    .lex "$/", match
    length rx1106_eos, rx1106_tgt
    gt rx1106_pos, rx1106_eos, rx1106_done
    set rx1106_off, 0
    lt rx1106_pos, 2, rx1106_start
    sub rx1106_off, rx1106_pos, 1
    substr rx1106_tgt, rx1106_tgt, rx1106_off
  rx1106_start:
    eq $I10, 1, rx1106_restart
    if_null rx1106_debug, debug_860
    rx1106_cur."!cursor_debug"("START", "identifier")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1107_done
    goto rxscan1107_scan
  rxscan1107_loop:
    (rx1106_pos) = rx1106_cur."from"()
    inc rx1106_pos
    rx1106_cur."!cursor_from"(rx1106_pos)
    ge rx1106_pos, rx1106_eos, rxscan1107_done
  rxscan1107_scan:
    set_addr $I10, rxscan1107_loop
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxscan1107_done:
.annotate 'line', 470
  # rx subrule "ident" subtype=method negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."ident"()
    unless $P10, rx1106_fail
    rx1106_pos = $P10."pos"()
  # rx rxquantr1108 ** 0..*
    set_addr $I10, rxquantr1108_done
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxquantr1108_loop:
  # rx enumcharlist negate=0 
    ge rx1106_pos, rx1106_eos, rx1106_fail
    sub $I10, rx1106_pos, rx1106_off
    substr $S10, rx1106_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1106_fail
    inc rx1106_pos
  # rx subrule "ident" subtype=method negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."ident"()
    unless $P10, rx1106_fail
    rx1106_pos = $P10."pos"()
    set_addr $I10, rxquantr1108_done
    (rx1106_rep) = rx1106_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1108_done
    rx1106_cur."!mark_push"(rx1106_rep, rx1106_pos, $I10)
    goto rxquantr1108_loop
  rxquantr1108_done:
  # rx pass
    rx1106_cur."!cursor_pass"(rx1106_pos, "identifier")
    if_null rx1106_debug, debug_861
    rx1106_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1106_pos)
  debug_861:
    .return (rx1106_cur)
  rx1106_restart:
.annotate 'line', 438
    if_null rx1106_debug, debug_862
    rx1106_cur."!cursor_debug"("NEXT", "identifier")
  debug_862:
  rx1106_fail:
    (rx1106_rep, rx1106_pos, $I10, $P10) = rx1106_cur."!mark_fail"(0)
    lt rx1106_pos, -1, rx1106_done
    eq rx1106_pos, -1, rx1106_fail
    jump $I10
  rx1106_done:
    rx1106_cur."!cursor_fail"()
    if_null rx1106_debug, debug_863
    rx1106_cur."!cursor_debug"("FAIL", "identifier")
  debug_863:
    .return (rx1106_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("42_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1110 = self."!PREFIX__!subrule"("ident", "")
    new $P1111, "ResizablePMCArray"
    push $P1111, $P1110
    .return ($P1111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("43_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1113_tgt
    .local int rx1113_pos
    .local int rx1113_off
    .local int rx1113_eos
    .local int rx1113_rep
    .local pmc rx1113_cur
    .local pmc rx1113_debug
    (rx1113_cur, rx1113_pos, rx1113_tgt, $I10) = self."!cursor_start"()
    rx1113_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1113_cur
    .local pmc match
    .lex "$/", match
    length rx1113_eos, rx1113_tgt
    gt rx1113_pos, rx1113_eos, rx1113_done
    set rx1113_off, 0
    lt rx1113_pos, 2, rx1113_start
    sub rx1113_off, rx1113_pos, 1
    substr rx1113_tgt, rx1113_tgt, rx1113_off
  rx1113_start:
    eq $I10, 1, rx1113_restart
    if_null rx1113_debug, debug_864
    rx1113_cur."!cursor_debug"("START", "name")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1114_done
    goto rxscan1114_scan
  rxscan1114_loop:
    (rx1113_pos) = rx1113_cur."from"()
    inc rx1113_pos
    rx1113_cur."!cursor_from"(rx1113_pos)
    ge rx1113_pos, rx1113_eos, rxscan1114_done
  rxscan1114_scan:
    set_addr $I10, rxscan1114_loop
    rx1113_cur."!mark_push"(0, rx1113_pos, $I10)
  rxscan1114_done:
.annotate 'line', 472
  # rx rxquantr1115 ** 1..*
    set_addr $I10, rxquantr1115_done
    rx1113_cur."!mark_push"(0, -1, $I10)
  rxquantr1115_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1113_cur."!cursor_pos"(rx1113_pos)
    $P10 = rx1113_cur."identifier"()
    unless $P10, rx1113_fail
    goto rxsubrule1116_pass
  rxsubrule1116_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1113_fail
  rxsubrule1116_pass:
    set_addr $I10, rxsubrule1116_back
    rx1113_cur."!mark_push"(0, rx1113_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1113_pos = $P10."pos"()
    set_addr $I10, rxquantr1115_done
    (rx1113_rep) = rx1113_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1115_done
    rx1113_cur."!mark_push"(rx1113_rep, rx1113_pos, $I10)
  # rx literal  "::"
    add $I11, rx1113_pos, 2
    gt $I11, rx1113_eos, rx1113_fail
    sub $I11, rx1113_pos, rx1113_off
    substr $S10, rx1113_tgt, $I11, 2
    ne $S10, "::", rx1113_fail
    add rx1113_pos, 2
    goto rxquantr1115_loop
  rxquantr1115_done:
  # rx pass
    rx1113_cur."!cursor_pass"(rx1113_pos, "name")
    if_null rx1113_debug, debug_865
    rx1113_cur."!cursor_debug"("PASS", "name", " at pos=", rx1113_pos)
  debug_865:
    .return (rx1113_cur)
  rx1113_restart:
.annotate 'line', 438
    if_null rx1113_debug, debug_866
    rx1113_cur."!cursor_debug"("NEXT", "name")
  debug_866:
  rx1113_fail:
    (rx1113_rep, rx1113_pos, $I10, $P10) = rx1113_cur."!mark_fail"(0)
    lt rx1113_pos, -1, rx1113_done
    eq rx1113_pos, -1, rx1113_fail
    jump $I10
  rx1113_done:
    rx1113_cur."!cursor_fail"()
    if_null rx1113_debug, debug_867
    rx1113_cur."!cursor_debug"("FAIL", "name")
  debug_867:
    .return (rx1113_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("44_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1118, "ResizablePMCArray"
    push $P1118, ""
    .return ($P1118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("45_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1120_tgt
    .local int rx1120_pos
    .local int rx1120_off
    .local int rx1120_eos
    .local int rx1120_rep
    .local pmc rx1120_cur
    .local pmc rx1120_debug
    (rx1120_cur, rx1120_pos, rx1120_tgt, $I10) = self."!cursor_start"()
    rx1120_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1120_cur
    .local pmc match
    .lex "$/", match
    length rx1120_eos, rx1120_tgt
    gt rx1120_pos, rx1120_eos, rx1120_done
    set rx1120_off, 0
    lt rx1120_pos, 2, rx1120_start
    sub rx1120_off, rx1120_pos, 1
    substr rx1120_tgt, rx1120_tgt, rx1120_off
  rx1120_start:
    eq $I10, 1, rx1120_restart
    if_null rx1120_debug, debug_868
    rx1120_cur."!cursor_debug"("START", "deflongname")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1121_done
    goto rxscan1121_scan
  rxscan1121_loop:
    (rx1120_pos) = rx1120_cur."from"()
    inc rx1120_pos
    rx1120_cur."!cursor_from"(rx1120_pos)
    ge rx1120_pos, rx1120_eos, rxscan1121_done
  rxscan1121_scan:
    set_addr $I10, rxscan1121_loop
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10)
  rxscan1121_done:
.annotate 'line', 475
  # rx subrule "identifier" subtype=capture negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."identifier"()
    unless $P10, rx1120_fail
    rx1120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1120_pos = $P10."pos"()
  # rx rxquantr1122 ** 0..1
    set_addr $I10, rxquantr1122_done
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10)
  rxquantr1122_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."colonpair"()
    unless $P10, rx1120_fail
    goto rxsubrule1123_pass
  rxsubrule1123_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1120_fail
  rxsubrule1123_pass:
    set_addr $I10, rxsubrule1123_back
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1120_pos = $P10."pos"()
    set_addr $I10, rxquantr1122_done
    (rx1120_rep) = rx1120_cur."!mark_commit"($I10)
  rxquantr1122_done:
.annotate 'line', 474
  # rx pass
    rx1120_cur."!cursor_pass"(rx1120_pos, "deflongname")
    if_null rx1120_debug, debug_869
    rx1120_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1120_pos)
  debug_869:
    .return (rx1120_cur)
  rx1120_restart:
.annotate 'line', 438
    if_null rx1120_debug, debug_870
    rx1120_cur."!cursor_debug"("NEXT", "deflongname")
  debug_870:
  rx1120_fail:
    (rx1120_rep, rx1120_pos, $I10, $P10) = rx1120_cur."!mark_fail"(0)
    lt rx1120_pos, -1, rx1120_done
    eq rx1120_pos, -1, rx1120_fail
    jump $I10
  rx1120_done:
    rx1120_cur."!cursor_fail"()
    if_null rx1120_debug, debug_871
    rx1120_cur."!cursor_debug"("FAIL", "deflongname")
  debug_871:
    .return (rx1120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("46_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1125 = self."!PREFIX__!subrule"("identifier", "")
    new $P1126, "ResizablePMCArray"
    push $P1126, $P1125
    .return ($P1126)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("47_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1128_tgt
    .local int rx1128_pos
    .local int rx1128_off
    .local int rx1128_eos
    .local int rx1128_rep
    .local pmc rx1128_cur
    .local pmc rx1128_debug
    (rx1128_cur, rx1128_pos, rx1128_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1128_cur
    .local pmc match
    .lex "$/", match
    length rx1128_eos, rx1128_tgt
    gt rx1128_pos, rx1128_eos, rx1128_done
    set rx1128_off, 0
    lt rx1128_pos, 2, rx1128_start
    sub rx1128_off, rx1128_pos, 1
    substr rx1128_tgt, rx1128_tgt, rx1128_off
  rx1128_start:
    eq $I10, 1, rx1128_restart
    if_null rx1128_debug, debug_872
    rx1128_cur."!cursor_debug"("START", "ENDSTMT")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1129_done
    goto rxscan1129_scan
  rxscan1129_loop:
    (rx1128_pos) = rx1128_cur."from"()
    inc rx1128_pos
    rx1128_cur."!cursor_from"(rx1128_pos)
    ge rx1128_pos, rx1128_eos, rxscan1129_done
  rxscan1129_scan:
    set_addr $I10, rxscan1129_loop
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxscan1129_done:
.annotate 'line', 482
  # rx rxquantr1130 ** 0..1
    set_addr $I10, rxquantr1130_done
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxquantr1130_loop:
  alt1131_0:
.annotate 'line', 479
    set_addr $I10, alt1131_1
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
.annotate 'line', 480
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1128_pos, rx1128_off
    set rx1128_rep, 0
    sub $I12, rx1128_eos, rx1128_pos
  rxenumcharlistq1132_loop:
    le $I12, 0, rxenumcharlistq1132_done
    substr $S10, rx1128_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1132_done
    inc rx1128_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1132_loop
  rxenumcharlistq1132_done:
    add rx1128_pos, rx1128_pos, rx1128_rep
  # rxanchor eol
    sub $I10, rx1128_pos, rx1128_off
    is_cclass $I11, 4096, rx1128_tgt, $I10
    if $I11, rxanchor1133_done
    ne rx1128_pos, rx1128_eos, rx1128_fail
    eq rx1128_pos, 0, rxanchor1133_done
    dec $I10
    is_cclass $I11, 4096, rx1128_tgt, $I10
    if $I11, rx1128_fail
  rxanchor1133_done:
  # rx subrule "ws" subtype=method negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."ws"()
    unless $P10, rx1128_fail
    rx1128_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."MARKER"("endstmt")
    unless $P10, rx1128_fail
    goto alt1131_end
  alt1131_1:
.annotate 'line', 481
  # rx rxquantr1134 ** 0..1
    set_addr $I10, rxquantr1134_done
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxquantr1134_loop:
  # rx subrule "unv" subtype=method negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."unv"()
    unless $P10, rx1128_fail
    goto rxsubrule1135_pass
  rxsubrule1135_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1128_fail
  rxsubrule1135_pass:
    set_addr $I10, rxsubrule1135_back
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10, $P10)
    rx1128_pos = $P10."pos"()
    set_addr $I10, rxquantr1134_done
    (rx1128_rep) = rx1128_cur."!mark_commit"($I10)
  rxquantr1134_done:
  # rxanchor eol
    sub $I10, rx1128_pos, rx1128_off
    is_cclass $I11, 4096, rx1128_tgt, $I10
    if $I11, rxanchor1136_done
    ne rx1128_pos, rx1128_eos, rx1128_fail
    eq rx1128_pos, 0, rxanchor1136_done
    dec $I10
    is_cclass $I11, 4096, rx1128_tgt, $I10
    if $I11, rx1128_fail
  rxanchor1136_done:
  # rx subrule "ws" subtype=method negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."ws"()
    unless $P10, rx1128_fail
    rx1128_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."MARKER"("endstmt")
    unless $P10, rx1128_fail
  alt1131_end:
.annotate 'line', 482
    set_addr $I10, rxquantr1130_done
    (rx1128_rep) = rx1128_cur."!mark_commit"($I10)
  rxquantr1130_done:
.annotate 'line', 478
  # rx pass
    rx1128_cur."!cursor_pass"(rx1128_pos, "ENDSTMT")
    if_null rx1128_debug, debug_873
    rx1128_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1128_pos)
  debug_873:
    .return (rx1128_cur)
  rx1128_restart:
.annotate 'line', 438
    if_null rx1128_debug, debug_874
    rx1128_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_874:
  rx1128_fail:
    (rx1128_rep, rx1128_pos, $I10, $P10) = rx1128_cur."!mark_fail"(0)
    lt rx1128_pos, -1, rx1128_done
    eq rx1128_pos, -1, rx1128_fail
    jump $I10
  rx1128_done:
    rx1128_cur."!cursor_fail"()
    if_null rx1128_debug, debug_875
    rx1128_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_875:
    .return (rx1128_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("48_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1138, "ResizablePMCArray"
    push $P1138, ""
    .return ($P1138)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("49_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1140_tgt
    .local int rx1140_pos
    .local int rx1140_off
    .local int rx1140_eos
    .local int rx1140_rep
    .local pmc rx1140_cur
    .local pmc rx1140_debug
    (rx1140_cur, rx1140_pos, rx1140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1140_cur
    .local pmc match
    .lex "$/", match
    length rx1140_eos, rx1140_tgt
    gt rx1140_pos, rx1140_eos, rx1140_done
    set rx1140_off, 0
    lt rx1140_pos, 2, rx1140_start
    sub rx1140_off, rx1140_pos, 1
    substr rx1140_tgt, rx1140_tgt, rx1140_off
  rx1140_start:
    eq $I10, 1, rx1140_restart
    if_null rx1140_debug, debug_876
    rx1140_cur."!cursor_debug"("START", "ws")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1141_done
    goto rxscan1141_scan
  rxscan1141_loop:
    (rx1140_pos) = rx1140_cur."from"()
    inc rx1140_pos
    rx1140_cur."!cursor_from"(rx1140_pos)
    ge rx1140_pos, rx1140_eos, rxscan1141_done
  rxscan1141_scan:
    set_addr $I10, rxscan1141_loop
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  rxscan1141_done:
  alt1142_0:
.annotate 'line', 485
    set_addr $I10, alt1142_1
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
.annotate 'line', 486
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."MARKED"("ws")
    unless $P10, rx1140_fail
    goto alt1142_end
  alt1142_1:
.annotate 'line', 487
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."ww"()
    if $P10, rx1140_fail
.annotate 'line', 492
  # rx rxquantr1143 ** 0..*
    set_addr $I10, rxquantr1143_done
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  rxquantr1143_loop:
  alt1144_0:
.annotate 'line', 488
    set_addr $I10, alt1144_1
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1140_pos, rx1140_off
    set rx1140_rep, 0
    sub $I12, rx1140_eos, rx1140_pos
  rxenumcharlistq1145_loop:
    le $I12, 0, rxenumcharlistq1145_done
    substr $S10, rx1140_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1145_done
    inc rx1140_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1145_loop
  rxenumcharlistq1145_done:
    lt rx1140_rep, 1, rx1140_fail
    add rx1140_pos, rx1140_pos, rx1140_rep
    goto alt1144_end
  alt1144_1:
    set_addr $I10, alt1144_2
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
.annotate 'line', 489
  # rx literal  "#"
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 35, rx1140_fail
    add rx1140_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1140_pos, rx1140_off
    find_cclass $I11, 4096, rx1140_tgt, $I10, rx1140_eos
    add rx1140_pos, rx1140_off, $I11
    goto alt1144_end
  alt1144_2:
    set_addr $I10, alt1144_3
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
.annotate 'line', 490
  # rxanchor bol
    eq rx1140_pos, 0, rxanchor1146_done
    ge rx1140_pos, rx1140_eos, rx1140_fail
    sub $I10, rx1140_pos, rx1140_off
    dec $I10
    is_cclass $I11, 4096, rx1140_tgt, $I10
    unless $I11, rx1140_fail
  rxanchor1146_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."pod_comment"()
    unless $P10, rx1140_fail
    rx1140_pos = $P10."pos"()
    goto alt1144_end
  alt1144_3:
.annotate 'line', 491
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1140_pos, rx1140_off
    set rx1140_rep, 0
    sub $I12, rx1140_eos, rx1140_pos
  rxenumcharlistq1147_loop:
    le $I12, 0, rxenumcharlistq1147_done
    substr $S10, rx1140_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1147_done
    inc rx1140_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1147_loop
  rxenumcharlistq1147_done:
    lt rx1140_rep, 1, rx1140_fail
    add rx1140_pos, rx1140_pos, rx1140_rep
  alt1144_end:
.annotate 'line', 492
    set_addr $I10, rxquantr1143_done
    (rx1140_rep) = rx1140_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1143_done
    rx1140_cur."!mark_push"(rx1140_rep, rx1140_pos, $I10)
    goto rxquantr1143_loop
  rxquantr1143_done:
.annotate 'line', 493
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."MARKER"("ws")
    unless $P10, rx1140_fail
  alt1142_end:
.annotate 'line', 485
  # rx pass
    rx1140_cur."!cursor_pass"(rx1140_pos, "ws")
    if_null rx1140_debug, debug_877
    rx1140_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1140_pos)
  debug_877:
    .return (rx1140_cur)
  rx1140_restart:
.annotate 'line', 438
    if_null rx1140_debug, debug_878
    rx1140_cur."!cursor_debug"("NEXT", "ws")
  debug_878:
  rx1140_fail:
    (rx1140_rep, rx1140_pos, $I10, $P10) = rx1140_cur."!mark_fail"(0)
    lt rx1140_pos, -1, rx1140_done
    eq rx1140_pos, -1, rx1140_fail
    jump $I10
  rx1140_done:
    rx1140_cur."!cursor_fail"()
    if_null rx1140_debug, debug_879
    rx1140_cur."!cursor_debug"("FAIL", "ws")
  debug_879:
    .return (rx1140_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("50_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1149, "ResizablePMCArray"
    push $P1149, ""
    push $P1149, ""
    .return ($P1149)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("51_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1156 = "52_1305640955.436" 
    capture_lex $P1156
    .local string rx1151_tgt
    .local int rx1151_pos
    .local int rx1151_off
    .local int rx1151_eos
    .local int rx1151_rep
    .local pmc rx1151_cur
    .local pmc rx1151_debug
    (rx1151_cur, rx1151_pos, rx1151_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1151_cur
    .local pmc match
    .lex "$/", match
    length rx1151_eos, rx1151_tgt
    gt rx1151_pos, rx1151_eos, rx1151_done
    set rx1151_off, 0
    lt rx1151_pos, 2, rx1151_start
    sub rx1151_off, rx1151_pos, 1
    substr rx1151_tgt, rx1151_tgt, rx1151_off
  rx1151_start:
    eq $I10, 1, rx1151_restart
    if_null rx1151_debug, debug_880
    rx1151_cur."!cursor_debug"("START", "unv")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1152_done
    goto rxscan1152_scan
  rxscan1152_loop:
    (rx1151_pos) = rx1151_cur."from"()
    inc rx1151_pos
    rx1151_cur."!cursor_from"(rx1151_pos)
    ge rx1151_pos, rx1151_eos, rxscan1152_done
  rxscan1152_scan:
    set_addr $I10, rxscan1152_loop
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  rxscan1152_done:
  alt1153_0:
.annotate 'line', 498
    set_addr $I10, alt1153_1
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
.annotate 'line', 499
  # rxanchor bol
    eq rx1151_pos, 0, rxanchor1154_done
    ge rx1151_pos, rx1151_eos, rx1151_fail
    sub $I10, rx1151_pos, rx1151_off
    dec $I10
    is_cclass $I11, 4096, rx1151_tgt, $I10
    unless $I11, rx1151_fail
  rxanchor1154_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    .const 'Sub' $P1156 = "52_1305640955.436" 
    capture_lex $P1156
    $P10 = rx1151_cur."before"($P1156)
    unless $P10, rx1151_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."pod_comment"()
    unless $P10, rx1151_fail
    rx1151_pos = $P10."pos"()
    goto alt1153_end
  alt1153_1:
    set_addr $I10, alt1153_2
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
.annotate 'line', 500
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1151_pos, rx1151_off
    set rx1151_rep, 0
    sub $I12, rx1151_eos, rx1151_pos
  rxenumcharlistq1161_loop:
    le $I12, 0, rxenumcharlistq1161_done
    substr $S10, rx1151_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1161_done
    inc rx1151_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1161_loop
  rxenumcharlistq1161_done:
    add rx1151_pos, rx1151_pos, rx1151_rep
  # rx literal  "#"
    add $I11, rx1151_pos, 1
    gt $I11, rx1151_eos, rx1151_fail
    sub $I11, rx1151_pos, rx1151_off
    ord $I11, rx1151_tgt, $I11
    ne $I11, 35, rx1151_fail
    add rx1151_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1151_pos, rx1151_off
    find_cclass $I11, 4096, rx1151_tgt, $I10, rx1151_eos
    add rx1151_pos, rx1151_off, $I11
    goto alt1153_end
  alt1153_2:
.annotate 'line', 501
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1151_pos, rx1151_off
    set rx1151_rep, 0
    sub $I12, rx1151_eos, rx1151_pos
  rxenumcharlistq1162_loop:
    le $I12, 0, rxenumcharlistq1162_done
    substr $S10, rx1151_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1162_done
    inc rx1151_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1162_loop
  rxenumcharlistq1162_done:
    lt rx1151_rep, 1, rx1151_fail
    add rx1151_pos, rx1151_pos, rx1151_rep
  alt1153_end:
.annotate 'line', 496
  # rx pass
    rx1151_cur."!cursor_pass"(rx1151_pos, "unv")
    if_null rx1151_debug, debug_885
    rx1151_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1151_pos)
  debug_885:
    .return (rx1151_cur)
  rx1151_restart:
.annotate 'line', 438
    if_null rx1151_debug, debug_886
    rx1151_cur."!cursor_debug"("NEXT", "unv")
  debug_886:
  rx1151_fail:
    (rx1151_rep, rx1151_pos, $I10, $P10) = rx1151_cur."!mark_fail"(0)
    lt rx1151_pos, -1, rx1151_done
    eq rx1151_pos, -1, rx1151_fail
    jump $I10
  rx1151_done:
    rx1151_cur."!cursor_fail"()
    if_null rx1151_debug, debug_887
    rx1151_cur."!cursor_debug"("FAIL", "unv")
  debug_887:
    .return (rx1151_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1155"  :anon :subid("52_1305640955.436") :method :outer("51_1305640955.436")
.annotate 'line', 499
    .local string rx1157_tgt
    .local int rx1157_pos
    .local int rx1157_off
    .local int rx1157_eos
    .local int rx1157_rep
    .local pmc rx1157_cur
    .local pmc rx1157_debug
    (rx1157_cur, rx1157_pos, rx1157_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1157_cur
    .local pmc match
    .lex "$/", match
    length rx1157_eos, rx1157_tgt
    gt rx1157_pos, rx1157_eos, rx1157_done
    set rx1157_off, 0
    lt rx1157_pos, 2, rx1157_start
    sub rx1157_off, rx1157_pos, 1
    substr rx1157_tgt, rx1157_tgt, rx1157_off
  rx1157_start:
    eq $I10, 1, rx1157_restart
    if_null rx1157_debug, debug_881
    rx1157_cur."!cursor_debug"("START", "")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1158_done
    goto rxscan1158_scan
  rxscan1158_loop:
    (rx1157_pos) = rx1157_cur."from"()
    inc rx1157_pos
    rx1157_cur."!cursor_from"(rx1157_pos)
    ge rx1157_pos, rx1157_eos, rxscan1158_done
  rxscan1158_scan:
    set_addr $I10, rxscan1158_loop
    rx1157_cur."!mark_push"(0, rx1157_pos, $I10)
  rxscan1158_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1157_pos, rx1157_off
    set rx1157_rep, 0
    sub $I12, rx1157_eos, rx1157_pos
  rxenumcharlistq1159_loop:
    le $I12, 0, rxenumcharlistq1159_done
    substr $S10, rx1157_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1159_done
    inc rx1157_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1159_loop
  rxenumcharlistq1159_done:
    add rx1157_pos, rx1157_pos, rx1157_rep
  # rx literal  "="
    add $I11, rx1157_pos, 1
    gt $I11, rx1157_eos, rx1157_fail
    sub $I11, rx1157_pos, rx1157_off
    ord $I11, rx1157_tgt, $I11
    ne $I11, 61, rx1157_fail
    add rx1157_pos, 1
  alt1160_0:
    set_addr $I10, alt1160_1
    rx1157_cur."!mark_push"(0, rx1157_pos, $I10)
  # rx charclass w
    ge rx1157_pos, rx1157_eos, rx1157_fail
    sub $I10, rx1157_pos, rx1157_off
    is_cclass $I11, 8192, rx1157_tgt, $I10
    unless $I11, rx1157_fail
    inc rx1157_pos
    goto alt1160_end
  alt1160_1:
  # rx literal  "\\"
    add $I11, rx1157_pos, 1
    gt $I11, rx1157_eos, rx1157_fail
    sub $I11, rx1157_pos, rx1157_off
    ord $I11, rx1157_tgt, $I11
    ne $I11, 92, rx1157_fail
    add rx1157_pos, 1
  alt1160_end:
  # rx pass
    rx1157_cur."!cursor_pass"(rx1157_pos, "")
    if_null rx1157_debug, debug_882
    rx1157_cur."!cursor_debug"("PASS", "", " at pos=", rx1157_pos)
  debug_882:
    .return (rx1157_cur)
  rx1157_restart:
    if_null rx1157_debug, debug_883
    rx1157_cur."!cursor_debug"("NEXT", "")
  debug_883:
  rx1157_fail:
    (rx1157_rep, rx1157_pos, $I10, $P10) = rx1157_cur."!mark_fail"(0)
    lt rx1157_pos, -1, rx1157_done
    eq rx1157_pos, -1, rx1157_fail
    jump $I10
  rx1157_done:
    rx1157_cur."!cursor_fail"()
    if_null rx1157_debug, debug_884
    rx1157_cur."!cursor_debug"("FAIL", "")
  debug_884:
    .return (rx1157_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("53_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1164, "ResizablePMCArray"
    push $P1164, ""
    push $P1164, ""
    push $P1164, ""
    .return ($P1164)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("54_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1195 = "55_1305640955.436" 
    capture_lex $P1195
    .local string rx1166_tgt
    .local int rx1166_pos
    .local int rx1166_off
    .local int rx1166_eos
    .local int rx1166_rep
    .local pmc rx1166_cur
    .local pmc rx1166_debug
    (rx1166_cur, rx1166_pos, rx1166_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1166_cur
    .local pmc match
    .lex "$/", match
    length rx1166_eos, rx1166_tgt
    gt rx1166_pos, rx1166_eos, rx1166_done
    set rx1166_off, 0
    lt rx1166_pos, 2, rx1166_start
    sub rx1166_off, rx1166_pos, 1
    substr rx1166_tgt, rx1166_tgt, rx1166_off
  rx1166_start:
    eq $I10, 1, rx1166_restart
    if_null rx1166_debug, debug_888
    rx1166_cur."!cursor_debug"("START", "pod_comment")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1167_done
    goto rxscan1167_scan
  rxscan1167_loop:
    (rx1166_pos) = rx1166_cur."from"()
    inc rx1166_pos
    rx1166_cur."!cursor_from"(rx1166_pos)
    ge rx1166_pos, rx1166_eos, rxscan1167_done
  rxscan1167_scan:
    set_addr $I10, rxscan1167_loop
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
  rxscan1167_done:
.annotate 'line', 506
  # rxanchor bol
    eq rx1166_pos, 0, rxanchor1168_done
    ge rx1166_pos, rx1166_eos, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    dec $I10
    is_cclass $I11, 4096, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  rxanchor1168_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1169_loop:
    le $I12, 0, rxenumcharlistq1169_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1169_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1169_loop
  rxenumcharlistq1169_done:
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx literal  "="
    add $I11, rx1166_pos, 1
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    ord $I11, rx1166_tgt, $I11
    ne $I11, 61, rx1166_fail
    add rx1166_pos, 1
  alt1170_0:
.annotate 'line', 507
    set_addr $I10, alt1170_1
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
.annotate 'line', 508
  # rx literal  "begin"
    add $I11, rx1166_pos, 5
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 5
    ne $S10, "begin", rx1166_fail
    add rx1166_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1171_loop:
    le $I12, 0, rxenumcharlistq1171_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1171_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1171_loop
  rxenumcharlistq1171_done:
    lt rx1166_rep, 1, rx1166_fail
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx literal  "END"
    add $I11, rx1166_pos, 3
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 3
    ne $S10, "END", rx1166_fail
    add rx1166_pos, 3
  # rxanchor rwb
    le rx1166_pos, 0, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 8192, rx1166_tgt, $I10
    if $I11, rx1166_fail
    dec $I10
    is_cclass $I11, 8192, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  alt1172_0:
.annotate 'line', 509
    set_addr $I10, alt1172_1
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
  # rx rxquantf1173 ** 0..*
    set_addr $I10, rxquantf1173_loop
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
    goto rxquantf1173_done
  rxquantf1173_loop:
  # rx charclass .
    ge rx1166_pos, rx1166_eos, rx1166_fail
    inc rx1166_pos
    set_addr $I10, rxquantf1173_loop
    rx1166_cur."!mark_push"(rx1166_rep, rx1166_pos, $I10)
  rxquantf1173_done:
  # rx charclass nl
    ge rx1166_pos, rx1166_eos, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 4096, rx1166_tgt, $I10
    unless $I11, rx1166_fail
    substr $S10, rx1166_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1166_pos, $I11
    inc rx1166_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1175_loop:
    le $I12, 0, rxenumcharlistq1175_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1175_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1175_loop
  rxenumcharlistq1175_done:
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx literal  "=end"
    add $I11, rx1166_pos, 4
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 4
    ne $S10, "=end", rx1166_fail
    add rx1166_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1176_loop:
    le $I12, 0, rxenumcharlistq1176_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1176_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1176_loop
  rxenumcharlistq1176_done:
    lt rx1166_rep, 1, rx1166_fail
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx literal  "END"
    add $I11, rx1166_pos, 3
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 3
    ne $S10, "END", rx1166_fail
    add rx1166_pos, 3
  # rxanchor rwb
    le rx1166_pos, 0, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 8192, rx1166_tgt, $I10
    if $I11, rx1166_fail
    dec $I10
    is_cclass $I11, 8192, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    find_cclass $I11, 4096, rx1166_tgt, $I10, rx1166_eos
    add rx1166_pos, rx1166_off, $I11
    goto alt1172_end
  alt1172_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    find_not_cclass $I11, 65535, rx1166_tgt, $I10, rx1166_eos
    add rx1166_pos, rx1166_off, $I11
  alt1172_end:
.annotate 'line', 508
    goto alt1170_end
  alt1170_1:
    set_addr $I10, alt1170_2
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
.annotate 'line', 510
  # rx literal  "begin"
    add $I11, rx1166_pos, 5
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 5
    ne $S10, "begin", rx1166_fail
    add rx1166_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1177_loop:
    le $I12, 0, rxenumcharlistq1177_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1177_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1177_loop
  rxenumcharlistq1177_done:
    lt rx1166_rep, 1, rx1166_fail
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."identifier"()
    unless $P10, rx1166_fail
    rx1166_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1166_pos = $P10."pos"()
  alt1178_0:
.annotate 'line', 511
    set_addr $I10, alt1178_1
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
.annotate 'line', 512
  # rx rxquantf1179 ** 0..*
    set_addr $I10, rxquantf1179_loop
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
    goto rxquantf1179_done
  rxquantf1179_loop:
  # rx charclass .
    ge rx1166_pos, rx1166_eos, rx1166_fail
    inc rx1166_pos
    set_addr $I10, rxquantf1179_loop
    rx1166_cur."!mark_push"(rx1166_rep, rx1166_pos, $I10)
  rxquantf1179_done:
  # rx charclass nl
    ge rx1166_pos, rx1166_eos, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 4096, rx1166_tgt, $I10
    unless $I11, rx1166_fail
    substr $S10, rx1166_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1166_pos, $I11
    inc rx1166_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1181_loop:
    le $I12, 0, rxenumcharlistq1181_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1181_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1181_loop
  rxenumcharlistq1181_done:
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx literal  "=end"
    add $I11, rx1166_pos, 4
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 4
    ne $S10, "=end", rx1166_fail
    add rx1166_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1182_loop:
    le $I12, 0, rxenumcharlistq1182_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1182_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1182_loop
  rxenumcharlistq1182_done:
    lt rx1166_rep, 1, rx1166_fail
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."!BACKREF"("identifier")
    unless $P10, rx1166_fail
    rx1166_pos = $P10."pos"()
  # rxanchor rwb
    le rx1166_pos, 0, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 8192, rx1166_tgt, $I10
    if $I11, rx1166_fail
    dec $I10
    is_cclass $I11, 8192, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    find_cclass $I11, 4096, rx1166_tgt, $I10, rx1166_eos
    add rx1166_pos, rx1166_off, $I11
    goto alt1178_end
  alt1178_1:
.annotate 'line', 513
  # rx subrule "panic" subtype=method negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."panic"("=begin without matching =end")
    unless $P10, rx1166_fail
    rx1166_pos = $P10."pos"()
  alt1178_end:
.annotate 'line', 510
    goto alt1170_end
  alt1170_2:
    set_addr $I10, alt1170_3
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
.annotate 'line', 515
  # rx literal  "begin"
    add $I11, rx1166_pos, 5
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 5
    ne $S10, "begin", rx1166_fail
    add rx1166_pos, 5
  # rxanchor rwb
    le rx1166_pos, 0, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 8192, rx1166_tgt, $I10
    if $I11, rx1166_fail
    dec $I10
    is_cclass $I11, 8192, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1184_loop:
    le $I12, 0, rxenumcharlistq1184_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1184_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1184_loop
  rxenumcharlistq1184_done:
    add rx1166_pos, rx1166_pos, rx1166_rep
  alt1185_0:
.annotate 'line', 516
    set_addr $I10, alt1185_1
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
  # rxanchor eol
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 4096, rx1166_tgt, $I10
    if $I11, rxanchor1186_done
    ne rx1166_pos, rx1166_eos, rx1166_fail
    eq rx1166_pos, 0, rxanchor1186_done
    dec $I10
    is_cclass $I11, 4096, rx1166_tgt, $I10
    if $I11, rx1166_fail
  rxanchor1186_done:
    goto alt1185_end
  alt1185_1:
    set_addr $I10, alt1185_2
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
  # rx literal  "#"
    add $I11, rx1166_pos, 1
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    ord $I11, rx1166_tgt, $I11
    ne $I11, 35, rx1166_fail
    add rx1166_pos, 1
    goto alt1185_end
  alt1185_2:
  # rx subrule "panic" subtype=method negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1166_fail
    rx1166_pos = $P10."pos"()
  alt1185_end:
  alt1187_0:
.annotate 'line', 517
    set_addr $I10, alt1187_1
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
.annotate 'line', 518
  # rx rxquantf1188 ** 0..*
    set_addr $I10, rxquantf1188_loop
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
    goto rxquantf1188_done
  rxquantf1188_loop:
  # rx charclass .
    ge rx1166_pos, rx1166_eos, rx1166_fail
    inc rx1166_pos
    set_addr $I10, rxquantf1188_loop
    rx1166_cur."!mark_push"(rx1166_rep, rx1166_pos, $I10)
  rxquantf1188_done:
  # rx charclass nl
    ge rx1166_pos, rx1166_eos, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 4096, rx1166_tgt, $I10
    unless $I11, rx1166_fail
    substr $S10, rx1166_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1166_pos, $I11
    inc rx1166_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    set rx1166_rep, 0
    sub $I12, rx1166_eos, rx1166_pos
  rxenumcharlistq1190_loop:
    le $I12, 0, rxenumcharlistq1190_done
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1190_done
    inc rx1166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1190_loop
  rxenumcharlistq1190_done:
    add rx1166_pos, rx1166_pos, rx1166_rep
  # rx literal  "=end"
    add $I11, rx1166_pos, 4
    gt $I11, rx1166_eos, rx1166_fail
    sub $I11, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I11, 4
    ne $S10, "=end", rx1166_fail
    add rx1166_pos, 4
  # rxanchor rwb
    le rx1166_pos, 0, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 8192, rx1166_tgt, $I10
    if $I11, rx1166_fail
    dec $I10
    is_cclass $I11, 8192, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    find_cclass $I11, 4096, rx1166_tgt, $I10, rx1166_eos
    add rx1166_pos, rx1166_off, $I11
    goto alt1187_end
  alt1187_1:
.annotate 'line', 519
  # rx subrule "panic" subtype=method negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."panic"("=begin without matching =end")
    unless $P10, rx1166_fail
    rx1166_pos = $P10."pos"()
  alt1187_end:
.annotate 'line', 515
    goto alt1170_end
  alt1170_3:
    set_addr $I10, alt1170_4
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
.annotate 'line', 521
  # rx subrule "identifier" subtype=capture negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."identifier"()
    unless $P10, rx1166_fail
    rx1166_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1166_pos = $P10."pos"()
.annotate 'line', 522
  # rx rxquantf1191 ** 0..*
    set_addr $I10, rxquantf1191_loop
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
    goto rxquantf1191_done
  rxquantf1191_loop:
  # rx charclass .
    ge rx1166_pos, rx1166_eos, rx1166_fail
    inc rx1166_pos
    set_addr $I10, rxquantf1191_loop
    rx1166_cur."!mark_push"(rx1166_rep, rx1166_pos, $I10)
  rxquantf1191_done:
  # rxanchor bol
    eq rx1166_pos, 0, rxanchor1193_done
    ge rx1166_pos, rx1166_eos, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    dec $I10
    is_cclass $I11, 4096, rx1166_tgt, $I10
    unless $I11, rx1166_fail
  rxanchor1193_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    .const 'Sub' $P1195 = "55_1305640955.436" 
    capture_lex $P1195
    $P10 = rx1166_cur."before"($P1195)
    unless $P10, rx1166_fail
.annotate 'line', 521
    goto alt1170_end
  alt1170_4:
  alt1201_0:
.annotate 'line', 528
    set_addr $I10, alt1201_1
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
  # rx charclass s
    ge rx1166_pos, rx1166_eos, rx1166_fail
    sub $I10, rx1166_pos, rx1166_off
    is_cclass $I11, 32, rx1166_tgt, $I10
    unless $I11, rx1166_fail
    inc rx1166_pos
    goto alt1201_end
  alt1201_1:
  # rx subrule "panic" subtype=method negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."panic"("Illegal pod directive")
    unless $P10, rx1166_fail
    rx1166_pos = $P10."pos"()
  alt1201_end:
.annotate 'line', 529
  # rx charclass_q N r 0..-1
    sub $I10, rx1166_pos, rx1166_off
    find_cclass $I11, 4096, rx1166_tgt, $I10, rx1166_eos
    add rx1166_pos, rx1166_off, $I11
  alt1170_end:
.annotate 'line', 505
  # rx pass
    rx1166_cur."!cursor_pass"(rx1166_pos, "pod_comment")
    if_null rx1166_debug, debug_893
    rx1166_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1166_pos)
  debug_893:
    .return (rx1166_cur)
  rx1166_restart:
.annotate 'line', 438
    if_null rx1166_debug, debug_894
    rx1166_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_894:
  rx1166_fail:
    (rx1166_rep, rx1166_pos, $I10, $P10) = rx1166_cur."!mark_fail"(0)
    lt rx1166_pos, -1, rx1166_done
    eq rx1166_pos, -1, rx1166_fail
    jump $I10
  rx1166_done:
    rx1166_cur."!cursor_fail"()
    if_null rx1166_debug, debug_895
    rx1166_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_895:
    .return (rx1166_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1194"  :anon :subid("55_1305640955.436") :method :outer("54_1305640955.436")
.annotate 'line', 522
    .local string rx1196_tgt
    .local int rx1196_pos
    .local int rx1196_off
    .local int rx1196_eos
    .local int rx1196_rep
    .local pmc rx1196_cur
    .local pmc rx1196_debug
    (rx1196_cur, rx1196_pos, rx1196_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1196_cur
    .local pmc match
    .lex "$/", match
    length rx1196_eos, rx1196_tgt
    gt rx1196_pos, rx1196_eos, rx1196_done
    set rx1196_off, 0
    lt rx1196_pos, 2, rx1196_start
    sub rx1196_off, rx1196_pos, 1
    substr rx1196_tgt, rx1196_tgt, rx1196_off
  rx1196_start:
    eq $I10, 1, rx1196_restart
    if_null rx1196_debug, debug_889
    rx1196_cur."!cursor_debug"("START", "")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1197_done
    goto rxscan1197_scan
  rxscan1197_loop:
    (rx1196_pos) = rx1196_cur."from"()
    inc rx1196_pos
    rx1196_cur."!cursor_from"(rx1196_pos)
    ge rx1196_pos, rx1196_eos, rxscan1197_done
  rxscan1197_scan:
    set_addr $I10, rxscan1197_loop
    rx1196_cur."!mark_push"(0, rx1196_pos, $I10)
  rxscan1197_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1196_pos, rx1196_off
    set rx1196_rep, 0
    sub $I12, rx1196_eos, rx1196_pos
  rxenumcharlistq1198_loop:
    le $I12, 0, rxenumcharlistq1198_done
    substr $S10, rx1196_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1198_done
    inc rx1196_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1198_loop
  rxenumcharlistq1198_done:
    add rx1196_pos, rx1196_pos, rx1196_rep
  alt1199_0:
    set_addr $I10, alt1199_1
    rx1196_cur."!mark_push"(0, rx1196_pos, $I10)
.annotate 'line', 523
  # rx literal  "="
    add $I11, rx1196_pos, 1
    gt $I11, rx1196_eos, rx1196_fail
    sub $I11, rx1196_pos, rx1196_off
    ord $I11, rx1196_tgt, $I11
    ne $I11, 61, rx1196_fail
    add rx1196_pos, 1
.annotate 'line', 525
  # rx rxquantr1200 ** 0..1
    set_addr $I10, rxquantr1200_done
    rx1196_cur."!mark_push"(0, rx1196_pos, $I10)
  rxquantr1200_loop:
.annotate 'line', 524
  # rx literal  "cut"
    add $I11, rx1196_pos, 3
    gt $I11, rx1196_eos, rx1196_fail
    sub $I11, rx1196_pos, rx1196_off
    substr $S10, rx1196_tgt, $I11, 3
    ne $S10, "cut", rx1196_fail
    add rx1196_pos, 3
  # rxanchor rwb
    le rx1196_pos, 0, rx1196_fail
    sub $I10, rx1196_pos, rx1196_off
    is_cclass $I11, 8192, rx1196_tgt, $I10
    if $I11, rx1196_fail
    dec $I10
    is_cclass $I11, 8192, rx1196_tgt, $I10
    unless $I11, rx1196_fail
.annotate 'line', 525
  # rx subrule "panic" subtype=method negate=
    rx1196_cur."!cursor_pos"(rx1196_pos)
    $P10 = rx1196_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1196_fail
    rx1196_pos = $P10."pos"()
    set_addr $I10, rxquantr1200_done
    (rx1196_rep) = rx1196_cur."!mark_commit"($I10)
  rxquantr1200_done:
.annotate 'line', 522
    goto alt1199_end
  alt1199_1:
.annotate 'line', 526
  # rx charclass nl
    ge rx1196_pos, rx1196_eos, rx1196_fail
    sub $I10, rx1196_pos, rx1196_off
    is_cclass $I11, 4096, rx1196_tgt, $I10
    unless $I11, rx1196_fail
    substr $S10, rx1196_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1196_pos, $I11
    inc rx1196_pos
  alt1199_end:
.annotate 'line', 522
  # rx pass
    rx1196_cur."!cursor_pass"(rx1196_pos, "")
    if_null rx1196_debug, debug_890
    rx1196_cur."!cursor_debug"("PASS", "", " at pos=", rx1196_pos)
  debug_890:
    .return (rx1196_cur)
  rx1196_restart:
    if_null rx1196_debug, debug_891
    rx1196_cur."!cursor_debug"("NEXT", "")
  debug_891:
  rx1196_fail:
    (rx1196_rep, rx1196_pos, $I10, $P10) = rx1196_cur."!mark_fail"(0)
    lt rx1196_pos, -1, rx1196_done
    eq rx1196_pos, -1, rx1196_fail
    jump $I10
  rx1196_done:
    rx1196_cur."!cursor_fail"()
    if_null rx1196_debug, debug_892
    rx1196_cur."!cursor_debug"("FAIL", "")
  debug_892:
    .return (rx1196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("56_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1203, "ResizablePMCArray"
    push $P1203, ""
    .return ($P1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("57_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 537
    new $P1205, "Undef"
    .lex "$*IN_DECL", $P1205
.annotate 'line', 539
    new $P1206, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P1206
.annotate 'line', 540
    new $P1207, "Undef"
    .lex "$*MAIN_SUB", $P1207
.annotate 'line', 543
    new $P1208, "Undef"
    .lex "$*PACKAGE", $P1208
.annotate 'line', 544
    new $P1209, "Undef"
    .lex "$*GLOBALish", $P1209
.annotate 'line', 438
    .local string rx1210_tgt
    .local int rx1210_pos
    .local int rx1210_off
    .local int rx1210_eos
    .local int rx1210_rep
    .local pmc rx1210_cur
    .local pmc rx1210_debug
    (rx1210_cur, rx1210_pos, rx1210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1210_cur
    .local pmc match
    .lex "$/", match
    length rx1210_eos, rx1210_tgt
    gt rx1210_pos, rx1210_eos, rx1210_done
    set rx1210_off, 0
    lt rx1210_pos, 2, rx1210_start
    sub rx1210_off, rx1210_pos, 1
    substr rx1210_tgt, rx1210_tgt, rx1210_off
  rx1210_start:
    eq $I10, 1, rx1210_restart
    if_null rx1210_debug, debug_896
    rx1210_cur."!cursor_debug"("START", "comp_unit")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1211_done
    goto rxscan1211_scan
  rxscan1211_loop:
    (rx1210_pos) = rx1210_cur."from"()
    inc rx1210_pos
    rx1210_cur."!cursor_from"(rx1210_pos)
    ge rx1210_pos, rx1210_eos, rxscan1211_done
  rxscan1211_scan:
    set_addr $I10, rxscan1211_loop
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  rxscan1211_done:
.annotate 'line', 537
    rx1210_cur."!cursor_pos"(rx1210_pos)
    new $P1212, "String"
    assign $P1212, ""
    store_lex "$*IN_DECL", $P1212
.annotate 'line', 539
    rx1210_cur."!cursor_pos"(rx1210_pos)
    new $P1213, "Integer"
    assign $P1213, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P1213
.annotate 'line', 540
    rx1210_cur."!cursor_pos"(rx1210_pos)
    find_lex $P1216, "$*MAIN_SUB"
    unless_null $P1216, vivify_897
    get_hll_global $P1214, "GLOBAL"
    get_who $P1215, $P1214
    set $P1216, $P1215["$MAIN_SUB"]
    unless_null $P1216, vivify_898
    die "Contextual $*MAIN_SUB not found"
  vivify_898:
  vivify_897:
.annotate 'line', 541
  # rx subrule "newpad" subtype=method negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."newpad"()
    unless $P10, rx1210_fail
    rx1210_pos = $P10."pos"()
.annotate 'line', 543
    rx1210_cur."!cursor_pos"(rx1210_pos)
    find_lex $P1219, "$*PACKAGE"
    unless_null $P1219, vivify_899
    get_hll_global $P1217, "GLOBAL"
    get_who $P1218, $P1217
    set $P1219, $P1218["$PACKAGE"]
    unless_null $P1219, vivify_900
    die "Contextual $*PACKAGE not found"
  vivify_900:
  vivify_899:
.annotate 'line', 544
    rx1210_cur."!cursor_pos"(rx1210_pos)
    find_lex $P1222, "$*GLOBALish"
    unless_null $P1222, vivify_901
    get_hll_global $P1220, "GLOBAL"
    get_who $P1221, $P1220
    set $P1222, $P1221["$GLOBALish"]
    unless_null $P1222, vivify_902
    die "Contextual $*GLOBALish not found"
  vivify_902:
  vivify_901:
.annotate 'line', 545
  # rx subrule "GLOBALish" subtype=method negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."GLOBALish"()
    unless $P10, rx1210_fail
    rx1210_pos = $P10."pos"()
.annotate 'line', 547
  # rx subrule "outerctx" subtype=method negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."outerctx"()
    unless $P10, rx1210_fail
    rx1210_pos = $P10."pos"()
.annotate 'line', 549
  # rx subrule "statementlist" subtype=capture negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."statementlist"()
    unless $P10, rx1210_fail
    rx1210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1210_pos = $P10."pos"()
  alt1223_0:
.annotate 'line', 550
    set_addr $I10, alt1223_1
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  # rxanchor eos
    ne rx1210_pos, rx1210_eos, rx1210_fail
    goto alt1223_end
  alt1223_1:
  # rx subrule "panic" subtype=method negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."panic"("Confused")
    unless $P10, rx1210_fail
    rx1210_pos = $P10."pos"()
  alt1223_end:
.annotate 'line', 536
  # rx pass
    rx1210_cur."!cursor_pass"(rx1210_pos, "comp_unit")
    if_null rx1210_debug, debug_903
    rx1210_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1210_pos)
  debug_903:
    .return (rx1210_cur)
  rx1210_restart:
.annotate 'line', 438
    if_null rx1210_debug, debug_904
    rx1210_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_904:
  rx1210_fail:
    (rx1210_rep, rx1210_pos, $I10, $P10) = rx1210_cur."!mark_fail"(0)
    lt rx1210_pos, -1, rx1210_done
    eq rx1210_pos, -1, rx1210_fail
    jump $I10
  rx1210_done:
    rx1210_cur."!cursor_fail"()
    if_null rx1210_debug, debug_905
    rx1210_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_905:
    .return (rx1210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("58_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1225 = self."!PREFIX__!subrule"("newpad", "")
    new $P1226, "ResizablePMCArray"
    push $P1226, $P1225
    .return ($P1226)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("59_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1228_tgt
    .local int rx1228_pos
    .local int rx1228_off
    .local int rx1228_eos
    .local int rx1228_rep
    .local pmc rx1228_cur
    .local pmc rx1228_debug
    (rx1228_cur, rx1228_pos, rx1228_tgt, $I10) = self."!cursor_start"()
    rx1228_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1228_cur
    .local pmc match
    .lex "$/", match
    length rx1228_eos, rx1228_tgt
    gt rx1228_pos, rx1228_eos, rx1228_done
    set rx1228_off, 0
    lt rx1228_pos, 2, rx1228_start
    sub rx1228_off, rx1228_pos, 1
    substr rx1228_tgt, rx1228_tgt, rx1228_off
  rx1228_start:
    eq $I10, 1, rx1228_restart
    if_null rx1228_debug, debug_906
    rx1228_cur."!cursor_debug"("START", "statementlist")
  debug_906:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1229_done
    goto rxscan1229_scan
  rxscan1229_loop:
    (rx1228_pos) = rx1228_cur."from"()
    inc rx1228_pos
    rx1228_cur."!cursor_from"(rx1228_pos)
    ge rx1228_pos, rx1228_eos, rxscan1229_done
  rxscan1229_scan:
    set_addr $I10, rxscan1229_loop
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
  rxscan1229_done:
  alt1230_0:
.annotate 'line', 553
    set_addr $I10, alt1230_1
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
.annotate 'line', 554
  # rx subrule "ws" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."ws"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
  # rxanchor eos
    ne rx1228_pos, rx1228_eos, rx1228_fail
  # rx subrule "ws" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."ws"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
    goto alt1230_end
  alt1230_1:
.annotate 'line', 555
  # rx subrule "ws" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."ws"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
  # rx rxquantr1234 ** 0..*
    set_addr $I10, rxquantr1234_done
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
  rxquantr1234_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."statement"()
    unless $P10, rx1228_fail
    rx1228_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1228_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."eat_terminator"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."ws"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
    set_addr $I10, rxquantr1234_done
    (rx1228_rep) = rx1228_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1234_done
    rx1228_cur."!mark_push"(rx1228_rep, rx1228_pos, $I10)
    goto rxquantr1234_loop
  rxquantr1234_done:
  # rx subrule "ws" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."ws"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
  alt1230_end:
.annotate 'line', 553
  # rx pass
    rx1228_cur."!cursor_pass"(rx1228_pos, "statementlist")
    if_null rx1228_debug, debug_907
    rx1228_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1228_pos)
  debug_907:
    .return (rx1228_cur)
  rx1228_restart:
.annotate 'line', 438
    if_null rx1228_debug, debug_908
    rx1228_cur."!cursor_debug"("NEXT", "statementlist")
  debug_908:
  rx1228_fail:
    (rx1228_rep, rx1228_pos, $I10, $P10) = rx1228_cur."!mark_fail"(0)
    lt rx1228_pos, -1, rx1228_done
    eq rx1228_pos, -1, rx1228_fail
    jump $I10
  rx1228_done:
    rx1228_cur."!cursor_fail"()
    if_null rx1228_debug, debug_909
    rx1228_cur."!cursor_debug"("FAIL", "statementlist")
  debug_909:
    .return (rx1228_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("60_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1238 = self."!PREFIX__!subrule"("ws", "")
    $P1239 = self."!PREFIX__!subrule"("ws", "")
    new $P1240, "ResizablePMCArray"
    push $P1240, $P1238
    push $P1240, $P1239
    .return ($P1240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("61_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1245 = "62_1305640955.436" 
    capture_lex $P1245
    .local string rx1242_tgt
    .local int rx1242_pos
    .local int rx1242_off
    .local int rx1242_eos
    .local int rx1242_rep
    .local pmc rx1242_cur
    .local pmc rx1242_debug
    (rx1242_cur, rx1242_pos, rx1242_tgt, $I10) = self."!cursor_start"()
    rx1242_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1242_cur
    .local pmc match
    .lex "$/", match
    length rx1242_eos, rx1242_tgt
    gt rx1242_pos, rx1242_eos, rx1242_done
    set rx1242_off, 0
    lt rx1242_pos, 2, rx1242_start
    sub rx1242_off, rx1242_pos, 1
    substr rx1242_tgt, rx1242_tgt, rx1242_off
  rx1242_start:
    eq $I10, 1, rx1242_restart
    if_null rx1242_debug, debug_910
    rx1242_cur."!cursor_debug"("START", "statement")
  debug_910:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1243_done
    goto rxscan1243_scan
  rxscan1243_loop:
    (rx1242_pos) = rx1242_cur."from"()
    inc rx1242_pos
    rx1242_cur."!cursor_from"(rx1242_pos)
    ge rx1242_pos, rx1242_eos, rxscan1243_done
  rxscan1243_scan:
    set_addr $I10, rxscan1243_loop
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxscan1243_done:
.annotate 'line', 559
  # rx subrule "before" subtype=zerowidth negate=1
    rx1242_cur."!cursor_pos"(rx1242_pos)
    .const 'Sub' $P1245 = "62_1305640955.436" 
    capture_lex $P1245
    $P10 = rx1242_cur."before"($P1245)
    if $P10, rx1242_fail
  alt1249_0:
.annotate 'line', 560
    set_addr $I10, alt1249_1
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
.annotate 'line', 561
  # rx subrule "statement_control" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."statement_control"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1242_pos = $P10."pos"()
    goto alt1249_end
  alt1249_1:
.annotate 'line', 562
  # rx subrule "EXPR" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."EXPR"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."ws"()
    unless $P10, rx1242_fail
    rx1242_pos = $P10."pos"()
.annotate 'line', 567
  # rx rxquantr1250 ** 0..1
    set_addr $I10, rxquantr1250_done
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxquantr1250_loop:
  alt1251_0:
.annotate 'line', 563
    set_addr $I10, alt1251_1
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
.annotate 'line', 564
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."MARKED"("endstmt")
    unless $P10, rx1242_fail
    goto alt1251_end
  alt1251_1:
    set_addr $I10, alt1251_2
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
.annotate 'line', 565
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."statement_mod_cond"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1242_pos = $P10."pos"()
  # rx rxquantr1252 ** 0..1
    set_addr $I10, rxquantr1252_done
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxquantr1252_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."statement_mod_loop"()
    unless $P10, rx1242_fail
    goto rxsubrule1253_pass
  rxsubrule1253_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1242_fail
  rxsubrule1253_pass:
    set_addr $I10, rxsubrule1253_back
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1242_pos = $P10."pos"()
    set_addr $I10, rxquantr1252_done
    (rx1242_rep) = rx1242_cur."!mark_commit"($I10)
  rxquantr1252_done:
    goto alt1251_end
  alt1251_2:
.annotate 'line', 566
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."statement_mod_loop"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1242_pos = $P10."pos"()
  alt1251_end:
.annotate 'line', 567
    set_addr $I10, rxquantr1250_done
    (rx1242_rep) = rx1242_cur."!mark_commit"($I10)
  rxquantr1250_done:
  alt1249_end:
.annotate 'line', 558
  # rx pass
    rx1242_cur."!cursor_pass"(rx1242_pos, "statement")
    if_null rx1242_debug, debug_915
    rx1242_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1242_pos)
  debug_915:
    .return (rx1242_cur)
  rx1242_restart:
.annotate 'line', 438
    if_null rx1242_debug, debug_916
    rx1242_cur."!cursor_debug"("NEXT", "statement")
  debug_916:
  rx1242_fail:
    (rx1242_rep, rx1242_pos, $I10, $P10) = rx1242_cur."!mark_fail"(0)
    lt rx1242_pos, -1, rx1242_done
    eq rx1242_pos, -1, rx1242_fail
    jump $I10
  rx1242_done:
    rx1242_cur."!cursor_fail"()
    if_null rx1242_debug, debug_917
    rx1242_cur."!cursor_debug"("FAIL", "statement")
  debug_917:
    .return (rx1242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1244"  :anon :subid("62_1305640955.436") :method :outer("61_1305640955.436")
.annotate 'line', 559
    .local string rx1246_tgt
    .local int rx1246_pos
    .local int rx1246_off
    .local int rx1246_eos
    .local int rx1246_rep
    .local pmc rx1246_cur
    .local pmc rx1246_debug
    (rx1246_cur, rx1246_pos, rx1246_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1246_cur
    .local pmc match
    .lex "$/", match
    length rx1246_eos, rx1246_tgt
    gt rx1246_pos, rx1246_eos, rx1246_done
    set rx1246_off, 0
    lt rx1246_pos, 2, rx1246_start
    sub rx1246_off, rx1246_pos, 1
    substr rx1246_tgt, rx1246_tgt, rx1246_off
  rx1246_start:
    eq $I10, 1, rx1246_restart
    if_null rx1246_debug, debug_911
    rx1246_cur."!cursor_debug"("START", "")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1247_done
    goto rxscan1247_scan
  rxscan1247_loop:
    (rx1246_pos) = rx1246_cur."from"()
    inc rx1246_pos
    rx1246_cur."!cursor_from"(rx1246_pos)
    ge rx1246_pos, rx1246_eos, rxscan1247_done
  rxscan1247_scan:
    set_addr $I10, rxscan1247_loop
    rx1246_cur."!mark_push"(0, rx1246_pos, $I10)
  rxscan1247_done:
  alt1248_0:
    set_addr $I10, alt1248_1
    rx1246_cur."!mark_push"(0, rx1246_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1246_pos, rx1246_eos, rx1246_fail
    sub $I10, rx1246_pos, rx1246_off
    substr $S10, rx1246_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1246_fail
    inc rx1246_pos
    goto alt1248_end
  alt1248_1:
  # rxanchor eos
    ne rx1246_pos, rx1246_eos, rx1246_fail
  alt1248_end:
  # rx pass
    rx1246_cur."!cursor_pass"(rx1246_pos, "")
    if_null rx1246_debug, debug_912
    rx1246_cur."!cursor_debug"("PASS", "", " at pos=", rx1246_pos)
  debug_912:
    .return (rx1246_cur)
  rx1246_restart:
    if_null rx1246_debug, debug_913
    rx1246_cur."!cursor_debug"("NEXT", "")
  debug_913:
  rx1246_fail:
    (rx1246_rep, rx1246_pos, $I10, $P10) = rx1246_cur."!mark_fail"(0)
    lt rx1246_pos, -1, rx1246_done
    eq rx1246_pos, -1, rx1246_fail
    jump $I10
  rx1246_done:
    rx1246_cur."!cursor_fail"()
    if_null rx1246_debug, debug_914
    rx1246_cur."!cursor_debug"("FAIL", "")
  debug_914:
    .return (rx1246_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("63_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1255, "ResizablePMCArray"
    push $P1255, ""
    .return ($P1255)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("64_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_918
    rx1257_cur."!cursor_debug"("START", "eat_terminator")
  debug_918:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1258_done
    goto rxscan1258_scan
  rxscan1258_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1258_done
  rxscan1258_scan:
    set_addr $I10, rxscan1258_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1258_done:
  alt1259_0:
.annotate 'line', 571
    set_addr $I10, alt1259_1
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
.annotate 'line', 572
  # rx literal  ";"
    add $I11, rx1257_pos, 1
    gt $I11, rx1257_eos, rx1257_fail
    sub $I11, rx1257_pos, rx1257_off
    ord $I11, rx1257_tgt, $I11
    ne $I11, 59, rx1257_fail
    add rx1257_pos, 1
    goto alt1259_end
  alt1259_1:
    set_addr $I10, alt1259_2
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
.annotate 'line', 573
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."MARKED"("endstmt")
    unless $P10, rx1257_fail
    goto alt1259_end
  alt1259_2:
    set_addr $I10, alt1259_3
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
.annotate 'line', 574
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."terminator"()
    unless $P10, rx1257_fail
    goto alt1259_end
  alt1259_3:
.annotate 'line', 575
  # rxanchor eos
    ne rx1257_pos, rx1257_eos, rx1257_fail
  alt1259_end:
.annotate 'line', 571
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, "eat_terminator")
    if_null rx1257_debug, debug_919
    rx1257_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1257_pos)
  debug_919:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 438
    if_null rx1257_debug, debug_920
    rx1257_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_920:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_921
    rx1257_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_921:
    .return (rx1257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("65_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1261, "ResizablePMCArray"
    push $P1261, ""
    push $P1261, ""
    push $P1261, ""
    push $P1261, ";"
    .return ($P1261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("66_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1263_tgt
    .local int rx1263_pos
    .local int rx1263_off
    .local int rx1263_eos
    .local int rx1263_rep
    .local pmc rx1263_cur
    .local pmc rx1263_debug
    (rx1263_cur, rx1263_pos, rx1263_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1263_cur
    .local pmc match
    .lex "$/", match
    length rx1263_eos, rx1263_tgt
    gt rx1263_pos, rx1263_eos, rx1263_done
    set rx1263_off, 0
    lt rx1263_pos, 2, rx1263_start
    sub rx1263_off, rx1263_pos, 1
    substr rx1263_tgt, rx1263_tgt, rx1263_off
  rx1263_start:
    eq $I10, 1, rx1263_restart
    if_null rx1263_debug, debug_922
    rx1263_cur."!cursor_debug"("START", "xblock")
  debug_922:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1264_done
    goto rxscan1264_scan
  rxscan1264_loop:
    (rx1263_pos) = rx1263_cur."from"()
    inc rx1263_pos
    rx1263_cur."!cursor_from"(rx1263_pos)
    ge rx1263_pos, rx1263_eos, rxscan1264_done
  rxscan1264_scan:
    set_addr $I10, rxscan1264_loop
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
  rxscan1264_done:
.annotate 'line', 579
  # rx subrule "EXPR" subtype=capture negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."EXPR"()
    unless $P10, rx1263_fail
    rx1263_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1263_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."ws"()
    unless $P10, rx1263_fail
    rx1263_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."pblock"()
    unless $P10, rx1263_fail
    rx1263_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1263_pos = $P10."pos"()
.annotate 'line', 578
  # rx pass
    rx1263_cur."!cursor_pass"(rx1263_pos, "xblock")
    if_null rx1263_debug, debug_923
    rx1263_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1263_pos)
  debug_923:
    .return (rx1263_cur)
  rx1263_restart:
.annotate 'line', 438
    if_null rx1263_debug, debug_924
    rx1263_cur."!cursor_debug"("NEXT", "xblock")
  debug_924:
  rx1263_fail:
    (rx1263_rep, rx1263_pos, $I10, $P10) = rx1263_cur."!mark_fail"(0)
    lt rx1263_pos, -1, rx1263_done
    eq rx1263_pos, -1, rx1263_fail
    jump $I10
  rx1263_done:
    rx1263_cur."!cursor_fail"()
    if_null rx1263_debug, debug_925
    rx1263_cur."!cursor_debug"("FAIL", "xblock")
  debug_925:
    .return (rx1263_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("67_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1266 = self."!PREFIX__!subrule"("EXPR", "")
    new $P1267, "ResizablePMCArray"
    push $P1267, $P1266
    .return ($P1267)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("68_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1269_tgt
    .local int rx1269_pos
    .local int rx1269_off
    .local int rx1269_eos
    .local int rx1269_rep
    .local pmc rx1269_cur
    .local pmc rx1269_debug
    (rx1269_cur, rx1269_pos, rx1269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1269_cur
    .local pmc match
    .lex "$/", match
    length rx1269_eos, rx1269_tgt
    gt rx1269_pos, rx1269_eos, rx1269_done
    set rx1269_off, 0
    lt rx1269_pos, 2, rx1269_start
    sub rx1269_off, rx1269_pos, 1
    substr rx1269_tgt, rx1269_tgt, rx1269_off
  rx1269_start:
    eq $I10, 1, rx1269_restart
    if_null rx1269_debug, debug_926
    rx1269_cur."!cursor_debug"("START", "pblock")
  debug_926:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1270_done
    goto rxscan1270_scan
  rxscan1270_loop:
    (rx1269_pos) = rx1269_cur."from"()
    inc rx1269_pos
    rx1269_cur."!cursor_from"(rx1269_pos)
    ge rx1269_pos, rx1269_eos, rxscan1270_done
  rxscan1270_scan:
    set_addr $I10, rxscan1270_loop
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
  rxscan1270_done:
  alt1271_0:
.annotate 'line', 582
    set_addr $I10, alt1271_1
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
.annotate 'line', 583
  # rx subrule "lambda" subtype=method negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."lambda"()
    unless $P10, rx1269_fail
    rx1269_pos = $P10."pos"()
.annotate 'line', 584
  # rx subrule "newpad" subtype=method negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."newpad"()
    unless $P10, rx1269_fail
    rx1269_pos = $P10."pos"()
.annotate 'line', 585
  # rx subrule "signature" subtype=capture negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."signature"()
    unless $P10, rx1269_fail
    rx1269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1269_pos = $P10."pos"()
.annotate 'line', 586
  # rx subrule "blockoid" subtype=capture negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."blockoid"()
    unless $P10, rx1269_fail
    rx1269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1269_pos = $P10."pos"()
.annotate 'line', 583
    goto alt1271_end
  alt1271_1:
    set_addr $I10, alt1271_2
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
.annotate 'line', 587
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1269_pos, rx1269_off
    substr $S10, rx1269_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1269_fail
.annotate 'line', 588
  # rx subrule "newpad" subtype=method negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."newpad"()
    unless $P10, rx1269_fail
    rx1269_pos = $P10."pos"()
.annotate 'line', 589
  # rx subrule "blockoid" subtype=capture negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."blockoid"()
    unless $P10, rx1269_fail
    rx1269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1269_pos = $P10."pos"()
.annotate 'line', 587
    goto alt1271_end
  alt1271_2:
.annotate 'line', 590
  # rx subrule "panic" subtype=method negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."panic"("Missing block")
    unless $P10, rx1269_fail
    rx1269_pos = $P10."pos"()
  alt1271_end:
.annotate 'line', 582
  # rx pass
    rx1269_cur."!cursor_pass"(rx1269_pos, "pblock")
    if_null rx1269_debug, debug_927
    rx1269_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1269_pos)
  debug_927:
    .return (rx1269_cur)
  rx1269_restart:
.annotate 'line', 438
    if_null rx1269_debug, debug_928
    rx1269_cur."!cursor_debug"("NEXT", "pblock")
  debug_928:
  rx1269_fail:
    (rx1269_rep, rx1269_pos, $I10, $P10) = rx1269_cur."!mark_fail"(0)
    lt rx1269_pos, -1, rx1269_done
    eq rx1269_pos, -1, rx1269_fail
    jump $I10
  rx1269_done:
    rx1269_cur."!cursor_fail"()
    if_null rx1269_debug, debug_929
    rx1269_cur."!cursor_debug"("FAIL", "pblock")
  debug_929:
    .return (rx1269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("69_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1273 = self."!PREFIX__!subrule"("panic", "")
    $P1274 = self."!PREFIX__!subrule"("lambda", "")
    new $P1275, "ResizablePMCArray"
    push $P1275, $P1273
    push $P1275, "{"
    push $P1275, $P1274
    .return ($P1275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("70_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1277_tgt
    .local int rx1277_pos
    .local int rx1277_off
    .local int rx1277_eos
    .local int rx1277_rep
    .local pmc rx1277_cur
    .local pmc rx1277_debug
    (rx1277_cur, rx1277_pos, rx1277_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1277_cur
    .local pmc match
    .lex "$/", match
    length rx1277_eos, rx1277_tgt
    gt rx1277_pos, rx1277_eos, rx1277_done
    set rx1277_off, 0
    lt rx1277_pos, 2, rx1277_start
    sub rx1277_off, rx1277_pos, 1
    substr rx1277_tgt, rx1277_tgt, rx1277_off
  rx1277_start:
    eq $I10, 1, rx1277_restart
    if_null rx1277_debug, debug_930
    rx1277_cur."!cursor_debug"("START", "lambda")
  debug_930:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1278_done
    goto rxscan1278_scan
  rxscan1278_loop:
    (rx1277_pos) = rx1277_cur."from"()
    inc rx1277_pos
    rx1277_cur."!cursor_from"(rx1277_pos)
    ge rx1277_pos, rx1277_eos, rxscan1278_done
  rxscan1278_scan:
    set_addr $I10, rxscan1278_loop
    rx1277_cur."!mark_push"(0, rx1277_pos, $I10)
  rxscan1278_done:
  alt1279_0:
.annotate 'line', 593
    set_addr $I10, alt1279_1
    rx1277_cur."!mark_push"(0, rx1277_pos, $I10)
  # rx literal  "->"
    add $I11, rx1277_pos, 2
    gt $I11, rx1277_eos, rx1277_fail
    sub $I11, rx1277_pos, rx1277_off
    substr $S10, rx1277_tgt, $I11, 2
    ne $S10, "->", rx1277_fail
    add rx1277_pos, 2
    goto alt1279_end
  alt1279_1:
  # rx literal  "<->"
    add $I11, rx1277_pos, 3
    gt $I11, rx1277_eos, rx1277_fail
    sub $I11, rx1277_pos, rx1277_off
    substr $S10, rx1277_tgt, $I11, 3
    ne $S10, "<->", rx1277_fail
    add rx1277_pos, 3
  alt1279_end:
  # rx pass
    rx1277_cur."!cursor_pass"(rx1277_pos, "lambda")
    if_null rx1277_debug, debug_931
    rx1277_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1277_pos)
  debug_931:
    .return (rx1277_cur)
  rx1277_restart:
.annotate 'line', 438
    if_null rx1277_debug, debug_932
    rx1277_cur."!cursor_debug"("NEXT", "lambda")
  debug_932:
  rx1277_fail:
    (rx1277_rep, rx1277_pos, $I10, $P10) = rx1277_cur."!mark_fail"(0)
    lt rx1277_pos, -1, rx1277_done
    eq rx1277_pos, -1, rx1277_fail
    jump $I10
  rx1277_done:
    rx1277_cur."!cursor_fail"()
    if_null rx1277_debug, debug_933
    rx1277_cur."!cursor_debug"("FAIL", "lambda")
  debug_933:
    .return (rx1277_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("71_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1281, "ResizablePMCArray"
    push $P1281, "<->"
    push $P1281, "->"
    .return ($P1281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("72_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1283_tgt
    .local int rx1283_pos
    .local int rx1283_off
    .local int rx1283_eos
    .local int rx1283_rep
    .local pmc rx1283_cur
    .local pmc rx1283_debug
    (rx1283_cur, rx1283_pos, rx1283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1283_cur
    .local pmc match
    .lex "$/", match
    length rx1283_eos, rx1283_tgt
    gt rx1283_pos, rx1283_eos, rx1283_done
    set rx1283_off, 0
    lt rx1283_pos, 2, rx1283_start
    sub rx1283_off, rx1283_pos, 1
    substr rx1283_tgt, rx1283_tgt, rx1283_off
  rx1283_start:
    eq $I10, 1, rx1283_restart
    if_null rx1283_debug, debug_934
    rx1283_cur."!cursor_debug"("START", "block")
  debug_934:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1284_done
    goto rxscan1284_scan
  rxscan1284_loop:
    (rx1283_pos) = rx1283_cur."from"()
    inc rx1283_pos
    rx1283_cur."!cursor_from"(rx1283_pos)
    ge rx1283_pos, rx1283_eos, rxscan1284_done
  rxscan1284_scan:
    set_addr $I10, rxscan1284_loop
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxscan1284_done:
  alt1285_0:
.annotate 'line', 596
    set_addr $I10, alt1285_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1283_fail
    goto alt1285_end
  alt1285_1:
  # rx subrule "panic" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."panic"("Missing block")
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1285_end:
.annotate 'line', 597
  # rx subrule "newpad" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."newpad"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 598
  # rx subrule "blockoid" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."blockoid"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1283_pos = $P10."pos"()
.annotate 'line', 595
  # rx pass
    rx1283_cur."!cursor_pass"(rx1283_pos, "block")
    if_null rx1283_debug, debug_935
    rx1283_cur."!cursor_debug"("PASS", "block", " at pos=", rx1283_pos)
  debug_935:
    .return (rx1283_cur)
  rx1283_restart:
.annotate 'line', 438
    if_null rx1283_debug, debug_936
    rx1283_cur."!cursor_debug"("NEXT", "block")
  debug_936:
  rx1283_fail:
    (rx1283_rep, rx1283_pos, $I10, $P10) = rx1283_cur."!mark_fail"(0)
    lt rx1283_pos, -1, rx1283_done
    eq rx1283_pos, -1, rx1283_fail
    jump $I10
  rx1283_done:
    rx1283_cur."!cursor_fail"()
    if_null rx1283_debug, debug_937
    rx1283_cur."!cursor_debug"("FAIL", "block")
  debug_937:
    .return (rx1283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("73_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1287 = self."!PREFIX__!subrule"("panic", "")
    new $P1288, "ResizablePMCArray"
    push $P1288, $P1287
    push $P1288, "{"
    .return ($P1288)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("74_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1290_tgt
    .local int rx1290_pos
    .local int rx1290_off
    .local int rx1290_eos
    .local int rx1290_rep
    .local pmc rx1290_cur
    .local pmc rx1290_debug
    (rx1290_cur, rx1290_pos, rx1290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1290_cur
    .local pmc match
    .lex "$/", match
    length rx1290_eos, rx1290_tgt
    gt rx1290_pos, rx1290_eos, rx1290_done
    set rx1290_off, 0
    lt rx1290_pos, 2, rx1290_start
    sub rx1290_off, rx1290_pos, 1
    substr rx1290_tgt, rx1290_tgt, rx1290_off
  rx1290_start:
    eq $I10, 1, rx1290_restart
    if_null rx1290_debug, debug_938
    rx1290_cur."!cursor_debug"("START", "blockoid")
  debug_938:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1291_done
    goto rxscan1291_scan
  rxscan1291_loop:
    (rx1290_pos) = rx1290_cur."from"()
    inc rx1290_pos
    rx1290_cur."!cursor_from"(rx1290_pos)
    ge rx1290_pos, rx1290_eos, rxscan1291_done
  rxscan1291_scan:
    set_addr $I10, rxscan1291_loop
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  rxscan1291_done:
.annotate 'line', 602
  # rx subrule "finishpad" subtype=method negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."finishpad"()
    unless $P10, rx1290_fail
    rx1290_pos = $P10."pos"()
  alt1292_0:
.annotate 'line', 603
    set_addr $I10, alt1292_1
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
.annotate 'line', 604
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1290_pos, 14
    gt $I11, rx1290_eos, rx1290_fail
    sub $I11, rx1290_pos, rx1290_off
    substr $S10, rx1290_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1290_fail
    add rx1290_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."you_are_here"()
    unless $P10, rx1290_fail
    rx1290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1290_pos = $P10."pos"()
    goto alt1292_end
  alt1292_1:
.annotate 'line', 605
  # rx literal  "{"
    add $I11, rx1290_pos, 1
    gt $I11, rx1290_eos, rx1290_fail
    sub $I11, rx1290_pos, rx1290_off
    ord $I11, rx1290_tgt, $I11
    ne $I11, 123, rx1290_fail
    add rx1290_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."statementlist"()
    unless $P10, rx1290_fail
    rx1290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1290_pos = $P10."pos"()
  alt1293_0:
    set_addr $I10, alt1293_1
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  # rx literal  "}"
    add $I11, rx1290_pos, 1
    gt $I11, rx1290_eos, rx1290_fail
    sub $I11, rx1290_pos, rx1290_off
    ord $I11, rx1290_tgt, $I11
    ne $I11, 125, rx1290_fail
    add rx1290_pos, 1
    goto alt1293_end
  alt1293_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."FAILGOAL"("'}'")
    unless $P10, rx1290_fail
    goto rxsubrule1295_pass
  rxsubrule1295_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1290_fail
  rxsubrule1295_pass:
    set_addr $I10, rxsubrule1295_back
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10, $P10)
    rx1290_pos = $P10."pos"()
  alt1293_end:
  alt1292_end:
.annotate 'line', 607
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."ENDSTMT"()
    unless $P10, rx1290_fail
.annotate 'line', 601
  # rx pass
    rx1290_cur."!cursor_pass"(rx1290_pos, "blockoid")
    if_null rx1290_debug, debug_939
    rx1290_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1290_pos)
  debug_939:
    .return (rx1290_cur)
  rx1290_restart:
.annotate 'line', 438
    if_null rx1290_debug, debug_940
    rx1290_cur."!cursor_debug"("NEXT", "blockoid")
  debug_940:
  rx1290_fail:
    (rx1290_rep, rx1290_pos, $I10, $P10) = rx1290_cur."!mark_fail"(0)
    lt rx1290_pos, -1, rx1290_done
    eq rx1290_pos, -1, rx1290_fail
    jump $I10
  rx1290_done:
    rx1290_cur."!cursor_fail"()
    if_null rx1290_debug, debug_941
    rx1290_cur."!cursor_debug"("FAIL", "blockoid")
  debug_941:
    .return (rx1290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("75_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1297 = self."!PREFIX__!subrule"("finishpad", "")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("76_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1300_tgt
    .local int rx1300_pos
    .local int rx1300_off
    .local int rx1300_eos
    .local int rx1300_rep
    .local pmc rx1300_cur
    .local pmc rx1300_debug
    (rx1300_cur, rx1300_pos, rx1300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1300_cur
    .local pmc match
    .lex "$/", match
    length rx1300_eos, rx1300_tgt
    gt rx1300_pos, rx1300_eos, rx1300_done
    set rx1300_off, 0
    lt rx1300_pos, 2, rx1300_start
    sub rx1300_off, rx1300_pos, 1
    substr rx1300_tgt, rx1300_tgt, rx1300_off
  rx1300_start:
    eq $I10, 1, rx1300_restart
    if_null rx1300_debug, debug_942
    rx1300_cur."!cursor_debug"("START", "newpad")
  debug_942:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1301_done
    goto rxscan1301_scan
  rxscan1301_loop:
    (rx1300_pos) = rx1300_cur."from"()
    inc rx1300_pos
    rx1300_cur."!cursor_from"(rx1300_pos)
    ge rx1300_pos, rx1300_eos, rxscan1301_done
  rxscan1301_scan:
    set_addr $I10, rxscan1301_loop
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  rxscan1301_done:
.annotate 'line', 610
  # rx pass
    rx1300_cur."!cursor_pass"(rx1300_pos, "newpad")
    if_null rx1300_debug, debug_943
    rx1300_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1300_pos)
  debug_943:
    .return (rx1300_cur)
  rx1300_restart:
.annotate 'line', 438
    if_null rx1300_debug, debug_944
    rx1300_cur."!cursor_debug"("NEXT", "newpad")
  debug_944:
  rx1300_fail:
    (rx1300_rep, rx1300_pos, $I10, $P10) = rx1300_cur."!mark_fail"(0)
    lt rx1300_pos, -1, rx1300_done
    eq rx1300_pos, -1, rx1300_fail
    jump $I10
  rx1300_done:
    rx1300_cur."!cursor_fail"()
    if_null rx1300_debug, debug_945
    rx1300_cur."!cursor_debug"("FAIL", "newpad")
  debug_945:
    .return (rx1300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("77_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1303, "ResizablePMCArray"
    push $P1303, ""
    .return ($P1303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("78_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1305_tgt
    .local int rx1305_pos
    .local int rx1305_off
    .local int rx1305_eos
    .local int rx1305_rep
    .local pmc rx1305_cur
    .local pmc rx1305_debug
    (rx1305_cur, rx1305_pos, rx1305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1305_cur
    .local pmc match
    .lex "$/", match
    length rx1305_eos, rx1305_tgt
    gt rx1305_pos, rx1305_eos, rx1305_done
    set rx1305_off, 0
    lt rx1305_pos, 2, rx1305_start
    sub rx1305_off, rx1305_pos, 1
    substr rx1305_tgt, rx1305_tgt, rx1305_off
  rx1305_start:
    eq $I10, 1, rx1305_restart
    if_null rx1305_debug, debug_946
    rx1305_cur."!cursor_debug"("START", "outerctx")
  debug_946:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1305_pos) = rx1305_cur."from"()
    inc rx1305_pos
    rx1305_cur."!cursor_from"(rx1305_pos)
    ge rx1305_pos, rx1305_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1305_cur."!mark_push"(0, rx1305_pos, $I10)
  rxscan1306_done:
.annotate 'line', 611
  # rx pass
    rx1305_cur."!cursor_pass"(rx1305_pos, "outerctx")
    if_null rx1305_debug, debug_947
    rx1305_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1305_pos)
  debug_947:
    .return (rx1305_cur)
  rx1305_restart:
.annotate 'line', 438
    if_null rx1305_debug, debug_948
    rx1305_cur."!cursor_debug"("NEXT", "outerctx")
  debug_948:
  rx1305_fail:
    (rx1305_rep, rx1305_pos, $I10, $P10) = rx1305_cur."!mark_fail"(0)
    lt rx1305_pos, -1, rx1305_done
    eq rx1305_pos, -1, rx1305_fail
    jump $I10
  rx1305_done:
    rx1305_cur."!cursor_fail"()
    if_null rx1305_debug, debug_949
    rx1305_cur."!cursor_debug"("FAIL", "outerctx")
  debug_949:
    .return (rx1305_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("79_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1308, "ResizablePMCArray"
    push $P1308, ""
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("80_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_950
    rx1310_cur."!cursor_debug"("START", "GLOBALish")
  debug_950:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1311_done:
.annotate 'line', 612
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "GLOBALish")
    if_null rx1310_debug, debug_951
    rx1310_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1310_pos)
  debug_951:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 438
    if_null rx1310_debug, debug_952
    rx1310_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_952:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_953
    rx1310_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_953:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("81_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1313, "ResizablePMCArray"
    push $P1313, ""
    .return ($P1313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("82_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1315_tgt
    .local int rx1315_pos
    .local int rx1315_off
    .local int rx1315_eos
    .local int rx1315_rep
    .local pmc rx1315_cur
    .local pmc rx1315_debug
    (rx1315_cur, rx1315_pos, rx1315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1315_cur
    .local pmc match
    .lex "$/", match
    length rx1315_eos, rx1315_tgt
    gt rx1315_pos, rx1315_eos, rx1315_done
    set rx1315_off, 0
    lt rx1315_pos, 2, rx1315_start
    sub rx1315_off, rx1315_pos, 1
    substr rx1315_tgt, rx1315_tgt, rx1315_off
  rx1315_start:
    eq $I10, 1, rx1315_restart
    if_null rx1315_debug, debug_954
    rx1315_cur."!cursor_debug"("START", "finishpad")
  debug_954:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1316_done
    goto rxscan1316_scan
  rxscan1316_loop:
    (rx1315_pos) = rx1315_cur."from"()
    inc rx1315_pos
    rx1315_cur."!cursor_from"(rx1315_pos)
    ge rx1315_pos, rx1315_eos, rxscan1316_done
  rxscan1316_scan:
    set_addr $I10, rxscan1316_loop
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  rxscan1316_done:
.annotate 'line', 613
  # rx pass
    rx1315_cur."!cursor_pass"(rx1315_pos, "finishpad")
    if_null rx1315_debug, debug_955
    rx1315_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1315_pos)
  debug_955:
    .return (rx1315_cur)
  rx1315_restart:
.annotate 'line', 438
    if_null rx1315_debug, debug_956
    rx1315_cur."!cursor_debug"("NEXT", "finishpad")
  debug_956:
  rx1315_fail:
    (rx1315_rep, rx1315_pos, $I10, $P10) = rx1315_cur."!mark_fail"(0)
    lt rx1315_pos, -1, rx1315_done
    eq rx1315_pos, -1, rx1315_fail
    jump $I10
  rx1315_done:
    rx1315_cur."!cursor_fail"()
    if_null rx1315_debug, debug_957
    rx1315_cur."!cursor_debug"("FAIL", "finishpad")
  debug_957:
    .return (rx1315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("83_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1318, "ResizablePMCArray"
    push $P1318, ""
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("84_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1320_tgt
    .local int rx1320_pos
    .local int rx1320_off
    .local int rx1320_eos
    .local int rx1320_rep
    .local pmc rx1320_cur
    .local pmc rx1320_debug
    (rx1320_cur, rx1320_pos, rx1320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1320_cur
    .local pmc match
    .lex "$/", match
    length rx1320_eos, rx1320_tgt
    gt rx1320_pos, rx1320_eos, rx1320_done
    set rx1320_off, 0
    lt rx1320_pos, 2, rx1320_start
    sub rx1320_off, rx1320_pos, 1
    substr rx1320_tgt, rx1320_tgt, rx1320_off
  rx1320_start:
    eq $I10, 1, rx1320_restart
    if_null rx1320_debug, debug_958
    rx1320_cur."!cursor_debug"("START", "you_are_here")
  debug_958:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1320_pos) = rx1320_cur."from"()
    inc rx1320_pos
    rx1320_cur."!cursor_from"(rx1320_pos)
    ge rx1320_pos, rx1320_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  rxscan1321_done:
.annotate 'line', 614
  # rx pass
    rx1320_cur."!cursor_pass"(rx1320_pos, "you_are_here")
    if_null rx1320_debug, debug_959
    rx1320_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1320_pos)
  debug_959:
    .return (rx1320_cur)
  rx1320_restart:
.annotate 'line', 438
    if_null rx1320_debug, debug_960
    rx1320_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_960:
  rx1320_fail:
    (rx1320_rep, rx1320_pos, $I10, $P10) = rx1320_cur."!mark_fail"(0)
    lt rx1320_pos, -1, rx1320_done
    eq rx1320_pos, -1, rx1320_fail
    jump $I10
  rx1320_done:
    rx1320_cur."!cursor_fail"()
    if_null rx1320_debug, debug_961
    rx1320_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_961:
    .return (rx1320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("85_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1323, "ResizablePMCArray"
    push $P1323, ""
    .return ($P1323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("86_1305640955.436")
    .param pmc param_1325
.annotate 'line', 616
    .lex "self", param_1325
    $P1326 = param_1325."!protoregex"("terminator")
    .return ($P1326)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("87_1305640955.436")
    .param pmc param_1328
.annotate 'line', 616
    .lex "self", param_1328
    $P1329 = param_1328."!PREFIX__!protoregex"("terminator")
    .return ($P1329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("88_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1331_tgt
    .local int rx1331_pos
    .local int rx1331_off
    .local int rx1331_eos
    .local int rx1331_rep
    .local pmc rx1331_cur
    .local pmc rx1331_debug
    (rx1331_cur, rx1331_pos, rx1331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1331_cur
    .local pmc match
    .lex "$/", match
    length rx1331_eos, rx1331_tgt
    gt rx1331_pos, rx1331_eos, rx1331_done
    set rx1331_off, 0
    lt rx1331_pos, 2, rx1331_start
    sub rx1331_off, rx1331_pos, 1
    substr rx1331_tgt, rx1331_tgt, rx1331_off
  rx1331_start:
    eq $I10, 1, rx1331_restart
    if_null rx1331_debug, debug_962
    rx1331_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_962:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1331_pos) = rx1331_cur."from"()
    inc rx1331_pos
    rx1331_cur."!cursor_from"(rx1331_pos)
    ge rx1331_pos, rx1331_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1331_cur."!mark_push"(0, rx1331_pos, $I10)
  rxscan1332_done:
.annotate 'line', 618
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1331_pos, rx1331_off
    substr $S10, rx1331_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1331_fail
  # rx pass
    rx1331_cur."!cursor_pass"(rx1331_pos, "terminator:sym<;>")
    if_null rx1331_debug, debug_963
    rx1331_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1331_pos)
  debug_963:
    .return (rx1331_cur)
  rx1331_restart:
.annotate 'line', 438
    if_null rx1331_debug, debug_964
    rx1331_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_964:
  rx1331_fail:
    (rx1331_rep, rx1331_pos, $I10, $P10) = rx1331_cur."!mark_fail"(0)
    lt rx1331_pos, -1, rx1331_done
    eq rx1331_pos, -1, rx1331_fail
    jump $I10
  rx1331_done:
    rx1331_cur."!cursor_fail"()
    if_null rx1331_debug, debug_965
    rx1331_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_965:
    .return (rx1331_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("89_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1334, "ResizablePMCArray"
    push $P1334, ";"
    .return ($P1334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("90_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1336_tgt
    .local int rx1336_pos
    .local int rx1336_off
    .local int rx1336_eos
    .local int rx1336_rep
    .local pmc rx1336_cur
    .local pmc rx1336_debug
    (rx1336_cur, rx1336_pos, rx1336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1336_cur
    .local pmc match
    .lex "$/", match
    length rx1336_eos, rx1336_tgt
    gt rx1336_pos, rx1336_eos, rx1336_done
    set rx1336_off, 0
    lt rx1336_pos, 2, rx1336_start
    sub rx1336_off, rx1336_pos, 1
    substr rx1336_tgt, rx1336_tgt, rx1336_off
  rx1336_start:
    eq $I10, 1, rx1336_restart
    if_null rx1336_debug, debug_966
    rx1336_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_966:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1337_done
    goto rxscan1337_scan
  rxscan1337_loop:
    (rx1336_pos) = rx1336_cur."from"()
    inc rx1336_pos
    rx1336_cur."!cursor_from"(rx1336_pos)
    ge rx1336_pos, rx1336_eos, rxscan1337_done
  rxscan1337_scan:
    set_addr $I10, rxscan1337_loop
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  rxscan1337_done:
.annotate 'line', 619
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1336_pos, rx1336_off
    substr $S10, rx1336_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1336_fail
  # rx pass
    rx1336_cur."!cursor_pass"(rx1336_pos, "terminator:sym<}>")
    if_null rx1336_debug, debug_967
    rx1336_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1336_pos)
  debug_967:
    .return (rx1336_cur)
  rx1336_restart:
.annotate 'line', 438
    if_null rx1336_debug, debug_968
    rx1336_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_968:
  rx1336_fail:
    (rx1336_rep, rx1336_pos, $I10, $P10) = rx1336_cur."!mark_fail"(0)
    lt rx1336_pos, -1, rx1336_done
    eq rx1336_pos, -1, rx1336_fail
    jump $I10
  rx1336_done:
    rx1336_cur."!cursor_fail"()
    if_null rx1336_debug, debug_969
    rx1336_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_969:
    .return (rx1336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("91_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1339, "ResizablePMCArray"
    push $P1339, "}"
    .return ($P1339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("92_1305640955.436")
    .param pmc param_1341
.annotate 'line', 623
    .lex "self", param_1341
    $P1342 = param_1341."!protoregex"("statement_control")
    .return ($P1342)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("93_1305640955.436")
    .param pmc param_1344
.annotate 'line', 623
    .lex "self", param_1344
    $P1345 = param_1344."!PREFIX__!protoregex"("statement_control")
    .return ($P1345)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("94_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1347_tgt
    .local int rx1347_pos
    .local int rx1347_off
    .local int rx1347_eos
    .local int rx1347_rep
    .local pmc rx1347_cur
    .local pmc rx1347_debug
    (rx1347_cur, rx1347_pos, rx1347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1347_cur
    .local pmc match
    .lex "$/", match
    length rx1347_eos, rx1347_tgt
    gt rx1347_pos, rx1347_eos, rx1347_done
    set rx1347_off, 0
    lt rx1347_pos, 2, rx1347_start
    sub rx1347_off, rx1347_pos, 1
    substr rx1347_tgt, rx1347_tgt, rx1347_off
  rx1347_start:
    eq $I10, 1, rx1347_restart
    if_null rx1347_debug, debug_970
    rx1347_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_970:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1348_done
    goto rxscan1348_scan
  rxscan1348_loop:
    (rx1347_pos) = rx1347_cur."from"()
    inc rx1347_pos
    rx1347_cur."!cursor_from"(rx1347_pos)
    ge rx1347_pos, rx1347_eos, rxscan1348_done
  rxscan1348_scan:
    set_addr $I10, rxscan1348_loop
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  rxscan1348_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1349_fail
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  # rx literal  "use"
    add $I11, rx1347_pos, 3
    gt $I11, rx1347_eos, rx1347_fail
    sub $I11, rx1347_pos, rx1347_off
    substr $S10, rx1347_tgt, $I11, 3
    ne $S10, "use", rx1347_fail
    add rx1347_pos, 3
    set_addr $I10, rxcap_1349_fail
    ($I12, $I11) = rx1347_cur."!mark_peek"($I10)
    rx1347_cur."!cursor_pos"($I11)
    ($P10) = rx1347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1347_pos, "")
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1349_done
  rxcap_1349_fail:
    goto rx1347_fail
  rxcap_1349_done:
  # rx charclass s
    ge rx1347_pos, rx1347_eos, rx1347_fail
    sub $I10, rx1347_pos, rx1347_off
    is_cclass $I11, 32, rx1347_tgt, $I10
    unless $I11, rx1347_fail
    inc rx1347_pos
  # rx subrule "ws" subtype=method negate=
    rx1347_cur."!cursor_pos"(rx1347_pos)
    $P10 = rx1347_cur."ws"()
    unless $P10, rx1347_fail
    rx1347_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1347_cur."!cursor_pos"(rx1347_pos)
    $P10 = rx1347_cur."name"()
    unless $P10, rx1347_fail
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1347_cur."!cursor_pos"(rx1347_pos)
    $P10 = rx1347_cur."ws"()
    unless $P10, rx1347_fail
    rx1347_pos = $P10."pos"()
.annotate 'line', 625
  # rx pass
    rx1347_cur."!cursor_pass"(rx1347_pos, "statement_control:sym<use>")
    if_null rx1347_debug, debug_971
    rx1347_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1347_pos)
  debug_971:
    .return (rx1347_cur)
  rx1347_restart:
.annotate 'line', 438
    if_null rx1347_debug, debug_972
    rx1347_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_972:
  rx1347_fail:
    (rx1347_rep, rx1347_pos, $I10, $P10) = rx1347_cur."!mark_fail"(0)
    lt rx1347_pos, -1, rx1347_done
    eq rx1347_pos, -1, rx1347_fail
    jump $I10
  rx1347_done:
    rx1347_cur."!cursor_fail"()
    if_null rx1347_debug, debug_973
    rx1347_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_973:
    .return (rx1347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("95_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1353, "ResizablePMCArray"
    push $P1353, "use"
    .return ($P1353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("96_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1355_tgt
    .local int rx1355_pos
    .local int rx1355_off
    .local int rx1355_eos
    .local int rx1355_rep
    .local pmc rx1355_cur
    .local pmc rx1355_debug
    (rx1355_cur, rx1355_pos, rx1355_tgt, $I10) = self."!cursor_start"()
    rx1355_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1355_cur
    .local pmc match
    .lex "$/", match
    length rx1355_eos, rx1355_tgt
    gt rx1355_pos, rx1355_eos, rx1355_done
    set rx1355_off, 0
    lt rx1355_pos, 2, rx1355_start
    sub rx1355_off, rx1355_pos, 1
    substr rx1355_tgt, rx1355_tgt, rx1355_off
  rx1355_start:
    eq $I10, 1, rx1355_restart
    if_null rx1355_debug, debug_974
    rx1355_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1356_done
    goto rxscan1356_scan
  rxscan1356_loop:
    (rx1355_pos) = rx1355_cur."from"()
    inc rx1355_pos
    rx1355_cur."!cursor_from"(rx1355_pos)
    ge rx1355_pos, rx1355_eos, rxscan1356_done
  rxscan1356_scan:
    set_addr $I10, rxscan1356_loop
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  rxscan1356_done:
.annotate 'line', 630
  # rx subcapture "sym"
    set_addr $I10, rxcap_1357_fail
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  # rx literal  "if"
    add $I11, rx1355_pos, 2
    gt $I11, rx1355_eos, rx1355_fail
    sub $I11, rx1355_pos, rx1355_off
    substr $S10, rx1355_tgt, $I11, 2
    ne $S10, "if", rx1355_fail
    add rx1355_pos, 2
    set_addr $I10, rxcap_1357_fail
    ($I12, $I11) = rx1355_cur."!mark_peek"($I10)
    rx1355_cur."!cursor_pos"($I11)
    ($P10) = rx1355_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1355_pos, "")
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1357_done
  rxcap_1357_fail:
    goto rx1355_fail
  rxcap_1357_done:
  # rx charclass s
    ge rx1355_pos, rx1355_eos, rx1355_fail
    sub $I10, rx1355_pos, rx1355_off
    is_cclass $I11, 32, rx1355_tgt, $I10
    unless $I11, rx1355_fail
    inc rx1355_pos
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
.annotate 'line', 631
  # rx subrule "xblock" subtype=capture negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."xblock"()
    unless $P10, rx1355_fail
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1355_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
.annotate 'line', 632
  # rx rxquantr1360 ** 0..*
    set_addr $I10, rxquantr1360_done
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  rxquantr1360_loop:
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1355_pos, 5
    gt $I11, rx1355_eos, rx1355_fail
    sub $I11, rx1355_pos, rx1355_off
    substr $S10, rx1355_tgt, $I11, 5
    ne $S10, "elsif", rx1355_fail
    add rx1355_pos, 5
  # rx charclass s
    ge rx1355_pos, rx1355_eos, rx1355_fail
    sub $I10, rx1355_pos, rx1355_off
    is_cclass $I11, 32, rx1355_tgt, $I10
    unless $I11, rx1355_fail
    inc rx1355_pos
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."xblock"()
    unless $P10, rx1355_fail
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1355_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
    set_addr $I10, rxquantr1360_done
    (rx1355_rep) = rx1355_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1360_done
    rx1355_cur."!mark_push"(rx1355_rep, rx1355_pos, $I10)
    goto rxquantr1360_loop
  rxquantr1360_done:
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
.annotate 'line', 633
  # rx rxquantr1365 ** 0..1
    set_addr $I10, rxquantr1365_done
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  rxquantr1365_loop:
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1355_pos, 4
    gt $I11, rx1355_eos, rx1355_fail
    sub $I11, rx1355_pos, rx1355_off
    substr $S10, rx1355_tgt, $I11, 4
    ne $S10, "else", rx1355_fail
    add rx1355_pos, 4
  # rx charclass s
    ge rx1355_pos, rx1355_eos, rx1355_fail
    sub $I10, rx1355_pos, rx1355_off
    is_cclass $I11, 32, rx1355_tgt, $I10
    unless $I11, rx1355_fail
    inc rx1355_pos
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."pblock"()
    unless $P10, rx1355_fail
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1355_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
    set_addr $I10, rxquantr1365_done
    (rx1355_rep) = rx1355_cur."!mark_commit"($I10)
  rxquantr1365_done:
  # rx subrule "ws" subtype=method negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."ws"()
    unless $P10, rx1355_fail
    rx1355_pos = $P10."pos"()
.annotate 'line', 629
  # rx pass
    rx1355_cur."!cursor_pass"(rx1355_pos, "statement_control:sym<if>")
    if_null rx1355_debug, debug_975
    rx1355_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1355_pos)
  debug_975:
    .return (rx1355_cur)
  rx1355_restart:
.annotate 'line', 438
    if_null rx1355_debug, debug_976
    rx1355_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_976:
  rx1355_fail:
    (rx1355_rep, rx1355_pos, $I10, $P10) = rx1355_cur."!mark_fail"(0)
    lt rx1355_pos, -1, rx1355_done
    eq rx1355_pos, -1, rx1355_fail
    jump $I10
  rx1355_done:
    rx1355_cur."!cursor_fail"()
    if_null rx1355_debug, debug_977
    rx1355_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_977:
    .return (rx1355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("97_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1371, "ResizablePMCArray"
    push $P1371, "if"
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("98_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1381 = "99_1305640955.436" 
    capture_lex $P1381
    .local string rx1373_tgt
    .local int rx1373_pos
    .local int rx1373_off
    .local int rx1373_eos
    .local int rx1373_rep
    .local pmc rx1373_cur
    .local pmc rx1373_debug
    (rx1373_cur, rx1373_pos, rx1373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1373_cur
    .local pmc match
    .lex "$/", match
    length rx1373_eos, rx1373_tgt
    gt rx1373_pos, rx1373_eos, rx1373_done
    set rx1373_off, 0
    lt rx1373_pos, 2, rx1373_start
    sub rx1373_off, rx1373_pos, 1
    substr rx1373_tgt, rx1373_tgt, rx1373_off
  rx1373_start:
    eq $I10, 1, rx1373_restart
    if_null rx1373_debug, debug_978
    rx1373_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    (rx1373_pos) = rx1373_cur."from"()
    inc rx1373_pos
    rx1373_cur."!cursor_from"(rx1373_pos)
    ge rx1373_pos, rx1373_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  rxscan1374_done:
.annotate 'line', 637
  # rx subcapture "sym"
    set_addr $I10, rxcap_1375_fail
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1373_pos, 6
    gt $I11, rx1373_eos, rx1373_fail
    sub $I11, rx1373_pos, rx1373_off
    substr $S10, rx1373_tgt, $I11, 6
    ne $S10, "unless", rx1373_fail
    add rx1373_pos, 6
    set_addr $I10, rxcap_1375_fail
    ($I12, $I11) = rx1373_cur."!mark_peek"($I10)
    rx1373_cur."!cursor_pos"($I11)
    ($P10) = rx1373_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1373_pos, "")
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1375_done
  rxcap_1375_fail:
    goto rx1373_fail
  rxcap_1375_done:
  # rx charclass s
    ge rx1373_pos, rx1373_eos, rx1373_fail
    sub $I10, rx1373_pos, rx1373_off
    is_cclass $I11, 32, rx1373_tgt, $I10
    unless $I11, rx1373_fail
    inc rx1373_pos
  # rx subrule "ws" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."ws"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
.annotate 'line', 638
  # rx subrule "xblock" subtype=capture negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."xblock"()
    unless $P10, rx1373_fail
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1373_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."ws"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
  alt1378_0:
.annotate 'line', 639
    set_addr $I10, alt1378_1
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."ws"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1373_cur."!cursor_pos"(rx1373_pos)
    .const 'Sub' $P1381 = "99_1305640955.436" 
    capture_lex $P1381
    $P10 = rx1373_cur."before"($P1381)
    if $P10, rx1373_fail
  # rx subrule "ws" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."ws"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
    goto alt1378_end
  alt1378_1:
  # rx subrule "ws" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."ws"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."ws"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
  alt1378_end:
  # rx subrule "ws" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."ws"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
.annotate 'line', 636
  # rx pass
    rx1373_cur."!cursor_pass"(rx1373_pos, "statement_control:sym<unless>")
    if_null rx1373_debug, debug_983
    rx1373_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1373_pos)
  debug_983:
    .return (rx1373_cur)
  rx1373_restart:
.annotate 'line', 438
    if_null rx1373_debug, debug_984
    rx1373_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_984:
  rx1373_fail:
    (rx1373_rep, rx1373_pos, $I10, $P10) = rx1373_cur."!mark_fail"(0)
    lt rx1373_pos, -1, rx1373_done
    eq rx1373_pos, -1, rx1373_fail
    jump $I10
  rx1373_done:
    rx1373_cur."!cursor_fail"()
    if_null rx1373_debug, debug_985
    rx1373_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_985:
    .return (rx1373_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1380"  :anon :subid("99_1305640955.436") :method :outer("98_1305640955.436")
.annotate 'line', 639
    .local string rx1382_tgt
    .local int rx1382_pos
    .local int rx1382_off
    .local int rx1382_eos
    .local int rx1382_rep
    .local pmc rx1382_cur
    .local pmc rx1382_debug
    (rx1382_cur, rx1382_pos, rx1382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1382_cur
    .local pmc match
    .lex "$/", match
    length rx1382_eos, rx1382_tgt
    gt rx1382_pos, rx1382_eos, rx1382_done
    set rx1382_off, 0
    lt rx1382_pos, 2, rx1382_start
    sub rx1382_off, rx1382_pos, 1
    substr rx1382_tgt, rx1382_tgt, rx1382_off
  rx1382_start:
    eq $I10, 1, rx1382_restart
    if_null rx1382_debug, debug_979
    rx1382_cur."!cursor_debug"("START", "")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1383_done
    goto rxscan1383_scan
  rxscan1383_loop:
    (rx1382_pos) = rx1382_cur."from"()
    inc rx1382_pos
    rx1382_cur."!cursor_from"(rx1382_pos)
    ge rx1382_pos, rx1382_eos, rxscan1383_done
  rxscan1383_scan:
    set_addr $I10, rxscan1383_loop
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  rxscan1383_done:
  # rx literal  "else"
    add $I11, rx1382_pos, 4
    gt $I11, rx1382_eos, rx1382_fail
    sub $I11, rx1382_pos, rx1382_off
    substr $S10, rx1382_tgt, $I11, 4
    ne $S10, "else", rx1382_fail
    add rx1382_pos, 4
  # rx pass
    rx1382_cur."!cursor_pass"(rx1382_pos, "")
    if_null rx1382_debug, debug_980
    rx1382_cur."!cursor_debug"("PASS", "", " at pos=", rx1382_pos)
  debug_980:
    .return (rx1382_cur)
  rx1382_restart:
    if_null rx1382_debug, debug_981
    rx1382_cur."!cursor_debug"("NEXT", "")
  debug_981:
  rx1382_fail:
    (rx1382_rep, rx1382_pos, $I10, $P10) = rx1382_cur."!mark_fail"(0)
    lt rx1382_pos, -1, rx1382_done
    eq rx1382_pos, -1, rx1382_fail
    jump $I10
  rx1382_done:
    rx1382_cur."!cursor_fail"()
    if_null rx1382_debug, debug_982
    rx1382_cur."!cursor_debug"("FAIL", "")
  debug_982:
    .return (rx1382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("100_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1389, "ResizablePMCArray"
    push $P1389, "unless"
    .return ($P1389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("101_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_986
    rx1391_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1392_done
    goto rxscan1392_scan
  rxscan1392_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1392_done
  rxscan1392_scan:
    set_addr $I10, rxscan1392_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1392_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1394_fail
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  alt1393_0:
    set_addr $I10, alt1393_1
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "while"
    add $I11, rx1391_pos, 5
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    substr $S10, rx1391_tgt, $I11, 5
    ne $S10, "while", rx1391_fail
    add rx1391_pos, 5
    goto alt1393_end
  alt1393_1:
  # rx literal  "until"
    add $I11, rx1391_pos, 5
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    substr $S10, rx1391_tgt, $I11, 5
    ne $S10, "until", rx1391_fail
    add rx1391_pos, 5
  alt1393_end:
    set_addr $I10, rxcap_1394_fail
    ($I12, $I11) = rx1391_cur."!mark_peek"($I10)
    rx1391_cur."!cursor_pos"($I11)
    ($P10) = rx1391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1391_pos, "")
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1394_done
  rxcap_1394_fail:
    goto rx1391_fail
  rxcap_1394_done:
  # rx charclass s
    ge rx1391_pos, rx1391_eos, rx1391_fail
    sub $I10, rx1391_pos, rx1391_off
    is_cclass $I11, 32, rx1391_tgt, $I10
    unless $I11, rx1391_fail
    inc rx1391_pos
  # rx subrule "ws" subtype=method negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."ws"()
    unless $P10, rx1391_fail
    rx1391_pos = $P10."pos"()
.annotate 'line', 644
  # rx subrule "xblock" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."xblock"()
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."ws"()
    unless $P10, rx1391_fail
    rx1391_pos = $P10."pos"()
.annotate 'line', 642
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "statement_control:sym<while>")
    if_null rx1391_debug, debug_987
    rx1391_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1391_pos)
  debug_987:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 438
    if_null rx1391_debug, debug_988
    rx1391_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_988:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_989
    rx1391_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_989:
    .return (rx1391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("102_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1398, "ResizablePMCArray"
    push $P1398, "until"
    push $P1398, "while"
    .return ($P1398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("103_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1400_tgt
    .local int rx1400_pos
    .local int rx1400_off
    .local int rx1400_eos
    .local int rx1400_rep
    .local pmc rx1400_cur
    .local pmc rx1400_debug
    (rx1400_cur, rx1400_pos, rx1400_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1400_cur
    .local pmc match
    .lex "$/", match
    length rx1400_eos, rx1400_tgt
    gt rx1400_pos, rx1400_eos, rx1400_done
    set rx1400_off, 0
    lt rx1400_pos, 2, rx1400_start
    sub rx1400_off, rx1400_pos, 1
    substr rx1400_tgt, rx1400_tgt, rx1400_off
  rx1400_start:
    eq $I10, 1, rx1400_restart
    if_null rx1400_debug, debug_990
    rx1400_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1401_done
    goto rxscan1401_scan
  rxscan1401_loop:
    (rx1400_pos) = rx1400_cur."from"()
    inc rx1400_pos
    rx1400_cur."!cursor_from"(rx1400_pos)
    ge rx1400_pos, rx1400_eos, rxscan1401_done
  rxscan1401_scan:
    set_addr $I10, rxscan1401_loop
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  rxscan1401_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1402_fail
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1400_pos, 6
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    substr $S10, rx1400_tgt, $I11, 6
    ne $S10, "repeat", rx1400_fail
    add rx1400_pos, 6
    set_addr $I10, rxcap_1402_fail
    ($I12, $I11) = rx1400_cur."!mark_peek"($I10)
    rx1400_cur."!cursor_pos"($I11)
    ($P10) = rx1400_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1400_pos, "")
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1402_done
  rxcap_1402_fail:
    goto rx1400_fail
  rxcap_1402_done:
  # rx charclass s
    ge rx1400_pos, rx1400_eos, rx1400_fail
    sub $I10, rx1400_pos, rx1400_off
    is_cclass $I11, 32, rx1400_tgt, $I10
    unless $I11, rx1400_fail
    inc rx1400_pos
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  alt1404_0:
.annotate 'line', 649
    set_addr $I10, alt1404_1
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
.annotate 'line', 650
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1407_fail
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  alt1406_0:
    set_addr $I10, alt1406_1
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  # rx literal  "while"
    add $I11, rx1400_pos, 5
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    substr $S10, rx1400_tgt, $I11, 5
    ne $S10, "while", rx1400_fail
    add rx1400_pos, 5
    goto alt1406_end
  alt1406_1:
  # rx literal  "until"
    add $I11, rx1400_pos, 5
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    substr $S10, rx1400_tgt, $I11, 5
    ne $S10, "until", rx1400_fail
    add rx1400_pos, 5
  alt1406_end:
    set_addr $I10, rxcap_1407_fail
    ($I12, $I11) = rx1400_cur."!mark_peek"($I10)
    rx1400_cur."!cursor_pos"($I11)
    ($P10) = rx1400_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1400_pos, "")
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1407_done
  rxcap_1407_fail:
    goto rx1400_fail
  rxcap_1407_done:
  # rx charclass s
    ge rx1400_pos, rx1400_eos, rx1400_fail
    sub $I10, rx1400_pos, rx1400_off
    is_cclass $I11, 32, rx1400_tgt, $I10
    unless $I11, rx1400_fail
    inc rx1400_pos
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."xblock"()
    unless $P10, rx1400_fail
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1400_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
    goto alt1404_end
  alt1404_1:
.annotate 'line', 651
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."pblock"()
    unless $P10, rx1400_fail
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1400_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1413_fail
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  alt1412_0:
    set_addr $I10, alt1412_1
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  # rx literal  "while"
    add $I11, rx1400_pos, 5
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    substr $S10, rx1400_tgt, $I11, 5
    ne $S10, "while", rx1400_fail
    add rx1400_pos, 5
    goto alt1412_end
  alt1412_1:
  # rx literal  "until"
    add $I11, rx1400_pos, 5
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    substr $S10, rx1400_tgt, $I11, 5
    ne $S10, "until", rx1400_fail
    add rx1400_pos, 5
  alt1412_end:
    set_addr $I10, rxcap_1413_fail
    ($I12, $I11) = rx1400_cur."!mark_peek"($I10)
    rx1400_cur."!cursor_pos"($I11)
    ($P10) = rx1400_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1400_pos, "")
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1413_done
  rxcap_1413_fail:
    goto rx1400_fail
  rxcap_1413_done:
  # rx charclass s
    ge rx1400_pos, rx1400_eos, rx1400_fail
    sub $I10, rx1400_pos, rx1400_off
    is_cclass $I11, 32, rx1400_tgt, $I10
    unless $I11, rx1400_fail
    inc rx1400_pos
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."EXPR"()
    unless $P10, rx1400_fail
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1400_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  alt1404_end:
.annotate 'line', 652
  # rx subrule "ws" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ws"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
.annotate 'line', 647
  # rx pass
    rx1400_cur."!cursor_pass"(rx1400_pos, "statement_control:sym<repeat>")
    if_null rx1400_debug, debug_991
    rx1400_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1400_pos)
  debug_991:
    .return (rx1400_cur)
  rx1400_restart:
.annotate 'line', 438
    if_null rx1400_debug, debug_992
    rx1400_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_992:
  rx1400_fail:
    (rx1400_rep, rx1400_pos, $I10, $P10) = rx1400_cur."!mark_fail"(0)
    lt rx1400_pos, -1, rx1400_done
    eq rx1400_pos, -1, rx1400_fail
    jump $I10
  rx1400_done:
    rx1400_cur."!cursor_fail"()
    if_null rx1400_debug, debug_993
    rx1400_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_993:
    .return (rx1400_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("104_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1418, "ResizablePMCArray"
    push $P1418, "repeat"
    .return ($P1418)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("105_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1420_tgt
    .local int rx1420_pos
    .local int rx1420_off
    .local int rx1420_eos
    .local int rx1420_rep
    .local pmc rx1420_cur
    .local pmc rx1420_debug
    (rx1420_cur, rx1420_pos, rx1420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1420_cur
    .local pmc match
    .lex "$/", match
    length rx1420_eos, rx1420_tgt
    gt rx1420_pos, rx1420_eos, rx1420_done
    set rx1420_off, 0
    lt rx1420_pos, 2, rx1420_start
    sub rx1420_off, rx1420_pos, 1
    substr rx1420_tgt, rx1420_tgt, rx1420_off
  rx1420_start:
    eq $I10, 1, rx1420_restart
    if_null rx1420_debug, debug_994
    rx1420_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1421_done
    goto rxscan1421_scan
  rxscan1421_loop:
    (rx1420_pos) = rx1420_cur."from"()
    inc rx1420_pos
    rx1420_cur."!cursor_from"(rx1420_pos)
    ge rx1420_pos, rx1420_eos, rxscan1421_done
  rxscan1421_scan:
    set_addr $I10, rxscan1421_loop
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  rxscan1421_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1422_fail
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  # rx literal  "for"
    add $I11, rx1420_pos, 3
    gt $I11, rx1420_eos, rx1420_fail
    sub $I11, rx1420_pos, rx1420_off
    substr $S10, rx1420_tgt, $I11, 3
    ne $S10, "for", rx1420_fail
    add rx1420_pos, 3
    set_addr $I10, rxcap_1422_fail
    ($I12, $I11) = rx1420_cur."!mark_peek"($I10)
    rx1420_cur."!cursor_pos"($I11)
    ($P10) = rx1420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1420_pos, "")
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1422_done
  rxcap_1422_fail:
    goto rx1420_fail
  rxcap_1422_done:
  # rx charclass s
    ge rx1420_pos, rx1420_eos, rx1420_fail
    sub $I10, rx1420_pos, rx1420_off
    is_cclass $I11, 32, rx1420_tgt, $I10
    unless $I11, rx1420_fail
    inc rx1420_pos
  # rx subrule "ws" subtype=method negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."ws"()
    unless $P10, rx1420_fail
    rx1420_pos = $P10."pos"()
.annotate 'line', 657
  # rx subrule "xblock" subtype=capture negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."xblock"()
    unless $P10, rx1420_fail
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1420_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."ws"()
    unless $P10, rx1420_fail
    rx1420_pos = $P10."pos"()
.annotate 'line', 655
  # rx pass
    rx1420_cur."!cursor_pass"(rx1420_pos, "statement_control:sym<for>")
    if_null rx1420_debug, debug_995
    rx1420_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1420_pos)
  debug_995:
    .return (rx1420_cur)
  rx1420_restart:
.annotate 'line', 438
    if_null rx1420_debug, debug_996
    rx1420_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_996:
  rx1420_fail:
    (rx1420_rep, rx1420_pos, $I10, $P10) = rx1420_cur."!mark_fail"(0)
    lt rx1420_pos, -1, rx1420_done
    eq rx1420_pos, -1, rx1420_fail
    jump $I10
  rx1420_done:
    rx1420_cur."!cursor_fail"()
    if_null rx1420_debug, debug_997
    rx1420_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_997:
    .return (rx1420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("106_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1426, "ResizablePMCArray"
    push $P1426, "for"
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("107_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1428_tgt
    .local int rx1428_pos
    .local int rx1428_off
    .local int rx1428_eos
    .local int rx1428_rep
    .local pmc rx1428_cur
    .local pmc rx1428_debug
    (rx1428_cur, rx1428_pos, rx1428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1428_cur
    .local pmc match
    .lex "$/", match
    length rx1428_eos, rx1428_tgt
    gt rx1428_pos, rx1428_eos, rx1428_done
    set rx1428_off, 0
    lt rx1428_pos, 2, rx1428_start
    sub rx1428_off, rx1428_pos, 1
    substr rx1428_tgt, rx1428_tgt, rx1428_off
  rx1428_start:
    eq $I10, 1, rx1428_restart
    if_null rx1428_debug, debug_998
    rx1428_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1429_done
    goto rxscan1429_scan
  rxscan1429_loop:
    (rx1428_pos) = rx1428_cur."from"()
    inc rx1428_pos
    rx1428_cur."!cursor_from"(rx1428_pos)
    ge rx1428_pos, rx1428_eos, rxscan1429_done
  rxscan1429_scan:
    set_addr $I10, rxscan1429_loop
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxscan1429_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1430_fail
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1428_pos, 5
    gt $I11, rx1428_eos, rx1428_fail
    sub $I11, rx1428_pos, rx1428_off
    substr $S10, rx1428_tgt, $I11, 5
    ne $S10, "CATCH", rx1428_fail
    add rx1428_pos, 5
    set_addr $I10, rxcap_1430_fail
    ($I12, $I11) = rx1428_cur."!mark_peek"($I10)
    rx1428_cur."!cursor_pos"($I11)
    ($P10) = rx1428_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1428_pos, "")
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1430_done
  rxcap_1430_fail:
    goto rx1428_fail
  rxcap_1430_done:
  # rx charclass s
    ge rx1428_pos, rx1428_eos, rx1428_fail
    sub $I10, rx1428_pos, rx1428_off
    is_cclass $I11, 32, rx1428_tgt, $I10
    unless $I11, rx1428_fail
    inc rx1428_pos
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
.annotate 'line', 662
  # rx subrule "block" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."block"()
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1428_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
.annotate 'line', 660
  # rx pass
    rx1428_cur."!cursor_pass"(rx1428_pos, "statement_control:sym<CATCH>")
    if_null rx1428_debug, debug_999
    rx1428_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1428_pos)
  debug_999:
    .return (rx1428_cur)
  rx1428_restart:
.annotate 'line', 438
    if_null rx1428_debug, debug_1000
    rx1428_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_1000:
  rx1428_fail:
    (rx1428_rep, rx1428_pos, $I10, $P10) = rx1428_cur."!mark_fail"(0)
    lt rx1428_pos, -1, rx1428_done
    eq rx1428_pos, -1, rx1428_fail
    jump $I10
  rx1428_done:
    rx1428_cur."!cursor_fail"()
    if_null rx1428_debug, debug_1001
    rx1428_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_1001:
    .return (rx1428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("108_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1434, "ResizablePMCArray"
    push $P1434, "CATCH"
    .return ($P1434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("109_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1436_tgt
    .local int rx1436_pos
    .local int rx1436_off
    .local int rx1436_eos
    .local int rx1436_rep
    .local pmc rx1436_cur
    .local pmc rx1436_debug
    (rx1436_cur, rx1436_pos, rx1436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1436_cur
    .local pmc match
    .lex "$/", match
    length rx1436_eos, rx1436_tgt
    gt rx1436_pos, rx1436_eos, rx1436_done
    set rx1436_off, 0
    lt rx1436_pos, 2, rx1436_start
    sub rx1436_off, rx1436_pos, 1
    substr rx1436_tgt, rx1436_tgt, rx1436_off
  rx1436_start:
    eq $I10, 1, rx1436_restart
    if_null rx1436_debug, debug_1002
    rx1436_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1437_done
    goto rxscan1437_scan
  rxscan1437_loop:
    (rx1436_pos) = rx1436_cur."from"()
    inc rx1436_pos
    rx1436_cur."!cursor_from"(rx1436_pos)
    ge rx1436_pos, rx1436_eos, rxscan1437_done
  rxscan1437_scan:
    set_addr $I10, rxscan1437_loop
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  rxscan1437_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1438_fail
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1436_pos, 7
    gt $I11, rx1436_eos, rx1436_fail
    sub $I11, rx1436_pos, rx1436_off
    substr $S10, rx1436_tgt, $I11, 7
    ne $S10, "CONTROL", rx1436_fail
    add rx1436_pos, 7
    set_addr $I10, rxcap_1438_fail
    ($I12, $I11) = rx1436_cur."!mark_peek"($I10)
    rx1436_cur."!cursor_pos"($I11)
    ($P10) = rx1436_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1436_pos, "")
    rx1436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1438_done
  rxcap_1438_fail:
    goto rx1436_fail
  rxcap_1438_done:
  # rx charclass s
    ge rx1436_pos, rx1436_eos, rx1436_fail
    sub $I10, rx1436_pos, rx1436_off
    is_cclass $I11, 32, rx1436_tgt, $I10
    unless $I11, rx1436_fail
    inc rx1436_pos
  # rx subrule "ws" subtype=method negate=
    rx1436_cur."!cursor_pos"(rx1436_pos)
    $P10 = rx1436_cur."ws"()
    unless $P10, rx1436_fail
    rx1436_pos = $P10."pos"()
.annotate 'line', 667
  # rx subrule "block" subtype=capture negate=
    rx1436_cur."!cursor_pos"(rx1436_pos)
    $P10 = rx1436_cur."block"()
    unless $P10, rx1436_fail
    rx1436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1436_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1436_cur."!cursor_pos"(rx1436_pos)
    $P10 = rx1436_cur."ws"()
    unless $P10, rx1436_fail
    rx1436_pos = $P10."pos"()
.annotate 'line', 665
  # rx pass
    rx1436_cur."!cursor_pass"(rx1436_pos, "statement_control:sym<CONTROL>")
    if_null rx1436_debug, debug_1003
    rx1436_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1436_pos)
  debug_1003:
    .return (rx1436_cur)
  rx1436_restart:
.annotate 'line', 438
    if_null rx1436_debug, debug_1004
    rx1436_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_1004:
  rx1436_fail:
    (rx1436_rep, rx1436_pos, $I10, $P10) = rx1436_cur."!mark_fail"(0)
    lt rx1436_pos, -1, rx1436_done
    eq rx1436_pos, -1, rx1436_fail
    jump $I10
  rx1436_done:
    rx1436_cur."!cursor_fail"()
    if_null rx1436_debug, debug_1005
    rx1436_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_1005:
    .return (rx1436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("110_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1442, "ResizablePMCArray"
    push $P1442, "CONTROL"
    .return ($P1442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("111_1305640955.436")
    .param pmc param_1444
.annotate 'line', 670
    .lex "self", param_1444
    $P1445 = param_1444."!protoregex"("statement_prefix")
    .return ($P1445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("112_1305640955.436")
    .param pmc param_1447
.annotate 'line', 670
    .lex "self", param_1447
    $P1448 = param_1447."!PREFIX__!protoregex"("statement_prefix")
    .return ($P1448)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("113_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1450_tgt
    .local int rx1450_pos
    .local int rx1450_off
    .local int rx1450_eos
    .local int rx1450_rep
    .local pmc rx1450_cur
    .local pmc rx1450_debug
    (rx1450_cur, rx1450_pos, rx1450_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1450_cur
    .local pmc match
    .lex "$/", match
    length rx1450_eos, rx1450_tgt
    gt rx1450_pos, rx1450_eos, rx1450_done
    set rx1450_off, 0
    lt rx1450_pos, 2, rx1450_start
    sub rx1450_off, rx1450_pos, 1
    substr rx1450_tgt, rx1450_tgt, rx1450_off
  rx1450_start:
    eq $I10, 1, rx1450_restart
    if_null rx1450_debug, debug_1006
    rx1450_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_1006:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1451_done
    goto rxscan1451_scan
  rxscan1451_loop:
    (rx1450_pos) = rx1450_cur."from"()
    inc rx1450_pos
    rx1450_cur."!cursor_from"(rx1450_pos)
    ge rx1450_pos, rx1450_eos, rxscan1451_done
  rxscan1451_scan:
    set_addr $I10, rxscan1451_loop
    rx1450_cur."!mark_push"(0, rx1450_pos, $I10)
  rxscan1451_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1452_fail
    rx1450_cur."!mark_push"(0, rx1450_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1450_pos, 4
    gt $I11, rx1450_eos, rx1450_fail
    sub $I11, rx1450_pos, rx1450_off
    substr $S10, rx1450_tgt, $I11, 4
    ne $S10, "INIT", rx1450_fail
    add rx1450_pos, 4
    set_addr $I10, rxcap_1452_fail
    ($I12, $I11) = rx1450_cur."!mark_peek"($I10)
    rx1450_cur."!cursor_pos"($I11)
    ($P10) = rx1450_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1450_pos, "")
    rx1450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1452_done
  rxcap_1452_fail:
    goto rx1450_fail
  rxcap_1452_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1450_cur."!cursor_pos"(rx1450_pos)
    $P10 = rx1450_cur."blorst"()
    unless $P10, rx1450_fail
    rx1450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1450_pos = $P10."pos"()
  # rx pass
    rx1450_cur."!cursor_pass"(rx1450_pos, "statement_prefix:sym<INIT>")
    if_null rx1450_debug, debug_1007
    rx1450_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1450_pos)
  debug_1007:
    .return (rx1450_cur)
  rx1450_restart:
.annotate 'line', 438
    if_null rx1450_debug, debug_1008
    rx1450_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_1008:
  rx1450_fail:
    (rx1450_rep, rx1450_pos, $I10, $P10) = rx1450_cur."!mark_fail"(0)
    lt rx1450_pos, -1, rx1450_done
    eq rx1450_pos, -1, rx1450_fail
    jump $I10
  rx1450_done:
    rx1450_cur."!cursor_fail"()
    if_null rx1450_debug, debug_1009
    rx1450_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_1009:
    .return (rx1450_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("114_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1454 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P1455, "ResizablePMCArray"
    push $P1455, $P1454
    .return ($P1455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("115_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1457_tgt
    .local int rx1457_pos
    .local int rx1457_off
    .local int rx1457_eos
    .local int rx1457_rep
    .local pmc rx1457_cur
    .local pmc rx1457_debug
    (rx1457_cur, rx1457_pos, rx1457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1457_cur
    .local pmc match
    .lex "$/", match
    length rx1457_eos, rx1457_tgt
    gt rx1457_pos, rx1457_eos, rx1457_done
    set rx1457_off, 0
    lt rx1457_pos, 2, rx1457_start
    sub rx1457_off, rx1457_pos, 1
    substr rx1457_tgt, rx1457_tgt, rx1457_off
  rx1457_start:
    eq $I10, 1, rx1457_restart
    if_null rx1457_debug, debug_1010
    rx1457_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_1010:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1457_pos) = rx1457_cur."from"()
    inc rx1457_pos
    rx1457_cur."!cursor_from"(rx1457_pos)
    ge rx1457_pos, rx1457_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1457_cur."!mark_push"(0, rx1457_pos, $I10)
  rxscan1458_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1457_cur."!mark_push"(0, rx1457_pos, $I10)
  # rx literal  "try"
    add $I11, rx1457_pos, 3
    gt $I11, rx1457_eos, rx1457_fail
    sub $I11, rx1457_pos, rx1457_off
    substr $S10, rx1457_tgt, $I11, 3
    ne $S10, "try", rx1457_fail
    add rx1457_pos, 3
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1457_cur."!mark_peek"($I10)
    rx1457_cur."!cursor_pos"($I11)
    ($P10) = rx1457_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1457_pos, "")
    rx1457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1457_fail
  rxcap_1459_done:
.annotate 'line', 675
  # rx subrule "blorst" subtype=capture negate=
    rx1457_cur."!cursor_pos"(rx1457_pos)
    $P10 = rx1457_cur."blorst"()
    unless $P10, rx1457_fail
    rx1457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1457_pos = $P10."pos"()
.annotate 'line', 673
  # rx pass
    rx1457_cur."!cursor_pass"(rx1457_pos, "statement_prefix:sym<try>")
    if_null rx1457_debug, debug_1011
    rx1457_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1457_pos)
  debug_1011:
    .return (rx1457_cur)
  rx1457_restart:
.annotate 'line', 438
    if_null rx1457_debug, debug_1012
    rx1457_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_1012:
  rx1457_fail:
    (rx1457_rep, rx1457_pos, $I10, $P10) = rx1457_cur."!mark_fail"(0)
    lt rx1457_pos, -1, rx1457_done
    eq rx1457_pos, -1, rx1457_fail
    jump $I10
  rx1457_done:
    rx1457_cur."!cursor_fail"()
    if_null rx1457_debug, debug_1013
    rx1457_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_1013:
    .return (rx1457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("116_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1461 = self."!PREFIX__!subrule"("blorst", "try")
    new $P1462, "ResizablePMCArray"
    push $P1462, $P1461
    .return ($P1462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("117_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1464_tgt
    .local int rx1464_pos
    .local int rx1464_off
    .local int rx1464_eos
    .local int rx1464_rep
    .local pmc rx1464_cur
    .local pmc rx1464_debug
    (rx1464_cur, rx1464_pos, rx1464_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1464_cur
    .local pmc match
    .lex "$/", match
    length rx1464_eos, rx1464_tgt
    gt rx1464_pos, rx1464_eos, rx1464_done
    set rx1464_off, 0
    lt rx1464_pos, 2, rx1464_start
    sub rx1464_off, rx1464_pos, 1
    substr rx1464_tgt, rx1464_tgt, rx1464_off
  rx1464_start:
    eq $I10, 1, rx1464_restart
    if_null rx1464_debug, debug_1014
    rx1464_cur."!cursor_debug"("START", "blorst")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1464_pos) = rx1464_cur."from"()
    inc rx1464_pos
    rx1464_cur."!cursor_from"(rx1464_pos)
    ge rx1464_pos, rx1464_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1464_cur."!mark_push"(0, rx1464_pos, $I10)
  rxscan1465_done:
.annotate 'line', 679
  # rx charclass s
    ge rx1464_pos, rx1464_eos, rx1464_fail
    sub $I10, rx1464_pos, rx1464_off
    is_cclass $I11, 32, rx1464_tgt, $I10
    unless $I11, rx1464_fail
    inc rx1464_pos
  # rx subrule "ws" subtype=method negate=
    rx1464_cur."!cursor_pos"(rx1464_pos)
    $P10 = rx1464_cur."ws"()
    unless $P10, rx1464_fail
    rx1464_pos = $P10."pos"()
  alt1466_0:
    set_addr $I10, alt1466_1
    rx1464_cur."!mark_push"(0, rx1464_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1464_pos, rx1464_off
    substr $S10, rx1464_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1464_fail
  # rx subrule "block" subtype=capture negate=
    rx1464_cur."!cursor_pos"(rx1464_pos)
    $P10 = rx1464_cur."block"()
    unless $P10, rx1464_fail
    rx1464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1464_pos = $P10."pos"()
    goto alt1466_end
  alt1466_1:
  # rx subrule "statement" subtype=capture negate=
    rx1464_cur."!cursor_pos"(rx1464_pos)
    $P10 = rx1464_cur."statement"()
    unless $P10, rx1464_fail
    rx1464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1464_pos = $P10."pos"()
  alt1466_end:
.annotate 'line', 678
  # rx pass
    rx1464_cur."!cursor_pass"(rx1464_pos, "blorst")
    if_null rx1464_debug, debug_1015
    rx1464_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1464_pos)
  debug_1015:
    .return (rx1464_cur)
  rx1464_restart:
.annotate 'line', 438
    if_null rx1464_debug, debug_1016
    rx1464_cur."!cursor_debug"("NEXT", "blorst")
  debug_1016:
  rx1464_fail:
    (rx1464_rep, rx1464_pos, $I10, $P10) = rx1464_cur."!mark_fail"(0)
    lt rx1464_pos, -1, rx1464_done
    eq rx1464_pos, -1, rx1464_fail
    jump $I10
  rx1464_done:
    rx1464_cur."!cursor_fail"()
    if_null rx1464_debug, debug_1017
    rx1464_cur."!cursor_debug"("FAIL", "blorst")
  debug_1017:
    .return (rx1464_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("118_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1468, "ResizablePMCArray"
    push $P1468, ""
    .return ($P1468)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("119_1305640955.436")
    .param pmc param_1470
.annotate 'line', 684
    .lex "self", param_1470
    $P1471 = param_1470."!protoregex"("statement_mod_cond")
    .return ($P1471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("120_1305640955.436")
    .param pmc param_1473
.annotate 'line', 684
    .lex "self", param_1473
    $P1474 = param_1473."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P1474)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("121_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1476_tgt
    .local int rx1476_pos
    .local int rx1476_off
    .local int rx1476_eos
    .local int rx1476_rep
    .local pmc rx1476_cur
    .local pmc rx1476_debug
    (rx1476_cur, rx1476_pos, rx1476_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1476_cur
    .local pmc match
    .lex "$/", match
    length rx1476_eos, rx1476_tgt
    gt rx1476_pos, rx1476_eos, rx1476_done
    set rx1476_off, 0
    lt rx1476_pos, 2, rx1476_start
    sub rx1476_off, rx1476_pos, 1
    substr rx1476_tgt, rx1476_tgt, rx1476_off
  rx1476_start:
    eq $I10, 1, rx1476_restart
    if_null rx1476_debug, debug_1018
    rx1476_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1477_done
    goto rxscan1477_scan
  rxscan1477_loop:
    (rx1476_pos) = rx1476_cur."from"()
    inc rx1476_pos
    rx1476_cur."!cursor_from"(rx1476_pos)
    ge rx1476_pos, rx1476_eos, rxscan1477_done
  rxscan1477_scan:
    set_addr $I10, rxscan1477_loop
    rx1476_cur."!mark_push"(0, rx1476_pos, $I10)
  rxscan1477_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1478_fail
    rx1476_cur."!mark_push"(0, rx1476_pos, $I10)
  # rx literal  "if"
    add $I11, rx1476_pos, 2
    gt $I11, rx1476_eos, rx1476_fail
    sub $I11, rx1476_pos, rx1476_off
    substr $S10, rx1476_tgt, $I11, 2
    ne $S10, "if", rx1476_fail
    add rx1476_pos, 2
    set_addr $I10, rxcap_1478_fail
    ($I12, $I11) = rx1476_cur."!mark_peek"($I10)
    rx1476_cur."!cursor_pos"($I11)
    ($P10) = rx1476_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1476_pos, "")
    rx1476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1478_done
  rxcap_1478_fail:
    goto rx1476_fail
  rxcap_1478_done:
  # rx subrule "ws" subtype=method negate=
    rx1476_cur."!cursor_pos"(rx1476_pos)
    $P10 = rx1476_cur."ws"()
    unless $P10, rx1476_fail
    rx1476_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1476_cur."!cursor_pos"(rx1476_pos)
    $P10 = rx1476_cur."EXPR"()
    unless $P10, rx1476_fail
    rx1476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1476_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1476_cur."!cursor_pos"(rx1476_pos)
    $P10 = rx1476_cur."ws"()
    unless $P10, rx1476_fail
    rx1476_pos = $P10."pos"()
  # rx pass
    rx1476_cur."!cursor_pass"(rx1476_pos, "statement_mod_cond:sym<if>")
    if_null rx1476_debug, debug_1019
    rx1476_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1476_pos)
  debug_1019:
    .return (rx1476_cur)
  rx1476_restart:
.annotate 'line', 438
    if_null rx1476_debug, debug_1020
    rx1476_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1020:
  rx1476_fail:
    (rx1476_rep, rx1476_pos, $I10, $P10) = rx1476_cur."!mark_fail"(0)
    lt rx1476_pos, -1, rx1476_done
    eq rx1476_pos, -1, rx1476_fail
    jump $I10
  rx1476_done:
    rx1476_cur."!cursor_fail"()
    if_null rx1476_debug, debug_1021
    rx1476_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1021:
    .return (rx1476_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("122_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1482 = self."!PREFIX__!subrule"("ws", "if")
    new $P1483, "ResizablePMCArray"
    push $P1483, $P1482
    .return ($P1483)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("123_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1485_tgt
    .local int rx1485_pos
    .local int rx1485_off
    .local int rx1485_eos
    .local int rx1485_rep
    .local pmc rx1485_cur
    .local pmc rx1485_debug
    (rx1485_cur, rx1485_pos, rx1485_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1485_cur
    .local pmc match
    .lex "$/", match
    length rx1485_eos, rx1485_tgt
    gt rx1485_pos, rx1485_eos, rx1485_done
    set rx1485_off, 0
    lt rx1485_pos, 2, rx1485_start
    sub rx1485_off, rx1485_pos, 1
    substr rx1485_tgt, rx1485_tgt, rx1485_off
  rx1485_start:
    eq $I10, 1, rx1485_restart
    if_null rx1485_debug, debug_1022
    rx1485_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1022:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1485_pos) = rx1485_cur."from"()
    inc rx1485_pos
    rx1485_cur."!cursor_from"(rx1485_pos)
    ge rx1485_pos, rx1485_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  rxscan1486_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1487_fail
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1485_pos, 6
    gt $I11, rx1485_eos, rx1485_fail
    sub $I11, rx1485_pos, rx1485_off
    substr $S10, rx1485_tgt, $I11, 6
    ne $S10, "unless", rx1485_fail
    add rx1485_pos, 6
    set_addr $I10, rxcap_1487_fail
    ($I12, $I11) = rx1485_cur."!mark_peek"($I10)
    rx1485_cur."!cursor_pos"($I11)
    ($P10) = rx1485_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1485_pos, "")
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1487_done
  rxcap_1487_fail:
    goto rx1485_fail
  rxcap_1487_done:
  # rx subrule "ws" subtype=method negate=
    rx1485_cur."!cursor_pos"(rx1485_pos)
    $P10 = rx1485_cur."ws"()
    unless $P10, rx1485_fail
    rx1485_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1485_cur."!cursor_pos"(rx1485_pos)
    $P10 = rx1485_cur."EXPR"()
    unless $P10, rx1485_fail
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1485_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1485_cur."!cursor_pos"(rx1485_pos)
    $P10 = rx1485_cur."ws"()
    unless $P10, rx1485_fail
    rx1485_pos = $P10."pos"()
  # rx pass
    rx1485_cur."!cursor_pass"(rx1485_pos, "statement_mod_cond:sym<unless>")
    if_null rx1485_debug, debug_1023
    rx1485_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1485_pos)
  debug_1023:
    .return (rx1485_cur)
  rx1485_restart:
.annotate 'line', 438
    if_null rx1485_debug, debug_1024
    rx1485_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1024:
  rx1485_fail:
    (rx1485_rep, rx1485_pos, $I10, $P10) = rx1485_cur."!mark_fail"(0)
    lt rx1485_pos, -1, rx1485_done
    eq rx1485_pos, -1, rx1485_fail
    jump $I10
  rx1485_done:
    rx1485_cur."!cursor_fail"()
    if_null rx1485_debug, debug_1025
    rx1485_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1025:
    .return (rx1485_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("124_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1491 = self."!PREFIX__!subrule"("ws", "unless")
    new $P1492, "ResizablePMCArray"
    push $P1492, $P1491
    .return ($P1492)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("125_1305640955.436")
    .param pmc param_1494
.annotate 'line', 689
    .lex "self", param_1494
    $P1495 = param_1494."!protoregex"("statement_mod_loop")
    .return ($P1495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("126_1305640955.436")
    .param pmc param_1497
.annotate 'line', 689
    .lex "self", param_1497
    $P1498 = param_1497."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P1498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("127_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1026
    rx1500_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1026:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1501_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1502_fail
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  # rx literal  "while"
    add $I11, rx1500_pos, 5
    gt $I11, rx1500_eos, rx1500_fail
    sub $I11, rx1500_pos, rx1500_off
    substr $S10, rx1500_tgt, $I11, 5
    ne $S10, "while", rx1500_fail
    add rx1500_pos, 5
    set_addr $I10, rxcap_1502_fail
    ($I12, $I11) = rx1500_cur."!mark_peek"($I10)
    rx1500_cur."!cursor_pos"($I11)
    ($P10) = rx1500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1500_pos, "")
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1502_done
  rxcap_1502_fail:
    goto rx1500_fail
  rxcap_1502_done:
  # rx subrule "ws" subtype=method negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."ws"()
    unless $P10, rx1500_fail
    rx1500_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."EXPR"()
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1500_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."ws"()
    unless $P10, rx1500_fail
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "statement_mod_loop:sym<while>")
    if_null rx1500_debug, debug_1027
    rx1500_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1500_pos)
  debug_1027:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 438
    if_null rx1500_debug, debug_1028
    rx1500_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1028:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1029
    rx1500_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1029:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("128_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1506 = self."!PREFIX__!subrule"("ws", "while")
    new $P1507, "ResizablePMCArray"
    push $P1507, $P1506
    .return ($P1507)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("129_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1509_tgt
    .local int rx1509_pos
    .local int rx1509_off
    .local int rx1509_eos
    .local int rx1509_rep
    .local pmc rx1509_cur
    .local pmc rx1509_debug
    (rx1509_cur, rx1509_pos, rx1509_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1509_cur
    .local pmc match
    .lex "$/", match
    length rx1509_eos, rx1509_tgt
    gt rx1509_pos, rx1509_eos, rx1509_done
    set rx1509_off, 0
    lt rx1509_pos, 2, rx1509_start
    sub rx1509_off, rx1509_pos, 1
    substr rx1509_tgt, rx1509_tgt, rx1509_off
  rx1509_start:
    eq $I10, 1, rx1509_restart
    if_null rx1509_debug, debug_1030
    rx1509_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1030:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1510_done
    goto rxscan1510_scan
  rxscan1510_loop:
    (rx1509_pos) = rx1509_cur."from"()
    inc rx1509_pos
    rx1509_cur."!cursor_from"(rx1509_pos)
    ge rx1509_pos, rx1509_eos, rxscan1510_done
  rxscan1510_scan:
    set_addr $I10, rxscan1510_loop
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  rxscan1510_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1511_fail
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  # rx literal  "until"
    add $I11, rx1509_pos, 5
    gt $I11, rx1509_eos, rx1509_fail
    sub $I11, rx1509_pos, rx1509_off
    substr $S10, rx1509_tgt, $I11, 5
    ne $S10, "until", rx1509_fail
    add rx1509_pos, 5
    set_addr $I10, rxcap_1511_fail
    ($I12, $I11) = rx1509_cur."!mark_peek"($I10)
    rx1509_cur."!cursor_pos"($I11)
    ($P10) = rx1509_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1509_pos, "")
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1511_done
  rxcap_1511_fail:
    goto rx1509_fail
  rxcap_1511_done:
  # rx subrule "ws" subtype=method negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."ws"()
    unless $P10, rx1509_fail
    rx1509_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."EXPR"()
    unless $P10, rx1509_fail
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1509_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."ws"()
    unless $P10, rx1509_fail
    rx1509_pos = $P10."pos"()
  # rx pass
    rx1509_cur."!cursor_pass"(rx1509_pos, "statement_mod_loop:sym<until>")
    if_null rx1509_debug, debug_1031
    rx1509_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1509_pos)
  debug_1031:
    .return (rx1509_cur)
  rx1509_restart:
.annotate 'line', 438
    if_null rx1509_debug, debug_1032
    rx1509_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1032:
  rx1509_fail:
    (rx1509_rep, rx1509_pos, $I10, $P10) = rx1509_cur."!mark_fail"(0)
    lt rx1509_pos, -1, rx1509_done
    eq rx1509_pos, -1, rx1509_fail
    jump $I10
  rx1509_done:
    rx1509_cur."!cursor_fail"()
    if_null rx1509_debug, debug_1033
    rx1509_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1033:
    .return (rx1509_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("130_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1515 = self."!PREFIX__!subrule"("ws", "until")
    new $P1516, "ResizablePMCArray"
    push $P1516, $P1515
    .return ($P1516)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("131_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1518_tgt
    .local int rx1518_pos
    .local int rx1518_off
    .local int rx1518_eos
    .local int rx1518_rep
    .local pmc rx1518_cur
    .local pmc rx1518_debug
    (rx1518_cur, rx1518_pos, rx1518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1518_cur
    .local pmc match
    .lex "$/", match
    length rx1518_eos, rx1518_tgt
    gt rx1518_pos, rx1518_eos, rx1518_done
    set rx1518_off, 0
    lt rx1518_pos, 2, rx1518_start
    sub rx1518_off, rx1518_pos, 1
    substr rx1518_tgt, rx1518_tgt, rx1518_off
  rx1518_start:
    eq $I10, 1, rx1518_restart
    if_null rx1518_debug, debug_1034
    rx1518_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1034:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1519_done
    goto rxscan1519_scan
  rxscan1519_loop:
    (rx1518_pos) = rx1518_cur."from"()
    inc rx1518_pos
    rx1518_cur."!cursor_from"(rx1518_pos)
    ge rx1518_pos, rx1518_eos, rxscan1519_done
  rxscan1519_scan:
    set_addr $I10, rxscan1519_loop
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  rxscan1519_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1520_fail
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  # rx literal  "for"
    add $I11, rx1518_pos, 3
    gt $I11, rx1518_eos, rx1518_fail
    sub $I11, rx1518_pos, rx1518_off
    substr $S10, rx1518_tgt, $I11, 3
    ne $S10, "for", rx1518_fail
    add rx1518_pos, 3
    set_addr $I10, rxcap_1520_fail
    ($I12, $I11) = rx1518_cur."!mark_peek"($I10)
    rx1518_cur."!cursor_pos"($I11)
    ($P10) = rx1518_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1518_pos, "")
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1520_done
  rxcap_1520_fail:
    goto rx1518_fail
  rxcap_1520_done:
  # rx subrule "ws" subtype=method negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."ws"()
    unless $P10, rx1518_fail
    rx1518_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."EXPR"()
    unless $P10, rx1518_fail
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1518_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."ws"()
    unless $P10, rx1518_fail
    rx1518_pos = $P10."pos"()
  # rx pass
    rx1518_cur."!cursor_pass"(rx1518_pos, "statement_mod_loop:sym<for>")
    if_null rx1518_debug, debug_1035
    rx1518_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1518_pos)
  debug_1035:
    .return (rx1518_cur)
  rx1518_restart:
.annotate 'line', 438
    if_null rx1518_debug, debug_1036
    rx1518_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1036:
  rx1518_fail:
    (rx1518_rep, rx1518_pos, $I10, $P10) = rx1518_cur."!mark_fail"(0)
    lt rx1518_pos, -1, rx1518_done
    eq rx1518_pos, -1, rx1518_fail
    jump $I10
  rx1518_done:
    rx1518_cur."!cursor_fail"()
    if_null rx1518_debug, debug_1037
    rx1518_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1037:
    .return (rx1518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("132_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1524 = self."!PREFIX__!subrule"("ws", "for")
    new $P1525, "ResizablePMCArray"
    push $P1525, $P1524
    .return ($P1525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("133_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1527_tgt
    .local int rx1527_pos
    .local int rx1527_off
    .local int rx1527_eos
    .local int rx1527_rep
    .local pmc rx1527_cur
    .local pmc rx1527_debug
    (rx1527_cur, rx1527_pos, rx1527_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1527_cur
    .local pmc match
    .lex "$/", match
    length rx1527_eos, rx1527_tgt
    gt rx1527_pos, rx1527_eos, rx1527_done
    set rx1527_off, 0
    lt rx1527_pos, 2, rx1527_start
    sub rx1527_off, rx1527_pos, 1
    substr rx1527_tgt, rx1527_tgt, rx1527_off
  rx1527_start:
    eq $I10, 1, rx1527_restart
    if_null rx1527_debug, debug_1038
    rx1527_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1528_done
    goto rxscan1528_scan
  rxscan1528_loop:
    (rx1527_pos) = rx1527_cur."from"()
    inc rx1527_pos
    rx1527_cur."!cursor_from"(rx1527_pos)
    ge rx1527_pos, rx1527_eos, rxscan1528_done
  rxscan1528_scan:
    set_addr $I10, rxscan1528_loop
    rx1527_cur."!mark_push"(0, rx1527_pos, $I10)
  rxscan1528_done:
.annotate 'line', 697
  # rx subrule "fatarrow" subtype=capture negate=
    rx1527_cur."!cursor_pos"(rx1527_pos)
    $P10 = rx1527_cur."fatarrow"()
    unless $P10, rx1527_fail
    rx1527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1527_pos = $P10."pos"()
  # rx pass
    rx1527_cur."!cursor_pass"(rx1527_pos, "term:sym<fatarrow>")
    if_null rx1527_debug, debug_1039
    rx1527_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1527_pos)
  debug_1039:
    .return (rx1527_cur)
  rx1527_restart:
.annotate 'line', 438
    if_null rx1527_debug, debug_1040
    rx1527_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1040:
  rx1527_fail:
    (rx1527_rep, rx1527_pos, $I10, $P10) = rx1527_cur."!mark_fail"(0)
    lt rx1527_pos, -1, rx1527_done
    eq rx1527_pos, -1, rx1527_fail
    jump $I10
  rx1527_done:
    rx1527_cur."!cursor_fail"()
    if_null rx1527_debug, debug_1041
    rx1527_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1041:
    .return (rx1527_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("134_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1530 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P1531, "ResizablePMCArray"
    push $P1531, $P1530
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("135_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1533_tgt
    .local int rx1533_pos
    .local int rx1533_off
    .local int rx1533_eos
    .local int rx1533_rep
    .local pmc rx1533_cur
    .local pmc rx1533_debug
    (rx1533_cur, rx1533_pos, rx1533_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1533_cur
    .local pmc match
    .lex "$/", match
    length rx1533_eos, rx1533_tgt
    gt rx1533_pos, rx1533_eos, rx1533_done
    set rx1533_off, 0
    lt rx1533_pos, 2, rx1533_start
    sub rx1533_off, rx1533_pos, 1
    substr rx1533_tgt, rx1533_tgt, rx1533_off
  rx1533_start:
    eq $I10, 1, rx1533_restart
    if_null rx1533_debug, debug_1042
    rx1533_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1534_done
    goto rxscan1534_scan
  rxscan1534_loop:
    (rx1533_pos) = rx1533_cur."from"()
    inc rx1533_pos
    rx1533_cur."!cursor_from"(rx1533_pos)
    ge rx1533_pos, rx1533_eos, rxscan1534_done
  rxscan1534_scan:
    set_addr $I10, rxscan1534_loop
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxscan1534_done:
.annotate 'line', 698
  # rx subrule "colonpair" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."colonpair"()
    unless $P10, rx1533_fail
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1533_pos = $P10."pos"()
  # rx pass
    rx1533_cur."!cursor_pass"(rx1533_pos, "term:sym<colonpair>")
    if_null rx1533_debug, debug_1043
    rx1533_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1533_pos)
  debug_1043:
    .return (rx1533_cur)
  rx1533_restart:
.annotate 'line', 438
    if_null rx1533_debug, debug_1044
    rx1533_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1044:
  rx1533_fail:
    (rx1533_rep, rx1533_pos, $I10, $P10) = rx1533_cur."!mark_fail"(0)
    lt rx1533_pos, -1, rx1533_done
    eq rx1533_pos, -1, rx1533_fail
    jump $I10
  rx1533_done:
    rx1533_cur."!cursor_fail"()
    if_null rx1533_debug, debug_1045
    rx1533_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1045:
    .return (rx1533_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("136_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1536 = self."!PREFIX__!subrule"("colonpair", "")
    new $P1537, "ResizablePMCArray"
    push $P1537, $P1536
    .return ($P1537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("137_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1539_tgt
    .local int rx1539_pos
    .local int rx1539_off
    .local int rx1539_eos
    .local int rx1539_rep
    .local pmc rx1539_cur
    .local pmc rx1539_debug
    (rx1539_cur, rx1539_pos, rx1539_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1539_cur
    .local pmc match
    .lex "$/", match
    length rx1539_eos, rx1539_tgt
    gt rx1539_pos, rx1539_eos, rx1539_done
    set rx1539_off, 0
    lt rx1539_pos, 2, rx1539_start
    sub rx1539_off, rx1539_pos, 1
    substr rx1539_tgt, rx1539_tgt, rx1539_off
  rx1539_start:
    eq $I10, 1, rx1539_restart
    if_null rx1539_debug, debug_1046
    rx1539_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1540_done
    goto rxscan1540_scan
  rxscan1540_loop:
    (rx1539_pos) = rx1539_cur."from"()
    inc rx1539_pos
    rx1539_cur."!cursor_from"(rx1539_pos)
    ge rx1539_pos, rx1539_eos, rxscan1540_done
  rxscan1540_scan:
    set_addr $I10, rxscan1540_loop
    rx1539_cur."!mark_push"(0, rx1539_pos, $I10)
  rxscan1540_done:
.annotate 'line', 699
  # rx subrule "variable" subtype=capture negate=
    rx1539_cur."!cursor_pos"(rx1539_pos)
    $P10 = rx1539_cur."variable"()
    unless $P10, rx1539_fail
    rx1539_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1539_pos = $P10."pos"()
  # rx pass
    rx1539_cur."!cursor_pass"(rx1539_pos, "term:sym<variable>")
    if_null rx1539_debug, debug_1047
    rx1539_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1539_pos)
  debug_1047:
    .return (rx1539_cur)
  rx1539_restart:
.annotate 'line', 438
    if_null rx1539_debug, debug_1048
    rx1539_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1048:
  rx1539_fail:
    (rx1539_rep, rx1539_pos, $I10, $P10) = rx1539_cur."!mark_fail"(0)
    lt rx1539_pos, -1, rx1539_done
    eq rx1539_pos, -1, rx1539_fail
    jump $I10
  rx1539_done:
    rx1539_cur."!cursor_fail"()
    if_null rx1539_debug, debug_1049
    rx1539_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1049:
    .return (rx1539_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("138_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1542 = self."!PREFIX__!subrule"("variable", "")
    new $P1543, "ResizablePMCArray"
    push $P1543, $P1542
    .return ($P1543)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("139_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1545_tgt
    .local int rx1545_pos
    .local int rx1545_off
    .local int rx1545_eos
    .local int rx1545_rep
    .local pmc rx1545_cur
    .local pmc rx1545_debug
    (rx1545_cur, rx1545_pos, rx1545_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1545_cur
    .local pmc match
    .lex "$/", match
    length rx1545_eos, rx1545_tgt
    gt rx1545_pos, rx1545_eos, rx1545_done
    set rx1545_off, 0
    lt rx1545_pos, 2, rx1545_start
    sub rx1545_off, rx1545_pos, 1
    substr rx1545_tgt, rx1545_tgt, rx1545_off
  rx1545_start:
    eq $I10, 1, rx1545_restart
    if_null rx1545_debug, debug_1050
    rx1545_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1546_done
    goto rxscan1546_scan
  rxscan1546_loop:
    (rx1545_pos) = rx1545_cur."from"()
    inc rx1545_pos
    rx1545_cur."!cursor_from"(rx1545_pos)
    ge rx1545_pos, rx1545_eos, rxscan1546_done
  rxscan1546_scan:
    set_addr $I10, rxscan1546_loop
    rx1545_cur."!mark_push"(0, rx1545_pos, $I10)
  rxscan1546_done:
.annotate 'line', 700
  # rx subrule "package_declarator" subtype=capture negate=
    rx1545_cur."!cursor_pos"(rx1545_pos)
    $P10 = rx1545_cur."package_declarator"()
    unless $P10, rx1545_fail
    rx1545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1545_pos = $P10."pos"()
  # rx pass
    rx1545_cur."!cursor_pass"(rx1545_pos, "term:sym<package_declarator>")
    if_null rx1545_debug, debug_1051
    rx1545_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1545_pos)
  debug_1051:
    .return (rx1545_cur)
  rx1545_restart:
.annotate 'line', 438
    if_null rx1545_debug, debug_1052
    rx1545_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1052:
  rx1545_fail:
    (rx1545_rep, rx1545_pos, $I10, $P10) = rx1545_cur."!mark_fail"(0)
    lt rx1545_pos, -1, rx1545_done
    eq rx1545_pos, -1, rx1545_fail
    jump $I10
  rx1545_done:
    rx1545_cur."!cursor_fail"()
    if_null rx1545_debug, debug_1053
    rx1545_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1053:
    .return (rx1545_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("140_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1548 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P1549, "ResizablePMCArray"
    push $P1549, $P1548
    .return ($P1549)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("141_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1551_tgt
    .local int rx1551_pos
    .local int rx1551_off
    .local int rx1551_eos
    .local int rx1551_rep
    .local pmc rx1551_cur
    .local pmc rx1551_debug
    (rx1551_cur, rx1551_pos, rx1551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1551_cur
    .local pmc match
    .lex "$/", match
    length rx1551_eos, rx1551_tgt
    gt rx1551_pos, rx1551_eos, rx1551_done
    set rx1551_off, 0
    lt rx1551_pos, 2, rx1551_start
    sub rx1551_off, rx1551_pos, 1
    substr rx1551_tgt, rx1551_tgt, rx1551_off
  rx1551_start:
    eq $I10, 1, rx1551_restart
    if_null rx1551_debug, debug_1054
    rx1551_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1552_done
    goto rxscan1552_scan
  rxscan1552_loop:
    (rx1551_pos) = rx1551_cur."from"()
    inc rx1551_pos
    rx1551_cur."!cursor_from"(rx1551_pos)
    ge rx1551_pos, rx1551_eos, rxscan1552_done
  rxscan1552_scan:
    set_addr $I10, rxscan1552_loop
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  rxscan1552_done:
.annotate 'line', 701
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."scope_declarator"()
    unless $P10, rx1551_fail
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1551_pos = $P10."pos"()
  # rx pass
    rx1551_cur."!cursor_pass"(rx1551_pos, "term:sym<scope_declarator>")
    if_null rx1551_debug, debug_1055
    rx1551_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1551_pos)
  debug_1055:
    .return (rx1551_cur)
  rx1551_restart:
.annotate 'line', 438
    if_null rx1551_debug, debug_1056
    rx1551_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1056:
  rx1551_fail:
    (rx1551_rep, rx1551_pos, $I10, $P10) = rx1551_cur."!mark_fail"(0)
    lt rx1551_pos, -1, rx1551_done
    eq rx1551_pos, -1, rx1551_fail
    jump $I10
  rx1551_done:
    rx1551_cur."!cursor_fail"()
    if_null rx1551_debug, debug_1057
    rx1551_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1057:
    .return (rx1551_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("142_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1554 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P1555, "ResizablePMCArray"
    push $P1555, $P1554
    .return ($P1555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("143_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1557_tgt
    .local int rx1557_pos
    .local int rx1557_off
    .local int rx1557_eos
    .local int rx1557_rep
    .local pmc rx1557_cur
    .local pmc rx1557_debug
    (rx1557_cur, rx1557_pos, rx1557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1557_cur
    .local pmc match
    .lex "$/", match
    length rx1557_eos, rx1557_tgt
    gt rx1557_pos, rx1557_eos, rx1557_done
    set rx1557_off, 0
    lt rx1557_pos, 2, rx1557_start
    sub rx1557_off, rx1557_pos, 1
    substr rx1557_tgt, rx1557_tgt, rx1557_off
  rx1557_start:
    eq $I10, 1, rx1557_restart
    if_null rx1557_debug, debug_1058
    rx1557_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1558_done
    goto rxscan1558_scan
  rxscan1558_loop:
    (rx1557_pos) = rx1557_cur."from"()
    inc rx1557_pos
    rx1557_cur."!cursor_from"(rx1557_pos)
    ge rx1557_pos, rx1557_eos, rxscan1558_done
  rxscan1558_scan:
    set_addr $I10, rxscan1558_loop
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  rxscan1558_done:
.annotate 'line', 702
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1557_cur."!cursor_pos"(rx1557_pos)
    $P10 = rx1557_cur."routine_declarator"()
    unless $P10, rx1557_fail
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1557_pos = $P10."pos"()
  # rx pass
    rx1557_cur."!cursor_pass"(rx1557_pos, "term:sym<routine_declarator>")
    if_null rx1557_debug, debug_1059
    rx1557_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1557_pos)
  debug_1059:
    .return (rx1557_cur)
  rx1557_restart:
.annotate 'line', 438
    if_null rx1557_debug, debug_1060
    rx1557_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1060:
  rx1557_fail:
    (rx1557_rep, rx1557_pos, $I10, $P10) = rx1557_cur."!mark_fail"(0)
    lt rx1557_pos, -1, rx1557_done
    eq rx1557_pos, -1, rx1557_fail
    jump $I10
  rx1557_done:
    rx1557_cur."!cursor_fail"()
    if_null rx1557_debug, debug_1061
    rx1557_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1061:
    .return (rx1557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("144_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1560 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P1561, "ResizablePMCArray"
    push $P1561, $P1560
    .return ($P1561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("145_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1571 = "147_1305640955.436" 
    capture_lex $P1571
    .const 'Sub' $P1566 = "146_1305640955.436" 
    capture_lex $P1566
    .local string rx1563_tgt
    .local int rx1563_pos
    .local int rx1563_off
    .local int rx1563_eos
    .local int rx1563_rep
    .local pmc rx1563_cur
    .local pmc rx1563_debug
    (rx1563_cur, rx1563_pos, rx1563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1563_cur
    .local pmc match
    .lex "$/", match
    length rx1563_eos, rx1563_tgt
    gt rx1563_pos, rx1563_eos, rx1563_done
    set rx1563_off, 0
    lt rx1563_pos, 2, rx1563_start
    sub rx1563_off, rx1563_pos, 1
    substr rx1563_tgt, rx1563_tgt, rx1563_off
  rx1563_start:
    eq $I10, 1, rx1563_restart
    if_null rx1563_debug, debug_1062
    rx1563_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1564_done
    goto rxscan1564_scan
  rxscan1564_loop:
    (rx1563_pos) = rx1563_cur."from"()
    inc rx1563_pos
    rx1563_cur."!cursor_from"(rx1563_pos)
    ge rx1563_pos, rx1563_eos, rxscan1564_done
  rxscan1564_scan:
    set_addr $I10, rxscan1564_loop
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  rxscan1564_done:
.annotate 'line', 704
  # rx subrule "before" subtype=zerowidth negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    .const 'Sub' $P1566 = "146_1305640955.436" 
    capture_lex $P1566
    $P10 = rx1563_cur."before"($P1566)
    unless $P10, rx1563_fail
.annotate 'line', 705
  # rx subrule "before" subtype=zerowidth negate=1
    rx1563_cur."!cursor_pos"(rx1563_pos)
    .const 'Sub' $P1571 = "147_1305640955.436" 
    capture_lex $P1571
    $P10 = rx1563_cur."before"($P1571)
    if $P10, rx1563_fail
.annotate 'line', 706
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    $P10 = rx1563_cur."multi_declarator"()
    unless $P10, rx1563_fail
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1563_pos = $P10."pos"()
.annotate 'line', 703
  # rx pass
    rx1563_cur."!cursor_pass"(rx1563_pos, "term:sym<multi_declarator>")
    if_null rx1563_debug, debug_1071
    rx1563_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1563_pos)
  debug_1071:
    .return (rx1563_cur)
  rx1563_restart:
.annotate 'line', 438
    if_null rx1563_debug, debug_1072
    rx1563_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1072:
  rx1563_fail:
    (rx1563_rep, rx1563_pos, $I10, $P10) = rx1563_cur."!mark_fail"(0)
    lt rx1563_pos, -1, rx1563_done
    eq rx1563_pos, -1, rx1563_fail
    jump $I10
  rx1563_done:
    rx1563_cur."!cursor_fail"()
    if_null rx1563_debug, debug_1073
    rx1563_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1073:
    .return (rx1563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1565"  :anon :subid("146_1305640955.436") :method :outer("145_1305640955.436")
.annotate 'line', 704
    .local string rx1567_tgt
    .local int rx1567_pos
    .local int rx1567_off
    .local int rx1567_eos
    .local int rx1567_rep
    .local pmc rx1567_cur
    .local pmc rx1567_debug
    (rx1567_cur, rx1567_pos, rx1567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1567_cur
    .local pmc match
    .lex "$/", match
    length rx1567_eos, rx1567_tgt
    gt rx1567_pos, rx1567_eos, rx1567_done
    set rx1567_off, 0
    lt rx1567_pos, 2, rx1567_start
    sub rx1567_off, rx1567_pos, 1
    substr rx1567_tgt, rx1567_tgt, rx1567_off
  rx1567_start:
    eq $I10, 1, rx1567_restart
    if_null rx1567_debug, debug_1063
    rx1567_cur."!cursor_debug"("START", "")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1567_pos) = rx1567_cur."from"()
    inc rx1567_pos
    rx1567_cur."!cursor_from"(rx1567_pos)
    ge rx1567_pos, rx1567_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  rxscan1568_done:
  alt1569_0:
    set_addr $I10, alt1569_1
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1567_pos, 5
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    substr $S10, rx1567_tgt, $I11, 5
    ne $S10, "multi", rx1567_fail
    add rx1567_pos, 5
    goto alt1569_end
  alt1569_1:
    set_addr $I10, alt1569_2
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1567_pos, 5
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    substr $S10, rx1567_tgt, $I11, 5
    ne $S10, "proto", rx1567_fail
    add rx1567_pos, 5
    goto alt1569_end
  alt1569_2:
  # rx literal  "only"
    add $I11, rx1567_pos, 4
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    substr $S10, rx1567_tgt, $I11, 4
    ne $S10, "only", rx1567_fail
    add rx1567_pos, 4
  alt1569_end:
  # rx pass
    rx1567_cur."!cursor_pass"(rx1567_pos, "")
    if_null rx1567_debug, debug_1064
    rx1567_cur."!cursor_debug"("PASS", "", " at pos=", rx1567_pos)
  debug_1064:
    .return (rx1567_cur)
  rx1567_restart:
    if_null rx1567_debug, debug_1065
    rx1567_cur."!cursor_debug"("NEXT", "")
  debug_1065:
  rx1567_fail:
    (rx1567_rep, rx1567_pos, $I10, $P10) = rx1567_cur."!mark_fail"(0)
    lt rx1567_pos, -1, rx1567_done
    eq rx1567_pos, -1, rx1567_fail
    jump $I10
  rx1567_done:
    rx1567_cur."!cursor_fail"()
    if_null rx1567_debug, debug_1066
    rx1567_cur."!cursor_debug"("FAIL", "")
  debug_1066:
    .return (rx1567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1570"  :anon :subid("147_1305640955.436") :method :outer("145_1305640955.436")
.annotate 'line', 705
    .local string rx1572_tgt
    .local int rx1572_pos
    .local int rx1572_off
    .local int rx1572_eos
    .local int rx1572_rep
    .local pmc rx1572_cur
    .local pmc rx1572_debug
    (rx1572_cur, rx1572_pos, rx1572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1572_cur
    .local pmc match
    .lex "$/", match
    length rx1572_eos, rx1572_tgt
    gt rx1572_pos, rx1572_eos, rx1572_done
    set rx1572_off, 0
    lt rx1572_pos, 2, rx1572_start
    sub rx1572_off, rx1572_pos, 1
    substr rx1572_tgt, rx1572_tgt, rx1572_off
  rx1572_start:
    eq $I10, 1, rx1572_restart
    if_null rx1572_debug, debug_1067
    rx1572_cur."!cursor_debug"("START", "")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1573_done
    goto rxscan1573_scan
  rxscan1573_loop:
    (rx1572_pos) = rx1572_cur."from"()
    inc rx1572_pos
    rx1572_cur."!cursor_from"(rx1572_pos)
    ge rx1572_pos, rx1572_eos, rxscan1573_done
  rxscan1573_scan:
    set_addr $I10, rxscan1573_loop
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  rxscan1573_done:
  # rx literal  "proto"
    add $I11, rx1572_pos, 5
    gt $I11, rx1572_eos, rx1572_fail
    sub $I11, rx1572_pos, rx1572_off
    substr $S10, rx1572_tgt, $I11, 5
    ne $S10, "proto", rx1572_fail
    add rx1572_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1572_cur."!cursor_pos"(rx1572_pos)
    $P10 = rx1572_cur."ws"()
    unless $P10, rx1572_fail
    rx1572_pos = $P10."pos"()
  alt1574_0:
    set_addr $I10, alt1574_1
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1572_pos, 5
    gt $I11, rx1572_eos, rx1572_fail
    sub $I11, rx1572_pos, rx1572_off
    substr $S10, rx1572_tgt, $I11, 5
    ne $S10, "regex", rx1572_fail
    add rx1572_pos, 5
    goto alt1574_end
  alt1574_1:
    set_addr $I10, alt1574_2
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  # rx literal  "token"
    add $I11, rx1572_pos, 5
    gt $I11, rx1572_eos, rx1572_fail
    sub $I11, rx1572_pos, rx1572_off
    substr $S10, rx1572_tgt, $I11, 5
    ne $S10, "token", rx1572_fail
    add rx1572_pos, 5
    goto alt1574_end
  alt1574_2:
  # rx literal  "rule"
    add $I11, rx1572_pos, 4
    gt $I11, rx1572_eos, rx1572_fail
    sub $I11, rx1572_pos, rx1572_off
    substr $S10, rx1572_tgt, $I11, 4
    ne $S10, "rule", rx1572_fail
    add rx1572_pos, 4
  alt1574_end:
  # rx pass
    rx1572_cur."!cursor_pass"(rx1572_pos, "")
    if_null rx1572_debug, debug_1068
    rx1572_cur."!cursor_debug"("PASS", "", " at pos=", rx1572_pos)
  debug_1068:
    .return (rx1572_cur)
  rx1572_restart:
    if_null rx1572_debug, debug_1069
    rx1572_cur."!cursor_debug"("NEXT", "")
  debug_1069:
  rx1572_fail:
    (rx1572_rep, rx1572_pos, $I10, $P10) = rx1572_cur."!mark_fail"(0)
    lt rx1572_pos, -1, rx1572_done
    eq rx1572_pos, -1, rx1572_fail
    jump $I10
  rx1572_done:
    rx1572_cur."!cursor_fail"()
    if_null rx1572_debug, debug_1070
    rx1572_cur."!cursor_debug"("FAIL", "")
  debug_1070:
    .return (rx1572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("148_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1576, "ResizablePMCArray"
    push $P1576, ""
    .return ($P1576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("149_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1074
    rx1578_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1579_done
    goto rxscan1579_scan
  rxscan1579_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1579_done
  rxscan1579_scan:
    set_addr $I10, rxscan1579_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1579_done:
.annotate 'line', 708
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."regex_declarator"()
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1578_pos = $P10."pos"()
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "term:sym<regex_declarator>")
    if_null rx1578_debug, debug_1075
    rx1578_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1578_pos)
  debug_1075:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 438
    if_null rx1578_debug, debug_1076
    rx1578_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1076:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1077
    rx1578_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1077:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("150_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1581 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P1582, "ResizablePMCArray"
    push $P1582, $P1581
    .return ($P1582)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("151_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1078
    rx1584_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1585_done
    goto rxscan1585_scan
  rxscan1585_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1585_done
  rxscan1585_scan:
    set_addr $I10, rxscan1585_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1585_done:
.annotate 'line', 709
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."statement_prefix"()
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "term:sym<statement_prefix>")
    if_null rx1584_debug, debug_1079
    rx1584_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1584_pos)
  debug_1079:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 438
    if_null rx1584_debug, debug_1080
    rx1584_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1080:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1081
    rx1584_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1081:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("152_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1587 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P1588, "ResizablePMCArray"
    push $P1588, $P1587
    .return ($P1588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("153_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1082
    rx1590_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1591_done
    goto rxscan1591_scan
  rxscan1591_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1591_done
  rxscan1591_scan:
    set_addr $I10, rxscan1591_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1591_done:
.annotate 'line', 710
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."lambda"()
    unless $P10, rx1590_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."pblock"()
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1590_pos = $P10."pos"()
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "term:sym<lambda>")
    if_null rx1590_debug, debug_1083
    rx1590_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1590_pos)
  debug_1083:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 438
    if_null rx1590_debug, debug_1084
    rx1590_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1084:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1085
    rx1590_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1085:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("154_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1593, "ResizablePMCArray"
    push $P1593, ""
    .return ($P1593)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("155_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1595_tgt
    .local int rx1595_pos
    .local int rx1595_off
    .local int rx1595_eos
    .local int rx1595_rep
    .local pmc rx1595_cur
    .local pmc rx1595_debug
    (rx1595_cur, rx1595_pos, rx1595_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1595_cur
    .local pmc match
    .lex "$/", match
    length rx1595_eos, rx1595_tgt
    gt rx1595_pos, rx1595_eos, rx1595_done
    set rx1595_off, 0
    lt rx1595_pos, 2, rx1595_start
    sub rx1595_off, rx1595_pos, 1
    substr rx1595_tgt, rx1595_tgt, rx1595_off
  rx1595_start:
    eq $I10, 1, rx1595_restart
    if_null rx1595_debug, debug_1086
    rx1595_cur."!cursor_debug"("START", "fatarrow")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1596_done
    goto rxscan1596_scan
  rxscan1596_loop:
    (rx1595_pos) = rx1595_cur."from"()
    inc rx1595_pos
    rx1595_cur."!cursor_from"(rx1595_pos)
    ge rx1595_pos, rx1595_eos, rxscan1596_done
  rxscan1596_scan:
    set_addr $I10, rxscan1596_loop
    rx1595_cur."!mark_push"(0, rx1595_pos, $I10)
  rxscan1596_done:
.annotate 'line', 713
  # rx subrule "identifier" subtype=capture negate=
    rx1595_cur."!cursor_pos"(rx1595_pos)
    $P10 = rx1595_cur."identifier"()
    unless $P10, rx1595_fail
    rx1595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1595_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1595_pos, rx1595_off
    set rx1595_rep, 0
    sub $I12, rx1595_eos, rx1595_pos
  rxenumcharlistq1597_loop:
    le $I12, 0, rxenumcharlistq1597_done
    substr $S10, rx1595_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1597_done
    inc rx1595_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1597_loop
  rxenumcharlistq1597_done:
    add rx1595_pos, rx1595_pos, rx1595_rep
  # rx literal  "=>"
    add $I11, rx1595_pos, 2
    gt $I11, rx1595_eos, rx1595_fail
    sub $I11, rx1595_pos, rx1595_off
    substr $S10, rx1595_tgt, $I11, 2
    ne $S10, "=>", rx1595_fail
    add rx1595_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1595_cur."!cursor_pos"(rx1595_pos)
    $P10 = rx1595_cur."ws"()
    unless $P10, rx1595_fail
    rx1595_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1595_cur."!cursor_pos"(rx1595_pos)
    $P10 = rx1595_cur."EXPR"("i=")
    unless $P10, rx1595_fail
    rx1595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1595_pos = $P10."pos"()
.annotate 'line', 712
  # rx pass
    rx1595_cur."!cursor_pass"(rx1595_pos, "fatarrow")
    if_null rx1595_debug, debug_1087
    rx1595_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1595_pos)
  debug_1087:
    .return (rx1595_cur)
  rx1595_restart:
.annotate 'line', 438
    if_null rx1595_debug, debug_1088
    rx1595_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1088:
  rx1595_fail:
    (rx1595_rep, rx1595_pos, $I10, $P10) = rx1595_cur."!mark_fail"(0)
    lt rx1595_pos, -1, rx1595_done
    eq rx1595_pos, -1, rx1595_fail
    jump $I10
  rx1595_done:
    rx1595_cur."!cursor_fail"()
    if_null rx1595_debug, debug_1089
    rx1595_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1089:
    .return (rx1595_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("156_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1599 = self."!PREFIX__!subrule"("identifier", "")
    new $P1600, "ResizablePMCArray"
    push $P1600, $P1599
    .return ($P1600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("157_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1602_tgt
    .local int rx1602_pos
    .local int rx1602_off
    .local int rx1602_eos
    .local int rx1602_rep
    .local pmc rx1602_cur
    .local pmc rx1602_debug
    (rx1602_cur, rx1602_pos, rx1602_tgt, $I10) = self."!cursor_start"()
    rx1602_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1602_cur
    .local pmc match
    .lex "$/", match
    length rx1602_eos, rx1602_tgt
    gt rx1602_pos, rx1602_eos, rx1602_done
    set rx1602_off, 0
    lt rx1602_pos, 2, rx1602_start
    sub rx1602_off, rx1602_pos, 1
    substr rx1602_tgt, rx1602_tgt, rx1602_off
  rx1602_start:
    eq $I10, 1, rx1602_restart
    if_null rx1602_debug, debug_1090
    rx1602_cur."!cursor_debug"("START", "colonpair")
  debug_1090:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1603_done
    goto rxscan1603_scan
  rxscan1603_loop:
    (rx1602_pos) = rx1602_cur."from"()
    inc rx1602_pos
    rx1602_cur."!cursor_from"(rx1602_pos)
    ge rx1602_pos, rx1602_eos, rxscan1603_done
  rxscan1603_scan:
    set_addr $I10, rxscan1603_loop
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
  rxscan1603_done:
.annotate 'line', 717
  # rx literal  ":"
    add $I11, rx1602_pos, 1
    gt $I11, rx1602_eos, rx1602_fail
    sub $I11, rx1602_pos, rx1602_off
    ord $I11, rx1602_tgt, $I11
    ne $I11, 58, rx1602_fail
    add rx1602_pos, 1
  alt1604_0:
.annotate 'line', 718
    set_addr $I10, alt1604_1
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
.annotate 'line', 719
  # rx subcapture "not"
    set_addr $I10, rxcap_1605_fail
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
  # rx literal  "!"
    add $I11, rx1602_pos, 1
    gt $I11, rx1602_eos, rx1602_fail
    sub $I11, rx1602_pos, rx1602_off
    ord $I11, rx1602_tgt, $I11
    ne $I11, 33, rx1602_fail
    add rx1602_pos, 1
    set_addr $I10, rxcap_1605_fail
    ($I12, $I11) = rx1602_cur."!mark_peek"($I10)
    rx1602_cur."!cursor_pos"($I11)
    ($P10) = rx1602_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1602_pos, "")
    rx1602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1605_done
  rxcap_1605_fail:
    goto rx1602_fail
  rxcap_1605_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1602_cur."!cursor_pos"(rx1602_pos)
    $P10 = rx1602_cur."identifier"()
    unless $P10, rx1602_fail
    rx1602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1602_pos = $P10."pos"()
    goto alt1604_end
  alt1604_1:
    set_addr $I10, alt1604_2
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
.annotate 'line', 720
  # rx subrule "identifier" subtype=capture negate=
    rx1602_cur."!cursor_pos"(rx1602_pos)
    $P10 = rx1602_cur."identifier"()
    unless $P10, rx1602_fail
    rx1602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1602_pos = $P10."pos"()
  # rx rxquantr1606 ** 0..1
    set_addr $I10, rxquantr1606_done
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
  rxquantr1606_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1602_cur."!cursor_pos"(rx1602_pos)
    $P10 = rx1602_cur."circumfix"()
    unless $P10, rx1602_fail
    goto rxsubrule1607_pass
  rxsubrule1607_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1602_fail
  rxsubrule1607_pass:
    set_addr $I10, rxsubrule1607_back
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1602_pos = $P10."pos"()
    set_addr $I10, rxquantr1606_done
    (rx1602_rep) = rx1602_cur."!mark_commit"($I10)
  rxquantr1606_done:
    goto alt1604_end
  alt1604_2:
.annotate 'line', 721
  # rx subrule "circumfix" subtype=capture negate=
    rx1602_cur."!cursor_pos"(rx1602_pos)
    $P10 = rx1602_cur."circumfix"()
    unless $P10, rx1602_fail
    rx1602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1602_pos = $P10."pos"()
  alt1604_end:
.annotate 'line', 716
  # rx pass
    rx1602_cur."!cursor_pass"(rx1602_pos, "colonpair")
    if_null rx1602_debug, debug_1091
    rx1602_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1602_pos)
  debug_1091:
    .return (rx1602_cur)
  rx1602_restart:
.annotate 'line', 438
    if_null rx1602_debug, debug_1092
    rx1602_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1092:
  rx1602_fail:
    (rx1602_rep, rx1602_pos, $I10, $P10) = rx1602_cur."!mark_fail"(0)
    lt rx1602_pos, -1, rx1602_done
    eq rx1602_pos, -1, rx1602_fail
    jump $I10
  rx1602_done:
    rx1602_cur."!cursor_fail"()
    if_null rx1602_debug, debug_1093
    rx1602_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1093:
    .return (rx1602_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("158_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1609 = self."!PREFIX__!subrule"("circumfix", ":")
    $P1610 = self."!PREFIX__!subrule"("identifier", ":")
    $P1611 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P1612, "ResizablePMCArray"
    push $P1612, $P1609
    push $P1612, $P1610
    push $P1612, $P1611
    .return ($P1612)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("159_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1614_tgt
    .local int rx1614_pos
    .local int rx1614_off
    .local int rx1614_eos
    .local int rx1614_rep
    .local pmc rx1614_cur
    .local pmc rx1614_debug
    (rx1614_cur, rx1614_pos, rx1614_tgt, $I10) = self."!cursor_start"()
    rx1614_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1614_cur
    .local pmc match
    .lex "$/", match
    length rx1614_eos, rx1614_tgt
    gt rx1614_pos, rx1614_eos, rx1614_done
    set rx1614_off, 0
    lt rx1614_pos, 2, rx1614_start
    sub rx1614_off, rx1614_pos, 1
    substr rx1614_tgt, rx1614_tgt, rx1614_off
  rx1614_start:
    eq $I10, 1, rx1614_restart
    if_null rx1614_debug, debug_1094
    rx1614_cur."!cursor_debug"("START", "variable")
  debug_1094:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1614_pos) = rx1614_cur."from"()
    inc rx1614_pos
    rx1614_cur."!cursor_from"(rx1614_pos)
    ge rx1614_pos, rx1614_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
  rxscan1615_done:
  alt1616_0:
.annotate 'line', 725
    set_addr $I10, alt1616_1
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
.annotate 'line', 726
  # rx subrule "sigil" subtype=capture negate=
    rx1614_cur."!cursor_pos"(rx1614_pos)
    $P10 = rx1614_cur."sigil"()
    unless $P10, rx1614_fail
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1614_pos = $P10."pos"()
  # rx rxquantr1617 ** 0..1
    set_addr $I10, rxquantr1617_done
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
  rxquantr1617_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1614_cur."!cursor_pos"(rx1614_pos)
    $P10 = rx1614_cur."twigil"()
    unless $P10, rx1614_fail
    goto rxsubrule1618_pass
  rxsubrule1618_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1614_fail
  rxsubrule1618_pass:
    set_addr $I10, rxsubrule1618_back
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1614_pos = $P10."pos"()
    set_addr $I10, rxquantr1617_done
    (rx1614_rep) = rx1614_cur."!mark_commit"($I10)
  rxquantr1617_done:
  # rx subrule "name" subtype=capture negate=
    rx1614_cur."!cursor_pos"(rx1614_pos)
    $P10 = rx1614_cur."name"()
    unless $P10, rx1614_fail
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1614_pos = $P10."pos"()
    goto alt1616_end
  alt1616_1:
    set_addr $I10, alt1616_2
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
.annotate 'line', 727
  # rx subrule "sigil" subtype=capture negate=
    rx1614_cur."!cursor_pos"(rx1614_pos)
    $P10 = rx1614_cur."sigil"()
    unless $P10, rx1614_fail
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1614_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1614_pos, rx1614_off
    substr $S10, rx1614_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1614_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1614_cur."!cursor_pos"(rx1614_pos)
    $P10 = rx1614_cur."postcircumfix"()
    unless $P10, rx1614_fail
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1614_pos = $P10."pos"()
    goto alt1616_end
  alt1616_2:
.annotate 'line', 728
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1619_fail
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
  # rx literal  "$"
    add $I11, rx1614_pos, 1
    gt $I11, rx1614_eos, rx1614_fail
    sub $I11, rx1614_pos, rx1614_off
    ord $I11, rx1614_tgt, $I11
    ne $I11, 36, rx1614_fail
    add rx1614_pos, 1
    set_addr $I10, rxcap_1619_fail
    ($I12, $I11) = rx1614_cur."!mark_peek"($I10)
    rx1614_cur."!cursor_pos"($I11)
    ($P10) = rx1614_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1614_pos, "")
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1619_done
  rxcap_1619_fail:
    goto rx1614_fail
  rxcap_1619_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1620_fail
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1614_pos, rx1614_eos, rx1614_fail
    sub $I10, rx1614_pos, rx1614_off
    substr $S10, rx1614_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1614_fail
    inc rx1614_pos
    set_addr $I10, rxcap_1620_fail
    ($I12, $I11) = rx1614_cur."!mark_peek"($I10)
    rx1614_cur."!cursor_pos"($I11)
    ($P10) = rx1614_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1614_pos, "")
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1620_done
  rxcap_1620_fail:
    goto rx1614_fail
  rxcap_1620_done:
  alt1616_end:
.annotate 'line', 725
  # rx pass
    rx1614_cur."!cursor_pass"(rx1614_pos, "variable")
    if_null rx1614_debug, debug_1095
    rx1614_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1614_pos)
  debug_1095:
    .return (rx1614_cur)
  rx1614_restart:
.annotate 'line', 438
    if_null rx1614_debug, debug_1096
    rx1614_cur."!cursor_debug"("NEXT", "variable")
  debug_1096:
  rx1614_fail:
    (rx1614_rep, rx1614_pos, $I10, $P10) = rx1614_cur."!mark_fail"(0)
    lt rx1614_pos, -1, rx1614_done
    eq rx1614_pos, -1, rx1614_fail
    jump $I10
  rx1614_done:
    rx1614_cur."!cursor_fail"()
    if_null rx1614_debug, debug_1097
    rx1614_cur."!cursor_debug"("FAIL", "variable")
  debug_1097:
    .return (rx1614_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("160_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1622 = self."!PREFIX__!subrule"("sigil", "")
    $P1623 = self."!PREFIX__!subrule"("sigil", "")
    new $P1624, "ResizablePMCArray"
    push $P1624, "/"
    push $P1624, "_"
    push $P1624, "!"
    push $P1624, $P1622
    push $P1624, $P1623
    .return ($P1624)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("161_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1626_tgt
    .local int rx1626_pos
    .local int rx1626_off
    .local int rx1626_eos
    .local int rx1626_rep
    .local pmc rx1626_cur
    .local pmc rx1626_debug
    (rx1626_cur, rx1626_pos, rx1626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1626_cur
    .local pmc match
    .lex "$/", match
    length rx1626_eos, rx1626_tgt
    gt rx1626_pos, rx1626_eos, rx1626_done
    set rx1626_off, 0
    lt rx1626_pos, 2, rx1626_start
    sub rx1626_off, rx1626_pos, 1
    substr rx1626_tgt, rx1626_tgt, rx1626_off
  rx1626_start:
    eq $I10, 1, rx1626_restart
    if_null rx1626_debug, debug_1098
    rx1626_cur."!cursor_debug"("START", "sigil")
  debug_1098:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1626_pos) = rx1626_cur."from"()
    inc rx1626_pos
    rx1626_cur."!cursor_from"(rx1626_pos)
    ge rx1626_pos, rx1626_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  rxscan1627_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 
    ge rx1626_pos, rx1626_eos, rx1626_fail
    sub $I10, rx1626_pos, rx1626_off
    substr $S10, rx1626_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1626_fail
    inc rx1626_pos
  # rx pass
    rx1626_cur."!cursor_pass"(rx1626_pos, "sigil")
    if_null rx1626_debug, debug_1099
    rx1626_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1626_pos)
  debug_1099:
    .return (rx1626_cur)
  rx1626_restart:
.annotate 'line', 438
    if_null rx1626_debug, debug_1100
    rx1626_cur."!cursor_debug"("NEXT", "sigil")
  debug_1100:
  rx1626_fail:
    (rx1626_rep, rx1626_pos, $I10, $P10) = rx1626_cur."!mark_fail"(0)
    lt rx1626_pos, -1, rx1626_done
    eq rx1626_pos, -1, rx1626_fail
    jump $I10
  rx1626_done:
    rx1626_cur."!cursor_fail"()
    if_null rx1626_debug, debug_1101
    rx1626_cur."!cursor_debug"("FAIL", "sigil")
  debug_1101:
    .return (rx1626_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("162_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1629, "ResizablePMCArray"
    push $P1629, "$"
    push $P1629, "@"
    push $P1629, "%"
    push $P1629, "&"
    .return ($P1629)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("163_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1631_tgt
    .local int rx1631_pos
    .local int rx1631_off
    .local int rx1631_eos
    .local int rx1631_rep
    .local pmc rx1631_cur
    .local pmc rx1631_debug
    (rx1631_cur, rx1631_pos, rx1631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1631_cur
    .local pmc match
    .lex "$/", match
    length rx1631_eos, rx1631_tgt
    gt rx1631_pos, rx1631_eos, rx1631_done
    set rx1631_off, 0
    lt rx1631_pos, 2, rx1631_start
    sub rx1631_off, rx1631_pos, 1
    substr rx1631_tgt, rx1631_tgt, rx1631_off
  rx1631_start:
    eq $I10, 1, rx1631_restart
    if_null rx1631_debug, debug_1102
    rx1631_cur."!cursor_debug"("START", "twigil")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1632_done
    goto rxscan1632_scan
  rxscan1632_loop:
    (rx1631_pos) = rx1631_cur."from"()
    inc rx1631_pos
    rx1631_cur."!cursor_from"(rx1631_pos)
    ge rx1631_pos, rx1631_eos, rxscan1632_done
  rxscan1632_scan:
    set_addr $I10, rxscan1632_loop
    rx1631_cur."!mark_push"(0, rx1631_pos, $I10)
  rxscan1632_done:
.annotate 'line', 733
  # rx enumcharlist negate=0 
    ge rx1631_pos, rx1631_eos, rx1631_fail
    sub $I10, rx1631_pos, rx1631_off
    substr $S10, rx1631_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1631_fail
    inc rx1631_pos
  # rx pass
    rx1631_cur."!cursor_pass"(rx1631_pos, "twigil")
    if_null rx1631_debug, debug_1103
    rx1631_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1631_pos)
  debug_1103:
    .return (rx1631_cur)
  rx1631_restart:
.annotate 'line', 438
    if_null rx1631_debug, debug_1104
    rx1631_cur."!cursor_debug"("NEXT", "twigil")
  debug_1104:
  rx1631_fail:
    (rx1631_rep, rx1631_pos, $I10, $P10) = rx1631_cur."!mark_fail"(0)
    lt rx1631_pos, -1, rx1631_done
    eq rx1631_pos, -1, rx1631_fail
    jump $I10
  rx1631_done:
    rx1631_cur."!cursor_fail"()
    if_null rx1631_debug, debug_1105
    rx1631_cur."!cursor_debug"("FAIL", "twigil")
  debug_1105:
    .return (rx1631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("164_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P1634, "ResizablePMCArray"
    push $P1634, "*"
    push $P1634, "!"
    push $P1634, "?"
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("165_1305640955.436")
    .param pmc param_1636
.annotate 'line', 735
    .lex "self", param_1636
    $P1637 = param_1636."!protoregex"("package_declarator")
    .return ($P1637)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("166_1305640955.436")
    .param pmc param_1639
.annotate 'line', 735
    .lex "self", param_1639
    $P1640 = param_1639."!PREFIX__!protoregex"("package_declarator")
    .return ($P1640)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("167_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 737
    new $P1642, "Undef"
    .lex "$*OUTERPACKAGE", $P1642
.annotate 'line', 738
    new $P1643, "Undef"
    .lex "$*PKGDECL", $P1643
.annotate 'line', 438
    .local string rx1644_tgt
    .local int rx1644_pos
    .local int rx1644_off
    .local int rx1644_eos
    .local int rx1644_rep
    .local pmc rx1644_cur
    .local pmc rx1644_debug
    (rx1644_cur, rx1644_pos, rx1644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1644_cur
    .local pmc match
    .lex "$/", match
    length rx1644_eos, rx1644_tgt
    gt rx1644_pos, rx1644_eos, rx1644_done
    set rx1644_off, 0
    lt rx1644_pos, 2, rx1644_start
    sub rx1644_off, rx1644_pos, 1
    substr rx1644_tgt, rx1644_tgt, rx1644_off
  rx1644_start:
    eq $I10, 1, rx1644_restart
    if_null rx1644_debug, debug_1106
    rx1644_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1645_done
    goto rxscan1645_scan
  rxscan1645_loop:
    (rx1644_pos) = rx1644_cur."from"()
    inc rx1644_pos
    rx1644_cur."!cursor_from"(rx1644_pos)
    ge rx1644_pos, rx1644_eos, rxscan1645_done
  rxscan1645_scan:
    set_addr $I10, rxscan1645_loop
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  rxscan1645_done:
.annotate 'line', 737
    rx1644_cur."!cursor_pos"(rx1644_pos)
    find_dynamic_lex $P1648, "$*PACKAGE"
    unless_null $P1648, vivify_1107
    get_hll_global $P1646, "GLOBAL"
    get_who $P1647, $P1646
    set $P1648, $P1647["$PACKAGE"]
    unless_null $P1648, vivify_1108
    die "Contextual $*PACKAGE not found"
  vivify_1108:
  vivify_1107:
    store_lex "$*OUTERPACKAGE", $P1648
.annotate 'line', 738
    rx1644_cur."!cursor_pos"(rx1644_pos)
    new $P1649, "String"
    assign $P1649, "module"
    store_lex "$*PKGDECL", $P1649
.annotate 'line', 739
  # rx subcapture "sym"
    set_addr $I10, rxcap_1650_fail
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  # rx literal  "module"
    add $I11, rx1644_pos, 6
    gt $I11, rx1644_eos, rx1644_fail
    sub $I11, rx1644_pos, rx1644_off
    substr $S10, rx1644_tgt, $I11, 6
    ne $S10, "module", rx1644_fail
    add rx1644_pos, 6
    set_addr $I10, rxcap_1650_fail
    ($I12, $I11) = rx1644_cur."!mark_peek"($I10)
    rx1644_cur."!cursor_pos"($I11)
    ($P10) = rx1644_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1644_pos, "")
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1650_done
  rxcap_1650_fail:
    goto rx1644_fail
  rxcap_1650_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1644_cur."!cursor_pos"(rx1644_pos)
    $P10 = rx1644_cur."package_def"()
    unless $P10, rx1644_fail
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1644_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx1644_cur."!cursor_pass"(rx1644_pos, "package_declarator:sym<module>")
    if_null rx1644_debug, debug_1109
    rx1644_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1644_pos)
  debug_1109:
    .return (rx1644_cur)
  rx1644_restart:
.annotate 'line', 438
    if_null rx1644_debug, debug_1110
    rx1644_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1110:
  rx1644_fail:
    (rx1644_rep, rx1644_pos, $I10, $P10) = rx1644_cur."!mark_fail"(0)
    lt rx1644_pos, -1, rx1644_done
    eq rx1644_pos, -1, rx1644_fail
    jump $I10
  rx1644_done:
    rx1644_cur."!cursor_fail"()
    if_null rx1644_debug, debug_1111
    rx1644_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1111:
    .return (rx1644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("168_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1652 = self."!PREFIX__!subrule"("package_def", "module")
    new $P1653, "ResizablePMCArray"
    push $P1653, $P1652
    .return ($P1653)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("169_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 742
    new $P1655, "Undef"
    .lex "$*OUTERPACKAGE", $P1655
.annotate 'line', 743
    new $P1656, "Undef"
    .lex "$*PKGDECL", $P1656
.annotate 'line', 438
    .local string rx1657_tgt
    .local int rx1657_pos
    .local int rx1657_off
    .local int rx1657_eos
    .local int rx1657_rep
    .local pmc rx1657_cur
    .local pmc rx1657_debug
    (rx1657_cur, rx1657_pos, rx1657_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1657_cur
    .local pmc match
    .lex "$/", match
    length rx1657_eos, rx1657_tgt
    gt rx1657_pos, rx1657_eos, rx1657_done
    set rx1657_off, 0
    lt rx1657_pos, 2, rx1657_start
    sub rx1657_off, rx1657_pos, 1
    substr rx1657_tgt, rx1657_tgt, rx1657_off
  rx1657_start:
    eq $I10, 1, rx1657_restart
    if_null rx1657_debug, debug_1112
    rx1657_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1658_done
    goto rxscan1658_scan
  rxscan1658_loop:
    (rx1657_pos) = rx1657_cur."from"()
    inc rx1657_pos
    rx1657_cur."!cursor_from"(rx1657_pos)
    ge rx1657_pos, rx1657_eos, rxscan1658_done
  rxscan1658_scan:
    set_addr $I10, rxscan1658_loop
    rx1657_cur."!mark_push"(0, rx1657_pos, $I10)
  rxscan1658_done:
.annotate 'line', 742
    rx1657_cur."!cursor_pos"(rx1657_pos)
    find_dynamic_lex $P1661, "$*PACKAGE"
    unless_null $P1661, vivify_1113
    get_hll_global $P1659, "GLOBAL"
    get_who $P1660, $P1659
    set $P1661, $P1660["$PACKAGE"]
    unless_null $P1661, vivify_1114
    die "Contextual $*PACKAGE not found"
  vivify_1114:
  vivify_1113:
    store_lex "$*OUTERPACKAGE", $P1661
.annotate 'line', 743
    rx1657_cur."!cursor_pos"(rx1657_pos)
    new $P1662, "String"
    assign $P1662, "knowhow"
    store_lex "$*PKGDECL", $P1662
.annotate 'line', 744
  # rx subcapture "sym"
    set_addr $I10, rxcap_1663_fail
    rx1657_cur."!mark_push"(0, rx1657_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1657_pos, 7
    gt $I11, rx1657_eos, rx1657_fail
    sub $I11, rx1657_pos, rx1657_off
    substr $S10, rx1657_tgt, $I11, 7
    ne $S10, "knowhow", rx1657_fail
    add rx1657_pos, 7
    set_addr $I10, rxcap_1663_fail
    ($I12, $I11) = rx1657_cur."!mark_peek"($I10)
    rx1657_cur."!cursor_pos"($I11)
    ($P10) = rx1657_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1657_pos, "")
    rx1657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1663_done
  rxcap_1663_fail:
    goto rx1657_fail
  rxcap_1663_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1657_cur."!cursor_pos"(rx1657_pos)
    $P10 = rx1657_cur."package_def"()
    unless $P10, rx1657_fail
    rx1657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1657_pos = $P10."pos"()
.annotate 'line', 741
  # rx pass
    rx1657_cur."!cursor_pass"(rx1657_pos, "package_declarator:sym<knowhow>")
    if_null rx1657_debug, debug_1115
    rx1657_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1657_pos)
  debug_1115:
    .return (rx1657_cur)
  rx1657_restart:
.annotate 'line', 438
    if_null rx1657_debug, debug_1116
    rx1657_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1116:
  rx1657_fail:
    (rx1657_rep, rx1657_pos, $I10, $P10) = rx1657_cur."!mark_fail"(0)
    lt rx1657_pos, -1, rx1657_done
    eq rx1657_pos, -1, rx1657_fail
    jump $I10
  rx1657_done:
    rx1657_cur."!cursor_fail"()
    if_null rx1657_debug, debug_1117
    rx1657_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1117:
    .return (rx1657_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("170_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1665 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P1666, "ResizablePMCArray"
    push $P1666, $P1665
    .return ($P1666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("171_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 747
    new $P1668, "Undef"
    .lex "$*OUTERPACKAGE", $P1668
.annotate 'line', 748
    new $P1669, "Undef"
    .lex "$*PKGDECL", $P1669
.annotate 'line', 438
    .local string rx1670_tgt
    .local int rx1670_pos
    .local int rx1670_off
    .local int rx1670_eos
    .local int rx1670_rep
    .local pmc rx1670_cur
    .local pmc rx1670_debug
    (rx1670_cur, rx1670_pos, rx1670_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1670_cur
    .local pmc match
    .lex "$/", match
    length rx1670_eos, rx1670_tgt
    gt rx1670_pos, rx1670_eos, rx1670_done
    set rx1670_off, 0
    lt rx1670_pos, 2, rx1670_start
    sub rx1670_off, rx1670_pos, 1
    substr rx1670_tgt, rx1670_tgt, rx1670_off
  rx1670_start:
    eq $I10, 1, rx1670_restart
    if_null rx1670_debug, debug_1118
    rx1670_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1671_done
    goto rxscan1671_scan
  rxscan1671_loop:
    (rx1670_pos) = rx1670_cur."from"()
    inc rx1670_pos
    rx1670_cur."!cursor_from"(rx1670_pos)
    ge rx1670_pos, rx1670_eos, rxscan1671_done
  rxscan1671_scan:
    set_addr $I10, rxscan1671_loop
    rx1670_cur."!mark_push"(0, rx1670_pos, $I10)
  rxscan1671_done:
.annotate 'line', 747
    rx1670_cur."!cursor_pos"(rx1670_pos)
    find_dynamic_lex $P1674, "$*PACKAGE"
    unless_null $P1674, vivify_1119
    get_hll_global $P1672, "GLOBAL"
    get_who $P1673, $P1672
    set $P1674, $P1673["$PACKAGE"]
    unless_null $P1674, vivify_1120
    die "Contextual $*PACKAGE not found"
  vivify_1120:
  vivify_1119:
    store_lex "$*OUTERPACKAGE", $P1674
.annotate 'line', 748
    rx1670_cur."!cursor_pos"(rx1670_pos)
    new $P1675, "String"
    assign $P1675, "class"
    store_lex "$*PKGDECL", $P1675
.annotate 'line', 749
  # rx subcapture "sym"
    set_addr $I10, rxcap_1676_fail
    rx1670_cur."!mark_push"(0, rx1670_pos, $I10)
  # rx literal  "class"
    add $I11, rx1670_pos, 5
    gt $I11, rx1670_eos, rx1670_fail
    sub $I11, rx1670_pos, rx1670_off
    substr $S10, rx1670_tgt, $I11, 5
    ne $S10, "class", rx1670_fail
    add rx1670_pos, 5
    set_addr $I10, rxcap_1676_fail
    ($I12, $I11) = rx1670_cur."!mark_peek"($I10)
    rx1670_cur."!cursor_pos"($I11)
    ($P10) = rx1670_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1670_pos, "")
    rx1670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1676_done
  rxcap_1676_fail:
    goto rx1670_fail
  rxcap_1676_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1670_cur."!cursor_pos"(rx1670_pos)
    $P10 = rx1670_cur."package_def"()
    unless $P10, rx1670_fail
    rx1670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1670_pos = $P10."pos"()
.annotate 'line', 746
  # rx pass
    rx1670_cur."!cursor_pass"(rx1670_pos, "package_declarator:sym<class>")
    if_null rx1670_debug, debug_1121
    rx1670_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1670_pos)
  debug_1121:
    .return (rx1670_cur)
  rx1670_restart:
.annotate 'line', 438
    if_null rx1670_debug, debug_1122
    rx1670_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1122:
  rx1670_fail:
    (rx1670_rep, rx1670_pos, $I10, $P10) = rx1670_cur."!mark_fail"(0)
    lt rx1670_pos, -1, rx1670_done
    eq rx1670_pos, -1, rx1670_fail
    jump $I10
  rx1670_done:
    rx1670_cur."!cursor_fail"()
    if_null rx1670_debug, debug_1123
    rx1670_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1123:
    .return (rx1670_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("172_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1678 = self."!PREFIX__!subrule"("package_def", "class")
    new $P1679, "ResizablePMCArray"
    push $P1679, $P1678
    .return ($P1679)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("173_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 752
    new $P1681, "Undef"
    .lex "$*OUTERPACKAGE", $P1681
.annotate 'line', 753
    new $P1682, "Undef"
    .lex "$*PKGDECL", $P1682
.annotate 'line', 438
    .local string rx1683_tgt
    .local int rx1683_pos
    .local int rx1683_off
    .local int rx1683_eos
    .local int rx1683_rep
    .local pmc rx1683_cur
    .local pmc rx1683_debug
    (rx1683_cur, rx1683_pos, rx1683_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1683_cur
    .local pmc match
    .lex "$/", match
    length rx1683_eos, rx1683_tgt
    gt rx1683_pos, rx1683_eos, rx1683_done
    set rx1683_off, 0
    lt rx1683_pos, 2, rx1683_start
    sub rx1683_off, rx1683_pos, 1
    substr rx1683_tgt, rx1683_tgt, rx1683_off
  rx1683_start:
    eq $I10, 1, rx1683_restart
    if_null rx1683_debug, debug_1124
    rx1683_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1684_done
    goto rxscan1684_scan
  rxscan1684_loop:
    (rx1683_pos) = rx1683_cur."from"()
    inc rx1683_pos
    rx1683_cur."!cursor_from"(rx1683_pos)
    ge rx1683_pos, rx1683_eos, rxscan1684_done
  rxscan1684_scan:
    set_addr $I10, rxscan1684_loop
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  rxscan1684_done:
.annotate 'line', 752
    rx1683_cur."!cursor_pos"(rx1683_pos)
    find_dynamic_lex $P1687, "$*PACKAGE"
    unless_null $P1687, vivify_1125
    get_hll_global $P1685, "GLOBAL"
    get_who $P1686, $P1685
    set $P1687, $P1686["$PACKAGE"]
    unless_null $P1687, vivify_1126
    die "Contextual $*PACKAGE not found"
  vivify_1126:
  vivify_1125:
    store_lex "$*OUTERPACKAGE", $P1687
.annotate 'line', 753
    rx1683_cur."!cursor_pos"(rx1683_pos)
    new $P1688, "String"
    assign $P1688, "grammar"
    store_lex "$*PKGDECL", $P1688
.annotate 'line', 754
  # rx subcapture "sym"
    set_addr $I10, rxcap_1689_fail
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1683_pos, 7
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    substr $S10, rx1683_tgt, $I11, 7
    ne $S10, "grammar", rx1683_fail
    add rx1683_pos, 7
    set_addr $I10, rxcap_1689_fail
    ($I12, $I11) = rx1683_cur."!mark_peek"($I10)
    rx1683_cur."!cursor_pos"($I11)
    ($P10) = rx1683_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1683_pos, "")
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1689_done
  rxcap_1689_fail:
    goto rx1683_fail
  rxcap_1689_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."package_def"()
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1683_pos = $P10."pos"()
.annotate 'line', 751
  # rx pass
    rx1683_cur."!cursor_pass"(rx1683_pos, "package_declarator:sym<grammar>")
    if_null rx1683_debug, debug_1127
    rx1683_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1683_pos)
  debug_1127:
    .return (rx1683_cur)
  rx1683_restart:
.annotate 'line', 438
    if_null rx1683_debug, debug_1128
    rx1683_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1128:
  rx1683_fail:
    (rx1683_rep, rx1683_pos, $I10, $P10) = rx1683_cur."!mark_fail"(0)
    lt rx1683_pos, -1, rx1683_done
    eq rx1683_pos, -1, rx1683_fail
    jump $I10
  rx1683_done:
    rx1683_cur."!cursor_fail"()
    if_null rx1683_debug, debug_1129
    rx1683_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1129:
    .return (rx1683_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("174_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1691 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P1692, "ResizablePMCArray"
    push $P1692, $P1691
    .return ($P1692)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("175_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 757
    new $P1694, "Undef"
    .lex "$*OUTERPACKAGE", $P1694
.annotate 'line', 758
    new $P1695, "Undef"
    .lex "$*PKGDECL", $P1695
.annotate 'line', 438
    .local string rx1696_tgt
    .local int rx1696_pos
    .local int rx1696_off
    .local int rx1696_eos
    .local int rx1696_rep
    .local pmc rx1696_cur
    .local pmc rx1696_debug
    (rx1696_cur, rx1696_pos, rx1696_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1696_cur
    .local pmc match
    .lex "$/", match
    length rx1696_eos, rx1696_tgt
    gt rx1696_pos, rx1696_eos, rx1696_done
    set rx1696_off, 0
    lt rx1696_pos, 2, rx1696_start
    sub rx1696_off, rx1696_pos, 1
    substr rx1696_tgt, rx1696_tgt, rx1696_off
  rx1696_start:
    eq $I10, 1, rx1696_restart
    if_null rx1696_debug, debug_1130
    rx1696_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1697_done
    goto rxscan1697_scan
  rxscan1697_loop:
    (rx1696_pos) = rx1696_cur."from"()
    inc rx1696_pos
    rx1696_cur."!cursor_from"(rx1696_pos)
    ge rx1696_pos, rx1696_eos, rxscan1697_done
  rxscan1697_scan:
    set_addr $I10, rxscan1697_loop
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  rxscan1697_done:
.annotate 'line', 757
    rx1696_cur."!cursor_pos"(rx1696_pos)
    find_dynamic_lex $P1700, "$*PACKAGE"
    unless_null $P1700, vivify_1131
    get_hll_global $P1698, "GLOBAL"
    get_who $P1699, $P1698
    set $P1700, $P1699["$PACKAGE"]
    unless_null $P1700, vivify_1132
    die "Contextual $*PACKAGE not found"
  vivify_1132:
  vivify_1131:
    store_lex "$*OUTERPACKAGE", $P1700
.annotate 'line', 758
    rx1696_cur."!cursor_pos"(rx1696_pos)
    new $P1701, "String"
    assign $P1701, "role"
    store_lex "$*PKGDECL", $P1701
.annotate 'line', 759
  # rx subcapture "sym"
    set_addr $I10, rxcap_1702_fail
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  # rx literal  "role"
    add $I11, rx1696_pos, 4
    gt $I11, rx1696_eos, rx1696_fail
    sub $I11, rx1696_pos, rx1696_off
    substr $S10, rx1696_tgt, $I11, 4
    ne $S10, "role", rx1696_fail
    add rx1696_pos, 4
    set_addr $I10, rxcap_1702_fail
    ($I12, $I11) = rx1696_cur."!mark_peek"($I10)
    rx1696_cur."!cursor_pos"($I11)
    ($P10) = rx1696_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1696_pos, "")
    rx1696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1702_done
  rxcap_1702_fail:
    goto rx1696_fail
  rxcap_1702_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1696_cur."!cursor_pos"(rx1696_pos)
    $P10 = rx1696_cur."package_def"()
    unless $P10, rx1696_fail
    rx1696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1696_pos = $P10."pos"()
.annotate 'line', 756
  # rx pass
    rx1696_cur."!cursor_pass"(rx1696_pos, "package_declarator:sym<role>")
    if_null rx1696_debug, debug_1133
    rx1696_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1696_pos)
  debug_1133:
    .return (rx1696_cur)
  rx1696_restart:
.annotate 'line', 438
    if_null rx1696_debug, debug_1134
    rx1696_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1134:
  rx1696_fail:
    (rx1696_rep, rx1696_pos, $I10, $P10) = rx1696_cur."!mark_fail"(0)
    lt rx1696_pos, -1, rx1696_done
    eq rx1696_pos, -1, rx1696_fail
    jump $I10
  rx1696_done:
    rx1696_cur."!cursor_fail"()
    if_null rx1696_debug, debug_1135
    rx1696_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1135:
    .return (rx1696_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("176_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1704 = self."!PREFIX__!subrule"("package_def", "role")
    new $P1705, "ResizablePMCArray"
    push $P1705, $P1704
    .return ($P1705)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("177_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 762
    new $P1707, "Undef"
    .lex "$*OUTERPACKAGE", $P1707
.annotate 'line', 763
    new $P1708, "Undef"
    .lex "$*PKGDECL", $P1708
.annotate 'line', 438
    .local string rx1709_tgt
    .local int rx1709_pos
    .local int rx1709_off
    .local int rx1709_eos
    .local int rx1709_rep
    .local pmc rx1709_cur
    .local pmc rx1709_debug
    (rx1709_cur, rx1709_pos, rx1709_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1709_cur
    .local pmc match
    .lex "$/", match
    length rx1709_eos, rx1709_tgt
    gt rx1709_pos, rx1709_eos, rx1709_done
    set rx1709_off, 0
    lt rx1709_pos, 2, rx1709_start
    sub rx1709_off, rx1709_pos, 1
    substr rx1709_tgt, rx1709_tgt, rx1709_off
  rx1709_start:
    eq $I10, 1, rx1709_restart
    if_null rx1709_debug, debug_1136
    rx1709_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1710_done
    goto rxscan1710_scan
  rxscan1710_loop:
    (rx1709_pos) = rx1709_cur."from"()
    inc rx1709_pos
    rx1709_cur."!cursor_from"(rx1709_pos)
    ge rx1709_pos, rx1709_eos, rxscan1710_done
  rxscan1710_scan:
    set_addr $I10, rxscan1710_loop
    rx1709_cur."!mark_push"(0, rx1709_pos, $I10)
  rxscan1710_done:
.annotate 'line', 762
    rx1709_cur."!cursor_pos"(rx1709_pos)
    find_dynamic_lex $P1713, "$*PACKAGE"
    unless_null $P1713, vivify_1137
    get_hll_global $P1711, "GLOBAL"
    get_who $P1712, $P1711
    set $P1713, $P1712["$PACKAGE"]
    unless_null $P1713, vivify_1138
    die "Contextual $*PACKAGE not found"
  vivify_1138:
  vivify_1137:
    store_lex "$*OUTERPACKAGE", $P1713
.annotate 'line', 763
    rx1709_cur."!cursor_pos"(rx1709_pos)
    new $P1714, "String"
    assign $P1714, "native"
    store_lex "$*PKGDECL", $P1714
.annotate 'line', 764
  # rx subcapture "sym"
    set_addr $I10, rxcap_1715_fail
    rx1709_cur."!mark_push"(0, rx1709_pos, $I10)
  # rx literal  "native"
    add $I11, rx1709_pos, 6
    gt $I11, rx1709_eos, rx1709_fail
    sub $I11, rx1709_pos, rx1709_off
    substr $S10, rx1709_tgt, $I11, 6
    ne $S10, "native", rx1709_fail
    add rx1709_pos, 6
    set_addr $I10, rxcap_1715_fail
    ($I12, $I11) = rx1709_cur."!mark_peek"($I10)
    rx1709_cur."!cursor_pos"($I11)
    ($P10) = rx1709_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1709_pos, "")
    rx1709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1715_done
  rxcap_1715_fail:
    goto rx1709_fail
  rxcap_1715_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1709_cur."!cursor_pos"(rx1709_pos)
    $P10 = rx1709_cur."package_def"()
    unless $P10, rx1709_fail
    rx1709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1709_pos = $P10."pos"()
.annotate 'line', 761
  # rx pass
    rx1709_cur."!cursor_pass"(rx1709_pos, "package_declarator:sym<native>")
    if_null rx1709_debug, debug_1139
    rx1709_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1709_pos)
  debug_1139:
    .return (rx1709_cur)
  rx1709_restart:
.annotate 'line', 438
    if_null rx1709_debug, debug_1140
    rx1709_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1140:
  rx1709_fail:
    (rx1709_rep, rx1709_pos, $I10, $P10) = rx1709_cur."!mark_fail"(0)
    lt rx1709_pos, -1, rx1709_done
    eq rx1709_pos, -1, rx1709_fail
    jump $I10
  rx1709_done:
    rx1709_cur."!cursor_fail"()
    if_null rx1709_debug, debug_1141
    rx1709_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1141:
    .return (rx1709_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("178_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1717 = self."!PREFIX__!subrule"("package_def", "native")
    new $P1718, "ResizablePMCArray"
    push $P1718, $P1717
    .return ($P1718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<stub>"  :subid("179_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 767
    new $P1720, "Undef"
    .lex "$*OUTERPACKAGE", $P1720
.annotate 'line', 768
    new $P1721, "Undef"
    .lex "$*PKGDECL", $P1721
.annotate 'line', 438
    .local string rx1722_tgt
    .local int rx1722_pos
    .local int rx1722_off
    .local int rx1722_eos
    .local int rx1722_rep
    .local pmc rx1722_cur
    .local pmc rx1722_debug
    (rx1722_cur, rx1722_pos, rx1722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1722_cur
    .local pmc match
    .lex "$/", match
    length rx1722_eos, rx1722_tgt
    gt rx1722_pos, rx1722_eos, rx1722_done
    set rx1722_off, 0
    lt rx1722_pos, 2, rx1722_start
    sub rx1722_off, rx1722_pos, 1
    substr rx1722_tgt, rx1722_tgt, rx1722_off
  rx1722_start:
    eq $I10, 1, rx1722_restart
    if_null rx1722_debug, debug_1142
    rx1722_cur."!cursor_debug"("START", "package_declarator:sym<stub>")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1723_done
    goto rxscan1723_scan
  rxscan1723_loop:
    (rx1722_pos) = rx1722_cur."from"()
    inc rx1722_pos
    rx1722_cur."!cursor_from"(rx1722_pos)
    ge rx1722_pos, rx1722_eos, rxscan1723_done
  rxscan1723_scan:
    set_addr $I10, rxscan1723_loop
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  rxscan1723_done:
.annotate 'line', 766
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
.annotate 'line', 767
    rx1722_cur."!cursor_pos"(rx1722_pos)
    find_dynamic_lex $P1727, "$*PACKAGE"
    unless_null $P1727, vivify_1143
    get_hll_global $P1725, "GLOBAL"
    get_who $P1726, $P1725
    set $P1727, $P1726["$PACKAGE"]
    unless_null $P1727, vivify_1144
    die "Contextual $*PACKAGE not found"
  vivify_1144:
  vivify_1143:
    store_lex "$*OUTERPACKAGE", $P1727
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
.annotate 'line', 768
    rx1722_cur."!cursor_pos"(rx1722_pos)
    new $P1729, "String"
    assign $P1729, "stub"
    store_lex "$*PKGDECL", $P1729
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
.annotate 'line', 769
  # rx subcapture "sym"
    set_addr $I10, rxcap_1731_fail
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  # rx literal  "stub"
    add $I11, rx1722_pos, 4
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    substr $S10, rx1722_tgt, $I11, 4
    ne $S10, "stub", rx1722_fail
    add rx1722_pos, 4
    set_addr $I10, rxcap_1731_fail
    ($I12, $I11) = rx1722_cur."!mark_peek"($I10)
    rx1722_cur."!cursor_pos"($I11)
    ($P10) = rx1722_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1722_pos, "")
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1731_done
  rxcap_1731_fail:
    goto rx1722_fail
  rxcap_1731_done:
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."name"()
    unless $P10, rx1722_fail
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1722_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
.annotate 'line', 770
  # rx literal  "metaclass"
    add $I11, rx1722_pos, 9
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    substr $S10, rx1722_tgt, $I11, 9
    ne $S10, "metaclass", rx1722_fail
    add rx1722_pos, 9
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."name"()
    unless $P10, rx1722_fail
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("metaclass")
    rx1722_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
.annotate 'line', 771
  # rx literal  "{"
    add $I11, rx1722_pos, 1
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    ord $I11, rx1722_tgt, $I11
    ne $I11, 123, rx1722_fail
    add rx1722_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
  # rx literal  "..."
    add $I11, rx1722_pos, 3
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    substr $S10, rx1722_tgt, $I11, 3
    ne $S10, "...", rx1722_fail
    add rx1722_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1722_pos, 1
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    ord $I11, rx1722_tgt, $I11
    ne $I11, 125, rx1722_fail
    add rx1722_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."ws"()
    unless $P10, rx1722_fail
    rx1722_pos = $P10."pos"()
.annotate 'line', 766
  # rx pass
    rx1722_cur."!cursor_pass"(rx1722_pos, "package_declarator:sym<stub>")
    if_null rx1722_debug, debug_1145
    rx1722_cur."!cursor_debug"("PASS", "package_declarator:sym<stub>", " at pos=", rx1722_pos)
  debug_1145:
    .return (rx1722_cur)
  rx1722_restart:
.annotate 'line', 438
    if_null rx1722_debug, debug_1146
    rx1722_cur."!cursor_debug"("NEXT", "package_declarator:sym<stub>")
  debug_1146:
  rx1722_fail:
    (rx1722_rep, rx1722_pos, $I10, $P10) = rx1722_cur."!mark_fail"(0)
    lt rx1722_pos, -1, rx1722_done
    eq rx1722_pos, -1, rx1722_fail
    jump $I10
  rx1722_done:
    rx1722_cur."!cursor_fail"()
    if_null rx1722_debug, debug_1147
    rx1722_cur."!cursor_debug"("FAIL", "package_declarator:sym<stub>")
  debug_1147:
    .return (rx1722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<stub>"  :subid("180_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1740 = self."!PREFIX__!subrule"("ws", "")
    new $P1741, "ResizablePMCArray"
    push $P1741, $P1740
    .return ($P1741)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("181_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1762 = "182_1305640955.436" 
    capture_lex $P1762
.annotate 'line', 775
    new $P1743, "Undef"
    .lex "$*PACKAGE", $P1743
.annotate 'line', 438
    .local string rx1744_tgt
    .local int rx1744_pos
    .local int rx1744_off
    .local int rx1744_eos
    .local int rx1744_rep
    .local pmc rx1744_cur
    .local pmc rx1744_debug
    (rx1744_cur, rx1744_pos, rx1744_tgt, $I10) = self."!cursor_start"()
    rx1744_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1744_cur
    .local pmc match
    .lex "$/", match
    length rx1744_eos, rx1744_tgt
    gt rx1744_pos, rx1744_eos, rx1744_done
    set rx1744_off, 0
    lt rx1744_pos, 2, rx1744_start
    sub rx1744_off, rx1744_pos, 1
    substr rx1744_tgt, rx1744_tgt, rx1744_off
  rx1744_start:
    eq $I10, 1, rx1744_restart
    if_null rx1744_debug, debug_1148
    rx1744_cur."!cursor_debug"("START", "package_def")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1745_done
    goto rxscan1745_scan
  rxscan1745_loop:
    (rx1744_pos) = rx1744_cur."from"()
    inc rx1744_pos
    rx1744_cur."!cursor_from"(rx1744_pos)
    ge rx1744_pos, rx1744_eos, rxscan1745_done
  rxscan1745_scan:
    set_addr $I10, rxscan1745_loop
    rx1744_cur."!mark_push"(0, rx1744_pos, $I10)
  rxscan1745_done:
.annotate 'line', 774
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
.annotate 'line', 775
    rx1744_cur."!cursor_pos"(rx1744_pos)
    find_lex $P1749, "$*PACKAGE"
    unless_null $P1749, vivify_1149
    get_hll_global $P1747, "GLOBAL"
    get_who $P1748, $P1747
    set $P1749, $P1748["$PACKAGE"]
    unless_null $P1749, vivify_1150
    die "Contextual $*PACKAGE not found"
  vivify_1150:
  vivify_1149:
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
.annotate 'line', 777
  # rx subrule "name" subtype=capture negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."name"()
    unless $P10, rx1744_fail
    rx1744_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1744_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
.annotate 'line', 778
  # rx rxquantr1752 ** 0..1
    set_addr $I10, rxquantr1752_done
    rx1744_cur."!mark_push"(0, rx1744_pos, $I10)
  rxquantr1752_loop:
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1744_pos, 2
    gt $I11, rx1744_eos, rx1744_fail
    sub $I11, rx1744_pos, rx1744_off
    substr $S10, rx1744_tgt, $I11, 2
    ne $S10, "is", rx1744_fail
    add rx1744_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1744_pos, 5
    gt $I11, rx1744_eos, rx1744_fail
    sub $I11, rx1744_pos, rx1744_off
    substr $S10, rx1744_tgt, $I11, 5
    ne $S10, "repr(", rx1744_fail
    add rx1744_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."quote_EXPR"()
    unless $P10, rx1744_fail
    rx1744_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1744_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1744_pos, 1
    gt $I11, rx1744_eos, rx1744_fail
    sub $I11, rx1744_pos, rx1744_off
    ord $I11, rx1744_tgt, $I11
    ne $I11, 41, rx1744_fail
    add rx1744_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
    set_addr $I10, rxquantr1752_done
    (rx1744_rep) = rx1744_cur."!mark_commit"($I10)
  rxquantr1752_done:
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
.annotate 'line', 780
    rx1744_cur."!cursor_pos"(rx1744_pos)
    find_lex $P1759, unicode:"$\x{a2}"
    $P1760 = $P1759."MATCH"()
    store_lex "$/", $P1760
    .const 'Sub' $P1762 = "182_1305640955.436" 
    capture_lex $P1762
    $P1884 = $P1762()
.annotate 'line', 806
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
.annotate 'line', 808
  # rx rxquantr1886 ** 0..1
    set_addr $I10, rxquantr1886_done
    rx1744_cur."!mark_push"(0, rx1744_pos, $I10)
  rxquantr1886_loop:
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1744_pos, 2
    gt $I11, rx1744_eos, rx1744_fail
    sub $I11, rx1744_pos, rx1744_off
    substr $S10, rx1744_tgt, $I11, 2
    ne $S10, "is", rx1744_fail
    add rx1744_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."name"()
    unless $P10, rx1744_fail
    rx1744_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1744_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
    set_addr $I10, rxquantr1886_done
    (rx1744_rep) = rx1744_cur."!mark_commit"($I10)
  rxquantr1886_done:
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
.annotate 'line', 809
  # rx rxquantr1891 ** 0..*
    set_addr $I10, rxquantr1891_done
    rx1744_cur."!mark_push"(0, rx1744_pos, $I10)
  rxquantr1891_loop:
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1744_pos, 4
    gt $I11, rx1744_eos, rx1744_fail
    sub $I11, rx1744_pos, rx1744_off
    substr $S10, rx1744_tgt, $I11, 4
    ne $S10, "does", rx1744_fail
    add rx1744_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."name"()
    unless $P10, rx1744_fail
    rx1744_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1744_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
    set_addr $I10, rxquantr1891_done
    (rx1744_rep) = rx1744_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1891_done
    rx1744_cur."!mark_push"(rx1744_rep, rx1744_pos, $I10)
    goto rxquantr1891_loop
  rxquantr1891_done:
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  alt1896_0:
.annotate 'line', 810
    set_addr $I10, alt1896_1
    rx1744_cur."!mark_push"(0, rx1744_pos, $I10)
.annotate 'line', 811
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1744_pos, 1
    gt $I11, rx1744_eos, rx1744_fail
    sub $I11, rx1744_pos, rx1744_off
    ord $I11, rx1744_tgt, $I11
    ne $I11, 59, rx1744_fail
    add rx1744_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."comp_unit"()
    unless $P10, rx1744_fail
    rx1744_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1744_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
    goto alt1896_end
  alt1896_1:
    set_addr $I10, alt1896_2
    rx1744_cur."!mark_push"(0, rx1744_pos, $I10)
.annotate 'line', 812
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1744_pos, rx1744_off
    substr $S10, rx1744_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1744_fail
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."block"()
    unless $P10, rx1744_fail
    rx1744_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1744_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
    goto alt1896_end
  alt1896_2:
.annotate 'line', 813
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."panic"("Malformed package declaration")
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
  alt1896_end:
.annotate 'line', 814
  # rx subrule "ws" subtype=method negate=
    rx1744_cur."!cursor_pos"(rx1744_pos)
    $P10 = rx1744_cur."ws"()
    unless $P10, rx1744_fail
    rx1744_pos = $P10."pos"()
.annotate 'line', 774
  # rx pass
    rx1744_cur."!cursor_pass"(rx1744_pos, "package_def")
    if_null rx1744_debug, debug_1218
    rx1744_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1744_pos)
  debug_1218:
    .return (rx1744_cur)
  rx1744_restart:
.annotate 'line', 438
    if_null rx1744_debug, debug_1219
    rx1744_cur."!cursor_debug"("NEXT", "package_def")
  debug_1219:
  rx1744_fail:
    (rx1744_rep, rx1744_pos, $I10, $P10) = rx1744_cur."!mark_fail"(0)
    lt rx1744_pos, -1, rx1744_done
    eq rx1744_pos, -1, rx1744_fail
    jump $I10
  rx1744_done:
    rx1744_cur."!cursor_fail"()
    if_null rx1744_debug, debug_1220
    rx1744_cur."!cursor_debug"("FAIL", "package_def")
  debug_1220:
    .return (rx1744_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1761"  :anon :subid("182_1305640955.436") :outer("181_1305640955.436")
.annotate 'line', 783
    $P1763 = root_new ['parrot';'Hash']
    .lex "%args", $P1763
.annotate 'line', 780
    find_lex $P1764, "%args"
    unless_null $P1764, vivify_1151
    $P1764 = root_new ['parrot';'Hash']
  vivify_1151:
.annotate 'line', 784
    find_lex $P1765, "$/"
    unless_null $P1765, vivify_1152
    $P1765 = root_new ['parrot';'Hash']
  vivify_1152:
    set $P1766, $P1765["name"]
    unless_null $P1766, vivify_1153
    new $P1766, "Undef"
  vivify_1153:
    set $S1767, $P1766
    new $P1768, 'String'
    set $P1768, $S1767
    find_lex $P1769, "%args"
    unless_null $P1769, vivify_1154
    $P1769 = root_new ['parrot';'Hash']
    store_lex "%args", $P1769
  vivify_1154:
    set $P1769["name"], $P1768
.annotate 'line', 785
    find_lex $P1771, "$/"
    unless_null $P1771, vivify_1155
    $P1771 = root_new ['parrot';'Hash']
  vivify_1155:
    set $P1772, $P1771["repr"]
    unless_null $P1772, vivify_1156
    new $P1772, "Undef"
  vivify_1156:
    unless $P1772, if_1770_end
.annotate 'line', 786
    find_lex $P1773, "$/"
    unless_null $P1773, vivify_1157
    $P1773 = root_new ['parrot';'Hash']
  vivify_1157:
    set $P1774, $P1773["repr"]
    unless_null $P1774, vivify_1158
    $P1774 = root_new ['parrot';'ResizablePMCArray']
  vivify_1158:
    set $P1775, $P1774[0]
    unless_null $P1775, vivify_1159
    $P1775 = root_new ['parrot';'Hash']
  vivify_1159:
    set $P1776, $P1775["quote_delimited"]
    unless_null $P1776, vivify_1160
    $P1776 = root_new ['parrot';'Hash']
  vivify_1160:
    set $P1777, $P1776["quote_atom"]
    unless_null $P1777, vivify_1161
    $P1777 = root_new ['parrot';'ResizablePMCArray']
  vivify_1161:
    set $P1778, $P1777[0]
    unless_null $P1778, vivify_1162
    new $P1778, "Undef"
  vivify_1162:
    set $S1779, $P1778
    new $P1780, 'String'
    set $P1780, $S1779
    find_lex $P1781, "%args"
    unless_null $P1781, vivify_1163
    $P1781 = root_new ['parrot';'Hash']
    store_lex "%args", $P1781
  vivify_1163:
    set $P1781["repr"], $P1780
  if_1770_end:
.annotate 'line', 788
    find_dynamic_lex $P1784, "$*SC"
    unless_null $P1784, vivify_1164
    get_hll_global $P1782, "GLOBAL"
    get_who $P1783, $P1782
    set $P1784, $P1783["$SC"]
    unless_null $P1784, vivify_1165
    die "Contextual $*SC not found"
  vivify_1165:
  vivify_1164:
    find_dynamic_lex $P1787, "$*PKGDECL"
    unless_null $P1787, vivify_1166
    get_hll_global $P1785, "GLOBAL"
    get_who $P1786, $P1785
    set $P1787, $P1786["$PKGDECL"]
    unless_null $P1787, vivify_1167
    die "Contextual $*PKGDECL not found"
  vivify_1167:
  vivify_1166:
    find_dynamic_lex $P1790, "%*HOW"
    unless_null $P1790, vivify_1168
    get_hll_global $P1788, "GLOBAL"
    get_who $P1789, $P1788
    set $P1790, $P1789["%HOW"]
    unless_null $P1790, vivify_1169
    die "Contextual %*HOW not found"
  vivify_1169:
  vivify_1168:
    set $P1791, $P1790[$P1787]
    unless_null $P1791, vivify_1170
    new $P1791, "Undef"
  vivify_1170:
    find_lex $P1792, "%args"
    unless_null $P1792, vivify_1171
    $P1792 = root_new ['parrot';'Hash']
  vivify_1171:
    $P1793 = $P1784."pkg_create_mo"($P1791, $P1792 :flat)
    store_dynamic_lex "$*PACKAGE", $P1793
.annotate 'line', 791
    find_dynamic_lex $P1800, "$*SCOPE"
    unless_null $P1800, vivify_1172
    get_hll_global $P1798, "GLOBAL"
    get_who $P1799, $P1798
    set $P1800, $P1799["$SCOPE"]
    unless_null $P1800, vivify_1173
    die "Contextual $*SCOPE not found"
  vivify_1173:
  vivify_1172:
    set $S1801, $P1800
    iseq $I1802, $S1801, "our"
    unless $I1802, unless_1797
    new $P1796, 'Integer'
    set $P1796, $I1802
    goto unless_1797_end
  unless_1797:
    find_dynamic_lex $P1805, "$*SCOPE"
    unless_null $P1805, vivify_1174
    get_hll_global $P1803, "GLOBAL"
    get_who $P1804, $P1803
    set $P1805, $P1804["$SCOPE"]
    unless_null $P1805, vivify_1175
    die "Contextual $*SCOPE not found"
  vivify_1175:
  vivify_1174:
    set $S1806, $P1805
    iseq $I1807, $S1806, ""
    new $P1796, 'Integer'
    set $P1796, $I1807
  unless_1797_end:
    if $P1796, if_1795
.annotate 'line', 797
    find_dynamic_lex $P1848, "$*SCOPE"
    unless_null $P1848, vivify_1176
    get_hll_global $P1846, "GLOBAL"
    get_who $P1847, $P1846
    set $P1848, $P1847["$SCOPE"]
    unless_null $P1848, vivify_1177
    die "Contextual $*SCOPE not found"
  vivify_1177:
  vivify_1176:
    set $S1849, $P1848
    iseq $I1850, $S1849, "my"
    if $I1850, if_1845
.annotate 'line', 804
    find_lex $P1877, "$/"
    unless_null $P1877, vivify_1178
    new $P1877, "Undef"
  vivify_1178:
    $P1878 = $P1877."CURSOR"()
    find_dynamic_lex $P1881, "$*SCOPE"
    unless_null $P1881, vivify_1179
    get_hll_global $P1879, "GLOBAL"
    get_who $P1880, $P1879
    set $P1881, $P1880["$SCOPE"]
    unless_null $P1881, vivify_1180
    die "Contextual $*SCOPE not found"
  vivify_1180:
  vivify_1179:
    concat $P1882, $P1881, " scoped packages are not supported"
    $P1883 = $P1878."panic"($P1882)
.annotate 'line', 803
    set $P1844, $P1883
.annotate 'line', 797
    goto if_1845_end
  if_1845:
.annotate 'line', 798
    find_lex $P1852, "$/"
    unless_null $P1852, vivify_1181
    $P1852 = root_new ['parrot';'Hash']
  vivify_1181:
    set $P1853, $P1852["name"]
    unless_null $P1853, vivify_1182
    $P1853 = root_new ['parrot';'Hash']
  vivify_1182:
    set $P1854, $P1853["identifier"]
    unless_null $P1854, vivify_1183
    new $P1854, "Undef"
  vivify_1183:
    set $N1855, $P1854
    isne $I1856, $N1855, 1.0
    unless $I1856, if_1851_end
.annotate 'line', 799
    find_lex $P1857, "$/"
    unless_null $P1857, vivify_1184
    $P1857 = root_new ['parrot';'Hash']
  vivify_1184:
    set $P1858, $P1857["name"]
    unless_null $P1858, vivify_1185
    new $P1858, "Undef"
  vivify_1185:
    $P1859 = $P1858."CURSOR"()
    $P1859."panic"("A my scoped package cannot have a multi-part name yet")
  if_1851_end:
.annotate 'line', 801
    find_dynamic_lex $P1862, "$*SC"
    unless_null $P1862, vivify_1186
    get_hll_global $P1860, "GLOBAL"
    get_who $P1861, $P1860
    set $P1862, $P1861["$SC"]
    unless_null $P1862, vivify_1187
    die "Contextual $*SC not found"
  vivify_1187:
  vivify_1186:
    get_hll_global $P1863, "GLOBAL"
    nqp_get_package_through_who $P1864, $P1863, "NQP"
    nqp_get_package_through_who $P1865, $P1864, "Actions"
    get_who $P1866, $P1865
    set $P1867, $P1866["@BLOCK"]
    unless_null $P1867, vivify_1188
    $P1867 = root_new ['parrot';'ResizablePMCArray']
  vivify_1188:
    set $P1868, $P1867[0]
    unless_null $P1868, vivify_1189
    new $P1868, "Undef"
  vivify_1189:
    find_lex $P1869, "$/"
    unless_null $P1869, vivify_1190
    $P1869 = root_new ['parrot';'Hash']
  vivify_1190:
    set $P1870, $P1869["name"]
    unless_null $P1870, vivify_1191
    $P1870 = root_new ['parrot';'Hash']
  vivify_1191:
    set $P1871, $P1870["identifier"]
    unless_null $P1871, vivify_1192
    $P1871 = root_new ['parrot';'ResizablePMCArray']
  vivify_1192:
    set $P1872, $P1871[0]
    unless_null $P1872, vivify_1193
    new $P1872, "Undef"
  vivify_1193:
    find_dynamic_lex $P1875, "$*PACKAGE"
    unless_null $P1875, vivify_1194
    get_hll_global $P1873, "GLOBAL"
    get_who $P1874, $P1873
    set $P1875, $P1874["$PACKAGE"]
    unless_null $P1875, vivify_1195
    die "Contextual $*PACKAGE not found"
  vivify_1195:
  vivify_1194:
    $P1876 = $P1862."install_lexical_symbol"($P1868, $P1872, $P1875)
.annotate 'line', 797
    set $P1844, $P1876
  if_1845_end:
    set $P1794, $P1844
.annotate 'line', 791
    goto if_1795_end
  if_1795:
.annotate 'line', 792
    find_dynamic_lex $P1810, "$*SC"
    unless_null $P1810, vivify_1196
    get_hll_global $P1808, "GLOBAL"
    get_who $P1809, $P1808
    set $P1810, $P1809["$SC"]
    unless_null $P1810, vivify_1197
    die "Contextual $*SC not found"
  vivify_1197:
  vivify_1196:
    find_dynamic_lex $P1813, "$*OUTERPACKAGE"
    unless_null $P1813, vivify_1198
    get_hll_global $P1811, "GLOBAL"
    get_who $P1812, $P1811
    set $P1813, $P1812["$OUTERPACKAGE"]
    unless_null $P1813, vivify_1199
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1199:
  vivify_1198:
    find_lex $P1814, "$/"
    unless_null $P1814, vivify_1200
    $P1814 = root_new ['parrot';'Hash']
  vivify_1200:
    set $P1815, $P1814["name"]
    unless_null $P1815, vivify_1201
    $P1815 = root_new ['parrot';'Hash']
  vivify_1201:
    set $P1816, $P1815["identifier"]
    unless_null $P1816, vivify_1202
    new $P1816, "Undef"
  vivify_1202:
    find_dynamic_lex $P1819, "$*PACKAGE"
    unless_null $P1819, vivify_1203
    get_hll_global $P1817, "GLOBAL"
    get_who $P1818, $P1817
    set $P1819, $P1818["$PACKAGE"]
    unless_null $P1819, vivify_1204
    die "Contextual $*PACKAGE not found"
  vivify_1204:
  vivify_1203:
    $P1810."install_package_symbol"($P1813, $P1816, $P1819)
.annotate 'line', 793
    find_lex $P1822, "$/"
    unless_null $P1822, vivify_1205
    $P1822 = root_new ['parrot';'Hash']
  vivify_1205:
    set $P1823, $P1822["name"]
    unless_null $P1823, vivify_1206
    $P1823 = root_new ['parrot';'Hash']
  vivify_1206:
    set $P1824, $P1823["identifier"]
    unless_null $P1824, vivify_1207
    new $P1824, "Undef"
  vivify_1207:
    set $N1825, $P1824
    iseq $I1826, $N1825, 1.0
    if $I1826, if_1821
    new $P1820, 'Integer'
    set $P1820, $I1826
    goto if_1821_end
  if_1821:
.annotate 'line', 794
    find_dynamic_lex $P1829, "$*SC"
    unless_null $P1829, vivify_1208
    get_hll_global $P1827, "GLOBAL"
    get_who $P1828, $P1827
    set $P1829, $P1828["$SC"]
    unless_null $P1829, vivify_1209
    die "Contextual $*SC not found"
  vivify_1209:
  vivify_1208:
    get_hll_global $P1830, "GLOBAL"
    nqp_get_package_through_who $P1831, $P1830, "NQP"
    nqp_get_package_through_who $P1832, $P1831, "Actions"
    get_who $P1833, $P1832
    set $P1834, $P1833["@BLOCK"]
    unless_null $P1834, vivify_1210
    $P1834 = root_new ['parrot';'ResizablePMCArray']
  vivify_1210:
    set $P1835, $P1834[0]
    unless_null $P1835, vivify_1211
    new $P1835, "Undef"
  vivify_1211:
    find_lex $P1836, "$/"
    unless_null $P1836, vivify_1212
    $P1836 = root_new ['parrot';'Hash']
  vivify_1212:
    set $P1837, $P1836["name"]
    unless_null $P1837, vivify_1213
    $P1837 = root_new ['parrot';'Hash']
  vivify_1213:
    set $P1838, $P1837["identifier"]
    unless_null $P1838, vivify_1214
    $P1838 = root_new ['parrot';'ResizablePMCArray']
  vivify_1214:
    set $P1839, $P1838[0]
    unless_null $P1839, vivify_1215
    new $P1839, "Undef"
  vivify_1215:
    find_dynamic_lex $P1842, "$*PACKAGE"
    unless_null $P1842, vivify_1216
    get_hll_global $P1840, "GLOBAL"
    get_who $P1841, $P1840
    set $P1842, $P1841["$PACKAGE"]
    unless_null $P1842, vivify_1217
    die "Contextual $*PACKAGE not found"
  vivify_1217:
  vivify_1216:
    $P1843 = $P1829."install_lexical_symbol"($P1835, $P1839, $P1842)
.annotate 'line', 793
    set $P1820, $P1843
  if_1821_end:
.annotate 'line', 791
    set $P1794, $P1820
  if_1795_end:
.annotate 'line', 780
    .return ($P1794)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("183_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1907 = self."!PREFIX__!subrule"("ws", "")
    new $P1908, "ResizablePMCArray"
    push $P1908, $P1907
    .return ($P1908)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("184_1305640955.436")
    .param pmc param_1910
.annotate 'line', 817
    .lex "self", param_1910
    $P1911 = param_1910."!protoregex"("scope_declarator")
    .return ($P1911)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("185_1305640955.436")
    .param pmc param_1913
.annotate 'line', 817
    .lex "self", param_1913
    $P1914 = param_1913."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1914)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("186_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1916_tgt
    .local int rx1916_pos
    .local int rx1916_off
    .local int rx1916_eos
    .local int rx1916_rep
    .local pmc rx1916_cur
    .local pmc rx1916_debug
    (rx1916_cur, rx1916_pos, rx1916_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1916_cur
    .local pmc match
    .lex "$/", match
    length rx1916_eos, rx1916_tgt
    gt rx1916_pos, rx1916_eos, rx1916_done
    set rx1916_off, 0
    lt rx1916_pos, 2, rx1916_start
    sub rx1916_off, rx1916_pos, 1
    substr rx1916_tgt, rx1916_tgt, rx1916_off
  rx1916_start:
    eq $I10, 1, rx1916_restart
    if_null rx1916_debug, debug_1221
    rx1916_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1221:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1917_done
    goto rxscan1917_scan
  rxscan1917_loop:
    (rx1916_pos) = rx1916_cur."from"()
    inc rx1916_pos
    rx1916_cur."!cursor_from"(rx1916_pos)
    ge rx1916_pos, rx1916_eos, rxscan1917_done
  rxscan1917_scan:
    set_addr $I10, rxscan1917_loop
    rx1916_cur."!mark_push"(0, rx1916_pos, $I10)
  rxscan1917_done:
.annotate 'line', 818
  # rx subcapture "sym"
    set_addr $I10, rxcap_1918_fail
    rx1916_cur."!mark_push"(0, rx1916_pos, $I10)
  # rx literal  "my"
    add $I11, rx1916_pos, 2
    gt $I11, rx1916_eos, rx1916_fail
    sub $I11, rx1916_pos, rx1916_off
    substr $S10, rx1916_tgt, $I11, 2
    ne $S10, "my", rx1916_fail
    add rx1916_pos, 2
    set_addr $I10, rxcap_1918_fail
    ($I12, $I11) = rx1916_cur."!mark_peek"($I10)
    rx1916_cur."!cursor_pos"($I11)
    ($P10) = rx1916_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1916_pos, "")
    rx1916_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1918_done
  rxcap_1918_fail:
    goto rx1916_fail
  rxcap_1918_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1916_cur."!cursor_pos"(rx1916_pos)
    $P10 = rx1916_cur."scoped"("my")
    unless $P10, rx1916_fail
    rx1916_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1916_pos = $P10."pos"()
  # rx pass
    rx1916_cur."!cursor_pass"(rx1916_pos, "scope_declarator:sym<my>")
    if_null rx1916_debug, debug_1222
    rx1916_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1916_pos)
  debug_1222:
    .return (rx1916_cur)
  rx1916_restart:
.annotate 'line', 438
    if_null rx1916_debug, debug_1223
    rx1916_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1223:
  rx1916_fail:
    (rx1916_rep, rx1916_pos, $I10, $P10) = rx1916_cur."!mark_fail"(0)
    lt rx1916_pos, -1, rx1916_done
    eq rx1916_pos, -1, rx1916_fail
    jump $I10
  rx1916_done:
    rx1916_cur."!cursor_fail"()
    if_null rx1916_debug, debug_1224
    rx1916_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1224:
    .return (rx1916_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("187_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1920 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1921, "ResizablePMCArray"
    push $P1921, $P1920
    .return ($P1921)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("188_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1923_tgt
    .local int rx1923_pos
    .local int rx1923_off
    .local int rx1923_eos
    .local int rx1923_rep
    .local pmc rx1923_cur
    .local pmc rx1923_debug
    (rx1923_cur, rx1923_pos, rx1923_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1923_cur
    .local pmc match
    .lex "$/", match
    length rx1923_eos, rx1923_tgt
    gt rx1923_pos, rx1923_eos, rx1923_done
    set rx1923_off, 0
    lt rx1923_pos, 2, rx1923_start
    sub rx1923_off, rx1923_pos, 1
    substr rx1923_tgt, rx1923_tgt, rx1923_off
  rx1923_start:
    eq $I10, 1, rx1923_restart
    if_null rx1923_debug, debug_1225
    rx1923_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1225:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1924_done
    goto rxscan1924_scan
  rxscan1924_loop:
    (rx1923_pos) = rx1923_cur."from"()
    inc rx1923_pos
    rx1923_cur."!cursor_from"(rx1923_pos)
    ge rx1923_pos, rx1923_eos, rxscan1924_done
  rxscan1924_scan:
    set_addr $I10, rxscan1924_loop
    rx1923_cur."!mark_push"(0, rx1923_pos, $I10)
  rxscan1924_done:
.annotate 'line', 819
  # rx subcapture "sym"
    set_addr $I10, rxcap_1925_fail
    rx1923_cur."!mark_push"(0, rx1923_pos, $I10)
  # rx literal  "our"
    add $I11, rx1923_pos, 3
    gt $I11, rx1923_eos, rx1923_fail
    sub $I11, rx1923_pos, rx1923_off
    substr $S10, rx1923_tgt, $I11, 3
    ne $S10, "our", rx1923_fail
    add rx1923_pos, 3
    set_addr $I10, rxcap_1925_fail
    ($I12, $I11) = rx1923_cur."!mark_peek"($I10)
    rx1923_cur."!cursor_pos"($I11)
    ($P10) = rx1923_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1923_pos, "")
    rx1923_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1925_done
  rxcap_1925_fail:
    goto rx1923_fail
  rxcap_1925_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1923_cur."!cursor_pos"(rx1923_pos)
    $P10 = rx1923_cur."scoped"("our")
    unless $P10, rx1923_fail
    rx1923_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1923_pos = $P10."pos"()
  # rx pass
    rx1923_cur."!cursor_pass"(rx1923_pos, "scope_declarator:sym<our>")
    if_null rx1923_debug, debug_1226
    rx1923_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1923_pos)
  debug_1226:
    .return (rx1923_cur)
  rx1923_restart:
.annotate 'line', 438
    if_null rx1923_debug, debug_1227
    rx1923_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1227:
  rx1923_fail:
    (rx1923_rep, rx1923_pos, $I10, $P10) = rx1923_cur."!mark_fail"(0)
    lt rx1923_pos, -1, rx1923_done
    eq rx1923_pos, -1, rx1923_fail
    jump $I10
  rx1923_done:
    rx1923_cur."!cursor_fail"()
    if_null rx1923_debug, debug_1228
    rx1923_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1228:
    .return (rx1923_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("189_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1927 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1928, "ResizablePMCArray"
    push $P1928, $P1927
    .return ($P1928)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("190_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1930_tgt
    .local int rx1930_pos
    .local int rx1930_off
    .local int rx1930_eos
    .local int rx1930_rep
    .local pmc rx1930_cur
    .local pmc rx1930_debug
    (rx1930_cur, rx1930_pos, rx1930_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1930_cur
    .local pmc match
    .lex "$/", match
    length rx1930_eos, rx1930_tgt
    gt rx1930_pos, rx1930_eos, rx1930_done
    set rx1930_off, 0
    lt rx1930_pos, 2, rx1930_start
    sub rx1930_off, rx1930_pos, 1
    substr rx1930_tgt, rx1930_tgt, rx1930_off
  rx1930_start:
    eq $I10, 1, rx1930_restart
    if_null rx1930_debug, debug_1229
    rx1930_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1229:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1931_done
    goto rxscan1931_scan
  rxscan1931_loop:
    (rx1930_pos) = rx1930_cur."from"()
    inc rx1930_pos
    rx1930_cur."!cursor_from"(rx1930_pos)
    ge rx1930_pos, rx1930_eos, rxscan1931_done
  rxscan1931_scan:
    set_addr $I10, rxscan1931_loop
    rx1930_cur."!mark_push"(0, rx1930_pos, $I10)
  rxscan1931_done:
.annotate 'line', 820
  # rx subcapture "sym"
    set_addr $I10, rxcap_1932_fail
    rx1930_cur."!mark_push"(0, rx1930_pos, $I10)
  # rx literal  "has"
    add $I11, rx1930_pos, 3
    gt $I11, rx1930_eos, rx1930_fail
    sub $I11, rx1930_pos, rx1930_off
    substr $S10, rx1930_tgt, $I11, 3
    ne $S10, "has", rx1930_fail
    add rx1930_pos, 3
    set_addr $I10, rxcap_1932_fail
    ($I12, $I11) = rx1930_cur."!mark_peek"($I10)
    rx1930_cur."!cursor_pos"($I11)
    ($P10) = rx1930_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1930_pos, "")
    rx1930_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1932_done
  rxcap_1932_fail:
    goto rx1930_fail
  rxcap_1932_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1930_cur."!cursor_pos"(rx1930_pos)
    $P10 = rx1930_cur."scoped"("has")
    unless $P10, rx1930_fail
    rx1930_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1930_pos = $P10."pos"()
  # rx pass
    rx1930_cur."!cursor_pass"(rx1930_pos, "scope_declarator:sym<has>")
    if_null rx1930_debug, debug_1230
    rx1930_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1930_pos)
  debug_1230:
    .return (rx1930_cur)
  rx1930_restart:
.annotate 'line', 438
    if_null rx1930_debug, debug_1231
    rx1930_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1231:
  rx1930_fail:
    (rx1930_rep, rx1930_pos, $I10, $P10) = rx1930_cur."!mark_fail"(0)
    lt rx1930_pos, -1, rx1930_done
    eq rx1930_pos, -1, rx1930_fail
    jump $I10
  rx1930_done:
    rx1930_cur."!cursor_fail"()
    if_null rx1930_debug, debug_1232
    rx1930_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1232:
    .return (rx1930_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("191_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1934 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1935, "ResizablePMCArray"
    push $P1935, $P1934
    .return ($P1935)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("192_1305640955.436") :method :outer("39_1305640955.436")
    .param pmc param_1937
.annotate 'line', 822
    .lex "$*SCOPE", param_1937
.annotate 'line', 438
    .local string rx1938_tgt
    .local int rx1938_pos
    .local int rx1938_off
    .local int rx1938_eos
    .local int rx1938_rep
    .local pmc rx1938_cur
    .local pmc rx1938_debug
    (rx1938_cur, rx1938_pos, rx1938_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1938_cur
    .local pmc match
    .lex "$/", match
    length rx1938_eos, rx1938_tgt
    gt rx1938_pos, rx1938_eos, rx1938_done
    set rx1938_off, 0
    lt rx1938_pos, 2, rx1938_start
    sub rx1938_off, rx1938_pos, 1
    substr rx1938_tgt, rx1938_tgt, rx1938_off
  rx1938_start:
    eq $I10, 1, rx1938_restart
    if_null rx1938_debug, debug_1233
    rx1938_cur."!cursor_debug"("START", "scoped")
  debug_1233:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1939_done
    goto rxscan1939_scan
  rxscan1939_loop:
    (rx1938_pos) = rx1938_cur."from"()
    inc rx1938_pos
    rx1938_cur."!cursor_from"(rx1938_pos)
    ge rx1938_pos, rx1938_eos, rxscan1939_done
  rxscan1939_scan:
    set_addr $I10, rxscan1939_loop
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
  rxscan1939_done:
  alt1940_0:
.annotate 'line', 822
    set_addr $I10, alt1940_1
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
.annotate 'line', 823
  # rx subrule "ws" subtype=method negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."ws"()
    unless $P10, rx1938_fail
    rx1938_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."declarator"()
    unless $P10, rx1938_fail
    rx1938_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1938_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."ws"()
    unless $P10, rx1938_fail
    rx1938_pos = $P10."pos"()
    goto alt1940_end
  alt1940_1:
    set_addr $I10, alt1940_2
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
.annotate 'line', 824
  # rx subrule "ws" subtype=method negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."ws"()
    unless $P10, rx1938_fail
    rx1938_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."multi_declarator"()
    unless $P10, rx1938_fail
    rx1938_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1938_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."ws"()
    unless $P10, rx1938_fail
    rx1938_pos = $P10."pos"()
    goto alt1940_end
  alt1940_2:
.annotate 'line', 825
  # rx subrule "ws" subtype=method negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."ws"()
    unless $P10, rx1938_fail
    rx1938_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."package_declarator"()
    unless $P10, rx1938_fail
    rx1938_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1938_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."ws"()
    unless $P10, rx1938_fail
    rx1938_pos = $P10."pos"()
  alt1940_end:
.annotate 'line', 822
  # rx pass
    rx1938_cur."!cursor_pass"(rx1938_pos, "scoped")
    if_null rx1938_debug, debug_1234
    rx1938_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1938_pos)
  debug_1234:
    .return (rx1938_cur)
  rx1938_restart:
.annotate 'line', 438
    if_null rx1938_debug, debug_1235
    rx1938_cur."!cursor_debug"("NEXT", "scoped")
  debug_1235:
  rx1938_fail:
    (rx1938_rep, rx1938_pos, $I10, $P10) = rx1938_cur."!mark_fail"(0)
    lt rx1938_pos, -1, rx1938_done
    eq rx1938_pos, -1, rx1938_fail
    jump $I10
  rx1938_done:
    rx1938_cur."!cursor_fail"()
    if_null rx1938_debug, debug_1236
    rx1938_cur."!cursor_debug"("FAIL", "scoped")
  debug_1236:
    .return (rx1938_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("193_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1948 = self."!PREFIX__!subrule"("ws", "")
    $P1949 = self."!PREFIX__!subrule"("ws", "")
    $P1950 = self."!PREFIX__!subrule"("ws", "")
    new $P1951, "ResizablePMCArray"
    push $P1951, $P1948
    push $P1951, $P1949
    push $P1951, $P1950
    .return ($P1951)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("194_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1958 = "195_1305640955.436" 
    capture_lex $P1958
    .local string rx1953_tgt
    .local int rx1953_pos
    .local int rx1953_off
    .local int rx1953_eos
    .local int rx1953_rep
    .local pmc rx1953_cur
    .local pmc rx1953_debug
    (rx1953_cur, rx1953_pos, rx1953_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1953_cur
    .local pmc match
    .lex "$/", match
    length rx1953_eos, rx1953_tgt
    gt rx1953_pos, rx1953_eos, rx1953_done
    set rx1953_off, 0
    lt rx1953_pos, 2, rx1953_start
    sub rx1953_off, rx1953_pos, 1
    substr rx1953_tgt, rx1953_tgt, rx1953_off
  rx1953_start:
    eq $I10, 1, rx1953_restart
    if_null rx1953_debug, debug_1237
    rx1953_cur."!cursor_debug"("START", "typename")
  debug_1237:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1954_done
    goto rxscan1954_scan
  rxscan1954_loop:
    (rx1953_pos) = rx1953_cur."from"()
    inc rx1953_pos
    rx1953_cur."!cursor_from"(rx1953_pos)
    ge rx1953_pos, rx1953_eos, rxscan1954_done
  rxscan1954_scan:
    set_addr $I10, rxscan1954_loop
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
  rxscan1954_done:
.annotate 'line', 829
  # rx subrule "name" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."name"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1953_pos = $P10."pos"()
.annotate 'line', 830
    rx1953_cur."!cursor_pos"(rx1953_pos)
    find_lex $P1955, unicode:"$\x{a2}"
    $P1956 = $P1955."MATCH"()
    store_lex "$/", $P1956
    .const 'Sub' $P1958 = "195_1305640955.436" 
    capture_lex $P1958
    $P1967 = $P1958()
    unless $P1967, rx1953_fail
.annotate 'line', 828
  # rx pass
    rx1953_cur."!cursor_pass"(rx1953_pos, "typename")
    if_null rx1953_debug, debug_1244
    rx1953_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1953_pos)
  debug_1244:
    .return (rx1953_cur)
  rx1953_restart:
.annotate 'line', 438
    if_null rx1953_debug, debug_1245
    rx1953_cur."!cursor_debug"("NEXT", "typename")
  debug_1245:
  rx1953_fail:
    (rx1953_rep, rx1953_pos, $I10, $P10) = rx1953_cur."!mark_fail"(0)
    lt rx1953_pos, -1, rx1953_done
    eq rx1953_pos, -1, rx1953_fail
    jump $I10
  rx1953_done:
    rx1953_cur."!cursor_fail"()
    if_null rx1953_debug, debug_1246
    rx1953_cur."!cursor_debug"("FAIL", "typename")
  debug_1246:
    .return (rx1953_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1957"  :anon :subid("195_1305640955.436") :outer("194_1305640955.436")
.annotate 'line', 830
    find_dynamic_lex $P1961, "$*ACTIONS"
    unless_null $P1961, vivify_1238
    get_hll_global $P1959, "GLOBAL"
    get_who $P1960, $P1959
    set $P1961, $P1960["$ACTIONS"]
    unless_null $P1961, vivify_1239
    die "Contextual $*ACTIONS not found"
  vivify_1239:
  vivify_1238:
    find_lex $P1962, "$/"
    unless_null $P1962, vivify_1240
    new $P1962, "Undef"
  vivify_1240:
    find_lex $P1963, "$/"
    unless_null $P1963, vivify_1241
    $P1963 = root_new ['parrot';'Hash']
  vivify_1241:
    set $P1964, $P1963["name"]
    unless_null $P1964, vivify_1242
    $P1964 = root_new ['parrot';'Hash']
  vivify_1242:
    set $P1965, $P1964["identifier"]
    unless_null $P1965, vivify_1243
    new $P1965, "Undef"
  vivify_1243:
    $P1966 = $P1961."known_sym"($P1962, $P1965)
    .return ($P1966)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("196_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1969 = self."!PREFIX__!subrule"("name", "")
    new $P1970, "ResizablePMCArray"
    push $P1970, $P1969
    .return ($P1970)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("197_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx1972_tgt
    .local int rx1972_pos
    .local int rx1972_off
    .local int rx1972_eos
    .local int rx1972_rep
    .local pmc rx1972_cur
    .local pmc rx1972_debug
    (rx1972_cur, rx1972_pos, rx1972_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1972_cur
    .local pmc match
    .lex "$/", match
    length rx1972_eos, rx1972_tgt
    gt rx1972_pos, rx1972_eos, rx1972_done
    set rx1972_off, 0
    lt rx1972_pos, 2, rx1972_start
    sub rx1972_off, rx1972_pos, 1
    substr rx1972_tgt, rx1972_tgt, rx1972_off
  rx1972_start:
    eq $I10, 1, rx1972_restart
    if_null rx1972_debug, debug_1247
    rx1972_cur."!cursor_debug"("START", "declarator")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1973_done
    goto rxscan1973_scan
  rxscan1973_loop:
    (rx1972_pos) = rx1972_cur."from"()
    inc rx1972_pos
    rx1972_cur."!cursor_from"(rx1972_pos)
    ge rx1972_pos, rx1972_eos, rxscan1973_done
  rxscan1973_scan:
    set_addr $I10, rxscan1973_loop
    rx1972_cur."!mark_push"(0, rx1972_pos, $I10)
  rxscan1973_done:
  alt1974_0:
.annotate 'line', 833
    set_addr $I10, alt1974_1
    rx1972_cur."!mark_push"(0, rx1972_pos, $I10)
.annotate 'line', 834
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1972_cur."!cursor_pos"(rx1972_pos)
    $P10 = rx1972_cur."variable_declarator"()
    unless $P10, rx1972_fail
    rx1972_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1972_pos = $P10."pos"()
    goto alt1974_end
  alt1974_1:
.annotate 'line', 835
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1972_cur."!cursor_pos"(rx1972_pos)
    $P10 = rx1972_cur."routine_declarator"()
    unless $P10, rx1972_fail
    rx1972_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1972_pos = $P10."pos"()
  alt1974_end:
.annotate 'line', 833
  # rx pass
    rx1972_cur."!cursor_pass"(rx1972_pos, "declarator")
    if_null rx1972_debug, debug_1248
    rx1972_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1972_pos)
  debug_1248:
    .return (rx1972_cur)
  rx1972_restart:
.annotate 'line', 438
    if_null rx1972_debug, debug_1249
    rx1972_cur."!cursor_debug"("NEXT", "declarator")
  debug_1249:
  rx1972_fail:
    (rx1972_rep, rx1972_pos, $I10, $P10) = rx1972_cur."!mark_fail"(0)
    lt rx1972_pos, -1, rx1972_done
    eq rx1972_pos, -1, rx1972_fail
    jump $I10
  rx1972_done:
    rx1972_cur."!cursor_fail"()
    if_null rx1972_debug, debug_1250
    rx1972_cur."!cursor_debug"("FAIL", "declarator")
  debug_1250:
    .return (rx1972_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("198_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P1976 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1977 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1978, "ResizablePMCArray"
    push $P1978, $P1976
    push $P1978, $P1977
    .return ($P1978)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("199_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P1993 = "200_1305640955.436" 
    capture_lex $P1993
.annotate 'line', 840
    new $P1980, "Undef"
    .lex "$*IN_DECL", $P1980
.annotate 'line', 438
    .local string rx1981_tgt
    .local int rx1981_pos
    .local int rx1981_off
    .local int rx1981_eos
    .local int rx1981_rep
    .local pmc rx1981_cur
    .local pmc rx1981_debug
    (rx1981_cur, rx1981_pos, rx1981_tgt, $I10) = self."!cursor_start"()
    rx1981_cur."!cursor_caparray"("typename", "trait")
    .lex unicode:"$\x{a2}", rx1981_cur
    .local pmc match
    .lex "$/", match
    length rx1981_eos, rx1981_tgt
    gt rx1981_pos, rx1981_eos, rx1981_done
    set rx1981_off, 0
    lt rx1981_pos, 2, rx1981_start
    sub rx1981_off, rx1981_pos, 1
    substr rx1981_tgt, rx1981_tgt, rx1981_off
  rx1981_start:
    eq $I10, 1, rx1981_restart
    if_null rx1981_debug, debug_1251
    rx1981_cur."!cursor_debug"("START", "variable_declarator")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1982_done
    goto rxscan1982_scan
  rxscan1982_loop:
    (rx1981_pos) = rx1981_cur."from"()
    inc rx1981_pos
    rx1981_cur."!cursor_from"(rx1981_pos)
    ge rx1981_pos, rx1981_eos, rxscan1982_done
  rxscan1982_scan:
    set_addr $I10, rxscan1982_loop
    rx1981_cur."!mark_push"(0, rx1981_pos, $I10)
  rxscan1982_done:
.annotate 'line', 838
  # rx subrule "ws" subtype=method negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."ws"()
    unless $P10, rx1981_fail
    rx1981_pos = $P10."pos"()
.annotate 'line', 839
  # rx rxquantr1984 ** 0..1
    set_addr $I10, rxquantr1984_done
    rx1981_cur."!mark_push"(0, rx1981_pos, $I10)
  rxquantr1984_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."typename"()
    unless $P10, rx1981_fail
    goto rxsubrule1985_pass
  rxsubrule1985_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1981_fail
  rxsubrule1985_pass:
    set_addr $I10, rxsubrule1985_back
    rx1981_cur."!mark_push"(0, rx1981_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1981_pos = $P10."pos"()
    set_addr $I10, rxquantr1984_done
    (rx1981_rep) = rx1981_cur."!mark_commit"($I10)
  rxquantr1984_done:
  # rx subrule "ws" subtype=method negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."ws"()
    unless $P10, rx1981_fail
    rx1981_pos = $P10."pos"()
.annotate 'line', 840
    rx1981_cur."!cursor_pos"(rx1981_pos)
    new $P1987, "String"
    assign $P1987, "variable"
    store_lex "$*IN_DECL", $P1987
  # rx subrule "ws" subtype=method negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."ws"()
    unless $P10, rx1981_fail
    rx1981_pos = $P10."pos"()
.annotate 'line', 841
  # rx subrule "variable" subtype=capture negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."variable"()
    unless $P10, rx1981_fail
    rx1981_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1981_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."ws"()
    unless $P10, rx1981_fail
    rx1981_pos = $P10."pos"()
.annotate 'line', 842
    rx1981_cur."!cursor_pos"(rx1981_pos)
    find_lex $P1990, unicode:"$\x{a2}"
    $P1991 = $P1990."MATCH"()
    store_lex "$/", $P1991
    .const 'Sub' $P1993 = "200_1305640955.436" 
    capture_lex $P1993
    $P1995 = $P1993()
  # rx subrule "ws" subtype=method negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."ws"()
    unless $P10, rx1981_fail
    rx1981_pos = $P10."pos"()
.annotate 'line', 843
  # rx rxquantr1997 ** 0..*
    set_addr $I10, rxquantr1997_done
    rx1981_cur."!mark_push"(0, rx1981_pos, $I10)
  rxquantr1997_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."trait"()
    unless $P10, rx1981_fail
    goto rxsubrule1998_pass
  rxsubrule1998_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1981_fail
  rxsubrule1998_pass:
    set_addr $I10, rxsubrule1998_back
    rx1981_cur."!mark_push"(0, rx1981_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1981_pos = $P10."pos"()
    set_addr $I10, rxquantr1997_done
    (rx1981_rep) = rx1981_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1997_done
    rx1981_cur."!mark_push"(rx1981_rep, rx1981_pos, $I10)
    goto rxquantr1997_loop
  rxquantr1997_done:
  # rx subrule "ws" subtype=method negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."ws"()
    unless $P10, rx1981_fail
    rx1981_pos = $P10."pos"()
.annotate 'line', 838
  # rx pass
    rx1981_cur."!cursor_pass"(rx1981_pos, "variable_declarator")
    if_null rx1981_debug, debug_1252
    rx1981_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1981_pos)
  debug_1252:
    .return (rx1981_cur)
  rx1981_restart:
.annotate 'line', 438
    if_null rx1981_debug, debug_1253
    rx1981_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1253:
  rx1981_fail:
    (rx1981_rep, rx1981_pos, $I10, $P10) = rx1981_cur."!mark_fail"(0)
    lt rx1981_pos, -1, rx1981_done
    eq rx1981_pos, -1, rx1981_fail
    jump $I10
  rx1981_done:
    rx1981_cur."!cursor_fail"()
    if_null rx1981_debug, debug_1254
    rx1981_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1254:
    .return (rx1981_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1992"  :anon :subid("200_1305640955.436") :outer("199_1305640955.436")
.annotate 'line', 842
    new $P1994, "Integer"
    assign $P1994, 0
    store_dynamic_lex "$*IN_DECL", $P1994
    .return ($P1994)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("201_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2001 = self."!PREFIX__!subrule"("ws", "")
    new $P2002, "ResizablePMCArray"
    push $P2002, $P2001
    .return ($P2002)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("202_1305640955.436")
    .param pmc param_2004
.annotate 'line', 846
    .lex "self", param_2004
    $P2005 = param_2004."!protoregex"("routine_declarator")
    .return ($P2005)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("203_1305640955.436")
    .param pmc param_2007
.annotate 'line', 846
    .lex "self", param_2007
    $P2008 = param_2007."!PREFIX__!protoregex"("routine_declarator")
    .return ($P2008)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("204_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2010_tgt
    .local int rx2010_pos
    .local int rx2010_off
    .local int rx2010_eos
    .local int rx2010_rep
    .local pmc rx2010_cur
    .local pmc rx2010_debug
    (rx2010_cur, rx2010_pos, rx2010_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2010_cur
    .local pmc match
    .lex "$/", match
    length rx2010_eos, rx2010_tgt
    gt rx2010_pos, rx2010_eos, rx2010_done
    set rx2010_off, 0
    lt rx2010_pos, 2, rx2010_start
    sub rx2010_off, rx2010_pos, 1
    substr rx2010_tgt, rx2010_tgt, rx2010_off
  rx2010_start:
    eq $I10, 1, rx2010_restart
    if_null rx2010_debug, debug_1255
    rx2010_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2011_done
    goto rxscan2011_scan
  rxscan2011_loop:
    (rx2010_pos) = rx2010_cur."from"()
    inc rx2010_pos
    rx2010_cur."!cursor_from"(rx2010_pos)
    ge rx2010_pos, rx2010_eos, rxscan2011_done
  rxscan2011_scan:
    set_addr $I10, rxscan2011_loop
    rx2010_cur."!mark_push"(0, rx2010_pos, $I10)
  rxscan2011_done:
.annotate 'line', 847
  # rx subcapture "sym"
    set_addr $I10, rxcap_2012_fail
    rx2010_cur."!mark_push"(0, rx2010_pos, $I10)
  # rx literal  "sub"
    add $I11, rx2010_pos, 3
    gt $I11, rx2010_eos, rx2010_fail
    sub $I11, rx2010_pos, rx2010_off
    substr $S10, rx2010_tgt, $I11, 3
    ne $S10, "sub", rx2010_fail
    add rx2010_pos, 3
    set_addr $I10, rxcap_2012_fail
    ($I12, $I11) = rx2010_cur."!mark_peek"($I10)
    rx2010_cur."!cursor_pos"($I11)
    ($P10) = rx2010_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2010_pos, "")
    rx2010_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2012_done
  rxcap_2012_fail:
    goto rx2010_fail
  rxcap_2012_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx2010_cur."!cursor_pos"(rx2010_pos)
    $P10 = rx2010_cur."routine_def"()
    unless $P10, rx2010_fail
    rx2010_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2010_pos = $P10."pos"()
  # rx pass
    rx2010_cur."!cursor_pass"(rx2010_pos, "routine_declarator:sym<sub>")
    if_null rx2010_debug, debug_1256
    rx2010_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx2010_pos)
  debug_1256:
    .return (rx2010_cur)
  rx2010_restart:
.annotate 'line', 438
    if_null rx2010_debug, debug_1257
    rx2010_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1257:
  rx2010_fail:
    (rx2010_rep, rx2010_pos, $I10, $P10) = rx2010_cur."!mark_fail"(0)
    lt rx2010_pos, -1, rx2010_done
    eq rx2010_pos, -1, rx2010_fail
    jump $I10
  rx2010_done:
    rx2010_cur."!cursor_fail"()
    if_null rx2010_debug, debug_1258
    rx2010_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1258:
    .return (rx2010_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("205_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2014 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P2015, "ResizablePMCArray"
    push $P2015, $P2014
    .return ($P2015)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("206_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2017_tgt
    .local int rx2017_pos
    .local int rx2017_off
    .local int rx2017_eos
    .local int rx2017_rep
    .local pmc rx2017_cur
    .local pmc rx2017_debug
    (rx2017_cur, rx2017_pos, rx2017_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2017_cur
    .local pmc match
    .lex "$/", match
    length rx2017_eos, rx2017_tgt
    gt rx2017_pos, rx2017_eos, rx2017_done
    set rx2017_off, 0
    lt rx2017_pos, 2, rx2017_start
    sub rx2017_off, rx2017_pos, 1
    substr rx2017_tgt, rx2017_tgt, rx2017_off
  rx2017_start:
    eq $I10, 1, rx2017_restart
    if_null rx2017_debug, debug_1259
    rx2017_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2018_done
    goto rxscan2018_scan
  rxscan2018_loop:
    (rx2017_pos) = rx2017_cur."from"()
    inc rx2017_pos
    rx2017_cur."!cursor_from"(rx2017_pos)
    ge rx2017_pos, rx2017_eos, rxscan2018_done
  rxscan2018_scan:
    set_addr $I10, rxscan2018_loop
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  rxscan2018_done:
.annotate 'line', 848
  # rx subcapture "sym"
    set_addr $I10, rxcap_2019_fail
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  # rx literal  "method"
    add $I11, rx2017_pos, 6
    gt $I11, rx2017_eos, rx2017_fail
    sub $I11, rx2017_pos, rx2017_off
    substr $S10, rx2017_tgt, $I11, 6
    ne $S10, "method", rx2017_fail
    add rx2017_pos, 6
    set_addr $I10, rxcap_2019_fail
    ($I12, $I11) = rx2017_cur."!mark_peek"($I10)
    rx2017_cur."!cursor_pos"($I11)
    ($P10) = rx2017_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2017_pos, "")
    rx2017_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2019_done
  rxcap_2019_fail:
    goto rx2017_fail
  rxcap_2019_done:
  # rx subrule "method_def" subtype=capture negate=
    rx2017_cur."!cursor_pos"(rx2017_pos)
    $P10 = rx2017_cur."method_def"()
    unless $P10, rx2017_fail
    rx2017_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx2017_pos = $P10."pos"()
  # rx pass
    rx2017_cur."!cursor_pass"(rx2017_pos, "routine_declarator:sym<method>")
    if_null rx2017_debug, debug_1260
    rx2017_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx2017_pos)
  debug_1260:
    .return (rx2017_cur)
  rx2017_restart:
.annotate 'line', 438
    if_null rx2017_debug, debug_1261
    rx2017_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1261:
  rx2017_fail:
    (rx2017_rep, rx2017_pos, $I10, $P10) = rx2017_cur."!mark_fail"(0)
    lt rx2017_pos, -1, rx2017_done
    eq rx2017_pos, -1, rx2017_fail
    jump $I10
  rx2017_done:
    rx2017_cur."!cursor_fail"()
    if_null rx2017_debug, debug_1262
    rx2017_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1262:
    .return (rx2017_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("207_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2021 = self."!PREFIX__!subrule"("method_def", "method")
    new $P2022, "ResizablePMCArray"
    push $P2022, $P2021
    .return ($P2022)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("208_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 851
    new $P2024, "Undef"
    .lex "$*RETURN_USED", $P2024
.annotate 'line', 438
    .local string rx2025_tgt
    .local int rx2025_pos
    .local int rx2025_off
    .local int rx2025_eos
    .local int rx2025_rep
    .local pmc rx2025_cur
    .local pmc rx2025_debug
    (rx2025_cur, rx2025_pos, rx2025_tgt, $I10) = self."!cursor_start"()
    rx2025_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx2025_cur
    .local pmc match
    .lex "$/", match
    length rx2025_eos, rx2025_tgt
    gt rx2025_pos, rx2025_eos, rx2025_done
    set rx2025_off, 0
    lt rx2025_pos, 2, rx2025_start
    sub rx2025_off, rx2025_pos, 1
    substr rx2025_tgt, rx2025_tgt, rx2025_off
  rx2025_start:
    eq $I10, 1, rx2025_restart
    if_null rx2025_debug, debug_1263
    rx2025_cur."!cursor_debug"("START", "routine_def")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2026_done
    goto rxscan2026_scan
  rxscan2026_loop:
    (rx2025_pos) = rx2025_cur."from"()
    inc rx2025_pos
    rx2025_cur."!cursor_from"(rx2025_pos)
    ge rx2025_pos, rx2025_eos, rxscan2026_done
  rxscan2026_scan:
    set_addr $I10, rxscan2026_loop
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
  rxscan2026_done:
.annotate 'line', 850
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
.annotate 'line', 851
    rx2025_cur."!cursor_pos"(rx2025_pos)
    new $P2028, "Integer"
    assign $P2028, 0
    store_lex "$*RETURN_USED", $P2028
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
.annotate 'line', 852
  # rx rxquantr2030 ** 0..1
    set_addr $I10, rxquantr2030_done
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
  rxquantr2030_loop:
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_2033_fail
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
  # rx rxquantr2032 ** 0..1
    set_addr $I10, rxquantr2032_done
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
  rxquantr2032_loop:
  # rx literal  "&"
    add $I11, rx2025_pos, 1
    gt $I11, rx2025_eos, rx2025_fail
    sub $I11, rx2025_pos, rx2025_off
    ord $I11, rx2025_tgt, $I11
    ne $I11, 38, rx2025_fail
    add rx2025_pos, 1
    set_addr $I10, rxquantr2032_done
    (rx2025_rep) = rx2025_cur."!mark_commit"($I10)
  rxquantr2032_done:
    set_addr $I10, rxcap_2033_fail
    ($I12, $I11) = rx2025_cur."!mark_peek"($I10)
    rx2025_cur."!cursor_pos"($I11)
    ($P10) = rx2025_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2025_pos, "")
    rx2025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_2033_done
  rxcap_2033_fail:
    goto rx2025_fail
  rxcap_2033_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."deflongname"()
    unless $P10, rx2025_fail
    rx2025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
    set_addr $I10, rxquantr2030_done
    (rx2025_rep) = rx2025_cur."!mark_commit"($I10)
  rxquantr2030_done:
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
.annotate 'line', 853
  # rx subrule "newpad" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."newpad"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  alt2037_0:
.annotate 'line', 854
    set_addr $I10, alt2037_1
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2025_pos, 1
    gt $I11, rx2025_eos, rx2025_fail
    sub $I11, rx2025_pos, rx2025_off
    ord $I11, rx2025_tgt, $I11
    ne $I11, 40, rx2025_fail
    add rx2025_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."signature"()
    unless $P10, rx2025_fail
    rx2025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2025_pos, 1
    gt $I11, rx2025_eos, rx2025_fail
    sub $I11, rx2025_pos, rx2025_off
    ord $I11, rx2025_tgt, $I11
    ne $I11, 41, rx2025_fail
    add rx2025_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
    goto alt2037_end
  alt2037_1:
.annotate 'line', 855
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  alt2037_end:
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
.annotate 'line', 856
  # rx rxquantr2045 ** 0..*
    set_addr $I10, rxquantr2045_done
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
  rxquantr2045_loop:
  # rx subrule "trait" subtype=capture negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."trait"()
    unless $P10, rx2025_fail
    goto rxsubrule2046_pass
  rxsubrule2046_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2025_fail
  rxsubrule2046_pass:
    set_addr $I10, rxsubrule2046_back
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx2025_pos = $P10."pos"()
    set_addr $I10, rxquantr2045_done
    (rx2025_rep) = rx2025_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2045_done
    rx2025_cur."!mark_push"(rx2025_rep, rx2025_pos, $I10)
    goto rxquantr2045_loop
  rxquantr2045_done:
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  alt2048_0:
.annotate 'line', 857
    set_addr $I10, alt2048_1
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
.annotate 'line', 858
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."onlystar"()
    unless $P10, rx2025_fail
    rx2025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx2025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
    goto alt2048_end
  alt2048_1:
.annotate 'line', 859
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."blockoid"()
    unless $P10, rx2025_fail
    rx2025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx2025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
  alt2048_end:
.annotate 'line', 860
  # rx subrule "ws" subtype=method negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."ws"()
    unless $P10, rx2025_fail
    rx2025_pos = $P10."pos"()
.annotate 'line', 850
  # rx pass
    rx2025_cur."!cursor_pass"(rx2025_pos, "routine_def")
    if_null rx2025_debug, debug_1264
    rx2025_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx2025_pos)
  debug_1264:
    .return (rx2025_cur)
  rx2025_restart:
.annotate 'line', 438
    if_null rx2025_debug, debug_1265
    rx2025_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1265:
  rx2025_fail:
    (rx2025_rep, rx2025_pos, $I10, $P10) = rx2025_cur."!mark_fail"(0)
    lt rx2025_pos, -1, rx2025_done
    eq rx2025_pos, -1, rx2025_fail
    jump $I10
  rx2025_done:
    rx2025_cur."!cursor_fail"()
    if_null rx2025_debug, debug_1266
    rx2025_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1266:
    .return (rx2025_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("209_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2055 = self."!PREFIX__!subrule"("ws", "")
    new $P2056, "ResizablePMCArray"
    push $P2056, $P2055
    .return ($P2056)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("210_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P2085 = "211_1305640955.436" 
    capture_lex $P2085
.annotate 'line', 864
    new $P2058, "Undef"
    .lex "$*RETURN_USED", $P2058
.annotate 'line', 865
    new $P2059, "Undef"
    .lex "$*INVOCANT_OK", $P2059
.annotate 'line', 438
    .local string rx2060_tgt
    .local int rx2060_pos
    .local int rx2060_off
    .local int rx2060_eos
    .local int rx2060_rep
    .local pmc rx2060_cur
    .local pmc rx2060_debug
    (rx2060_cur, rx2060_pos, rx2060_tgt, $I10) = self."!cursor_start"()
    rx2060_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx2060_cur
    .local pmc match
    .lex "$/", match
    length rx2060_eos, rx2060_tgt
    gt rx2060_pos, rx2060_eos, rx2060_done
    set rx2060_off, 0
    lt rx2060_pos, 2, rx2060_start
    sub rx2060_off, rx2060_pos, 1
    substr rx2060_tgt, rx2060_tgt, rx2060_off
  rx2060_start:
    eq $I10, 1, rx2060_restart
    if_null rx2060_debug, debug_1267
    rx2060_cur."!cursor_debug"("START", "method_def")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2061_done
    goto rxscan2061_scan
  rxscan2061_loop:
    (rx2060_pos) = rx2060_cur."from"()
    inc rx2060_pos
    rx2060_cur."!cursor_from"(rx2060_pos)
    ge rx2060_pos, rx2060_eos, rxscan2061_done
  rxscan2061_scan:
    set_addr $I10, rxscan2061_loop
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10)
  rxscan2061_done:
.annotate 'line', 863
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 864
    rx2060_cur."!cursor_pos"(rx2060_pos)
    new $P2063, "Integer"
    assign $P2063, 0
    store_lex "$*RETURN_USED", $P2063
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 865
    rx2060_cur."!cursor_pos"(rx2060_pos)
    new $P2065, "Integer"
    assign $P2065, 1
    store_lex "$*INVOCANT_OK", $P2065
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 866
  # rx subcapture "private"
    set_addr $I10, rxcap_2068_fail
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10)
  # rx rxquantr2067 ** 0..1
    set_addr $I10, rxquantr2067_done
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10)
  rxquantr2067_loop:
  # rx literal  "!"
    add $I11, rx2060_pos, 1
    gt $I11, rx2060_eos, rx2060_fail
    sub $I11, rx2060_pos, rx2060_off
    ord $I11, rx2060_tgt, $I11
    ne $I11, 33, rx2060_fail
    add rx2060_pos, 1
    set_addr $I10, rxquantr2067_done
    (rx2060_rep) = rx2060_cur."!mark_commit"($I10)
  rxquantr2067_done:
    set_addr $I10, rxcap_2068_fail
    ($I12, $I11) = rx2060_cur."!mark_peek"($I10)
    rx2060_cur."!cursor_pos"($I11)
    ($P10) = rx2060_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2060_pos, "")
    rx2060_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_2068_done
  rxcap_2068_fail:
    goto rx2060_fail
  rxcap_2068_done:
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 867
  # rx rxquantr2070 ** 0..1
    set_addr $I10, rxquantr2070_done
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10)
  rxquantr2070_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."deflongname"()
    unless $P10, rx2060_fail
    goto rxsubrule2071_pass
  rxsubrule2071_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2060_fail
  rxsubrule2071_pass:
    set_addr $I10, rxsubrule2071_back
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx2060_pos = $P10."pos"()
    set_addr $I10, rxquantr2070_done
    (rx2060_rep) = rx2060_cur."!mark_commit"($I10)
  rxquantr2070_done:
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 868
  # rx subrule "newpad" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."newpad"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  alt2074_0:
.annotate 'line', 869
    set_addr $I10, alt2074_1
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2060_pos, 1
    gt $I11, rx2060_eos, rx2060_fail
    sub $I11, rx2060_pos, rx2060_off
    ord $I11, rx2060_tgt, $I11
    ne $I11, 40, rx2060_fail
    add rx2060_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."signature"()
    unless $P10, rx2060_fail
    rx2060_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2060_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2060_pos, 1
    gt $I11, rx2060_eos, rx2060_fail
    sub $I11, rx2060_pos, rx2060_off
    ord $I11, rx2060_tgt, $I11
    ne $I11, 41, rx2060_fail
    add rx2060_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
    goto alt2074_end
  alt2074_1:
.annotate 'line', 870
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  alt2074_end:
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 871
    rx2060_cur."!cursor_pos"(rx2060_pos)
    find_lex $P2082, unicode:"$\x{a2}"
    $P2083 = $P2082."MATCH"()
    store_lex "$/", $P2083
    .const 'Sub' $P2085 = "211_1305640955.436" 
    capture_lex $P2085
    $P2087 = $P2085()
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 872
  # rx rxquantr2089 ** 0..*
    set_addr $I10, rxquantr2089_done
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10)
  rxquantr2089_loop:
  # rx subrule "trait" subtype=capture negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."trait"()
    unless $P10, rx2060_fail
    goto rxsubrule2090_pass
  rxsubrule2090_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2060_fail
  rxsubrule2090_pass:
    set_addr $I10, rxsubrule2090_back
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx2060_pos = $P10."pos"()
    set_addr $I10, rxquantr2089_done
    (rx2060_rep) = rx2060_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2089_done
    rx2060_cur."!mark_push"(rx2060_rep, rx2060_pos, $I10)
    goto rxquantr2089_loop
  rxquantr2089_done:
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  alt2092_0:
.annotate 'line', 873
    set_addr $I10, alt2092_1
    rx2060_cur."!mark_push"(0, rx2060_pos, $I10)
.annotate 'line', 874
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."onlystar"()
    unless $P10, rx2060_fail
    rx2060_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx2060_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
    goto alt2092_end
  alt2092_1:
.annotate 'line', 875
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."blockoid"()
    unless $P10, rx2060_fail
    rx2060_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx2060_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
  alt2092_end:
.annotate 'line', 876
  # rx subrule "ws" subtype=method negate=
    rx2060_cur."!cursor_pos"(rx2060_pos)
    $P10 = rx2060_cur."ws"()
    unless $P10, rx2060_fail
    rx2060_pos = $P10."pos"()
.annotate 'line', 863
  # rx pass
    rx2060_cur."!cursor_pass"(rx2060_pos, "method_def")
    if_null rx2060_debug, debug_1268
    rx2060_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx2060_pos)
  debug_1268:
    .return (rx2060_cur)
  rx2060_restart:
.annotate 'line', 438
    if_null rx2060_debug, debug_1269
    rx2060_cur."!cursor_debug"("NEXT", "method_def")
  debug_1269:
  rx2060_fail:
    (rx2060_rep, rx2060_pos, $I10, $P10) = rx2060_cur."!mark_fail"(0)
    lt rx2060_pos, -1, rx2060_done
    eq rx2060_pos, -1, rx2060_fail
    jump $I10
  rx2060_done:
    rx2060_cur."!cursor_fail"()
    if_null rx2060_debug, debug_1270
    rx2060_cur."!cursor_debug"("FAIL", "method_def")
  debug_1270:
    .return (rx2060_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2084"  :anon :subid("211_1305640955.436") :outer("210_1305640955.436")
.annotate 'line', 871
    new $P2086, "Integer"
    assign $P2086, 0
    store_dynamic_lex "$*INVOCANT_OK", $P2086
    .return ($P2086)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("212_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2099 = self."!PREFIX__!subrule"("ws", "")
    new $P2100, "ResizablePMCArray"
    push $P2100, $P2099
    .return ($P2100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("213_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P2107 = "214_1305640955.436" 
    capture_lex $P2107
    .local string rx2102_tgt
    .local int rx2102_pos
    .local int rx2102_off
    .local int rx2102_eos
    .local int rx2102_rep
    .local pmc rx2102_cur
    .local pmc rx2102_debug
    (rx2102_cur, rx2102_pos, rx2102_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2102_cur
    .local pmc match
    .lex "$/", match
    length rx2102_eos, rx2102_tgt
    gt rx2102_pos, rx2102_eos, rx2102_done
    set rx2102_off, 0
    lt rx2102_pos, 2, rx2102_start
    sub rx2102_off, rx2102_pos, 1
    substr rx2102_tgt, rx2102_tgt, rx2102_off
  rx2102_start:
    eq $I10, 1, rx2102_restart
    if_null rx2102_debug, debug_1271
    rx2102_cur."!cursor_debug"("START", "onlystar")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2103_done
    goto rxscan2103_scan
  rxscan2103_loop:
    (rx2102_pos) = rx2102_cur."from"()
    inc rx2102_pos
    rx2102_cur."!cursor_from"(rx2102_pos)
    ge rx2102_pos, rx2102_eos, rxscan2103_done
  rxscan2103_scan:
    set_addr $I10, rxscan2103_loop
    rx2102_cur."!mark_push"(0, rx2102_pos, $I10)
  rxscan2103_done:
.annotate 'line', 880
    rx2102_cur."!cursor_pos"(rx2102_pos)
    find_lex $P2104, unicode:"$\x{a2}"
    $P2105 = $P2104."MATCH"()
    store_lex "$/", $P2105
    .const 'Sub' $P2107 = "214_1305640955.436" 
    capture_lex $P2107
    $P2113 = $P2107()
    unless $P2113, rx2102_fail
.annotate 'line', 881
  # rx literal  "{"
    add $I11, rx2102_pos, 1
    gt $I11, rx2102_eos, rx2102_fail
    sub $I11, rx2102_pos, rx2102_off
    ord $I11, rx2102_tgt, $I11
    ne $I11, 123, rx2102_fail
    add rx2102_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2102_cur."!cursor_pos"(rx2102_pos)
    $P10 = rx2102_cur."ws"()
    unless $P10, rx2102_fail
    rx2102_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx2102_pos, 1
    gt $I11, rx2102_eos, rx2102_fail
    sub $I11, rx2102_pos, rx2102_off
    ord $I11, rx2102_tgt, $I11
    ne $I11, 42, rx2102_fail
    add rx2102_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2102_cur."!cursor_pos"(rx2102_pos)
    $P10 = rx2102_cur."ws"()
    unless $P10, rx2102_fail
    rx2102_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2102_pos, 1
    gt $I11, rx2102_eos, rx2102_fail
    sub $I11, rx2102_pos, rx2102_off
    ord $I11, rx2102_tgt, $I11
    ne $I11, 125, rx2102_fail
    add rx2102_pos, 1
.annotate 'line', 882
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2102_cur."!cursor_pos"(rx2102_pos)
    $P10 = rx2102_cur."ENDSTMT"()
    unless $P10, rx2102_fail
.annotate 'line', 883
  # rx subrule "finishpad" subtype=method negate=
    rx2102_cur."!cursor_pos"(rx2102_pos)
    $P10 = rx2102_cur."finishpad"()
    unless $P10, rx2102_fail
    rx2102_pos = $P10."pos"()
.annotate 'line', 879
  # rx pass
    rx2102_cur."!cursor_pass"(rx2102_pos, "onlystar")
    if_null rx2102_debug, debug_1274
    rx2102_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx2102_pos)
  debug_1274:
    .return (rx2102_cur)
  rx2102_restart:
.annotate 'line', 438
    if_null rx2102_debug, debug_1275
    rx2102_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1275:
  rx2102_fail:
    (rx2102_rep, rx2102_pos, $I10, $P10) = rx2102_cur."!mark_fail"(0)
    lt rx2102_pos, -1, rx2102_done
    eq rx2102_pos, -1, rx2102_fail
    jump $I10
  rx2102_done:
    rx2102_cur."!cursor_fail"()
    if_null rx2102_debug, debug_1276
    rx2102_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1276:
    .return (rx2102_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2106"  :anon :subid("214_1305640955.436") :outer("213_1305640955.436")
.annotate 'line', 880
    find_dynamic_lex $P2110, "$*MULTINESS"
    unless_null $P2110, vivify_1272
    get_hll_global $P2108, "GLOBAL"
    get_who $P2109, $P2108
    set $P2110, $P2109["$MULTINESS"]
    unless_null $P2110, vivify_1273
    die "Contextual $*MULTINESS not found"
  vivify_1273:
  vivify_1272:
    set $S2111, $P2110
    iseq $I2112, $S2111, "proto"
    .return ($I2112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("215_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2115, "ResizablePMCArray"
    push $P2115, ""
    .return ($P2115)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("216_1305640955.436")
    .param pmc param_2117
.annotate 'line', 886
    .lex "self", param_2117
    $P2118 = param_2117."!protoregex"("multi_declarator")
    .return ($P2118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("217_1305640955.436")
    .param pmc param_2120
.annotate 'line', 886
    .lex "self", param_2120
    $P2121 = param_2120."!PREFIX__!protoregex"("multi_declarator")
    .return ($P2121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("218_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 888
    new $P2123, "Undef"
    .lex "$*MULTINESS", $P2123
.annotate 'line', 438
    .local string rx2124_tgt
    .local int rx2124_pos
    .local int rx2124_off
    .local int rx2124_eos
    .local int rx2124_rep
    .local pmc rx2124_cur
    .local pmc rx2124_debug
    (rx2124_cur, rx2124_pos, rx2124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2124_cur
    .local pmc match
    .lex "$/", match
    length rx2124_eos, rx2124_tgt
    gt rx2124_pos, rx2124_eos, rx2124_done
    set rx2124_off, 0
    lt rx2124_pos, 2, rx2124_start
    sub rx2124_off, rx2124_pos, 1
    substr rx2124_tgt, rx2124_tgt, rx2124_off
  rx2124_start:
    eq $I10, 1, rx2124_restart
    if_null rx2124_debug, debug_1277
    rx2124_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1277:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2125_done
    goto rxscan2125_scan
  rxscan2125_loop:
    (rx2124_pos) = rx2124_cur."from"()
    inc rx2124_pos
    rx2124_cur."!cursor_from"(rx2124_pos)
    ge rx2124_pos, rx2124_eos, rxscan2125_done
  rxscan2125_scan:
    set_addr $I10, rxscan2125_loop
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  rxscan2125_done:
.annotate 'line', 888
    rx2124_cur."!cursor_pos"(rx2124_pos)
    new $P2126, "String"
    assign $P2126, "multi"
    store_lex "$*MULTINESS", $P2126
.annotate 'line', 889
  # rx subcapture "sym"
    set_addr $I10, rxcap_2127_fail
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  # rx literal  "multi"
    add $I11, rx2124_pos, 5
    gt $I11, rx2124_eos, rx2124_fail
    sub $I11, rx2124_pos, rx2124_off
    substr $S10, rx2124_tgt, $I11, 5
    ne $S10, "multi", rx2124_fail
    add rx2124_pos, 5
    set_addr $I10, rxcap_2127_fail
    ($I12, $I11) = rx2124_cur."!mark_peek"($I10)
    rx2124_cur."!cursor_pos"($I11)
    ($P10) = rx2124_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2124_pos, "")
    rx2124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2127_done
  rxcap_2127_fail:
    goto rx2124_fail
  rxcap_2127_done:
.annotate 'line', 890
  # rx subrule "ws" subtype=method negate=
    rx2124_cur."!cursor_pos"(rx2124_pos)
    $P10 = rx2124_cur."ws"()
    unless $P10, rx2124_fail
    rx2124_pos = $P10."pos"()
  alt2128_0:
    set_addr $I10, alt2128_1
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2124_cur."!cursor_pos"(rx2124_pos)
    $P10 = rx2124_cur."declarator"()
    unless $P10, rx2124_fail
    rx2124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2124_pos = $P10."pos"()
    goto alt2128_end
  alt2128_1:
    set_addr $I10, alt2128_2
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2124_cur."!cursor_pos"(rx2124_pos)
    $P10 = rx2124_cur."routine_def"()
    unless $P10, rx2124_fail
    rx2124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2124_pos = $P10."pos"()
    goto alt2128_end
  alt2128_2:
  # rx subrule "panic" subtype=method negate=
    rx2124_cur."!cursor_pos"(rx2124_pos)
    $P10 = rx2124_cur."panic"("Malformed multi")
    unless $P10, rx2124_fail
    rx2124_pos = $P10."pos"()
  alt2128_end:
.annotate 'line', 887
  # rx pass
    rx2124_cur."!cursor_pass"(rx2124_pos, "multi_declarator:sym<multi>")
    if_null rx2124_debug, debug_1278
    rx2124_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx2124_pos)
  debug_1278:
    .return (rx2124_cur)
  rx2124_restart:
.annotate 'line', 438
    if_null rx2124_debug, debug_1279
    rx2124_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1279:
  rx2124_fail:
    (rx2124_rep, rx2124_pos, $I10, $P10) = rx2124_cur."!mark_fail"(0)
    lt rx2124_pos, -1, rx2124_done
    eq rx2124_pos, -1, rx2124_fail
    jump $I10
  rx2124_done:
    rx2124_cur."!cursor_fail"()
    if_null rx2124_debug, debug_1280
    rx2124_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1280:
    .return (rx2124_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("219_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2130 = self."!PREFIX__!subrule"("ws", "multi")
    new $P2131, "ResizablePMCArray"
    push $P2131, $P2130
    .return ($P2131)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("220_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 893
    new $P2133, "Undef"
    .lex "$*MULTINESS", $P2133
.annotate 'line', 438
    .local string rx2134_tgt
    .local int rx2134_pos
    .local int rx2134_off
    .local int rx2134_eos
    .local int rx2134_rep
    .local pmc rx2134_cur
    .local pmc rx2134_debug
    (rx2134_cur, rx2134_pos, rx2134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2134_cur
    .local pmc match
    .lex "$/", match
    length rx2134_eos, rx2134_tgt
    gt rx2134_pos, rx2134_eos, rx2134_done
    set rx2134_off, 0
    lt rx2134_pos, 2, rx2134_start
    sub rx2134_off, rx2134_pos, 1
    substr rx2134_tgt, rx2134_tgt, rx2134_off
  rx2134_start:
    eq $I10, 1, rx2134_restart
    if_null rx2134_debug, debug_1281
    rx2134_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1281:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2135_done
    goto rxscan2135_scan
  rxscan2135_loop:
    (rx2134_pos) = rx2134_cur."from"()
    inc rx2134_pos
    rx2134_cur."!cursor_from"(rx2134_pos)
    ge rx2134_pos, rx2134_eos, rxscan2135_done
  rxscan2135_scan:
    set_addr $I10, rxscan2135_loop
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  rxscan2135_done:
.annotate 'line', 893
    rx2134_cur."!cursor_pos"(rx2134_pos)
    new $P2136, "String"
    assign $P2136, "proto"
    store_lex "$*MULTINESS", $P2136
.annotate 'line', 894
  # rx subcapture "sym"
    set_addr $I10, rxcap_2137_fail
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2134_pos, 5
    gt $I11, rx2134_eos, rx2134_fail
    sub $I11, rx2134_pos, rx2134_off
    substr $S10, rx2134_tgt, $I11, 5
    ne $S10, "proto", rx2134_fail
    add rx2134_pos, 5
    set_addr $I10, rxcap_2137_fail
    ($I12, $I11) = rx2134_cur."!mark_peek"($I10)
    rx2134_cur."!cursor_pos"($I11)
    ($P10) = rx2134_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2134_pos, "")
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2137_done
  rxcap_2137_fail:
    goto rx2134_fail
  rxcap_2137_done:
.annotate 'line', 895
  # rx subrule "ws" subtype=method negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."ws"()
    unless $P10, rx2134_fail
    rx2134_pos = $P10."pos"()
  alt2138_0:
    set_addr $I10, alt2138_1
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."declarator"()
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2134_pos = $P10."pos"()
    goto alt2138_end
  alt2138_1:
    set_addr $I10, alt2138_2
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."routine_def"()
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2134_pos = $P10."pos"()
    goto alt2138_end
  alt2138_2:
  # rx subrule "panic" subtype=method negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."panic"("Malformed proto")
    unless $P10, rx2134_fail
    rx2134_pos = $P10."pos"()
  alt2138_end:
.annotate 'line', 892
  # rx pass
    rx2134_cur."!cursor_pass"(rx2134_pos, "multi_declarator:sym<proto>")
    if_null rx2134_debug, debug_1282
    rx2134_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx2134_pos)
  debug_1282:
    .return (rx2134_cur)
  rx2134_restart:
.annotate 'line', 438
    if_null rx2134_debug, debug_1283
    rx2134_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1283:
  rx2134_fail:
    (rx2134_rep, rx2134_pos, $I10, $P10) = rx2134_cur."!mark_fail"(0)
    lt rx2134_pos, -1, rx2134_done
    eq rx2134_pos, -1, rx2134_fail
    jump $I10
  rx2134_done:
    rx2134_cur."!cursor_fail"()
    if_null rx2134_debug, debug_1284
    rx2134_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1284:
    .return (rx2134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("221_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2140 = self."!PREFIX__!subrule"("ws", "proto")
    new $P2141, "ResizablePMCArray"
    push $P2141, $P2140
    .return ($P2141)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("222_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 898
    new $P2143, "Undef"
    .lex "$*MULTINESS", $P2143
.annotate 'line', 438
    .local string rx2144_tgt
    .local int rx2144_pos
    .local int rx2144_off
    .local int rx2144_eos
    .local int rx2144_rep
    .local pmc rx2144_cur
    .local pmc rx2144_debug
    (rx2144_cur, rx2144_pos, rx2144_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2144_cur
    .local pmc match
    .lex "$/", match
    length rx2144_eos, rx2144_tgt
    gt rx2144_pos, rx2144_eos, rx2144_done
    set rx2144_off, 0
    lt rx2144_pos, 2, rx2144_start
    sub rx2144_off, rx2144_pos, 1
    substr rx2144_tgt, rx2144_tgt, rx2144_off
  rx2144_start:
    eq $I10, 1, rx2144_restart
    if_null rx2144_debug, debug_1285
    rx2144_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1285:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2145_done
    goto rxscan2145_scan
  rxscan2145_loop:
    (rx2144_pos) = rx2144_cur."from"()
    inc rx2144_pos
    rx2144_cur."!cursor_from"(rx2144_pos)
    ge rx2144_pos, rx2144_eos, rxscan2145_done
  rxscan2145_scan:
    set_addr $I10, rxscan2145_loop
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  rxscan2145_done:
.annotate 'line', 898
    rx2144_cur."!cursor_pos"(rx2144_pos)
    new $P2146, "String"
    assign $P2146, ""
    store_lex "$*MULTINESS", $P2146
.annotate 'line', 899
  # rx subrule "declarator" subtype=capture negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."declarator"()
    unless $P10, rx2144_fail
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2144_pos = $P10."pos"()
.annotate 'line', 897
  # rx pass
    rx2144_cur."!cursor_pass"(rx2144_pos, "multi_declarator:sym<null>")
    if_null rx2144_debug, debug_1286
    rx2144_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx2144_pos)
  debug_1286:
    .return (rx2144_cur)
  rx2144_restart:
.annotate 'line', 438
    if_null rx2144_debug, debug_1287
    rx2144_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1287:
  rx2144_fail:
    (rx2144_rep, rx2144_pos, $I10, $P10) = rx2144_cur."!mark_fail"(0)
    lt rx2144_pos, -1, rx2144_done
    eq rx2144_pos, -1, rx2144_fail
    jump $I10
  rx2144_done:
    rx2144_cur."!cursor_fail"()
    if_null rx2144_debug, debug_1288
    rx2144_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1288:
    .return (rx2144_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("223_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2148 = self."!PREFIX__!subrule"("declarator", "")
    new $P2149, "ResizablePMCArray"
    push $P2149, $P2148
    .return ($P2149)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("224_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P2157 = "225_1305640955.436" 
    capture_lex $P2157
    .local string rx2151_tgt
    .local int rx2151_pos
    .local int rx2151_off
    .local int rx2151_eos
    .local int rx2151_rep
    .local pmc rx2151_cur
    .local pmc rx2151_debug
    (rx2151_cur, rx2151_pos, rx2151_tgt, $I10) = self."!cursor_start"()
    rx2151_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx2151_cur
    .local pmc match
    .lex "$/", match
    length rx2151_eos, rx2151_tgt
    gt rx2151_pos, rx2151_eos, rx2151_done
    set rx2151_off, 0
    lt rx2151_pos, 2, rx2151_start
    sub rx2151_off, rx2151_pos, 1
    substr rx2151_tgt, rx2151_tgt, rx2151_off
  rx2151_start:
    eq $I10, 1, rx2151_restart
    if_null rx2151_debug, debug_1289
    rx2151_cur."!cursor_debug"("START", "signature")
  debug_1289:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2152_done
    goto rxscan2152_scan
  rxscan2152_loop:
    (rx2151_pos) = rx2151_cur."from"()
    inc rx2151_pos
    rx2151_cur."!cursor_from"(rx2151_pos)
    ge rx2151_pos, rx2151_eos, rxscan2152_done
  rxscan2152_scan:
    set_addr $I10, rxscan2152_loop
    rx2151_cur."!mark_push"(0, rx2151_pos, $I10)
  rxscan2152_done:
.annotate 'line', 903
  # rx rxquantr2153 ** 0..1
    set_addr $I10, rxquantr2153_done
    rx2151_cur."!mark_push"(0, rx2151_pos, $I10)
  rxquantr2153_loop:
    rx2151_cur."!cursor_pos"(rx2151_pos)
    find_lex $P2154, unicode:"$\x{a2}"
    $P2155 = $P2154."MATCH"()
    store_lex "$/", $P2155
    .const 'Sub' $P2157 = "225_1305640955.436" 
    capture_lex $P2157
    $P2161 = $P2157()
    unless $P2161, rx2151_fail
  # rx subrule "ws" subtype=method negate=
    rx2151_cur."!cursor_pos"(rx2151_pos)
    $P10 = rx2151_cur."ws"()
    unless $P10, rx2151_fail
    rx2151_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2151_cur."!cursor_pos"(rx2151_pos)
    $P10 = rx2151_cur."parameter"()
    unless $P10, rx2151_fail
    rx2151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx2151_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2151_cur."!cursor_pos"(rx2151_pos)
    $P10 = rx2151_cur."ws"()
    unless $P10, rx2151_fail
    rx2151_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx2151_pos, 1
    gt $I11, rx2151_eos, rx2151_fail
    sub $I11, rx2151_pos, rx2151_off
    ord $I11, rx2151_tgt, $I11
    ne $I11, 58, rx2151_fail
    add rx2151_pos, 1
    set_addr $I10, rxquantr2153_done
    (rx2151_rep) = rx2151_cur."!mark_commit"($I10)
  rxquantr2153_done:
.annotate 'line', 904
  # rx rxquantr2162 ** 0..1
    set_addr $I10, rxquantr2162_done
    rx2151_cur."!mark_push"(0, rx2151_pos, $I10)
  rxquantr2162_loop:
  # rx rxquantr2163 ** 1..*
    set_addr $I10, rxquantr2163_done
    rx2151_cur."!mark_push"(0, -1, $I10)
  rxquantr2163_loop:
  # rx subrule "ws" subtype=method negate=
    rx2151_cur."!cursor_pos"(rx2151_pos)
    $P10 = rx2151_cur."ws"()
    unless $P10, rx2151_fail
    rx2151_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2151_cur."!cursor_pos"(rx2151_pos)
    $P10 = rx2151_cur."parameter"()
    unless $P10, rx2151_fail
    rx2151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx2151_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2151_cur."!cursor_pos"(rx2151_pos)
    $P10 = rx2151_cur."ws"()
    unless $P10, rx2151_fail
    rx2151_pos = $P10."pos"()
    set_addr $I10, rxquantr2163_done
    (rx2151_rep) = rx2151_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2163_done
    rx2151_cur."!mark_push"(rx2151_rep, rx2151_pos, $I10)
  # rx literal  ","
    add $I11, rx2151_pos, 1
    gt $I11, rx2151_eos, rx2151_fail
    sub $I11, rx2151_pos, rx2151_off
    ord $I11, rx2151_tgt, $I11
    ne $I11, 44, rx2151_fail
    add rx2151_pos, 1
    goto rxquantr2163_loop
  rxquantr2163_done:
    set_addr $I10, rxquantr2162_done
    (rx2151_rep) = rx2151_cur."!mark_commit"($I10)
  rxquantr2162_done:
.annotate 'line', 902
  # rx pass
    rx2151_cur."!cursor_pass"(rx2151_pos, "signature")
    if_null rx2151_debug, debug_1292
    rx2151_cur."!cursor_debug"("PASS", "signature", " at pos=", rx2151_pos)
  debug_1292:
    .return (rx2151_cur)
  rx2151_restart:
.annotate 'line', 438
    if_null rx2151_debug, debug_1293
    rx2151_cur."!cursor_debug"("NEXT", "signature")
  debug_1293:
  rx2151_fail:
    (rx2151_rep, rx2151_pos, $I10, $P10) = rx2151_cur."!mark_fail"(0)
    lt rx2151_pos, -1, rx2151_done
    eq rx2151_pos, -1, rx2151_fail
    jump $I10
  rx2151_done:
    rx2151_cur."!cursor_fail"()
    if_null rx2151_debug, debug_1294
    rx2151_cur."!cursor_debug"("FAIL", "signature")
  debug_1294:
    .return (rx2151_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2156"  :anon :subid("225_1305640955.436") :outer("224_1305640955.436")
.annotate 'line', 903
    find_dynamic_lex $P2160, "$*INVOCANT_OK"
    unless_null $P2160, vivify_1290
    get_hll_global $P2158, "GLOBAL"
    get_who $P2159, $P2158
    set $P2160, $P2159["$INVOCANT_OK"]
    unless_null $P2160, vivify_1291
    die "Contextual $*INVOCANT_OK not found"
  vivify_1291:
  vivify_1290:
    .return ($P2160)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("226_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2165, "ResizablePMCArray"
    push $P2165, ""
    .return ($P2165)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("227_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2167_tgt
    .local int rx2167_pos
    .local int rx2167_off
    .local int rx2167_eos
    .local int rx2167_rep
    .local pmc rx2167_cur
    .local pmc rx2167_debug
    (rx2167_cur, rx2167_pos, rx2167_tgt, $I10) = self."!cursor_start"()
    rx2167_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx2167_cur
    .local pmc match
    .lex "$/", match
    length rx2167_eos, rx2167_tgt
    gt rx2167_pos, rx2167_eos, rx2167_done
    set rx2167_off, 0
    lt rx2167_pos, 2, rx2167_start
    sub rx2167_off, rx2167_pos, 1
    substr rx2167_tgt, rx2167_tgt, rx2167_off
  rx2167_start:
    eq $I10, 1, rx2167_restart
    if_null rx2167_debug, debug_1295
    rx2167_cur."!cursor_debug"("START", "parameter")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2168_done
    goto rxscan2168_scan
  rxscan2168_loop:
    (rx2167_pos) = rx2167_cur."from"()
    inc rx2167_pos
    rx2167_cur."!cursor_from"(rx2167_pos)
    ge rx2167_pos, rx2167_eos, rxscan2168_done
  rxscan2168_scan:
    set_addr $I10, rxscan2168_loop
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  rxscan2168_done:
.annotate 'line', 908
  # rx rxquantr2169 ** 0..*
    set_addr $I10, rxquantr2169_done
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  rxquantr2169_loop:
  # rx subrule "typename" subtype=capture negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."typename"()
    unless $P10, rx2167_fail
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx2167_pos = $P10."pos"()
  # rx rxquantr2170 ** 0..1
    set_addr $I10, rxquantr2170_done
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  rxquantr2170_loop:
  # rx literal  ":"
    add $I11, rx2167_pos, 1
    gt $I11, rx2167_eos, rx2167_fail
    sub $I11, rx2167_pos, rx2167_off
    ord $I11, rx2167_tgt, $I11
    ne $I11, 58, rx2167_fail
    add rx2167_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_2171_fail
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2167_pos, rx2167_eos, rx2167_fail
    sub $I10, rx2167_pos, rx2167_off
    substr $S10, rx2167_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx2167_fail
    inc rx2167_pos
    set_addr $I10, rxcap_2171_fail
    ($I12, $I11) = rx2167_cur."!mark_peek"($I10)
    rx2167_cur."!cursor_pos"($I11)
    ($P10) = rx2167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2167_pos, "")
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_2171_done
  rxcap_2171_fail:
    goto rx2167_fail
  rxcap_2171_done:
    set_addr $I10, rxquantr2170_done
    (rx2167_rep) = rx2167_cur."!mark_commit"($I10)
  rxquantr2170_done:
  # rx subrule "ws" subtype=method negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."ws"()
    unless $P10, rx2167_fail
    rx2167_pos = $P10."pos"()
    set_addr $I10, rxquantr2169_done
    (rx2167_rep) = rx2167_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2169_done
    rx2167_cur."!mark_push"(rx2167_rep, rx2167_pos, $I10)
    goto rxquantr2169_loop
  rxquantr2169_done:
  alt2172_0:
.annotate 'line', 909
    set_addr $I10, alt2172_1
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
.annotate 'line', 910
  # rx subcapture "quant"
    set_addr $I10, rxcap_2173_fail
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  # rx literal  "*"
    add $I11, rx2167_pos, 1
    gt $I11, rx2167_eos, rx2167_fail
    sub $I11, rx2167_pos, rx2167_off
    ord $I11, rx2167_tgt, $I11
    ne $I11, 42, rx2167_fail
    add rx2167_pos, 1
    set_addr $I10, rxcap_2173_fail
    ($I12, $I11) = rx2167_cur."!mark_peek"($I10)
    rx2167_cur."!cursor_pos"($I11)
    ($P10) = rx2167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2167_pos, "")
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2173_done
  rxcap_2173_fail:
    goto rx2167_fail
  rxcap_2173_done:
  # rx subrule "param_var" subtype=capture negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."param_var"()
    unless $P10, rx2167_fail
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2167_pos = $P10."pos"()
    goto alt2172_end
  alt2172_1:
  alt2174_0:
.annotate 'line', 911
    set_addr $I10, alt2174_1
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."param_var"()
    unless $P10, rx2167_fail
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2167_pos = $P10."pos"()
    goto alt2174_end
  alt2174_1:
  # rx subrule "named_param" subtype=capture negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."named_param"()
    unless $P10, rx2167_fail
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx2167_pos = $P10."pos"()
  alt2174_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_2176_fail
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  alt2175_0:
    set_addr $I10, alt2175_1
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  # rx literal  "?"
    add $I11, rx2167_pos, 1
    gt $I11, rx2167_eos, rx2167_fail
    sub $I11, rx2167_pos, rx2167_off
    ord $I11, rx2167_tgt, $I11
    ne $I11, 63, rx2167_fail
    add rx2167_pos, 1
    goto alt2175_end
  alt2175_1:
    set_addr $I10, alt2175_2
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  # rx literal  "!"
    add $I11, rx2167_pos, 1
    gt $I11, rx2167_eos, rx2167_fail
    sub $I11, rx2167_pos, rx2167_off
    ord $I11, rx2167_tgt, $I11
    ne $I11, 33, rx2167_fail
    add rx2167_pos, 1
    goto alt2175_end
  alt2175_2:
  alt2175_end:
    set_addr $I10, rxcap_2176_fail
    ($I12, $I11) = rx2167_cur."!mark_peek"($I10)
    rx2167_cur."!cursor_pos"($I11)
    ($P10) = rx2167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2167_pos, "")
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2176_done
  rxcap_2176_fail:
    goto rx2167_fail
  rxcap_2176_done:
  alt2172_end:
.annotate 'line', 913
  # rx rxquantr2177 ** 0..1
    set_addr $I10, rxquantr2177_done
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  rxquantr2177_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."default_value"()
    unless $P10, rx2167_fail
    goto rxsubrule2178_pass
  rxsubrule2178_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2167_fail
  rxsubrule2178_pass:
    set_addr $I10, rxsubrule2178_back
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx2167_pos = $P10."pos"()
    set_addr $I10, rxquantr2177_done
    (rx2167_rep) = rx2167_cur."!mark_commit"($I10)
  rxquantr2177_done:
.annotate 'line', 907
  # rx pass
    rx2167_cur."!cursor_pass"(rx2167_pos, "parameter")
    if_null rx2167_debug, debug_1296
    rx2167_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx2167_pos)
  debug_1296:
    .return (rx2167_cur)
  rx2167_restart:
.annotate 'line', 438
    if_null rx2167_debug, debug_1297
    rx2167_cur."!cursor_debug"("NEXT", "parameter")
  debug_1297:
  rx2167_fail:
    (rx2167_rep, rx2167_pos, $I10, $P10) = rx2167_cur."!mark_fail"(0)
    lt rx2167_pos, -1, rx2167_done
    eq rx2167_pos, -1, rx2167_fail
    jump $I10
  rx2167_done:
    rx2167_cur."!cursor_fail"()
    if_null rx2167_debug, debug_1298
    rx2167_cur."!cursor_debug"("FAIL", "parameter")
  debug_1298:
    .return (rx2167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("228_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2180, "ResizablePMCArray"
    push $P2180, ""
    .return ($P2180)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("229_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2182_tgt
    .local int rx2182_pos
    .local int rx2182_off
    .local int rx2182_eos
    .local int rx2182_rep
    .local pmc rx2182_cur
    .local pmc rx2182_debug
    (rx2182_cur, rx2182_pos, rx2182_tgt, $I10) = self."!cursor_start"()
    rx2182_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx2182_cur
    .local pmc match
    .lex "$/", match
    length rx2182_eos, rx2182_tgt
    gt rx2182_pos, rx2182_eos, rx2182_done
    set rx2182_off, 0
    lt rx2182_pos, 2, rx2182_start
    sub rx2182_off, rx2182_pos, 1
    substr rx2182_tgt, rx2182_tgt, rx2182_off
  rx2182_start:
    eq $I10, 1, rx2182_restart
    if_null rx2182_debug, debug_1299
    rx2182_cur."!cursor_debug"("START", "param_var")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2183_done
    goto rxscan2183_scan
  rxscan2183_loop:
    (rx2182_pos) = rx2182_cur."from"()
    inc rx2182_pos
    rx2182_cur."!cursor_from"(rx2182_pos)
    ge rx2182_pos, rx2182_eos, rxscan2183_done
  rxscan2183_scan:
    set_addr $I10, rxscan2183_loop
    rx2182_cur."!mark_push"(0, rx2182_pos, $I10)
  rxscan2183_done:
.annotate 'line', 917
  # rx subrule "sigil" subtype=capture negate=
    rx2182_cur."!cursor_pos"(rx2182_pos)
    $P10 = rx2182_cur."sigil"()
    unless $P10, rx2182_fail
    rx2182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2182_pos = $P10."pos"()
  # rx rxquantr2184 ** 0..1
    set_addr $I10, rxquantr2184_done
    rx2182_cur."!mark_push"(0, rx2182_pos, $I10)
  rxquantr2184_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx2182_cur."!cursor_pos"(rx2182_pos)
    $P10 = rx2182_cur."twigil"()
    unless $P10, rx2182_fail
    goto rxsubrule2185_pass
  rxsubrule2185_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2182_fail
  rxsubrule2185_pass:
    set_addr $I10, rxsubrule2185_back
    rx2182_cur."!mark_push"(0, rx2182_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx2182_pos = $P10."pos"()
    set_addr $I10, rxquantr2184_done
    (rx2182_rep) = rx2182_cur."!mark_commit"($I10)
  rxquantr2184_done:
  alt2186_0:
.annotate 'line', 918
    set_addr $I10, alt2186_1
    rx2182_cur."!mark_push"(0, rx2182_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx2182_cur."!cursor_pos"(rx2182_pos)
    $P10 = rx2182_cur."ident"()
    unless $P10, rx2182_fail
    rx2182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2182_pos = $P10."pos"()
    goto alt2186_end
  alt2186_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_2187_fail
    rx2182_cur."!mark_push"(0, rx2182_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2182_pos, rx2182_eos, rx2182_fail
    sub $I10, rx2182_pos, rx2182_off
    substr $S10, rx2182_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx2182_fail
    inc rx2182_pos
    set_addr $I10, rxcap_2187_fail
    ($I12, $I11) = rx2182_cur."!mark_peek"($I10)
    rx2182_cur."!cursor_pos"($I11)
    ($P10) = rx2182_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2182_pos, "")
    rx2182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_2187_done
  rxcap_2187_fail:
    goto rx2182_fail
  rxcap_2187_done:
  alt2186_end:
.annotate 'line', 916
  # rx pass
    rx2182_cur."!cursor_pass"(rx2182_pos, "param_var")
    if_null rx2182_debug, debug_1300
    rx2182_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx2182_pos)
  debug_1300:
    .return (rx2182_cur)
  rx2182_restart:
.annotate 'line', 438
    if_null rx2182_debug, debug_1301
    rx2182_cur."!cursor_debug"("NEXT", "param_var")
  debug_1301:
  rx2182_fail:
    (rx2182_rep, rx2182_pos, $I10, $P10) = rx2182_cur."!mark_fail"(0)
    lt rx2182_pos, -1, rx2182_done
    eq rx2182_pos, -1, rx2182_fail
    jump $I10
  rx2182_done:
    rx2182_cur."!cursor_fail"()
    if_null rx2182_debug, debug_1302
    rx2182_cur."!cursor_debug"("FAIL", "param_var")
  debug_1302:
    .return (rx2182_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("230_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2189 = self."!PREFIX__!subrule"("sigil", "")
    new $P2190, "ResizablePMCArray"
    push $P2190, $P2189
    .return ($P2190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("231_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2192_tgt
    .local int rx2192_pos
    .local int rx2192_off
    .local int rx2192_eos
    .local int rx2192_rep
    .local pmc rx2192_cur
    .local pmc rx2192_debug
    (rx2192_cur, rx2192_pos, rx2192_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2192_cur
    .local pmc match
    .lex "$/", match
    length rx2192_eos, rx2192_tgt
    gt rx2192_pos, rx2192_eos, rx2192_done
    set rx2192_off, 0
    lt rx2192_pos, 2, rx2192_start
    sub rx2192_off, rx2192_pos, 1
    substr rx2192_tgt, rx2192_tgt, rx2192_off
  rx2192_start:
    eq $I10, 1, rx2192_restart
    if_null rx2192_debug, debug_1303
    rx2192_cur."!cursor_debug"("START", "named_param")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2193_done
    goto rxscan2193_scan
  rxscan2193_loop:
    (rx2192_pos) = rx2192_cur."from"()
    inc rx2192_pos
    rx2192_cur."!cursor_from"(rx2192_pos)
    ge rx2192_pos, rx2192_eos, rxscan2193_done
  rxscan2193_scan:
    set_addr $I10, rxscan2193_loop
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  rxscan2193_done:
.annotate 'line', 922
  # rx literal  ":"
    add $I11, rx2192_pos, 1
    gt $I11, rx2192_eos, rx2192_fail
    sub $I11, rx2192_pos, rx2192_off
    ord $I11, rx2192_tgt, $I11
    ne $I11, 58, rx2192_fail
    add rx2192_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."param_var"()
    unless $P10, rx2192_fail
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2192_pos = $P10."pos"()
.annotate 'line', 921
  # rx pass
    rx2192_cur."!cursor_pass"(rx2192_pos, "named_param")
    if_null rx2192_debug, debug_1304
    rx2192_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx2192_pos)
  debug_1304:
    .return (rx2192_cur)
  rx2192_restart:
.annotate 'line', 438
    if_null rx2192_debug, debug_1305
    rx2192_cur."!cursor_debug"("NEXT", "named_param")
  debug_1305:
  rx2192_fail:
    (rx2192_rep, rx2192_pos, $I10, $P10) = rx2192_cur."!mark_fail"(0)
    lt rx2192_pos, -1, rx2192_done
    eq rx2192_pos, -1, rx2192_fail
    jump $I10
  rx2192_done:
    rx2192_cur."!cursor_fail"()
    if_null rx2192_debug, debug_1306
    rx2192_cur."!cursor_debug"("FAIL", "named_param")
  debug_1306:
    .return (rx2192_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("232_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2195 = self."!PREFIX__!subrule"("param_var", ":")
    new $P2196, "ResizablePMCArray"
    push $P2196, $P2195
    .return ($P2196)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("233_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2198_tgt
    .local int rx2198_pos
    .local int rx2198_off
    .local int rx2198_eos
    .local int rx2198_rep
    .local pmc rx2198_cur
    .local pmc rx2198_debug
    (rx2198_cur, rx2198_pos, rx2198_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2198_cur
    .local pmc match
    .lex "$/", match
    length rx2198_eos, rx2198_tgt
    gt rx2198_pos, rx2198_eos, rx2198_done
    set rx2198_off, 0
    lt rx2198_pos, 2, rx2198_start
    sub rx2198_off, rx2198_pos, 1
    substr rx2198_tgt, rx2198_tgt, rx2198_off
  rx2198_start:
    eq $I10, 1, rx2198_restart
    if_null rx2198_debug, debug_1307
    rx2198_cur."!cursor_debug"("START", "default_value")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2199_done
    goto rxscan2199_scan
  rxscan2199_loop:
    (rx2198_pos) = rx2198_cur."from"()
    inc rx2198_pos
    rx2198_cur."!cursor_from"(rx2198_pos)
    ge rx2198_pos, rx2198_eos, rxscan2199_done
  rxscan2199_scan:
    set_addr $I10, rxscan2199_loop
    rx2198_cur."!mark_push"(0, rx2198_pos, $I10)
  rxscan2199_done:
.annotate 'line', 925
  # rx subrule "ws" subtype=method negate=
    rx2198_cur."!cursor_pos"(rx2198_pos)
    $P10 = rx2198_cur."ws"()
    unless $P10, rx2198_fail
    rx2198_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx2198_pos, 1
    gt $I11, rx2198_eos, rx2198_fail
    sub $I11, rx2198_pos, rx2198_off
    ord $I11, rx2198_tgt, $I11
    ne $I11, 61, rx2198_fail
    add rx2198_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2198_cur."!cursor_pos"(rx2198_pos)
    $P10 = rx2198_cur."ws"()
    unless $P10, rx2198_fail
    rx2198_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2198_cur."!cursor_pos"(rx2198_pos)
    $P10 = rx2198_cur."EXPR"("i=")
    unless $P10, rx2198_fail
    rx2198_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2198_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2198_cur."!cursor_pos"(rx2198_pos)
    $P10 = rx2198_cur."ws"()
    unless $P10, rx2198_fail
    rx2198_pos = $P10."pos"()
  # rx pass
    rx2198_cur."!cursor_pass"(rx2198_pos, "default_value")
    if_null rx2198_debug, debug_1308
    rx2198_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx2198_pos)
  debug_1308:
    .return (rx2198_cur)
  rx2198_restart:
.annotate 'line', 438
    if_null rx2198_debug, debug_1309
    rx2198_cur."!cursor_debug"("NEXT", "default_value")
  debug_1309:
  rx2198_fail:
    (rx2198_rep, rx2198_pos, $I10, $P10) = rx2198_cur."!mark_fail"(0)
    lt rx2198_pos, -1, rx2198_done
    eq rx2198_pos, -1, rx2198_fail
    jump $I10
  rx2198_done:
    rx2198_cur."!cursor_fail"()
    if_null rx2198_debug, debug_1310
    rx2198_cur."!cursor_debug"("FAIL", "default_value")
  debug_1310:
    .return (rx2198_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("234_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2204 = self."!PREFIX__!subrule"("ws", "")
    new $P2205, "ResizablePMCArray"
    push $P2205, $P2204
    .return ($P2205)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("235_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2207_tgt
    .local int rx2207_pos
    .local int rx2207_off
    .local int rx2207_eos
    .local int rx2207_rep
    .local pmc rx2207_cur
    .local pmc rx2207_debug
    (rx2207_cur, rx2207_pos, rx2207_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2207_cur
    .local pmc match
    .lex "$/", match
    length rx2207_eos, rx2207_tgt
    gt rx2207_pos, rx2207_eos, rx2207_done
    set rx2207_off, 0
    lt rx2207_pos, 2, rx2207_start
    sub rx2207_off, rx2207_pos, 1
    substr rx2207_tgt, rx2207_tgt, rx2207_off
  rx2207_start:
    eq $I10, 1, rx2207_restart
    if_null rx2207_debug, debug_1311
    rx2207_cur."!cursor_debug"("START", "trait")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2208_done
    goto rxscan2208_scan
  rxscan2208_loop:
    (rx2207_pos) = rx2207_cur."from"()
    inc rx2207_pos
    rx2207_cur."!cursor_from"(rx2207_pos)
    ge rx2207_pos, rx2207_eos, rxscan2208_done
  rxscan2208_scan:
    set_addr $I10, rxscan2208_loop
    rx2207_cur."!mark_push"(0, rx2207_pos, $I10)
  rxscan2208_done:
.annotate 'line', 927
  # rx subrule "ws" subtype=method negate=
    rx2207_cur."!cursor_pos"(rx2207_pos)
    $P10 = rx2207_cur."ws"()
    unless $P10, rx2207_fail
    rx2207_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx2207_cur."!cursor_pos"(rx2207_pos)
    $P10 = rx2207_cur."trait_mod"()
    unless $P10, rx2207_fail
    rx2207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx2207_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2207_cur."!cursor_pos"(rx2207_pos)
    $P10 = rx2207_cur."ws"()
    unless $P10, rx2207_fail
    rx2207_pos = $P10."pos"()
  # rx pass
    rx2207_cur."!cursor_pass"(rx2207_pos, "trait")
    if_null rx2207_debug, debug_1312
    rx2207_cur."!cursor_debug"("PASS", "trait", " at pos=", rx2207_pos)
  debug_1312:
    .return (rx2207_cur)
  rx2207_restart:
.annotate 'line', 438
    if_null rx2207_debug, debug_1313
    rx2207_cur."!cursor_debug"("NEXT", "trait")
  debug_1313:
  rx2207_fail:
    (rx2207_rep, rx2207_pos, $I10, $P10) = rx2207_cur."!mark_fail"(0)
    lt rx2207_pos, -1, rx2207_done
    eq rx2207_pos, -1, rx2207_fail
    jump $I10
  rx2207_done:
    rx2207_cur."!cursor_fail"()
    if_null rx2207_debug, debug_1314
    rx2207_cur."!cursor_debug"("FAIL", "trait")
  debug_1314:
    .return (rx2207_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("236_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2212 = self."!PREFIX__!subrule"("ws", "")
    new $P2213, "ResizablePMCArray"
    push $P2213, $P2212
    .return ($P2213)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("237_1305640955.436")
    .param pmc param_2215
.annotate 'line', 929
    .lex "self", param_2215
    $P2216 = param_2215."!protoregex"("trait_mod")
    .return ($P2216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("238_1305640955.436")
    .param pmc param_2218
.annotate 'line', 929
    .lex "self", param_2218
    $P2219 = param_2218."!PREFIX__!protoregex"("trait_mod")
    .return ($P2219)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("239_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2221_tgt
    .local int rx2221_pos
    .local int rx2221_off
    .local int rx2221_eos
    .local int rx2221_rep
    .local pmc rx2221_cur
    .local pmc rx2221_debug
    (rx2221_cur, rx2221_pos, rx2221_tgt, $I10) = self."!cursor_start"()
    rx2221_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx2221_cur
    .local pmc match
    .lex "$/", match
    length rx2221_eos, rx2221_tgt
    gt rx2221_pos, rx2221_eos, rx2221_done
    set rx2221_off, 0
    lt rx2221_pos, 2, rx2221_start
    sub rx2221_off, rx2221_pos, 1
    substr rx2221_tgt, rx2221_tgt, rx2221_off
  rx2221_start:
    eq $I10, 1, rx2221_restart
    if_null rx2221_debug, debug_1315
    rx2221_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2222_done
    goto rxscan2222_scan
  rxscan2222_loop:
    (rx2221_pos) = rx2221_cur."from"()
    inc rx2221_pos
    rx2221_cur."!cursor_from"(rx2221_pos)
    ge rx2221_pos, rx2221_eos, rxscan2222_done
  rxscan2222_scan:
    set_addr $I10, rxscan2222_loop
    rx2221_cur."!mark_push"(0, rx2221_pos, $I10)
  rxscan2222_done:
.annotate 'line', 930
  # rx subcapture "sym"
    set_addr $I10, rxcap_2223_fail
    rx2221_cur."!mark_push"(0, rx2221_pos, $I10)
  # rx literal  "is"
    add $I11, rx2221_pos, 2
    gt $I11, rx2221_eos, rx2221_fail
    sub $I11, rx2221_pos, rx2221_off
    substr $S10, rx2221_tgt, $I11, 2
    ne $S10, "is", rx2221_fail
    add rx2221_pos, 2
    set_addr $I10, rxcap_2223_fail
    ($I12, $I11) = rx2221_cur."!mark_peek"($I10)
    rx2221_cur."!cursor_pos"($I11)
    ($P10) = rx2221_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2221_pos, "")
    rx2221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2223_done
  rxcap_2223_fail:
    goto rx2221_fail
  rxcap_2223_done:
  # rx subrule "ws" subtype=method negate=
    rx2221_cur."!cursor_pos"(rx2221_pos)
    $P10 = rx2221_cur."ws"()
    unless $P10, rx2221_fail
    rx2221_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx2221_cur."!cursor_pos"(rx2221_pos)
    $P10 = rx2221_cur."deflongname"()
    unless $P10, rx2221_fail
    rx2221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2221_pos = $P10."pos"()
  # rx rxquantr2225 ** 0..1
    set_addr $I10, rxquantr2225_done
    rx2221_cur."!mark_push"(0, rx2221_pos, $I10)
  rxquantr2225_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx2221_cur."!cursor_pos"(rx2221_pos)
    $P10 = rx2221_cur."circumfix"()
    unless $P10, rx2221_fail
    goto rxsubrule2226_pass
  rxsubrule2226_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2221_fail
  rxsubrule2226_pass:
    set_addr $I10, rxsubrule2226_back
    rx2221_cur."!mark_push"(0, rx2221_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx2221_pos = $P10."pos"()
    set_addr $I10, rxquantr2225_done
    (rx2221_rep) = rx2221_cur."!mark_commit"($I10)
  rxquantr2225_done:
  # rx subrule "ws" subtype=method negate=
    rx2221_cur."!cursor_pos"(rx2221_pos)
    $P10 = rx2221_cur."ws"()
    unless $P10, rx2221_fail
    rx2221_pos = $P10."pos"()
  # rx pass
    rx2221_cur."!cursor_pass"(rx2221_pos, "trait_mod:sym<is>")
    if_null rx2221_debug, debug_1316
    rx2221_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx2221_pos)
  debug_1316:
    .return (rx2221_cur)
  rx2221_restart:
.annotate 'line', 438
    if_null rx2221_debug, debug_1317
    rx2221_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1317:
  rx2221_fail:
    (rx2221_rep, rx2221_pos, $I10, $P10) = rx2221_cur."!mark_fail"(0)
    lt rx2221_pos, -1, rx2221_done
    eq rx2221_pos, -1, rx2221_fail
    jump $I10
  rx2221_done:
    rx2221_cur."!cursor_fail"()
    if_null rx2221_debug, debug_1318
    rx2221_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1318:
    .return (rx2221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("240_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2229 = self."!PREFIX__!subrule"("ws", "is")
    new $P2230, "ResizablePMCArray"
    push $P2230, $P2229
    .return ($P2230)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("241_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2232_tgt
    .local int rx2232_pos
    .local int rx2232_off
    .local int rx2232_eos
    .local int rx2232_rep
    .local pmc rx2232_cur
    .local pmc rx2232_debug
    (rx2232_cur, rx2232_pos, rx2232_tgt, $I10) = self."!cursor_start"()
    rx2232_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx2232_cur
    .local pmc match
    .lex "$/", match
    length rx2232_eos, rx2232_tgt
    gt rx2232_pos, rx2232_eos, rx2232_done
    set rx2232_off, 0
    lt rx2232_pos, 2, rx2232_start
    sub rx2232_off, rx2232_pos, 1
    substr rx2232_tgt, rx2232_tgt, rx2232_off
  rx2232_start:
    eq $I10, 1, rx2232_restart
    if_null rx2232_debug, debug_1319
    rx2232_cur."!cursor_debug"("START", "regex_declarator")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2233_done
    goto rxscan2233_scan
  rxscan2233_loop:
    (rx2232_pos) = rx2232_cur."from"()
    inc rx2232_pos
    rx2232_cur."!cursor_from"(rx2232_pos)
    ge rx2232_pos, rx2232_eos, rxscan2233_done
  rxscan2233_scan:
    set_addr $I10, rxscan2233_loop
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  rxscan2233_done:
.annotate 'line', 932
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  alt2235_0:
.annotate 'line', 933
    set_addr $I10, alt2235_1
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
.annotate 'line', 934
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_2237_fail
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2232_pos, 5
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 5
    ne $S10, "proto", rx2232_fail
    add rx2232_pos, 5
    set_addr $I10, rxcap_2237_fail
    ($I12, $I11) = rx2232_cur."!mark_peek"($I10)
    rx2232_cur."!cursor_pos"($I11)
    ($P10) = rx2232_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2232_pos, "")
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_2237_done
  rxcap_2237_fail:
    goto rx2232_fail
  rxcap_2237_done:
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  alt2239_0:
    set_addr $I10, alt2239_1
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2232_pos, 5
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 5
    ne $S10, "regex", rx2232_fail
    add rx2232_pos, 5
    goto alt2239_end
  alt2239_1:
    set_addr $I10, alt2239_2
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  # rx literal  "token"
    add $I11, rx2232_pos, 5
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 5
    ne $S10, "token", rx2232_fail
    add rx2232_pos, 5
    goto alt2239_end
  alt2239_2:
  # rx literal  "rule"
    add $I11, rx2232_pos, 4
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 4
    ne $S10, "rule", rx2232_fail
    add rx2232_pos, 4
  alt2239_end:
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 935
  # rx subrule "deflongname" subtype=capture negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."deflongname"()
    unless $P10, rx2232_fail
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2232_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  alt2242_0:
.annotate 'line', 936
    set_addr $I10, alt2242_1
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
.annotate 'line', 937
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 123, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx2232_pos, 5
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 5
    ne $S10, "<...>", rx2232_fail
    add rx2232_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 125, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ENDSTMT"()
    unless $P10, rx2232_fail
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
    goto alt2242_end
  alt2242_1:
    set_addr $I10, alt2242_2
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
.annotate 'line', 938
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 123, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx2232_pos, 3
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 3
    ne $S10, "<*>", rx2232_fail
    add rx2232_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 125, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ENDSTMT"()
    unless $P10, rx2232_fail
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
    goto alt2242_end
  alt2242_2:
.annotate 'line', 939
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  alt2242_end:
.annotate 'line', 940
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 934
    goto alt2235_end
  alt2235_1:
.annotate 'line', 941
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_2256_fail
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  alt2255_0:
    set_addr $I10, alt2255_1
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2232_pos, 5
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 5
    ne $S10, "regex", rx2232_fail
    add rx2232_pos, 5
    goto alt2255_end
  alt2255_1:
    set_addr $I10, alt2255_2
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  # rx literal  "token"
    add $I11, rx2232_pos, 5
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 5
    ne $S10, "token", rx2232_fail
    add rx2232_pos, 5
    goto alt2255_end
  alt2255_2:
  # rx literal  "rule"
    add $I11, rx2232_pos, 4
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 4
    ne $S10, "rule", rx2232_fail
    add rx2232_pos, 4
  alt2255_end:
    set_addr $I10, rxcap_2256_fail
    ($I12, $I11) = rx2232_cur."!mark_peek"($I10)
    rx2232_cur."!cursor_pos"($I11)
    ($P10) = rx2232_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2232_pos, "")
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2256_done
  rxcap_2256_fail:
    goto rx2232_fail
  rxcap_2256_done:
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 942
  # rx subrule "deflongname" subtype=capture negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."deflongname"()
    unless $P10, rx2232_fail
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2232_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 943
  # rx subrule "newpad" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."newpad"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 944
  # rx rxquantr2260 ** 0..1
    set_addr $I10, rxquantr2260_done
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  rxquantr2260_loop:
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 40, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."signature"()
    unless $P10, rx2232_fail
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2232_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 41, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
    set_addr $I10, rxquantr2260_done
    (rx2232_rep) = rx2232_cur."!mark_commit"($I10)
  rxquantr2260_done:
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 945
  # rx reduce name="regex_declarator" key="open"
    rx2232_cur."!cursor_pos"(rx2232_pos)
    rx2232_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 946
  # rx literal  "{"
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 123, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2232_fail
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2232_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2232_pos, 1
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    ord $I11, rx2232_tgt, $I11
    ne $I11, 125, rx2232_fail
    add rx2232_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ENDSTMT"()
    unless $P10, rx2232_fail
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
  alt2235_end:
.annotate 'line', 947
  # rx subrule "ws" subtype=method negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."ws"()
    unless $P10, rx2232_fail
    rx2232_pos = $P10."pos"()
.annotate 'line', 932
  # rx pass
    rx2232_cur."!cursor_pass"(rx2232_pos, "regex_declarator")
    if_null rx2232_debug, debug_1320
    rx2232_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx2232_pos)
  debug_1320:
    .return (rx2232_cur)
  rx2232_restart:
.annotate 'line', 438
    if_null rx2232_debug, debug_1321
    rx2232_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1321:
  rx2232_fail:
    (rx2232_rep, rx2232_pos, $I10, $P10) = rx2232_cur."!mark_fail"(0)
    lt rx2232_pos, -1, rx2232_done
    eq rx2232_pos, -1, rx2232_fail
    jump $I10
  rx2232_done:
    rx2232_cur."!cursor_fail"()
    if_null rx2232_debug, debug_1322
    rx2232_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1322:
    .return (rx2232_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("242_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2270 = self."!PREFIX__!subrule"("ws", "")
    new $P2271, "ResizablePMCArray"
    push $P2271, $P2270
    .return ($P2271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("243_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2273_tgt
    .local int rx2273_pos
    .local int rx2273_off
    .local int rx2273_eos
    .local int rx2273_rep
    .local pmc rx2273_cur
    .local pmc rx2273_debug
    (rx2273_cur, rx2273_pos, rx2273_tgt, $I10) = self."!cursor_start"()
    rx2273_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2273_cur
    .local pmc match
    .lex "$/", match
    length rx2273_eos, rx2273_tgt
    gt rx2273_pos, rx2273_eos, rx2273_done
    set rx2273_off, 0
    lt rx2273_pos, 2, rx2273_start
    sub rx2273_off, rx2273_pos, 1
    substr rx2273_tgt, rx2273_tgt, rx2273_off
  rx2273_start:
    eq $I10, 1, rx2273_restart
    if_null rx2273_debug, debug_1323
    rx2273_cur."!cursor_debug"("START", "dotty")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2274_done
    goto rxscan2274_scan
  rxscan2274_loop:
    (rx2273_pos) = rx2273_cur."from"()
    inc rx2273_pos
    rx2273_cur."!cursor_from"(rx2273_pos)
    ge rx2273_pos, rx2273_eos, rxscan2274_done
  rxscan2274_scan:
    set_addr $I10, rxscan2274_loop
    rx2273_cur."!mark_push"(0, rx2273_pos, $I10)
  rxscan2274_done:
.annotate 'line', 951
  # rx literal  "."
    add $I11, rx2273_pos, 1
    gt $I11, rx2273_eos, rx2273_fail
    sub $I11, rx2273_pos, rx2273_off
    ord $I11, rx2273_tgt, $I11
    ne $I11, 46, rx2273_fail
    add rx2273_pos, 1
  alt2275_0:
.annotate 'line', 952
    set_addr $I10, alt2275_1
    rx2273_cur."!mark_push"(0, rx2273_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx2273_cur."!cursor_pos"(rx2273_pos)
    $P10 = rx2273_cur."deflongname"()
    unless $P10, rx2273_fail
    rx2273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx2273_pos = $P10."pos"()
    goto alt2275_end
  alt2275_1:
.annotate 'line', 953
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2273_pos, rx2273_off
    substr $S10, rx2273_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx2273_fail
  # rx subrule "quote" subtype=capture negate=
    rx2273_cur."!cursor_pos"(rx2273_pos)
    $P10 = rx2273_cur."quote"()
    unless $P10, rx2273_fail
    rx2273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2273_pos = $P10."pos"()
  alt2276_0:
.annotate 'line', 954
    set_addr $I10, alt2276_1
    rx2273_cur."!mark_push"(0, rx2273_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2273_pos, rx2273_off
    substr $S10, rx2273_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2273_fail
    goto alt2276_end
  alt2276_1:
  # rx subrule "panic" subtype=method negate=
    rx2273_cur."!cursor_pos"(rx2273_pos)
    $P10 = rx2273_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx2273_fail
    rx2273_pos = $P10."pos"()
  alt2276_end:
  alt2275_end:
.annotate 'line', 960
  # rx rxquantr2277 ** 0..1
    set_addr $I10, rxquantr2277_done
    rx2273_cur."!mark_push"(0, rx2273_pos, $I10)
  rxquantr2277_loop:
  alt2278_0:
.annotate 'line', 957
    set_addr $I10, alt2278_1
    rx2273_cur."!mark_push"(0, rx2273_pos, $I10)
.annotate 'line', 958
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2273_pos, rx2273_off
    substr $S10, rx2273_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2273_fail
  # rx subrule "args" subtype=capture negate=
    rx2273_cur."!cursor_pos"(rx2273_pos)
    $P10 = rx2273_cur."args"()
    unless $P10, rx2273_fail
    rx2273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2273_pos = $P10."pos"()
    goto alt2278_end
  alt2278_1:
.annotate 'line', 959
  # rx literal  ":"
    add $I11, rx2273_pos, 1
    gt $I11, rx2273_eos, rx2273_fail
    sub $I11, rx2273_pos, rx2273_off
    ord $I11, rx2273_tgt, $I11
    ne $I11, 58, rx2273_fail
    add rx2273_pos, 1
  # rx charclass s
    ge rx2273_pos, rx2273_eos, rx2273_fail
    sub $I10, rx2273_pos, rx2273_off
    is_cclass $I11, 32, rx2273_tgt, $I10
    unless $I11, rx2273_fail
    inc rx2273_pos
  # rx subrule "arglist" subtype=capture negate=
    rx2273_cur."!cursor_pos"(rx2273_pos)
    $P10 = rx2273_cur."arglist"()
    unless $P10, rx2273_fail
    rx2273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2273_pos = $P10."pos"()
  alt2278_end:
.annotate 'line', 960
    set_addr $I10, rxquantr2277_done
    (rx2273_rep) = rx2273_cur."!mark_commit"($I10)
  rxquantr2277_done:
.annotate 'line', 950
  # rx pass
    rx2273_cur."!cursor_pass"(rx2273_pos, "dotty")
    if_null rx2273_debug, debug_1324
    rx2273_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx2273_pos)
  debug_1324:
    .return (rx2273_cur)
  rx2273_restart:
.annotate 'line', 438
    if_null rx2273_debug, debug_1325
    rx2273_cur."!cursor_debug"("NEXT", "dotty")
  debug_1325:
  rx2273_fail:
    (rx2273_rep, rx2273_pos, $I10, $P10) = rx2273_cur."!mark_fail"(0)
    lt rx2273_pos, -1, rx2273_done
    eq rx2273_pos, -1, rx2273_fail
    jump $I10
  rx2273_done:
    rx2273_cur."!cursor_fail"()
    if_null rx2273_debug, debug_1326
    rx2273_cur."!cursor_debug"("FAIL", "dotty")
  debug_1326:
    .return (rx2273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("244_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2280 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P2281, "ResizablePMCArray"
    push $P2281, "'"
    push $P2281, "\""
    push $P2281, $P2280
    .return ($P2281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("245_1305640955.436")
    .param pmc param_2283
.annotate 'line', 964
    .lex "self", param_2283
    $P2284 = param_2283."!protoregex"("term")
    .return ($P2284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("246_1305640955.436")
    .param pmc param_2286
.annotate 'line', 964
    .lex "self", param_2286
    $P2287 = param_2286."!PREFIX__!protoregex"("term")
    .return ($P2287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("247_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2289_tgt
    .local int rx2289_pos
    .local int rx2289_off
    .local int rx2289_eos
    .local int rx2289_rep
    .local pmc rx2289_cur
    .local pmc rx2289_debug
    (rx2289_cur, rx2289_pos, rx2289_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2289_cur
    .local pmc match
    .lex "$/", match
    length rx2289_eos, rx2289_tgt
    gt rx2289_pos, rx2289_eos, rx2289_done
    set rx2289_off, 0
    lt rx2289_pos, 2, rx2289_start
    sub rx2289_off, rx2289_pos, 1
    substr rx2289_tgt, rx2289_tgt, rx2289_off
  rx2289_start:
    eq $I10, 1, rx2289_restart
    if_null rx2289_debug, debug_1327
    rx2289_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2290_done
    goto rxscan2290_scan
  rxscan2290_loop:
    (rx2289_pos) = rx2289_cur."from"()
    inc rx2289_pos
    rx2289_cur."!cursor_from"(rx2289_pos)
    ge rx2289_pos, rx2289_eos, rxscan2290_done
  rxscan2290_scan:
    set_addr $I10, rxscan2290_loop
    rx2289_cur."!mark_push"(0, rx2289_pos, $I10)
  rxscan2290_done:
.annotate 'line', 966
  # rx subcapture "sym"
    set_addr $I10, rxcap_2291_fail
    rx2289_cur."!mark_push"(0, rx2289_pos, $I10)
  # rx literal  "self"
    add $I11, rx2289_pos, 4
    gt $I11, rx2289_eos, rx2289_fail
    sub $I11, rx2289_pos, rx2289_off
    substr $S10, rx2289_tgt, $I11, 4
    ne $S10, "self", rx2289_fail
    add rx2289_pos, 4
    set_addr $I10, rxcap_2291_fail
    ($I12, $I11) = rx2289_cur."!mark_peek"($I10)
    rx2289_cur."!cursor_pos"($I11)
    ($P10) = rx2289_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2289_pos, "")
    rx2289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2291_done
  rxcap_2291_fail:
    goto rx2289_fail
  rxcap_2291_done:
  # rxanchor rwb
    le rx2289_pos, 0, rx2289_fail
    sub $I10, rx2289_pos, rx2289_off
    is_cclass $I11, 8192, rx2289_tgt, $I10
    if $I11, rx2289_fail
    dec $I10
    is_cclass $I11, 8192, rx2289_tgt, $I10
    unless $I11, rx2289_fail
  # rx pass
    rx2289_cur."!cursor_pass"(rx2289_pos, "term:sym<self>")
    if_null rx2289_debug, debug_1328
    rx2289_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx2289_pos)
  debug_1328:
    .return (rx2289_cur)
  rx2289_restart:
.annotate 'line', 438
    if_null rx2289_debug, debug_1329
    rx2289_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1329:
  rx2289_fail:
    (rx2289_rep, rx2289_pos, $I10, $P10) = rx2289_cur."!mark_fail"(0)
    lt rx2289_pos, -1, rx2289_done
    eq rx2289_pos, -1, rx2289_fail
    jump $I10
  rx2289_done:
    rx2289_cur."!cursor_fail"()
    if_null rx2289_debug, debug_1330
    rx2289_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1330:
    .return (rx2289_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("248_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2293, "ResizablePMCArray"
    push $P2293, "self"
    .return ($P2293)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("249_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2295_tgt
    .local int rx2295_pos
    .local int rx2295_off
    .local int rx2295_eos
    .local int rx2295_rep
    .local pmc rx2295_cur
    .local pmc rx2295_debug
    (rx2295_cur, rx2295_pos, rx2295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2295_cur
    .local pmc match
    .lex "$/", match
    length rx2295_eos, rx2295_tgt
    gt rx2295_pos, rx2295_eos, rx2295_done
    set rx2295_off, 0
    lt rx2295_pos, 2, rx2295_start
    sub rx2295_off, rx2295_pos, 1
    substr rx2295_tgt, rx2295_tgt, rx2295_off
  rx2295_start:
    eq $I10, 1, rx2295_restart
    if_null rx2295_debug, debug_1331
    rx2295_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2296_done
    goto rxscan2296_scan
  rxscan2296_loop:
    (rx2295_pos) = rx2295_cur."from"()
    inc rx2295_pos
    rx2295_cur."!cursor_from"(rx2295_pos)
    ge rx2295_pos, rx2295_eos, rxscan2296_done
  rxscan2296_scan:
    set_addr $I10, rxscan2296_loop
    rx2295_cur."!mark_push"(0, rx2295_pos, $I10)
  rxscan2296_done:
.annotate 'line', 969
  # rx subrule "deflongname" subtype=capture negate=
    rx2295_cur."!cursor_pos"(rx2295_pos)
    $P10 = rx2295_cur."deflongname"()
    unless $P10, rx2295_fail
    rx2295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2295_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2295_pos, rx2295_off
    substr $S10, rx2295_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2295_fail
  # rx subrule "args" subtype=capture negate=
    rx2295_cur."!cursor_pos"(rx2295_pos)
    $P10 = rx2295_cur."args"()
    unless $P10, rx2295_fail
    rx2295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2295_pos = $P10."pos"()
.annotate 'line', 968
  # rx pass
    rx2295_cur."!cursor_pass"(rx2295_pos, "term:sym<identifier>")
    if_null rx2295_debug, debug_1332
    rx2295_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx2295_pos)
  debug_1332:
    .return (rx2295_cur)
  rx2295_restart:
.annotate 'line', 438
    if_null rx2295_debug, debug_1333
    rx2295_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1333:
  rx2295_fail:
    (rx2295_rep, rx2295_pos, $I10, $P10) = rx2295_cur."!mark_fail"(0)
    lt rx2295_pos, -1, rx2295_done
    eq rx2295_pos, -1, rx2295_fail
    jump $I10
  rx2295_done:
    rx2295_cur."!cursor_fail"()
    if_null rx2295_debug, debug_1334
    rx2295_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1334:
    .return (rx2295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("250_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2298 = self."!PREFIX__!subrule"("deflongname", "")
    new $P2299, "ResizablePMCArray"
    push $P2299, $P2298
    .return ($P2299)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("251_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2301_tgt
    .local int rx2301_pos
    .local int rx2301_off
    .local int rx2301_eos
    .local int rx2301_rep
    .local pmc rx2301_cur
    .local pmc rx2301_debug
    (rx2301_cur, rx2301_pos, rx2301_tgt, $I10) = self."!cursor_start"()
    rx2301_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2301_cur
    .local pmc match
    .lex "$/", match
    length rx2301_eos, rx2301_tgt
    gt rx2301_pos, rx2301_eos, rx2301_done
    set rx2301_off, 0
    lt rx2301_pos, 2, rx2301_start
    sub rx2301_off, rx2301_pos, 1
    substr rx2301_tgt, rx2301_tgt, rx2301_off
  rx2301_start:
    eq $I10, 1, rx2301_restart
    if_null rx2301_debug, debug_1335
    rx2301_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2302_done
    goto rxscan2302_scan
  rxscan2302_loop:
    (rx2301_pos) = rx2301_cur."from"()
    inc rx2301_pos
    rx2301_cur."!cursor_from"(rx2301_pos)
    ge rx2301_pos, rx2301_eos, rxscan2302_done
  rxscan2302_scan:
    set_addr $I10, rxscan2302_loop
    rx2301_cur."!mark_push"(0, rx2301_pos, $I10)
  rxscan2302_done:
.annotate 'line', 973
  # rx subrule "name" subtype=capture negate=
    rx2301_cur."!cursor_pos"(rx2301_pos)
    $P10 = rx2301_cur."name"()
    unless $P10, rx2301_fail
    rx2301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2301_pos = $P10."pos"()
  # rx rxquantr2303 ** 0..1
    set_addr $I10, rxquantr2303_done
    rx2301_cur."!mark_push"(0, rx2301_pos, $I10)
  rxquantr2303_loop:
  # rx subrule "args" subtype=capture negate=
    rx2301_cur."!cursor_pos"(rx2301_pos)
    $P10 = rx2301_cur."args"()
    unless $P10, rx2301_fail
    goto rxsubrule2304_pass
  rxsubrule2304_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2301_fail
  rxsubrule2304_pass:
    set_addr $I10, rxsubrule2304_back
    rx2301_cur."!mark_push"(0, rx2301_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2301_pos = $P10."pos"()
    set_addr $I10, rxquantr2303_done
    (rx2301_rep) = rx2301_cur."!mark_commit"($I10)
  rxquantr2303_done:
.annotate 'line', 972
  # rx pass
    rx2301_cur."!cursor_pass"(rx2301_pos, "term:sym<name>")
    if_null rx2301_debug, debug_1336
    rx2301_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx2301_pos)
  debug_1336:
    .return (rx2301_cur)
  rx2301_restart:
.annotate 'line', 438
    if_null rx2301_debug, debug_1337
    rx2301_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1337:
  rx2301_fail:
    (rx2301_rep, rx2301_pos, $I10, $P10) = rx2301_cur."!mark_fail"(0)
    lt rx2301_pos, -1, rx2301_done
    eq rx2301_pos, -1, rx2301_fail
    jump $I10
  rx2301_done:
    rx2301_cur."!cursor_fail"()
    if_null rx2301_debug, debug_1338
    rx2301_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1338:
    .return (rx2301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("252_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2306 = self."!PREFIX__!subrule"("name", "")
    new $P2307, "ResizablePMCArray"
    push $P2307, $P2306
    .return ($P2307)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("253_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2309_tgt
    .local int rx2309_pos
    .local int rx2309_off
    .local int rx2309_eos
    .local int rx2309_rep
    .local pmc rx2309_cur
    .local pmc rx2309_debug
    (rx2309_cur, rx2309_pos, rx2309_tgt, $I10) = self."!cursor_start"()
    rx2309_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2309_cur
    .local pmc match
    .lex "$/", match
    length rx2309_eos, rx2309_tgt
    gt rx2309_pos, rx2309_eos, rx2309_done
    set rx2309_off, 0
    lt rx2309_pos, 2, rx2309_start
    sub rx2309_off, rx2309_pos, 1
    substr rx2309_tgt, rx2309_tgt, rx2309_off
  rx2309_start:
    eq $I10, 1, rx2309_restart
    if_null rx2309_debug, debug_1339
    rx2309_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1339:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2310_done
    goto rxscan2310_scan
  rxscan2310_loop:
    (rx2309_pos) = rx2309_cur."from"()
    inc rx2309_pos
    rx2309_cur."!cursor_from"(rx2309_pos)
    ge rx2309_pos, rx2309_eos, rxscan2310_done
  rxscan2310_scan:
    set_addr $I10, rxscan2310_loop
    rx2309_cur."!mark_push"(0, rx2309_pos, $I10)
  rxscan2310_done:
.annotate 'line', 977
  # rx literal  "pir::"
    add $I11, rx2309_pos, 5
    gt $I11, rx2309_eos, rx2309_fail
    sub $I11, rx2309_pos, rx2309_off
    substr $S10, rx2309_tgt, $I11, 5
    ne $S10, "pir::", rx2309_fail
    add rx2309_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_2311_fail
    rx2309_cur."!mark_push"(0, rx2309_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx2309_pos, rx2309_off
    find_not_cclass $I11, 8192, rx2309_tgt, $I10, rx2309_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx2309_fail
    add rx2309_pos, rx2309_off, $I11
    set_addr $I10, rxcap_2311_fail
    ($I12, $I11) = rx2309_cur."!mark_peek"($I10)
    rx2309_cur."!cursor_pos"($I11)
    ($P10) = rx2309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2309_pos, "")
    rx2309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_2311_done
  rxcap_2311_fail:
    goto rx2309_fail
  rxcap_2311_done:
  # rx rxquantr2312 ** 0..1
    set_addr $I10, rxquantr2312_done
    rx2309_cur."!mark_push"(0, rx2309_pos, $I10)
  rxquantr2312_loop:
  # rx subrule "args" subtype=capture negate=
    rx2309_cur."!cursor_pos"(rx2309_pos)
    $P10 = rx2309_cur."args"()
    unless $P10, rx2309_fail
    goto rxsubrule2313_pass
  rxsubrule2313_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2309_fail
  rxsubrule2313_pass:
    set_addr $I10, rxsubrule2313_back
    rx2309_cur."!mark_push"(0, rx2309_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2309_pos = $P10."pos"()
    set_addr $I10, rxquantr2312_done
    (rx2309_rep) = rx2309_cur."!mark_commit"($I10)
  rxquantr2312_done:
.annotate 'line', 976
  # rx pass
    rx2309_cur."!cursor_pass"(rx2309_pos, "term:sym<pir::op>")
    if_null rx2309_debug, debug_1340
    rx2309_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx2309_pos)
  debug_1340:
    .return (rx2309_cur)
  rx2309_restart:
.annotate 'line', 438
    if_null rx2309_debug, debug_1341
    rx2309_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1341:
  rx2309_fail:
    (rx2309_rep, rx2309_pos, $I10, $P10) = rx2309_cur."!mark_fail"(0)
    lt rx2309_pos, -1, rx2309_done
    eq rx2309_pos, -1, rx2309_fail
    jump $I10
  rx2309_done:
    rx2309_cur."!cursor_fail"()
    if_null rx2309_debug, debug_1342
    rx2309_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1342:
    .return (rx2309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("254_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2315, "ResizablePMCArray"
    push $P2315, "pir::"
    .return ($P2315)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("255_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P2323 = "256_1305640955.436" 
    capture_lex $P2323
    .local string rx2317_tgt
    .local int rx2317_pos
    .local int rx2317_off
    .local int rx2317_eos
    .local int rx2317_rep
    .local pmc rx2317_cur
    .local pmc rx2317_debug
    (rx2317_cur, rx2317_pos, rx2317_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2317_cur
    .local pmc match
    .lex "$/", match
    length rx2317_eos, rx2317_tgt
    gt rx2317_pos, rx2317_eos, rx2317_done
    set rx2317_off, 0
    lt rx2317_pos, 2, rx2317_start
    sub rx2317_off, rx2317_pos, 1
    substr rx2317_tgt, rx2317_tgt, rx2317_off
  rx2317_start:
    eq $I10, 1, rx2317_restart
    if_null rx2317_debug, debug_1343
    rx2317_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1343:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2318_done
    goto rxscan2318_scan
  rxscan2318_loop:
    (rx2317_pos) = rx2317_cur."from"()
    inc rx2317_pos
    rx2317_cur."!cursor_from"(rx2317_pos)
    ge rx2317_pos, rx2317_eos, rxscan2318_done
  rxscan2318_scan:
    set_addr $I10, rxscan2318_loop
    rx2317_cur."!mark_push"(0, rx2317_pos, $I10)
  rxscan2318_done:
.annotate 'line', 981
  # rx literal  "{*}"
    add $I11, rx2317_pos, 3
    gt $I11, rx2317_eos, rx2317_fail
    sub $I11, rx2317_pos, rx2317_off
    substr $S10, rx2317_tgt, $I11, 3
    ne $S10, "{*}", rx2317_fail
    add rx2317_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2317_cur."!cursor_pos"(rx2317_pos)
    $P10 = rx2317_cur."ENDSTMT"()
    unless $P10, rx2317_fail
  alt2319_0:
.annotate 'line', 982
    set_addr $I10, alt2319_1
    rx2317_cur."!mark_push"(0, rx2317_pos, $I10)
    rx2317_cur."!cursor_pos"(rx2317_pos)
    find_lex $P2320, unicode:"$\x{a2}"
    $P2321 = $P2320."MATCH"()
    store_lex "$/", $P2321
    .const 'Sub' $P2323 = "256_1305640955.436" 
    capture_lex $P2323
    $P2329 = $P2323()
    unless $P2329, rx2317_fail
    goto alt2319_end
  alt2319_1:
  # rx subrule "panic" subtype=method negate=
    rx2317_cur."!cursor_pos"(rx2317_pos)
    $P10 = rx2317_cur."panic"("{*} may only appear in proto")
    unless $P10, rx2317_fail
    rx2317_pos = $P10."pos"()
  alt2319_end:
.annotate 'line', 980
  # rx pass
    rx2317_cur."!cursor_pass"(rx2317_pos, "term:sym<onlystar>")
    if_null rx2317_debug, debug_1346
    rx2317_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx2317_pos)
  debug_1346:
    .return (rx2317_cur)
  rx2317_restart:
.annotate 'line', 438
    if_null rx2317_debug, debug_1347
    rx2317_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1347:
  rx2317_fail:
    (rx2317_rep, rx2317_pos, $I10, $P10) = rx2317_cur."!mark_fail"(0)
    lt rx2317_pos, -1, rx2317_done
    eq rx2317_pos, -1, rx2317_fail
    jump $I10
  rx2317_done:
    rx2317_cur."!cursor_fail"()
    if_null rx2317_debug, debug_1348
    rx2317_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1348:
    .return (rx2317_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2322"  :anon :subid("256_1305640955.436") :outer("255_1305640955.436")
.annotate 'line', 982
    find_dynamic_lex $P2326, "$*MULTINESS"
    unless_null $P2326, vivify_1344
    get_hll_global $P2324, "GLOBAL"
    get_who $P2325, $P2324
    set $P2326, $P2325["$MULTINESS"]
    unless_null $P2326, vivify_1345
    die "Contextual $*MULTINESS not found"
  vivify_1345:
  vivify_1344:
    set $S2327, $P2326
    iseq $I2328, $S2327, "proto"
    .return ($I2328)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("257_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2331, "ResizablePMCArray"
    push $P2331, "{*}"
    .return ($P2331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("258_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2333_tgt
    .local int rx2333_pos
    .local int rx2333_off
    .local int rx2333_eos
    .local int rx2333_rep
    .local pmc rx2333_cur
    .local pmc rx2333_debug
    (rx2333_cur, rx2333_pos, rx2333_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2333_cur
    .local pmc match
    .lex "$/", match
    length rx2333_eos, rx2333_tgt
    gt rx2333_pos, rx2333_eos, rx2333_done
    set rx2333_off, 0
    lt rx2333_pos, 2, rx2333_start
    sub rx2333_off, rx2333_pos, 1
    substr rx2333_tgt, rx2333_tgt, rx2333_off
  rx2333_start:
    eq $I10, 1, rx2333_restart
    if_null rx2333_debug, debug_1349
    rx2333_cur."!cursor_debug"("START", "args")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2334_done
    goto rxscan2334_scan
  rxscan2334_loop:
    (rx2333_pos) = rx2333_cur."from"()
    inc rx2333_pos
    rx2333_cur."!cursor_from"(rx2333_pos)
    ge rx2333_pos, rx2333_eos, rxscan2334_done
  rxscan2334_scan:
    set_addr $I10, rxscan2334_loop
    rx2333_cur."!mark_push"(0, rx2333_pos, $I10)
  rxscan2334_done:
.annotate 'line', 986
  # rx literal  "("
    add $I11, rx2333_pos, 1
    gt $I11, rx2333_eos, rx2333_fail
    sub $I11, rx2333_pos, rx2333_off
    ord $I11, rx2333_tgt, $I11
    ne $I11, 40, rx2333_fail
    add rx2333_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2333_cur."!cursor_pos"(rx2333_pos)
    $P10 = rx2333_cur."arglist"()
    unless $P10, rx2333_fail
    rx2333_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2333_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2333_pos, 1
    gt $I11, rx2333_eos, rx2333_fail
    sub $I11, rx2333_pos, rx2333_off
    ord $I11, rx2333_tgt, $I11
    ne $I11, 41, rx2333_fail
    add rx2333_pos, 1
  # rx pass
    rx2333_cur."!cursor_pass"(rx2333_pos, "args")
    if_null rx2333_debug, debug_1350
    rx2333_cur."!cursor_debug"("PASS", "args", " at pos=", rx2333_pos)
  debug_1350:
    .return (rx2333_cur)
  rx2333_restart:
.annotate 'line', 438
    if_null rx2333_debug, debug_1351
    rx2333_cur."!cursor_debug"("NEXT", "args")
  debug_1351:
  rx2333_fail:
    (rx2333_rep, rx2333_pos, $I10, $P10) = rx2333_cur."!mark_fail"(0)
    lt rx2333_pos, -1, rx2333_done
    eq rx2333_pos, -1, rx2333_fail
    jump $I10
  rx2333_done:
    rx2333_cur."!cursor_fail"()
    if_null rx2333_debug, debug_1352
    rx2333_cur."!cursor_debug"("FAIL", "args")
  debug_1352:
    .return (rx2333_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("259_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2336 = self."!PREFIX__!subrule"("arglist", "(")
    new $P2337, "ResizablePMCArray"
    push $P2337, $P2336
    .return ($P2337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("260_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2339_tgt
    .local int rx2339_pos
    .local int rx2339_off
    .local int rx2339_eos
    .local int rx2339_rep
    .local pmc rx2339_cur
    .local pmc rx2339_debug
    (rx2339_cur, rx2339_pos, rx2339_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2339_cur
    .local pmc match
    .lex "$/", match
    length rx2339_eos, rx2339_tgt
    gt rx2339_pos, rx2339_eos, rx2339_done
    set rx2339_off, 0
    lt rx2339_pos, 2, rx2339_start
    sub rx2339_off, rx2339_pos, 1
    substr rx2339_tgt, rx2339_tgt, rx2339_off
  rx2339_start:
    eq $I10, 1, rx2339_restart
    if_null rx2339_debug, debug_1353
    rx2339_cur."!cursor_debug"("START", "arglist")
  debug_1353:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2340_done
    goto rxscan2340_scan
  rxscan2340_loop:
    (rx2339_pos) = rx2339_cur."from"()
    inc rx2339_pos
    rx2339_cur."!cursor_from"(rx2339_pos)
    ge rx2339_pos, rx2339_eos, rxscan2340_done
  rxscan2340_scan:
    set_addr $I10, rxscan2340_loop
    rx2339_cur."!mark_push"(0, rx2339_pos, $I10)
  rxscan2340_done:
.annotate 'line', 990
  # rx subrule "ws" subtype=method negate=
    rx2339_cur."!cursor_pos"(rx2339_pos)
    $P10 = rx2339_cur."ws"()
    unless $P10, rx2339_fail
    rx2339_pos = $P10."pos"()
  alt2341_0:
.annotate 'line', 991
    set_addr $I10, alt2341_1
    rx2339_cur."!mark_push"(0, rx2339_pos, $I10)
.annotate 'line', 992
  # rx subrule "EXPR" subtype=capture negate=
    rx2339_cur."!cursor_pos"(rx2339_pos)
    $P10 = rx2339_cur."EXPR"("f=")
    unless $P10, rx2339_fail
    rx2339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2339_pos = $P10."pos"()
    goto alt2341_end
  alt2341_1:
  alt2341_end:
.annotate 'line', 989
  # rx pass
    rx2339_cur."!cursor_pass"(rx2339_pos, "arglist")
    if_null rx2339_debug, debug_1354
    rx2339_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx2339_pos)
  debug_1354:
    .return (rx2339_cur)
  rx2339_restart:
.annotate 'line', 438
    if_null rx2339_debug, debug_1355
    rx2339_cur."!cursor_debug"("NEXT", "arglist")
  debug_1355:
  rx2339_fail:
    (rx2339_rep, rx2339_pos, $I10, $P10) = rx2339_cur."!mark_fail"(0)
    lt rx2339_pos, -1, rx2339_done
    eq rx2339_pos, -1, rx2339_fail
    jump $I10
  rx2339_done:
    rx2339_cur."!cursor_fail"()
    if_null rx2339_debug, debug_1356
    rx2339_cur."!cursor_debug"("FAIL", "arglist")
  debug_1356:
    .return (rx2339_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("261_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2343 = self."!PREFIX__!subrule"("ws", "")
    new $P2344, "ResizablePMCArray"
    push $P2344, $P2343
    .return ($P2344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("262_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2346_tgt
    .local int rx2346_pos
    .local int rx2346_off
    .local int rx2346_eos
    .local int rx2346_rep
    .local pmc rx2346_cur
    .local pmc rx2346_debug
    (rx2346_cur, rx2346_pos, rx2346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2346_cur
    .local pmc match
    .lex "$/", match
    length rx2346_eos, rx2346_tgt
    gt rx2346_pos, rx2346_eos, rx2346_done
    set rx2346_off, 0
    lt rx2346_pos, 2, rx2346_start
    sub rx2346_off, rx2346_pos, 1
    substr rx2346_tgt, rx2346_tgt, rx2346_off
  rx2346_start:
    eq $I10, 1, rx2346_restart
    if_null rx2346_debug, debug_1357
    rx2346_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2347_done
    goto rxscan2347_scan
  rxscan2347_loop:
    (rx2346_pos) = rx2346_cur."from"()
    inc rx2346_pos
    rx2346_cur."!cursor_from"(rx2346_pos)
    ge rx2346_pos, rx2346_eos, rxscan2347_done
  rxscan2347_scan:
    set_addr $I10, rxscan2347_loop
    rx2346_cur."!mark_push"(0, rx2346_pos, $I10)
  rxscan2347_done:
.annotate 'line', 998
  # rx subrule "value" subtype=capture negate=
    rx2346_cur."!cursor_pos"(rx2346_pos)
    $P10 = rx2346_cur."value"()
    unless $P10, rx2346_fail
    rx2346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx2346_pos = $P10."pos"()
  # rx pass
    rx2346_cur."!cursor_pass"(rx2346_pos, "term:sym<value>")
    if_null rx2346_debug, debug_1358
    rx2346_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx2346_pos)
  debug_1358:
    .return (rx2346_cur)
  rx2346_restart:
.annotate 'line', 438
    if_null rx2346_debug, debug_1359
    rx2346_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1359:
  rx2346_fail:
    (rx2346_rep, rx2346_pos, $I10, $P10) = rx2346_cur."!mark_fail"(0)
    lt rx2346_pos, -1, rx2346_done
    eq rx2346_pos, -1, rx2346_fail
    jump $I10
  rx2346_done:
    rx2346_cur."!cursor_fail"()
    if_null rx2346_debug, debug_1360
    rx2346_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1360:
    .return (rx2346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("263_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2349 = self."!PREFIX__!subrule"("value", "")
    new $P2350, "ResizablePMCArray"
    push $P2350, $P2349
    .return ($P2350)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("264_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2352_tgt
    .local int rx2352_pos
    .local int rx2352_off
    .local int rx2352_eos
    .local int rx2352_rep
    .local pmc rx2352_cur
    .local pmc rx2352_debug
    (rx2352_cur, rx2352_pos, rx2352_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2352_cur
    .local pmc match
    .lex "$/", match
    length rx2352_eos, rx2352_tgt
    gt rx2352_pos, rx2352_eos, rx2352_done
    set rx2352_off, 0
    lt rx2352_pos, 2, rx2352_start
    sub rx2352_off, rx2352_pos, 1
    substr rx2352_tgt, rx2352_tgt, rx2352_off
  rx2352_start:
    eq $I10, 1, rx2352_restart
    if_null rx2352_debug, debug_1361
    rx2352_cur."!cursor_debug"("START", "value")
  debug_1361:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2353_done
    goto rxscan2353_scan
  rxscan2353_loop:
    (rx2352_pos) = rx2352_cur."from"()
    inc rx2352_pos
    rx2352_cur."!cursor_from"(rx2352_pos)
    ge rx2352_pos, rx2352_eos, rxscan2353_done
  rxscan2353_scan:
    set_addr $I10, rxscan2353_loop
    rx2352_cur."!mark_push"(0, rx2352_pos, $I10)
  rxscan2353_done:
  alt2354_0:
.annotate 'line', 1000
    set_addr $I10, alt2354_1
    rx2352_cur."!mark_push"(0, rx2352_pos, $I10)
.annotate 'line', 1001
  # rx subrule "quote" subtype=capture negate=
    rx2352_cur."!cursor_pos"(rx2352_pos)
    $P10 = rx2352_cur."quote"()
    unless $P10, rx2352_fail
    rx2352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2352_pos = $P10."pos"()
    goto alt2354_end
  alt2354_1:
.annotate 'line', 1002
  # rx subrule "number" subtype=capture negate=
    rx2352_cur."!cursor_pos"(rx2352_pos)
    $P10 = rx2352_cur."number"()
    unless $P10, rx2352_fail
    rx2352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx2352_pos = $P10."pos"()
  alt2354_end:
.annotate 'line', 1000
  # rx pass
    rx2352_cur."!cursor_pass"(rx2352_pos, "value")
    if_null rx2352_debug, debug_1362
    rx2352_cur."!cursor_debug"("PASS", "value", " at pos=", rx2352_pos)
  debug_1362:
    .return (rx2352_cur)
  rx2352_restart:
.annotate 'line', 438
    if_null rx2352_debug, debug_1363
    rx2352_cur."!cursor_debug"("NEXT", "value")
  debug_1363:
  rx2352_fail:
    (rx2352_rep, rx2352_pos, $I10, $P10) = rx2352_cur."!mark_fail"(0)
    lt rx2352_pos, -1, rx2352_done
    eq rx2352_pos, -1, rx2352_fail
    jump $I10
  rx2352_done:
    rx2352_cur."!cursor_fail"()
    if_null rx2352_debug, debug_1364
    rx2352_cur."!cursor_debug"("FAIL", "value")
  debug_1364:
    .return (rx2352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("265_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2356 = self."!PREFIX__!subrule"("number", "")
    $P2357 = self."!PREFIX__!subrule"("quote", "")
    new $P2358, "ResizablePMCArray"
    push $P2358, $P2356
    push $P2358, $P2357
    .return ($P2358)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("266_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2360_tgt
    .local int rx2360_pos
    .local int rx2360_off
    .local int rx2360_eos
    .local int rx2360_rep
    .local pmc rx2360_cur
    .local pmc rx2360_debug
    (rx2360_cur, rx2360_pos, rx2360_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2360_cur
    .local pmc match
    .lex "$/", match
    length rx2360_eos, rx2360_tgt
    gt rx2360_pos, rx2360_eos, rx2360_done
    set rx2360_off, 0
    lt rx2360_pos, 2, rx2360_start
    sub rx2360_off, rx2360_pos, 1
    substr rx2360_tgt, rx2360_tgt, rx2360_off
  rx2360_start:
    eq $I10, 1, rx2360_restart
    if_null rx2360_debug, debug_1365
    rx2360_cur."!cursor_debug"("START", "number")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2361_done
    goto rxscan2361_scan
  rxscan2361_loop:
    (rx2360_pos) = rx2360_cur."from"()
    inc rx2360_pos
    rx2360_cur."!cursor_from"(rx2360_pos)
    ge rx2360_pos, rx2360_eos, rxscan2361_done
  rxscan2361_scan:
    set_addr $I10, rxscan2361_loop
    rx2360_cur."!mark_push"(0, rx2360_pos, $I10)
  rxscan2361_done:
.annotate 'line', 1006
  # rx subcapture "sign"
    set_addr $I10, rxcap_2363_fail
    rx2360_cur."!mark_push"(0, rx2360_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx2360_pos, rx2360_off
    set rx2360_rep, 0
    sub $I12, rx2360_eos, rx2360_pos
    le $I12, 1, rxenumcharlistq2362_loop
    set $I12, 1
  rxenumcharlistq2362_loop:
    le $I12, 0, rxenumcharlistq2362_done
    substr $S10, rx2360_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq2362_done
    inc rx2360_rep
  rxenumcharlistq2362_done:
    add rx2360_pos, rx2360_pos, rx2360_rep
    set_addr $I10, rxcap_2363_fail
    ($I12, $I11) = rx2360_cur."!mark_peek"($I10)
    rx2360_cur."!cursor_pos"($I11)
    ($P10) = rx2360_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2360_pos, "")
    rx2360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_2363_done
  rxcap_2363_fail:
    goto rx2360_fail
  rxcap_2363_done:
  alt2364_0:
.annotate 'line', 1007
    set_addr $I10, alt2364_1
    rx2360_cur."!mark_push"(0, rx2360_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx2360_cur."!cursor_pos"(rx2360_pos)
    $P10 = rx2360_cur."dec_number"()
    unless $P10, rx2360_fail
    rx2360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx2360_pos = $P10."pos"()
    goto alt2364_end
  alt2364_1:
  # rx subrule "integer" subtype=capture negate=
    rx2360_cur."!cursor_pos"(rx2360_pos)
    $P10 = rx2360_cur."integer"()
    unless $P10, rx2360_fail
    rx2360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx2360_pos = $P10."pos"()
  alt2364_end:
.annotate 'line', 1005
  # rx pass
    rx2360_cur."!cursor_pass"(rx2360_pos, "number")
    if_null rx2360_debug, debug_1366
    rx2360_cur."!cursor_debug"("PASS", "number", " at pos=", rx2360_pos)
  debug_1366:
    .return (rx2360_cur)
  rx2360_restart:
.annotate 'line', 438
    if_null rx2360_debug, debug_1367
    rx2360_cur."!cursor_debug"("NEXT", "number")
  debug_1367:
  rx2360_fail:
    (rx2360_rep, rx2360_pos, $I10, $P10) = rx2360_cur."!mark_fail"(0)
    lt rx2360_pos, -1, rx2360_done
    eq rx2360_pos, -1, rx2360_fail
    jump $I10
  rx2360_done:
    rx2360_cur."!cursor_fail"()
    if_null rx2360_debug, debug_1368
    rx2360_cur."!cursor_debug"("FAIL", "number")
  debug_1368:
    .return (rx2360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("267_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2366, "ResizablePMCArray"
    push $P2366, ""
    .return ($P2366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("268_1305640955.436")
    .param pmc param_2368
.annotate 'line', 1010
    .lex "self", param_2368
    $P2369 = param_2368."!protoregex"("quote")
    .return ($P2369)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("269_1305640955.436")
    .param pmc param_2371
.annotate 'line', 1010
    .lex "self", param_2371
    $P2372 = param_2371."!PREFIX__!protoregex"("quote")
    .return ($P2372)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("270_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2374_tgt
    .local int rx2374_pos
    .local int rx2374_off
    .local int rx2374_eos
    .local int rx2374_rep
    .local pmc rx2374_cur
    .local pmc rx2374_debug
    (rx2374_cur, rx2374_pos, rx2374_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2374_cur
    .local pmc match
    .lex "$/", match
    length rx2374_eos, rx2374_tgt
    gt rx2374_pos, rx2374_eos, rx2374_done
    set rx2374_off, 0
    lt rx2374_pos, 2, rx2374_start
    sub rx2374_off, rx2374_pos, 1
    substr rx2374_tgt, rx2374_tgt, rx2374_off
  rx2374_start:
    eq $I10, 1, rx2374_restart
    if_null rx2374_debug, debug_1369
    rx2374_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2375_done
    goto rxscan2375_scan
  rxscan2375_loop:
    (rx2374_pos) = rx2374_cur."from"()
    inc rx2374_pos
    rx2374_cur."!cursor_from"(rx2374_pos)
    ge rx2374_pos, rx2374_eos, rxscan2375_done
  rxscan2375_scan:
    set_addr $I10, rxscan2375_loop
    rx2374_cur."!mark_push"(0, rx2374_pos, $I10)
  rxscan2375_done:
.annotate 'line', 1011
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2374_pos, rx2374_off
    substr $S10, rx2374_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx2374_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2374_cur."!cursor_pos"(rx2374_pos)
    $P10 = rx2374_cur."quote_EXPR"(":q")
    unless $P10, rx2374_fail
    rx2374_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2374_pos = $P10."pos"()
  # rx pass
    rx2374_cur."!cursor_pass"(rx2374_pos, "quote:sym<apos>")
    if_null rx2374_debug, debug_1370
    rx2374_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx2374_pos)
  debug_1370:
    .return (rx2374_cur)
  rx2374_restart:
.annotate 'line', 438
    if_null rx2374_debug, debug_1371
    rx2374_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1371:
  rx2374_fail:
    (rx2374_rep, rx2374_pos, $I10, $P10) = rx2374_cur."!mark_fail"(0)
    lt rx2374_pos, -1, rx2374_done
    eq rx2374_pos, -1, rx2374_fail
    jump $I10
  rx2374_done:
    rx2374_cur."!cursor_fail"()
    if_null rx2374_debug, debug_1372
    rx2374_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1372:
    .return (rx2374_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("271_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2377, "ResizablePMCArray"
    push $P2377, "'"
    .return ($P2377)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("272_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2379_tgt
    .local int rx2379_pos
    .local int rx2379_off
    .local int rx2379_eos
    .local int rx2379_rep
    .local pmc rx2379_cur
    .local pmc rx2379_debug
    (rx2379_cur, rx2379_pos, rx2379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2379_cur
    .local pmc match
    .lex "$/", match
    length rx2379_eos, rx2379_tgt
    gt rx2379_pos, rx2379_eos, rx2379_done
    set rx2379_off, 0
    lt rx2379_pos, 2, rx2379_start
    sub rx2379_off, rx2379_pos, 1
    substr rx2379_tgt, rx2379_tgt, rx2379_off
  rx2379_start:
    eq $I10, 1, rx2379_restart
    if_null rx2379_debug, debug_1373
    rx2379_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1373:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2380_done
    goto rxscan2380_scan
  rxscan2380_loop:
    (rx2379_pos) = rx2379_cur."from"()
    inc rx2379_pos
    rx2379_cur."!cursor_from"(rx2379_pos)
    ge rx2379_pos, rx2379_eos, rxscan2380_done
  rxscan2380_scan:
    set_addr $I10, rxscan2380_loop
    rx2379_cur."!mark_push"(0, rx2379_pos, $I10)
  rxscan2380_done:
.annotate 'line', 1012
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2379_pos, rx2379_off
    substr $S10, rx2379_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx2379_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2379_cur."!cursor_pos"(rx2379_pos)
    $P10 = rx2379_cur."quote_EXPR"(":qq")
    unless $P10, rx2379_fail
    rx2379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2379_pos = $P10."pos"()
  # rx pass
    rx2379_cur."!cursor_pass"(rx2379_pos, "quote:sym<dblq>")
    if_null rx2379_debug, debug_1374
    rx2379_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx2379_pos)
  debug_1374:
    .return (rx2379_cur)
  rx2379_restart:
.annotate 'line', 438
    if_null rx2379_debug, debug_1375
    rx2379_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1375:
  rx2379_fail:
    (rx2379_rep, rx2379_pos, $I10, $P10) = rx2379_cur."!mark_fail"(0)
    lt rx2379_pos, -1, rx2379_done
    eq rx2379_pos, -1, rx2379_fail
    jump $I10
  rx2379_done:
    rx2379_cur."!cursor_fail"()
    if_null rx2379_debug, debug_1376
    rx2379_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1376:
    .return (rx2379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("273_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2382, "ResizablePMCArray"
    push $P2382, "\""
    .return ($P2382)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("274_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2384_tgt
    .local int rx2384_pos
    .local int rx2384_off
    .local int rx2384_eos
    .local int rx2384_rep
    .local pmc rx2384_cur
    .local pmc rx2384_debug
    (rx2384_cur, rx2384_pos, rx2384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2384_cur
    .local pmc match
    .lex "$/", match
    length rx2384_eos, rx2384_tgt
    gt rx2384_pos, rx2384_eos, rx2384_done
    set rx2384_off, 0
    lt rx2384_pos, 2, rx2384_start
    sub rx2384_off, rx2384_pos, 1
    substr rx2384_tgt, rx2384_tgt, rx2384_off
  rx2384_start:
    eq $I10, 1, rx2384_restart
    if_null rx2384_debug, debug_1377
    rx2384_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1377:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2385_done
    goto rxscan2385_scan
  rxscan2385_loop:
    (rx2384_pos) = rx2384_cur."from"()
    inc rx2384_pos
    rx2384_cur."!cursor_from"(rx2384_pos)
    ge rx2384_pos, rx2384_eos, rxscan2385_done
  rxscan2385_scan:
    set_addr $I10, rxscan2385_loop
    rx2384_cur."!mark_push"(0, rx2384_pos, $I10)
  rxscan2385_done:
.annotate 'line', 1013
  # rx subcapture "sym"
    set_addr $I10, rxcap_2386_fail
    rx2384_cur."!mark_push"(0, rx2384_pos, $I10)
  # rx literal  "q"
    add $I11, rx2384_pos, 1
    gt $I11, rx2384_eos, rx2384_fail
    sub $I11, rx2384_pos, rx2384_off
    ord $I11, rx2384_tgt, $I11
    ne $I11, 113, rx2384_fail
    add rx2384_pos, 1
    set_addr $I10, rxcap_2386_fail
    ($I12, $I11) = rx2384_cur."!mark_peek"($I10)
    rx2384_cur."!cursor_pos"($I11)
    ($P10) = rx2384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2384_pos, "")
    rx2384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2386_done
  rxcap_2386_fail:
    goto rx2384_fail
  rxcap_2386_done:
  # rxanchor rwb
    le rx2384_pos, 0, rx2384_fail
    sub $I10, rx2384_pos, rx2384_off
    is_cclass $I11, 8192, rx2384_tgt, $I10
    if $I11, rx2384_fail
    dec $I10
    is_cclass $I11, 8192, rx2384_tgt, $I10
    unless $I11, rx2384_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2384_pos, rx2384_off
    substr $S10, rx2384_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2384_fail
  # rx subrule "ws" subtype=method negate=
    rx2384_cur."!cursor_pos"(rx2384_pos)
    $P10 = rx2384_cur."ws"()
    unless $P10, rx2384_fail
    rx2384_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2384_cur."!cursor_pos"(rx2384_pos)
    $P10 = rx2384_cur."quote_EXPR"(":q")
    unless $P10, rx2384_fail
    rx2384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2384_pos = $P10."pos"()
  # rx pass
    rx2384_cur."!cursor_pass"(rx2384_pos, "quote:sym<q>")
    if_null rx2384_debug, debug_1378
    rx2384_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx2384_pos)
  debug_1378:
    .return (rx2384_cur)
  rx2384_restart:
.annotate 'line', 438
    if_null rx2384_debug, debug_1379
    rx2384_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1379:
  rx2384_fail:
    (rx2384_rep, rx2384_pos, $I10, $P10) = rx2384_cur."!mark_fail"(0)
    lt rx2384_pos, -1, rx2384_done
    eq rx2384_pos, -1, rx2384_fail
    jump $I10
  rx2384_done:
    rx2384_cur."!cursor_fail"()
    if_null rx2384_debug, debug_1380
    rx2384_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1380:
    .return (rx2384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("275_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2388 = self."!PREFIX__!subrule"("ws", "q")
    new $P2389, "ResizablePMCArray"
    push $P2389, $P2388
    .return ($P2389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("276_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2391_tgt
    .local int rx2391_pos
    .local int rx2391_off
    .local int rx2391_eos
    .local int rx2391_rep
    .local pmc rx2391_cur
    .local pmc rx2391_debug
    (rx2391_cur, rx2391_pos, rx2391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2391_cur
    .local pmc match
    .lex "$/", match
    length rx2391_eos, rx2391_tgt
    gt rx2391_pos, rx2391_eos, rx2391_done
    set rx2391_off, 0
    lt rx2391_pos, 2, rx2391_start
    sub rx2391_off, rx2391_pos, 1
    substr rx2391_tgt, rx2391_tgt, rx2391_off
  rx2391_start:
    eq $I10, 1, rx2391_restart
    if_null rx2391_debug, debug_1381
    rx2391_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1381:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2392_done
    goto rxscan2392_scan
  rxscan2392_loop:
    (rx2391_pos) = rx2391_cur."from"()
    inc rx2391_pos
    rx2391_cur."!cursor_from"(rx2391_pos)
    ge rx2391_pos, rx2391_eos, rxscan2392_done
  rxscan2392_scan:
    set_addr $I10, rxscan2392_loop
    rx2391_cur."!mark_push"(0, rx2391_pos, $I10)
  rxscan2392_done:
.annotate 'line', 1014
  # rx subcapture "sym"
    set_addr $I10, rxcap_2393_fail
    rx2391_cur."!mark_push"(0, rx2391_pos, $I10)
  # rx literal  "qq"
    add $I11, rx2391_pos, 2
    gt $I11, rx2391_eos, rx2391_fail
    sub $I11, rx2391_pos, rx2391_off
    substr $S10, rx2391_tgt, $I11, 2
    ne $S10, "qq", rx2391_fail
    add rx2391_pos, 2
    set_addr $I10, rxcap_2393_fail
    ($I12, $I11) = rx2391_cur."!mark_peek"($I10)
    rx2391_cur."!cursor_pos"($I11)
    ($P10) = rx2391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2391_pos, "")
    rx2391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2393_done
  rxcap_2393_fail:
    goto rx2391_fail
  rxcap_2393_done:
  # rxanchor rwb
    le rx2391_pos, 0, rx2391_fail
    sub $I10, rx2391_pos, rx2391_off
    is_cclass $I11, 8192, rx2391_tgt, $I10
    if $I11, rx2391_fail
    dec $I10
    is_cclass $I11, 8192, rx2391_tgt, $I10
    unless $I11, rx2391_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2391_pos, rx2391_off
    substr $S10, rx2391_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2391_fail
  # rx subrule "ws" subtype=method negate=
    rx2391_cur."!cursor_pos"(rx2391_pos)
    $P10 = rx2391_cur."ws"()
    unless $P10, rx2391_fail
    rx2391_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2391_cur."!cursor_pos"(rx2391_pos)
    $P10 = rx2391_cur."quote_EXPR"(":qq")
    unless $P10, rx2391_fail
    rx2391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2391_pos = $P10."pos"()
  # rx pass
    rx2391_cur."!cursor_pass"(rx2391_pos, "quote:sym<qq>")
    if_null rx2391_debug, debug_1382
    rx2391_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx2391_pos)
  debug_1382:
    .return (rx2391_cur)
  rx2391_restart:
.annotate 'line', 438
    if_null rx2391_debug, debug_1383
    rx2391_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1383:
  rx2391_fail:
    (rx2391_rep, rx2391_pos, $I10, $P10) = rx2391_cur."!mark_fail"(0)
    lt rx2391_pos, -1, rx2391_done
    eq rx2391_pos, -1, rx2391_fail
    jump $I10
  rx2391_done:
    rx2391_cur."!cursor_fail"()
    if_null rx2391_debug, debug_1384
    rx2391_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1384:
    .return (rx2391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("277_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2395 = self."!PREFIX__!subrule"("ws", "qq")
    new $P2396, "ResizablePMCArray"
    push $P2396, $P2395
    .return ($P2396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("278_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2398_tgt
    .local int rx2398_pos
    .local int rx2398_off
    .local int rx2398_eos
    .local int rx2398_rep
    .local pmc rx2398_cur
    .local pmc rx2398_debug
    (rx2398_cur, rx2398_pos, rx2398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2398_cur
    .local pmc match
    .lex "$/", match
    length rx2398_eos, rx2398_tgt
    gt rx2398_pos, rx2398_eos, rx2398_done
    set rx2398_off, 0
    lt rx2398_pos, 2, rx2398_start
    sub rx2398_off, rx2398_pos, 1
    substr rx2398_tgt, rx2398_tgt, rx2398_off
  rx2398_start:
    eq $I10, 1, rx2398_restart
    if_null rx2398_debug, debug_1385
    rx2398_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1385:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2399_done
    goto rxscan2399_scan
  rxscan2399_loop:
    (rx2398_pos) = rx2398_cur."from"()
    inc rx2398_pos
    rx2398_cur."!cursor_from"(rx2398_pos)
    ge rx2398_pos, rx2398_eos, rxscan2399_done
  rxscan2399_scan:
    set_addr $I10, rxscan2399_loop
    rx2398_cur."!mark_push"(0, rx2398_pos, $I10)
  rxscan2399_done:
.annotate 'line', 1015
  # rx subcapture "sym"
    set_addr $I10, rxcap_2400_fail
    rx2398_cur."!mark_push"(0, rx2398_pos, $I10)
  # rx literal  "Q"
    add $I11, rx2398_pos, 1
    gt $I11, rx2398_eos, rx2398_fail
    sub $I11, rx2398_pos, rx2398_off
    ord $I11, rx2398_tgt, $I11
    ne $I11, 81, rx2398_fail
    add rx2398_pos, 1
    set_addr $I10, rxcap_2400_fail
    ($I12, $I11) = rx2398_cur."!mark_peek"($I10)
    rx2398_cur."!cursor_pos"($I11)
    ($P10) = rx2398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2398_pos, "")
    rx2398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2400_done
  rxcap_2400_fail:
    goto rx2398_fail
  rxcap_2400_done:
  # rxanchor rwb
    le rx2398_pos, 0, rx2398_fail
    sub $I10, rx2398_pos, rx2398_off
    is_cclass $I11, 8192, rx2398_tgt, $I10
    if $I11, rx2398_fail
    dec $I10
    is_cclass $I11, 8192, rx2398_tgt, $I10
    unless $I11, rx2398_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2398_pos, rx2398_off
    substr $S10, rx2398_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2398_fail
  # rx subrule "ws" subtype=method negate=
    rx2398_cur."!cursor_pos"(rx2398_pos)
    $P10 = rx2398_cur."ws"()
    unless $P10, rx2398_fail
    rx2398_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2398_cur."!cursor_pos"(rx2398_pos)
    $P10 = rx2398_cur."quote_EXPR"()
    unless $P10, rx2398_fail
    rx2398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2398_pos = $P10."pos"()
  # rx pass
    rx2398_cur."!cursor_pass"(rx2398_pos, "quote:sym<Q>")
    if_null rx2398_debug, debug_1386
    rx2398_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx2398_pos)
  debug_1386:
    .return (rx2398_cur)
  rx2398_restart:
.annotate 'line', 438
    if_null rx2398_debug, debug_1387
    rx2398_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1387:
  rx2398_fail:
    (rx2398_rep, rx2398_pos, $I10, $P10) = rx2398_cur."!mark_fail"(0)
    lt rx2398_pos, -1, rx2398_done
    eq rx2398_pos, -1, rx2398_fail
    jump $I10
  rx2398_done:
    rx2398_cur."!cursor_fail"()
    if_null rx2398_debug, debug_1388
    rx2398_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1388:
    .return (rx2398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("279_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2402 = self."!PREFIX__!subrule"("ws", "Q")
    new $P2403, "ResizablePMCArray"
    push $P2403, $P2402
    .return ($P2403)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("280_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2405_tgt
    .local int rx2405_pos
    .local int rx2405_off
    .local int rx2405_eos
    .local int rx2405_rep
    .local pmc rx2405_cur
    .local pmc rx2405_debug
    (rx2405_cur, rx2405_pos, rx2405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2405_cur
    .local pmc match
    .lex "$/", match
    length rx2405_eos, rx2405_tgt
    gt rx2405_pos, rx2405_eos, rx2405_done
    set rx2405_off, 0
    lt rx2405_pos, 2, rx2405_start
    sub rx2405_off, rx2405_pos, 1
    substr rx2405_tgt, rx2405_tgt, rx2405_off
  rx2405_start:
    eq $I10, 1, rx2405_restart
    if_null rx2405_debug, debug_1389
    rx2405_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1389:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2406_done
    goto rxscan2406_scan
  rxscan2406_loop:
    (rx2405_pos) = rx2405_cur."from"()
    inc rx2405_pos
    rx2405_cur."!cursor_from"(rx2405_pos)
    ge rx2405_pos, rx2405_eos, rxscan2406_done
  rxscan2406_scan:
    set_addr $I10, rxscan2406_loop
    rx2405_cur."!mark_push"(0, rx2405_pos, $I10)
  rxscan2406_done:
.annotate 'line', 1016
  # rx subcapture "sym"
    set_addr $I10, rxcap_2407_fail
    rx2405_cur."!mark_push"(0, rx2405_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx2405_pos, 5
    gt $I11, rx2405_eos, rx2405_fail
    sub $I11, rx2405_pos, rx2405_off
    substr $S10, rx2405_tgt, $I11, 5
    ne $S10, "Q:PIR", rx2405_fail
    add rx2405_pos, 5
    set_addr $I10, rxcap_2407_fail
    ($I12, $I11) = rx2405_cur."!mark_peek"($I10)
    rx2405_cur."!cursor_pos"($I11)
    ($P10) = rx2405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2405_pos, "")
    rx2405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2407_done
  rxcap_2407_fail:
    goto rx2405_fail
  rxcap_2407_done:
  # rx subrule "ws" subtype=method negate=
    rx2405_cur."!cursor_pos"(rx2405_pos)
    $P10 = rx2405_cur."ws"()
    unless $P10, rx2405_fail
    rx2405_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2405_cur."!cursor_pos"(rx2405_pos)
    $P10 = rx2405_cur."quote_EXPR"()
    unless $P10, rx2405_fail
    rx2405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2405_pos = $P10."pos"()
  # rx pass
    rx2405_cur."!cursor_pass"(rx2405_pos, "quote:sym<Q:PIR>")
    if_null rx2405_debug, debug_1390
    rx2405_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx2405_pos)
  debug_1390:
    .return (rx2405_cur)
  rx2405_restart:
.annotate 'line', 438
    if_null rx2405_debug, debug_1391
    rx2405_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1391:
  rx2405_fail:
    (rx2405_rep, rx2405_pos, $I10, $P10) = rx2405_cur."!mark_fail"(0)
    lt rx2405_pos, -1, rx2405_done
    eq rx2405_pos, -1, rx2405_fail
    jump $I10
  rx2405_done:
    rx2405_cur."!cursor_fail"()
    if_null rx2405_debug, debug_1392
    rx2405_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1392:
    .return (rx2405_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("281_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2409 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P2410, "ResizablePMCArray"
    push $P2410, $P2409
    .return ($P2410)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("282_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2412_tgt
    .local int rx2412_pos
    .local int rx2412_off
    .local int rx2412_eos
    .local int rx2412_rep
    .local pmc rx2412_cur
    .local pmc rx2412_debug
    (rx2412_cur, rx2412_pos, rx2412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2412_cur
    .local pmc match
    .lex "$/", match
    length rx2412_eos, rx2412_tgt
    gt rx2412_pos, rx2412_eos, rx2412_done
    set rx2412_off, 0
    lt rx2412_pos, 2, rx2412_start
    sub rx2412_off, rx2412_pos, 1
    substr rx2412_tgt, rx2412_tgt, rx2412_off
  rx2412_start:
    eq $I10, 1, rx2412_restart
    if_null rx2412_debug, debug_1393
    rx2412_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1393:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2413_done
    goto rxscan2413_scan
  rxscan2413_loop:
    (rx2412_pos) = rx2412_cur."from"()
    inc rx2412_pos
    rx2412_cur."!cursor_from"(rx2412_pos)
    ge rx2412_pos, rx2412_eos, rxscan2413_done
  rxscan2413_scan:
    set_addr $I10, rxscan2413_loop
    rx2412_cur."!mark_push"(0, rx2412_pos, $I10)
  rxscan2413_done:
.annotate 'line', 1018
  # rx literal  "/"
    add $I11, rx2412_pos, 1
    gt $I11, rx2412_eos, rx2412_fail
    sub $I11, rx2412_pos, rx2412_off
    ord $I11, rx2412_tgt, $I11
    ne $I11, 47, rx2412_fail
    add rx2412_pos, 1
.annotate 'line', 1019
  # rx subrule "newpad" subtype=method negate=
    rx2412_cur."!cursor_pos"(rx2412_pos)
    $P10 = rx2412_cur."newpad"()
    unless $P10, rx2412_fail
    rx2412_pos = $P10."pos"()
.annotate 'line', 1020
  # rx reduce name="quote:sym</ />" key="open"
    rx2412_cur."!cursor_pos"(rx2412_pos)
    rx2412_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 1021
  # rx subrule "LANG" subtype=capture negate=
    rx2412_cur."!cursor_pos"(rx2412_pos)
    $P10 = rx2412_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2412_fail
    rx2412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2412_pos = $P10."pos"()
.annotate 'line', 1022
  # rx literal  "/"
    add $I11, rx2412_pos, 1
    gt $I11, rx2412_eos, rx2412_fail
    sub $I11, rx2412_pos, rx2412_off
    ord $I11, rx2412_tgt, $I11
    ne $I11, 47, rx2412_fail
    add rx2412_pos, 1
.annotate 'line', 1017
  # rx pass
    rx2412_cur."!cursor_pass"(rx2412_pos, "quote:sym</ />")
    if_null rx2412_debug, debug_1394
    rx2412_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx2412_pos)
  debug_1394:
    .return (rx2412_cur)
  rx2412_restart:
.annotate 'line', 438
    if_null rx2412_debug, debug_1395
    rx2412_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1395:
  rx2412_fail:
    (rx2412_rep, rx2412_pos, $I10, $P10) = rx2412_cur."!mark_fail"(0)
    lt rx2412_pos, -1, rx2412_done
    eq rx2412_pos, -1, rx2412_fail
    jump $I10
  rx2412_done:
    rx2412_cur."!cursor_fail"()
    if_null rx2412_debug, debug_1396
    rx2412_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1396:
    .return (rx2412_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("283_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2415 = self."!PREFIX__!subrule"("newpad", "/")
    new $P2416, "ResizablePMCArray"
    push $P2416, $P2415
    .return ($P2416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("284_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2418_tgt
    .local int rx2418_pos
    .local int rx2418_off
    .local int rx2418_eos
    .local int rx2418_rep
    .local pmc rx2418_cur
    .local pmc rx2418_debug
    (rx2418_cur, rx2418_pos, rx2418_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2418_cur
    .local pmc match
    .lex "$/", match
    length rx2418_eos, rx2418_tgt
    gt rx2418_pos, rx2418_eos, rx2418_done
    set rx2418_off, 0
    lt rx2418_pos, 2, rx2418_start
    sub rx2418_off, rx2418_pos, 1
    substr rx2418_tgt, rx2418_tgt, rx2418_off
  rx2418_start:
    eq $I10, 1, rx2418_restart
    if_null rx2418_debug, debug_1397
    rx2418_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1397:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2419_done
    goto rxscan2419_scan
  rxscan2419_loop:
    (rx2418_pos) = rx2418_cur."from"()
    inc rx2418_pos
    rx2418_cur."!cursor_from"(rx2418_pos)
    ge rx2418_pos, rx2418_eos, rxscan2419_done
  rxscan2419_scan:
    set_addr $I10, rxscan2419_loop
    rx2418_cur."!mark_push"(0, rx2418_pos, $I10)
  rxscan2419_done:
.annotate 'line', 1025
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2418_pos, rx2418_off
    substr $S10, rx2418_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2418_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2418_cur."!cursor_pos"(rx2418_pos)
    $P10 = rx2418_cur."quotemod_check"("s")
    unless $P10, rx2418_fail
  # rx subrule "variable" subtype=capture negate=
    rx2418_cur."!cursor_pos"(rx2418_pos)
    $P10 = rx2418_cur."variable"()
    unless $P10, rx2418_fail
    rx2418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2418_pos = $P10."pos"()
  # rx pass
    rx2418_cur."!cursor_pass"(rx2418_pos, "quote_escape:sym<$>")
    if_null rx2418_debug, debug_1398
    rx2418_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2418_pos)
  debug_1398:
    .return (rx2418_cur)
  rx2418_restart:
.annotate 'line', 438
    if_null rx2418_debug, debug_1399
    rx2418_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1399:
  rx2418_fail:
    (rx2418_rep, rx2418_pos, $I10, $P10) = rx2418_cur."!mark_fail"(0)
    lt rx2418_pos, -1, rx2418_done
    eq rx2418_pos, -1, rx2418_fail
    jump $I10
  rx2418_done:
    rx2418_cur."!cursor_fail"()
    if_null rx2418_debug, debug_1400
    rx2418_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1400:
    .return (rx2418_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("285_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2421, "ResizablePMCArray"
    push $P2421, "$"
    .return ($P2421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("286_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2423_tgt
    .local int rx2423_pos
    .local int rx2423_off
    .local int rx2423_eos
    .local int rx2423_rep
    .local pmc rx2423_cur
    .local pmc rx2423_debug
    (rx2423_cur, rx2423_pos, rx2423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2423_cur
    .local pmc match
    .lex "$/", match
    length rx2423_eos, rx2423_tgt
    gt rx2423_pos, rx2423_eos, rx2423_done
    set rx2423_off, 0
    lt rx2423_pos, 2, rx2423_start
    sub rx2423_off, rx2423_pos, 1
    substr rx2423_tgt, rx2423_tgt, rx2423_off
  rx2423_start:
    eq $I10, 1, rx2423_restart
    if_null rx2423_debug, debug_1401
    rx2423_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1401:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2424_done
    goto rxscan2424_scan
  rxscan2424_loop:
    (rx2423_pos) = rx2423_cur."from"()
    inc rx2423_pos
    rx2423_cur."!cursor_from"(rx2423_pos)
    ge rx2423_pos, rx2423_eos, rxscan2424_done
  rxscan2424_scan:
    set_addr $I10, rxscan2424_loop
    rx2423_cur."!mark_push"(0, rx2423_pos, $I10)
  rxscan2424_done:
.annotate 'line', 1026
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2423_pos, rx2423_off
    substr $S10, rx2423_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2423_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2423_cur."!cursor_pos"(rx2423_pos)
    $P10 = rx2423_cur."quotemod_check"("c")
    unless $P10, rx2423_fail
  # rx subrule "block" subtype=capture negate=
    rx2423_cur."!cursor_pos"(rx2423_pos)
    $P10 = rx2423_cur."block"()
    unless $P10, rx2423_fail
    rx2423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2423_pos = $P10."pos"()
  # rx pass
    rx2423_cur."!cursor_pass"(rx2423_pos, "quote_escape:sym<{ }>")
    if_null rx2423_debug, debug_1402
    rx2423_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2423_pos)
  debug_1402:
    .return (rx2423_cur)
  rx2423_restart:
.annotate 'line', 438
    if_null rx2423_debug, debug_1403
    rx2423_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1403:
  rx2423_fail:
    (rx2423_rep, rx2423_pos, $I10, $P10) = rx2423_cur."!mark_fail"(0)
    lt rx2423_pos, -1, rx2423_done
    eq rx2423_pos, -1, rx2423_fail
    jump $I10
  rx2423_done:
    rx2423_cur."!cursor_fail"()
    if_null rx2423_debug, debug_1404
    rx2423_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1404:
    .return (rx2423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("287_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2426, "ResizablePMCArray"
    push $P2426, "{"
    .return ($P2426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("288_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2428_tgt
    .local int rx2428_pos
    .local int rx2428_off
    .local int rx2428_eos
    .local int rx2428_rep
    .local pmc rx2428_cur
    .local pmc rx2428_debug
    (rx2428_cur, rx2428_pos, rx2428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2428_cur
    .local pmc match
    .lex "$/", match
    length rx2428_eos, rx2428_tgt
    gt rx2428_pos, rx2428_eos, rx2428_done
    set rx2428_off, 0
    lt rx2428_pos, 2, rx2428_start
    sub rx2428_off, rx2428_pos, 1
    substr rx2428_tgt, rx2428_tgt, rx2428_off
  rx2428_start:
    eq $I10, 1, rx2428_restart
    if_null rx2428_debug, debug_1405
    rx2428_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1405:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2429_done
    goto rxscan2429_scan
  rxscan2429_loop:
    (rx2428_pos) = rx2428_cur."from"()
    inc rx2428_pos
    rx2428_cur."!cursor_from"(rx2428_pos)
    ge rx2428_pos, rx2428_eos, rxscan2429_done
  rxscan2429_scan:
    set_addr $I10, rxscan2429_loop
    rx2428_cur."!mark_push"(0, rx2428_pos, $I10)
  rxscan2429_done:
.annotate 'line', 1027
  # rx literal  "\\e"
    add $I11, rx2428_pos, 2
    gt $I11, rx2428_eos, rx2428_fail
    sub $I11, rx2428_pos, rx2428_off
    substr $S10, rx2428_tgt, $I11, 2
    ne $S10, "\\e", rx2428_fail
    add rx2428_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2428_cur."!cursor_pos"(rx2428_pos)
    $P10 = rx2428_cur."quotemod_check"("b")
    unless $P10, rx2428_fail
  # rx pass
    rx2428_cur."!cursor_pass"(rx2428_pos, "quote_escape:sym<esc>")
    if_null rx2428_debug, debug_1406
    rx2428_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2428_pos)
  debug_1406:
    .return (rx2428_cur)
  rx2428_restart:
.annotate 'line', 438
    if_null rx2428_debug, debug_1407
    rx2428_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1407:
  rx2428_fail:
    (rx2428_rep, rx2428_pos, $I10, $P10) = rx2428_cur."!mark_fail"(0)
    lt rx2428_pos, -1, rx2428_done
    eq rx2428_pos, -1, rx2428_fail
    jump $I10
  rx2428_done:
    rx2428_cur."!cursor_fail"()
    if_null rx2428_debug, debug_1408
    rx2428_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1408:
    .return (rx2428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("289_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2431, "ResizablePMCArray"
    push $P2431, "\\e"
    .return ($P2431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("290_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2433_tgt
    .local int rx2433_pos
    .local int rx2433_off
    .local int rx2433_eos
    .local int rx2433_rep
    .local pmc rx2433_cur
    .local pmc rx2433_debug
    (rx2433_cur, rx2433_pos, rx2433_tgt, $I10) = self."!cursor_start"()
    rx2433_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2433_cur
    .local pmc match
    .lex "$/", match
    length rx2433_eos, rx2433_tgt
    gt rx2433_pos, rx2433_eos, rx2433_done
    set rx2433_off, 0
    lt rx2433_pos, 2, rx2433_start
    sub rx2433_off, rx2433_pos, 1
    substr rx2433_tgt, rx2433_tgt, rx2433_off
  rx2433_start:
    eq $I10, 1, rx2433_restart
    if_null rx2433_debug, debug_1409
    rx2433_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1409:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2434_done
    goto rxscan2434_scan
  rxscan2434_loop:
    (rx2433_pos) = rx2433_cur."from"()
    inc rx2433_pos
    rx2433_cur."!cursor_from"(rx2433_pos)
    ge rx2433_pos, rx2433_eos, rxscan2434_done
  rxscan2434_scan:
    set_addr $I10, rxscan2434_loop
    rx2433_cur."!mark_push"(0, rx2433_pos, $I10)
  rxscan2434_done:
.annotate 'line', 1029
  # rx literal  "("
    add $I11, rx2433_pos, 1
    gt $I11, rx2433_eos, rx2433_fail
    sub $I11, rx2433_pos, rx2433_off
    ord $I11, rx2433_tgt, $I11
    ne $I11, 40, rx2433_fail
    add rx2433_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2433_cur."!cursor_pos"(rx2433_pos)
    $P10 = rx2433_cur."ws"()
    unless $P10, rx2433_fail
    rx2433_pos = $P10."pos"()
  # rx rxquantr2435 ** 0..1
    set_addr $I10, rxquantr2435_done
    rx2433_cur."!mark_push"(0, rx2433_pos, $I10)
  rxquantr2435_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2433_cur."!cursor_pos"(rx2433_pos)
    $P10 = rx2433_cur."EXPR"()
    unless $P10, rx2433_fail
    goto rxsubrule2436_pass
  rxsubrule2436_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2433_fail
  rxsubrule2436_pass:
    set_addr $I10, rxsubrule2436_back
    rx2433_cur."!mark_push"(0, rx2433_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2433_pos = $P10."pos"()
    set_addr $I10, rxquantr2435_done
    (rx2433_rep) = rx2433_cur."!mark_commit"($I10)
  rxquantr2435_done:
  # rx literal  ")"
    add $I11, rx2433_pos, 1
    gt $I11, rx2433_eos, rx2433_fail
    sub $I11, rx2433_pos, rx2433_off
    ord $I11, rx2433_tgt, $I11
    ne $I11, 41, rx2433_fail
    add rx2433_pos, 1
  # rx pass
    rx2433_cur."!cursor_pass"(rx2433_pos, "circumfix:sym<( )>")
    if_null rx2433_debug, debug_1410
    rx2433_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2433_pos)
  debug_1410:
    .return (rx2433_cur)
  rx2433_restart:
.annotate 'line', 438
    if_null rx2433_debug, debug_1411
    rx2433_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1411:
  rx2433_fail:
    (rx2433_rep, rx2433_pos, $I10, $P10) = rx2433_cur."!mark_fail"(0)
    lt rx2433_pos, -1, rx2433_done
    eq rx2433_pos, -1, rx2433_fail
    jump $I10
  rx2433_done:
    rx2433_cur."!cursor_fail"()
    if_null rx2433_debug, debug_1412
    rx2433_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1412:
    .return (rx2433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("291_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2438 = self."!PREFIX__!subrule"("ws", "(")
    new $P2439, "ResizablePMCArray"
    push $P2439, $P2438
    .return ($P2439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("292_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2441_tgt
    .local int rx2441_pos
    .local int rx2441_off
    .local int rx2441_eos
    .local int rx2441_rep
    .local pmc rx2441_cur
    .local pmc rx2441_debug
    (rx2441_cur, rx2441_pos, rx2441_tgt, $I10) = self."!cursor_start"()
    rx2441_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2441_cur
    .local pmc match
    .lex "$/", match
    length rx2441_eos, rx2441_tgt
    gt rx2441_pos, rx2441_eos, rx2441_done
    set rx2441_off, 0
    lt rx2441_pos, 2, rx2441_start
    sub rx2441_off, rx2441_pos, 1
    substr rx2441_tgt, rx2441_tgt, rx2441_off
  rx2441_start:
    eq $I10, 1, rx2441_restart
    if_null rx2441_debug, debug_1413
    rx2441_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1413:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2442_done
    goto rxscan2442_scan
  rxscan2442_loop:
    (rx2441_pos) = rx2441_cur."from"()
    inc rx2441_pos
    rx2441_cur."!cursor_from"(rx2441_pos)
    ge rx2441_pos, rx2441_eos, rxscan2442_done
  rxscan2442_scan:
    set_addr $I10, rxscan2442_loop
    rx2441_cur."!mark_push"(0, rx2441_pos, $I10)
  rxscan2442_done:
.annotate 'line', 1030
  # rx literal  "["
    add $I11, rx2441_pos, 1
    gt $I11, rx2441_eos, rx2441_fail
    sub $I11, rx2441_pos, rx2441_off
    ord $I11, rx2441_tgt, $I11
    ne $I11, 91, rx2441_fail
    add rx2441_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2441_cur."!cursor_pos"(rx2441_pos)
    $P10 = rx2441_cur."ws"()
    unless $P10, rx2441_fail
    rx2441_pos = $P10."pos"()
  # rx rxquantr2443 ** 0..1
    set_addr $I10, rxquantr2443_done
    rx2441_cur."!mark_push"(0, rx2441_pos, $I10)
  rxquantr2443_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2441_cur."!cursor_pos"(rx2441_pos)
    $P10 = rx2441_cur."EXPR"()
    unless $P10, rx2441_fail
    goto rxsubrule2444_pass
  rxsubrule2444_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2441_fail
  rxsubrule2444_pass:
    set_addr $I10, rxsubrule2444_back
    rx2441_cur."!mark_push"(0, rx2441_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2441_pos = $P10."pos"()
    set_addr $I10, rxquantr2443_done
    (rx2441_rep) = rx2441_cur."!mark_commit"($I10)
  rxquantr2443_done:
  # rx literal  "]"
    add $I11, rx2441_pos, 1
    gt $I11, rx2441_eos, rx2441_fail
    sub $I11, rx2441_pos, rx2441_off
    ord $I11, rx2441_tgt, $I11
    ne $I11, 93, rx2441_fail
    add rx2441_pos, 1
  # rx pass
    rx2441_cur."!cursor_pass"(rx2441_pos, "circumfix:sym<[ ]>")
    if_null rx2441_debug, debug_1414
    rx2441_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2441_pos)
  debug_1414:
    .return (rx2441_cur)
  rx2441_restart:
.annotate 'line', 438
    if_null rx2441_debug, debug_1415
    rx2441_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1415:
  rx2441_fail:
    (rx2441_rep, rx2441_pos, $I10, $P10) = rx2441_cur."!mark_fail"(0)
    lt rx2441_pos, -1, rx2441_done
    eq rx2441_pos, -1, rx2441_fail
    jump $I10
  rx2441_done:
    rx2441_cur."!cursor_fail"()
    if_null rx2441_debug, debug_1416
    rx2441_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1416:
    .return (rx2441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("293_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2446 = self."!PREFIX__!subrule"("ws", "[")
    new $P2447, "ResizablePMCArray"
    push $P2447, $P2446
    .return ($P2447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("294_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2449_tgt
    .local int rx2449_pos
    .local int rx2449_off
    .local int rx2449_eos
    .local int rx2449_rep
    .local pmc rx2449_cur
    .local pmc rx2449_debug
    (rx2449_cur, rx2449_pos, rx2449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2449_cur
    .local pmc match
    .lex "$/", match
    length rx2449_eos, rx2449_tgt
    gt rx2449_pos, rx2449_eos, rx2449_done
    set rx2449_off, 0
    lt rx2449_pos, 2, rx2449_start
    sub rx2449_off, rx2449_pos, 1
    substr rx2449_tgt, rx2449_tgt, rx2449_off
  rx2449_start:
    eq $I10, 1, rx2449_restart
    if_null rx2449_debug, debug_1417
    rx2449_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1417:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2450_done
    goto rxscan2450_scan
  rxscan2450_loop:
    (rx2449_pos) = rx2449_cur."from"()
    inc rx2449_pos
    rx2449_cur."!cursor_from"(rx2449_pos)
    ge rx2449_pos, rx2449_eos, rxscan2450_done
  rxscan2450_scan:
    set_addr $I10, rxscan2450_loop
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  rxscan2450_done:
.annotate 'line', 1031
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2449_pos, rx2449_off
    substr $S10, rx2449_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2449_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2449_cur."!cursor_pos"(rx2449_pos)
    $P10 = rx2449_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2449_fail
    rx2449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2449_pos = $P10."pos"()
  # rx pass
    rx2449_cur."!cursor_pass"(rx2449_pos, "circumfix:sym<ang>")
    if_null rx2449_debug, debug_1418
    rx2449_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2449_pos)
  debug_1418:
    .return (rx2449_cur)
  rx2449_restart:
.annotate 'line', 438
    if_null rx2449_debug, debug_1419
    rx2449_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1419:
  rx2449_fail:
    (rx2449_rep, rx2449_pos, $I10, $P10) = rx2449_cur."!mark_fail"(0)
    lt rx2449_pos, -1, rx2449_done
    eq rx2449_pos, -1, rx2449_fail
    jump $I10
  rx2449_done:
    rx2449_cur."!cursor_fail"()
    if_null rx2449_debug, debug_1420
    rx2449_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1420:
    .return (rx2449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("295_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2452, "ResizablePMCArray"
    push $P2452, "<"
    .return ($P2452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("296_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2454_tgt
    .local int rx2454_pos
    .local int rx2454_off
    .local int rx2454_eos
    .local int rx2454_rep
    .local pmc rx2454_cur
    .local pmc rx2454_debug
    (rx2454_cur, rx2454_pos, rx2454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2454_cur
    .local pmc match
    .lex "$/", match
    length rx2454_eos, rx2454_tgt
    gt rx2454_pos, rx2454_eos, rx2454_done
    set rx2454_off, 0
    lt rx2454_pos, 2, rx2454_start
    sub rx2454_off, rx2454_pos, 1
    substr rx2454_tgt, rx2454_tgt, rx2454_off
  rx2454_start:
    eq $I10, 1, rx2454_restart
    if_null rx2454_debug, debug_1421
    rx2454_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2455_done
    goto rxscan2455_scan
  rxscan2455_loop:
    (rx2454_pos) = rx2454_cur."from"()
    inc rx2454_pos
    rx2454_cur."!cursor_from"(rx2454_pos)
    ge rx2454_pos, rx2454_eos, rxscan2455_done
  rxscan2455_scan:
    set_addr $I10, rxscan2455_loop
    rx2454_cur."!mark_push"(0, rx2454_pos, $I10)
  rxscan2455_done:
.annotate 'line', 1032
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2454_pos, rx2454_off
    substr $S10, rx2454_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2454_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    $P10 = rx2454_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2454_fail
    rx2454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2454_pos = $P10."pos"()
  # rx pass
    rx2454_cur."!cursor_pass"(rx2454_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2454_debug, debug_1422
    rx2454_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2454_pos)
  debug_1422:
    .return (rx2454_cur)
  rx2454_restart:
.annotate 'line', 438
    if_null rx2454_debug, debug_1423
    rx2454_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1423:
  rx2454_fail:
    (rx2454_rep, rx2454_pos, $I10, $P10) = rx2454_cur."!mark_fail"(0)
    lt rx2454_pos, -1, rx2454_done
    eq rx2454_pos, -1, rx2454_fail
    jump $I10
  rx2454_done:
    rx2454_cur."!cursor_fail"()
    if_null rx2454_debug, debug_1424
    rx2454_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1424:
    .return (rx2454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("297_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2457, "ResizablePMCArray"
    push $P2457, unicode:"\x{ab}"
    .return ($P2457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("298_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2459_tgt
    .local int rx2459_pos
    .local int rx2459_off
    .local int rx2459_eos
    .local int rx2459_rep
    .local pmc rx2459_cur
    .local pmc rx2459_debug
    (rx2459_cur, rx2459_pos, rx2459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2459_cur
    .local pmc match
    .lex "$/", match
    length rx2459_eos, rx2459_tgt
    gt rx2459_pos, rx2459_eos, rx2459_done
    set rx2459_off, 0
    lt rx2459_pos, 2, rx2459_start
    sub rx2459_off, rx2459_pos, 1
    substr rx2459_tgt, rx2459_tgt, rx2459_off
  rx2459_start:
    eq $I10, 1, rx2459_restart
    if_null rx2459_debug, debug_1425
    rx2459_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1425:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2460_done
    goto rxscan2460_scan
  rxscan2460_loop:
    (rx2459_pos) = rx2459_cur."from"()
    inc rx2459_pos
    rx2459_cur."!cursor_from"(rx2459_pos)
    ge rx2459_pos, rx2459_eos, rxscan2460_done
  rxscan2460_scan:
    set_addr $I10, rxscan2460_loop
    rx2459_cur."!mark_push"(0, rx2459_pos, $I10)
  rxscan2460_done:
.annotate 'line', 1033
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2459_pos, rx2459_off
    substr $S10, rx2459_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2459_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2459_cur."!cursor_pos"(rx2459_pos)
    $P10 = rx2459_cur."pblock"()
    unless $P10, rx2459_fail
    rx2459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2459_pos = $P10."pos"()
  # rx pass
    rx2459_cur."!cursor_pass"(rx2459_pos, "circumfix:sym<{ }>")
    if_null rx2459_debug, debug_1426
    rx2459_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2459_pos)
  debug_1426:
    .return (rx2459_cur)
  rx2459_restart:
.annotate 'line', 438
    if_null rx2459_debug, debug_1427
    rx2459_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1427:
  rx2459_fail:
    (rx2459_rep, rx2459_pos, $I10, $P10) = rx2459_cur."!mark_fail"(0)
    lt rx2459_pos, -1, rx2459_done
    eq rx2459_pos, -1, rx2459_fail
    jump $I10
  rx2459_done:
    rx2459_cur."!cursor_fail"()
    if_null rx2459_debug, debug_1428
    rx2459_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1428:
    .return (rx2459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("299_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2462, "ResizablePMCArray"
    push $P2462, "{"
    .return ($P2462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("300_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2464_tgt
    .local int rx2464_pos
    .local int rx2464_off
    .local int rx2464_eos
    .local int rx2464_rep
    .local pmc rx2464_cur
    .local pmc rx2464_debug
    (rx2464_cur, rx2464_pos, rx2464_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2464_cur
    .local pmc match
    .lex "$/", match
    length rx2464_eos, rx2464_tgt
    gt rx2464_pos, rx2464_eos, rx2464_done
    set rx2464_off, 0
    lt rx2464_pos, 2, rx2464_start
    sub rx2464_off, rx2464_pos, 1
    substr rx2464_tgt, rx2464_tgt, rx2464_off
  rx2464_start:
    eq $I10, 1, rx2464_restart
    if_null rx2464_debug, debug_1429
    rx2464_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1429:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2465_done
    goto rxscan2465_scan
  rxscan2465_loop:
    (rx2464_pos) = rx2464_cur."from"()
    inc rx2464_pos
    rx2464_cur."!cursor_from"(rx2464_pos)
    ge rx2464_pos, rx2464_eos, rxscan2465_done
  rxscan2465_scan:
    set_addr $I10, rxscan2465_loop
    rx2464_cur."!mark_push"(0, rx2464_pos, $I10)
  rxscan2465_done:
.annotate 'line', 1034
  # rx subrule "sigil" subtype=capture negate=
    rx2464_cur."!cursor_pos"(rx2464_pos)
    $P10 = rx2464_cur."sigil"()
    unless $P10, rx2464_fail
    rx2464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2464_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2464_pos, 1
    gt $I11, rx2464_eos, rx2464_fail
    sub $I11, rx2464_pos, rx2464_off
    ord $I11, rx2464_tgt, $I11
    ne $I11, 40, rx2464_fail
    add rx2464_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2464_cur."!cursor_pos"(rx2464_pos)
    $P10 = rx2464_cur."semilist"()
    unless $P10, rx2464_fail
    rx2464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2464_pos = $P10."pos"()
  alt2466_0:
    set_addr $I10, alt2466_1
    rx2464_cur."!mark_push"(0, rx2464_pos, $I10)
  # rx literal  ")"
    add $I11, rx2464_pos, 1
    gt $I11, rx2464_eos, rx2464_fail
    sub $I11, rx2464_pos, rx2464_off
    ord $I11, rx2464_tgt, $I11
    ne $I11, 41, rx2464_fail
    add rx2464_pos, 1
    goto alt2466_end
  alt2466_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2464_cur."!cursor_pos"(rx2464_pos)
    $P10 = rx2464_cur."FAILGOAL"("')'")
    unless $P10, rx2464_fail
    goto rxsubrule2468_pass
  rxsubrule2468_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2464_fail
  rxsubrule2468_pass:
    set_addr $I10, rxsubrule2468_back
    rx2464_cur."!mark_push"(0, rx2464_pos, $I10, $P10)
    rx2464_pos = $P10."pos"()
  alt2466_end:
  # rx pass
    rx2464_cur."!cursor_pass"(rx2464_pos, "circumfix:sym<sigil>")
    if_null rx2464_debug, debug_1430
    rx2464_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2464_pos)
  debug_1430:
    .return (rx2464_cur)
  rx2464_restart:
.annotate 'line', 438
    if_null rx2464_debug, debug_1431
    rx2464_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1431:
  rx2464_fail:
    (rx2464_rep, rx2464_pos, $I10, $P10) = rx2464_cur."!mark_fail"(0)
    lt rx2464_pos, -1, rx2464_done
    eq rx2464_pos, -1, rx2464_fail
    jump $I10
  rx2464_done:
    rx2464_cur."!cursor_fail"()
    if_null rx2464_debug, debug_1432
    rx2464_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1432:
    .return (rx2464_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("301_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2470 = self."!PREFIX__!subrule"("sigil", "")
    new $P2471, "ResizablePMCArray"
    push $P2471, $P2470
    .return ($P2471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("302_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2473_tgt
    .local int rx2473_pos
    .local int rx2473_off
    .local int rx2473_eos
    .local int rx2473_rep
    .local pmc rx2473_cur
    .local pmc rx2473_debug
    (rx2473_cur, rx2473_pos, rx2473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2473_cur
    .local pmc match
    .lex "$/", match
    length rx2473_eos, rx2473_tgt
    gt rx2473_pos, rx2473_eos, rx2473_done
    set rx2473_off, 0
    lt rx2473_pos, 2, rx2473_start
    sub rx2473_off, rx2473_pos, 1
    substr rx2473_tgt, rx2473_tgt, rx2473_off
  rx2473_start:
    eq $I10, 1, rx2473_restart
    if_null rx2473_debug, debug_1433
    rx2473_cur."!cursor_debug"("START", "semilist")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2474_done
    goto rxscan2474_scan
  rxscan2474_loop:
    (rx2473_pos) = rx2473_cur."from"()
    inc rx2473_pos
    rx2473_cur."!cursor_from"(rx2473_pos)
    ge rx2473_pos, rx2473_eos, rxscan2474_done
  rxscan2474_scan:
    set_addr $I10, rxscan2474_loop
    rx2473_cur."!mark_push"(0, rx2473_pos, $I10)
  rxscan2474_done:
.annotate 'line', 1036
  # rx subrule "ws" subtype=method negate=
    rx2473_cur."!cursor_pos"(rx2473_pos)
    $P10 = rx2473_cur."ws"()
    unless $P10, rx2473_fail
    rx2473_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2473_cur."!cursor_pos"(rx2473_pos)
    $P10 = rx2473_cur."statement"()
    unless $P10, rx2473_fail
    rx2473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2473_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2473_cur."!cursor_pos"(rx2473_pos)
    $P10 = rx2473_cur."ws"()
    unless $P10, rx2473_fail
    rx2473_pos = $P10."pos"()
  # rx pass
    rx2473_cur."!cursor_pass"(rx2473_pos, "semilist")
    if_null rx2473_debug, debug_1434
    rx2473_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2473_pos)
  debug_1434:
    .return (rx2473_cur)
  rx2473_restart:
.annotate 'line', 438
    if_null rx2473_debug, debug_1435
    rx2473_cur."!cursor_debug"("NEXT", "semilist")
  debug_1435:
  rx2473_fail:
    (rx2473_rep, rx2473_pos, $I10, $P10) = rx2473_cur."!mark_fail"(0)
    lt rx2473_pos, -1, rx2473_done
    eq rx2473_pos, -1, rx2473_fail
    jump $I10
  rx2473_done:
    rx2473_cur."!cursor_fail"()
    if_null rx2473_debug, debug_1436
    rx2473_cur."!cursor_debug"("FAIL", "semilist")
  debug_1436:
    .return (rx2473_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("303_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2478 = self."!PREFIX__!subrule"("ws", "")
    new $P2479, "ResizablePMCArray"
    push $P2479, $P2478
    .return ($P2479)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("304_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2481_tgt
    .local int rx2481_pos
    .local int rx2481_off
    .local int rx2481_eos
    .local int rx2481_rep
    .local pmc rx2481_cur
    .local pmc rx2481_debug
    (rx2481_cur, rx2481_pos, rx2481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2481_cur
    .local pmc match
    .lex "$/", match
    length rx2481_eos, rx2481_tgt
    gt rx2481_pos, rx2481_eos, rx2481_done
    set rx2481_off, 0
    lt rx2481_pos, 2, rx2481_start
    sub rx2481_off, rx2481_pos, 1
    substr rx2481_tgt, rx2481_tgt, rx2481_off
  rx2481_start:
    eq $I10, 1, rx2481_restart
    if_null rx2481_debug, debug_1437
    rx2481_cur."!cursor_debug"("START", "infixish")
  debug_1437:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2482_done
    goto rxscan2482_scan
  rxscan2482_loop:
    (rx2481_pos) = rx2481_cur."from"()
    inc rx2481_pos
    rx2481_cur."!cursor_from"(rx2481_pos)
    ge rx2481_pos, rx2481_eos, rxscan2482_done
  rxscan2482_scan:
    set_addr $I10, rxscan2482_loop
    rx2481_cur."!mark_push"(0, rx2481_pos, $I10)
  rxscan2482_done:
.annotate 'line', 1059
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2481_cur."!cursor_pos"(rx2481_pos)
    $P10 = rx2481_cur."infixstopper"()
    if $P10, rx2481_fail
  # rx subrule "infix" subtype=capture negate=
    rx2481_cur."!cursor_pos"(rx2481_pos)
    $P10 = rx2481_cur."infix"()
    unless $P10, rx2481_fail
    rx2481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2481_pos = $P10."pos"()
  # rx pass
    rx2481_cur."!cursor_pass"(rx2481_pos, "infixish")
    if_null rx2481_debug, debug_1438
    rx2481_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2481_pos)
  debug_1438:
    .return (rx2481_cur)
  rx2481_restart:
.annotate 'line', 438
    if_null rx2481_debug, debug_1439
    rx2481_cur."!cursor_debug"("NEXT", "infixish")
  debug_1439:
  rx2481_fail:
    (rx2481_rep, rx2481_pos, $I10, $P10) = rx2481_cur."!mark_fail"(0)
    lt rx2481_pos, -1, rx2481_done
    eq rx2481_pos, -1, rx2481_fail
    jump $I10
  rx2481_done:
    rx2481_cur."!cursor_fail"()
    if_null rx2481_debug, debug_1440
    rx2481_cur."!cursor_debug"("FAIL", "infixish")
  debug_1440:
    .return (rx2481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("305_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2484, "ResizablePMCArray"
    push $P2484, ""
    .return ($P2484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("306_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2486_tgt
    .local int rx2486_pos
    .local int rx2486_off
    .local int rx2486_eos
    .local int rx2486_rep
    .local pmc rx2486_cur
    .local pmc rx2486_debug
    (rx2486_cur, rx2486_pos, rx2486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2486_cur
    .local pmc match
    .lex "$/", match
    length rx2486_eos, rx2486_tgt
    gt rx2486_pos, rx2486_eos, rx2486_done
    set rx2486_off, 0
    lt rx2486_pos, 2, rx2486_start
    sub rx2486_off, rx2486_pos, 1
    substr rx2486_tgt, rx2486_tgt, rx2486_off
  rx2486_start:
    eq $I10, 1, rx2486_restart
    if_null rx2486_debug, debug_1441
    rx2486_cur."!cursor_debug"("START", "infixstopper")
  debug_1441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2487_done
    goto rxscan2487_scan
  rxscan2487_loop:
    (rx2486_pos) = rx2486_cur."from"()
    inc rx2486_pos
    rx2486_cur."!cursor_from"(rx2486_pos)
    ge rx2486_pos, rx2486_eos, rxscan2487_done
  rxscan2487_scan:
    set_addr $I10, rxscan2487_loop
    rx2486_cur."!mark_push"(0, rx2486_pos, $I10)
  rxscan2487_done:
.annotate 'line', 1060
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2486_cur."!cursor_pos"(rx2486_pos)
    $P10 = rx2486_cur."lambda"()
    unless $P10, rx2486_fail
  # rx pass
    rx2486_cur."!cursor_pass"(rx2486_pos, "infixstopper")
    if_null rx2486_debug, debug_1442
    rx2486_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2486_pos)
  debug_1442:
    .return (rx2486_cur)
  rx2486_restart:
.annotate 'line', 438
    if_null rx2486_debug, debug_1443
    rx2486_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1443:
  rx2486_fail:
    (rx2486_rep, rx2486_pos, $I10, $P10) = rx2486_cur."!mark_fail"(0)
    lt rx2486_pos, -1, rx2486_done
    eq rx2486_pos, -1, rx2486_fail
    jump $I10
  rx2486_done:
    rx2486_cur."!cursor_fail"()
    if_null rx2486_debug, debug_1444
    rx2486_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1444:
    .return (rx2486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("307_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2489, "ResizablePMCArray"
    push $P2489, ""
    .return ($P2489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("308_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2491_tgt
    .local int rx2491_pos
    .local int rx2491_off
    .local int rx2491_eos
    .local int rx2491_rep
    .local pmc rx2491_cur
    .local pmc rx2491_debug
    (rx2491_cur, rx2491_pos, rx2491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2491_cur
    .local pmc match
    .lex "$/", match
    length rx2491_eos, rx2491_tgt
    gt rx2491_pos, rx2491_eos, rx2491_done
    set rx2491_off, 0
    lt rx2491_pos, 2, rx2491_start
    sub rx2491_off, rx2491_pos, 1
    substr rx2491_tgt, rx2491_tgt, rx2491_off
  rx2491_start:
    eq $I10, 1, rx2491_restart
    if_null rx2491_debug, debug_1445
    rx2491_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1445:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2492_done
    goto rxscan2492_scan
  rxscan2492_loop:
    (rx2491_pos) = rx2491_cur."from"()
    inc rx2491_pos
    rx2491_cur."!cursor_from"(rx2491_pos)
    ge rx2491_pos, rx2491_eos, rxscan2492_done
  rxscan2492_scan:
    set_addr $I10, rxscan2492_loop
    rx2491_cur."!mark_push"(0, rx2491_pos, $I10)
  rxscan2492_done:
.annotate 'line', 1063
  # rx literal  "["
    add $I11, rx2491_pos, 1
    gt $I11, rx2491_eos, rx2491_fail
    sub $I11, rx2491_pos, rx2491_off
    ord $I11, rx2491_tgt, $I11
    ne $I11, 91, rx2491_fail
    add rx2491_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2491_cur."!cursor_pos"(rx2491_pos)
    $P10 = rx2491_cur."ws"()
    unless $P10, rx2491_fail
    rx2491_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2491_cur."!cursor_pos"(rx2491_pos)
    $P10 = rx2491_cur."EXPR"()
    unless $P10, rx2491_fail
    rx2491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2491_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2491_pos, 1
    gt $I11, rx2491_eos, rx2491_fail
    sub $I11, rx2491_pos, rx2491_off
    ord $I11, rx2491_tgt, $I11
    ne $I11, 93, rx2491_fail
    add rx2491_pos, 1
.annotate 'line', 1064
  # rx subrule "O" subtype=capture negate=
    rx2491_cur."!cursor_pos"(rx2491_pos)
    $P10 = rx2491_cur."O"("%methodop")
    unless $P10, rx2491_fail
    rx2491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2491_pos = $P10."pos"()
.annotate 'line', 1062
  # rx pass
    rx2491_cur."!cursor_pass"(rx2491_pos, "postcircumfix:sym<[ ]>")
    if_null rx2491_debug, debug_1446
    rx2491_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2491_pos)
  debug_1446:
    .return (rx2491_cur)
  rx2491_restart:
.annotate 'line', 438
    if_null rx2491_debug, debug_1447
    rx2491_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1447:
  rx2491_fail:
    (rx2491_rep, rx2491_pos, $I10, $P10) = rx2491_cur."!mark_fail"(0)
    lt rx2491_pos, -1, rx2491_done
    eq rx2491_pos, -1, rx2491_fail
    jump $I10
  rx2491_done:
    rx2491_cur."!cursor_fail"()
    if_null rx2491_debug, debug_1448
    rx2491_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1448:
    .return (rx2491_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("309_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2494 = self."!PREFIX__!subrule"("ws", "[")
    new $P2495, "ResizablePMCArray"
    push $P2495, $P2494
    .return ($P2495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("310_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2497_tgt
    .local int rx2497_pos
    .local int rx2497_off
    .local int rx2497_eos
    .local int rx2497_rep
    .local pmc rx2497_cur
    .local pmc rx2497_debug
    (rx2497_cur, rx2497_pos, rx2497_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2497_cur
    .local pmc match
    .lex "$/", match
    length rx2497_eos, rx2497_tgt
    gt rx2497_pos, rx2497_eos, rx2497_done
    set rx2497_off, 0
    lt rx2497_pos, 2, rx2497_start
    sub rx2497_off, rx2497_pos, 1
    substr rx2497_tgt, rx2497_tgt, rx2497_off
  rx2497_start:
    eq $I10, 1, rx2497_restart
    if_null rx2497_debug, debug_1449
    rx2497_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1449:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2498_done
    goto rxscan2498_scan
  rxscan2498_loop:
    (rx2497_pos) = rx2497_cur."from"()
    inc rx2497_pos
    rx2497_cur."!cursor_from"(rx2497_pos)
    ge rx2497_pos, rx2497_eos, rxscan2498_done
  rxscan2498_scan:
    set_addr $I10, rxscan2498_loop
    rx2497_cur."!mark_push"(0, rx2497_pos, $I10)
  rxscan2498_done:
.annotate 'line', 1068
  # rx literal  "{"
    add $I11, rx2497_pos, 1
    gt $I11, rx2497_eos, rx2497_fail
    sub $I11, rx2497_pos, rx2497_off
    ord $I11, rx2497_tgt, $I11
    ne $I11, 123, rx2497_fail
    add rx2497_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2497_cur."!cursor_pos"(rx2497_pos)
    $P10 = rx2497_cur."ws"()
    unless $P10, rx2497_fail
    rx2497_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2497_cur."!cursor_pos"(rx2497_pos)
    $P10 = rx2497_cur."EXPR"()
    unless $P10, rx2497_fail
    rx2497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2497_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2497_pos, 1
    gt $I11, rx2497_eos, rx2497_fail
    sub $I11, rx2497_pos, rx2497_off
    ord $I11, rx2497_tgt, $I11
    ne $I11, 125, rx2497_fail
    add rx2497_pos, 1
.annotate 'line', 1069
  # rx subrule "O" subtype=capture negate=
    rx2497_cur."!cursor_pos"(rx2497_pos)
    $P10 = rx2497_cur."O"("%methodop")
    unless $P10, rx2497_fail
    rx2497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2497_pos = $P10."pos"()
.annotate 'line', 1067
  # rx pass
    rx2497_cur."!cursor_pass"(rx2497_pos, "postcircumfix:sym<{ }>")
    if_null rx2497_debug, debug_1450
    rx2497_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2497_pos)
  debug_1450:
    .return (rx2497_cur)
  rx2497_restart:
.annotate 'line', 438
    if_null rx2497_debug, debug_1451
    rx2497_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1451:
  rx2497_fail:
    (rx2497_rep, rx2497_pos, $I10, $P10) = rx2497_cur."!mark_fail"(0)
    lt rx2497_pos, -1, rx2497_done
    eq rx2497_pos, -1, rx2497_fail
    jump $I10
  rx2497_done:
    rx2497_cur."!cursor_fail"()
    if_null rx2497_debug, debug_1452
    rx2497_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1452:
    .return (rx2497_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("311_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2500 = self."!PREFIX__!subrule"("ws", "{")
    new $P2501, "ResizablePMCArray"
    push $P2501, $P2500
    .return ($P2501)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("312_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2503_tgt
    .local int rx2503_pos
    .local int rx2503_off
    .local int rx2503_eos
    .local int rx2503_rep
    .local pmc rx2503_cur
    .local pmc rx2503_debug
    (rx2503_cur, rx2503_pos, rx2503_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2503_cur
    .local pmc match
    .lex "$/", match
    length rx2503_eos, rx2503_tgt
    gt rx2503_pos, rx2503_eos, rx2503_done
    set rx2503_off, 0
    lt rx2503_pos, 2, rx2503_start
    sub rx2503_off, rx2503_pos, 1
    substr rx2503_tgt, rx2503_tgt, rx2503_off
  rx2503_start:
    eq $I10, 1, rx2503_restart
    if_null rx2503_debug, debug_1453
    rx2503_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2504_done
    goto rxscan2504_scan
  rxscan2504_loop:
    (rx2503_pos) = rx2503_cur."from"()
    inc rx2503_pos
    rx2503_cur."!cursor_from"(rx2503_pos)
    ge rx2503_pos, rx2503_eos, rxscan2504_done
  rxscan2504_scan:
    set_addr $I10, rxscan2504_loop
    rx2503_cur."!mark_push"(0, rx2503_pos, $I10)
  rxscan2504_done:
.annotate 'line', 1073
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2503_pos, rx2503_off
    substr $S10, rx2503_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2503_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2503_cur."!cursor_pos"(rx2503_pos)
    $P10 = rx2503_cur."quote_EXPR"(":q")
    unless $P10, rx2503_fail
    rx2503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2503_pos = $P10."pos"()
.annotate 'line', 1074
  # rx subrule "O" subtype=capture negate=
    rx2503_cur."!cursor_pos"(rx2503_pos)
    $P10 = rx2503_cur."O"("%methodop")
    unless $P10, rx2503_fail
    rx2503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2503_pos = $P10."pos"()
.annotate 'line', 1072
  # rx pass
    rx2503_cur."!cursor_pass"(rx2503_pos, "postcircumfix:sym<ang>")
    if_null rx2503_debug, debug_1454
    rx2503_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2503_pos)
  debug_1454:
    .return (rx2503_cur)
  rx2503_restart:
.annotate 'line', 438
    if_null rx2503_debug, debug_1455
    rx2503_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1455:
  rx2503_fail:
    (rx2503_rep, rx2503_pos, $I10, $P10) = rx2503_cur."!mark_fail"(0)
    lt rx2503_pos, -1, rx2503_done
    eq rx2503_pos, -1, rx2503_fail
    jump $I10
  rx2503_done:
    rx2503_cur."!cursor_fail"()
    if_null rx2503_debug, debug_1456
    rx2503_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1456:
    .return (rx2503_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("313_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2506, "ResizablePMCArray"
    push $P2506, "<"
    .return ($P2506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("314_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2508_tgt
    .local int rx2508_pos
    .local int rx2508_off
    .local int rx2508_eos
    .local int rx2508_rep
    .local pmc rx2508_cur
    .local pmc rx2508_debug
    (rx2508_cur, rx2508_pos, rx2508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2508_cur
    .local pmc match
    .lex "$/", match
    length rx2508_eos, rx2508_tgt
    gt rx2508_pos, rx2508_eos, rx2508_done
    set rx2508_off, 0
    lt rx2508_pos, 2, rx2508_start
    sub rx2508_off, rx2508_pos, 1
    substr rx2508_tgt, rx2508_tgt, rx2508_off
  rx2508_start:
    eq $I10, 1, rx2508_restart
    if_null rx2508_debug, debug_1457
    rx2508_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1457:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2509_done
    goto rxscan2509_scan
  rxscan2509_loop:
    (rx2508_pos) = rx2508_cur."from"()
    inc rx2508_pos
    rx2508_cur."!cursor_from"(rx2508_pos)
    ge rx2508_pos, rx2508_eos, rxscan2509_done
  rxscan2509_scan:
    set_addr $I10, rxscan2509_loop
    rx2508_cur."!mark_push"(0, rx2508_pos, $I10)
  rxscan2509_done:
.annotate 'line', 1078
  # rx literal  "("
    add $I11, rx2508_pos, 1
    gt $I11, rx2508_eos, rx2508_fail
    sub $I11, rx2508_pos, rx2508_off
    ord $I11, rx2508_tgt, $I11
    ne $I11, 40, rx2508_fail
    add rx2508_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2508_cur."!cursor_pos"(rx2508_pos)
    $P10 = rx2508_cur."ws"()
    unless $P10, rx2508_fail
    rx2508_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2508_cur."!cursor_pos"(rx2508_pos)
    $P10 = rx2508_cur."arglist"()
    unless $P10, rx2508_fail
    rx2508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2508_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2508_pos, 1
    gt $I11, rx2508_eos, rx2508_fail
    sub $I11, rx2508_pos, rx2508_off
    ord $I11, rx2508_tgt, $I11
    ne $I11, 41, rx2508_fail
    add rx2508_pos, 1
.annotate 'line', 1079
  # rx subrule "O" subtype=capture negate=
    rx2508_cur."!cursor_pos"(rx2508_pos)
    $P10 = rx2508_cur."O"("%methodop")
    unless $P10, rx2508_fail
    rx2508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2508_pos = $P10."pos"()
.annotate 'line', 1077
  # rx pass
    rx2508_cur."!cursor_pass"(rx2508_pos, "postcircumfix:sym<( )>")
    if_null rx2508_debug, debug_1458
    rx2508_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2508_pos)
  debug_1458:
    .return (rx2508_cur)
  rx2508_restart:
.annotate 'line', 438
    if_null rx2508_debug, debug_1459
    rx2508_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1459:
  rx2508_fail:
    (rx2508_rep, rx2508_pos, $I10, $P10) = rx2508_cur."!mark_fail"(0)
    lt rx2508_pos, -1, rx2508_done
    eq rx2508_pos, -1, rx2508_fail
    jump $I10
  rx2508_done:
    rx2508_cur."!cursor_fail"()
    if_null rx2508_debug, debug_1460
    rx2508_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1460:
    .return (rx2508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("315_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2511 = self."!PREFIX__!subrule"("ws", "(")
    new $P2512, "ResizablePMCArray"
    push $P2512, $P2511
    .return ($P2512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("316_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2514_tgt
    .local int rx2514_pos
    .local int rx2514_off
    .local int rx2514_eos
    .local int rx2514_rep
    .local pmc rx2514_cur
    .local pmc rx2514_debug
    (rx2514_cur, rx2514_pos, rx2514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2514_cur
    .local pmc match
    .lex "$/", match
    length rx2514_eos, rx2514_tgt
    gt rx2514_pos, rx2514_eos, rx2514_done
    set rx2514_off, 0
    lt rx2514_pos, 2, rx2514_start
    sub rx2514_off, rx2514_pos, 1
    substr rx2514_tgt, rx2514_tgt, rx2514_off
  rx2514_start:
    eq $I10, 1, rx2514_restart
    if_null rx2514_debug, debug_1461
    rx2514_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1461:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2515_done
    goto rxscan2515_scan
  rxscan2515_loop:
    (rx2514_pos) = rx2514_cur."from"()
    inc rx2514_pos
    rx2514_cur."!cursor_from"(rx2514_pos)
    ge rx2514_pos, rx2514_eos, rxscan2515_done
  rxscan2515_scan:
    set_addr $I10, rxscan2515_loop
    rx2514_cur."!mark_push"(0, rx2514_pos, $I10)
  rxscan2515_done:
.annotate 'line', 1082
  # rx subrule "dotty" subtype=capture negate=
    rx2514_cur."!cursor_pos"(rx2514_pos)
    $P10 = rx2514_cur."dotty"()
    unless $P10, rx2514_fail
    rx2514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2514_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2514_cur."!cursor_pos"(rx2514_pos)
    $P10 = rx2514_cur."O"("%methodop")
    unless $P10, rx2514_fail
    rx2514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2514_pos = $P10."pos"()
  # rx pass
    rx2514_cur."!cursor_pass"(rx2514_pos, "postfix:sym<.>")
    if_null rx2514_debug, debug_1462
    rx2514_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2514_pos)
  debug_1462:
    .return (rx2514_cur)
  rx2514_restart:
.annotate 'line', 438
    if_null rx2514_debug, debug_1463
    rx2514_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1463:
  rx2514_fail:
    (rx2514_rep, rx2514_pos, $I10, $P10) = rx2514_cur."!mark_fail"(0)
    lt rx2514_pos, -1, rx2514_done
    eq rx2514_pos, -1, rx2514_fail
    jump $I10
  rx2514_done:
    rx2514_cur."!cursor_fail"()
    if_null rx2514_debug, debug_1464
    rx2514_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1464:
    .return (rx2514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("317_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2517 = self."!PREFIX__!subrule"("dotty", "")
    new $P2518, "ResizablePMCArray"
    push $P2518, $P2517
    .return ($P2518)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("318_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2520_tgt
    .local int rx2520_pos
    .local int rx2520_off
    .local int rx2520_eos
    .local int rx2520_rep
    .local pmc rx2520_cur
    .local pmc rx2520_debug
    (rx2520_cur, rx2520_pos, rx2520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2520_cur
    .local pmc match
    .lex "$/", match
    length rx2520_eos, rx2520_tgt
    gt rx2520_pos, rx2520_eos, rx2520_done
    set rx2520_off, 0
    lt rx2520_pos, 2, rx2520_start
    sub rx2520_off, rx2520_pos, 1
    substr rx2520_tgt, rx2520_tgt, rx2520_off
  rx2520_start:
    eq $I10, 1, rx2520_restart
    if_null rx2520_debug, debug_1465
    rx2520_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1465:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2521_done
    goto rxscan2521_scan
  rxscan2521_loop:
    (rx2520_pos) = rx2520_cur."from"()
    inc rx2520_pos
    rx2520_cur."!cursor_from"(rx2520_pos)
    ge rx2520_pos, rx2520_eos, rxscan2521_done
  rxscan2521_scan:
    set_addr $I10, rxscan2521_loop
    rx2520_cur."!mark_push"(0, rx2520_pos, $I10)
  rxscan2521_done:
.annotate 'line', 1084
  # rx subcapture "sym"
    set_addr $I10, rxcap_2522_fail
    rx2520_cur."!mark_push"(0, rx2520_pos, $I10)
  # rx literal  "++"
    add $I11, rx2520_pos, 2
    gt $I11, rx2520_eos, rx2520_fail
    sub $I11, rx2520_pos, rx2520_off
    substr $S10, rx2520_tgt, $I11, 2
    ne $S10, "++", rx2520_fail
    add rx2520_pos, 2
    set_addr $I10, rxcap_2522_fail
    ($I12, $I11) = rx2520_cur."!mark_peek"($I10)
    rx2520_cur."!cursor_pos"($I11)
    ($P10) = rx2520_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2520_pos, "")
    rx2520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2522_done
  rxcap_2522_fail:
    goto rx2520_fail
  rxcap_2522_done:
  # rx subrule "O" subtype=capture negate=
    rx2520_cur."!cursor_pos"(rx2520_pos)
    $P10 = rx2520_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2520_fail
    rx2520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2520_pos = $P10."pos"()
  # rx pass
    rx2520_cur."!cursor_pass"(rx2520_pos, "prefix:sym<++>")
    if_null rx2520_debug, debug_1466
    rx2520_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2520_pos)
  debug_1466:
    .return (rx2520_cur)
  rx2520_restart:
.annotate 'line', 438
    if_null rx2520_debug, debug_1467
    rx2520_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1467:
  rx2520_fail:
    (rx2520_rep, rx2520_pos, $I10, $P10) = rx2520_cur."!mark_fail"(0)
    lt rx2520_pos, -1, rx2520_done
    eq rx2520_pos, -1, rx2520_fail
    jump $I10
  rx2520_done:
    rx2520_cur."!cursor_fail"()
    if_null rx2520_debug, debug_1468
    rx2520_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1468:
    .return (rx2520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("319_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2524 = self."!PREFIX__!subrule"("O", "++")
    new $P2525, "ResizablePMCArray"
    push $P2525, $P2524
    .return ($P2525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("320_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2527_tgt
    .local int rx2527_pos
    .local int rx2527_off
    .local int rx2527_eos
    .local int rx2527_rep
    .local pmc rx2527_cur
    .local pmc rx2527_debug
    (rx2527_cur, rx2527_pos, rx2527_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2527_cur
    .local pmc match
    .lex "$/", match
    length rx2527_eos, rx2527_tgt
    gt rx2527_pos, rx2527_eos, rx2527_done
    set rx2527_off, 0
    lt rx2527_pos, 2, rx2527_start
    sub rx2527_off, rx2527_pos, 1
    substr rx2527_tgt, rx2527_tgt, rx2527_off
  rx2527_start:
    eq $I10, 1, rx2527_restart
    if_null rx2527_debug, debug_1469
    rx2527_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1469:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2528_done
    goto rxscan2528_scan
  rxscan2528_loop:
    (rx2527_pos) = rx2527_cur."from"()
    inc rx2527_pos
    rx2527_cur."!cursor_from"(rx2527_pos)
    ge rx2527_pos, rx2527_eos, rxscan2528_done
  rxscan2528_scan:
    set_addr $I10, rxscan2528_loop
    rx2527_cur."!mark_push"(0, rx2527_pos, $I10)
  rxscan2528_done:
.annotate 'line', 1085
  # rx subcapture "sym"
    set_addr $I10, rxcap_2529_fail
    rx2527_cur."!mark_push"(0, rx2527_pos, $I10)
  # rx literal  "--"
    add $I11, rx2527_pos, 2
    gt $I11, rx2527_eos, rx2527_fail
    sub $I11, rx2527_pos, rx2527_off
    substr $S10, rx2527_tgt, $I11, 2
    ne $S10, "--", rx2527_fail
    add rx2527_pos, 2
    set_addr $I10, rxcap_2529_fail
    ($I12, $I11) = rx2527_cur."!mark_peek"($I10)
    rx2527_cur."!cursor_pos"($I11)
    ($P10) = rx2527_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2527_pos, "")
    rx2527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2529_done
  rxcap_2529_fail:
    goto rx2527_fail
  rxcap_2529_done:
  # rx subrule "O" subtype=capture negate=
    rx2527_cur."!cursor_pos"(rx2527_pos)
    $P10 = rx2527_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2527_fail
    rx2527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2527_pos = $P10."pos"()
  # rx pass
    rx2527_cur."!cursor_pass"(rx2527_pos, "prefix:sym<-->")
    if_null rx2527_debug, debug_1470
    rx2527_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2527_pos)
  debug_1470:
    .return (rx2527_cur)
  rx2527_restart:
.annotate 'line', 438
    if_null rx2527_debug, debug_1471
    rx2527_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1471:
  rx2527_fail:
    (rx2527_rep, rx2527_pos, $I10, $P10) = rx2527_cur."!mark_fail"(0)
    lt rx2527_pos, -1, rx2527_done
    eq rx2527_pos, -1, rx2527_fail
    jump $I10
  rx2527_done:
    rx2527_cur."!cursor_fail"()
    if_null rx2527_debug, debug_1472
    rx2527_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1472:
    .return (rx2527_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("321_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2531 = self."!PREFIX__!subrule"("O", "--")
    new $P2532, "ResizablePMCArray"
    push $P2532, $P2531
    .return ($P2532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("322_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2534_tgt
    .local int rx2534_pos
    .local int rx2534_off
    .local int rx2534_eos
    .local int rx2534_rep
    .local pmc rx2534_cur
    .local pmc rx2534_debug
    (rx2534_cur, rx2534_pos, rx2534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2534_cur
    .local pmc match
    .lex "$/", match
    length rx2534_eos, rx2534_tgt
    gt rx2534_pos, rx2534_eos, rx2534_done
    set rx2534_off, 0
    lt rx2534_pos, 2, rx2534_start
    sub rx2534_off, rx2534_pos, 1
    substr rx2534_tgt, rx2534_tgt, rx2534_off
  rx2534_start:
    eq $I10, 1, rx2534_restart
    if_null rx2534_debug, debug_1473
    rx2534_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1473:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2535_done
    goto rxscan2535_scan
  rxscan2535_loop:
    (rx2534_pos) = rx2534_cur."from"()
    inc rx2534_pos
    rx2534_cur."!cursor_from"(rx2534_pos)
    ge rx2534_pos, rx2534_eos, rxscan2535_done
  rxscan2535_scan:
    set_addr $I10, rxscan2535_loop
    rx2534_cur."!mark_push"(0, rx2534_pos, $I10)
  rxscan2535_done:
.annotate 'line', 1088
  # rx subcapture "sym"
    set_addr $I10, rxcap_2536_fail
    rx2534_cur."!mark_push"(0, rx2534_pos, $I10)
  # rx literal  "++"
    add $I11, rx2534_pos, 2
    gt $I11, rx2534_eos, rx2534_fail
    sub $I11, rx2534_pos, rx2534_off
    substr $S10, rx2534_tgt, $I11, 2
    ne $S10, "++", rx2534_fail
    add rx2534_pos, 2
    set_addr $I10, rxcap_2536_fail
    ($I12, $I11) = rx2534_cur."!mark_peek"($I10)
    rx2534_cur."!cursor_pos"($I11)
    ($P10) = rx2534_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2534_pos, "")
    rx2534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2536_done
  rxcap_2536_fail:
    goto rx2534_fail
  rxcap_2536_done:
  # rx subrule "O" subtype=capture negate=
    rx2534_cur."!cursor_pos"(rx2534_pos)
    $P10 = rx2534_cur."O"("%autoincrement")
    unless $P10, rx2534_fail
    rx2534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2534_pos = $P10."pos"()
  # rx pass
    rx2534_cur."!cursor_pass"(rx2534_pos, "postfix:sym<++>")
    if_null rx2534_debug, debug_1474
    rx2534_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2534_pos)
  debug_1474:
    .return (rx2534_cur)
  rx2534_restart:
.annotate 'line', 438
    if_null rx2534_debug, debug_1475
    rx2534_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1475:
  rx2534_fail:
    (rx2534_rep, rx2534_pos, $I10, $P10) = rx2534_cur."!mark_fail"(0)
    lt rx2534_pos, -1, rx2534_done
    eq rx2534_pos, -1, rx2534_fail
    jump $I10
  rx2534_done:
    rx2534_cur."!cursor_fail"()
    if_null rx2534_debug, debug_1476
    rx2534_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1476:
    .return (rx2534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("323_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2538 = self."!PREFIX__!subrule"("O", "++")
    new $P2539, "ResizablePMCArray"
    push $P2539, $P2538
    .return ($P2539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("324_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2541_tgt
    .local int rx2541_pos
    .local int rx2541_off
    .local int rx2541_eos
    .local int rx2541_rep
    .local pmc rx2541_cur
    .local pmc rx2541_debug
    (rx2541_cur, rx2541_pos, rx2541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2541_cur
    .local pmc match
    .lex "$/", match
    length rx2541_eos, rx2541_tgt
    gt rx2541_pos, rx2541_eos, rx2541_done
    set rx2541_off, 0
    lt rx2541_pos, 2, rx2541_start
    sub rx2541_off, rx2541_pos, 1
    substr rx2541_tgt, rx2541_tgt, rx2541_off
  rx2541_start:
    eq $I10, 1, rx2541_restart
    if_null rx2541_debug, debug_1477
    rx2541_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1477:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2542_done
    goto rxscan2542_scan
  rxscan2542_loop:
    (rx2541_pos) = rx2541_cur."from"()
    inc rx2541_pos
    rx2541_cur."!cursor_from"(rx2541_pos)
    ge rx2541_pos, rx2541_eos, rxscan2542_done
  rxscan2542_scan:
    set_addr $I10, rxscan2542_loop
    rx2541_cur."!mark_push"(0, rx2541_pos, $I10)
  rxscan2542_done:
.annotate 'line', 1089
  # rx subcapture "sym"
    set_addr $I10, rxcap_2543_fail
    rx2541_cur."!mark_push"(0, rx2541_pos, $I10)
  # rx literal  "--"
    add $I11, rx2541_pos, 2
    gt $I11, rx2541_eos, rx2541_fail
    sub $I11, rx2541_pos, rx2541_off
    substr $S10, rx2541_tgt, $I11, 2
    ne $S10, "--", rx2541_fail
    add rx2541_pos, 2
    set_addr $I10, rxcap_2543_fail
    ($I12, $I11) = rx2541_cur."!mark_peek"($I10)
    rx2541_cur."!cursor_pos"($I11)
    ($P10) = rx2541_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2541_pos, "")
    rx2541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2543_done
  rxcap_2543_fail:
    goto rx2541_fail
  rxcap_2543_done:
  # rx subrule "O" subtype=capture negate=
    rx2541_cur."!cursor_pos"(rx2541_pos)
    $P10 = rx2541_cur."O"("%autoincrement")
    unless $P10, rx2541_fail
    rx2541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2541_pos = $P10."pos"()
  # rx pass
    rx2541_cur."!cursor_pass"(rx2541_pos, "postfix:sym<-->")
    if_null rx2541_debug, debug_1478
    rx2541_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2541_pos)
  debug_1478:
    .return (rx2541_cur)
  rx2541_restart:
.annotate 'line', 438
    if_null rx2541_debug, debug_1479
    rx2541_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1479:
  rx2541_fail:
    (rx2541_rep, rx2541_pos, $I10, $P10) = rx2541_cur."!mark_fail"(0)
    lt rx2541_pos, -1, rx2541_done
    eq rx2541_pos, -1, rx2541_fail
    jump $I10
  rx2541_done:
    rx2541_cur."!cursor_fail"()
    if_null rx2541_debug, debug_1480
    rx2541_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1480:
    .return (rx2541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("325_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2545 = self."!PREFIX__!subrule"("O", "--")
    new $P2546, "ResizablePMCArray"
    push $P2546, $P2545
    .return ($P2546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("326_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2548_tgt
    .local int rx2548_pos
    .local int rx2548_off
    .local int rx2548_eos
    .local int rx2548_rep
    .local pmc rx2548_cur
    .local pmc rx2548_debug
    (rx2548_cur, rx2548_pos, rx2548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2548_cur
    .local pmc match
    .lex "$/", match
    length rx2548_eos, rx2548_tgt
    gt rx2548_pos, rx2548_eos, rx2548_done
    set rx2548_off, 0
    lt rx2548_pos, 2, rx2548_start
    sub rx2548_off, rx2548_pos, 1
    substr rx2548_tgt, rx2548_tgt, rx2548_off
  rx2548_start:
    eq $I10, 1, rx2548_restart
    if_null rx2548_debug, debug_1481
    rx2548_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1481:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2549_done
    goto rxscan2549_scan
  rxscan2549_loop:
    (rx2548_pos) = rx2548_cur."from"()
    inc rx2548_pos
    rx2548_cur."!cursor_from"(rx2548_pos)
    ge rx2548_pos, rx2548_eos, rxscan2549_done
  rxscan2549_scan:
    set_addr $I10, rxscan2549_loop
    rx2548_cur."!mark_push"(0, rx2548_pos, $I10)
  rxscan2549_done:
.annotate 'line', 1091
  # rx subcapture "sym"
    set_addr $I10, rxcap_2550_fail
    rx2548_cur."!mark_push"(0, rx2548_pos, $I10)
  # rx literal  "**"
    add $I11, rx2548_pos, 2
    gt $I11, rx2548_eos, rx2548_fail
    sub $I11, rx2548_pos, rx2548_off
    substr $S10, rx2548_tgt, $I11, 2
    ne $S10, "**", rx2548_fail
    add rx2548_pos, 2
    set_addr $I10, rxcap_2550_fail
    ($I12, $I11) = rx2548_cur."!mark_peek"($I10)
    rx2548_cur."!cursor_pos"($I11)
    ($P10) = rx2548_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2548_pos, "")
    rx2548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2550_done
  rxcap_2550_fail:
    goto rx2548_fail
  rxcap_2550_done:
  # rx subrule "O" subtype=capture negate=
    rx2548_cur."!cursor_pos"(rx2548_pos)
    $P10 = rx2548_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx2548_fail
    rx2548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2548_pos = $P10."pos"()
  # rx pass
    rx2548_cur."!cursor_pass"(rx2548_pos, "infix:sym<**>")
    if_null rx2548_debug, debug_1482
    rx2548_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2548_pos)
  debug_1482:
    .return (rx2548_cur)
  rx2548_restart:
.annotate 'line', 438
    if_null rx2548_debug, debug_1483
    rx2548_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1483:
  rx2548_fail:
    (rx2548_rep, rx2548_pos, $I10, $P10) = rx2548_cur."!mark_fail"(0)
    lt rx2548_pos, -1, rx2548_done
    eq rx2548_pos, -1, rx2548_fail
    jump $I10
  rx2548_done:
    rx2548_cur."!cursor_fail"()
    if_null rx2548_debug, debug_1484
    rx2548_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1484:
    .return (rx2548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("327_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2552 = self."!PREFIX__!subrule"("O", "**")
    new $P2553, "ResizablePMCArray"
    push $P2553, $P2552
    .return ($P2553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("328_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2555_tgt
    .local int rx2555_pos
    .local int rx2555_off
    .local int rx2555_eos
    .local int rx2555_rep
    .local pmc rx2555_cur
    .local pmc rx2555_debug
    (rx2555_cur, rx2555_pos, rx2555_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2555_cur
    .local pmc match
    .lex "$/", match
    length rx2555_eos, rx2555_tgt
    gt rx2555_pos, rx2555_eos, rx2555_done
    set rx2555_off, 0
    lt rx2555_pos, 2, rx2555_start
    sub rx2555_off, rx2555_pos, 1
    substr rx2555_tgt, rx2555_tgt, rx2555_off
  rx2555_start:
    eq $I10, 1, rx2555_restart
    if_null rx2555_debug, debug_1485
    rx2555_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1485:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2556_done
    goto rxscan2556_scan
  rxscan2556_loop:
    (rx2555_pos) = rx2555_cur."from"()
    inc rx2555_pos
    rx2555_cur."!cursor_from"(rx2555_pos)
    ge rx2555_pos, rx2555_eos, rxscan2556_done
  rxscan2556_scan:
    set_addr $I10, rxscan2556_loop
    rx2555_cur."!mark_push"(0, rx2555_pos, $I10)
  rxscan2556_done:
.annotate 'line', 1093
  # rx subcapture "sym"
    set_addr $I10, rxcap_2557_fail
    rx2555_cur."!mark_push"(0, rx2555_pos, $I10)
  # rx literal  "+"
    add $I11, rx2555_pos, 1
    gt $I11, rx2555_eos, rx2555_fail
    sub $I11, rx2555_pos, rx2555_off
    ord $I11, rx2555_tgt, $I11
    ne $I11, 43, rx2555_fail
    add rx2555_pos, 1
    set_addr $I10, rxcap_2557_fail
    ($I12, $I11) = rx2555_cur."!mark_peek"($I10)
    rx2555_cur."!cursor_pos"($I11)
    ($P10) = rx2555_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2555_pos, "")
    rx2555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2557_done
  rxcap_2557_fail:
    goto rx2555_fail
  rxcap_2557_done:
  # rx subrule "O" subtype=capture negate=
    rx2555_cur."!cursor_pos"(rx2555_pos)
    $P10 = rx2555_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2555_fail
    rx2555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2555_pos = $P10."pos"()
  # rx pass
    rx2555_cur."!cursor_pass"(rx2555_pos, "prefix:sym<+>")
    if_null rx2555_debug, debug_1486
    rx2555_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2555_pos)
  debug_1486:
    .return (rx2555_cur)
  rx2555_restart:
.annotate 'line', 438
    if_null rx2555_debug, debug_1487
    rx2555_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1487:
  rx2555_fail:
    (rx2555_rep, rx2555_pos, $I10, $P10) = rx2555_cur."!mark_fail"(0)
    lt rx2555_pos, -1, rx2555_done
    eq rx2555_pos, -1, rx2555_fail
    jump $I10
  rx2555_done:
    rx2555_cur."!cursor_fail"()
    if_null rx2555_debug, debug_1488
    rx2555_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1488:
    .return (rx2555_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("329_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2559 = self."!PREFIX__!subrule"("O", "+")
    new $P2560, "ResizablePMCArray"
    push $P2560, $P2559
    .return ($P2560)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("330_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2562_tgt
    .local int rx2562_pos
    .local int rx2562_off
    .local int rx2562_eos
    .local int rx2562_rep
    .local pmc rx2562_cur
    .local pmc rx2562_debug
    (rx2562_cur, rx2562_pos, rx2562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2562_cur
    .local pmc match
    .lex "$/", match
    length rx2562_eos, rx2562_tgt
    gt rx2562_pos, rx2562_eos, rx2562_done
    set rx2562_off, 0
    lt rx2562_pos, 2, rx2562_start
    sub rx2562_off, rx2562_pos, 1
    substr rx2562_tgt, rx2562_tgt, rx2562_off
  rx2562_start:
    eq $I10, 1, rx2562_restart
    if_null rx2562_debug, debug_1489
    rx2562_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1489:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2563_done
    goto rxscan2563_scan
  rxscan2563_loop:
    (rx2562_pos) = rx2562_cur."from"()
    inc rx2562_pos
    rx2562_cur."!cursor_from"(rx2562_pos)
    ge rx2562_pos, rx2562_eos, rxscan2563_done
  rxscan2563_scan:
    set_addr $I10, rxscan2563_loop
    rx2562_cur."!mark_push"(0, rx2562_pos, $I10)
  rxscan2563_done:
.annotate 'line', 1094
  # rx subcapture "sym"
    set_addr $I10, rxcap_2564_fail
    rx2562_cur."!mark_push"(0, rx2562_pos, $I10)
  # rx literal  "~"
    add $I11, rx2562_pos, 1
    gt $I11, rx2562_eos, rx2562_fail
    sub $I11, rx2562_pos, rx2562_off
    ord $I11, rx2562_tgt, $I11
    ne $I11, 126, rx2562_fail
    add rx2562_pos, 1
    set_addr $I10, rxcap_2564_fail
    ($I12, $I11) = rx2562_cur."!mark_peek"($I10)
    rx2562_cur."!cursor_pos"($I11)
    ($P10) = rx2562_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2562_pos, "")
    rx2562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2564_done
  rxcap_2564_fail:
    goto rx2562_fail
  rxcap_2564_done:
  # rx subrule "O" subtype=capture negate=
    rx2562_cur."!cursor_pos"(rx2562_pos)
    $P10 = rx2562_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2562_fail
    rx2562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2562_pos = $P10."pos"()
  # rx pass
    rx2562_cur."!cursor_pass"(rx2562_pos, "prefix:sym<~>")
    if_null rx2562_debug, debug_1490
    rx2562_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2562_pos)
  debug_1490:
    .return (rx2562_cur)
  rx2562_restart:
.annotate 'line', 438
    if_null rx2562_debug, debug_1491
    rx2562_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1491:
  rx2562_fail:
    (rx2562_rep, rx2562_pos, $I10, $P10) = rx2562_cur."!mark_fail"(0)
    lt rx2562_pos, -1, rx2562_done
    eq rx2562_pos, -1, rx2562_fail
    jump $I10
  rx2562_done:
    rx2562_cur."!cursor_fail"()
    if_null rx2562_debug, debug_1492
    rx2562_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1492:
    .return (rx2562_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("331_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2566 = self."!PREFIX__!subrule"("O", "~")
    new $P2567, "ResizablePMCArray"
    push $P2567, $P2566
    .return ($P2567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("332_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2569_tgt
    .local int rx2569_pos
    .local int rx2569_off
    .local int rx2569_eos
    .local int rx2569_rep
    .local pmc rx2569_cur
    .local pmc rx2569_debug
    (rx2569_cur, rx2569_pos, rx2569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2569_cur
    .local pmc match
    .lex "$/", match
    length rx2569_eos, rx2569_tgt
    gt rx2569_pos, rx2569_eos, rx2569_done
    set rx2569_off, 0
    lt rx2569_pos, 2, rx2569_start
    sub rx2569_off, rx2569_pos, 1
    substr rx2569_tgt, rx2569_tgt, rx2569_off
  rx2569_start:
    eq $I10, 1, rx2569_restart
    if_null rx2569_debug, debug_1493
    rx2569_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1493:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2570_done
    goto rxscan2570_scan
  rxscan2570_loop:
    (rx2569_pos) = rx2569_cur."from"()
    inc rx2569_pos
    rx2569_cur."!cursor_from"(rx2569_pos)
    ge rx2569_pos, rx2569_eos, rxscan2570_done
  rxscan2570_scan:
    set_addr $I10, rxscan2570_loop
    rx2569_cur."!mark_push"(0, rx2569_pos, $I10)
  rxscan2570_done:
.annotate 'line', 1095
  # rx subcapture "sym"
    set_addr $I10, rxcap_2571_fail
    rx2569_cur."!mark_push"(0, rx2569_pos, $I10)
  # rx literal  "-"
    add $I11, rx2569_pos, 1
    gt $I11, rx2569_eos, rx2569_fail
    sub $I11, rx2569_pos, rx2569_off
    ord $I11, rx2569_tgt, $I11
    ne $I11, 45, rx2569_fail
    add rx2569_pos, 1
    set_addr $I10, rxcap_2571_fail
    ($I12, $I11) = rx2569_cur."!mark_peek"($I10)
    rx2569_cur."!cursor_pos"($I11)
    ($P10) = rx2569_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2569_pos, "")
    rx2569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2571_done
  rxcap_2571_fail:
    goto rx2569_fail
  rxcap_2571_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2569_pos, rx2569_off
    substr $S10, rx2569_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2569_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2569_cur."!cursor_pos"(rx2569_pos)
    $P10 = rx2569_cur."number"()
    if $P10, rx2569_fail
  # rx subrule "O" subtype=capture negate=
    rx2569_cur."!cursor_pos"(rx2569_pos)
    $P10 = rx2569_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2569_fail
    rx2569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2569_pos = $P10."pos"()
  # rx pass
    rx2569_cur."!cursor_pass"(rx2569_pos, "prefix:sym<->")
    if_null rx2569_debug, debug_1494
    rx2569_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2569_pos)
  debug_1494:
    .return (rx2569_cur)
  rx2569_restart:
.annotate 'line', 438
    if_null rx2569_debug, debug_1495
    rx2569_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1495:
  rx2569_fail:
    (rx2569_rep, rx2569_pos, $I10, $P10) = rx2569_cur."!mark_fail"(0)
    lt rx2569_pos, -1, rx2569_done
    eq rx2569_pos, -1, rx2569_fail
    jump $I10
  rx2569_done:
    rx2569_cur."!cursor_fail"()
    if_null rx2569_debug, debug_1496
    rx2569_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1496:
    .return (rx2569_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("333_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2573, "ResizablePMCArray"
    push $P2573, "-"
    .return ($P2573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("334_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2575_tgt
    .local int rx2575_pos
    .local int rx2575_off
    .local int rx2575_eos
    .local int rx2575_rep
    .local pmc rx2575_cur
    .local pmc rx2575_debug
    (rx2575_cur, rx2575_pos, rx2575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2575_cur
    .local pmc match
    .lex "$/", match
    length rx2575_eos, rx2575_tgt
    gt rx2575_pos, rx2575_eos, rx2575_done
    set rx2575_off, 0
    lt rx2575_pos, 2, rx2575_start
    sub rx2575_off, rx2575_pos, 1
    substr rx2575_tgt, rx2575_tgt, rx2575_off
  rx2575_start:
    eq $I10, 1, rx2575_restart
    if_null rx2575_debug, debug_1497
    rx2575_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1497:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2576_done
    goto rxscan2576_scan
  rxscan2576_loop:
    (rx2575_pos) = rx2575_cur."from"()
    inc rx2575_pos
    rx2575_cur."!cursor_from"(rx2575_pos)
    ge rx2575_pos, rx2575_eos, rxscan2576_done
  rxscan2576_scan:
    set_addr $I10, rxscan2576_loop
    rx2575_cur."!mark_push"(0, rx2575_pos, $I10)
  rxscan2576_done:
.annotate 'line', 1096
  # rx subcapture "sym"
    set_addr $I10, rxcap_2577_fail
    rx2575_cur."!mark_push"(0, rx2575_pos, $I10)
  # rx literal  "?"
    add $I11, rx2575_pos, 1
    gt $I11, rx2575_eos, rx2575_fail
    sub $I11, rx2575_pos, rx2575_off
    ord $I11, rx2575_tgt, $I11
    ne $I11, 63, rx2575_fail
    add rx2575_pos, 1
    set_addr $I10, rxcap_2577_fail
    ($I12, $I11) = rx2575_cur."!mark_peek"($I10)
    rx2575_cur."!cursor_pos"($I11)
    ($P10) = rx2575_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2575_pos, "")
    rx2575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2577_done
  rxcap_2577_fail:
    goto rx2575_fail
  rxcap_2577_done:
  # rx subrule "O" subtype=capture negate=
    rx2575_cur."!cursor_pos"(rx2575_pos)
    $P10 = rx2575_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2575_fail
    rx2575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2575_pos = $P10."pos"()
  # rx pass
    rx2575_cur."!cursor_pass"(rx2575_pos, "prefix:sym<?>")
    if_null rx2575_debug, debug_1498
    rx2575_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2575_pos)
  debug_1498:
    .return (rx2575_cur)
  rx2575_restart:
.annotate 'line', 438
    if_null rx2575_debug, debug_1499
    rx2575_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1499:
  rx2575_fail:
    (rx2575_rep, rx2575_pos, $I10, $P10) = rx2575_cur."!mark_fail"(0)
    lt rx2575_pos, -1, rx2575_done
    eq rx2575_pos, -1, rx2575_fail
    jump $I10
  rx2575_done:
    rx2575_cur."!cursor_fail"()
    if_null rx2575_debug, debug_1500
    rx2575_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1500:
    .return (rx2575_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("335_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2579 = self."!PREFIX__!subrule"("O", "?")
    new $P2580, "ResizablePMCArray"
    push $P2580, $P2579
    .return ($P2580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("336_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2582_tgt
    .local int rx2582_pos
    .local int rx2582_off
    .local int rx2582_eos
    .local int rx2582_rep
    .local pmc rx2582_cur
    .local pmc rx2582_debug
    (rx2582_cur, rx2582_pos, rx2582_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2582_cur
    .local pmc match
    .lex "$/", match
    length rx2582_eos, rx2582_tgt
    gt rx2582_pos, rx2582_eos, rx2582_done
    set rx2582_off, 0
    lt rx2582_pos, 2, rx2582_start
    sub rx2582_off, rx2582_pos, 1
    substr rx2582_tgt, rx2582_tgt, rx2582_off
  rx2582_start:
    eq $I10, 1, rx2582_restart
    if_null rx2582_debug, debug_1501
    rx2582_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1501:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2583_done
    goto rxscan2583_scan
  rxscan2583_loop:
    (rx2582_pos) = rx2582_cur."from"()
    inc rx2582_pos
    rx2582_cur."!cursor_from"(rx2582_pos)
    ge rx2582_pos, rx2582_eos, rxscan2583_done
  rxscan2583_scan:
    set_addr $I10, rxscan2583_loop
    rx2582_cur."!mark_push"(0, rx2582_pos, $I10)
  rxscan2583_done:
.annotate 'line', 1097
  # rx subcapture "sym"
    set_addr $I10, rxcap_2584_fail
    rx2582_cur."!mark_push"(0, rx2582_pos, $I10)
  # rx literal  "!"
    add $I11, rx2582_pos, 1
    gt $I11, rx2582_eos, rx2582_fail
    sub $I11, rx2582_pos, rx2582_off
    ord $I11, rx2582_tgt, $I11
    ne $I11, 33, rx2582_fail
    add rx2582_pos, 1
    set_addr $I10, rxcap_2584_fail
    ($I12, $I11) = rx2582_cur."!mark_peek"($I10)
    rx2582_cur."!cursor_pos"($I11)
    ($P10) = rx2582_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2582_pos, "")
    rx2582_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2584_done
  rxcap_2584_fail:
    goto rx2582_fail
  rxcap_2584_done:
  # rx subrule "O" subtype=capture negate=
    rx2582_cur."!cursor_pos"(rx2582_pos)
    $P10 = rx2582_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2582_fail
    rx2582_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2582_pos = $P10."pos"()
  # rx pass
    rx2582_cur."!cursor_pass"(rx2582_pos, "prefix:sym<!>")
    if_null rx2582_debug, debug_1502
    rx2582_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2582_pos)
  debug_1502:
    .return (rx2582_cur)
  rx2582_restart:
.annotate 'line', 438
    if_null rx2582_debug, debug_1503
    rx2582_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1503:
  rx2582_fail:
    (rx2582_rep, rx2582_pos, $I10, $P10) = rx2582_cur."!mark_fail"(0)
    lt rx2582_pos, -1, rx2582_done
    eq rx2582_pos, -1, rx2582_fail
    jump $I10
  rx2582_done:
    rx2582_cur."!cursor_fail"()
    if_null rx2582_debug, debug_1504
    rx2582_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1504:
    .return (rx2582_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("337_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2586 = self."!PREFIX__!subrule"("O", "!")
    new $P2587, "ResizablePMCArray"
    push $P2587, $P2586
    .return ($P2587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("338_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2589_tgt
    .local int rx2589_pos
    .local int rx2589_off
    .local int rx2589_eos
    .local int rx2589_rep
    .local pmc rx2589_cur
    .local pmc rx2589_debug
    (rx2589_cur, rx2589_pos, rx2589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2589_cur
    .local pmc match
    .lex "$/", match
    length rx2589_eos, rx2589_tgt
    gt rx2589_pos, rx2589_eos, rx2589_done
    set rx2589_off, 0
    lt rx2589_pos, 2, rx2589_start
    sub rx2589_off, rx2589_pos, 1
    substr rx2589_tgt, rx2589_tgt, rx2589_off
  rx2589_start:
    eq $I10, 1, rx2589_restart
    if_null rx2589_debug, debug_1505
    rx2589_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1505:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2590_done
    goto rxscan2590_scan
  rxscan2590_loop:
    (rx2589_pos) = rx2589_cur."from"()
    inc rx2589_pos
    rx2589_cur."!cursor_from"(rx2589_pos)
    ge rx2589_pos, rx2589_eos, rxscan2590_done
  rxscan2590_scan:
    set_addr $I10, rxscan2590_loop
    rx2589_cur."!mark_push"(0, rx2589_pos, $I10)
  rxscan2590_done:
.annotate 'line', 1098
  # rx subcapture "sym"
    set_addr $I10, rxcap_2591_fail
    rx2589_cur."!mark_push"(0, rx2589_pos, $I10)
  # rx literal  "|"
    add $I11, rx2589_pos, 1
    gt $I11, rx2589_eos, rx2589_fail
    sub $I11, rx2589_pos, rx2589_off
    ord $I11, rx2589_tgt, $I11
    ne $I11, 124, rx2589_fail
    add rx2589_pos, 1
    set_addr $I10, rxcap_2591_fail
    ($I12, $I11) = rx2589_cur."!mark_peek"($I10)
    rx2589_cur."!cursor_pos"($I11)
    ($P10) = rx2589_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2589_pos, "")
    rx2589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2591_done
  rxcap_2591_fail:
    goto rx2589_fail
  rxcap_2591_done:
  # rx subrule "O" subtype=capture negate=
    rx2589_cur."!cursor_pos"(rx2589_pos)
    $P10 = rx2589_cur."O"("%symbolic_unary")
    unless $P10, rx2589_fail
    rx2589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2589_pos = $P10."pos"()
  # rx pass
    rx2589_cur."!cursor_pass"(rx2589_pos, "prefix:sym<|>")
    if_null rx2589_debug, debug_1506
    rx2589_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2589_pos)
  debug_1506:
    .return (rx2589_cur)
  rx2589_restart:
.annotate 'line', 438
    if_null rx2589_debug, debug_1507
    rx2589_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1507:
  rx2589_fail:
    (rx2589_rep, rx2589_pos, $I10, $P10) = rx2589_cur."!mark_fail"(0)
    lt rx2589_pos, -1, rx2589_done
    eq rx2589_pos, -1, rx2589_fail
    jump $I10
  rx2589_done:
    rx2589_cur."!cursor_fail"()
    if_null rx2589_debug, debug_1508
    rx2589_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1508:
    .return (rx2589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("339_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2593 = self."!PREFIX__!subrule"("O", "|")
    new $P2594, "ResizablePMCArray"
    push $P2594, $P2593
    .return ($P2594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("340_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2596_tgt
    .local int rx2596_pos
    .local int rx2596_off
    .local int rx2596_eos
    .local int rx2596_rep
    .local pmc rx2596_cur
    .local pmc rx2596_debug
    (rx2596_cur, rx2596_pos, rx2596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2596_cur
    .local pmc match
    .lex "$/", match
    length rx2596_eos, rx2596_tgt
    gt rx2596_pos, rx2596_eos, rx2596_done
    set rx2596_off, 0
    lt rx2596_pos, 2, rx2596_start
    sub rx2596_off, rx2596_pos, 1
    substr rx2596_tgt, rx2596_tgt, rx2596_off
  rx2596_start:
    eq $I10, 1, rx2596_restart
    if_null rx2596_debug, debug_1509
    rx2596_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1509:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2597_done
    goto rxscan2597_scan
  rxscan2597_loop:
    (rx2596_pos) = rx2596_cur."from"()
    inc rx2596_pos
    rx2596_cur."!cursor_from"(rx2596_pos)
    ge rx2596_pos, rx2596_eos, rxscan2597_done
  rxscan2597_scan:
    set_addr $I10, rxscan2597_loop
    rx2596_cur."!mark_push"(0, rx2596_pos, $I10)
  rxscan2597_done:
.annotate 'line', 1100
  # rx subcapture "sym"
    set_addr $I10, rxcap_2598_fail
    rx2596_cur."!mark_push"(0, rx2596_pos, $I10)
  # rx literal  "*"
    add $I11, rx2596_pos, 1
    gt $I11, rx2596_eos, rx2596_fail
    sub $I11, rx2596_pos, rx2596_off
    ord $I11, rx2596_tgt, $I11
    ne $I11, 42, rx2596_fail
    add rx2596_pos, 1
    set_addr $I10, rxcap_2598_fail
    ($I12, $I11) = rx2596_cur."!mark_peek"($I10)
    rx2596_cur."!cursor_pos"($I11)
    ($P10) = rx2596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2596_pos, "")
    rx2596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2598_done
  rxcap_2598_fail:
    goto rx2596_fail
  rxcap_2598_done:
  # rx subrule "O" subtype=capture negate=
    rx2596_cur."!cursor_pos"(rx2596_pos)
    $P10 = rx2596_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2596_fail
    rx2596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2596_pos = $P10."pos"()
  # rx pass
    rx2596_cur."!cursor_pass"(rx2596_pos, "infix:sym<*>")
    if_null rx2596_debug, debug_1510
    rx2596_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2596_pos)
  debug_1510:
    .return (rx2596_cur)
  rx2596_restart:
.annotate 'line', 438
    if_null rx2596_debug, debug_1511
    rx2596_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1511:
  rx2596_fail:
    (rx2596_rep, rx2596_pos, $I10, $P10) = rx2596_cur."!mark_fail"(0)
    lt rx2596_pos, -1, rx2596_done
    eq rx2596_pos, -1, rx2596_fail
    jump $I10
  rx2596_done:
    rx2596_cur."!cursor_fail"()
    if_null rx2596_debug, debug_1512
    rx2596_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1512:
    .return (rx2596_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("341_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2600 = self."!PREFIX__!subrule"("O", "*")
    new $P2601, "ResizablePMCArray"
    push $P2601, $P2600
    .return ($P2601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("342_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2603_tgt
    .local int rx2603_pos
    .local int rx2603_off
    .local int rx2603_eos
    .local int rx2603_rep
    .local pmc rx2603_cur
    .local pmc rx2603_debug
    (rx2603_cur, rx2603_pos, rx2603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2603_cur
    .local pmc match
    .lex "$/", match
    length rx2603_eos, rx2603_tgt
    gt rx2603_pos, rx2603_eos, rx2603_done
    set rx2603_off, 0
    lt rx2603_pos, 2, rx2603_start
    sub rx2603_off, rx2603_pos, 1
    substr rx2603_tgt, rx2603_tgt, rx2603_off
  rx2603_start:
    eq $I10, 1, rx2603_restart
    if_null rx2603_debug, debug_1513
    rx2603_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1513:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2604_done
    goto rxscan2604_scan
  rxscan2604_loop:
    (rx2603_pos) = rx2603_cur."from"()
    inc rx2603_pos
    rx2603_cur."!cursor_from"(rx2603_pos)
    ge rx2603_pos, rx2603_eos, rxscan2604_done
  rxscan2604_scan:
    set_addr $I10, rxscan2604_loop
    rx2603_cur."!mark_push"(0, rx2603_pos, $I10)
  rxscan2604_done:
.annotate 'line', 1101
  # rx subcapture "sym"
    set_addr $I10, rxcap_2605_fail
    rx2603_cur."!mark_push"(0, rx2603_pos, $I10)
  # rx literal  "/"
    add $I11, rx2603_pos, 1
    gt $I11, rx2603_eos, rx2603_fail
    sub $I11, rx2603_pos, rx2603_off
    ord $I11, rx2603_tgt, $I11
    ne $I11, 47, rx2603_fail
    add rx2603_pos, 1
    set_addr $I10, rxcap_2605_fail
    ($I12, $I11) = rx2603_cur."!mark_peek"($I10)
    rx2603_cur."!cursor_pos"($I11)
    ($P10) = rx2603_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2603_pos, "")
    rx2603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2605_done
  rxcap_2605_fail:
    goto rx2603_fail
  rxcap_2605_done:
  # rx subrule "O" subtype=capture negate=
    rx2603_cur."!cursor_pos"(rx2603_pos)
    $P10 = rx2603_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2603_fail
    rx2603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2603_pos = $P10."pos"()
  # rx pass
    rx2603_cur."!cursor_pass"(rx2603_pos, "infix:sym</>")
    if_null rx2603_debug, debug_1514
    rx2603_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2603_pos)
  debug_1514:
    .return (rx2603_cur)
  rx2603_restart:
.annotate 'line', 438
    if_null rx2603_debug, debug_1515
    rx2603_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1515:
  rx2603_fail:
    (rx2603_rep, rx2603_pos, $I10, $P10) = rx2603_cur."!mark_fail"(0)
    lt rx2603_pos, -1, rx2603_done
    eq rx2603_pos, -1, rx2603_fail
    jump $I10
  rx2603_done:
    rx2603_cur."!cursor_fail"()
    if_null rx2603_debug, debug_1516
    rx2603_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1516:
    .return (rx2603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("343_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2607 = self."!PREFIX__!subrule"("O", "/")
    new $P2608, "ResizablePMCArray"
    push $P2608, $P2607
    .return ($P2608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("344_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2610_tgt
    .local int rx2610_pos
    .local int rx2610_off
    .local int rx2610_eos
    .local int rx2610_rep
    .local pmc rx2610_cur
    .local pmc rx2610_debug
    (rx2610_cur, rx2610_pos, rx2610_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2610_cur
    .local pmc match
    .lex "$/", match
    length rx2610_eos, rx2610_tgt
    gt rx2610_pos, rx2610_eos, rx2610_done
    set rx2610_off, 0
    lt rx2610_pos, 2, rx2610_start
    sub rx2610_off, rx2610_pos, 1
    substr rx2610_tgt, rx2610_tgt, rx2610_off
  rx2610_start:
    eq $I10, 1, rx2610_restart
    if_null rx2610_debug, debug_1517
    rx2610_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1517:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2611_done
    goto rxscan2611_scan
  rxscan2611_loop:
    (rx2610_pos) = rx2610_cur."from"()
    inc rx2610_pos
    rx2610_cur."!cursor_from"(rx2610_pos)
    ge rx2610_pos, rx2610_eos, rxscan2611_done
  rxscan2611_scan:
    set_addr $I10, rxscan2611_loop
    rx2610_cur."!mark_push"(0, rx2610_pos, $I10)
  rxscan2611_done:
.annotate 'line', 1102
  # rx subcapture "sym"
    set_addr $I10, rxcap_2612_fail
    rx2610_cur."!mark_push"(0, rx2610_pos, $I10)
  # rx literal  "%"
    add $I11, rx2610_pos, 1
    gt $I11, rx2610_eos, rx2610_fail
    sub $I11, rx2610_pos, rx2610_off
    ord $I11, rx2610_tgt, $I11
    ne $I11, 37, rx2610_fail
    add rx2610_pos, 1
    set_addr $I10, rxcap_2612_fail
    ($I12, $I11) = rx2610_cur."!mark_peek"($I10)
    rx2610_cur."!cursor_pos"($I11)
    ($P10) = rx2610_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2610_pos, "")
    rx2610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2612_done
  rxcap_2612_fail:
    goto rx2610_fail
  rxcap_2612_done:
  # rx subrule "O" subtype=capture negate=
    rx2610_cur."!cursor_pos"(rx2610_pos)
    $P10 = rx2610_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2610_fail
    rx2610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2610_pos = $P10."pos"()
  # rx pass
    rx2610_cur."!cursor_pass"(rx2610_pos, "infix:sym<%>")
    if_null rx2610_debug, debug_1518
    rx2610_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2610_pos)
  debug_1518:
    .return (rx2610_cur)
  rx2610_restart:
.annotate 'line', 438
    if_null rx2610_debug, debug_1519
    rx2610_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1519:
  rx2610_fail:
    (rx2610_rep, rx2610_pos, $I10, $P10) = rx2610_cur."!mark_fail"(0)
    lt rx2610_pos, -1, rx2610_done
    eq rx2610_pos, -1, rx2610_fail
    jump $I10
  rx2610_done:
    rx2610_cur."!cursor_fail"()
    if_null rx2610_debug, debug_1520
    rx2610_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1520:
    .return (rx2610_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("345_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2614 = self."!PREFIX__!subrule"("O", "%")
    new $P2615, "ResizablePMCArray"
    push $P2615, $P2614
    .return ($P2615)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("346_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2617_tgt
    .local int rx2617_pos
    .local int rx2617_off
    .local int rx2617_eos
    .local int rx2617_rep
    .local pmc rx2617_cur
    .local pmc rx2617_debug
    (rx2617_cur, rx2617_pos, rx2617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2617_cur
    .local pmc match
    .lex "$/", match
    length rx2617_eos, rx2617_tgt
    gt rx2617_pos, rx2617_eos, rx2617_done
    set rx2617_off, 0
    lt rx2617_pos, 2, rx2617_start
    sub rx2617_off, rx2617_pos, 1
    substr rx2617_tgt, rx2617_tgt, rx2617_off
  rx2617_start:
    eq $I10, 1, rx2617_restart
    if_null rx2617_debug, debug_1521
    rx2617_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1521:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2618_done
    goto rxscan2618_scan
  rxscan2618_loop:
    (rx2617_pos) = rx2617_cur."from"()
    inc rx2617_pos
    rx2617_cur."!cursor_from"(rx2617_pos)
    ge rx2617_pos, rx2617_eos, rxscan2618_done
  rxscan2618_scan:
    set_addr $I10, rxscan2618_loop
    rx2617_cur."!mark_push"(0, rx2617_pos, $I10)
  rxscan2618_done:
.annotate 'line', 1103
  # rx subcapture "sym"
    set_addr $I10, rxcap_2619_fail
    rx2617_cur."!mark_push"(0, rx2617_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2617_pos, 2
    gt $I11, rx2617_eos, rx2617_fail
    sub $I11, rx2617_pos, rx2617_off
    substr $S10, rx2617_tgt, $I11, 2
    ne $S10, "+&", rx2617_fail
    add rx2617_pos, 2
    set_addr $I10, rxcap_2619_fail
    ($I12, $I11) = rx2617_cur."!mark_peek"($I10)
    rx2617_cur."!cursor_pos"($I11)
    ($P10) = rx2617_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2617_pos, "")
    rx2617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2619_done
  rxcap_2619_fail:
    goto rx2617_fail
  rxcap_2619_done:
  # rx subrule "O" subtype=capture negate=
    rx2617_cur."!cursor_pos"(rx2617_pos)
    $P10 = rx2617_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2617_fail
    rx2617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2617_pos = $P10."pos"()
  # rx pass
    rx2617_cur."!cursor_pass"(rx2617_pos, "infix:sym<+&>")
    if_null rx2617_debug, debug_1522
    rx2617_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2617_pos)
  debug_1522:
    .return (rx2617_cur)
  rx2617_restart:
.annotate 'line', 438
    if_null rx2617_debug, debug_1523
    rx2617_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1523:
  rx2617_fail:
    (rx2617_rep, rx2617_pos, $I10, $P10) = rx2617_cur."!mark_fail"(0)
    lt rx2617_pos, -1, rx2617_done
    eq rx2617_pos, -1, rx2617_fail
    jump $I10
  rx2617_done:
    rx2617_cur."!cursor_fail"()
    if_null rx2617_debug, debug_1524
    rx2617_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1524:
    .return (rx2617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("347_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2621 = self."!PREFIX__!subrule"("O", "+&")
    new $P2622, "ResizablePMCArray"
    push $P2622, $P2621
    .return ($P2622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("348_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2624_tgt
    .local int rx2624_pos
    .local int rx2624_off
    .local int rx2624_eos
    .local int rx2624_rep
    .local pmc rx2624_cur
    .local pmc rx2624_debug
    (rx2624_cur, rx2624_pos, rx2624_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2624_cur
    .local pmc match
    .lex "$/", match
    length rx2624_eos, rx2624_tgt
    gt rx2624_pos, rx2624_eos, rx2624_done
    set rx2624_off, 0
    lt rx2624_pos, 2, rx2624_start
    sub rx2624_off, rx2624_pos, 1
    substr rx2624_tgt, rx2624_tgt, rx2624_off
  rx2624_start:
    eq $I10, 1, rx2624_restart
    if_null rx2624_debug, debug_1525
    rx2624_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1525:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2625_done
    goto rxscan2625_scan
  rxscan2625_loop:
    (rx2624_pos) = rx2624_cur."from"()
    inc rx2624_pos
    rx2624_cur."!cursor_from"(rx2624_pos)
    ge rx2624_pos, rx2624_eos, rxscan2625_done
  rxscan2625_scan:
    set_addr $I10, rxscan2625_loop
    rx2624_cur."!mark_push"(0, rx2624_pos, $I10)
  rxscan2625_done:
.annotate 'line', 1105
  # rx subcapture "sym"
    set_addr $I10, rxcap_2626_fail
    rx2624_cur."!mark_push"(0, rx2624_pos, $I10)
  # rx literal  "+"
    add $I11, rx2624_pos, 1
    gt $I11, rx2624_eos, rx2624_fail
    sub $I11, rx2624_pos, rx2624_off
    ord $I11, rx2624_tgt, $I11
    ne $I11, 43, rx2624_fail
    add rx2624_pos, 1
    set_addr $I10, rxcap_2626_fail
    ($I12, $I11) = rx2624_cur."!mark_peek"($I10)
    rx2624_cur."!cursor_pos"($I11)
    ($P10) = rx2624_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2624_pos, "")
    rx2624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2626_done
  rxcap_2626_fail:
    goto rx2624_fail
  rxcap_2626_done:
  # rx subrule "O" subtype=capture negate=
    rx2624_cur."!cursor_pos"(rx2624_pos)
    $P10 = rx2624_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2624_fail
    rx2624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2624_pos = $P10."pos"()
  # rx pass
    rx2624_cur."!cursor_pass"(rx2624_pos, "infix:sym<+>")
    if_null rx2624_debug, debug_1526
    rx2624_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2624_pos)
  debug_1526:
    .return (rx2624_cur)
  rx2624_restart:
.annotate 'line', 438
    if_null rx2624_debug, debug_1527
    rx2624_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1527:
  rx2624_fail:
    (rx2624_rep, rx2624_pos, $I10, $P10) = rx2624_cur."!mark_fail"(0)
    lt rx2624_pos, -1, rx2624_done
    eq rx2624_pos, -1, rx2624_fail
    jump $I10
  rx2624_done:
    rx2624_cur."!cursor_fail"()
    if_null rx2624_debug, debug_1528
    rx2624_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1528:
    .return (rx2624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("349_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2628 = self."!PREFIX__!subrule"("O", "+")
    new $P2629, "ResizablePMCArray"
    push $P2629, $P2628
    .return ($P2629)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("350_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2631_tgt
    .local int rx2631_pos
    .local int rx2631_off
    .local int rx2631_eos
    .local int rx2631_rep
    .local pmc rx2631_cur
    .local pmc rx2631_debug
    (rx2631_cur, rx2631_pos, rx2631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2631_cur
    .local pmc match
    .lex "$/", match
    length rx2631_eos, rx2631_tgt
    gt rx2631_pos, rx2631_eos, rx2631_done
    set rx2631_off, 0
    lt rx2631_pos, 2, rx2631_start
    sub rx2631_off, rx2631_pos, 1
    substr rx2631_tgt, rx2631_tgt, rx2631_off
  rx2631_start:
    eq $I10, 1, rx2631_restart
    if_null rx2631_debug, debug_1529
    rx2631_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1529:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2632_done
    goto rxscan2632_scan
  rxscan2632_loop:
    (rx2631_pos) = rx2631_cur."from"()
    inc rx2631_pos
    rx2631_cur."!cursor_from"(rx2631_pos)
    ge rx2631_pos, rx2631_eos, rxscan2632_done
  rxscan2632_scan:
    set_addr $I10, rxscan2632_loop
    rx2631_cur."!mark_push"(0, rx2631_pos, $I10)
  rxscan2632_done:
.annotate 'line', 1106
  # rx subcapture "sym"
    set_addr $I10, rxcap_2633_fail
    rx2631_cur."!mark_push"(0, rx2631_pos, $I10)
  # rx literal  "-"
    add $I11, rx2631_pos, 1
    gt $I11, rx2631_eos, rx2631_fail
    sub $I11, rx2631_pos, rx2631_off
    ord $I11, rx2631_tgt, $I11
    ne $I11, 45, rx2631_fail
    add rx2631_pos, 1
    set_addr $I10, rxcap_2633_fail
    ($I12, $I11) = rx2631_cur."!mark_peek"($I10)
    rx2631_cur."!cursor_pos"($I11)
    ($P10) = rx2631_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2631_pos, "")
    rx2631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2633_done
  rxcap_2633_fail:
    goto rx2631_fail
  rxcap_2633_done:
  # rx subrule "O" subtype=capture negate=
    rx2631_cur."!cursor_pos"(rx2631_pos)
    $P10 = rx2631_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2631_fail
    rx2631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2631_pos = $P10."pos"()
  # rx pass
    rx2631_cur."!cursor_pass"(rx2631_pos, "infix:sym<->")
    if_null rx2631_debug, debug_1530
    rx2631_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2631_pos)
  debug_1530:
    .return (rx2631_cur)
  rx2631_restart:
.annotate 'line', 438
    if_null rx2631_debug, debug_1531
    rx2631_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1531:
  rx2631_fail:
    (rx2631_rep, rx2631_pos, $I10, $P10) = rx2631_cur."!mark_fail"(0)
    lt rx2631_pos, -1, rx2631_done
    eq rx2631_pos, -1, rx2631_fail
    jump $I10
  rx2631_done:
    rx2631_cur."!cursor_fail"()
    if_null rx2631_debug, debug_1532
    rx2631_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1532:
    .return (rx2631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("351_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2635 = self."!PREFIX__!subrule"("O", "-")
    new $P2636, "ResizablePMCArray"
    push $P2636, $P2635
    .return ($P2636)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("352_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2638_tgt
    .local int rx2638_pos
    .local int rx2638_off
    .local int rx2638_eos
    .local int rx2638_rep
    .local pmc rx2638_cur
    .local pmc rx2638_debug
    (rx2638_cur, rx2638_pos, rx2638_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2638_cur
    .local pmc match
    .lex "$/", match
    length rx2638_eos, rx2638_tgt
    gt rx2638_pos, rx2638_eos, rx2638_done
    set rx2638_off, 0
    lt rx2638_pos, 2, rx2638_start
    sub rx2638_off, rx2638_pos, 1
    substr rx2638_tgt, rx2638_tgt, rx2638_off
  rx2638_start:
    eq $I10, 1, rx2638_restart
    if_null rx2638_debug, debug_1533
    rx2638_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1533:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2639_done
    goto rxscan2639_scan
  rxscan2639_loop:
    (rx2638_pos) = rx2638_cur."from"()
    inc rx2638_pos
    rx2638_cur."!cursor_from"(rx2638_pos)
    ge rx2638_pos, rx2638_eos, rxscan2639_done
  rxscan2639_scan:
    set_addr $I10, rxscan2639_loop
    rx2638_cur."!mark_push"(0, rx2638_pos, $I10)
  rxscan2639_done:
.annotate 'line', 1107
  # rx subcapture "sym"
    set_addr $I10, rxcap_2640_fail
    rx2638_cur."!mark_push"(0, rx2638_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2638_pos, 2
    gt $I11, rx2638_eos, rx2638_fail
    sub $I11, rx2638_pos, rx2638_off
    substr $S10, rx2638_tgt, $I11, 2
    ne $S10, "+|", rx2638_fail
    add rx2638_pos, 2
    set_addr $I10, rxcap_2640_fail
    ($I12, $I11) = rx2638_cur."!mark_peek"($I10)
    rx2638_cur."!cursor_pos"($I11)
    ($P10) = rx2638_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2638_pos, "")
    rx2638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2640_done
  rxcap_2640_fail:
    goto rx2638_fail
  rxcap_2640_done:
  # rx subrule "O" subtype=capture negate=
    rx2638_cur."!cursor_pos"(rx2638_pos)
    $P10 = rx2638_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2638_fail
    rx2638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2638_pos = $P10."pos"()
  # rx pass
    rx2638_cur."!cursor_pass"(rx2638_pos, "infix:sym<+|>")
    if_null rx2638_debug, debug_1534
    rx2638_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2638_pos)
  debug_1534:
    .return (rx2638_cur)
  rx2638_restart:
.annotate 'line', 438
    if_null rx2638_debug, debug_1535
    rx2638_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1535:
  rx2638_fail:
    (rx2638_rep, rx2638_pos, $I10, $P10) = rx2638_cur."!mark_fail"(0)
    lt rx2638_pos, -1, rx2638_done
    eq rx2638_pos, -1, rx2638_fail
    jump $I10
  rx2638_done:
    rx2638_cur."!cursor_fail"()
    if_null rx2638_debug, debug_1536
    rx2638_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1536:
    .return (rx2638_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("353_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2642 = self."!PREFIX__!subrule"("O", "+|")
    new $P2643, "ResizablePMCArray"
    push $P2643, $P2642
    .return ($P2643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("354_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2645_tgt
    .local int rx2645_pos
    .local int rx2645_off
    .local int rx2645_eos
    .local int rx2645_rep
    .local pmc rx2645_cur
    .local pmc rx2645_debug
    (rx2645_cur, rx2645_pos, rx2645_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2645_cur
    .local pmc match
    .lex "$/", match
    length rx2645_eos, rx2645_tgt
    gt rx2645_pos, rx2645_eos, rx2645_done
    set rx2645_off, 0
    lt rx2645_pos, 2, rx2645_start
    sub rx2645_off, rx2645_pos, 1
    substr rx2645_tgt, rx2645_tgt, rx2645_off
  rx2645_start:
    eq $I10, 1, rx2645_restart
    if_null rx2645_debug, debug_1537
    rx2645_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1537:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2646_done
    goto rxscan2646_scan
  rxscan2646_loop:
    (rx2645_pos) = rx2645_cur."from"()
    inc rx2645_pos
    rx2645_cur."!cursor_from"(rx2645_pos)
    ge rx2645_pos, rx2645_eos, rxscan2646_done
  rxscan2646_scan:
    set_addr $I10, rxscan2646_loop
    rx2645_cur."!mark_push"(0, rx2645_pos, $I10)
  rxscan2646_done:
.annotate 'line', 1108
  # rx subcapture "sym"
    set_addr $I10, rxcap_2647_fail
    rx2645_cur."!mark_push"(0, rx2645_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2645_pos, 2
    gt $I11, rx2645_eos, rx2645_fail
    sub $I11, rx2645_pos, rx2645_off
    substr $S10, rx2645_tgt, $I11, 2
    ne $S10, "+^", rx2645_fail
    add rx2645_pos, 2
    set_addr $I10, rxcap_2647_fail
    ($I12, $I11) = rx2645_cur."!mark_peek"($I10)
    rx2645_cur."!cursor_pos"($I11)
    ($P10) = rx2645_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2645_pos, "")
    rx2645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2647_done
  rxcap_2647_fail:
    goto rx2645_fail
  rxcap_2647_done:
  # rx subrule "O" subtype=capture negate=
    rx2645_cur."!cursor_pos"(rx2645_pos)
    $P10 = rx2645_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2645_fail
    rx2645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2645_pos = $P10."pos"()
  # rx pass
    rx2645_cur."!cursor_pass"(rx2645_pos, "infix:sym<+^>")
    if_null rx2645_debug, debug_1538
    rx2645_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2645_pos)
  debug_1538:
    .return (rx2645_cur)
  rx2645_restart:
.annotate 'line', 438
    if_null rx2645_debug, debug_1539
    rx2645_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1539:
  rx2645_fail:
    (rx2645_rep, rx2645_pos, $I10, $P10) = rx2645_cur."!mark_fail"(0)
    lt rx2645_pos, -1, rx2645_done
    eq rx2645_pos, -1, rx2645_fail
    jump $I10
  rx2645_done:
    rx2645_cur."!cursor_fail"()
    if_null rx2645_debug, debug_1540
    rx2645_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1540:
    .return (rx2645_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("355_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2649 = self."!PREFIX__!subrule"("O", "+^")
    new $P2650, "ResizablePMCArray"
    push $P2650, $P2649
    .return ($P2650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("356_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2652_tgt
    .local int rx2652_pos
    .local int rx2652_off
    .local int rx2652_eos
    .local int rx2652_rep
    .local pmc rx2652_cur
    .local pmc rx2652_debug
    (rx2652_cur, rx2652_pos, rx2652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2652_cur
    .local pmc match
    .lex "$/", match
    length rx2652_eos, rx2652_tgt
    gt rx2652_pos, rx2652_eos, rx2652_done
    set rx2652_off, 0
    lt rx2652_pos, 2, rx2652_start
    sub rx2652_off, rx2652_pos, 1
    substr rx2652_tgt, rx2652_tgt, rx2652_off
  rx2652_start:
    eq $I10, 1, rx2652_restart
    if_null rx2652_debug, debug_1541
    rx2652_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1541:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2653_done
    goto rxscan2653_scan
  rxscan2653_loop:
    (rx2652_pos) = rx2652_cur."from"()
    inc rx2652_pos
    rx2652_cur."!cursor_from"(rx2652_pos)
    ge rx2652_pos, rx2652_eos, rxscan2653_done
  rxscan2653_scan:
    set_addr $I10, rxscan2653_loop
    rx2652_cur."!mark_push"(0, rx2652_pos, $I10)
  rxscan2653_done:
.annotate 'line', 1110
  # rx subcapture "sym"
    set_addr $I10, rxcap_2654_fail
    rx2652_cur."!mark_push"(0, rx2652_pos, $I10)
  # rx literal  "~"
    add $I11, rx2652_pos, 1
    gt $I11, rx2652_eos, rx2652_fail
    sub $I11, rx2652_pos, rx2652_off
    ord $I11, rx2652_tgt, $I11
    ne $I11, 126, rx2652_fail
    add rx2652_pos, 1
    set_addr $I10, rxcap_2654_fail
    ($I12, $I11) = rx2652_cur."!mark_peek"($I10)
    rx2652_cur."!cursor_pos"($I11)
    ($P10) = rx2652_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2652_pos, "")
    rx2652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2654_done
  rxcap_2654_fail:
    goto rx2652_fail
  rxcap_2654_done:
  # rx subrule "O" subtype=capture negate=
    rx2652_cur."!cursor_pos"(rx2652_pos)
    $P10 = rx2652_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2652_fail
    rx2652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2652_pos = $P10."pos"()
  # rx pass
    rx2652_cur."!cursor_pass"(rx2652_pos, "infix:sym<~>")
    if_null rx2652_debug, debug_1542
    rx2652_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2652_pos)
  debug_1542:
    .return (rx2652_cur)
  rx2652_restart:
.annotate 'line', 438
    if_null rx2652_debug, debug_1543
    rx2652_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1543:
  rx2652_fail:
    (rx2652_rep, rx2652_pos, $I10, $P10) = rx2652_cur."!mark_fail"(0)
    lt rx2652_pos, -1, rx2652_done
    eq rx2652_pos, -1, rx2652_fail
    jump $I10
  rx2652_done:
    rx2652_cur."!cursor_fail"()
    if_null rx2652_debug, debug_1544
    rx2652_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1544:
    .return (rx2652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("357_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2656 = self."!PREFIX__!subrule"("O", "~")
    new $P2657, "ResizablePMCArray"
    push $P2657, $P2656
    .return ($P2657)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("358_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2659_tgt
    .local int rx2659_pos
    .local int rx2659_off
    .local int rx2659_eos
    .local int rx2659_rep
    .local pmc rx2659_cur
    .local pmc rx2659_debug
    (rx2659_cur, rx2659_pos, rx2659_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2659_cur
    .local pmc match
    .lex "$/", match
    length rx2659_eos, rx2659_tgt
    gt rx2659_pos, rx2659_eos, rx2659_done
    set rx2659_off, 0
    lt rx2659_pos, 2, rx2659_start
    sub rx2659_off, rx2659_pos, 1
    substr rx2659_tgt, rx2659_tgt, rx2659_off
  rx2659_start:
    eq $I10, 1, rx2659_restart
    if_null rx2659_debug, debug_1545
    rx2659_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1545:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2660_done
    goto rxscan2660_scan
  rxscan2660_loop:
    (rx2659_pos) = rx2659_cur."from"()
    inc rx2659_pos
    rx2659_cur."!cursor_from"(rx2659_pos)
    ge rx2659_pos, rx2659_eos, rxscan2660_done
  rxscan2660_scan:
    set_addr $I10, rxscan2660_loop
    rx2659_cur."!mark_push"(0, rx2659_pos, $I10)
  rxscan2660_done:
.annotate 'line', 1112
  # rx subcapture "sym"
    set_addr $I10, rxcap_2661_fail
    rx2659_cur."!mark_push"(0, rx2659_pos, $I10)
  # rx literal  "=="
    add $I11, rx2659_pos, 2
    gt $I11, rx2659_eos, rx2659_fail
    sub $I11, rx2659_pos, rx2659_off
    substr $S10, rx2659_tgt, $I11, 2
    ne $S10, "==", rx2659_fail
    add rx2659_pos, 2
    set_addr $I10, rxcap_2661_fail
    ($I12, $I11) = rx2659_cur."!mark_peek"($I10)
    rx2659_cur."!cursor_pos"($I11)
    ($P10) = rx2659_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2659_pos, "")
    rx2659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2661_done
  rxcap_2661_fail:
    goto rx2659_fail
  rxcap_2661_done:
  # rx subrule "O" subtype=capture negate=
    rx2659_cur."!cursor_pos"(rx2659_pos)
    $P10 = rx2659_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2659_fail
    rx2659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2659_pos = $P10."pos"()
  # rx pass
    rx2659_cur."!cursor_pass"(rx2659_pos, "infix:sym<==>")
    if_null rx2659_debug, debug_1546
    rx2659_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2659_pos)
  debug_1546:
    .return (rx2659_cur)
  rx2659_restart:
.annotate 'line', 438
    if_null rx2659_debug, debug_1547
    rx2659_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1547:
  rx2659_fail:
    (rx2659_rep, rx2659_pos, $I10, $P10) = rx2659_cur."!mark_fail"(0)
    lt rx2659_pos, -1, rx2659_done
    eq rx2659_pos, -1, rx2659_fail
    jump $I10
  rx2659_done:
    rx2659_cur."!cursor_fail"()
    if_null rx2659_debug, debug_1548
    rx2659_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1548:
    .return (rx2659_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("359_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2663 = self."!PREFIX__!subrule"("O", "==")
    new $P2664, "ResizablePMCArray"
    push $P2664, $P2663
    .return ($P2664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("360_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2666_tgt
    .local int rx2666_pos
    .local int rx2666_off
    .local int rx2666_eos
    .local int rx2666_rep
    .local pmc rx2666_cur
    .local pmc rx2666_debug
    (rx2666_cur, rx2666_pos, rx2666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2666_cur
    .local pmc match
    .lex "$/", match
    length rx2666_eos, rx2666_tgt
    gt rx2666_pos, rx2666_eos, rx2666_done
    set rx2666_off, 0
    lt rx2666_pos, 2, rx2666_start
    sub rx2666_off, rx2666_pos, 1
    substr rx2666_tgt, rx2666_tgt, rx2666_off
  rx2666_start:
    eq $I10, 1, rx2666_restart
    if_null rx2666_debug, debug_1549
    rx2666_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1549:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2667_done
    goto rxscan2667_scan
  rxscan2667_loop:
    (rx2666_pos) = rx2666_cur."from"()
    inc rx2666_pos
    rx2666_cur."!cursor_from"(rx2666_pos)
    ge rx2666_pos, rx2666_eos, rxscan2667_done
  rxscan2667_scan:
    set_addr $I10, rxscan2667_loop
    rx2666_cur."!mark_push"(0, rx2666_pos, $I10)
  rxscan2667_done:
.annotate 'line', 1113
  # rx subcapture "sym"
    set_addr $I10, rxcap_2668_fail
    rx2666_cur."!mark_push"(0, rx2666_pos, $I10)
  # rx literal  "!="
    add $I11, rx2666_pos, 2
    gt $I11, rx2666_eos, rx2666_fail
    sub $I11, rx2666_pos, rx2666_off
    substr $S10, rx2666_tgt, $I11, 2
    ne $S10, "!=", rx2666_fail
    add rx2666_pos, 2
    set_addr $I10, rxcap_2668_fail
    ($I12, $I11) = rx2666_cur."!mark_peek"($I10)
    rx2666_cur."!cursor_pos"($I11)
    ($P10) = rx2666_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2666_pos, "")
    rx2666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2668_done
  rxcap_2668_fail:
    goto rx2666_fail
  rxcap_2668_done:
  # rx subrule "O" subtype=capture negate=
    rx2666_cur."!cursor_pos"(rx2666_pos)
    $P10 = rx2666_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2666_fail
    rx2666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2666_pos = $P10."pos"()
  # rx pass
    rx2666_cur."!cursor_pass"(rx2666_pos, "infix:sym<!=>")
    if_null rx2666_debug, debug_1550
    rx2666_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2666_pos)
  debug_1550:
    .return (rx2666_cur)
  rx2666_restart:
.annotate 'line', 438
    if_null rx2666_debug, debug_1551
    rx2666_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1551:
  rx2666_fail:
    (rx2666_rep, rx2666_pos, $I10, $P10) = rx2666_cur."!mark_fail"(0)
    lt rx2666_pos, -1, rx2666_done
    eq rx2666_pos, -1, rx2666_fail
    jump $I10
  rx2666_done:
    rx2666_cur."!cursor_fail"()
    if_null rx2666_debug, debug_1552
    rx2666_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1552:
    .return (rx2666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("361_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2670 = self."!PREFIX__!subrule"("O", "!=")
    new $P2671, "ResizablePMCArray"
    push $P2671, $P2670
    .return ($P2671)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("362_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2673_tgt
    .local int rx2673_pos
    .local int rx2673_off
    .local int rx2673_eos
    .local int rx2673_rep
    .local pmc rx2673_cur
    .local pmc rx2673_debug
    (rx2673_cur, rx2673_pos, rx2673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2673_cur
    .local pmc match
    .lex "$/", match
    length rx2673_eos, rx2673_tgt
    gt rx2673_pos, rx2673_eos, rx2673_done
    set rx2673_off, 0
    lt rx2673_pos, 2, rx2673_start
    sub rx2673_off, rx2673_pos, 1
    substr rx2673_tgt, rx2673_tgt, rx2673_off
  rx2673_start:
    eq $I10, 1, rx2673_restart
    if_null rx2673_debug, debug_1553
    rx2673_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1553:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2674_done
    goto rxscan2674_scan
  rxscan2674_loop:
    (rx2673_pos) = rx2673_cur."from"()
    inc rx2673_pos
    rx2673_cur."!cursor_from"(rx2673_pos)
    ge rx2673_pos, rx2673_eos, rxscan2674_done
  rxscan2674_scan:
    set_addr $I10, rxscan2674_loop
    rx2673_cur."!mark_push"(0, rx2673_pos, $I10)
  rxscan2674_done:
.annotate 'line', 1114
  # rx subcapture "sym"
    set_addr $I10, rxcap_2675_fail
    rx2673_cur."!mark_push"(0, rx2673_pos, $I10)
  # rx literal  "<="
    add $I11, rx2673_pos, 2
    gt $I11, rx2673_eos, rx2673_fail
    sub $I11, rx2673_pos, rx2673_off
    substr $S10, rx2673_tgt, $I11, 2
    ne $S10, "<=", rx2673_fail
    add rx2673_pos, 2
    set_addr $I10, rxcap_2675_fail
    ($I12, $I11) = rx2673_cur."!mark_peek"($I10)
    rx2673_cur."!cursor_pos"($I11)
    ($P10) = rx2673_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2673_pos, "")
    rx2673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2675_done
  rxcap_2675_fail:
    goto rx2673_fail
  rxcap_2675_done:
  # rx subrule "O" subtype=capture negate=
    rx2673_cur."!cursor_pos"(rx2673_pos)
    $P10 = rx2673_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2673_fail
    rx2673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2673_pos = $P10."pos"()
  # rx pass
    rx2673_cur."!cursor_pass"(rx2673_pos, "infix:sym<<=>")
    if_null rx2673_debug, debug_1554
    rx2673_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2673_pos)
  debug_1554:
    .return (rx2673_cur)
  rx2673_restart:
.annotate 'line', 438
    if_null rx2673_debug, debug_1555
    rx2673_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1555:
  rx2673_fail:
    (rx2673_rep, rx2673_pos, $I10, $P10) = rx2673_cur."!mark_fail"(0)
    lt rx2673_pos, -1, rx2673_done
    eq rx2673_pos, -1, rx2673_fail
    jump $I10
  rx2673_done:
    rx2673_cur."!cursor_fail"()
    if_null rx2673_debug, debug_1556
    rx2673_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1556:
    .return (rx2673_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("363_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2677 = self."!PREFIX__!subrule"("O", "<=")
    new $P2678, "ResizablePMCArray"
    push $P2678, $P2677
    .return ($P2678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("364_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2680_tgt
    .local int rx2680_pos
    .local int rx2680_off
    .local int rx2680_eos
    .local int rx2680_rep
    .local pmc rx2680_cur
    .local pmc rx2680_debug
    (rx2680_cur, rx2680_pos, rx2680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2680_cur
    .local pmc match
    .lex "$/", match
    length rx2680_eos, rx2680_tgt
    gt rx2680_pos, rx2680_eos, rx2680_done
    set rx2680_off, 0
    lt rx2680_pos, 2, rx2680_start
    sub rx2680_off, rx2680_pos, 1
    substr rx2680_tgt, rx2680_tgt, rx2680_off
  rx2680_start:
    eq $I10, 1, rx2680_restart
    if_null rx2680_debug, debug_1557
    rx2680_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1557:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2681_done
    goto rxscan2681_scan
  rxscan2681_loop:
    (rx2680_pos) = rx2680_cur."from"()
    inc rx2680_pos
    rx2680_cur."!cursor_from"(rx2680_pos)
    ge rx2680_pos, rx2680_eos, rxscan2681_done
  rxscan2681_scan:
    set_addr $I10, rxscan2681_loop
    rx2680_cur."!mark_push"(0, rx2680_pos, $I10)
  rxscan2681_done:
.annotate 'line', 1115
  # rx subcapture "sym"
    set_addr $I10, rxcap_2682_fail
    rx2680_cur."!mark_push"(0, rx2680_pos, $I10)
  # rx literal  ">="
    add $I11, rx2680_pos, 2
    gt $I11, rx2680_eos, rx2680_fail
    sub $I11, rx2680_pos, rx2680_off
    substr $S10, rx2680_tgt, $I11, 2
    ne $S10, ">=", rx2680_fail
    add rx2680_pos, 2
    set_addr $I10, rxcap_2682_fail
    ($I12, $I11) = rx2680_cur."!mark_peek"($I10)
    rx2680_cur."!cursor_pos"($I11)
    ($P10) = rx2680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2680_pos, "")
    rx2680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2682_done
  rxcap_2682_fail:
    goto rx2680_fail
  rxcap_2682_done:
  # rx subrule "O" subtype=capture negate=
    rx2680_cur."!cursor_pos"(rx2680_pos)
    $P10 = rx2680_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2680_fail
    rx2680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2680_pos = $P10."pos"()
  # rx pass
    rx2680_cur."!cursor_pass"(rx2680_pos, "infix:sym<>=>")
    if_null rx2680_debug, debug_1558
    rx2680_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2680_pos)
  debug_1558:
    .return (rx2680_cur)
  rx2680_restart:
.annotate 'line', 438
    if_null rx2680_debug, debug_1559
    rx2680_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1559:
  rx2680_fail:
    (rx2680_rep, rx2680_pos, $I10, $P10) = rx2680_cur."!mark_fail"(0)
    lt rx2680_pos, -1, rx2680_done
    eq rx2680_pos, -1, rx2680_fail
    jump $I10
  rx2680_done:
    rx2680_cur."!cursor_fail"()
    if_null rx2680_debug, debug_1560
    rx2680_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1560:
    .return (rx2680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("365_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2684 = self."!PREFIX__!subrule"("O", ">=")
    new $P2685, "ResizablePMCArray"
    push $P2685, $P2684
    .return ($P2685)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("366_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2687_tgt
    .local int rx2687_pos
    .local int rx2687_off
    .local int rx2687_eos
    .local int rx2687_rep
    .local pmc rx2687_cur
    .local pmc rx2687_debug
    (rx2687_cur, rx2687_pos, rx2687_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2687_cur
    .local pmc match
    .lex "$/", match
    length rx2687_eos, rx2687_tgt
    gt rx2687_pos, rx2687_eos, rx2687_done
    set rx2687_off, 0
    lt rx2687_pos, 2, rx2687_start
    sub rx2687_off, rx2687_pos, 1
    substr rx2687_tgt, rx2687_tgt, rx2687_off
  rx2687_start:
    eq $I10, 1, rx2687_restart
    if_null rx2687_debug, debug_1561
    rx2687_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1561:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2688_done
    goto rxscan2688_scan
  rxscan2688_loop:
    (rx2687_pos) = rx2687_cur."from"()
    inc rx2687_pos
    rx2687_cur."!cursor_from"(rx2687_pos)
    ge rx2687_pos, rx2687_eos, rxscan2688_done
  rxscan2688_scan:
    set_addr $I10, rxscan2688_loop
    rx2687_cur."!mark_push"(0, rx2687_pos, $I10)
  rxscan2688_done:
.annotate 'line', 1116
  # rx subcapture "sym"
    set_addr $I10, rxcap_2689_fail
    rx2687_cur."!mark_push"(0, rx2687_pos, $I10)
  # rx literal  "<"
    add $I11, rx2687_pos, 1
    gt $I11, rx2687_eos, rx2687_fail
    sub $I11, rx2687_pos, rx2687_off
    ord $I11, rx2687_tgt, $I11
    ne $I11, 60, rx2687_fail
    add rx2687_pos, 1
    set_addr $I10, rxcap_2689_fail
    ($I12, $I11) = rx2687_cur."!mark_peek"($I10)
    rx2687_cur."!cursor_pos"($I11)
    ($P10) = rx2687_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2687_pos, "")
    rx2687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2689_done
  rxcap_2689_fail:
    goto rx2687_fail
  rxcap_2689_done:
  # rx subrule "O" subtype=capture negate=
    rx2687_cur."!cursor_pos"(rx2687_pos)
    $P10 = rx2687_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2687_fail
    rx2687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2687_pos = $P10."pos"()
  # rx pass
    rx2687_cur."!cursor_pass"(rx2687_pos, "infix:sym<<>")
    if_null rx2687_debug, debug_1562
    rx2687_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2687_pos)
  debug_1562:
    .return (rx2687_cur)
  rx2687_restart:
.annotate 'line', 438
    if_null rx2687_debug, debug_1563
    rx2687_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1563:
  rx2687_fail:
    (rx2687_rep, rx2687_pos, $I10, $P10) = rx2687_cur."!mark_fail"(0)
    lt rx2687_pos, -1, rx2687_done
    eq rx2687_pos, -1, rx2687_fail
    jump $I10
  rx2687_done:
    rx2687_cur."!cursor_fail"()
    if_null rx2687_debug, debug_1564
    rx2687_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1564:
    .return (rx2687_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("367_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2691 = self."!PREFIX__!subrule"("O", "<")
    new $P2692, "ResizablePMCArray"
    push $P2692, $P2691
    .return ($P2692)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("368_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2694_tgt
    .local int rx2694_pos
    .local int rx2694_off
    .local int rx2694_eos
    .local int rx2694_rep
    .local pmc rx2694_cur
    .local pmc rx2694_debug
    (rx2694_cur, rx2694_pos, rx2694_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2694_cur
    .local pmc match
    .lex "$/", match
    length rx2694_eos, rx2694_tgt
    gt rx2694_pos, rx2694_eos, rx2694_done
    set rx2694_off, 0
    lt rx2694_pos, 2, rx2694_start
    sub rx2694_off, rx2694_pos, 1
    substr rx2694_tgt, rx2694_tgt, rx2694_off
  rx2694_start:
    eq $I10, 1, rx2694_restart
    if_null rx2694_debug, debug_1565
    rx2694_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1565:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2695_done
    goto rxscan2695_scan
  rxscan2695_loop:
    (rx2694_pos) = rx2694_cur."from"()
    inc rx2694_pos
    rx2694_cur."!cursor_from"(rx2694_pos)
    ge rx2694_pos, rx2694_eos, rxscan2695_done
  rxscan2695_scan:
    set_addr $I10, rxscan2695_loop
    rx2694_cur."!mark_push"(0, rx2694_pos, $I10)
  rxscan2695_done:
.annotate 'line', 1117
  # rx subcapture "sym"
    set_addr $I10, rxcap_2696_fail
    rx2694_cur."!mark_push"(0, rx2694_pos, $I10)
  # rx literal  ">"
    add $I11, rx2694_pos, 1
    gt $I11, rx2694_eos, rx2694_fail
    sub $I11, rx2694_pos, rx2694_off
    ord $I11, rx2694_tgt, $I11
    ne $I11, 62, rx2694_fail
    add rx2694_pos, 1
    set_addr $I10, rxcap_2696_fail
    ($I12, $I11) = rx2694_cur."!mark_peek"($I10)
    rx2694_cur."!cursor_pos"($I11)
    ($P10) = rx2694_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2694_pos, "")
    rx2694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2696_done
  rxcap_2696_fail:
    goto rx2694_fail
  rxcap_2696_done:
  # rx subrule "O" subtype=capture negate=
    rx2694_cur."!cursor_pos"(rx2694_pos)
    $P10 = rx2694_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2694_fail
    rx2694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2694_pos = $P10."pos"()
  # rx pass
    rx2694_cur."!cursor_pass"(rx2694_pos, "infix:sym<>>")
    if_null rx2694_debug, debug_1566
    rx2694_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2694_pos)
  debug_1566:
    .return (rx2694_cur)
  rx2694_restart:
.annotate 'line', 438
    if_null rx2694_debug, debug_1567
    rx2694_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1567:
  rx2694_fail:
    (rx2694_rep, rx2694_pos, $I10, $P10) = rx2694_cur."!mark_fail"(0)
    lt rx2694_pos, -1, rx2694_done
    eq rx2694_pos, -1, rx2694_fail
    jump $I10
  rx2694_done:
    rx2694_cur."!cursor_fail"()
    if_null rx2694_debug, debug_1568
    rx2694_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1568:
    .return (rx2694_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("369_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2698 = self."!PREFIX__!subrule"("O", ">")
    new $P2699, "ResizablePMCArray"
    push $P2699, $P2698
    .return ($P2699)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("370_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2701_tgt
    .local int rx2701_pos
    .local int rx2701_off
    .local int rx2701_eos
    .local int rx2701_rep
    .local pmc rx2701_cur
    .local pmc rx2701_debug
    (rx2701_cur, rx2701_pos, rx2701_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2701_cur
    .local pmc match
    .lex "$/", match
    length rx2701_eos, rx2701_tgt
    gt rx2701_pos, rx2701_eos, rx2701_done
    set rx2701_off, 0
    lt rx2701_pos, 2, rx2701_start
    sub rx2701_off, rx2701_pos, 1
    substr rx2701_tgt, rx2701_tgt, rx2701_off
  rx2701_start:
    eq $I10, 1, rx2701_restart
    if_null rx2701_debug, debug_1569
    rx2701_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1569:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2702_done
    goto rxscan2702_scan
  rxscan2702_loop:
    (rx2701_pos) = rx2701_cur."from"()
    inc rx2701_pos
    rx2701_cur."!cursor_from"(rx2701_pos)
    ge rx2701_pos, rx2701_eos, rxscan2702_done
  rxscan2702_scan:
    set_addr $I10, rxscan2702_loop
    rx2701_cur."!mark_push"(0, rx2701_pos, $I10)
  rxscan2702_done:
.annotate 'line', 1118
  # rx subcapture "sym"
    set_addr $I10, rxcap_2703_fail
    rx2701_cur."!mark_push"(0, rx2701_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2701_pos, 2
    gt $I11, rx2701_eos, rx2701_fail
    sub $I11, rx2701_pos, rx2701_off
    substr $S10, rx2701_tgt, $I11, 2
    ne $S10, "eq", rx2701_fail
    add rx2701_pos, 2
    set_addr $I10, rxcap_2703_fail
    ($I12, $I11) = rx2701_cur."!mark_peek"($I10)
    rx2701_cur."!cursor_pos"($I11)
    ($P10) = rx2701_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2701_pos, "")
    rx2701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2703_done
  rxcap_2703_fail:
    goto rx2701_fail
  rxcap_2703_done:
  # rx subrule "O" subtype=capture negate=
    rx2701_cur."!cursor_pos"(rx2701_pos)
    $P10 = rx2701_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2701_fail
    rx2701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2701_pos = $P10."pos"()
  # rx pass
    rx2701_cur."!cursor_pass"(rx2701_pos, "infix:sym<eq>")
    if_null rx2701_debug, debug_1570
    rx2701_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2701_pos)
  debug_1570:
    .return (rx2701_cur)
  rx2701_restart:
.annotate 'line', 438
    if_null rx2701_debug, debug_1571
    rx2701_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1571:
  rx2701_fail:
    (rx2701_rep, rx2701_pos, $I10, $P10) = rx2701_cur."!mark_fail"(0)
    lt rx2701_pos, -1, rx2701_done
    eq rx2701_pos, -1, rx2701_fail
    jump $I10
  rx2701_done:
    rx2701_cur."!cursor_fail"()
    if_null rx2701_debug, debug_1572
    rx2701_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1572:
    .return (rx2701_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("371_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2705 = self."!PREFIX__!subrule"("O", "eq")
    new $P2706, "ResizablePMCArray"
    push $P2706, $P2705
    .return ($P2706)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("372_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2708_tgt
    .local int rx2708_pos
    .local int rx2708_off
    .local int rx2708_eos
    .local int rx2708_rep
    .local pmc rx2708_cur
    .local pmc rx2708_debug
    (rx2708_cur, rx2708_pos, rx2708_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2708_cur
    .local pmc match
    .lex "$/", match
    length rx2708_eos, rx2708_tgt
    gt rx2708_pos, rx2708_eos, rx2708_done
    set rx2708_off, 0
    lt rx2708_pos, 2, rx2708_start
    sub rx2708_off, rx2708_pos, 1
    substr rx2708_tgt, rx2708_tgt, rx2708_off
  rx2708_start:
    eq $I10, 1, rx2708_restart
    if_null rx2708_debug, debug_1573
    rx2708_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1573:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2709_done
    goto rxscan2709_scan
  rxscan2709_loop:
    (rx2708_pos) = rx2708_cur."from"()
    inc rx2708_pos
    rx2708_cur."!cursor_from"(rx2708_pos)
    ge rx2708_pos, rx2708_eos, rxscan2709_done
  rxscan2709_scan:
    set_addr $I10, rxscan2709_loop
    rx2708_cur."!mark_push"(0, rx2708_pos, $I10)
  rxscan2709_done:
.annotate 'line', 1119
  # rx subcapture "sym"
    set_addr $I10, rxcap_2710_fail
    rx2708_cur."!mark_push"(0, rx2708_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2708_pos, 2
    gt $I11, rx2708_eos, rx2708_fail
    sub $I11, rx2708_pos, rx2708_off
    substr $S10, rx2708_tgt, $I11, 2
    ne $S10, "ne", rx2708_fail
    add rx2708_pos, 2
    set_addr $I10, rxcap_2710_fail
    ($I12, $I11) = rx2708_cur."!mark_peek"($I10)
    rx2708_cur."!cursor_pos"($I11)
    ($P10) = rx2708_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2708_pos, "")
    rx2708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2710_done
  rxcap_2710_fail:
    goto rx2708_fail
  rxcap_2710_done:
  # rx subrule "O" subtype=capture negate=
    rx2708_cur."!cursor_pos"(rx2708_pos)
    $P10 = rx2708_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2708_fail
    rx2708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2708_pos = $P10."pos"()
  # rx pass
    rx2708_cur."!cursor_pass"(rx2708_pos, "infix:sym<ne>")
    if_null rx2708_debug, debug_1574
    rx2708_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2708_pos)
  debug_1574:
    .return (rx2708_cur)
  rx2708_restart:
.annotate 'line', 438
    if_null rx2708_debug, debug_1575
    rx2708_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1575:
  rx2708_fail:
    (rx2708_rep, rx2708_pos, $I10, $P10) = rx2708_cur."!mark_fail"(0)
    lt rx2708_pos, -1, rx2708_done
    eq rx2708_pos, -1, rx2708_fail
    jump $I10
  rx2708_done:
    rx2708_cur."!cursor_fail"()
    if_null rx2708_debug, debug_1576
    rx2708_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1576:
    .return (rx2708_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("373_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2712 = self."!PREFIX__!subrule"("O", "ne")
    new $P2713, "ResizablePMCArray"
    push $P2713, $P2712
    .return ($P2713)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("374_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2715_tgt
    .local int rx2715_pos
    .local int rx2715_off
    .local int rx2715_eos
    .local int rx2715_rep
    .local pmc rx2715_cur
    .local pmc rx2715_debug
    (rx2715_cur, rx2715_pos, rx2715_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2715_cur
    .local pmc match
    .lex "$/", match
    length rx2715_eos, rx2715_tgt
    gt rx2715_pos, rx2715_eos, rx2715_done
    set rx2715_off, 0
    lt rx2715_pos, 2, rx2715_start
    sub rx2715_off, rx2715_pos, 1
    substr rx2715_tgt, rx2715_tgt, rx2715_off
  rx2715_start:
    eq $I10, 1, rx2715_restart
    if_null rx2715_debug, debug_1577
    rx2715_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1577:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2716_done
    goto rxscan2716_scan
  rxscan2716_loop:
    (rx2715_pos) = rx2715_cur."from"()
    inc rx2715_pos
    rx2715_cur."!cursor_from"(rx2715_pos)
    ge rx2715_pos, rx2715_eos, rxscan2716_done
  rxscan2716_scan:
    set_addr $I10, rxscan2716_loop
    rx2715_cur."!mark_push"(0, rx2715_pos, $I10)
  rxscan2716_done:
.annotate 'line', 1120
  # rx subcapture "sym"
    set_addr $I10, rxcap_2717_fail
    rx2715_cur."!mark_push"(0, rx2715_pos, $I10)
  # rx literal  "le"
    add $I11, rx2715_pos, 2
    gt $I11, rx2715_eos, rx2715_fail
    sub $I11, rx2715_pos, rx2715_off
    substr $S10, rx2715_tgt, $I11, 2
    ne $S10, "le", rx2715_fail
    add rx2715_pos, 2
    set_addr $I10, rxcap_2717_fail
    ($I12, $I11) = rx2715_cur."!mark_peek"($I10)
    rx2715_cur."!cursor_pos"($I11)
    ($P10) = rx2715_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2715_pos, "")
    rx2715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2717_done
  rxcap_2717_fail:
    goto rx2715_fail
  rxcap_2717_done:
  # rx subrule "O" subtype=capture negate=
    rx2715_cur."!cursor_pos"(rx2715_pos)
    $P10 = rx2715_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2715_fail
    rx2715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2715_pos = $P10."pos"()
  # rx pass
    rx2715_cur."!cursor_pass"(rx2715_pos, "infix:sym<le>")
    if_null rx2715_debug, debug_1578
    rx2715_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2715_pos)
  debug_1578:
    .return (rx2715_cur)
  rx2715_restart:
.annotate 'line', 438
    if_null rx2715_debug, debug_1579
    rx2715_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1579:
  rx2715_fail:
    (rx2715_rep, rx2715_pos, $I10, $P10) = rx2715_cur."!mark_fail"(0)
    lt rx2715_pos, -1, rx2715_done
    eq rx2715_pos, -1, rx2715_fail
    jump $I10
  rx2715_done:
    rx2715_cur."!cursor_fail"()
    if_null rx2715_debug, debug_1580
    rx2715_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1580:
    .return (rx2715_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("375_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2719 = self."!PREFIX__!subrule"("O", "le")
    new $P2720, "ResizablePMCArray"
    push $P2720, $P2719
    .return ($P2720)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("376_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2722_tgt
    .local int rx2722_pos
    .local int rx2722_off
    .local int rx2722_eos
    .local int rx2722_rep
    .local pmc rx2722_cur
    .local pmc rx2722_debug
    (rx2722_cur, rx2722_pos, rx2722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2722_cur
    .local pmc match
    .lex "$/", match
    length rx2722_eos, rx2722_tgt
    gt rx2722_pos, rx2722_eos, rx2722_done
    set rx2722_off, 0
    lt rx2722_pos, 2, rx2722_start
    sub rx2722_off, rx2722_pos, 1
    substr rx2722_tgt, rx2722_tgt, rx2722_off
  rx2722_start:
    eq $I10, 1, rx2722_restart
    if_null rx2722_debug, debug_1581
    rx2722_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1581:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2723_done
    goto rxscan2723_scan
  rxscan2723_loop:
    (rx2722_pos) = rx2722_cur."from"()
    inc rx2722_pos
    rx2722_cur."!cursor_from"(rx2722_pos)
    ge rx2722_pos, rx2722_eos, rxscan2723_done
  rxscan2723_scan:
    set_addr $I10, rxscan2723_loop
    rx2722_cur."!mark_push"(0, rx2722_pos, $I10)
  rxscan2723_done:
.annotate 'line', 1121
  # rx subcapture "sym"
    set_addr $I10, rxcap_2724_fail
    rx2722_cur."!mark_push"(0, rx2722_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2722_pos, 2
    gt $I11, rx2722_eos, rx2722_fail
    sub $I11, rx2722_pos, rx2722_off
    substr $S10, rx2722_tgt, $I11, 2
    ne $S10, "ge", rx2722_fail
    add rx2722_pos, 2
    set_addr $I10, rxcap_2724_fail
    ($I12, $I11) = rx2722_cur."!mark_peek"($I10)
    rx2722_cur."!cursor_pos"($I11)
    ($P10) = rx2722_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2722_pos, "")
    rx2722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2724_done
  rxcap_2724_fail:
    goto rx2722_fail
  rxcap_2724_done:
  # rx subrule "O" subtype=capture negate=
    rx2722_cur."!cursor_pos"(rx2722_pos)
    $P10 = rx2722_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2722_fail
    rx2722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2722_pos = $P10."pos"()
  # rx pass
    rx2722_cur."!cursor_pass"(rx2722_pos, "infix:sym<ge>")
    if_null rx2722_debug, debug_1582
    rx2722_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2722_pos)
  debug_1582:
    .return (rx2722_cur)
  rx2722_restart:
.annotate 'line', 438
    if_null rx2722_debug, debug_1583
    rx2722_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1583:
  rx2722_fail:
    (rx2722_rep, rx2722_pos, $I10, $P10) = rx2722_cur."!mark_fail"(0)
    lt rx2722_pos, -1, rx2722_done
    eq rx2722_pos, -1, rx2722_fail
    jump $I10
  rx2722_done:
    rx2722_cur."!cursor_fail"()
    if_null rx2722_debug, debug_1584
    rx2722_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1584:
    .return (rx2722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("377_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2726 = self."!PREFIX__!subrule"("O", "ge")
    new $P2727, "ResizablePMCArray"
    push $P2727, $P2726
    .return ($P2727)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("378_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2729_tgt
    .local int rx2729_pos
    .local int rx2729_off
    .local int rx2729_eos
    .local int rx2729_rep
    .local pmc rx2729_cur
    .local pmc rx2729_debug
    (rx2729_cur, rx2729_pos, rx2729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2729_cur
    .local pmc match
    .lex "$/", match
    length rx2729_eos, rx2729_tgt
    gt rx2729_pos, rx2729_eos, rx2729_done
    set rx2729_off, 0
    lt rx2729_pos, 2, rx2729_start
    sub rx2729_off, rx2729_pos, 1
    substr rx2729_tgt, rx2729_tgt, rx2729_off
  rx2729_start:
    eq $I10, 1, rx2729_restart
    if_null rx2729_debug, debug_1585
    rx2729_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1585:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2730_done
    goto rxscan2730_scan
  rxscan2730_loop:
    (rx2729_pos) = rx2729_cur."from"()
    inc rx2729_pos
    rx2729_cur."!cursor_from"(rx2729_pos)
    ge rx2729_pos, rx2729_eos, rxscan2730_done
  rxscan2730_scan:
    set_addr $I10, rxscan2730_loop
    rx2729_cur."!mark_push"(0, rx2729_pos, $I10)
  rxscan2730_done:
.annotate 'line', 1122
  # rx subcapture "sym"
    set_addr $I10, rxcap_2731_fail
    rx2729_cur."!mark_push"(0, rx2729_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2729_pos, 2
    gt $I11, rx2729_eos, rx2729_fail
    sub $I11, rx2729_pos, rx2729_off
    substr $S10, rx2729_tgt, $I11, 2
    ne $S10, "lt", rx2729_fail
    add rx2729_pos, 2
    set_addr $I10, rxcap_2731_fail
    ($I12, $I11) = rx2729_cur."!mark_peek"($I10)
    rx2729_cur."!cursor_pos"($I11)
    ($P10) = rx2729_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2729_pos, "")
    rx2729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2731_done
  rxcap_2731_fail:
    goto rx2729_fail
  rxcap_2731_done:
  # rx subrule "O" subtype=capture negate=
    rx2729_cur."!cursor_pos"(rx2729_pos)
    $P10 = rx2729_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2729_fail
    rx2729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2729_pos = $P10."pos"()
  # rx pass
    rx2729_cur."!cursor_pass"(rx2729_pos, "infix:sym<lt>")
    if_null rx2729_debug, debug_1586
    rx2729_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2729_pos)
  debug_1586:
    .return (rx2729_cur)
  rx2729_restart:
.annotate 'line', 438
    if_null rx2729_debug, debug_1587
    rx2729_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1587:
  rx2729_fail:
    (rx2729_rep, rx2729_pos, $I10, $P10) = rx2729_cur."!mark_fail"(0)
    lt rx2729_pos, -1, rx2729_done
    eq rx2729_pos, -1, rx2729_fail
    jump $I10
  rx2729_done:
    rx2729_cur."!cursor_fail"()
    if_null rx2729_debug, debug_1588
    rx2729_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1588:
    .return (rx2729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("379_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2733 = self."!PREFIX__!subrule"("O", "lt")
    new $P2734, "ResizablePMCArray"
    push $P2734, $P2733
    .return ($P2734)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("380_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2736_tgt
    .local int rx2736_pos
    .local int rx2736_off
    .local int rx2736_eos
    .local int rx2736_rep
    .local pmc rx2736_cur
    .local pmc rx2736_debug
    (rx2736_cur, rx2736_pos, rx2736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2736_cur
    .local pmc match
    .lex "$/", match
    length rx2736_eos, rx2736_tgt
    gt rx2736_pos, rx2736_eos, rx2736_done
    set rx2736_off, 0
    lt rx2736_pos, 2, rx2736_start
    sub rx2736_off, rx2736_pos, 1
    substr rx2736_tgt, rx2736_tgt, rx2736_off
  rx2736_start:
    eq $I10, 1, rx2736_restart
    if_null rx2736_debug, debug_1589
    rx2736_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1589:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2737_done
    goto rxscan2737_scan
  rxscan2737_loop:
    (rx2736_pos) = rx2736_cur."from"()
    inc rx2736_pos
    rx2736_cur."!cursor_from"(rx2736_pos)
    ge rx2736_pos, rx2736_eos, rxscan2737_done
  rxscan2737_scan:
    set_addr $I10, rxscan2737_loop
    rx2736_cur."!mark_push"(0, rx2736_pos, $I10)
  rxscan2737_done:
.annotate 'line', 1123
  # rx subcapture "sym"
    set_addr $I10, rxcap_2738_fail
    rx2736_cur."!mark_push"(0, rx2736_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2736_pos, 2
    gt $I11, rx2736_eos, rx2736_fail
    sub $I11, rx2736_pos, rx2736_off
    substr $S10, rx2736_tgt, $I11, 2
    ne $S10, "gt", rx2736_fail
    add rx2736_pos, 2
    set_addr $I10, rxcap_2738_fail
    ($I12, $I11) = rx2736_cur."!mark_peek"($I10)
    rx2736_cur."!cursor_pos"($I11)
    ($P10) = rx2736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2736_pos, "")
    rx2736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2738_done
  rxcap_2738_fail:
    goto rx2736_fail
  rxcap_2738_done:
  # rx subrule "O" subtype=capture negate=
    rx2736_cur."!cursor_pos"(rx2736_pos)
    $P10 = rx2736_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2736_fail
    rx2736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2736_pos = $P10."pos"()
  # rx pass
    rx2736_cur."!cursor_pass"(rx2736_pos, "infix:sym<gt>")
    if_null rx2736_debug, debug_1590
    rx2736_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2736_pos)
  debug_1590:
    .return (rx2736_cur)
  rx2736_restart:
.annotate 'line', 438
    if_null rx2736_debug, debug_1591
    rx2736_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1591:
  rx2736_fail:
    (rx2736_rep, rx2736_pos, $I10, $P10) = rx2736_cur."!mark_fail"(0)
    lt rx2736_pos, -1, rx2736_done
    eq rx2736_pos, -1, rx2736_fail
    jump $I10
  rx2736_done:
    rx2736_cur."!cursor_fail"()
    if_null rx2736_debug, debug_1592
    rx2736_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1592:
    .return (rx2736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("381_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2740 = self."!PREFIX__!subrule"("O", "gt")
    new $P2741, "ResizablePMCArray"
    push $P2741, $P2740
    .return ($P2741)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("382_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2743_tgt
    .local int rx2743_pos
    .local int rx2743_off
    .local int rx2743_eos
    .local int rx2743_rep
    .local pmc rx2743_cur
    .local pmc rx2743_debug
    (rx2743_cur, rx2743_pos, rx2743_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2743_cur
    .local pmc match
    .lex "$/", match
    length rx2743_eos, rx2743_tgt
    gt rx2743_pos, rx2743_eos, rx2743_done
    set rx2743_off, 0
    lt rx2743_pos, 2, rx2743_start
    sub rx2743_off, rx2743_pos, 1
    substr rx2743_tgt, rx2743_tgt, rx2743_off
  rx2743_start:
    eq $I10, 1, rx2743_restart
    if_null rx2743_debug, debug_1593
    rx2743_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1593:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2744_done
    goto rxscan2744_scan
  rxscan2744_loop:
    (rx2743_pos) = rx2743_cur."from"()
    inc rx2743_pos
    rx2743_cur."!cursor_from"(rx2743_pos)
    ge rx2743_pos, rx2743_eos, rxscan2744_done
  rxscan2744_scan:
    set_addr $I10, rxscan2744_loop
    rx2743_cur."!mark_push"(0, rx2743_pos, $I10)
  rxscan2744_done:
.annotate 'line', 1124
  # rx subcapture "sym"
    set_addr $I10, rxcap_2745_fail
    rx2743_cur."!mark_push"(0, rx2743_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2743_pos, 3
    gt $I11, rx2743_eos, rx2743_fail
    sub $I11, rx2743_pos, rx2743_off
    substr $S10, rx2743_tgt, $I11, 3
    ne $S10, "=:=", rx2743_fail
    add rx2743_pos, 3
    set_addr $I10, rxcap_2745_fail
    ($I12, $I11) = rx2743_cur."!mark_peek"($I10)
    rx2743_cur."!cursor_pos"($I11)
    ($P10) = rx2743_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2743_pos, "")
    rx2743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2745_done
  rxcap_2745_fail:
    goto rx2743_fail
  rxcap_2745_done:
  # rx subrule "O" subtype=capture negate=
    rx2743_cur."!cursor_pos"(rx2743_pos)
    $P10 = rx2743_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2743_fail
    rx2743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2743_pos = $P10."pos"()
  # rx pass
    rx2743_cur."!cursor_pass"(rx2743_pos, "infix:sym<=:=>")
    if_null rx2743_debug, debug_1594
    rx2743_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2743_pos)
  debug_1594:
    .return (rx2743_cur)
  rx2743_restart:
.annotate 'line', 438
    if_null rx2743_debug, debug_1595
    rx2743_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1595:
  rx2743_fail:
    (rx2743_rep, rx2743_pos, $I10, $P10) = rx2743_cur."!mark_fail"(0)
    lt rx2743_pos, -1, rx2743_done
    eq rx2743_pos, -1, rx2743_fail
    jump $I10
  rx2743_done:
    rx2743_cur."!cursor_fail"()
    if_null rx2743_debug, debug_1596
    rx2743_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1596:
    .return (rx2743_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("383_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2747 = self."!PREFIX__!subrule"("O", "=:=")
    new $P2748, "ResizablePMCArray"
    push $P2748, $P2747
    .return ($P2748)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("384_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2750_tgt
    .local int rx2750_pos
    .local int rx2750_off
    .local int rx2750_eos
    .local int rx2750_rep
    .local pmc rx2750_cur
    .local pmc rx2750_debug
    (rx2750_cur, rx2750_pos, rx2750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2750_cur
    .local pmc match
    .lex "$/", match
    length rx2750_eos, rx2750_tgt
    gt rx2750_pos, rx2750_eos, rx2750_done
    set rx2750_off, 0
    lt rx2750_pos, 2, rx2750_start
    sub rx2750_off, rx2750_pos, 1
    substr rx2750_tgt, rx2750_tgt, rx2750_off
  rx2750_start:
    eq $I10, 1, rx2750_restart
    if_null rx2750_debug, debug_1597
    rx2750_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1597:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2751_done
    goto rxscan2751_scan
  rxscan2751_loop:
    (rx2750_pos) = rx2750_cur."from"()
    inc rx2750_pos
    rx2750_cur."!cursor_from"(rx2750_pos)
    ge rx2750_pos, rx2750_eos, rxscan2751_done
  rxscan2751_scan:
    set_addr $I10, rxscan2751_loop
    rx2750_cur."!mark_push"(0, rx2750_pos, $I10)
  rxscan2751_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2752_fail
    rx2750_cur."!mark_push"(0, rx2750_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2750_pos, 2
    gt $I11, rx2750_eos, rx2750_fail
    sub $I11, rx2750_pos, rx2750_off
    substr $S10, rx2750_tgt, $I11, 2
    ne $S10, "~~", rx2750_fail
    add rx2750_pos, 2
    set_addr $I10, rxcap_2752_fail
    ($I12, $I11) = rx2750_cur."!mark_peek"($I10)
    rx2750_cur."!cursor_pos"($I11)
    ($P10) = rx2750_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2750_pos, "")
    rx2750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2752_done
  rxcap_2752_fail:
    goto rx2750_fail
  rxcap_2752_done:
  # rx subrule "O" subtype=capture negate=
    rx2750_cur."!cursor_pos"(rx2750_pos)
    $P10 = rx2750_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2750_fail
    rx2750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2750_pos = $P10."pos"()
  # rx pass
    rx2750_cur."!cursor_pass"(rx2750_pos, "infix:sym<~~>")
    if_null rx2750_debug, debug_1598
    rx2750_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2750_pos)
  debug_1598:
    .return (rx2750_cur)
  rx2750_restart:
.annotate 'line', 438
    if_null rx2750_debug, debug_1599
    rx2750_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1599:
  rx2750_fail:
    (rx2750_rep, rx2750_pos, $I10, $P10) = rx2750_cur."!mark_fail"(0)
    lt rx2750_pos, -1, rx2750_done
    eq rx2750_pos, -1, rx2750_fail
    jump $I10
  rx2750_done:
    rx2750_cur."!cursor_fail"()
    if_null rx2750_debug, debug_1600
    rx2750_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1600:
    .return (rx2750_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("385_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2754 = self."!PREFIX__!subrule"("O", "~~")
    new $P2755, "ResizablePMCArray"
    push $P2755, $P2754
    .return ($P2755)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("386_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2757_tgt
    .local int rx2757_pos
    .local int rx2757_off
    .local int rx2757_eos
    .local int rx2757_rep
    .local pmc rx2757_cur
    .local pmc rx2757_debug
    (rx2757_cur, rx2757_pos, rx2757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2757_cur
    .local pmc match
    .lex "$/", match
    length rx2757_eos, rx2757_tgt
    gt rx2757_pos, rx2757_eos, rx2757_done
    set rx2757_off, 0
    lt rx2757_pos, 2, rx2757_start
    sub rx2757_off, rx2757_pos, 1
    substr rx2757_tgt, rx2757_tgt, rx2757_off
  rx2757_start:
    eq $I10, 1, rx2757_restart
    if_null rx2757_debug, debug_1601
    rx2757_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1601:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2758_done
    goto rxscan2758_scan
  rxscan2758_loop:
    (rx2757_pos) = rx2757_cur."from"()
    inc rx2757_pos
    rx2757_cur."!cursor_from"(rx2757_pos)
    ge rx2757_pos, rx2757_eos, rxscan2758_done
  rxscan2758_scan:
    set_addr $I10, rxscan2758_loop
    rx2757_cur."!mark_push"(0, rx2757_pos, $I10)
  rxscan2758_done:
.annotate 'line', 1127
  # rx subcapture "sym"
    set_addr $I10, rxcap_2759_fail
    rx2757_cur."!mark_push"(0, rx2757_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2757_pos, 2
    gt $I11, rx2757_eos, rx2757_fail
    sub $I11, rx2757_pos, rx2757_off
    substr $S10, rx2757_tgt, $I11, 2
    ne $S10, "&&", rx2757_fail
    add rx2757_pos, 2
    set_addr $I10, rxcap_2759_fail
    ($I12, $I11) = rx2757_cur."!mark_peek"($I10)
    rx2757_cur."!cursor_pos"($I11)
    ($P10) = rx2757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2757_pos, "")
    rx2757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2759_done
  rxcap_2759_fail:
    goto rx2757_fail
  rxcap_2759_done:
  # rx subrule "O" subtype=capture negate=
    rx2757_cur."!cursor_pos"(rx2757_pos)
    $P10 = rx2757_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2757_fail
    rx2757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2757_pos = $P10."pos"()
  # rx pass
    rx2757_cur."!cursor_pass"(rx2757_pos, "infix:sym<&&>")
    if_null rx2757_debug, debug_1602
    rx2757_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2757_pos)
  debug_1602:
    .return (rx2757_cur)
  rx2757_restart:
.annotate 'line', 438
    if_null rx2757_debug, debug_1603
    rx2757_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1603:
  rx2757_fail:
    (rx2757_rep, rx2757_pos, $I10, $P10) = rx2757_cur."!mark_fail"(0)
    lt rx2757_pos, -1, rx2757_done
    eq rx2757_pos, -1, rx2757_fail
    jump $I10
  rx2757_done:
    rx2757_cur."!cursor_fail"()
    if_null rx2757_debug, debug_1604
    rx2757_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1604:
    .return (rx2757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("387_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2761 = self."!PREFIX__!subrule"("O", "&&")
    new $P2762, "ResizablePMCArray"
    push $P2762, $P2761
    .return ($P2762)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("388_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2764_tgt
    .local int rx2764_pos
    .local int rx2764_off
    .local int rx2764_eos
    .local int rx2764_rep
    .local pmc rx2764_cur
    .local pmc rx2764_debug
    (rx2764_cur, rx2764_pos, rx2764_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2764_cur
    .local pmc match
    .lex "$/", match
    length rx2764_eos, rx2764_tgt
    gt rx2764_pos, rx2764_eos, rx2764_done
    set rx2764_off, 0
    lt rx2764_pos, 2, rx2764_start
    sub rx2764_off, rx2764_pos, 1
    substr rx2764_tgt, rx2764_tgt, rx2764_off
  rx2764_start:
    eq $I10, 1, rx2764_restart
    if_null rx2764_debug, debug_1605
    rx2764_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1605:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2765_done
    goto rxscan2765_scan
  rxscan2765_loop:
    (rx2764_pos) = rx2764_cur."from"()
    inc rx2764_pos
    rx2764_cur."!cursor_from"(rx2764_pos)
    ge rx2764_pos, rx2764_eos, rxscan2765_done
  rxscan2765_scan:
    set_addr $I10, rxscan2765_loop
    rx2764_cur."!mark_push"(0, rx2764_pos, $I10)
  rxscan2765_done:
.annotate 'line', 1129
  # rx subcapture "sym"
    set_addr $I10, rxcap_2766_fail
    rx2764_cur."!mark_push"(0, rx2764_pos, $I10)
  # rx literal  "||"
    add $I11, rx2764_pos, 2
    gt $I11, rx2764_eos, rx2764_fail
    sub $I11, rx2764_pos, rx2764_off
    substr $S10, rx2764_tgt, $I11, 2
    ne $S10, "||", rx2764_fail
    add rx2764_pos, 2
    set_addr $I10, rxcap_2766_fail
    ($I12, $I11) = rx2764_cur."!mark_peek"($I10)
    rx2764_cur."!cursor_pos"($I11)
    ($P10) = rx2764_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2764_pos, "")
    rx2764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2766_done
  rxcap_2766_fail:
    goto rx2764_fail
  rxcap_2766_done:
  # rx subrule "O" subtype=capture negate=
    rx2764_cur."!cursor_pos"(rx2764_pos)
    $P10 = rx2764_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2764_fail
    rx2764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2764_pos = $P10."pos"()
  # rx pass
    rx2764_cur."!cursor_pass"(rx2764_pos, "infix:sym<||>")
    if_null rx2764_debug, debug_1606
    rx2764_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2764_pos)
  debug_1606:
    .return (rx2764_cur)
  rx2764_restart:
.annotate 'line', 438
    if_null rx2764_debug, debug_1607
    rx2764_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1607:
  rx2764_fail:
    (rx2764_rep, rx2764_pos, $I10, $P10) = rx2764_cur."!mark_fail"(0)
    lt rx2764_pos, -1, rx2764_done
    eq rx2764_pos, -1, rx2764_fail
    jump $I10
  rx2764_done:
    rx2764_cur."!cursor_fail"()
    if_null rx2764_debug, debug_1608
    rx2764_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1608:
    .return (rx2764_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("389_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2768 = self."!PREFIX__!subrule"("O", "||")
    new $P2769, "ResizablePMCArray"
    push $P2769, $P2768
    .return ($P2769)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("390_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2771_tgt
    .local int rx2771_pos
    .local int rx2771_off
    .local int rx2771_eos
    .local int rx2771_rep
    .local pmc rx2771_cur
    .local pmc rx2771_debug
    (rx2771_cur, rx2771_pos, rx2771_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2771_cur
    .local pmc match
    .lex "$/", match
    length rx2771_eos, rx2771_tgt
    gt rx2771_pos, rx2771_eos, rx2771_done
    set rx2771_off, 0
    lt rx2771_pos, 2, rx2771_start
    sub rx2771_off, rx2771_pos, 1
    substr rx2771_tgt, rx2771_tgt, rx2771_off
  rx2771_start:
    eq $I10, 1, rx2771_restart
    if_null rx2771_debug, debug_1609
    rx2771_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1609:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2772_done
    goto rxscan2772_scan
  rxscan2772_loop:
    (rx2771_pos) = rx2771_cur."from"()
    inc rx2771_pos
    rx2771_cur."!cursor_from"(rx2771_pos)
    ge rx2771_pos, rx2771_eos, rxscan2772_done
  rxscan2772_scan:
    set_addr $I10, rxscan2772_loop
    rx2771_cur."!mark_push"(0, rx2771_pos, $I10)
  rxscan2772_done:
.annotate 'line', 1130
  # rx subcapture "sym"
    set_addr $I10, rxcap_2773_fail
    rx2771_cur."!mark_push"(0, rx2771_pos, $I10)
  # rx literal  "//"
    add $I11, rx2771_pos, 2
    gt $I11, rx2771_eos, rx2771_fail
    sub $I11, rx2771_pos, rx2771_off
    substr $S10, rx2771_tgt, $I11, 2
    ne $S10, "//", rx2771_fail
    add rx2771_pos, 2
    set_addr $I10, rxcap_2773_fail
    ($I12, $I11) = rx2771_cur."!mark_peek"($I10)
    rx2771_cur."!cursor_pos"($I11)
    ($P10) = rx2771_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2771_pos, "")
    rx2771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2773_done
  rxcap_2773_fail:
    goto rx2771_fail
  rxcap_2773_done:
  # rx subrule "O" subtype=capture negate=
    rx2771_cur."!cursor_pos"(rx2771_pos)
    $P10 = rx2771_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2771_fail
    rx2771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2771_pos = $P10."pos"()
  # rx pass
    rx2771_cur."!cursor_pass"(rx2771_pos, "infix:sym<//>")
    if_null rx2771_debug, debug_1610
    rx2771_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2771_pos)
  debug_1610:
    .return (rx2771_cur)
  rx2771_restart:
.annotate 'line', 438
    if_null rx2771_debug, debug_1611
    rx2771_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1611:
  rx2771_fail:
    (rx2771_rep, rx2771_pos, $I10, $P10) = rx2771_cur."!mark_fail"(0)
    lt rx2771_pos, -1, rx2771_done
    eq rx2771_pos, -1, rx2771_fail
    jump $I10
  rx2771_done:
    rx2771_cur."!cursor_fail"()
    if_null rx2771_debug, debug_1612
    rx2771_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1612:
    .return (rx2771_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("391_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2775 = self."!PREFIX__!subrule"("O", "//")
    new $P2776, "ResizablePMCArray"
    push $P2776, $P2775
    .return ($P2776)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("392_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2778_tgt
    .local int rx2778_pos
    .local int rx2778_off
    .local int rx2778_eos
    .local int rx2778_rep
    .local pmc rx2778_cur
    .local pmc rx2778_debug
    (rx2778_cur, rx2778_pos, rx2778_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2778_cur
    .local pmc match
    .lex "$/", match
    length rx2778_eos, rx2778_tgt
    gt rx2778_pos, rx2778_eos, rx2778_done
    set rx2778_off, 0
    lt rx2778_pos, 2, rx2778_start
    sub rx2778_off, rx2778_pos, 1
    substr rx2778_tgt, rx2778_tgt, rx2778_off
  rx2778_start:
    eq $I10, 1, rx2778_restart
    if_null rx2778_debug, debug_1613
    rx2778_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1613:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2779_done
    goto rxscan2779_scan
  rxscan2779_loop:
    (rx2778_pos) = rx2778_cur."from"()
    inc rx2778_pos
    rx2778_cur."!cursor_from"(rx2778_pos)
    ge rx2778_pos, rx2778_eos, rxscan2779_done
  rxscan2779_scan:
    set_addr $I10, rxscan2779_loop
    rx2778_cur."!mark_push"(0, rx2778_pos, $I10)
  rxscan2779_done:
.annotate 'line', 1133
  # rx literal  "??"
    add $I11, rx2778_pos, 2
    gt $I11, rx2778_eos, rx2778_fail
    sub $I11, rx2778_pos, rx2778_off
    substr $S10, rx2778_tgt, $I11, 2
    ne $S10, "??", rx2778_fail
    add rx2778_pos, 2
.annotate 'line', 1134
  # rx subrule "ws" subtype=method negate=
    rx2778_cur."!cursor_pos"(rx2778_pos)
    $P10 = rx2778_cur."ws"()
    unless $P10, rx2778_fail
    rx2778_pos = $P10."pos"()
.annotate 'line', 1135
  # rx subrule "EXPR" subtype=capture negate=
    rx2778_cur."!cursor_pos"(rx2778_pos)
    $P10 = rx2778_cur."EXPR"("i=")
    unless $P10, rx2778_fail
    rx2778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2778_pos = $P10."pos"()
.annotate 'line', 1136
  # rx literal  "!!"
    add $I11, rx2778_pos, 2
    gt $I11, rx2778_eos, rx2778_fail
    sub $I11, rx2778_pos, rx2778_off
    substr $S10, rx2778_tgt, $I11, 2
    ne $S10, "!!", rx2778_fail
    add rx2778_pos, 2
.annotate 'line', 1137
  # rx subrule "O" subtype=capture negate=
    rx2778_cur."!cursor_pos"(rx2778_pos)
    $P10 = rx2778_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2778_fail
    rx2778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2778_pos = $P10."pos"()
.annotate 'line', 1132
  # rx pass
    rx2778_cur."!cursor_pass"(rx2778_pos, "infix:sym<?? !!>")
    if_null rx2778_debug, debug_1614
    rx2778_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2778_pos)
  debug_1614:
    .return (rx2778_cur)
  rx2778_restart:
.annotate 'line', 438
    if_null rx2778_debug, debug_1615
    rx2778_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1615:
  rx2778_fail:
    (rx2778_rep, rx2778_pos, $I10, $P10) = rx2778_cur."!mark_fail"(0)
    lt rx2778_pos, -1, rx2778_done
    eq rx2778_pos, -1, rx2778_fail
    jump $I10
  rx2778_done:
    rx2778_cur."!cursor_fail"()
    if_null rx2778_debug, debug_1616
    rx2778_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1616:
    .return (rx2778_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("393_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2781 = self."!PREFIX__!subrule"("ws", "??")
    new $P2782, "ResizablePMCArray"
    push $P2782, $P2781
    .return ($P2782)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("394_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2784_tgt
    .local int rx2784_pos
    .local int rx2784_off
    .local int rx2784_eos
    .local int rx2784_rep
    .local pmc rx2784_cur
    .local pmc rx2784_debug
    (rx2784_cur, rx2784_pos, rx2784_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2784_cur
    .local pmc match
    .lex "$/", match
    length rx2784_eos, rx2784_tgt
    gt rx2784_pos, rx2784_eos, rx2784_done
    set rx2784_off, 0
    lt rx2784_pos, 2, rx2784_start
    sub rx2784_off, rx2784_pos, 1
    substr rx2784_tgt, rx2784_tgt, rx2784_off
  rx2784_start:
    eq $I10, 1, rx2784_restart
    if_null rx2784_debug, debug_1617
    rx2784_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2785_done
    goto rxscan2785_scan
  rxscan2785_loop:
    (rx2784_pos) = rx2784_cur."from"()
    inc rx2784_pos
    rx2784_cur."!cursor_from"(rx2784_pos)
    ge rx2784_pos, rx2784_eos, rxscan2785_done
  rxscan2785_scan:
    set_addr $I10, rxscan2785_loop
    rx2784_cur."!mark_push"(0, rx2784_pos, $I10)
  rxscan2785_done:
.annotate 'line', 1141
  # rx subcapture "sym"
    set_addr $I10, rxcap_2786_fail
    rx2784_cur."!mark_push"(0, rx2784_pos, $I10)
  # rx literal  "="
    add $I11, rx2784_pos, 1
    gt $I11, rx2784_eos, rx2784_fail
    sub $I11, rx2784_pos, rx2784_off
    ord $I11, rx2784_tgt, $I11
    ne $I11, 61, rx2784_fail
    add rx2784_pos, 1
    set_addr $I10, rxcap_2786_fail
    ($I12, $I11) = rx2784_cur."!mark_peek"($I10)
    rx2784_cur."!cursor_pos"($I11)
    ($P10) = rx2784_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2784_pos, "")
    rx2784_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2786_done
  rxcap_2786_fail:
    goto rx2784_fail
  rxcap_2786_done:
  # rx subrule "panic" subtype=method negate=
    rx2784_cur."!cursor_pos"(rx2784_pos)
    $P10 = rx2784_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2784_fail
    rx2784_pos = $P10."pos"()
.annotate 'line', 1140
  # rx pass
    rx2784_cur."!cursor_pass"(rx2784_pos, "infix:sym<=>")
    if_null rx2784_debug, debug_1618
    rx2784_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2784_pos)
  debug_1618:
    .return (rx2784_cur)
  rx2784_restart:
.annotate 'line', 438
    if_null rx2784_debug, debug_1619
    rx2784_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1619:
  rx2784_fail:
    (rx2784_rep, rx2784_pos, $I10, $P10) = rx2784_cur."!mark_fail"(0)
    lt rx2784_pos, -1, rx2784_done
    eq rx2784_pos, -1, rx2784_fail
    jump $I10
  rx2784_done:
    rx2784_cur."!cursor_fail"()
    if_null rx2784_debug, debug_1620
    rx2784_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1620:
    .return (rx2784_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("395_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2788 = self."!PREFIX__!subrule"("panic", "=")
    new $P2789, "ResizablePMCArray"
    push $P2789, $P2788
    .return ($P2789)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("396_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2791_tgt
    .local int rx2791_pos
    .local int rx2791_off
    .local int rx2791_eos
    .local int rx2791_rep
    .local pmc rx2791_cur
    .local pmc rx2791_debug
    (rx2791_cur, rx2791_pos, rx2791_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2791_cur
    .local pmc match
    .lex "$/", match
    length rx2791_eos, rx2791_tgt
    gt rx2791_pos, rx2791_eos, rx2791_done
    set rx2791_off, 0
    lt rx2791_pos, 2, rx2791_start
    sub rx2791_off, rx2791_pos, 1
    substr rx2791_tgt, rx2791_tgt, rx2791_off
  rx2791_start:
    eq $I10, 1, rx2791_restart
    if_null rx2791_debug, debug_1621
    rx2791_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2792_done
    goto rxscan2792_scan
  rxscan2792_loop:
    (rx2791_pos) = rx2791_cur."from"()
    inc rx2791_pos
    rx2791_cur."!cursor_from"(rx2791_pos)
    ge rx2791_pos, rx2791_eos, rxscan2792_done
  rxscan2792_scan:
    set_addr $I10, rxscan2792_loop
    rx2791_cur."!mark_push"(0, rx2791_pos, $I10)
  rxscan2792_done:
.annotate 'line', 1143
  # rx subcapture "sym"
    set_addr $I10, rxcap_2793_fail
    rx2791_cur."!mark_push"(0, rx2791_pos, $I10)
  # rx literal  ":="
    add $I11, rx2791_pos, 2
    gt $I11, rx2791_eos, rx2791_fail
    sub $I11, rx2791_pos, rx2791_off
    substr $S10, rx2791_tgt, $I11, 2
    ne $S10, ":=", rx2791_fail
    add rx2791_pos, 2
    set_addr $I10, rxcap_2793_fail
    ($I12, $I11) = rx2791_cur."!mark_peek"($I10)
    rx2791_cur."!cursor_pos"($I11)
    ($P10) = rx2791_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2791_pos, "")
    rx2791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2793_done
  rxcap_2793_fail:
    goto rx2791_fail
  rxcap_2793_done:
  # rx subrule "O" subtype=capture negate=
    rx2791_cur."!cursor_pos"(rx2791_pos)
    $P10 = rx2791_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2791_fail
    rx2791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2791_pos = $P10."pos"()
  # rx pass
    rx2791_cur."!cursor_pass"(rx2791_pos, "infix:sym<:=>")
    if_null rx2791_debug, debug_1622
    rx2791_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2791_pos)
  debug_1622:
    .return (rx2791_cur)
  rx2791_restart:
.annotate 'line', 438
    if_null rx2791_debug, debug_1623
    rx2791_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1623:
  rx2791_fail:
    (rx2791_rep, rx2791_pos, $I10, $P10) = rx2791_cur."!mark_fail"(0)
    lt rx2791_pos, -1, rx2791_done
    eq rx2791_pos, -1, rx2791_fail
    jump $I10
  rx2791_done:
    rx2791_cur."!cursor_fail"()
    if_null rx2791_debug, debug_1624
    rx2791_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1624:
    .return (rx2791_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("397_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2795 = self."!PREFIX__!subrule"("O", ":=")
    new $P2796, "ResizablePMCArray"
    push $P2796, $P2795
    .return ($P2796)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("398_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2798_tgt
    .local int rx2798_pos
    .local int rx2798_off
    .local int rx2798_eos
    .local int rx2798_rep
    .local pmc rx2798_cur
    .local pmc rx2798_debug
    (rx2798_cur, rx2798_pos, rx2798_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2798_cur
    .local pmc match
    .lex "$/", match
    length rx2798_eos, rx2798_tgt
    gt rx2798_pos, rx2798_eos, rx2798_done
    set rx2798_off, 0
    lt rx2798_pos, 2, rx2798_start
    sub rx2798_off, rx2798_pos, 1
    substr rx2798_tgt, rx2798_tgt, rx2798_off
  rx2798_start:
    eq $I10, 1, rx2798_restart
    if_null rx2798_debug, debug_1625
    rx2798_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2799_done
    goto rxscan2799_scan
  rxscan2799_loop:
    (rx2798_pos) = rx2798_cur."from"()
    inc rx2798_pos
    rx2798_cur."!cursor_from"(rx2798_pos)
    ge rx2798_pos, rx2798_eos, rxscan2799_done
  rxscan2799_scan:
    set_addr $I10, rxscan2799_loop
    rx2798_cur."!mark_push"(0, rx2798_pos, $I10)
  rxscan2799_done:
.annotate 'line', 1144
  # rx subcapture "sym"
    set_addr $I10, rxcap_2800_fail
    rx2798_cur."!mark_push"(0, rx2798_pos, $I10)
  # rx literal  "::="
    add $I11, rx2798_pos, 3
    gt $I11, rx2798_eos, rx2798_fail
    sub $I11, rx2798_pos, rx2798_off
    substr $S10, rx2798_tgt, $I11, 3
    ne $S10, "::=", rx2798_fail
    add rx2798_pos, 3
    set_addr $I10, rxcap_2800_fail
    ($I12, $I11) = rx2798_cur."!mark_peek"($I10)
    rx2798_cur."!cursor_pos"($I11)
    ($P10) = rx2798_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2798_pos, "")
    rx2798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2800_done
  rxcap_2800_fail:
    goto rx2798_fail
  rxcap_2800_done:
  # rx subrule "O" subtype=capture negate=
    rx2798_cur."!cursor_pos"(rx2798_pos)
    $P10 = rx2798_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2798_fail
    rx2798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2798_pos = $P10."pos"()
  # rx pass
    rx2798_cur."!cursor_pass"(rx2798_pos, "infix:sym<::=>")
    if_null rx2798_debug, debug_1626
    rx2798_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2798_pos)
  debug_1626:
    .return (rx2798_cur)
  rx2798_restart:
.annotate 'line', 438
    if_null rx2798_debug, debug_1627
    rx2798_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1627:
  rx2798_fail:
    (rx2798_rep, rx2798_pos, $I10, $P10) = rx2798_cur."!mark_fail"(0)
    lt rx2798_pos, -1, rx2798_done
    eq rx2798_pos, -1, rx2798_fail
    jump $I10
  rx2798_done:
    rx2798_cur."!cursor_fail"()
    if_null rx2798_debug, debug_1628
    rx2798_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1628:
    .return (rx2798_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("399_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2802 = self."!PREFIX__!subrule"("O", "::=")
    new $P2803, "ResizablePMCArray"
    push $P2803, $P2802
    .return ($P2803)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("400_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2805_tgt
    .local int rx2805_pos
    .local int rx2805_off
    .local int rx2805_eos
    .local int rx2805_rep
    .local pmc rx2805_cur
    .local pmc rx2805_debug
    (rx2805_cur, rx2805_pos, rx2805_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2805_cur
    .local pmc match
    .lex "$/", match
    length rx2805_eos, rx2805_tgt
    gt rx2805_pos, rx2805_eos, rx2805_done
    set rx2805_off, 0
    lt rx2805_pos, 2, rx2805_start
    sub rx2805_off, rx2805_pos, 1
    substr rx2805_tgt, rx2805_tgt, rx2805_off
  rx2805_start:
    eq $I10, 1, rx2805_restart
    if_null rx2805_debug, debug_1629
    rx2805_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2806_done
    goto rxscan2806_scan
  rxscan2806_loop:
    (rx2805_pos) = rx2805_cur."from"()
    inc rx2805_pos
    rx2805_cur."!cursor_from"(rx2805_pos)
    ge rx2805_pos, rx2805_eos, rxscan2806_done
  rxscan2806_scan:
    set_addr $I10, rxscan2806_loop
    rx2805_cur."!mark_push"(0, rx2805_pos, $I10)
  rxscan2806_done:
.annotate 'line', 1146
  # rx subcapture "sym"
    set_addr $I10, rxcap_2807_fail
    rx2805_cur."!mark_push"(0, rx2805_pos, $I10)
  # rx literal  ","
    add $I11, rx2805_pos, 1
    gt $I11, rx2805_eos, rx2805_fail
    sub $I11, rx2805_pos, rx2805_off
    ord $I11, rx2805_tgt, $I11
    ne $I11, 44, rx2805_fail
    add rx2805_pos, 1
    set_addr $I10, rxcap_2807_fail
    ($I12, $I11) = rx2805_cur."!mark_peek"($I10)
    rx2805_cur."!cursor_pos"($I11)
    ($P10) = rx2805_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2805_pos, "")
    rx2805_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2807_done
  rxcap_2807_fail:
    goto rx2805_fail
  rxcap_2807_done:
  # rx subrule "O" subtype=capture negate=
    rx2805_cur."!cursor_pos"(rx2805_pos)
    $P10 = rx2805_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2805_fail
    rx2805_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2805_pos = $P10."pos"()
  # rx pass
    rx2805_cur."!cursor_pass"(rx2805_pos, "infix:sym<,>")
    if_null rx2805_debug, debug_1630
    rx2805_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2805_pos)
  debug_1630:
    .return (rx2805_cur)
  rx2805_restart:
.annotate 'line', 438
    if_null rx2805_debug, debug_1631
    rx2805_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1631:
  rx2805_fail:
    (rx2805_rep, rx2805_pos, $I10, $P10) = rx2805_cur."!mark_fail"(0)
    lt rx2805_pos, -1, rx2805_done
    eq rx2805_pos, -1, rx2805_fail
    jump $I10
  rx2805_done:
    rx2805_cur."!cursor_fail"()
    if_null rx2805_debug, debug_1632
    rx2805_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1632:
    .return (rx2805_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("401_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    $P2809 = self."!PREFIX__!subrule"("O", ",")
    new $P2810, "ResizablePMCArray"
    push $P2810, $P2809
    .return ($P2810)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("402_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .const 'Sub' $P2818 = "403_1305640955.436" 
    capture_lex $P2818
    .local string rx2812_tgt
    .local int rx2812_pos
    .local int rx2812_off
    .local int rx2812_eos
    .local int rx2812_rep
    .local pmc rx2812_cur
    .local pmc rx2812_debug
    (rx2812_cur, rx2812_pos, rx2812_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2812_cur
    .local pmc match
    .lex "$/", match
    length rx2812_eos, rx2812_tgt
    gt rx2812_pos, rx2812_eos, rx2812_done
    set rx2812_off, 0
    lt rx2812_pos, 2, rx2812_start
    sub rx2812_off, rx2812_pos, 1
    substr rx2812_tgt, rx2812_tgt, rx2812_off
  rx2812_start:
    eq $I10, 1, rx2812_restart
    if_null rx2812_debug, debug_1633
    rx2812_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1633:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2813_done
    goto rxscan2813_scan
  rxscan2813_loop:
    (rx2812_pos) = rx2812_cur."from"()
    inc rx2812_pos
    rx2812_cur."!cursor_from"(rx2812_pos)
    ge rx2812_pos, rx2812_eos, rxscan2813_done
  rxscan2813_scan:
    set_addr $I10, rxscan2813_loop
    rx2812_cur."!mark_push"(0, rx2812_pos, $I10)
  rxscan2813_done:
.annotate 'line', 1148
  # rx subcapture "sym"
    set_addr $I10, rxcap_2814_fail
    rx2812_cur."!mark_push"(0, rx2812_pos, $I10)
  # rx literal  "return"
    add $I11, rx2812_pos, 6
    gt $I11, rx2812_eos, rx2812_fail
    sub $I11, rx2812_pos, rx2812_off
    substr $S10, rx2812_tgt, $I11, 6
    ne $S10, "return", rx2812_fail
    add rx2812_pos, 6
    set_addr $I10, rxcap_2814_fail
    ($I12, $I11) = rx2812_cur."!mark_peek"($I10)
    rx2812_cur."!cursor_pos"($I11)
    ($P10) = rx2812_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2812_pos, "")
    rx2812_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2814_done
  rxcap_2814_fail:
    goto rx2812_fail
  rxcap_2814_done:
  # rx charclass s
    ge rx2812_pos, rx2812_eos, rx2812_fail
    sub $I10, rx2812_pos, rx2812_off
    is_cclass $I11, 32, rx2812_tgt, $I10
    unless $I11, rx2812_fail
    inc rx2812_pos
  # rx subrule "O" subtype=capture negate=
    rx2812_cur."!cursor_pos"(rx2812_pos)
    $P10 = rx2812_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2812_fail
    rx2812_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2812_pos = $P10."pos"()
    rx2812_cur."!cursor_pos"(rx2812_pos)
    find_lex $P2815, unicode:"$\x{a2}"
    $P2816 = $P2815."MATCH"()
    store_lex "$/", $P2816
    .const 'Sub' $P2818 = "403_1305640955.436" 
    capture_lex $P2818
    $P2820 = $P2818()
  # rx pass
    rx2812_cur."!cursor_pass"(rx2812_pos, "prefix:sym<return>")
    if_null rx2812_debug, debug_1634
    rx2812_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2812_pos)
  debug_1634:
    .return (rx2812_cur)
  rx2812_restart:
.annotate 'line', 438
    if_null rx2812_debug, debug_1635
    rx2812_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1635:
  rx2812_fail:
    (rx2812_rep, rx2812_pos, $I10, $P10) = rx2812_cur."!mark_fail"(0)
    lt rx2812_pos, -1, rx2812_done
    eq rx2812_pos, -1, rx2812_fail
    jump $I10
  rx2812_done:
    rx2812_cur."!cursor_fail"()
    if_null rx2812_debug, debug_1636
    rx2812_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1636:
    .return (rx2812_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2817"  :anon :subid("403_1305640955.436") :outer("402_1305640955.436")
.annotate 'line', 1148
    new $P2819, "Integer"
    assign $P2819, 1
    store_dynamic_lex "$*RETURN_USED", $P2819
    .return ($P2819)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("404_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2822, "ResizablePMCArray"
    push $P2822, "return"
    .return ($P2822)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("405_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2824_tgt
    .local int rx2824_pos
    .local int rx2824_off
    .local int rx2824_eos
    .local int rx2824_rep
    .local pmc rx2824_cur
    .local pmc rx2824_debug
    (rx2824_cur, rx2824_pos, rx2824_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2824_cur
    .local pmc match
    .lex "$/", match
    length rx2824_eos, rx2824_tgt
    gt rx2824_pos, rx2824_eos, rx2824_done
    set rx2824_off, 0
    lt rx2824_pos, 2, rx2824_start
    sub rx2824_off, rx2824_pos, 1
    substr rx2824_tgt, rx2824_tgt, rx2824_off
  rx2824_start:
    eq $I10, 1, rx2824_restart
    if_null rx2824_debug, debug_1637
    rx2824_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2825_done
    goto rxscan2825_scan
  rxscan2825_loop:
    (rx2824_pos) = rx2824_cur."from"()
    inc rx2824_pos
    rx2824_cur."!cursor_from"(rx2824_pos)
    ge rx2824_pos, rx2824_eos, rxscan2825_done
  rxscan2825_scan:
    set_addr $I10, rxscan2825_loop
    rx2824_cur."!mark_push"(0, rx2824_pos, $I10)
  rxscan2825_done:
.annotate 'line', 1149
  # rx subcapture "sym"
    set_addr $I10, rxcap_2826_fail
    rx2824_cur."!mark_push"(0, rx2824_pos, $I10)
  # rx literal  "make"
    add $I11, rx2824_pos, 4
    gt $I11, rx2824_eos, rx2824_fail
    sub $I11, rx2824_pos, rx2824_off
    substr $S10, rx2824_tgt, $I11, 4
    ne $S10, "make", rx2824_fail
    add rx2824_pos, 4
    set_addr $I10, rxcap_2826_fail
    ($I12, $I11) = rx2824_cur."!mark_peek"($I10)
    rx2824_cur."!cursor_pos"($I11)
    ($P10) = rx2824_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2824_pos, "")
    rx2824_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2826_done
  rxcap_2826_fail:
    goto rx2824_fail
  rxcap_2826_done:
  # rx charclass s
    ge rx2824_pos, rx2824_eos, rx2824_fail
    sub $I10, rx2824_pos, rx2824_off
    is_cclass $I11, 32, rx2824_tgt, $I10
    unless $I11, rx2824_fail
    inc rx2824_pos
  # rx subrule "O" subtype=capture negate=
    rx2824_cur."!cursor_pos"(rx2824_pos)
    $P10 = rx2824_cur."O"("%list_prefix")
    unless $P10, rx2824_fail
    rx2824_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2824_pos = $P10."pos"()
  # rx pass
    rx2824_cur."!cursor_pass"(rx2824_pos, "prefix:sym<make>")
    if_null rx2824_debug, debug_1638
    rx2824_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2824_pos)
  debug_1638:
    .return (rx2824_cur)
  rx2824_restart:
.annotate 'line', 438
    if_null rx2824_debug, debug_1639
    rx2824_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1639:
  rx2824_fail:
    (rx2824_rep, rx2824_pos, $I10, $P10) = rx2824_cur."!mark_fail"(0)
    lt rx2824_pos, -1, rx2824_done
    eq rx2824_pos, -1, rx2824_fail
    jump $I10
  rx2824_done:
    rx2824_cur."!cursor_fail"()
    if_null rx2824_debug, debug_1640
    rx2824_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1640:
    .return (rx2824_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("406_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2828, "ResizablePMCArray"
    push $P2828, "make"
    .return ($P2828)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("407_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2830_tgt
    .local int rx2830_pos
    .local int rx2830_off
    .local int rx2830_eos
    .local int rx2830_rep
    .local pmc rx2830_cur
    .local pmc rx2830_debug
    (rx2830_cur, rx2830_pos, rx2830_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2830_cur
    .local pmc match
    .lex "$/", match
    length rx2830_eos, rx2830_tgt
    gt rx2830_pos, rx2830_eos, rx2830_done
    set rx2830_off, 0
    lt rx2830_pos, 2, rx2830_start
    sub rx2830_off, rx2830_pos, 1
    substr rx2830_tgt, rx2830_tgt, rx2830_off
  rx2830_start:
    eq $I10, 1, rx2830_restart
    if_null rx2830_debug, debug_1641
    rx2830_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1641:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2831_done
    goto rxscan2831_scan
  rxscan2831_loop:
    (rx2830_pos) = rx2830_cur."from"()
    inc rx2830_pos
    rx2830_cur."!cursor_from"(rx2830_pos)
    ge rx2830_pos, rx2830_eos, rxscan2831_done
  rxscan2831_scan:
    set_addr $I10, rxscan2831_loop
    rx2830_cur."!mark_push"(0, rx2830_pos, $I10)
  rxscan2831_done:
.annotate 'line', 1150
  # rx subcapture "sym"
    set_addr $I10, rxcap_2832_fail
    rx2830_cur."!mark_push"(0, rx2830_pos, $I10)
  # rx literal  "last"
    add $I11, rx2830_pos, 4
    gt $I11, rx2830_eos, rx2830_fail
    sub $I11, rx2830_pos, rx2830_off
    substr $S10, rx2830_tgt, $I11, 4
    ne $S10, "last", rx2830_fail
    add rx2830_pos, 4
    set_addr $I10, rxcap_2832_fail
    ($I12, $I11) = rx2830_cur."!mark_peek"($I10)
    rx2830_cur."!cursor_pos"($I11)
    ($P10) = rx2830_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2830_pos, "")
    rx2830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2832_done
  rxcap_2832_fail:
    goto rx2830_fail
  rxcap_2832_done:
  # rx pass
    rx2830_cur."!cursor_pass"(rx2830_pos, "term:sym<last>")
    if_null rx2830_debug, debug_1642
    rx2830_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2830_pos)
  debug_1642:
    .return (rx2830_cur)
  rx2830_restart:
.annotate 'line', 438
    if_null rx2830_debug, debug_1643
    rx2830_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1643:
  rx2830_fail:
    (rx2830_rep, rx2830_pos, $I10, $P10) = rx2830_cur."!mark_fail"(0)
    lt rx2830_pos, -1, rx2830_done
    eq rx2830_pos, -1, rx2830_fail
    jump $I10
  rx2830_done:
    rx2830_cur."!cursor_fail"()
    if_null rx2830_debug, debug_1644
    rx2830_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1644:
    .return (rx2830_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("408_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2834, "ResizablePMCArray"
    push $P2834, "last"
    .return ($P2834)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("409_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2836_tgt
    .local int rx2836_pos
    .local int rx2836_off
    .local int rx2836_eos
    .local int rx2836_rep
    .local pmc rx2836_cur
    .local pmc rx2836_debug
    (rx2836_cur, rx2836_pos, rx2836_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2836_cur
    .local pmc match
    .lex "$/", match
    length rx2836_eos, rx2836_tgt
    gt rx2836_pos, rx2836_eos, rx2836_done
    set rx2836_off, 0
    lt rx2836_pos, 2, rx2836_start
    sub rx2836_off, rx2836_pos, 1
    substr rx2836_tgt, rx2836_tgt, rx2836_off
  rx2836_start:
    eq $I10, 1, rx2836_restart
    if_null rx2836_debug, debug_1645
    rx2836_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1645:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2837_done
    goto rxscan2837_scan
  rxscan2837_loop:
    (rx2836_pos) = rx2836_cur."from"()
    inc rx2836_pos
    rx2836_cur."!cursor_from"(rx2836_pos)
    ge rx2836_pos, rx2836_eos, rxscan2837_done
  rxscan2837_scan:
    set_addr $I10, rxscan2837_loop
    rx2836_cur."!mark_push"(0, rx2836_pos, $I10)
  rxscan2837_done:
.annotate 'line', 1151
  # rx subcapture "sym"
    set_addr $I10, rxcap_2838_fail
    rx2836_cur."!mark_push"(0, rx2836_pos, $I10)
  # rx literal  "next"
    add $I11, rx2836_pos, 4
    gt $I11, rx2836_eos, rx2836_fail
    sub $I11, rx2836_pos, rx2836_off
    substr $S10, rx2836_tgt, $I11, 4
    ne $S10, "next", rx2836_fail
    add rx2836_pos, 4
    set_addr $I10, rxcap_2838_fail
    ($I12, $I11) = rx2836_cur."!mark_peek"($I10)
    rx2836_cur."!cursor_pos"($I11)
    ($P10) = rx2836_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2836_pos, "")
    rx2836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2838_done
  rxcap_2838_fail:
    goto rx2836_fail
  rxcap_2838_done:
  # rx pass
    rx2836_cur."!cursor_pass"(rx2836_pos, "term:sym<next>")
    if_null rx2836_debug, debug_1646
    rx2836_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2836_pos)
  debug_1646:
    .return (rx2836_cur)
  rx2836_restart:
.annotate 'line', 438
    if_null rx2836_debug, debug_1647
    rx2836_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1647:
  rx2836_fail:
    (rx2836_rep, rx2836_pos, $I10, $P10) = rx2836_cur."!mark_fail"(0)
    lt rx2836_pos, -1, rx2836_done
    eq rx2836_pos, -1, rx2836_fail
    jump $I10
  rx2836_done:
    rx2836_cur."!cursor_fail"()
    if_null rx2836_debug, debug_1648
    rx2836_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1648:
    .return (rx2836_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("410_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2840, "ResizablePMCArray"
    push $P2840, "next"
    .return ($P2840)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("411_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    .local string rx2842_tgt
    .local int rx2842_pos
    .local int rx2842_off
    .local int rx2842_eos
    .local int rx2842_rep
    .local pmc rx2842_cur
    .local pmc rx2842_debug
    (rx2842_cur, rx2842_pos, rx2842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2842_cur
    .local pmc match
    .lex "$/", match
    length rx2842_eos, rx2842_tgt
    gt rx2842_pos, rx2842_eos, rx2842_done
    set rx2842_off, 0
    lt rx2842_pos, 2, rx2842_start
    sub rx2842_off, rx2842_pos, 1
    substr rx2842_tgt, rx2842_tgt, rx2842_off
  rx2842_start:
    eq $I10, 1, rx2842_restart
    if_null rx2842_debug, debug_1649
    rx2842_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1649:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2843_done
    goto rxscan2843_scan
  rxscan2843_loop:
    (rx2842_pos) = rx2842_cur."from"()
    inc rx2842_pos
    rx2842_cur."!cursor_from"(rx2842_pos)
    ge rx2842_pos, rx2842_eos, rxscan2843_done
  rxscan2843_scan:
    set_addr $I10, rxscan2843_loop
    rx2842_cur."!mark_push"(0, rx2842_pos, $I10)
  rxscan2843_done:
.annotate 'line', 1152
  # rx subcapture "sym"
    set_addr $I10, rxcap_2844_fail
    rx2842_cur."!mark_push"(0, rx2842_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2842_pos, 4
    gt $I11, rx2842_eos, rx2842_fail
    sub $I11, rx2842_pos, rx2842_off
    substr $S10, rx2842_tgt, $I11, 4
    ne $S10, "redo", rx2842_fail
    add rx2842_pos, 4
    set_addr $I10, rxcap_2844_fail
    ($I12, $I11) = rx2842_cur."!mark_peek"($I10)
    rx2842_cur."!cursor_pos"($I11)
    ($P10) = rx2842_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2842_pos, "")
    rx2842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2844_done
  rxcap_2844_fail:
    goto rx2842_fail
  rxcap_2844_done:
  # rx pass
    rx2842_cur."!cursor_pass"(rx2842_pos, "term:sym<redo>")
    if_null rx2842_debug, debug_1650
    rx2842_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2842_pos)
  debug_1650:
    .return (rx2842_cur)
  rx2842_restart:
.annotate 'line', 438
    if_null rx2842_debug, debug_1651
    rx2842_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1651:
  rx2842_fail:
    (rx2842_rep, rx2842_pos, $I10, $P10) = rx2842_cur."!mark_fail"(0)
    lt rx2842_pos, -1, rx2842_done
    eq rx2842_pos, -1, rx2842_fail
    jump $I10
  rx2842_done:
    rx2842_cur."!cursor_fail"()
    if_null rx2842_debug, debug_1652
    rx2842_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1652:
    .return (rx2842_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("412_1305640955.436") :method :outer("39_1305640955.436")
.annotate 'line', 438
    new $P2846, "ResizablePMCArray"
    push $P2846, "redo"
    .return ($P2846)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch" :anon :subid("413_1305640955.436") :outer("39_1305640955.436")
    .param pmc param_2848
    .param pmc param_2849
.annotate 'line', 1154
    .lex "self", param_2848
    .lex "$/", param_2849
.annotate 'line', 1156
    new $P2850, "Undef"
    .lex "$t", $P2850
    find_lex $P2851, "$/"
    unless_null $P2851, vivify_1653
    $P2851 = root_new ['parrot';'ResizablePMCArray']
  vivify_1653:
    set $P2852, $P2851[0]
    unless_null $P2852, vivify_1654
    new $P2852, "Undef"
  vivify_1654:
    store_lex "$t", $P2852
    find_lex $P2853, "$/"
    unless_null $P2853, vivify_1655
    $P2853 = root_new ['parrot';'ResizablePMCArray']
  vivify_1655:
    set $P2854, $P2853[1]
    unless_null $P2854, vivify_1656
    new $P2854, "Undef"
  vivify_1656:
    find_lex $P2855, "$/"
    unless_null $P2855, vivify_1657
    $P2855 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2855
  vivify_1657:
    set $P2855[0], $P2854
    find_lex $P2856, "$t"
    unless_null $P2856, vivify_1658
    new $P2856, "Undef"
  vivify_1658:
    find_lex $P2857, "$/"
    unless_null $P2857, vivify_1659
    $P2857 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2857
  vivify_1659:
    set $P2857[1], $P2856
.annotate 'line', 1154
    .return ($P2856)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2859"  :subid("414_1305640955.436") :outer("10_1305640955.436")
.annotate 'line', 1160
    .const 'Sub' $P2921 = "434_1305640955.436" 
    capture_lex $P2921
    .const 'Sub' $P2918 = "433_1305640955.436" 
    capture_lex $P2918
    .const 'Sub' $P2916 = "432_1305640955.436" 
    capture_lex $P2916
    .const 'Sub' $P2913 = "431_1305640955.436" 
    capture_lex $P2913
    .const 'Sub' $P2910 = "430_1305640955.436" 
    capture_lex $P2910
    .const 'Sub' $P2901 = "428_1305640955.436" 
    capture_lex $P2901
    .const 'Sub' $P2899 = "427_1305640955.436" 
    capture_lex $P2899
    .const 'Sub' $P2891 = "425_1305640955.436" 
    capture_lex $P2891
    .const 'Sub' $P2889 = "424_1305640955.436" 
    capture_lex $P2889
    .const 'Sub' $P2886 = "423_1305640955.436" 
    capture_lex $P2886
    .const 'Sub' $P2884 = "422_1305640955.436" 
    capture_lex $P2884
    .const 'Sub' $P2877 = "420_1305640955.436" 
    capture_lex $P2877
    .const 'Sub' $P2875 = "419_1305640955.436" 
    capture_lex $P2875
    .const 'Sub' $P2872 = "418_1305640955.436" 
    capture_lex $P2872
    .const 'Sub' $P2870 = "417_1305640955.436" 
    capture_lex $P2870
    .const 'Sub' $P2863 = "415_1305640955.436" 
    capture_lex $P2863
    .lex "$?PACKAGE", $P2861
    .lex "$?CLASS", $P2862
    .const 'Sub' $P2921 = "434_1305640955.436" 
    capture_lex $P2921
    .return ($P2921)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("415_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .const 'Sub' $P2867 = "416_1305640955.436" 
    capture_lex $P2867
    .local string rx2864_tgt
    .local int rx2864_pos
    .local int rx2864_off
    .local int rx2864_eos
    .local int rx2864_rep
    .local pmc rx2864_cur
    .local pmc rx2864_debug
    (rx2864_cur, rx2864_pos, rx2864_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2864_cur
    .local pmc match
    .lex "$/", match
    length rx2864_eos, rx2864_tgt
    gt rx2864_pos, rx2864_eos, rx2864_done
    set rx2864_off, 0
    lt rx2864_pos, 2, rx2864_start
    sub rx2864_off, rx2864_pos, 1
    substr rx2864_tgt, rx2864_tgt, rx2864_off
  rx2864_start:
    eq $I10, 1, rx2864_restart
    if_null rx2864_debug, debug_1660
    rx2864_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2865_done
    goto rxscan2865_scan
  rxscan2865_loop:
    (rx2864_pos) = rx2864_cur."from"()
    inc rx2864_pos
    rx2864_cur."!cursor_from"(rx2864_pos)
    ge rx2864_pos, rx2864_eos, rxscan2865_done
  rxscan2865_scan:
    set_addr $I10, rxscan2865_loop
    rx2864_cur."!mark_push"(0, rx2864_pos, $I10)
  rxscan2865_done:
.annotate 'line', 1162
  # rx literal  ":"
    add $I11, rx2864_pos, 1
    gt $I11, rx2864_eos, rx2864_fail
    sub $I11, rx2864_pos, rx2864_off
    ord $I11, rx2864_tgt, $I11
    ne $I11, 58, rx2864_fail
    add rx2864_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2864_cur."!cursor_pos"(rx2864_pos)
    .const 'Sub' $P2867 = "416_1305640955.436" 
    capture_lex $P2867
    $P10 = rx2864_cur."before"($P2867)
    unless $P10, rx2864_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2864_cur."!cursor_pos"(rx2864_pos)
    $P10 = rx2864_cur."LANG"("MAIN", "statement")
    unless $P10, rx2864_fail
    rx2864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2864_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2864_cur."!cursor_pos"(rx2864_pos)
    $P10 = rx2864_cur."ws"()
    unless $P10, rx2864_fail
    rx2864_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2864_pos, 1
    gt $I11, rx2864_eos, rx2864_fail
    sub $I11, rx2864_pos, rx2864_off
    ord $I11, rx2864_tgt, $I11
    ne $I11, 59, rx2864_fail
    add rx2864_pos, 1
.annotate 'line', 1161
  # rx pass
    rx2864_cur."!cursor_pass"(rx2864_pos, "metachar:sym<:my>")
    if_null rx2864_debug, debug_1665
    rx2864_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2864_pos)
  debug_1665:
    .return (rx2864_cur)
  rx2864_restart:
.annotate 'line', 1160
    if_null rx2864_debug, debug_1666
    rx2864_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1666:
  rx2864_fail:
    (rx2864_rep, rx2864_pos, $I10, $P10) = rx2864_cur."!mark_fail"(0)
    lt rx2864_pos, -1, rx2864_done
    eq rx2864_pos, -1, rx2864_fail
    jump $I10
  rx2864_done:
    rx2864_cur."!cursor_fail"()
    if_null rx2864_debug, debug_1667
    rx2864_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1667:
    .return (rx2864_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2866"  :anon :subid("416_1305640955.436") :method :outer("415_1305640955.436")
.annotate 'line', 1162
    .local string rx2868_tgt
    .local int rx2868_pos
    .local int rx2868_off
    .local int rx2868_eos
    .local int rx2868_rep
    .local pmc rx2868_cur
    .local pmc rx2868_debug
    (rx2868_cur, rx2868_pos, rx2868_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2868_cur
    .local pmc match
    .lex "$/", match
    length rx2868_eos, rx2868_tgt
    gt rx2868_pos, rx2868_eos, rx2868_done
    set rx2868_off, 0
    lt rx2868_pos, 2, rx2868_start
    sub rx2868_off, rx2868_pos, 1
    substr rx2868_tgt, rx2868_tgt, rx2868_off
  rx2868_start:
    eq $I10, 1, rx2868_restart
    if_null rx2868_debug, debug_1661
    rx2868_cur."!cursor_debug"("START", "")
  debug_1661:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2869_done
    goto rxscan2869_scan
  rxscan2869_loop:
    (rx2868_pos) = rx2868_cur."from"()
    inc rx2868_pos
    rx2868_cur."!cursor_from"(rx2868_pos)
    ge rx2868_pos, rx2868_eos, rxscan2869_done
  rxscan2869_scan:
    set_addr $I10, rxscan2869_loop
    rx2868_cur."!mark_push"(0, rx2868_pos, $I10)
  rxscan2869_done:
  # rx literal  "my"
    add $I11, rx2868_pos, 2
    gt $I11, rx2868_eos, rx2868_fail
    sub $I11, rx2868_pos, rx2868_off
    substr $S10, rx2868_tgt, $I11, 2
    ne $S10, "my", rx2868_fail
    add rx2868_pos, 2
  # rx pass
    rx2868_cur."!cursor_pass"(rx2868_pos, "")
    if_null rx2868_debug, debug_1662
    rx2868_cur."!cursor_debug"("PASS", "", " at pos=", rx2868_pos)
  debug_1662:
    .return (rx2868_cur)
  rx2868_restart:
    if_null rx2868_debug, debug_1663
    rx2868_cur."!cursor_debug"("NEXT", "")
  debug_1663:
  rx2868_fail:
    (rx2868_rep, rx2868_pos, $I10, $P10) = rx2868_cur."!mark_fail"(0)
    lt rx2868_pos, -1, rx2868_done
    eq rx2868_pos, -1, rx2868_fail
    jump $I10
  rx2868_done:
    rx2868_cur."!cursor_fail"()
    if_null rx2868_debug, debug_1664
    rx2868_cur."!cursor_debug"("FAIL", "")
  debug_1664:
    .return (rx2868_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("417_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    new $P2871, "ResizablePMCArray"
    push $P2871, ":"
    .return ($P2871)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("418_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .local string rx2873_tgt
    .local int rx2873_pos
    .local int rx2873_off
    .local int rx2873_eos
    .local int rx2873_rep
    .local pmc rx2873_cur
    .local pmc rx2873_debug
    (rx2873_cur, rx2873_pos, rx2873_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2873_cur
    .local pmc match
    .lex "$/", match
    length rx2873_eos, rx2873_tgt
    gt rx2873_pos, rx2873_eos, rx2873_done
    set rx2873_off, 0
    lt rx2873_pos, 2, rx2873_start
    sub rx2873_off, rx2873_pos, 1
    substr rx2873_tgt, rx2873_tgt, rx2873_off
  rx2873_start:
    eq $I10, 1, rx2873_restart
    if_null rx2873_debug, debug_1668
    rx2873_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2874_done
    goto rxscan2874_scan
  rxscan2874_loop:
    (rx2873_pos) = rx2873_cur."from"()
    inc rx2873_pos
    rx2873_cur."!cursor_from"(rx2873_pos)
    ge rx2873_pos, rx2873_eos, rxscan2874_done
  rxscan2874_scan:
    set_addr $I10, rxscan2874_loop
    rx2873_cur."!mark_push"(0, rx2873_pos, $I10)
  rxscan2874_done:
.annotate 'line', 1166
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2873_pos, rx2873_off
    substr $S10, rx2873_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2873_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2873_cur."!cursor_pos"(rx2873_pos)
    $P10 = rx2873_cur."codeblock"()
    unless $P10, rx2873_fail
    rx2873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2873_pos = $P10."pos"()
.annotate 'line', 1165
  # rx pass
    rx2873_cur."!cursor_pass"(rx2873_pos, "metachar:sym<{ }>")
    if_null rx2873_debug, debug_1669
    rx2873_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2873_pos)
  debug_1669:
    .return (rx2873_cur)
  rx2873_restart:
.annotate 'line', 1160
    if_null rx2873_debug, debug_1670
    rx2873_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1670:
  rx2873_fail:
    (rx2873_rep, rx2873_pos, $I10, $P10) = rx2873_cur."!mark_fail"(0)
    lt rx2873_pos, -1, rx2873_done
    eq rx2873_pos, -1, rx2873_fail
    jump $I10
  rx2873_done:
    rx2873_cur."!cursor_fail"()
    if_null rx2873_debug, debug_1671
    rx2873_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1671:
    .return (rx2873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("419_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    new $P2876, "ResizablePMCArray"
    push $P2876, "{"
    .return ($P2876)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("420_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .const 'Sub' $P2881 = "421_1305640955.436" 
    capture_lex $P2881
    .local string rx2878_tgt
    .local int rx2878_pos
    .local int rx2878_off
    .local int rx2878_eos
    .local int rx2878_rep
    .local pmc rx2878_cur
    .local pmc rx2878_debug
    (rx2878_cur, rx2878_pos, rx2878_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2878_cur
    .local pmc match
    .lex "$/", match
    length rx2878_eos, rx2878_tgt
    gt rx2878_pos, rx2878_eos, rx2878_done
    set rx2878_off, 0
    lt rx2878_pos, 2, rx2878_start
    sub rx2878_off, rx2878_pos, 1
    substr rx2878_tgt, rx2878_tgt, rx2878_off
  rx2878_start:
    eq $I10, 1, rx2878_restart
    if_null rx2878_debug, debug_1672
    rx2878_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2879_done
    goto rxscan2879_scan
  rxscan2879_loop:
    (rx2878_pos) = rx2878_cur."from"()
    inc rx2878_pos
    rx2878_cur."!cursor_from"(rx2878_pos)
    ge rx2878_pos, rx2878_eos, rxscan2879_done
  rxscan2879_scan:
    set_addr $I10, rxscan2879_loop
    rx2878_cur."!mark_push"(0, rx2878_pos, $I10)
  rxscan2879_done:
.annotate 'line', 1170
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2878_pos, rx2878_off
    substr $S10, rx2878_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2878_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2878_cur."!cursor_pos"(rx2878_pos)
    .const 'Sub' $P2881 = "421_1305640955.436" 
    capture_lex $P2881
    $P10 = rx2878_cur."before"($P2881)
    unless $P10, rx2878_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2878_cur."!cursor_pos"(rx2878_pos)
    $P10 = rx2878_cur."LANG"("MAIN", "variable")
    unless $P10, rx2878_fail
    rx2878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2878_pos = $P10."pos"()
.annotate 'line', 1169
  # rx pass
    rx2878_cur."!cursor_pass"(rx2878_pos, "metachar:sym<nqpvar>")
    if_null rx2878_debug, debug_1677
    rx2878_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2878_pos)
  debug_1677:
    .return (rx2878_cur)
  rx2878_restart:
.annotate 'line', 1160
    if_null rx2878_debug, debug_1678
    rx2878_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1678:
  rx2878_fail:
    (rx2878_rep, rx2878_pos, $I10, $P10) = rx2878_cur."!mark_fail"(0)
    lt rx2878_pos, -1, rx2878_done
    eq rx2878_pos, -1, rx2878_fail
    jump $I10
  rx2878_done:
    rx2878_cur."!cursor_fail"()
    if_null rx2878_debug, debug_1679
    rx2878_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1679:
    .return (rx2878_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2880"  :anon :subid("421_1305640955.436") :method :outer("420_1305640955.436")
.annotate 'line', 1170
    .local string rx2882_tgt
    .local int rx2882_pos
    .local int rx2882_off
    .local int rx2882_eos
    .local int rx2882_rep
    .local pmc rx2882_cur
    .local pmc rx2882_debug
    (rx2882_cur, rx2882_pos, rx2882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2882_cur
    .local pmc match
    .lex "$/", match
    length rx2882_eos, rx2882_tgt
    gt rx2882_pos, rx2882_eos, rx2882_done
    set rx2882_off, 0
    lt rx2882_pos, 2, rx2882_start
    sub rx2882_off, rx2882_pos, 1
    substr rx2882_tgt, rx2882_tgt, rx2882_off
  rx2882_start:
    eq $I10, 1, rx2882_restart
    if_null rx2882_debug, debug_1673
    rx2882_cur."!cursor_debug"("START", "")
  debug_1673:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2883_done
    goto rxscan2883_scan
  rxscan2883_loop:
    (rx2882_pos) = rx2882_cur."from"()
    inc rx2882_pos
    rx2882_cur."!cursor_from"(rx2882_pos)
    ge rx2882_pos, rx2882_eos, rxscan2883_done
  rxscan2883_scan:
    set_addr $I10, rxscan2883_loop
    rx2882_cur."!mark_push"(0, rx2882_pos, $I10)
  rxscan2883_done:
  # rx charclass .
    ge rx2882_pos, rx2882_eos, rx2882_fail
    inc rx2882_pos
  # rx charclass w
    ge rx2882_pos, rx2882_eos, rx2882_fail
    sub $I10, rx2882_pos, rx2882_off
    is_cclass $I11, 8192, rx2882_tgt, $I10
    unless $I11, rx2882_fail
    inc rx2882_pos
  # rx pass
    rx2882_cur."!cursor_pass"(rx2882_pos, "")
    if_null rx2882_debug, debug_1674
    rx2882_cur."!cursor_debug"("PASS", "", " at pos=", rx2882_pos)
  debug_1674:
    .return (rx2882_cur)
  rx2882_restart:
    if_null rx2882_debug, debug_1675
    rx2882_cur."!cursor_debug"("NEXT", "")
  debug_1675:
  rx2882_fail:
    (rx2882_rep, rx2882_pos, $I10, $P10) = rx2882_cur."!mark_fail"(0)
    lt rx2882_pos, -1, rx2882_done
    eq rx2882_pos, -1, rx2882_fail
    jump $I10
  rx2882_done:
    rx2882_cur."!cursor_fail"()
    if_null rx2882_debug, debug_1676
    rx2882_cur."!cursor_debug"("FAIL", "")
  debug_1676:
    .return (rx2882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("422_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    new $P2885, "ResizablePMCArray"
    push $P2885, "$"
    push $P2885, "@"
    .return ($P2885)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("423_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .local string rx2887_tgt
    .local int rx2887_pos
    .local int rx2887_off
    .local int rx2887_eos
    .local int rx2887_rep
    .local pmc rx2887_cur
    .local pmc rx2887_debug
    (rx2887_cur, rx2887_pos, rx2887_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2887_cur
    .local pmc match
    .lex "$/", match
    length rx2887_eos, rx2887_tgt
    gt rx2887_pos, rx2887_eos, rx2887_done
    set rx2887_off, 0
    lt rx2887_pos, 2, rx2887_start
    sub rx2887_off, rx2887_pos, 1
    substr rx2887_tgt, rx2887_tgt, rx2887_off
  rx2887_start:
    eq $I10, 1, rx2887_restart
    if_null rx2887_debug, debug_1680
    rx2887_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2888_done
    goto rxscan2888_scan
  rxscan2888_loop:
    (rx2887_pos) = rx2887_cur."from"()
    inc rx2887_pos
    rx2887_cur."!cursor_from"(rx2887_pos)
    ge rx2887_pos, rx2887_eos, rxscan2888_done
  rxscan2888_scan:
    set_addr $I10, rxscan2888_loop
    rx2887_cur."!mark_push"(0, rx2887_pos, $I10)
  rxscan2888_done:
.annotate 'line', 1174
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2887_pos, rx2887_off
    substr $S10, rx2887_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2887_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2887_cur."!cursor_pos"(rx2887_pos)
    $P10 = rx2887_cur."codeblock"()
    unless $P10, rx2887_fail
    rx2887_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2887_pos = $P10."pos"()
.annotate 'line', 1173
  # rx pass
    rx2887_cur."!cursor_pass"(rx2887_pos, "assertion:sym<{ }>")
    if_null rx2887_debug, debug_1681
    rx2887_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2887_pos)
  debug_1681:
    .return (rx2887_cur)
  rx2887_restart:
.annotate 'line', 1160
    if_null rx2887_debug, debug_1682
    rx2887_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1682:
  rx2887_fail:
    (rx2887_rep, rx2887_pos, $I10, $P10) = rx2887_cur."!mark_fail"(0)
    lt rx2887_pos, -1, rx2887_done
    eq rx2887_pos, -1, rx2887_fail
    jump $I10
  rx2887_done:
    rx2887_cur."!cursor_fail"()
    if_null rx2887_debug, debug_1683
    rx2887_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1683:
    .return (rx2887_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("424_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    new $P2890, "ResizablePMCArray"
    push $P2890, "{"
    .return ($P2890)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("425_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .const 'Sub' $P2895 = "426_1305640955.436" 
    capture_lex $P2895
    .local string rx2892_tgt
    .local int rx2892_pos
    .local int rx2892_off
    .local int rx2892_eos
    .local int rx2892_rep
    .local pmc rx2892_cur
    .local pmc rx2892_debug
    (rx2892_cur, rx2892_pos, rx2892_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2892_cur
    .local pmc match
    .lex "$/", match
    length rx2892_eos, rx2892_tgt
    gt rx2892_pos, rx2892_eos, rx2892_done
    set rx2892_off, 0
    lt rx2892_pos, 2, rx2892_start
    sub rx2892_off, rx2892_pos, 1
    substr rx2892_tgt, rx2892_tgt, rx2892_off
  rx2892_start:
    eq $I10, 1, rx2892_restart
    if_null rx2892_debug, debug_1684
    rx2892_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2893_done
    goto rxscan2893_scan
  rxscan2893_loop:
    (rx2892_pos) = rx2892_cur."from"()
    inc rx2892_pos
    rx2892_cur."!cursor_from"(rx2892_pos)
    ge rx2892_pos, rx2892_eos, rxscan2893_done
  rxscan2893_scan:
    set_addr $I10, rxscan2893_loop
    rx2892_cur."!mark_push"(0, rx2892_pos, $I10)
  rxscan2893_done:
.annotate 'line', 1178
  # rx subcapture "zw"
    set_addr $I10, rxcap_2898_fail
    rx2892_cur."!mark_push"(0, rx2892_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2892_pos, rx2892_eos, rx2892_fail
    sub $I10, rx2892_pos, rx2892_off
    substr $S10, rx2892_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2892_fail
    inc rx2892_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2892_cur."!cursor_pos"(rx2892_pos)
    .const 'Sub' $P2895 = "426_1305640955.436" 
    capture_lex $P2895
    $P10 = rx2892_cur."before"($P2895)
    unless $P10, rx2892_fail
    set_addr $I10, rxcap_2898_fail
    ($I12, $I11) = rx2892_cur."!mark_peek"($I10)
    rx2892_cur."!cursor_pos"($I11)
    ($P10) = rx2892_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2892_pos, "")
    rx2892_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2898_done
  rxcap_2898_fail:
    goto rx2892_fail
  rxcap_2898_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2892_cur."!cursor_pos"(rx2892_pos)
    $P10 = rx2892_cur."codeblock"()
    unless $P10, rx2892_fail
    rx2892_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2892_pos = $P10."pos"()
.annotate 'line', 1177
  # rx pass
    rx2892_cur."!cursor_pass"(rx2892_pos, "assertion:sym<?{ }>")
    if_null rx2892_debug, debug_1689
    rx2892_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2892_pos)
  debug_1689:
    .return (rx2892_cur)
  rx2892_restart:
.annotate 'line', 1160
    if_null rx2892_debug, debug_1690
    rx2892_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1690:
  rx2892_fail:
    (rx2892_rep, rx2892_pos, $I10, $P10) = rx2892_cur."!mark_fail"(0)
    lt rx2892_pos, -1, rx2892_done
    eq rx2892_pos, -1, rx2892_fail
    jump $I10
  rx2892_done:
    rx2892_cur."!cursor_fail"()
    if_null rx2892_debug, debug_1691
    rx2892_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1691:
    .return (rx2892_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2894"  :anon :subid("426_1305640955.436") :method :outer("425_1305640955.436")
.annotate 'line', 1178
    .local string rx2896_tgt
    .local int rx2896_pos
    .local int rx2896_off
    .local int rx2896_eos
    .local int rx2896_rep
    .local pmc rx2896_cur
    .local pmc rx2896_debug
    (rx2896_cur, rx2896_pos, rx2896_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2896_cur
    .local pmc match
    .lex "$/", match
    length rx2896_eos, rx2896_tgt
    gt rx2896_pos, rx2896_eos, rx2896_done
    set rx2896_off, 0
    lt rx2896_pos, 2, rx2896_start
    sub rx2896_off, rx2896_pos, 1
    substr rx2896_tgt, rx2896_tgt, rx2896_off
  rx2896_start:
    eq $I10, 1, rx2896_restart
    if_null rx2896_debug, debug_1685
    rx2896_cur."!cursor_debug"("START", "")
  debug_1685:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2897_done
    goto rxscan2897_scan
  rxscan2897_loop:
    (rx2896_pos) = rx2896_cur."from"()
    inc rx2896_pos
    rx2896_cur."!cursor_from"(rx2896_pos)
    ge rx2896_pos, rx2896_eos, rxscan2897_done
  rxscan2897_scan:
    set_addr $I10, rxscan2897_loop
    rx2896_cur."!mark_push"(0, rx2896_pos, $I10)
  rxscan2897_done:
  # rx literal  "{"
    add $I11, rx2896_pos, 1
    gt $I11, rx2896_eos, rx2896_fail
    sub $I11, rx2896_pos, rx2896_off
    ord $I11, rx2896_tgt, $I11
    ne $I11, 123, rx2896_fail
    add rx2896_pos, 1
  # rx pass
    rx2896_cur."!cursor_pass"(rx2896_pos, "")
    if_null rx2896_debug, debug_1686
    rx2896_cur."!cursor_debug"("PASS", "", " at pos=", rx2896_pos)
  debug_1686:
    .return (rx2896_cur)
  rx2896_restart:
    if_null rx2896_debug, debug_1687
    rx2896_cur."!cursor_debug"("NEXT", "")
  debug_1687:
  rx2896_fail:
    (rx2896_rep, rx2896_pos, $I10, $P10) = rx2896_cur."!mark_fail"(0)
    lt rx2896_pos, -1, rx2896_done
    eq rx2896_pos, -1, rx2896_fail
    jump $I10
  rx2896_done:
    rx2896_cur."!cursor_fail"()
    if_null rx2896_debug, debug_1688
    rx2896_cur."!cursor_debug"("FAIL", "")
  debug_1688:
    .return (rx2896_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("427_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    new $P2900, "ResizablePMCArray"
    push $P2900, "!"
    push $P2900, "?"
    .return ($P2900)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("428_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .const 'Sub' $P2907 = "429_1305640955.436" 
    capture_lex $P2907
    .local string rx2902_tgt
    .local int rx2902_pos
    .local int rx2902_off
    .local int rx2902_eos
    .local int rx2902_rep
    .local pmc rx2902_cur
    .local pmc rx2902_debug
    (rx2902_cur, rx2902_pos, rx2902_tgt, $I10) = self."!cursor_start"()
    rx2902_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2902_cur
    .local pmc match
    .lex "$/", match
    length rx2902_eos, rx2902_tgt
    gt rx2902_pos, rx2902_eos, rx2902_done
    set rx2902_off, 0
    lt rx2902_pos, 2, rx2902_start
    sub rx2902_off, rx2902_pos, 1
    substr rx2902_tgt, rx2902_tgt, rx2902_off
  rx2902_start:
    eq $I10, 1, rx2902_restart
    if_null rx2902_debug, debug_1692
    rx2902_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2903_done
    goto rxscan2903_scan
  rxscan2903_loop:
    (rx2902_pos) = rx2902_cur."from"()
    inc rx2902_pos
    rx2902_cur."!cursor_from"(rx2902_pos)
    ge rx2902_pos, rx2902_eos, rxscan2903_done
  rxscan2903_scan:
    set_addr $I10, rxscan2903_loop
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
  rxscan2903_done:
.annotate 'line', 1182
  # rx subrule "identifier" subtype=capture negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    $P10 = rx2902_cur."identifier"()
    unless $P10, rx2902_fail
    rx2902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2902_pos = $P10."pos"()
.annotate 'line', 1189
  # rx rxquantr2904 ** 0..1
    set_addr $I10, rxquantr2904_done
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
  rxquantr2904_loop:
  alt2905_0:
.annotate 'line', 1183
    set_addr $I10, alt2905_1
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
.annotate 'line', 1184
  # rx subrule "before" subtype=zerowidth negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    .const 'Sub' $P2907 = "429_1305640955.436" 
    capture_lex $P2907
    $P10 = rx2902_cur."before"($P2907)
    unless $P10, rx2902_fail
    goto alt2905_end
  alt2905_1:
    set_addr $I10, alt2905_2
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
.annotate 'line', 1185
  # rx literal  "="
    add $I11, rx2902_pos, 1
    gt $I11, rx2902_eos, rx2902_fail
    sub $I11, rx2902_pos, rx2902_off
    ord $I11, rx2902_tgt, $I11
    ne $I11, 61, rx2902_fail
    add rx2902_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    $P10 = rx2902_cur."assertion"()
    unless $P10, rx2902_fail
    rx2902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2902_pos = $P10."pos"()
    goto alt2905_end
  alt2905_2:
    set_addr $I10, alt2905_3
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
.annotate 'line', 1186
  # rx literal  ":"
    add $I11, rx2902_pos, 1
    gt $I11, rx2902_eos, rx2902_fail
    sub $I11, rx2902_pos, rx2902_off
    ord $I11, rx2902_tgt, $I11
    ne $I11, 58, rx2902_fail
    add rx2902_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    $P10 = rx2902_cur."arglist"()
    unless $P10, rx2902_fail
    rx2902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2902_pos = $P10."pos"()
    goto alt2905_end
  alt2905_3:
    set_addr $I10, alt2905_4
    rx2902_cur."!mark_push"(0, rx2902_pos, $I10)
.annotate 'line', 1187
  # rx literal  "("
    add $I11, rx2902_pos, 1
    gt $I11, rx2902_eos, rx2902_fail
    sub $I11, rx2902_pos, rx2902_off
    ord $I11, rx2902_tgt, $I11
    ne $I11, 40, rx2902_fail
    add rx2902_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    $P10 = rx2902_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2902_fail
    rx2902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2902_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2902_pos, 1
    gt $I11, rx2902_eos, rx2902_fail
    sub $I11, rx2902_pos, rx2902_off
    ord $I11, rx2902_tgt, $I11
    ne $I11, 41, rx2902_fail
    add rx2902_pos, 1
    goto alt2905_end
  alt2905_4:
.annotate 'line', 1188
  # rx subrule "normspace" subtype=method negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    $P10 = rx2902_cur."normspace"()
    unless $P10, rx2902_fail
    rx2902_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2902_cur."!cursor_pos"(rx2902_pos)
    $P10 = rx2902_cur."nibbler"()
    unless $P10, rx2902_fail
    rx2902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2902_pos = $P10."pos"()
  alt2905_end:
.annotate 'line', 1189
    set_addr $I10, rxquantr2904_done
    (rx2902_rep) = rx2902_cur."!mark_commit"($I10)
  rxquantr2904_done:
.annotate 'line', 1181
  # rx pass
    rx2902_cur."!cursor_pass"(rx2902_pos, "assertion:sym<name>")
    if_null rx2902_debug, debug_1697
    rx2902_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2902_pos)
  debug_1697:
    .return (rx2902_cur)
  rx2902_restart:
.annotate 'line', 1160
    if_null rx2902_debug, debug_1698
    rx2902_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1698:
  rx2902_fail:
    (rx2902_rep, rx2902_pos, $I10, $P10) = rx2902_cur."!mark_fail"(0)
    lt rx2902_pos, -1, rx2902_done
    eq rx2902_pos, -1, rx2902_fail
    jump $I10
  rx2902_done:
    rx2902_cur."!cursor_fail"()
    if_null rx2902_debug, debug_1699
    rx2902_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1699:
    .return (rx2902_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2906"  :anon :subid("429_1305640955.436") :method :outer("428_1305640955.436")
.annotate 'line', 1184
    .local string rx2908_tgt
    .local int rx2908_pos
    .local int rx2908_off
    .local int rx2908_eos
    .local int rx2908_rep
    .local pmc rx2908_cur
    .local pmc rx2908_debug
    (rx2908_cur, rx2908_pos, rx2908_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2908_cur
    .local pmc match
    .lex "$/", match
    length rx2908_eos, rx2908_tgt
    gt rx2908_pos, rx2908_eos, rx2908_done
    set rx2908_off, 0
    lt rx2908_pos, 2, rx2908_start
    sub rx2908_off, rx2908_pos, 1
    substr rx2908_tgt, rx2908_tgt, rx2908_off
  rx2908_start:
    eq $I10, 1, rx2908_restart
    if_null rx2908_debug, debug_1693
    rx2908_cur."!cursor_debug"("START", "")
  debug_1693:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2909_done
    goto rxscan2909_scan
  rxscan2909_loop:
    (rx2908_pos) = rx2908_cur."from"()
    inc rx2908_pos
    rx2908_cur."!cursor_from"(rx2908_pos)
    ge rx2908_pos, rx2908_eos, rxscan2909_done
  rxscan2909_scan:
    set_addr $I10, rxscan2909_loop
    rx2908_cur."!mark_push"(0, rx2908_pos, $I10)
  rxscan2909_done:
  # rx literal  ">"
    add $I11, rx2908_pos, 1
    gt $I11, rx2908_eos, rx2908_fail
    sub $I11, rx2908_pos, rx2908_off
    ord $I11, rx2908_tgt, $I11
    ne $I11, 62, rx2908_fail
    add rx2908_pos, 1
  # rx pass
    rx2908_cur."!cursor_pass"(rx2908_pos, "")
    if_null rx2908_debug, debug_1694
    rx2908_cur."!cursor_debug"("PASS", "", " at pos=", rx2908_pos)
  debug_1694:
    .return (rx2908_cur)
  rx2908_restart:
    if_null rx2908_debug, debug_1695
    rx2908_cur."!cursor_debug"("NEXT", "")
  debug_1695:
  rx2908_fail:
    (rx2908_rep, rx2908_pos, $I10, $P10) = rx2908_cur."!mark_fail"(0)
    lt rx2908_pos, -1, rx2908_done
    eq rx2908_pos, -1, rx2908_fail
    jump $I10
  rx2908_done:
    rx2908_cur."!cursor_fail"()
    if_null rx2908_debug, debug_1696
    rx2908_cur."!cursor_debug"("FAIL", "")
  debug_1696:
    .return (rx2908_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("430_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    $P2911 = self."!PREFIX__!subrule"("identifier", "")
    new $P2912, "ResizablePMCArray"
    push $P2912, $P2911
    .return ($P2912)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("431_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .local string rx2914_tgt
    .local int rx2914_pos
    .local int rx2914_off
    .local int rx2914_eos
    .local int rx2914_rep
    .local pmc rx2914_cur
    .local pmc rx2914_debug
    (rx2914_cur, rx2914_pos, rx2914_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2914_cur
    .local pmc match
    .lex "$/", match
    length rx2914_eos, rx2914_tgt
    gt rx2914_pos, rx2914_eos, rx2914_done
    set rx2914_off, 0
    lt rx2914_pos, 2, rx2914_start
    sub rx2914_off, rx2914_pos, 1
    substr rx2914_tgt, rx2914_tgt, rx2914_off
  rx2914_start:
    eq $I10, 1, rx2914_restart
    if_null rx2914_debug, debug_1700
    rx2914_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2915_done
    goto rxscan2915_scan
  rxscan2915_loop:
    (rx2914_pos) = rx2914_cur."from"()
    inc rx2914_pos
    rx2914_cur."!cursor_from"(rx2914_pos)
    ge rx2914_pos, rx2914_eos, rxscan2915_done
  rxscan2915_scan:
    set_addr $I10, rxscan2915_loop
    rx2914_cur."!mark_push"(0, rx2914_pos, $I10)
  rxscan2915_done:
.annotate 'line', 1193
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2914_pos, rx2914_off
    substr $S10, rx2914_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2914_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2914_cur."!cursor_pos"(rx2914_pos)
    $P10 = rx2914_cur."LANG"("MAIN", "variable")
    unless $P10, rx2914_fail
    rx2914_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2914_pos = $P10."pos"()
.annotate 'line', 1192
  # rx pass
    rx2914_cur."!cursor_pass"(rx2914_pos, "assertion:sym<var>")
    if_null rx2914_debug, debug_1701
    rx2914_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2914_pos)
  debug_1701:
    .return (rx2914_cur)
  rx2914_restart:
.annotate 'line', 1160
    if_null rx2914_debug, debug_1702
    rx2914_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1702:
  rx2914_fail:
    (rx2914_rep, rx2914_pos, $I10, $P10) = rx2914_cur."!mark_fail"(0)
    lt rx2914_pos, -1, rx2914_done
    eq rx2914_pos, -1, rx2914_fail
    jump $I10
  rx2914_done:
    rx2914_cur."!cursor_fail"()
    if_null rx2914_debug, debug_1703
    rx2914_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1703:
    .return (rx2914_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("432_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    new $P2917, "ResizablePMCArray"
    push $P2917, "$"
    push $P2917, "@"
    .return ($P2917)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("433_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    .local string rx2919_tgt
    .local int rx2919_pos
    .local int rx2919_off
    .local int rx2919_eos
    .local int rx2919_rep
    .local pmc rx2919_cur
    .local pmc rx2919_debug
    (rx2919_cur, rx2919_pos, rx2919_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2919_cur
    .local pmc match
    .lex "$/", match
    length rx2919_eos, rx2919_tgt
    gt rx2919_pos, rx2919_eos, rx2919_done
    set rx2919_off, 0
    lt rx2919_pos, 2, rx2919_start
    sub rx2919_off, rx2919_pos, 1
    substr rx2919_tgt, rx2919_tgt, rx2919_off
  rx2919_start:
    eq $I10, 1, rx2919_restart
    if_null rx2919_debug, debug_1704
    rx2919_cur."!cursor_debug"("START", "codeblock")
  debug_1704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2920_done
    goto rxscan2920_scan
  rxscan2920_loop:
    (rx2919_pos) = rx2919_cur."from"()
    inc rx2919_pos
    rx2919_cur."!cursor_from"(rx2919_pos)
    ge rx2919_pos, rx2919_eos, rxscan2920_done
  rxscan2920_scan:
    set_addr $I10, rxscan2920_loop
    rx2919_cur."!mark_push"(0, rx2919_pos, $I10)
  rxscan2920_done:
.annotate 'line', 1197
  # rx subrule "LANG" subtype=capture negate=
    rx2919_cur."!cursor_pos"(rx2919_pos)
    $P10 = rx2919_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2919_fail
    rx2919_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2919_pos = $P10."pos"()
.annotate 'line', 1196
  # rx pass
    rx2919_cur."!cursor_pass"(rx2919_pos, "codeblock")
    if_null rx2919_debug, debug_1705
    rx2919_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2919_pos)
  debug_1705:
    .return (rx2919_cur)
  rx2919_restart:
.annotate 'line', 1160
    if_null rx2919_debug, debug_1706
    rx2919_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1706:
  rx2919_fail:
    (rx2919_rep, rx2919_pos, $I10, $P10) = rx2919_cur."!mark_fail"(0)
    lt rx2919_pos, -1, rx2919_done
    eq rx2919_pos, -1, rx2919_fail
    jump $I10
  rx2919_done:
    rx2919_cur."!cursor_fail"()
    if_null rx2919_debug, debug_1707
    rx2919_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1707:
    .return (rx2919_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("434_1305640955.436") :method :outer("414_1305640955.436")
.annotate 'line', 1160
    $P2922 = self."!PREFIX__!subrule"("LANG", "")
    new $P2923, "ResizablePMCArray"
    push $P2923, $P2922
    .return ($P2923)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2924"  :subid("435_1305640955.436") :outer("10_1305640955.436")
.annotate 'line', 1203
    .const 'Sub' $P7133 = "612_1305640955.436" 
    capture_lex $P7133
    .const 'Sub' $P7118 = "611_1305640955.436" 
    capture_lex $P7118
    .const 'Sub' $P7113 = "610_1305640955.436" 
    capture_lex $P7113
    .const 'Sub' $P7108 = "609_1305640955.436" 
    capture_lex $P7108
    .const 'Sub' $P7103 = "608_1305640955.436" 
    capture_lex $P7103
    .const 'Sub' $P7086 = "607_1305640955.436" 
    capture_lex $P7086
    .const 'Sub' $P7075 = "606_1305640955.436" 
    capture_lex $P7075
    .const 'Sub' $P7064 = "605_1305640955.436" 
    capture_lex $P7064
    .const 'Sub' $P7056 = "604_1305640955.436" 
    capture_lex $P7056
    .const 'Sub' $P7051 = "603_1305640955.436" 
    capture_lex $P7051
    .const 'Sub' $P7036 = "602_1305640955.436" 
    capture_lex $P7036
    .const 'Sub' $P7028 = "601_1305640955.436" 
    capture_lex $P7028
    .const 'Sub' $P6970 = "600_1305640955.436" 
    capture_lex $P6970
    .const 'Sub' $P6955 = "599_1305640955.436" 
    capture_lex $P6955
    .const 'Sub' $P6947 = "598_1305640955.436" 
    capture_lex $P6947
    .const 'Sub' $P6939 = "597_1305640955.436" 
    capture_lex $P6939
    .const 'Sub' $P6931 = "596_1305640955.436" 
    capture_lex $P6931
    .const 'Sub' $P6923 = "595_1305640955.436" 
    capture_lex $P6923
    .const 'Sub' $P6915 = "594_1305640955.436" 
    capture_lex $P6915
    .const 'Sub' $P6886 = "593_1305640955.436" 
    capture_lex $P6886
    .const 'Sub' $P6871 = "592_1305640955.436" 
    capture_lex $P6871
    .const 'Sub' $P6863 = "591_1305640955.436" 
    capture_lex $P6863
    .const 'Sub' $P6849 = "590_1305640955.436" 
    capture_lex $P6849
    .const 'Sub' $P6835 = "589_1305640955.436" 
    capture_lex $P6835
    .const 'Sub' $P6821 = "588_1305640955.436" 
    capture_lex $P6821
    .const 'Sub' $P6813 = "587_1305640955.436" 
    capture_lex $P6813
    .const 'Sub' $P6783 = "586_1305640955.436" 
    capture_lex $P6783
    .const 'Sub' $P6745 = "584_1305640955.436" 
    capture_lex $P6745
    .const 'Sub' $P6737 = "583_1305640955.436" 
    capture_lex $P6737
    .const 'Sub' $P6729 = "582_1305640955.436" 
    capture_lex $P6729
    .const 'Sub' $P6698 = "581_1305640955.436" 
    capture_lex $P6698
    .const 'Sub' $P6679 = "580_1305640955.436" 
    capture_lex $P6679
    .const 'Sub' $P6671 = "579_1305640955.436" 
    capture_lex $P6671
    .const 'Sub' $P6663 = "578_1305640955.436" 
    capture_lex $P6663
    .const 'Sub' $P6555 = "575_1305640955.436" 
    capture_lex $P6555
    .const 'Sub' $P6547 = "574_1305640955.436" 
    capture_lex $P6547
    .const 'Sub' $P6537 = "573_1305640955.436" 
    capture_lex $P6537
    .const 'Sub' $P6503 = "572_1305640955.436" 
    capture_lex $P6503
    .const 'Sub' $P6461 = "570_1305640955.436" 
    capture_lex $P6461
    .const 'Sub' $P6447 = "569_1305640955.436" 
    capture_lex $P6447
    .const 'Sub' $P6437 = "568_1305640955.436" 
    capture_lex $P6437
    .const 'Sub' $P6385 = "567_1305640955.436" 
    capture_lex $P6385
    .const 'Sub' $P6156 = "562_1305640955.436" 
    capture_lex $P6156
    .const 'Sub' $P6038 = "557_1305640955.436" 
    capture_lex $P6038
    .const 'Sub' $P6030 = "556_1305640955.436" 
    capture_lex $P6030
    .const 'Sub' $P5986 = "554_1305640955.436" 
    capture_lex $P5986
    .const 'Sub' $P5971 = "553_1305640955.436" 
    capture_lex $P5971
    .const 'Sub' $P5948 = "552_1305640955.436" 
    capture_lex $P5948
    .const 'Sub' $P5845 = "551_1305640955.436" 
    capture_lex $P5845
    .const 'Sub' $P5791 = "548_1305640955.436" 
    capture_lex $P5791
    .const 'Sub' $P5649 = "545_1305640955.436" 
    capture_lex $P5649
    .const 'Sub' $P5322 = "538_1305640955.436" 
    capture_lex $P5322
    .const 'Sub' $P5314 = "537_1305640955.436" 
    capture_lex $P5314
    .const 'Sub' $P5306 = "536_1305640955.436" 
    capture_lex $P5306
    .const 'Sub' $P5163 = "533_1305640955.436" 
    capture_lex $P5163
    .const 'Sub' $P5155 = "532_1305640955.436" 
    capture_lex $P5155
    .const 'Sub' $P5140 = "531_1305640955.436" 
    capture_lex $P5140
    .const 'Sub' $P5125 = "530_1305640955.436" 
    capture_lex $P5125
    .const 'Sub' $P5110 = "529_1305640955.436" 
    capture_lex $P5110
    .const 'Sub' $P5088 = "528_1305640955.436" 
    capture_lex $P5088
    .const 'Sub' $P5080 = "527_1305640955.436" 
    capture_lex $P5080
    .const 'Sub' $P5072 = "526_1305640955.436" 
    capture_lex $P5072
    .const 'Sub' $P5064 = "525_1305640955.436" 
    capture_lex $P5064
    .const 'Sub' $P4830 = "519_1305640955.436" 
    capture_lex $P4830
    .const 'Sub' $P4731 = "518_1305640955.436" 
    capture_lex $P4731
    .const 'Sub' $P4723 = "517_1305640955.436" 
    capture_lex $P4723
    .const 'Sub' $P4715 = "516_1305640955.436" 
    capture_lex $P4715
    .const 'Sub' $P4707 = "515_1305640955.436" 
    capture_lex $P4707
    .const 'Sub' $P4699 = "514_1305640955.436" 
    capture_lex $P4699
    .const 'Sub' $P4691 = "513_1305640955.436" 
    capture_lex $P4691
    .const 'Sub' $P4683 = "512_1305640955.436" 
    capture_lex $P4683
    .const 'Sub' $P4480 = "506_1305640955.436" 
    capture_lex $P4480
    .const 'Sub' $P4453 = "505_1305640955.436" 
    capture_lex $P4453
    .const 'Sub' $P4439 = "504_1305640955.436" 
    capture_lex $P4439
    .const 'Sub' $P4431 = "503_1305640955.436" 
    capture_lex $P4431
    .const 'Sub' $P4423 = "502_1305640955.436" 
    capture_lex $P4423
    .const 'Sub' $P4415 = "501_1305640955.436" 
    capture_lex $P4415
    .const 'Sub' $P4407 = "500_1305640955.436" 
    capture_lex $P4407
    .const 'Sub' $P4399 = "499_1305640955.436" 
    capture_lex $P4399
    .const 'Sub' $P4391 = "498_1305640955.436" 
    capture_lex $P4391
    .const 'Sub' $P4383 = "497_1305640955.436" 
    capture_lex $P4383
    .const 'Sub' $P4375 = "496_1305640955.436" 
    capture_lex $P4375
    .const 'Sub' $P4367 = "495_1305640955.436" 
    capture_lex $P4367
    .const 'Sub' $P4359 = "494_1305640955.436" 
    capture_lex $P4359
    .const 'Sub' $P4351 = "493_1305640955.436" 
    capture_lex $P4351
    .const 'Sub' $P4343 = "492_1305640955.436" 
    capture_lex $P4343
    .const 'Sub' $P4335 = "491_1305640955.436" 
    capture_lex $P4335
    .const 'Sub' $P4319 = "490_1305640955.436" 
    capture_lex $P4319
    .const 'Sub' $P4265 = "489_1305640955.436" 
    capture_lex $P4265
    .const 'Sub' $P4248 = "488_1305640955.436" 
    capture_lex $P4248
    .const 'Sub' $P4224 = "487_1305640955.436" 
    capture_lex $P4224
    .const 'Sub' $P4201 = "486_1305640955.436" 
    capture_lex $P4201
    .const 'Sub' $P4174 = "485_1305640955.436" 
    capture_lex $P4174
    .const 'Sub' $P4137 = "484_1305640955.436" 
    capture_lex $P4137
    .const 'Sub' $P4122 = "483_1305640955.436" 
    capture_lex $P4122
    .const 'Sub' $P4110 = "482_1305640955.436" 
    capture_lex $P4110
    .const 'Sub' $P4059 = "480_1305640955.436" 
    capture_lex $P4059
    .const 'Sub' $P4034 = "479_1305640955.436" 
    capture_lex $P4034
    .const 'Sub' $P4027 = "478_1305640955.436" 
    capture_lex $P4027
    .const 'Sub' $P3985 = "477_1305640955.436" 
    capture_lex $P3985
    .const 'Sub' $P3935 = "475_1305640955.436" 
    capture_lex $P3935
    .const 'Sub' $P3918 = "474_1305640955.436" 
    capture_lex $P3918
    .const 'Sub' $P3879 = "472_1305640955.436" 
    capture_lex $P3879
    .const 'Sub' $P3871 = "471_1305640955.436" 
    capture_lex $P3871
    .const 'Sub' $P3863 = "470_1305640955.436" 
    capture_lex $P3863
    .const 'Sub' $P3846 = "469_1305640955.436" 
    capture_lex $P3846
    .const 'Sub' $P3750 = "467_1305640955.436" 
    capture_lex $P3750
    .const 'Sub' $P3706 = "465_1305640955.436" 
    capture_lex $P3706
    .const 'Sub' $P3557 = "464_1305640955.436" 
    capture_lex $P3557
    .const 'Sub' $P3526 = "463_1305640955.436" 
    capture_lex $P3526
    .const 'Sub' $P3518 = "462_1305640955.436" 
    capture_lex $P3518
    .const 'Sub' $P3389 = "456_1305640955.436" 
    capture_lex $P3389
    .const 'Sub' $P3354 = "454_1305640955.436" 
    capture_lex $P3354
    .const 'Sub' $P3349 = "453_1305640955.436" 
    capture_lex $P3349
    .const 'Sub' $P3344 = "452_1305640955.436" 
    capture_lex $P3344
    .const 'Sub' $P3231 = "449_1305640955.436" 
    capture_lex $P3231
    .const 'Sub' $P3213 = "448_1305640955.436" 
    capture_lex $P3213
    .const 'Sub' $P3138 = "446_1305640955.436" 
    capture_lex $P3138
    .const 'Sub' $P3123 = "445_1305640955.436" 
    capture_lex $P3123
    .const 'Sub' $P3036 = "444_1305640955.436" 
    capture_lex $P3036
    .const 'Sub' $P3010 = "442_1305640955.436" 
    capture_lex $P3010
    .const 'Sub' $P2994 = "441_1305640955.436" 
    capture_lex $P2994
    .const 'Sub' $P2970 = "440_1305640955.436" 
    capture_lex $P2970
    .const 'Sub' $P2934 = "437_1305640955.436" 
    capture_lex $P2934
    .const 'Sub' $P2926 = "436_1305640955.436" 
    capture_lex $P2926
.annotate 'line', 1207
    .const 'Sub' $P2926 = "436_1305640955.436" 
    newclosure $P2933, $P2926
    .lex "xblock_immediate", $P2933
.annotate 'line', 1212
    .const 'Sub' $P2934 = "437_1305640955.436" 
    newclosure $P2969, $P2934
    .lex "block_immediate", $P2969
.annotate 'line', 1222
    .const 'Sub' $P2970 = "440_1305640955.436" 
    newclosure $P2993, $P2970
    .lex "vivitype", $P2993
.annotate 'line', 1241
    .const 'Sub' $P2994 = "441_1305640955.436" 
    newclosure $P3009, $P2994
    .lex "colonpair_str", $P3009
.annotate 'line', 1414
    .const 'Sub' $P3010 = "442_1305640955.436" 
    newclosure $P3035, $P3010
    .lex "import_HOW_exports", $P3035
.annotate 'line', 1519
    .const 'Sub' $P3036 = "444_1305640955.436" 
    newclosure $P3122, $P3036
    .lex "push_block_handler", $P3122
.annotate 'line', 2064
    .const 'Sub' $P3123 = "445_1305640955.436" 
    newclosure $P3137, $P3123
    .lex "only_star_block", $P3137
.annotate 'line', 2073
    .const 'Sub' $P3138 = "446_1305640955.436" 
    newclosure $P3212, $P3138
    .lex "attach_multi_signature", $P3212
.annotate 'line', 2536
    .const 'Sub' $P3213 = "448_1305640955.436" 
    newclosure $P3230, $P3213
    .lex "control", $P3230
.annotate 'line', 2555
    .const 'Sub' $P3231 = "449_1305640955.436" 
    newclosure $P3343, $P3231
    .lex "lexical_package_lookup", $P3343
.annotate 'line', 2604
    .const 'Sub' $P3344 = "452_1305640955.436" 
    newclosure $P3348, $P3344
    .lex "is_lexical", $P3348
.annotate 'line', 2610
    .const 'Sub' $P3349 = "453_1305640955.436" 
    newclosure $P3353, $P3349
    .lex "is_package", $P3353
.annotate 'line', 2616
    .const 'Sub' $P3354 = "454_1305640955.436" 
    newclosure $P3388, $P3354
    .lex "is_scope", $P3388
.annotate 'line', 2639
    .const 'Sub' $P3389 = "456_1305640955.436" 
    newclosure $P3509, $P3389
    .lex "find_sym", $P3509
.annotate 'line', 1203
    .lex "$?PACKAGE", $P3510
    .lex "$?CLASS", $P3511
.annotate 'line', 1205
    new $P3512, "ResizablePMCArray"
    find_lex $P3513, "$?PACKAGE"
    get_who $P3514, $P3513
    set $P3514["@BLOCK"], $P3512
    find_lex $P3515, "xblock_immediate"
    find_lex $P3516, "block_immediate"
    find_lex $P3517, "vivitype"
.annotate 'line', 1233
    find_lex $P3556, "colonpair_str"
.annotate 'line', 1397
    find_lex $P3984, "import_HOW_exports"
.annotate 'line', 1512
    find_lex $P4247, "push_block_handler"
.annotate 'line', 2005
    find_lex $P5789, "only_star_block"
    find_lex $P5790, "attach_multi_signature"
.annotate 'line', 2527
    find_lex $P7102, "control"
.annotate 'line', 2549
    find_lex $P7129, "lexical_package_lookup"
    find_lex $P7130, "is_lexical"
    find_lex $P7131, "is_package"
    find_lex $P7132, "is_scope"
.annotate 'line', 2627
    find_lex $P7152, "find_sym"
.annotate 'line', 1203
    .return ($P7152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("436_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_2927
.annotate 'line', 1207
    .lex "$xblock", param_2927
.annotate 'line', 1208
    find_lex $P2928, "$xblock"
    unless_null $P2928, vivify_1708
    $P2928 = root_new ['parrot';'ResizablePMCArray']
  vivify_1708:
    set $P2929, $P2928[1]
    unless_null $P2929, vivify_1709
    new $P2929, "Undef"
  vivify_1709:
    $P2930 = "block_immediate"($P2929)
    find_lex $P2931, "$xblock"
    unless_null $P2931, vivify_1710
    $P2931 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2931
  vivify_1710:
    set $P2931[1], $P2930
    find_lex $P2932, "$xblock"
    unless_null $P2932, vivify_1711
    new $P2932, "Undef"
  vivify_1711:
.annotate 'line', 1207
    .return ($P2932)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("437_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_2935
.annotate 'line', 1212
    .const 'Sub' $P2945 = "438_1305640955.436" 
    capture_lex $P2945
    .lex "$block", param_2935
.annotate 'line', 1213
    find_lex $P2936, "$block"
    unless_null $P2936, vivify_1712
    new $P2936, "Undef"
  vivify_1712:
    $P2936."blocktype"("immediate")
.annotate 'line', 1214
    find_lex $P2940, "$block"
    unless_null $P2940, vivify_1713
    new $P2940, "Undef"
  vivify_1713:
    $P2941 = $P2940."symtable"()
    unless $P2941, unless_2939
    set $P2938, $P2941
    goto unless_2939_end
  unless_2939:
    find_lex $P2942, "$block"
    unless_null $P2942, vivify_1714
    new $P2942, "Undef"
  vivify_1714:
    $P2943 = $P2942."handlers"()
    set $P2938, $P2943
  unless_2939_end:
    if $P2938, unless_2937_end
    .const 'Sub' $P2945 = "438_1305640955.436" 
    capture_lex $P2945
    $P2945()
  unless_2937_end:
    find_lex $P2968, "$block"
    unless_null $P2968, vivify_1721
    new $P2968, "Undef"
  vivify_1721:
.annotate 'line', 1212
    .return ($P2968)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2944"  :anon :subid("438_1305640955.436") :outer("437_1305640955.436")
.annotate 'line', 1214
    .const 'Sub' $P2959 = "439_1305640955.436" 
    capture_lex $P2959
.annotate 'line', 1215
    new $P2946, "Undef"
    .lex "$stmts", $P2946
    get_hll_global $P2947, "GLOBAL"
    nqp_get_package_through_who $P2948, $P2947, "PAST"
    get_who $P2949, $P2948
    set $P2950, $P2949["Stmts"]
    find_lex $P2951, "$block"
    unless_null $P2951, vivify_1715
    new $P2951, "Undef"
  vivify_1715:
    $P2952 = $P2950."new"($P2951 :named("node"))
    store_lex "$stmts", $P2952
.annotate 'line', 1216
    find_lex $P2954, "$block"
    unless_null $P2954, vivify_1716
    new $P2954, "Undef"
  vivify_1716:
    $P2955 = $P2954."list"()
    defined $I2956, $P2955
    unless $I2956, for_undef_1717
    iter $P2953, $P2955
    new $P2965, 'ExceptionHandler'
    set_label $P2965, loop2964_handler
    $P2965."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2965
  loop2964_test:
    unless $P2953, loop2964_done
    shift $P2957, $P2953
  loop2964_redo:
    .const 'Sub' $P2959 = "439_1305640955.436" 
    capture_lex $P2959
    $P2959($P2957)
  loop2964_next:
    goto loop2964_test
  loop2964_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2966, exception, 'type'
    eq $P2966, .CONTROL_LOOP_NEXT, loop2964_next
    eq $P2966, .CONTROL_LOOP_REDO, loop2964_redo
  loop2964_done:
    pop_eh 
  for_undef_1717:
.annotate 'line', 1217
    find_lex $P2967, "$stmts"
    unless_null $P2967, vivify_1720
    new $P2967, "Undef"
  vivify_1720:
    store_lex "$block", $P2967
.annotate 'line', 1214
    .return ($P2967)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2958"  :anon :subid("439_1305640955.436") :outer("438_1305640955.436")
    .param pmc param_2960
.annotate 'line', 1216
    .lex "$_", param_2960
    find_lex $P2961, "$stmts"
    unless_null $P2961, vivify_1718
    new $P2961, "Undef"
  vivify_1718:
    find_lex $P2962, "$_"
    unless_null $P2962, vivify_1719
    new $P2962, "Undef"
  vivify_1719:
    $P2963 = $P2961."push"($P2962)
    .return ($P2963)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("440_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_2971
.annotate 'line', 1222
    .lex "$sigil", param_2971
.annotate 'line', 1223
    find_lex $P2974, "$sigil"
    unless_null $P2974, vivify_1722
    new $P2974, "Undef"
  vivify_1722:
    set $S2975, $P2974
    iseq $I2976, $S2975, "%"
    if $I2976, if_2973
.annotate 'line', 1225
    find_lex $P2984, "$sigil"
    unless_null $P2984, vivify_1723
    new $P2984, "Undef"
  vivify_1723:
    set $S2985, $P2984
    iseq $I2986, $S2985, "@"
    if $I2986, if_2983
    new $P2992, "String"
    assign $P2992, "Undef"
    set $P2982, $P2992
    goto if_2983_end
  if_2983:
.annotate 'line', 1226
    get_hll_global $P2987, "GLOBAL"
    nqp_get_package_through_who $P2988, $P2987, "PAST"
    get_who $P2989, $P2988
    set $P2990, $P2989["Op"]
    $P2991 = $P2990."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2982, $P2991
  if_2983_end:
    set $P2972, $P2982
.annotate 'line', 1223
    goto if_2973_end
  if_2973:
.annotate 'line', 1224
    get_hll_global $P2977, "GLOBAL"
    nqp_get_package_through_who $P2978, $P2977, "PAST"
    get_who $P2979, $P2978
    set $P2980, $P2979["Op"]
    $P2981 = $P2980."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2972, $P2981
  if_2973_end:
.annotate 'line', 1222
    .return ($P2972)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("441_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_2995
.annotate 'line', 1241
    .lex "$ast", param_2995
.annotate 'line', 1242
    get_hll_global $P2998, "GLOBAL"
    nqp_get_package_through_who $P2999, $P2998, "PAST"
    get_who $P3000, $P2999
    set $P3001, $P3000["Op"]
    find_lex $P3002, "$ast"
    unless_null $P3002, vivify_1724
    new $P3002, "Undef"
  vivify_1724:
    $P3003 = $P3001."ACCEPTS"($P3002)
    if $P3003, if_2997
.annotate 'line', 1244
    find_lex $P3007, "$ast"
    unless_null $P3007, vivify_1725
    new $P3007, "Undef"
  vivify_1725:
    $P3008 = $P3007."value"()
    set $P2996, $P3008
.annotate 'line', 1242
    goto if_2997_end
  if_2997:
.annotate 'line', 1243
    find_lex $P3004, "$ast"
    unless_null $P3004, vivify_1726
    new $P3004, "Undef"
  vivify_1726:
    $P3005 = $P3004."list"()
    join $S3006, " ", $P3005
    new $P2996, 'String'
    set $P2996, $S3006
  if_2997_end:
.annotate 'line', 1241
    .return ($P2996)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("442_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3011
.annotate 'line', 1414
    .const 'Sub' $P3023 = "443_1305640955.436" 
    capture_lex $P3023
    .lex "$UNIT", param_3011
.annotate 'line', 1416
    find_lex $P3014, "$UNIT"
    unless_null $P3014, vivify_1727
    new $P3014, "Undef"
  vivify_1727:
    exists $I3015, $P3014["EXPORTHOW"]
    if $I3015, if_3013
    new $P3012, 'Integer'
    set $P3012, $I3015
    goto if_3013_end
  if_3013:
.annotate 'line', 1417
    find_lex $P3017, "$UNIT"
    unless_null $P3017, vivify_1728
    $P3017 = root_new ['parrot';'Hash']
  vivify_1728:
    set $P3018, $P3017["EXPORTHOW"]
    unless_null $P3018, vivify_1729
    new $P3018, "Undef"
  vivify_1729:
    get_who $P3019, $P3018
    defined $I3020, $P3019
    unless $I3020, for_undef_1730
    iter $P3016, $P3019
    new $P3033, 'ExceptionHandler'
    set_label $P3033, loop3032_handler
    $P3033."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3033
  loop3032_test:
    unless $P3016, loop3032_done
    shift $P3021, $P3016
  loop3032_redo:
    .const 'Sub' $P3023 = "443_1305640955.436" 
    capture_lex $P3023
    $P3023($P3021)
  loop3032_next:
    goto loop3032_test
  loop3032_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3034, exception, 'type'
    eq $P3034, .CONTROL_LOOP_NEXT, loop3032_next
    eq $P3034, .CONTROL_LOOP_REDO, loop3032_redo
  loop3032_done:
    pop_eh 
  for_undef_1730:
.annotate 'line', 1416
    set $P3012, $P3016
  if_3013_end:
.annotate 'line', 1414
    .return ($P3012)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3022"  :anon :subid("443_1305640955.436") :outer("442_1305640955.436")
    .param pmc param_3024
.annotate 'line', 1417
    .lex "$_", param_3024
.annotate 'line', 1418
    find_lex $P3025, "$_"
    unless_null $P3025, vivify_1731
    new $P3025, "Undef"
  vivify_1731:
    $P3026 = $P3025."value"()
    find_lex $P3027, "$_"
    unless_null $P3027, vivify_1732
    new $P3027, "Undef"
  vivify_1732:
    $P3028 = $P3027."key"()
    find_dynamic_lex $P3031, "%*HOW"
    unless_null $P3031, vivify_1733
    get_hll_global $P3029, "GLOBAL"
    get_who $P3030, $P3029
    set $P3031, $P3030["%HOW"]
    unless_null $P3031, vivify_1734
    die "Contextual %*HOW not found"
  vivify_1734:
    store_dynamic_lex "%*HOW", $P3031
  vivify_1733:
    set $P3031[$P3028], $P3026
.annotate 'line', 1417
    .return ($P3026)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("444_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3037
    .param pmc param_3038
.annotate 'line', 1519
    .lex "$/", param_3037
    .lex "$block", param_3038
.annotate 'line', 1520
    find_lex $P3040, "$?PACKAGE"
    get_who $P3041, $P3040
    set $P3042, $P3041["@BLOCK"]
    unless_null $P3042, vivify_1735
    $P3042 = root_new ['parrot';'ResizablePMCArray']
  vivify_1735:
    set $P3043, $P3042[0]
    unless_null $P3043, vivify_1736
    new $P3043, "Undef"
  vivify_1736:
    $P3044 = $P3043."handlers"()
    if $P3044, unless_3039_end
.annotate 'line', 1521
    find_lex $P3045, "$?PACKAGE"
    get_who $P3046, $P3045
    set $P3047, $P3046["@BLOCK"]
    unless_null $P3047, vivify_1737
    $P3047 = root_new ['parrot';'ResizablePMCArray']
  vivify_1737:
    set $P3048, $P3047[0]
    unless_null $P3048, vivify_1738
    new $P3048, "Undef"
  vivify_1738:
    new $P3049, "ResizablePMCArray"
    $P3048."handlers"($P3049)
  unless_3039_end:
.annotate 'line', 1523
    find_lex $P3051, "$block"
    unless_null $P3051, vivify_1739
    new $P3051, "Undef"
  vivify_1739:
    $P3052 = $P3051."arity"()
    if $P3052, unless_3050_end
.annotate 'line', 1524
    find_lex $P3053, "$block"
    unless_null $P3053, vivify_1740
    new $P3053, "Undef"
  vivify_1740:
.annotate 'line', 1525
    get_hll_global $P3054, "GLOBAL"
    nqp_get_package_through_who $P3055, $P3054, "PAST"
    get_who $P3056, $P3055
    set $P3057, $P3056["Op"]
.annotate 'line', 1526
    get_hll_global $P3058, "GLOBAL"
    nqp_get_package_through_who $P3059, $P3058, "PAST"
    get_who $P3060, $P3059
    set $P3061, $P3060["Var"]
    $P3062 = $P3061."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1527
    get_hll_global $P3063, "GLOBAL"
    nqp_get_package_through_who $P3064, $P3063, "PAST"
    get_who $P3065, $P3064
    set $P3066, $P3065["Var"]
    $P3067 = $P3066."new"("lexical" :named("scope"), "$_" :named("name"))
    $P3068 = $P3057."new"($P3062, $P3067, "bind" :named("pasttype"))
.annotate 'line', 1525
    $P3053."unshift"($P3068)
.annotate 'line', 1530
    find_lex $P3069, "$block"
    unless_null $P3069, vivify_1741
    new $P3069, "Undef"
  vivify_1741:
    get_hll_global $P3070, "GLOBAL"
    nqp_get_package_through_who $P3071, $P3070, "PAST"
    get_who $P3072, $P3071
    set $P3073, $P3072["Var"]
    $P3074 = $P3073."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3069."unshift"($P3074)
.annotate 'line', 1531
    find_lex $P3075, "$block"
    unless_null $P3075, vivify_1742
    new $P3075, "Undef"
  vivify_1742:
    $P3075."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1532
    find_lex $P3076, "$block"
    unless_null $P3076, vivify_1743
    new $P3076, "Undef"
  vivify_1743:
    $P3076."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1533
    find_lex $P3077, "$block"
    unless_null $P3077, vivify_1744
    new $P3077, "Undef"
  vivify_1744:
    $P3077."arity"(1)
  unless_3050_end:
.annotate 'line', 1535
    find_lex $P3078, "$block"
    unless_null $P3078, vivify_1745
    new $P3078, "Undef"
  vivify_1745:
    $P3078."blocktype"("declaration")
.annotate 'line', 1536
    find_lex $P3079, "$?PACKAGE"
    get_who $P3080, $P3079
    set $P3081, $P3080["@BLOCK"]
    unless_null $P3081, vivify_1746
    $P3081 = root_new ['parrot';'ResizablePMCArray']
  vivify_1746:
    set $P3082, $P3081[0]
    unless_null $P3082, vivify_1747
    new $P3082, "Undef"
  vivify_1747:
    $P3083 = $P3082."handlers"()
.annotate 'line', 1537
    get_hll_global $P3084, "GLOBAL"
    nqp_get_package_through_who $P3085, $P3084, "PAST"
    get_who $P3086, $P3085
    set $P3087, $P3086["Control"]
    find_lex $P3088, "$/"
    unless_null $P3088, vivify_1748
    new $P3088, "Undef"
  vivify_1748:
.annotate 'line', 1539
    get_hll_global $P3089, "GLOBAL"
    nqp_get_package_through_who $P3090, $P3089, "PAST"
    get_who $P3091, $P3090
    set $P3092, $P3091["Stmts"]
.annotate 'line', 1540
    get_hll_global $P3093, "GLOBAL"
    nqp_get_package_through_who $P3094, $P3093, "PAST"
    get_who $P3095, $P3094
    set $P3096, $P3095["Op"]
    find_lex $P3097, "$block"
    unless_null $P3097, vivify_1749
    new $P3097, "Undef"
  vivify_1749:
.annotate 'line', 1542
    get_hll_global $P3098, "GLOBAL"
    nqp_get_package_through_who $P3099, $P3098, "PAST"
    get_who $P3100, $P3099
    set $P3101, $P3100["Var"]
    $P3102 = $P3101."new"("register" :named("scope"), "exception" :named("name"))
    $P3103 = $P3096."new"($P3097, $P3102, "call" :named("pasttype"))
.annotate 'line', 1544
    get_hll_global $P3104, "GLOBAL"
    nqp_get_package_through_who $P3105, $P3104, "PAST"
    get_who $P3106, $P3105
    set $P3107, $P3106["Op"]
.annotate 'line', 1545
    get_hll_global $P3108, "GLOBAL"
    nqp_get_package_through_who $P3109, $P3108, "PAST"
    get_who $P3110, $P3109
    set $P3111, $P3110["Var"]
.annotate 'line', 1546
    get_hll_global $P3112, "GLOBAL"
    nqp_get_package_through_who $P3113, $P3112, "PAST"
    get_who $P3114, $P3113
    set $P3115, $P3114["Var"]
    $P3116 = $P3115."new"("register" :named("scope"), "exception" :named("name"))
    $P3117 = $P3111."new"($P3116, "handled", "keyed" :named("scope"))
.annotate 'line', 1545
    $P3118 = $P3107."new"($P3117, 1, "bind" :named("pasttype"))
.annotate 'line', 1544
    $P3119 = $P3092."new"($P3103, $P3118)
.annotate 'line', 1539
    $P3120 = $P3087."new"($P3119, $P3088 :named("node"))
.annotate 'line', 1537
    $P3121 = $P3083."unshift"($P3120)
.annotate 'line', 1519
    .return ($P3121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("445_1305640955.436") :outer("435_1305640955.436")
.annotate 'line', 2065
    new $P3124, "Undef"
    .lex "$past", $P3124
    find_lex $P3125, "$?PACKAGE"
    get_who $P3126, $P3125
    set $P3127, $P3126["@BLOCK"]
    unless_null $P3127, vivify_1750
    $P3127 = root_new ['parrot';'ResizablePMCArray']
  vivify_1750:
    $P3128 = $P3127."shift"()
    store_lex "$past", $P3128
.annotate 'line', 2066
    find_lex $P3129, "$past"
    unless_null $P3129, vivify_1751
    new $P3129, "Undef"
  vivify_1751:
    $P3129."closure"(1)
.annotate 'line', 2067
    find_lex $P3130, "$past"
    unless_null $P3130, vivify_1752
    new $P3130, "Undef"
  vivify_1752:
    get_hll_global $P3131, "GLOBAL"
    nqp_get_package_through_who $P3132, $P3131, "PAST"
    get_who $P3133, $P3132
    set $P3134, $P3133["Op"]
    $P3135 = $P3134."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P3130."push"($P3135)
    find_lex $P3136, "$past"
    unless_null $P3136, vivify_1753
    new $P3136, "Undef"
  vivify_1753:
.annotate 'line', 2064
    .return ($P3136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("446_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3139
.annotate 'line', 2073
    .const 'Sub' $P3159 = "447_1305640955.436" 
    capture_lex $P3159
    .lex "$routine", param_3139
.annotate 'line', 2077
    new $P3140, "Undef"
    .lex "$types", $P3140
.annotate 'line', 2078
    new $P3141, "Undef"
    .lex "$definednesses", $P3141
.annotate 'line', 2077
    get_hll_global $P3142, "GLOBAL"
    nqp_get_package_through_who $P3143, $P3142, "PAST"
    get_who $P3144, $P3143
    set $P3145, $P3144["Op"]
    $P3146 = $P3145."new"("list" :named("pasttype"))
    store_lex "$types", $P3146
.annotate 'line', 2078
    get_hll_global $P3147, "GLOBAL"
    nqp_get_package_through_who $P3148, $P3147, "PAST"
    get_who $P3149, $P3148
    set $P3150, $P3149["Op"]
    $P3151 = $P3150."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P3151
.annotate 'line', 2079
    find_lex $P3153, "$routine"
    unless_null $P3153, vivify_1754
    $P3153 = root_new ['parrot';'ResizablePMCArray']
  vivify_1754:
    set $P3154, $P3153[0]
    unless_null $P3154, vivify_1755
    new $P3154, "Undef"
  vivify_1755:
    $P3155 = $P3154."list"()
    defined $I3156, $P3155
    unless $I3156, for_undef_1756
    iter $P3152, $P3155
    new $P3203, 'ExceptionHandler'
    set_label $P3203, loop3202_handler
    $P3203."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3203
  loop3202_test:
    unless $P3152, loop3202_done
    shift $P3157, $P3152
  loop3202_redo:
    .const 'Sub' $P3159 = "447_1305640955.436" 
    capture_lex $P3159
    $P3159($P3157)
  loop3202_next:
    goto loop3202_test
  loop3202_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3204, exception, 'type'
    eq $P3204, .CONTROL_LOOP_NEXT, loop3202_next
    eq $P3204, .CONTROL_LOOP_REDO, loop3202_redo
  loop3202_done:
    pop_eh 
  for_undef_1756:
.annotate 'line', 2086
    find_dynamic_lex $P3207, "$*SC"
    unless_null $P3207, vivify_1766
    get_hll_global $P3205, "GLOBAL"
    get_who $P3206, $P3205
    set $P3207, $P3206["$SC"]
    unless_null $P3207, vivify_1767
    die "Contextual $*SC not found"
  vivify_1767:
  vivify_1766:
    find_lex $P3208, "$routine"
    unless_null $P3208, vivify_1768
    new $P3208, "Undef"
  vivify_1768:
    find_lex $P3209, "$types"
    unless_null $P3209, vivify_1769
    new $P3209, "Undef"
  vivify_1769:
    find_lex $P3210, "$definednesses"
    unless_null $P3210, vivify_1770
    new $P3210, "Undef"
  vivify_1770:
    $P3211 = $P3207."set_routine_signature"($P3208, $P3209, $P3210)
.annotate 'line', 2073
    .return ($P3211)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3158"  :anon :subid("447_1305640955.436") :outer("446_1305640955.436")
    .param pmc param_3160
.annotate 'line', 2079
    .lex "$_", param_3160
.annotate 'line', 2080
    get_hll_global $P3165, "GLOBAL"
    nqp_get_package_through_who $P3166, $P3165, "PAST"
    get_who $P3167, $P3166
    set $P3168, $P3167["Var"]
    find_lex $P3169, "$_"
    unless_null $P3169, vivify_1757
    new $P3169, "Undef"
  vivify_1757:
    $P3170 = $P3168."ACCEPTS"($P3169)
    if $P3170, if_3164
    set $P3163, $P3170
    goto if_3164_end
  if_3164:
    find_lex $P3171, "$_"
    unless_null $P3171, vivify_1758
    new $P3171, "Undef"
  vivify_1758:
    $S3172 = $P3171."scope"()
    iseq $I3173, $S3172, "parameter"
    new $P3163, 'Integer'
    set $P3163, $I3173
  if_3164_end:
    if $P3163, if_3162
    set $P3161, $P3163
    goto if_3162_end
  if_3162:
.annotate 'line', 2081
    find_lex $P3174, "$types"
    unless_null $P3174, vivify_1759
    new $P3174, "Undef"
  vivify_1759:
    find_lex $P3176, "$_"
    unless_null $P3176, vivify_1760
    new $P3176, "Undef"
  vivify_1760:
    $P3177 = $P3176."multitype"()
    set $P3175, $P3177
    defined $I3179, $P3175
    if $I3179, default_3178
    get_hll_global $P3180, "GLOBAL"
    nqp_get_package_through_who $P3181, $P3180, "PAST"
    get_who $P3182, $P3181
    set $P3183, $P3182["Op"]
    $P3184 = $P3183."new"("null P" :named("pirop"))
    set $P3175, $P3184
  default_3178:
    $P3174."push"($P3175)
.annotate 'line', 2082
    find_lex $P3185, "$definednesses"
    unless_null $P3185, vivify_1761
    new $P3185, "Undef"
  vivify_1761:
    find_lex $P3188, "$_"
    unless_null $P3188, vivify_1762
    $P3188 = root_new ['parrot';'Hash']
  vivify_1762:
    set $P3189, $P3188["definedness"]
    unless_null $P3189, vivify_1763
    new $P3189, "Undef"
  vivify_1763:
    set $S3190, $P3189
    iseq $I3191, $S3190, "D"
    if $I3191, if_3187
.annotate 'line', 2083
    find_lex $P3195, "$_"
    unless_null $P3195, vivify_1764
    $P3195 = root_new ['parrot';'Hash']
  vivify_1764:
    set $P3196, $P3195["definedness"]
    unless_null $P3196, vivify_1765
    new $P3196, "Undef"
  vivify_1765:
    set $S3197, $P3196
    iseq $I3198, $S3197, "U"
    if $I3198, if_3194
    new $P3200, "Integer"
    assign $P3200, 0
    set $P3193, $P3200
    goto if_3194_end
  if_3194:
    new $P3199, "Integer"
    assign $P3199, 2
    set $P3193, $P3199
  if_3194_end:
    set $P3186, $P3193
.annotate 'line', 2082
    goto if_3187_end
  if_3187:
    new $P3192, "Integer"
    assign $P3192, 1
    set $P3186, $P3192
  if_3187_end:
    $P3201 = $P3185."push"($P3186)
.annotate 'line', 2080
    set $P3161, $P3201
  if_3162_end:
.annotate 'line', 2079
    .return ($P3161)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("448_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3214
    .param pmc param_3215
.annotate 'line', 2536
    .lex "$/", param_3214
    .lex "$type", param_3215
.annotate 'line', 2537
    find_lex $P3216, "$/"
    get_hll_global $P3217, "GLOBAL"
    nqp_get_package_through_who $P3218, $P3217, "PAST"
    get_who $P3219, $P3218
    set $P3220, $P3219["Op"]
    find_lex $P3221, "$/"
    unless_null $P3221, vivify_1771
    new $P3221, "Undef"
  vivify_1771:
.annotate 'line', 2541
    get_hll_global $P3222, "GLOBAL"
    nqp_get_package_through_who $P3223, $P3222, "PAST"
    get_who $P3224, $P3223
    set $P3225, $P3224["Val"]
    find_lex $P3226, "$type"
    unless_null $P3226, vivify_1772
    new $P3226, "Undef"
  vivify_1772:
    $P3227 = $P3225."new"($P3226 :named("value"), "!except_types" :named("returns"))
    $P3228 = $P3220."new"(0, $P3227, $P3221 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2537
    $P3229 = $P3216."!make"($P3228)
.annotate 'line', 2536
    .return ($P3229)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("449_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3234
    .param pmc param_3235
.annotate 'line', 2555
    .const 'Sub' $P3288 = "450_1305640955.436" 
    capture_lex $P3288
    new $P3233, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3233, control_3232
    push_eh $P3233
    .lex "@name", param_3234
    .lex "$/", param_3235
.annotate 'line', 2561
    new $P3236, "Undef"
    .lex "$final_name", $P3236
.annotate 'line', 2562
    new $P3237, "Undef"
    .lex "$lookup", $P3237
.annotate 'line', 2557
    find_lex $P3239, "@name"
    unless_null $P3239, vivify_1773
    $P3239 = root_new ['parrot';'ResizablePMCArray']
  vivify_1773:
    set $N3240, $P3239
    iseq $I3241, $N3240, 0.0
    unless $I3241, if_3238_end
    find_lex $P3242, "$/"
    unless_null $P3242, vivify_1774
    new $P3242, "Undef"
  vivify_1774:
    $P3243 = $P3242."CURSOR"()
    $P3243."panic"("Cannot compile empty name")
  if_3238_end:
.annotate 'line', 2561
    find_lex $P3244, "@name"
    unless_null $P3244, vivify_1775
    $P3244 = root_new ['parrot';'ResizablePMCArray']
  vivify_1775:
    $P3245 = $P3244."pop"()
    store_lex "$final_name", $P3245
.annotate 'line', 2562
    get_hll_global $P3246, "GLOBAL"
    nqp_get_package_through_who $P3247, $P3246, "PAST"
    get_who $P3248, $P3247
    set $P3249, $P3248["Var"]
    find_lex $P3250, "$final_name"
    unless_null $P3250, vivify_1776
    new $P3250, "Undef"
  vivify_1776:
    set $S3251, $P3250
    $P3252 = $P3249."new"($S3251, "keyed" :named("scope"))
    store_lex "$lookup", $P3252
.annotate 'line', 2566
    find_lex $P3254, "@name"
    unless_null $P3254, vivify_1777
    $P3254 = root_new ['parrot';'ResizablePMCArray']
  vivify_1777:
    set $N3255, $P3254
    iseq $I3256, $N3255, 0.0
    if $I3256, if_3253
.annotate 'line', 2584
    .const 'Sub' $P3288 = "450_1305640955.436" 
    capture_lex $P3288
    $P3288()
    goto if_3253_end
  if_3253:
.annotate 'line', 2567
    find_lex $P3257, "$lookup"
    unless_null $P3257, vivify_1790
    new $P3257, "Undef"
  vivify_1790:
    get_hll_global $P3258, "GLOBAL"
    nqp_get_package_through_who $P3259, $P3258, "PAST"
    get_who $P3260, $P3259
    set $P3261, $P3260["Op"]
.annotate 'line', 2569
    get_hll_global $P3262, "GLOBAL"
    nqp_get_package_through_who $P3263, $P3262, "PAST"
    get_who $P3264, $P3263
    set $P3265, $P3264["Var"]
    $P3266 = $P3265."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3267 = $P3261."new"($P3266, "get_who PP" :named("pirop"))
.annotate 'line', 2567
    $P3257."unshift"($P3267)
.annotate 'line', 2571
    find_lex $P3268, "$lookup"
    unless_null $P3268, vivify_1791
    new $P3268, "Undef"
  vivify_1791:
    get_hll_global $P3269, "GLOBAL"
    nqp_get_package_through_who $P3270, $P3269, "PAST"
    get_who $P3271, $P3270
    set $P3272, $P3271["Var"]
.annotate 'line', 2573
    get_hll_global $P3273, "GLOBAL"
    nqp_get_package_through_who $P3274, $P3273, "PAST"
    get_who $P3275, $P3274
    set $P3276, $P3275["Op"]
.annotate 'line', 2575
    get_hll_global $P3277, "GLOBAL"
    nqp_get_package_through_who $P3278, $P3277, "PAST"
    get_who $P3279, $P3278
    set $P3280, $P3279["Var"]
    new $P3281, "ResizablePMCArray"
    $P3282 = $P3280."new"("GLOBAL" :named("name"), $P3281 :named("namespace"), "package" :named("scope"))
    $P3283 = $P3276."new"($P3282, "get_who PP" :named("pirop"))
.annotate 'line', 2577
    find_lex $P3284, "$final_name"
    unless_null $P3284, vivify_1792
    new $P3284, "Undef"
  vivify_1792:
    set $S3285, $P3284
    $P3286 = $P3272."new"($P3283, $S3285, "keyed" :named("scope"))
.annotate 'line', 2571
    $P3268."viviself"($P3286)
  if_3253_end:
.annotate 'line', 2599
    new $P3340, "Exception"
    set $P3340['type'], .CONTROL_RETURN
    find_lex $P3341, "$lookup"
    unless_null $P3341, vivify_1793
    new $P3341, "Undef"
  vivify_1793:
    setattribute $P3340, 'payload', $P3341
    throw $P3340
.annotate 'line', 2555
    .return ()
  control_3232:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3342, exception, "payload"
    .return ($P3342)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3287"  :anon :subid("450_1305640955.436") :outer("449_1305640955.436")
.annotate 'line', 2584
    .const 'Sub' $P3319 = "451_1305640955.436" 
    capture_lex $P3319
.annotate 'line', 2585
    new $P3289, "Undef"
    .lex "$path", $P3289
    find_lex $P3292, "@name"
    unless_null $P3292, vivify_1778
    $P3292 = root_new ['parrot';'ResizablePMCArray']
  vivify_1778:
    set $P3293, $P3292[0]
    unless_null $P3293, vivify_1779
    new $P3293, "Undef"
  vivify_1779:
    $P3294 = "is_lexical"($P3293)
    if $P3294, if_3291
.annotate 'line', 2587
    get_hll_global $P3302, "GLOBAL"
    nqp_get_package_through_who $P3303, $P3302, "PAST"
    get_who $P3304, $P3303
    set $P3305, $P3304["Var"]
    new $P3306, "ResizablePMCArray"
    $P3307 = $P3305."new"("GLOBAL" :named("name"), $P3306 :named("namespace"), "package" :named("scope"))
    set $P3290, $P3307
.annotate 'line', 2585
    goto if_3291_end
  if_3291:
.annotate 'line', 2586
    get_hll_global $P3295, "GLOBAL"
    nqp_get_package_through_who $P3296, $P3295, "PAST"
    get_who $P3297, $P3296
    set $P3298, $P3297["Var"]
    find_lex $P3299, "@name"
    unless_null $P3299, vivify_1780
    $P3299 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    $P3300 = $P3299."shift"()
    $P3301 = $P3298."new"($P3300 :named("name"), "lexical" :named("scope"))
    set $P3290, $P3301
  if_3291_end:
.annotate 'line', 2585
    store_lex "$path", $P3290
.annotate 'line', 2588
    find_lex $P3309, "@name"
    unless_null $P3309, vivify_1781
    $P3309 = root_new ['parrot';'ResizablePMCArray']
  vivify_1781:
    set $P3310, $P3309[0]
    unless_null $P3310, vivify_1782
    new $P3310, "Undef"
  vivify_1782:
    set $S3311, $P3310
    iseq $I3312, $S3311, "GLOBAL"
    unless $I3312, if_3308_end
.annotate 'line', 2589
    find_lex $P3313, "@name"
    unless_null $P3313, vivify_1783
    $P3313 = root_new ['parrot';'ResizablePMCArray']
  vivify_1783:
    $P3313."shift"()
  if_3308_end:
.annotate 'line', 2591
    find_lex $P3315, "@name"
    unless_null $P3315, vivify_1784
    $P3315 = root_new ['parrot';'ResizablePMCArray']
  vivify_1784:
    defined $I3316, $P3315
    unless $I3316, for_undef_1785
    iter $P3314, $P3315
    new $P3330, 'ExceptionHandler'
    set_label $P3330, loop3329_handler
    $P3330."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3330
  loop3329_test:
    unless $P3314, loop3329_done
    shift $P3317, $P3314
  loop3329_redo:
    .const 'Sub' $P3319 = "451_1305640955.436" 
    capture_lex $P3319
    $P3319($P3317)
  loop3329_next:
    goto loop3329_test
  loop3329_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3331, exception, 'type'
    eq $P3331, .CONTROL_LOOP_NEXT, loop3329_next
    eq $P3331, .CONTROL_LOOP_REDO, loop3329_redo
  loop3329_done:
    pop_eh 
  for_undef_1785:
.annotate 'line', 2596
    find_lex $P3332, "$lookup"
    unless_null $P3332, vivify_1788
    new $P3332, "Undef"
  vivify_1788:
    get_hll_global $P3333, "GLOBAL"
    nqp_get_package_through_who $P3334, $P3333, "PAST"
    get_who $P3335, $P3334
    set $P3336, $P3335["Op"]
    find_lex $P3337, "$path"
    unless_null $P3337, vivify_1789
    new $P3337, "Undef"
  vivify_1789:
    $P3338 = $P3336."new"($P3337, "get_who PP" :named("pirop"))
    $P3339 = $P3332."unshift"($P3338)
.annotate 'line', 2584
    .return ($P3339)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3318"  :anon :subid("451_1305640955.436") :outer("450_1305640955.436")
    .param pmc param_3320
.annotate 'line', 2591
    .lex "$_", param_3320
.annotate 'line', 2592
    get_hll_global $P3321, "GLOBAL"
    nqp_get_package_through_who $P3322, $P3321, "PAST"
    get_who $P3323, $P3322
    set $P3324, $P3323["Op"]
    find_lex $P3325, "$path"
    unless_null $P3325, vivify_1786
    new $P3325, "Undef"
  vivify_1786:
.annotate 'line', 2594
    find_lex $P3326, "$_"
    unless_null $P3326, vivify_1787
    new $P3326, "Undef"
  vivify_1787:
    set $S3327, $P3326
    $P3328 = $P3324."new"($P3325, $S3327, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2592
    store_lex "$path", $P3328
.annotate 'line', 2591
    .return ($P3328)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("452_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3345
.annotate 'line', 2604
    .lex "$name", param_3345
.annotate 'line', 2605
    find_lex $P3346, "$name"
    unless_null $P3346, vivify_1794
    new $P3346, "Undef"
  vivify_1794:
    $P3347 = "is_scope"($P3346, "lexical")
.annotate 'line', 2604
    .return ($P3347)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("453_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3350
.annotate 'line', 2610
    .lex "$name", param_3350
.annotate 'line', 2611
    find_lex $P3351, "$name"
    unless_null $P3351, vivify_1795
    new $P3351, "Undef"
  vivify_1795:
    $P3352 = "is_scope"($P3351, "package")
.annotate 'line', 2610
    .return ($P3352)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("454_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3357
    .param pmc param_3358
.annotate 'line', 2616
    .const 'Sub' $P3366 = "455_1305640955.436" 
    capture_lex $P3366
    new $P3356, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3356, control_3355
    push_eh $P3356
    .lex "$name", param_3357
    .lex "$wanted_scope", param_3358
.annotate 'line', 2617
    find_lex $P3360, "$?PACKAGE"
    get_who $P3361, $P3360
    set $P3362, $P3361["@BLOCK"]
    unless_null $P3362, vivify_1796
    $P3362 = root_new ['parrot';'ResizablePMCArray']
  vivify_1796:
    defined $I3363, $P3362
    unless $I3363, for_undef_1797
    iter $P3359, $P3362
    new $P3385, 'ExceptionHandler'
    set_label $P3385, loop3384_handler
    $P3385."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3385
  loop3384_test:
    unless $P3359, loop3384_done
    shift $P3364, $P3359
  loop3384_redo:
    .const 'Sub' $P3366 = "455_1305640955.436" 
    capture_lex $P3366
    $P3366($P3364)
  loop3384_next:
    goto loop3384_test
  loop3384_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3386, exception, 'type'
    eq $P3386, .CONTROL_LOOP_NEXT, loop3384_next
    eq $P3386, .CONTROL_LOOP_REDO, loop3384_redo
  loop3384_done:
    pop_eh 
  for_undef_1797:
.annotate 'line', 2616
    .return (0)
  control_3355:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3387, exception, "payload"
    .return ($P3387)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3365"  :anon :subid("455_1305640955.436") :outer("454_1305640955.436")
    .param pmc param_3368
.annotate 'line', 2618
    $P3367 = root_new ['parrot';'Hash']
    .lex "%sym", $P3367
    .lex "$_", param_3368
    find_lex $P3369, "$_"
    unless_null $P3369, vivify_1798
    new $P3369, "Undef"
  vivify_1798:
    find_lex $P3370, "$name"
    unless_null $P3370, vivify_1799
    new $P3370, "Undef"
  vivify_1799:
    $P3371 = $P3369."symbol"($P3370)
    store_lex "%sym", $P3371
.annotate 'line', 2619
    find_lex $P3374, "%sym"
    unless_null $P3374, vivify_1800
    $P3374 = root_new ['parrot';'Hash']
  vivify_1800:
    set $N3375, $P3374
    if $N3375, if_3373
    new $P3372, 'Float'
    set $P3372, $N3375
    goto if_3373_end
  if_3373:
.annotate 'line', 2620
    new $P3376, "Exception"
    set $P3376['type'], .CONTROL_RETURN
    find_lex $P3377, "%sym"
    unless_null $P3377, vivify_1801
    $P3377 = root_new ['parrot';'Hash']
  vivify_1801:
    set $P3378, $P3377["scope"]
    unless_null $P3378, vivify_1802
    new $P3378, "Undef"
  vivify_1802:
    set $S3379, $P3378
    find_lex $P3380, "$wanted_scope"
    unless_null $P3380, vivify_1803
    new $P3380, "Undef"
  vivify_1803:
    set $S3381, $P3380
    iseq $I3382, $S3379, $S3381
    new $P3383, 'Integer'
    set $P3383, $I3382
    setattribute $P3376, 'payload', $P3383
    throw $P3376
  if_3373_end:
.annotate 'line', 2617
    .return ($P3372)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("456_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3392
    .param pmc param_3393
.annotate 'line', 2639
    .const 'Sub' $P3487 = "461_1305640955.436" 
    capture_lex $P3487
    .const 'Sub' $P3447 = "459_1305640955.436" 
    capture_lex $P3447
    .const 'Sub' $P3405 = "457_1305640955.436" 
    capture_lex $P3405
    new $P3391, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3391, control_3390
    push_eh $P3391
    .lex "@name", param_3392
    .lex "$/", param_3393
.annotate 'line', 2663
    new $P3394, "Undef"
    .lex "$result", $P3394
.annotate 'line', 2641
    find_lex $P3396, "@name"
    unless_null $P3396, vivify_1804
    $P3396 = root_new ['parrot';'ResizablePMCArray']
  vivify_1804:
    set $N3397, $P3396
    if $N3397, unless_3395_end
    find_lex $P3398, "$/"
    unless_null $P3398, vivify_1805
    new $P3398, "Undef"
  vivify_1805:
    $P3399 = $P3398."CURSOR"()
    $P3399."panic"("Cannot look up empty name")
  unless_3395_end:
.annotate 'line', 2645
    find_lex $P3401, "@name"
    unless_null $P3401, vivify_1806
    $P3401 = root_new ['parrot';'ResizablePMCArray']
  vivify_1806:
    set $N3402, $P3401
    iseq $I3403, $N3402, 1.0
    unless $I3403, if_3400_end
    .const 'Sub' $P3405 = "457_1305640955.436" 
    capture_lex $P3405
    $P3405()
  if_3400_end:
.annotate 'line', 2663
    find_dynamic_lex $P3441, "$*GLOBALish"
    unless_null $P3441, vivify_1818
    get_hll_global $P3439, "GLOBAL"
    get_who $P3440, $P3439
    set $P3441, $P3440["$GLOBALish"]
    unless_null $P3441, vivify_1819
    die "Contextual $*GLOBALish not found"
  vivify_1819:
  vivify_1818:
    store_lex "$result", $P3441
.annotate 'line', 2664
    find_lex $P3443, "@name"
    unless_null $P3443, vivify_1820
    $P3443 = root_new ['parrot';'ResizablePMCArray']
  vivify_1820:
    set $N3444, $P3443
    isge $I3445, $N3444, 2.0
    unless $I3445, if_3442_end
    .const 'Sub' $P3447 = "459_1305640955.436" 
    capture_lex $P3447
    $P3447()
  if_3442_end:
.annotate 'line', 2682
    find_lex $P3483, "@name"
    unless_null $P3483, vivify_1833
    $P3483 = root_new ['parrot';'ResizablePMCArray']
  vivify_1833:
    defined $I3484, $P3483
    unless $I3484, for_undef_1834
    iter $P3482, $P3483
    new $P3505, 'ExceptionHandler'
    set_label $P3505, loop3504_handler
    $P3505."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3505
  loop3504_test:
    unless $P3482, loop3504_done
    shift $P3485, $P3482
  loop3504_redo:
    .const 'Sub' $P3487 = "461_1305640955.436" 
    capture_lex $P3487
    $P3487($P3485)
  loop3504_next:
    goto loop3504_test
  loop3504_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3506, exception, 'type'
    eq $P3506, .CONTROL_LOOP_NEXT, loop3504_next
    eq $P3506, .CONTROL_LOOP_REDO, loop3504_redo
  loop3504_done:
    pop_eh 
  for_undef_1834:
    find_lex $P3507, "$result"
    unless_null $P3507, vivify_1841
    new $P3507, "Undef"
  vivify_1841:
.annotate 'line', 2639
    .return ($P3507)
  control_3390:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3508, exception, "payload"
    .return ($P3508)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3404"  :anon :subid("457_1305640955.436") :outer("456_1305640955.436")
.annotate 'line', 2645
    .const 'Sub' $P3416 = "458_1305640955.436" 
    capture_lex $P3416
.annotate 'line', 2646
    new $P3406, "Undef"
    .lex "$final_name", $P3406
    find_lex $P3407, "@name"
    unless_null $P3407, vivify_1807
    $P3407 = root_new ['parrot';'ResizablePMCArray']
  vivify_1807:
    set $P3408, $P3407[0]
    unless_null $P3408, vivify_1808
    new $P3408, "Undef"
  vivify_1808:
    store_lex "$final_name", $P3408
.annotate 'line', 2647
    find_lex $P3410, "$?PACKAGE"
    get_who $P3411, $P3410
    set $P3412, $P3411["@BLOCK"]
    unless_null $P3412, vivify_1809
    $P3412 = root_new ['parrot';'ResizablePMCArray']
  vivify_1809:
    defined $I3413, $P3412
    unless $I3413, for_undef_1810
    iter $P3409, $P3412
    new $P3437, 'ExceptionHandler'
    set_label $P3437, loop3436_handler
    $P3437."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3437
  loop3436_test:
    unless $P3409, loop3436_done
    shift $P3414, $P3409
  loop3436_redo:
    .const 'Sub' $P3416 = "458_1305640955.436" 
    capture_lex $P3416
    $P3416($P3414)
  loop3436_next:
    goto loop3436_test
  loop3436_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3438, exception, 'type'
    eq $P3438, .CONTROL_LOOP_NEXT, loop3436_next
    eq $P3438, .CONTROL_LOOP_REDO, loop3436_redo
  loop3436_done:
    pop_eh 
  for_undef_1810:
.annotate 'line', 2645
    .return ($P3409)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3415"  :anon :subid("458_1305640955.436") :outer("457_1305640955.436")
    .param pmc param_3418
.annotate 'line', 2648
    $P3417 = root_new ['parrot';'Hash']
    .lex "%sym", $P3417
    .lex "$_", param_3418
    find_lex $P3419, "$_"
    unless_null $P3419, vivify_1811
    new $P3419, "Undef"
  vivify_1811:
    find_lex $P3420, "$final_name"
    unless_null $P3420, vivify_1812
    new $P3420, "Undef"
  vivify_1812:
    $P3421 = $P3419."symbol"($P3420)
    store_lex "%sym", $P3421
.annotate 'line', 2649
    find_lex $P3424, "%sym"
    unless_null $P3424, vivify_1813
    $P3424 = root_new ['parrot';'Hash']
  vivify_1813:
    set $N3425, $P3424
    if $N3425, if_3423
    new $P3422, 'Float'
    set $P3422, $N3425
    goto if_3423_end
  if_3423:
.annotate 'line', 2650
    find_lex $P3428, "%sym"
    unless_null $P3428, vivify_1814
    $P3428 = root_new ['parrot';'Hash']
  vivify_1814:
    exists $I3429, $P3428["value"]
    if $I3429, if_3427
.annotate 'line', 2654
    new $P3433, 'String'
    set $P3433, "No compile-time value for "
    find_lex $P3434, "$final_name"
    unless_null $P3434, vivify_1815
    new $P3434, "Undef"
  vivify_1815:
    concat $P3435, $P3433, $P3434
    die $P3435
.annotate 'line', 2653
    goto if_3427_end
  if_3427:
.annotate 'line', 2651
    new $P3430, "Exception"
    set $P3430['type'], .CONTROL_RETURN
    find_lex $P3431, "%sym"
    unless_null $P3431, vivify_1816
    $P3431 = root_new ['parrot';'Hash']
  vivify_1816:
    set $P3432, $P3431["value"]
    unless_null $P3432, vivify_1817
    new $P3432, "Undef"
  vivify_1817:
    setattribute $P3430, 'payload', $P3432
    throw $P3430
  if_3427_end:
.annotate 'line', 2649
    set $P3422, $P3426
  if_3423_end:
.annotate 'line', 2647
    .return ($P3422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3446"  :anon :subid("459_1305640955.436") :outer("456_1305640955.436")
.annotate 'line', 2664
    .const 'Sub' $P3458 = "460_1305640955.436" 
    capture_lex $P3458
.annotate 'line', 2665
    new $P3448, "Undef"
    .lex "$first", $P3448
    find_lex $P3449, "@name"
    unless_null $P3449, vivify_1821
    $P3449 = root_new ['parrot';'ResizablePMCArray']
  vivify_1821:
    set $P3450, $P3449[0]
    unless_null $P3450, vivify_1822
    new $P3450, "Undef"
  vivify_1822:
    store_lex "$first", $P3450
.annotate 'line', 2666
    find_lex $P3452, "$?PACKAGE"
    get_who $P3453, $P3452
    set $P3454, $P3453["@BLOCK"]
    unless_null $P3454, vivify_1823
    $P3454 = root_new ['parrot';'ResizablePMCArray']
  vivify_1823:
    defined $I3455, $P3454
    unless $I3455, for_undef_1824
    iter $P3451, $P3454
    new $P3480, 'ExceptionHandler'
    set_label $P3480, loop3479_handler
    $P3480."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3480
  loop3479_test:
    unless $P3451, loop3479_done
    shift $P3456, $P3451
  loop3479_redo:
    .const 'Sub' $P3458 = "460_1305640955.436" 
    capture_lex $P3458
    $P3458($P3456)
  loop3479_next:
    goto loop3479_test
  loop3479_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3481, exception, 'type'
    eq $P3481, .CONTROL_LOOP_NEXT, loop3479_next
    eq $P3481, .CONTROL_LOOP_REDO, loop3479_redo
  loop3479_done:
    pop_eh 
  for_undef_1824:
.annotate 'line', 2664
    .return ($P3451)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3457"  :anon :subid("460_1305640955.436") :outer("459_1305640955.436")
    .param pmc param_3460
.annotate 'line', 2667
    $P3459 = root_new ['parrot';'Hash']
    .lex "%sym", $P3459
    .lex "$_", param_3460
    find_lex $P3461, "$_"
    unless_null $P3461, vivify_1825
    new $P3461, "Undef"
  vivify_1825:
    find_lex $P3462, "$first"
    unless_null $P3462, vivify_1826
    new $P3462, "Undef"
  vivify_1826:
    $P3463 = $P3461."symbol"($P3462)
    store_lex "%sym", $P3463
.annotate 'line', 2668
    find_lex $P3466, "%sym"
    unless_null $P3466, vivify_1827
    $P3466 = root_new ['parrot';'Hash']
  vivify_1827:
    set $N3467, $P3466
    if $N3467, if_3465
    new $P3464, 'Float'
    set $P3464, $N3467
    goto if_3465_end
  if_3465:
.annotate 'line', 2669
    find_lex $P3470, "%sym"
    unless_null $P3470, vivify_1828
    $P3470 = root_new ['parrot';'Hash']
  vivify_1828:
    exists $I3471, $P3470["value"]
    if $I3471, if_3469
.annotate 'line', 2675
    new $P3476, 'String'
    set $P3476, "No compile-time value for "
    find_lex $P3477, "$first"
    unless_null $P3477, vivify_1829
    new $P3477, "Undef"
  vivify_1829:
    concat $P3478, $P3476, $P3477
    die $P3478
.annotate 'line', 2674
    goto if_3469_end
  if_3469:
.annotate 'line', 2670
    find_lex $P3472, "%sym"
    unless_null $P3472, vivify_1830
    $P3472 = root_new ['parrot';'Hash']
  vivify_1830:
    set $P3473, $P3472["value"]
    unless_null $P3473, vivify_1831
    new $P3473, "Undef"
  vivify_1831:
    store_lex "$result", $P3473
.annotate 'line', 2671
    find_lex $P3474, "@name"
    unless_null $P3474, vivify_1832
    $P3474 = root_new ['parrot';'ResizablePMCArray']
  vivify_1832:
    $P3474."shift"()
.annotate 'line', 2672
    set $I3475, .CONTROL_LOOP_LAST
    die 0, $I3475
  if_3469_end:
.annotate 'line', 2668
    set $P3464, $P3468
  if_3465_end:
.annotate 'line', 2666
    .return ($P3464)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3486"  :anon :subid("461_1305640955.436") :outer("456_1305640955.436")
    .param pmc param_3488
.annotate 'line', 2682
    .lex "$_", param_3488
.annotate 'line', 2683
    find_lex $P3493, "$_"
    unless_null $P3493, vivify_1835
    new $P3493, "Undef"
  vivify_1835:
    set $S3494, $P3493
    find_lex $P3491, "$result"
    unless_null $P3491, vivify_1836
    new $P3491, "Undef"
  vivify_1836:
    get_who $P3492, $P3491
    exists $I3495, $P3492[$S3494]
    if $I3495, if_3490
.annotate 'line', 2687
    new $P3500, "String"
    assign $P3500, "Could not locate compile-time value for symbol "
.annotate 'line', 2688
    find_lex $P3501, "@name"
    unless_null $P3501, vivify_1837
    $P3501 = root_new ['parrot';'ResizablePMCArray']
  vivify_1837:
    join $S3502, "::", $P3501
    concat $P3503, $P3500, $S3502
.annotate 'line', 2687
    die $P3503
.annotate 'line', 2686
    goto if_3490_end
  if_3490:
.annotate 'line', 2684
    find_lex $P3496, "$_"
    unless_null $P3496, vivify_1838
    new $P3496, "Undef"
  vivify_1838:
    find_lex $P3497, "$result"
    unless_null $P3497, vivify_1839
    new $P3497, "Undef"
  vivify_1839:
    get_who $P3498, $P3497
    set $P3499, $P3498[$P3496]
    unless_null $P3499, vivify_1840
    new $P3499, "Undef"
  vivify_1840:
    store_lex "$result", $P3499
.annotate 'line', 2683
    set $P3489, $P3499
  if_3490_end:
.annotate 'line', 2682
    .return ($P3489)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP" :anon :subid("462_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3519
    .param pmc param_3520
.annotate 'line', 1231
    .lex "self", param_3519
    .lex "$/", param_3520
    find_lex $P3521, "$/"
    find_lex $P3522, "$/"
    unless_null $P3522, vivify_1842
    $P3522 = root_new ['parrot';'Hash']
  vivify_1842:
    set $P3523, $P3522["comp_unit"]
    unless_null $P3523, vivify_1843
    new $P3523, "Undef"
  vivify_1843:
    $P3524 = $P3523."ast"()
    $P3525 = $P3521."!make"($P3524)
    .return ($P3525)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname" :anon :subid("463_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3527
    .param pmc param_3528
.annotate 'line', 1233
    .lex "self", param_3527
    .lex "$/", param_3528
.annotate 'line', 1234
    find_lex $P3529, "$/"
.annotate 'line', 1235
    find_lex $P3532, "$/"
    unless_null $P3532, vivify_1844
    $P3532 = root_new ['parrot';'Hash']
  vivify_1844:
    set $P3533, $P3532["colonpair"]
    unless_null $P3533, vivify_1845
    new $P3533, "Undef"
  vivify_1845:
    if $P3533, if_3531
.annotate 'line', 1237
    find_lex $P3553, "$/"
    unless_null $P3553, vivify_1846
    new $P3553, "Undef"
  vivify_1846:
    set $S3554, $P3553
    new $P3530, 'String'
    set $P3530, $S3554
.annotate 'line', 1235
    goto if_3531_end
  if_3531:
    find_lex $P3534, "$/"
    unless_null $P3534, vivify_1847
    $P3534 = root_new ['parrot';'Hash']
  vivify_1847:
    set $P3535, $P3534["identifier"]
    unless_null $P3535, vivify_1848
    new $P3535, "Undef"
  vivify_1848:
    set $S3536, $P3535
    new $P3537, 'String'
    set $P3537, $S3536
    concat $P3538, $P3537, ":"
    find_lex $P3539, "$/"
    unless_null $P3539, vivify_1849
    $P3539 = root_new ['parrot';'Hash']
  vivify_1849:
    set $P3540, $P3539["colonpair"]
    unless_null $P3540, vivify_1850
    $P3540 = root_new ['parrot';'ResizablePMCArray']
  vivify_1850:
    set $P3541, $P3540[0]
    unless_null $P3541, vivify_1851
    new $P3541, "Undef"
  vivify_1851:
    $P3542 = $P3541."ast"()
    $S3543 = $P3542."named"()
    concat $P3544, $P3538, $S3543
    concat $P3545, $P3544, "<"
.annotate 'line', 1236
    find_lex $P3546, "$/"
    unless_null $P3546, vivify_1852
    $P3546 = root_new ['parrot';'Hash']
  vivify_1852:
    set $P3547, $P3546["colonpair"]
    unless_null $P3547, vivify_1853
    $P3547 = root_new ['parrot';'ResizablePMCArray']
  vivify_1853:
    set $P3548, $P3547[0]
    unless_null $P3548, vivify_1854
    new $P3548, "Undef"
  vivify_1854:
    $P3549 = $P3548."ast"()
    $S3550 = "colonpair_str"($P3549)
    concat $P3551, $P3545, $S3550
    concat $P3552, $P3551, ">"
    set $P3530, $P3552
  if_3531_end:
.annotate 'line', 1235
    $P3555 = $P3529."!make"($P3530)
.annotate 'line', 1233
    .return ($P3555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit" :anon :subid("464_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3558
    .param pmc param_3559
.annotate 'line', 1247
    .lex "self", param_3558
    .lex "$/", param_3559
.annotate 'line', 1248
    new $P3560, "Undef"
    .lex "$mainline", $P3560
.annotate 'line', 1249
    new $P3561, "Undef"
    .lex "$unit", $P3561
.annotate 'line', 1279
    new $P3562, "Undef"
    .lex "$main_tasks", $P3562
.annotate 'line', 1248
    find_lex $P3563, "$/"
    unless_null $P3563, vivify_1855
    $P3563 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P3564, $P3563["statementlist"]
    unless_null $P3564, vivify_1856
    new $P3564, "Undef"
  vivify_1856:
    $P3565 = $P3564."ast"()
    store_lex "$mainline", $P3565
.annotate 'line', 1249
    find_lex $P3566, "$?PACKAGE"
    get_who $P3567, $P3566
    set $P3568, $P3567["@BLOCK"]
    unless_null $P3568, vivify_1857
    $P3568 = root_new ['parrot';'ResizablePMCArray']
  vivify_1857:
    $P3569 = $P3568."shift"()
    store_lex "$unit", $P3569
.annotate 'line', 1253
    find_lex $P3570, "$unit"
    unless_null $P3570, vivify_1858
    new $P3570, "Undef"
  vivify_1858:
    $P3571 = $P3570."loadinit"()
    find_dynamic_lex $P3574, "$*SC"
    unless_null $P3574, vivify_1859
    get_hll_global $P3572, "GLOBAL"
    get_who $P3573, $P3572
    set $P3574, $P3573["$SC"]
    unless_null $P3574, vivify_1860
    die "Contextual $*SC not found"
  vivify_1860:
  vivify_1859:
    $P3575 = $P3574."to_past"()
    $P3571."push"($P3575)
.annotate 'line', 1258
    find_lex $P3576, "$unit"
    unless_null $P3576, vivify_1861
    new $P3576, "Undef"
  vivify_1861:
    $P3577 = $P3576."loadinit"()
    get_hll_global $P3578, "GLOBAL"
    nqp_get_package_through_who $P3579, $P3578, "PAST"
    get_who $P3580, $P3579
    set $P3581, $P3580["Op"]
.annotate 'line', 1260
    get_hll_global $P3582, "GLOBAL"
    nqp_get_package_through_who $P3583, $P3582, "PAST"
    get_who $P3584, $P3583
    set $P3585, $P3584["Var"]
    new $P3586, "ResizablePMCArray"
    $P3587 = $P3585."new"("GLOBAL" :named("name"), $P3586 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1261
    find_dynamic_lex $P3590, "$*SC"
    unless_null $P3590, vivify_1862
    get_hll_global $P3588, "GLOBAL"
    get_who $P3589, $P3588
    set $P3590, $P3589["$SC"]
    unless_null $P3590, vivify_1863
    die "Contextual $*SC not found"
  vivify_1863:
  vivify_1862:
    find_dynamic_lex $P3593, "$*PACKAGE"
    unless_null $P3593, vivify_1864
    get_hll_global $P3591, "GLOBAL"
    get_who $P3592, $P3591
    set $P3593, $P3592["$PACKAGE"]
    unless_null $P3593, vivify_1865
    die "Contextual $*PACKAGE not found"
  vivify_1865:
  vivify_1864:
    $P3594 = $P3590."get_slot_past_for_object"($P3593)
    $P3595 = $P3581."new"($P3587, $P3594, "bind" :named("pasttype"))
.annotate 'line', 1258
    $P3577."push"($P3595)
.annotate 'line', 1267
    find_dynamic_lex $P3599, "$*HAS_YOU_ARE_HERE"
    unless_null $P3599, vivify_1866
    get_hll_global $P3597, "GLOBAL"
    get_who $P3598, $P3597
    set $P3599, $P3598["$HAS_YOU_ARE_HERE"]
    unless_null $P3599, vivify_1867
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1867:
  vivify_1866:
    if $P3599, unless_3596_end
.annotate 'line', 1268
    find_lex $P3600, "$unit"
    unless_null $P3600, vivify_1868
    new $P3600, "Undef"
  vivify_1868:
    find_lex $P3601, "self"
    $P3602 = $P3601."CTXSAVE"()
    $P3600."push"($P3602)
  unless_3596_end:
.annotate 'line', 1272
    find_lex $P3603, "$unit"
    unless_null $P3603, vivify_1869
    new $P3603, "Undef"
  vivify_1869:
    $P3603."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 1278
    find_lex $P3604, "$unit"
    unless_null $P3604, vivify_1870
    new $P3604, "Undef"
  vivify_1870:
    get_hll_global $P3605, "GLOBAL"
    nqp_get_package_through_who $P3606, $P3605, "PAST"
    get_who $P3607, $P3606
    set $P3608, $P3607["Var"]
    $P3609 = $P3608."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3604."unshift"($P3609)
.annotate 'line', 1279
    get_hll_global $P3610, "GLOBAL"
    nqp_get_package_through_who $P3611, $P3610, "PAST"
    get_who $P3612, $P3611
    set $P3613, $P3612["Stmts"]
.annotate 'line', 1280
    get_hll_global $P3614, "GLOBAL"
    nqp_get_package_through_who $P3615, $P3614, "PAST"
    get_who $P3616, $P3615
    set $P3617, $P3616["Op"]
    $P3618 = $P3617."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1281
    get_hll_global $P3619, "GLOBAL"
    nqp_get_package_through_who $P3620, $P3619, "PAST"
    get_who $P3621, $P3620
    set $P3622, $P3621["Op"]
.annotate 'line', 1283
    get_hll_global $P3623, "GLOBAL"
    nqp_get_package_through_who $P3624, $P3623, "PAST"
    get_who $P3625, $P3624
    set $P3626, $P3625["Var"]
    new $P3627, "ResizablePMCArray"
    $P3628 = $P3626."new"("ModuleLoader" :named("name"), $P3627 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1284
    get_hll_global $P3629, "GLOBAL"
    nqp_get_package_through_who $P3630, $P3629, "PAST"
    get_who $P3631, $P3630
    set $P3632, $P3631["Var"]
    get_hll_global $P3633, "GLOBAL"
    nqp_get_package_through_who $P3634, $P3633, "PAST"
    get_who $P3635, $P3634
    set $P3636, $P3635["Op"]
    $P3637 = $P3636."new"("getinterp P" :named("pirop"))
    $P3638 = $P3632."new"($P3637, "context", "keyed" :named("scope"))
    $P3639 = $P3622."new"($P3628, $P3638, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1281
    $P3640 = $P3613."new"($P3618, $P3639)
.annotate 'line', 1279
    store_lex "$main_tasks", $P3640
.annotate 'line', 1287
    find_dynamic_lex $P3644, "$*MAIN_SUB"
    unless_null $P3644, vivify_1871
    get_hll_global $P3642, "GLOBAL"
    get_who $P3643, $P3642
    set $P3644, $P3643["$MAIN_SUB"]
    unless_null $P3644, vivify_1872
    die "Contextual $*MAIN_SUB not found"
  vivify_1872:
  vivify_1871:
    unless $P3644, if_3641_end
.annotate 'line', 1288
    find_lex $P3645, "$main_tasks"
    unless_null $P3645, vivify_1873
    new $P3645, "Undef"
  vivify_1873:
    get_hll_global $P3646, "GLOBAL"
    nqp_get_package_through_who $P3647, $P3646, "PAST"
    get_who $P3648, $P3647
    set $P3649, $P3648["Op"]
.annotate 'line', 1289
    get_hll_global $P3650, "GLOBAL"
    nqp_get_package_through_who $P3651, $P3650, "PAST"
    get_who $P3652, $P3651
    set $P3653, $P3652["Val"]
    find_dynamic_lex $P3656, "$*MAIN_SUB"
    unless_null $P3656, vivify_1874
    get_hll_global $P3654, "GLOBAL"
    get_who $P3655, $P3654
    set $P3656, $P3655["$MAIN_SUB"]
    unless_null $P3656, vivify_1875
    die "Contextual $*MAIN_SUB not found"
  vivify_1875:
  vivify_1874:
    $P3657 = $P3653."new"($P3656 :named("value"))
.annotate 'line', 1290
    get_hll_global $P3658, "GLOBAL"
    nqp_get_package_through_who $P3659, $P3658, "PAST"
    get_who $P3660, $P3659
    set $P3661, $P3660["Var"]
    $P3662 = $P3661."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3663 = $P3649."new"($P3657, $P3662, "call" :named("pasttype"))
.annotate 'line', 1288
    $P3645."push"($P3663)
  if_3641_end:
.annotate 'line', 1293
    find_lex $P3664, "$mainline"
    unless_null $P3664, vivify_1876
    new $P3664, "Undef"
  vivify_1876:
    get_hll_global $P3665, "GLOBAL"
    nqp_get_package_through_who $P3666, $P3665, "PAST"
    get_who $P3667, $P3666
    set $P3668, $P3667["Op"]
.annotate 'line', 1295
    get_hll_global $P3669, "GLOBAL"
    nqp_get_package_through_who $P3670, $P3669, "PAST"
    get_who $P3671, $P3670
    set $P3672, $P3671["Var"]
    $P3673 = $P3672."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P3674, "$main_tasks"
    unless_null $P3674, vivify_1877
    new $P3674, "Undef"
  vivify_1877:
    $P3675 = $P3668."new"($P3673, $P3674, "if" :named("pasttype"))
.annotate 'line', 1293
    $P3664."push"($P3675)
.annotate 'line', 1302
    find_lex $P3676, "$unit"
    unless_null $P3676, vivify_1878
    new $P3676, "Undef"
  vivify_1878:
.annotate 'line', 1303
    get_hll_global $P3677, "GLOBAL"
    nqp_get_package_through_who $P3678, $P3677, "PAST"
    get_who $P3679, $P3678
    set $P3680, $P3679["Op"]
    find_lex $P3681, "$mainline"
    unless_null $P3681, vivify_1879
    new $P3681, "Undef"
  vivify_1879:
    $P3682 = $P3680."new"($P3681, "return" :named("pirop"))
    $P3676."push"($P3682)
.annotate 'line', 1308
    find_lex $P3683, "$unit"
    unless_null $P3683, vivify_1880
    new $P3683, "Undef"
  vivify_1880:
.annotate 'line', 1309
    get_hll_global $P3684, "GLOBAL"
    nqp_get_package_through_who $P3685, $P3684, "PAST"
    get_who $P3686, $P3685
    set $P3687, $P3686["Block"]
.annotate 'line', 1311
    get_hll_global $P3688, "GLOBAL"
    nqp_get_package_through_who $P3689, $P3688, "PAST"
    get_who $P3690, $P3689
    set $P3691, $P3690["Op"]
    get_hll_global $P3692, "GLOBAL"
    nqp_get_package_through_who $P3693, $P3692, "PAST"
    get_who $P3694, $P3693
    set $P3695, $P3694["Val"]
    find_lex $P3696, "$unit"
    unless_null $P3696, vivify_1881
    new $P3696, "Undef"
  vivify_1881:
    $P3697 = $P3695."new"($P3696 :named("value"))
    $P3698 = $P3691."new"($P3697, "call" :named("pasttype"))
    $P3699 = $P3687."new"($P3698, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1309
    $P3683."push"($P3699)
.annotate 'line', 1314
    find_lex $P3700, "$unit"
    unless_null $P3700, vivify_1882
    new $P3700, "Undef"
  vivify_1882:
    find_lex $P3701, "$/"
    unless_null $P3701, vivify_1883
    new $P3701, "Undef"
  vivify_1883:
    $P3700."node"($P3701)
.annotate 'line', 1317
    find_lex $P3702, "$unit"
    unless_null $P3702, vivify_1884
    new $P3702, "Undef"
  vivify_1884:
    $P3702."hll"("nqp")
.annotate 'line', 1319
    find_lex $P3703, "$/"
    find_lex $P3704, "$unit"
    unless_null $P3704, vivify_1885
    new $P3704, "Undef"
  vivify_1885:
    $P3705 = $P3703."!make"($P3704)
.annotate 'line', 1247
    .return ($P3705)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist" :anon :subid("465_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3707
    .param pmc param_3708
.annotate 'line', 1322
    .const 'Sub' $P3725 = "466_1305640955.436" 
    capture_lex $P3725
    .lex "self", param_3707
    .lex "$/", param_3708
.annotate 'line', 1323
    new $P3709, "Undef"
    .lex "$past", $P3709
    get_hll_global $P3710, "GLOBAL"
    nqp_get_package_through_who $P3711, $P3710, "PAST"
    get_who $P3712, $P3711
    set $P3713, $P3712["Stmts"]
    find_lex $P3714, "$/"
    unless_null $P3714, vivify_1886
    new $P3714, "Undef"
  vivify_1886:
    $P3715 = $P3713."new"($P3714 :named("node"))
    store_lex "$past", $P3715
.annotate 'line', 1324
    find_lex $P3717, "$/"
    unless_null $P3717, vivify_1887
    $P3717 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3718, $P3717["statement"]
    unless_null $P3718, vivify_1888
    new $P3718, "Undef"
  vivify_1888:
    unless $P3718, if_3716_end
.annotate 'line', 1325
    find_lex $P3720, "$/"
    unless_null $P3720, vivify_1889
    $P3720 = root_new ['parrot';'Hash']
  vivify_1889:
    set $P3721, $P3720["statement"]
    unless_null $P3721, vivify_1890
    new $P3721, "Undef"
  vivify_1890:
    defined $I3722, $P3721
    unless $I3722, for_undef_1891
    iter $P3719, $P3721
    new $P3745, 'ExceptionHandler'
    set_label $P3745, loop3744_handler
    $P3745."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3745
  loop3744_test:
    unless $P3719, loop3744_done
    shift $P3723, $P3719
  loop3744_redo:
    .const 'Sub' $P3725 = "466_1305640955.436" 
    capture_lex $P3725
    $P3725($P3723)
  loop3744_next:
    goto loop3744_test
  loop3744_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3746, exception, 'type'
    eq $P3746, .CONTROL_LOOP_NEXT, loop3744_next
    eq $P3746, .CONTROL_LOOP_REDO, loop3744_redo
  loop3744_done:
    pop_eh 
  for_undef_1891:
  if_3716_end:
.annotate 'line', 1332
    find_lex $P3747, "$/"
    find_lex $P3748, "$past"
    unless_null $P3748, vivify_1902
    new $P3748, "Undef"
  vivify_1902:
    $P3749 = $P3747."!make"($P3748)
.annotate 'line', 1322
    .return ($P3749)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3724"  :anon :subid("466_1305640955.436") :outer("465_1305640955.436")
    .param pmc param_3727
.annotate 'line', 1326
    new $P3726, "Undef"
    .lex "$ast", $P3726
    .lex "$_", param_3727
    find_lex $P3728, "$_"
    unless_null $P3728, vivify_1892
    new $P3728, "Undef"
  vivify_1892:
    $P3729 = $P3728."ast"()
    store_lex "$ast", $P3729
.annotate 'line', 1327
    find_lex $P3731, "$ast"
    unless_null $P3731, vivify_1893
    $P3731 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3732, $P3731["sink"]
    unless_null $P3732, vivify_1894
    new $P3732, "Undef"
  vivify_1894:
    defined $I3733, $P3732
    unless $I3733, if_3730_end
    find_lex $P3734, "$ast"
    unless_null $P3734, vivify_1895
    $P3734 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P3735, $P3734["sink"]
    unless_null $P3735, vivify_1896
    new $P3735, "Undef"
  vivify_1896:
    store_lex "$ast", $P3735
  if_3730_end:
.annotate 'line', 1328
    find_lex $P3737, "$ast"
    unless_null $P3737, vivify_1897
    $P3737 = root_new ['parrot';'Hash']
  vivify_1897:
    set $P3738, $P3737["bareblock"]
    unless_null $P3738, vivify_1898
    new $P3738, "Undef"
  vivify_1898:
    unless $P3738, if_3736_end
    find_lex $P3739, "$ast"
    unless_null $P3739, vivify_1899
    new $P3739, "Undef"
  vivify_1899:
    $P3740 = "block_immediate"($P3739)
    store_lex "$ast", $P3740
  if_3736_end:
.annotate 'line', 1329
    find_lex $P3741, "$past"
    unless_null $P3741, vivify_1900
    new $P3741, "Undef"
  vivify_1900:
    find_lex $P3742, "$ast"
    unless_null $P3742, vivify_1901
    new $P3742, "Undef"
  vivify_1901:
    $P3743 = $P3741."push"($P3742)
.annotate 'line', 1325
    .return ($P3743)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement" :anon :subid("467_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3751
    .param pmc param_3752
    .param pmc param_3753 :optional
    .param int has_param_3753 :opt_flag
.annotate 'line', 1335
    .const 'Sub' $P3761 = "468_1305640955.436" 
    capture_lex $P3761
    .lex "self", param_3751
    .lex "$/", param_3752
    if has_param_3753, optparam_1903
    new $P3754, "Undef"
    set param_3753, $P3754
  optparam_1903:
    .lex "$key", param_3753
.annotate 'line', 1336
    new $P3755, "Undef"
    .lex "$past", $P3755
.annotate 'line', 1335
    find_lex $P3756, "$past"
    unless_null $P3756, vivify_1904
    new $P3756, "Undef"
  vivify_1904:
.annotate 'line', 1337
    find_lex $P3758, "$/"
    unless_null $P3758, vivify_1905
    $P3758 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3759, $P3758["EXPR"]
    unless_null $P3759, vivify_1906
    new $P3759, "Undef"
  vivify_1906:
    if $P3759, if_3757
.annotate 'line', 1358
    find_lex $P3837, "$/"
    unless_null $P3837, vivify_1907
    $P3837 = root_new ['parrot';'Hash']
  vivify_1907:
    set $P3838, $P3837["statement_control"]
    unless_null $P3838, vivify_1908
    new $P3838, "Undef"
  vivify_1908:
    if $P3838, if_3836
.annotate 'line', 1359
    new $P3842, "Integer"
    assign $P3842, 0
    store_lex "$past", $P3842
    goto if_3836_end
  if_3836:
.annotate 'line', 1358
    find_lex $P3839, "$/"
    unless_null $P3839, vivify_1909
    $P3839 = root_new ['parrot';'Hash']
  vivify_1909:
    set $P3840, $P3839["statement_control"]
    unless_null $P3840, vivify_1910
    new $P3840, "Undef"
  vivify_1910:
    $P3841 = $P3840."ast"()
    store_lex "$past", $P3841
  if_3836_end:
    goto if_3757_end
  if_3757:
.annotate 'line', 1337
    .const 'Sub' $P3761 = "468_1305640955.436" 
    capture_lex $P3761
    $P3761()
  if_3757_end:
.annotate 'line', 1360
    find_lex $P3843, "$/"
    find_lex $P3844, "$past"
    unless_null $P3844, vivify_1944
    new $P3844, "Undef"
  vivify_1944:
    $P3845 = $P3843."!make"($P3844)
.annotate 'line', 1335
    .return ($P3845)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3760"  :anon :subid("468_1305640955.436") :outer("467_1305640955.436")
.annotate 'line', 1338
    new $P3762, "Undef"
    .lex "$mc", $P3762
.annotate 'line', 1339
    new $P3763, "Undef"
    .lex "$ml", $P3763
.annotate 'line', 1338
    find_lex $P3764, "$/"
    unless_null $P3764, vivify_1911
    $P3764 = root_new ['parrot';'Hash']
  vivify_1911:
    set $P3765, $P3764["statement_mod_cond"]
    unless_null $P3765, vivify_1912
    $P3765 = root_new ['parrot';'ResizablePMCArray']
  vivify_1912:
    set $P3766, $P3765[0]
    unless_null $P3766, vivify_1913
    new $P3766, "Undef"
  vivify_1913:
    store_lex "$mc", $P3766
.annotate 'line', 1339
    find_lex $P3767, "$/"
    unless_null $P3767, vivify_1914
    $P3767 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P3768, $P3767["statement_mod_loop"]
    unless_null $P3768, vivify_1915
    $P3768 = root_new ['parrot';'ResizablePMCArray']
  vivify_1915:
    set $P3769, $P3768[0]
    unless_null $P3769, vivify_1916
    new $P3769, "Undef"
  vivify_1916:
    store_lex "$ml", $P3769
.annotate 'line', 1340
    find_lex $P3770, "$/"
    unless_null $P3770, vivify_1917
    $P3770 = root_new ['parrot';'Hash']
  vivify_1917:
    set $P3771, $P3770["EXPR"]
    unless_null $P3771, vivify_1918
    new $P3771, "Undef"
  vivify_1918:
    $P3772 = $P3771."ast"()
    store_lex "$past", $P3772
.annotate 'line', 1341
    find_lex $P3774, "$mc"
    unless_null $P3774, vivify_1919
    new $P3774, "Undef"
  vivify_1919:
    unless $P3774, if_3773_end
.annotate 'line', 1342
    get_hll_global $P3775, "GLOBAL"
    nqp_get_package_through_who $P3776, $P3775, "PAST"
    get_who $P3777, $P3776
    set $P3778, $P3777["Op"]
    find_lex $P3779, "$mc"
    unless_null $P3779, vivify_1920
    $P3779 = root_new ['parrot';'Hash']
  vivify_1920:
    set $P3780, $P3779["cond"]
    unless_null $P3780, vivify_1921
    new $P3780, "Undef"
  vivify_1921:
    $P3781 = $P3780."ast"()
    find_lex $P3782, "$past"
    unless_null $P3782, vivify_1922
    new $P3782, "Undef"
  vivify_1922:
    find_lex $P3783, "$mc"
    unless_null $P3783, vivify_1923
    $P3783 = root_new ['parrot';'Hash']
  vivify_1923:
    set $P3784, $P3783["sym"]
    unless_null $P3784, vivify_1924
    new $P3784, "Undef"
  vivify_1924:
    set $S3785, $P3784
    find_lex $P3786, "$/"
    unless_null $P3786, vivify_1925
    new $P3786, "Undef"
  vivify_1925:
    $P3787 = $P3778."new"($P3781, $P3782, $S3785 :named("pasttype"), $P3786 :named("node"))
    store_lex "$past", $P3787
  if_3773_end:
.annotate 'line', 1344
    find_lex $P3790, "$ml"
    unless_null $P3790, vivify_1926
    new $P3790, "Undef"
  vivify_1926:
    if $P3790, if_3789
    set $P3788, $P3790
    goto if_3789_end
  if_3789:
.annotate 'line', 1345
    find_lex $P3793, "$ml"
    unless_null $P3793, vivify_1927
    $P3793 = root_new ['parrot';'Hash']
  vivify_1927:
    set $P3794, $P3793["sym"]
    unless_null $P3794, vivify_1928
    new $P3794, "Undef"
  vivify_1928:
    set $S3795, $P3794
    iseq $I3796, $S3795, "for"
    if $I3796, if_3792
.annotate 'line', 1354
    get_hll_global $P3823, "GLOBAL"
    nqp_get_package_through_who $P3824, $P3823, "PAST"
    get_who $P3825, $P3824
    set $P3826, $P3825["Op"]
    find_lex $P3827, "$ml"
    unless_null $P3827, vivify_1929
    $P3827 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P3828, $P3827["cond"]
    unless_null $P3828, vivify_1930
    new $P3828, "Undef"
  vivify_1930:
    $P3829 = $P3828."ast"()
    find_lex $P3830, "$past"
    unless_null $P3830, vivify_1931
    new $P3830, "Undef"
  vivify_1931:
    find_lex $P3831, "$ml"
    unless_null $P3831, vivify_1932
    $P3831 = root_new ['parrot';'Hash']
  vivify_1932:
    set $P3832, $P3831["sym"]
    unless_null $P3832, vivify_1933
    new $P3832, "Undef"
  vivify_1933:
    set $S3833, $P3832
    find_lex $P3834, "$/"
    unless_null $P3834, vivify_1934
    new $P3834, "Undef"
  vivify_1934:
    $P3835 = $P3826."new"($P3829, $P3830, $S3833 :named("pasttype"), $P3834 :named("node"))
    store_lex "$past", $P3835
.annotate 'line', 1353
    set $P3791, $P3835
.annotate 'line', 1345
    goto if_3792_end
  if_3792:
.annotate 'line', 1346
    get_hll_global $P3797, "GLOBAL"
    nqp_get_package_through_who $P3798, $P3797, "PAST"
    get_who $P3799, $P3798
    set $P3800, $P3799["Block"]
.annotate 'line', 1347
    get_hll_global $P3801, "GLOBAL"
    nqp_get_package_through_who $P3802, $P3801, "PAST"
    get_who $P3803, $P3802
    set $P3804, $P3803["Var"]
    $P3805 = $P3804."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3806, "$past"
    unless_null $P3806, vivify_1935
    new $P3806, "Undef"
  vivify_1935:
    $P3807 = $P3800."new"($P3805, $P3806, "immediate" :named("blocktype"))
.annotate 'line', 1346
    store_lex "$past", $P3807
.annotate 'line', 1349
    find_lex $P3808, "$past"
    unless_null $P3808, vivify_1936
    new $P3808, "Undef"
  vivify_1936:
    $P3808."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1350
    find_lex $P3809, "$past"
    unless_null $P3809, vivify_1937
    new $P3809, "Undef"
  vivify_1937:
    $P3809."arity"(1)
.annotate 'line', 1351
    get_hll_global $P3810, "GLOBAL"
    nqp_get_package_through_who $P3811, $P3810, "PAST"
    get_who $P3812, $P3811
    set $P3813, $P3812["Op"]
    find_lex $P3814, "$ml"
    unless_null $P3814, vivify_1938
    $P3814 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P3815, $P3814["cond"]
    unless_null $P3815, vivify_1939
    new $P3815, "Undef"
  vivify_1939:
    $P3816 = $P3815."ast"()
    find_lex $P3817, "$past"
    unless_null $P3817, vivify_1940
    new $P3817, "Undef"
  vivify_1940:
    find_lex $P3818, "$ml"
    unless_null $P3818, vivify_1941
    $P3818 = root_new ['parrot';'Hash']
  vivify_1941:
    set $P3819, $P3818["sym"]
    unless_null $P3819, vivify_1942
    new $P3819, "Undef"
  vivify_1942:
    set $S3820, $P3819
    find_lex $P3821, "$/"
    unless_null $P3821, vivify_1943
    new $P3821, "Undef"
  vivify_1943:
    $P3822 = $P3813."new"($P3816, $P3817, $S3820 :named("pasttype"), $P3821 :named("node"))
    store_lex "$past", $P3822
.annotate 'line', 1345
    set $P3791, $P3822
  if_3792_end:
.annotate 'line', 1344
    set $P3788, $P3791
  if_3789_end:
.annotate 'line', 1337
    .return ($P3788)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock" :anon :subid("469_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3847
    .param pmc param_3848
.annotate 'line', 1363
    .lex "self", param_3847
    .lex "$/", param_3848
.annotate 'line', 1364
    find_lex $P3849, "$/"
    get_hll_global $P3850, "GLOBAL"
    nqp_get_package_through_who $P3851, $P3850, "PAST"
    get_who $P3852, $P3851
    set $P3853, $P3852["Op"]
    find_lex $P3854, "$/"
    unless_null $P3854, vivify_1945
    $P3854 = root_new ['parrot';'Hash']
  vivify_1945:
    set $P3855, $P3854["EXPR"]
    unless_null $P3855, vivify_1946
    new $P3855, "Undef"
  vivify_1946:
    $P3856 = $P3855."ast"()
    find_lex $P3857, "$/"
    unless_null $P3857, vivify_1947
    $P3857 = root_new ['parrot';'Hash']
  vivify_1947:
    set $P3858, $P3857["pblock"]
    unless_null $P3858, vivify_1948
    new $P3858, "Undef"
  vivify_1948:
    $P3859 = $P3858."ast"()
    find_lex $P3860, "$/"
    unless_null $P3860, vivify_1949
    new $P3860, "Undef"
  vivify_1949:
    $P3861 = $P3853."new"($P3856, $P3859, "if" :named("pasttype"), $P3860 :named("node"))
    $P3862 = $P3849."!make"($P3861)
.annotate 'line', 1363
    .return ($P3862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock" :anon :subid("470_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3864
    .param pmc param_3865
.annotate 'line', 1367
    .lex "self", param_3864
    .lex "$/", param_3865
.annotate 'line', 1368
    find_lex $P3866, "$/"
    find_lex $P3867, "$/"
    unless_null $P3867, vivify_1950
    $P3867 = root_new ['parrot';'Hash']
  vivify_1950:
    set $P3868, $P3867["blockoid"]
    unless_null $P3868, vivify_1951
    new $P3868, "Undef"
  vivify_1951:
    $P3869 = $P3868."ast"()
    $P3870 = $P3866."!make"($P3869)
.annotate 'line', 1367
    .return ($P3870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block" :anon :subid("471_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3872
    .param pmc param_3873
.annotate 'line', 1371
    .lex "self", param_3872
    .lex "$/", param_3873
.annotate 'line', 1372
    find_lex $P3874, "$/"
    find_lex $P3875, "$/"
    unless_null $P3875, vivify_1952
    $P3875 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P3876, $P3875["blockoid"]
    unless_null $P3876, vivify_1953
    new $P3876, "Undef"
  vivify_1953:
    $P3877 = $P3876."ast"()
    $P3878 = $P3874."!make"($P3877)
.annotate 'line', 1371
    .return ($P3878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid" :anon :subid("472_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3880
    .param pmc param_3881
.annotate 'line', 1375
    .const 'Sub' $P3892 = "473_1305640955.436" 
    capture_lex $P3892
    .lex "self", param_3880
    .lex "$/", param_3881
.annotate 'line', 1376
    new $P3882, "Undef"
    .lex "$BLOCK", $P3882
    find_lex $P3883, "$?PACKAGE"
    get_who $P3884, $P3883
    set $P3885, $P3884["@BLOCK"]
    unless_null $P3885, vivify_1954
    $P3885 = root_new ['parrot';'ResizablePMCArray']
  vivify_1954:
    $P3886 = $P3885."shift"()
    store_lex "$BLOCK", $P3886
.annotate 'line', 1377
    find_lex $P3889, "$/"
    unless_null $P3889, vivify_1955
    $P3889 = root_new ['parrot';'Hash']
  vivify_1955:
    set $P3890, $P3889["statementlist"]
    unless_null $P3890, vivify_1956
    new $P3890, "Undef"
  vivify_1956:
    if $P3890, if_3888
.annotate 'line', 1385
    find_dynamic_lex $P3909, "$*HAS_YOU_ARE_HERE"
    unless_null $P3909, vivify_1957
    get_hll_global $P3907, "GLOBAL"
    get_who $P3908, $P3907
    set $P3909, $P3908["$HAS_YOU_ARE_HERE"]
    unless_null $P3909, vivify_1958
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1958:
  vivify_1957:
    unless $P3909, if_3906_end
.annotate 'line', 1386
    find_lex $P3910, "$/"
    unless_null $P3910, vivify_1959
    new $P3910, "Undef"
  vivify_1959:
    $P3911 = $P3910."CURSOR"()
    $P3911."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3906_end:
.annotate 'line', 1388
    new $P3912, "Integer"
    assign $P3912, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3912
.annotate 'line', 1389
    find_lex $P3913, "$/"
    find_lex $P3914, "$/"
    unless_null $P3914, vivify_1960
    $P3914 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P3915, $P3914["you_are_here"]
    unless_null $P3915, vivify_1961
    new $P3915, "Undef"
  vivify_1961:
    $P3916 = $P3915."ast"()
    $P3917 = $P3913."!make"($P3916)
.annotate 'line', 1384
    set $P3887, $P3917
.annotate 'line', 1377
    goto if_3888_end
  if_3888:
    .const 'Sub' $P3892 = "473_1305640955.436" 
    capture_lex $P3892
    $P3905 = $P3892()
    set $P3887, $P3905
  if_3888_end:
.annotate 'line', 1375
    .return ($P3887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3891"  :anon :subid("473_1305640955.436") :outer("472_1305640955.436")
.annotate 'line', 1378
    new $P3893, "Undef"
    .lex "$past", $P3893
    find_lex $P3894, "$/"
    unless_null $P3894, vivify_1962
    $P3894 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P3895, $P3894["statementlist"]
    unless_null $P3895, vivify_1963
    new $P3895, "Undef"
  vivify_1963:
    $P3896 = $P3895."ast"()
    store_lex "$past", $P3896
.annotate 'line', 1379
    find_lex $P3897, "$BLOCK"
    unless_null $P3897, vivify_1964
    new $P3897, "Undef"
  vivify_1964:
    find_lex $P3898, "$past"
    unless_null $P3898, vivify_1965
    new $P3898, "Undef"
  vivify_1965:
    $P3897."push"($P3898)
.annotate 'line', 1380
    find_lex $P3899, "$BLOCK"
    unless_null $P3899, vivify_1966
    new $P3899, "Undef"
  vivify_1966:
    find_lex $P3900, "$/"
    unless_null $P3900, vivify_1967
    new $P3900, "Undef"
  vivify_1967:
    $P3899."node"($P3900)
.annotate 'line', 1381
    find_lex $P3901, "$BLOCK"
    unless_null $P3901, vivify_1968
    new $P3901, "Undef"
  vivify_1968:
    $P3901."closure"(1)
.annotate 'line', 1382
    find_dynamic_lex $P3902, "$/"
    find_lex $P3903, "$BLOCK"
    unless_null $P3903, vivify_1969
    new $P3903, "Undef"
  vivify_1969:
    $P3904 = $P3902."!make"($P3903)
.annotate 'line', 1377
    .return ($P3904)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad" :anon :subid("474_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3919
    .param pmc param_3920
.annotate 'line', 1393
    .lex "self", param_3919
    .lex "$/", param_3920
.annotate 'line', 1394
    find_lex $P3921, "$?PACKAGE"
    get_who $P3922, $P3921
    set $P3923, $P3922["@BLOCK"]
    unless_null $P3923, vivify_1970
    $P3923 = root_new ['parrot';'ResizablePMCArray']
  vivify_1970:
    get_hll_global $P3924, "GLOBAL"
    nqp_get_package_through_who $P3925, $P3924, "PAST"
    get_who $P3926, $P3925
    set $P3927, $P3926["Block"]
    get_hll_global $P3928, "GLOBAL"
    nqp_get_package_through_who $P3929, $P3928, "PAST"
    get_who $P3930, $P3929
    set $P3931, $P3930["Stmts"]
    $P3932 = $P3931."new"()
    $P3933 = $P3927."new"($P3932)
    $P3934 = $P3923."unshift"($P3933)
.annotate 'line', 1393
    .return ($P3934)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx" :anon :subid("475_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3936
    .param pmc param_3937
.annotate 'line', 1397
    .const 'Sub' $P3946 = "476_1305640955.436" 
    capture_lex $P3946
    .lex "self", param_3936
    .lex "$/", param_3937
.annotate 'line', 1398
    find_dynamic_lex $P3941, "%*COMPILING"
    unless_null $P3941, vivify_1971
    get_hll_global $P3939, "GLOBAL"
    get_who $P3940, $P3939
    set $P3941, $P3940["%COMPILING"]
    unless_null $P3941, vivify_1972
    die "Contextual %*COMPILING not found"
  vivify_1972:
  vivify_1971:
    set $P3942, $P3941["%?OPTIONS"]
    unless_null $P3942, vivify_1973
    $P3942 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P3943, $P3942["outer_ctx"]
    unless_null $P3943, vivify_1974
    new $P3943, "Undef"
  vivify_1974:
    defined $I3944, $P3943
    if $I3944, unless_3938_end
    .const 'Sub' $P3946 = "476_1305640955.436" 
    capture_lex $P3946
    $P3946()
  unless_3938_end:
.annotate 'line', 1411
    find_lex $P3978, "self"
    find_lex $P3979, "$?PACKAGE"
    get_who $P3980, $P3979
    set $P3981, $P3980["@BLOCK"]
    unless_null $P3981, vivify_1990
    $P3981 = root_new ['parrot';'ResizablePMCArray']
  vivify_1990:
    set $P3982, $P3981[0]
    unless_null $P3982, vivify_1991
    new $P3982, "Undef"
  vivify_1991:
    $P3983 = $P3978."SET_BLOCK_OUTER_CTX"($P3982)
.annotate 'line', 1397
    .return ($P3983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3945"  :anon :subid("476_1305640955.436") :outer("475_1305640955.436")
.annotate 'line', 1401
    new $P3947, "Undef"
    .lex "$SETTING", $P3947
    find_dynamic_lex $P3950, "$*SC"
    unless_null $P3950, vivify_1975
    get_hll_global $P3948, "GLOBAL"
    get_who $P3949, $P3948
    set $P3950, $P3949["$SC"]
    unless_null $P3950, vivify_1976
    die "Contextual $*SC not found"
  vivify_1976:
  vivify_1975:
    find_dynamic_lex $P3954, "%*COMPILING"
    unless_null $P3954, vivify_1977
    get_hll_global $P3952, "GLOBAL"
    get_who $P3953, $P3952
    set $P3954, $P3953["%COMPILING"]
    unless_null $P3954, vivify_1978
    die "Contextual %*COMPILING not found"
  vivify_1978:
  vivify_1977:
    set $P3955, $P3954["%?OPTIONS"]
    unless_null $P3955, vivify_1979
    $P3955 = root_new ['parrot';'Hash']
  vivify_1979:
    set $P3956, $P3955["setting"]
    unless_null $P3956, vivify_1980
    new $P3956, "Undef"
  vivify_1980:
    set $P3951, $P3956
    defined $I3958, $P3951
    if $I3958, default_3957
    new $P3959, "String"
    assign $P3959, "NQPCORE"
    set $P3951, $P3959
  default_3957:
    $P3960 = $P3950."load_setting"($P3951)
    store_lex "$SETTING", $P3960
.annotate 'line', 1406
    find_dynamic_lex $P3965, "%*COMPILING"
    unless_null $P3965, vivify_1981
    get_hll_global $P3963, "GLOBAL"
    get_who $P3964, $P3963
    set $P3965, $P3964["%COMPILING"]
    unless_null $P3965, vivify_1982
    die "Contextual %*COMPILING not found"
  vivify_1982:
  vivify_1981:
    set $P3966, $P3965["%?OPTIONS"]
    unless_null $P3966, vivify_1983
    $P3966 = root_new ['parrot';'Hash']
  vivify_1983:
    set $P3967, $P3966["setting"]
    unless_null $P3967, vivify_1984
    new $P3967, "Undef"
  vivify_1984:
    set $S3968, $P3967
    iseq $I3969, $S3968, "NULL"
    unless $I3969, unless_3962
    new $P3961, 'Integer'
    set $P3961, $I3969
    goto unless_3962_end
  unless_3962:
.annotate 'line', 1407
    find_lex $P3970, "$SETTING"
    unless_null $P3970, vivify_1985
    new $P3970, "Undef"
  vivify_1985:
    "import_HOW_exports"($P3970)
.annotate 'line', 1408
    find_dynamic_lex $P3973, "$*SC"
    unless_null $P3973, vivify_1986
    get_hll_global $P3971, "GLOBAL"
    get_who $P3972, $P3971
    set $P3973, $P3972["$SC"]
    unless_null $P3973, vivify_1987
    die "Contextual $*SC not found"
  vivify_1987:
  vivify_1986:
    find_dynamic_lex $P3976, "$*GLOBALish"
    unless_null $P3976, vivify_1988
    get_hll_global $P3974, "GLOBAL"
    get_who $P3975, $P3974
    set $P3976, $P3975["$GLOBALish"]
    unless_null $P3976, vivify_1989
    die "Contextual $*GLOBALish not found"
  vivify_1989:
  vivify_1988:
    $P3977 = $P3973."load_module"("NQPRegex", $P3976)
.annotate 'line', 1406
    set $P3961, $P3977
  unless_3962_end:
.annotate 'line', 1398
    .return ($P3961)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish" :anon :subid("477_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_3986
    .param pmc param_3987
.annotate 'line', 1423
    .lex "self", param_3986
    .lex "$/", param_3987
.annotate 'line', 1427
    find_dynamic_lex $P3990, "$*SC"
    unless_null $P3990, vivify_1992
    get_hll_global $P3988, "GLOBAL"
    get_who $P3989, $P3988
    set $P3990, $P3989["$SC"]
    unless_null $P3990, vivify_1993
    die "Contextual $*SC not found"
  vivify_1993:
  vivify_1992:
    find_dynamic_lex $P3993, "%*HOW"
    unless_null $P3993, vivify_1994
    get_hll_global $P3991, "GLOBAL"
    get_who $P3992, $P3991
    set $P3993, $P3992["%HOW"]
    unless_null $P3993, vivify_1995
    die "Contextual %*HOW not found"
  vivify_1995:
  vivify_1994:
    set $P3994, $P3993["knowhow"]
    unless_null $P3994, vivify_1996
    new $P3994, "Undef"
  vivify_1996:
    $P3995 = $P3990."pkg_create_mo"($P3994, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3995
.annotate 'line', 1428
    find_dynamic_lex $P3998, "$*GLOBALish"
    unless_null $P3998, vivify_1997
    get_hll_global $P3996, "GLOBAL"
    get_who $P3997, $P3996
    set $P3998, $P3997["$GLOBALish"]
    unless_null $P3998, vivify_1998
    die "Contextual $*GLOBALish not found"
  vivify_1998:
  vivify_1997:
    get_how $P3999, $P3998
    find_dynamic_lex $P4002, "$*GLOBALish"
    unless_null $P4002, vivify_1999
    get_hll_global $P4000, "GLOBAL"
    get_who $P4001, $P4000
    set $P4002, $P4001["$GLOBALish"]
    unless_null $P4002, vivify_2000
    die "Contextual $*GLOBALish not found"
  vivify_2000:
  vivify_1999:
    $P3999."compose"($P4002)
.annotate 'line', 1429
    find_dynamic_lex $P4005, "$*SC"
    unless_null $P4005, vivify_2001
    get_hll_global $P4003, "GLOBAL"
    get_who $P4004, $P4003
    set $P4005, $P4004["$SC"]
    unless_null $P4005, vivify_2002
    die "Contextual $*SC not found"
  vivify_2002:
  vivify_2001:
    find_lex $P4006, "$?PACKAGE"
    get_who $P4007, $P4006
    set $P4008, $P4007["@BLOCK"]
    unless_null $P4008, vivify_2003
    $P4008 = root_new ['parrot';'ResizablePMCArray']
  vivify_2003:
    set $P4009, $P4008[0]
    unless_null $P4009, vivify_2004
    new $P4009, "Undef"
  vivify_2004:
    find_dynamic_lex $P4012, "$*GLOBALish"
    unless_null $P4012, vivify_2005
    get_hll_global $P4010, "GLOBAL"
    get_who $P4011, $P4010
    set $P4012, $P4011["$GLOBALish"]
    unless_null $P4012, vivify_2006
    die "Contextual $*GLOBALish not found"
  vivify_2006:
  vivify_2005:
    $P4005."install_lexical_symbol"($P4009, "GLOBALish", $P4012)
.annotate 'line', 1432
    find_dynamic_lex $P4015, "$*GLOBALish"
    unless_null $P4015, vivify_2007
    get_hll_global $P4013, "GLOBAL"
    get_who $P4014, $P4013
    set $P4015, $P4014["$GLOBALish"]
    unless_null $P4015, vivify_2008
    die "Contextual $*GLOBALish not found"
  vivify_2008:
  vivify_2007:
    store_dynamic_lex "$*PACKAGE", $P4015
.annotate 'line', 1433
    find_dynamic_lex $P4018, "$*SC"
    unless_null $P4018, vivify_2009
    get_hll_global $P4016, "GLOBAL"
    get_who $P4017, $P4016
    set $P4018, $P4017["$SC"]
    unless_null $P4018, vivify_2010
    die "Contextual $*SC not found"
  vivify_2010:
  vivify_2009:
    find_lex $P4019, "$?PACKAGE"
    get_who $P4020, $P4019
    set $P4021, $P4020["@BLOCK"]
    unless_null $P4021, vivify_2011
    $P4021 = root_new ['parrot';'ResizablePMCArray']
  vivify_2011:
    set $P4022, $P4021[0]
    unless_null $P4022, vivify_2012
    new $P4022, "Undef"
  vivify_2012:
    find_dynamic_lex $P4025, "$*PACKAGE"
    unless_null $P4025, vivify_2013
    get_hll_global $P4023, "GLOBAL"
    get_who $P4024, $P4023
    set $P4025, $P4024["$PACKAGE"]
    unless_null $P4025, vivify_2014
    die "Contextual $*PACKAGE not found"
  vivify_2014:
  vivify_2013:
    $P4026 = $P4018."install_lexical_symbol"($P4022, "$?PACKAGE", $P4025)
.annotate 'line', 1423
    .return ($P4026)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here" :anon :subid("478_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4028
    .param pmc param_4029
.annotate 'line', 1436
    .lex "self", param_4028
    .lex "$/", param_4029
.annotate 'line', 1437
    find_lex $P4030, "$/"
    find_lex $P4031, "self"
    $P4032 = $P4031."CTXSAVE"()
    $P4033 = $P4030."!make"($P4032)
.annotate 'line', 1436
    .return ($P4033)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>" :anon :subid("479_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4035
    .param pmc param_4036
.annotate 'line', 1442
    .lex "self", param_4035
    .lex "$/", param_4036
.annotate 'line', 1443
    new $P4037, "Undef"
    .lex "$module", $P4037
    find_dynamic_lex $P4040, "$*SC"
    unless_null $P4040, vivify_2015
    get_hll_global $P4038, "GLOBAL"
    get_who $P4039, $P4038
    set $P4040, $P4039["$SC"]
    unless_null $P4040, vivify_2016
    die "Contextual $*SC not found"
  vivify_2016:
  vivify_2015:
    find_lex $P4041, "$/"
    unless_null $P4041, vivify_2017
    $P4041 = root_new ['parrot';'Hash']
  vivify_2017:
    set $P4042, $P4041["name"]
    unless_null $P4042, vivify_2018
    new $P4042, "Undef"
  vivify_2018:
    set $S4043, $P4042
    find_dynamic_lex $P4046, "$*GLOBALish"
    unless_null $P4046, vivify_2019
    get_hll_global $P4044, "GLOBAL"
    get_who $P4045, $P4044
    set $P4046, $P4045["$GLOBALish"]
    unless_null $P4046, vivify_2020
    die "Contextual $*GLOBALish not found"
  vivify_2020:
  vivify_2019:
    $P4047 = $P4040."load_module"($S4043, $P4046)
    store_lex "$module", $P4047
.annotate 'line', 1444
    find_lex $P4049, "$module"
    unless_null $P4049, vivify_2021
    new $P4049, "Undef"
  vivify_2021:
    defined $I4050, $P4049
    unless $I4050, if_4048_end
.annotate 'line', 1445
    find_lex $P4051, "$module"
    unless_null $P4051, vivify_2022
    new $P4051, "Undef"
  vivify_2022:
    "import_HOW_exports"($P4051)
  if_4048_end:
.annotate 'line', 1447
    find_lex $P4052, "$/"
    get_hll_global $P4053, "GLOBAL"
    nqp_get_package_through_who $P4054, $P4053, "PAST"
    get_who $P4055, $P4054
    set $P4056, $P4055["Stmts"]
    $P4057 = $P4056."new"()
    $P4058 = $P4052."!make"($P4057)
.annotate 'line', 1442
    .return ($P4058)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>" :anon :subid("480_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4060
    .param pmc param_4061
.annotate 'line', 1450
    .const 'Sub' $P4089 = "481_1305640955.436" 
    capture_lex $P4089
    .lex "self", param_4060
    .lex "$/", param_4061
.annotate 'line', 1451
    new $P4062, "Undef"
    .lex "$count", $P4062
.annotate 'line', 1452
    new $P4063, "Undef"
    .lex "$past", $P4063
.annotate 'line', 1451
    find_lex $P4064, "$/"
    unless_null $P4064, vivify_2023
    $P4064 = root_new ['parrot';'Hash']
  vivify_2023:
    set $P4065, $P4064["xblock"]
    unless_null $P4065, vivify_2024
    new $P4065, "Undef"
  vivify_2024:
    set $N4066, $P4065
    new $P4067, 'Float'
    set $P4067, $N4066
    sub $P4068, $P4067, 1
    store_lex "$count", $P4068
.annotate 'line', 1452
    find_lex $P4069, "$count"
    unless_null $P4069, vivify_2025
    new $P4069, "Undef"
  vivify_2025:
    set $I4070, $P4069
    find_lex $P4071, "$/"
    unless_null $P4071, vivify_2026
    $P4071 = root_new ['parrot';'Hash']
  vivify_2026:
    set $P4072, $P4071["xblock"]
    unless_null $P4072, vivify_2027
    $P4072 = root_new ['parrot';'ResizablePMCArray']
  vivify_2027:
    set $P4073, $P4072[$I4070]
    unless_null $P4073, vivify_2028
    new $P4073, "Undef"
  vivify_2028:
    $P4074 = $P4073."ast"()
    $P4075 = "xblock_immediate"($P4074)
    store_lex "$past", $P4075
.annotate 'line', 1453
    find_lex $P4077, "$/"
    unless_null $P4077, vivify_2029
    $P4077 = root_new ['parrot';'Hash']
  vivify_2029:
    set $P4078, $P4077["else"]
    unless_null $P4078, vivify_2030
    new $P4078, "Undef"
  vivify_2030:
    unless $P4078, if_4076_end
.annotate 'line', 1454
    find_lex $P4079, "$past"
    unless_null $P4079, vivify_2031
    new $P4079, "Undef"
  vivify_2031:
    find_lex $P4080, "$/"
    unless_null $P4080, vivify_2032
    $P4080 = root_new ['parrot';'Hash']
  vivify_2032:
    set $P4081, $P4080["else"]
    unless_null $P4081, vivify_2033
    $P4081 = root_new ['parrot';'ResizablePMCArray']
  vivify_2033:
    set $P4082, $P4081[0]
    unless_null $P4082, vivify_2034
    new $P4082, "Undef"
  vivify_2034:
    $P4083 = $P4082."ast"()
    $P4084 = "block_immediate"($P4083)
    $P4079."push"($P4084)
  if_4076_end:
.annotate 'line', 1457
    new $P4105, 'ExceptionHandler'
    set_label $P4105, loop4104_handler
    $P4105."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4105
  loop4104_test:
    find_lex $P4085, "$count"
    unless_null $P4085, vivify_2035
    new $P4085, "Undef"
  vivify_2035:
    set $N4086, $P4085
    isgt $I4087, $N4086, 0.0
    unless $I4087, loop4104_done
  loop4104_redo:
    .const 'Sub' $P4089 = "481_1305640955.436" 
    capture_lex $P4089
    $P4089()
  loop4104_next:
    goto loop4104_test
  loop4104_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4106, exception, 'type'
    eq $P4106, .CONTROL_LOOP_NEXT, loop4104_next
    eq $P4106, .CONTROL_LOOP_REDO, loop4104_redo
  loop4104_done:
    pop_eh 
.annotate 'line', 1463
    find_lex $P4107, "$/"
    find_lex $P4108, "$past"
    unless_null $P4108, vivify_2044
    new $P4108, "Undef"
  vivify_2044:
    $P4109 = $P4107."!make"($P4108)
.annotate 'line', 1450
    .return ($P4109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4088"  :anon :subid("481_1305640955.436") :outer("480_1305640955.436")
.annotate 'line', 1459
    new $P4090, "Undef"
    .lex "$else", $P4090
.annotate 'line', 1457
    find_lex $P4091, "$count"
    unless_null $P4091, vivify_2036
    new $P4091, "Undef"
  vivify_2036:
    clone $P4092, $P4091
    dec $P4091
.annotate 'line', 1459
    find_lex $P4093, "$past"
    unless_null $P4093, vivify_2037
    new $P4093, "Undef"
  vivify_2037:
    store_lex "$else", $P4093
.annotate 'line', 1460
    find_lex $P4094, "$count"
    unless_null $P4094, vivify_2038
    new $P4094, "Undef"
  vivify_2038:
    set $I4095, $P4094
    find_lex $P4096, "$/"
    unless_null $P4096, vivify_2039
    $P4096 = root_new ['parrot';'Hash']
  vivify_2039:
    set $P4097, $P4096["xblock"]
    unless_null $P4097, vivify_2040
    $P4097 = root_new ['parrot';'ResizablePMCArray']
  vivify_2040:
    set $P4098, $P4097[$I4095]
    unless_null $P4098, vivify_2041
    new $P4098, "Undef"
  vivify_2041:
    $P4099 = $P4098."ast"()
    $P4100 = "xblock_immediate"($P4099)
    store_lex "$past", $P4100
.annotate 'line', 1461
    find_lex $P4101, "$past"
    unless_null $P4101, vivify_2042
    new $P4101, "Undef"
  vivify_2042:
    find_lex $P4102, "$else"
    unless_null $P4102, vivify_2043
    new $P4102, "Undef"
  vivify_2043:
    $P4103 = $P4101."push"($P4102)
.annotate 'line', 1457
    .return ($P4103)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>" :anon :subid("482_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4111
    .param pmc param_4112
.annotate 'line', 1466
    .lex "self", param_4111
    .lex "$/", param_4112
.annotate 'line', 1467
    new $P4113, "Undef"
    .lex "$past", $P4113
    find_lex $P4114, "$/"
    unless_null $P4114, vivify_2045
    $P4114 = root_new ['parrot';'Hash']
  vivify_2045:
    set $P4115, $P4114["xblock"]
    unless_null $P4115, vivify_2046
    new $P4115, "Undef"
  vivify_2046:
    $P4116 = $P4115."ast"()
    $P4117 = "xblock_immediate"($P4116)
    store_lex "$past", $P4117
.annotate 'line', 1468
    find_lex $P4118, "$past"
    unless_null $P4118, vivify_2047
    new $P4118, "Undef"
  vivify_2047:
    $P4118."pasttype"("unless")
.annotate 'line', 1469
    find_lex $P4119, "$/"
    find_lex $P4120, "$past"
    unless_null $P4120, vivify_2048
    new $P4120, "Undef"
  vivify_2048:
    $P4121 = $P4119."!make"($P4120)
.annotate 'line', 1466
    .return ($P4121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>" :anon :subid("483_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4123
    .param pmc param_4124
.annotate 'line', 1472
    .lex "self", param_4123
    .lex "$/", param_4124
.annotate 'line', 1473
    new $P4125, "Undef"
    .lex "$past", $P4125
    find_lex $P4126, "$/"
    unless_null $P4126, vivify_2049
    $P4126 = root_new ['parrot';'Hash']
  vivify_2049:
    set $P4127, $P4126["xblock"]
    unless_null $P4127, vivify_2050
    new $P4127, "Undef"
  vivify_2050:
    $P4128 = $P4127."ast"()
    $P4129 = "xblock_immediate"($P4128)
    store_lex "$past", $P4129
.annotate 'line', 1474
    find_lex $P4130, "$past"
    unless_null $P4130, vivify_2051
    new $P4130, "Undef"
  vivify_2051:
    find_lex $P4131, "$/"
    unless_null $P4131, vivify_2052
    $P4131 = root_new ['parrot';'Hash']
  vivify_2052:
    set $P4132, $P4131["sym"]
    unless_null $P4132, vivify_2053
    new $P4132, "Undef"
  vivify_2053:
    set $S4133, $P4132
    $P4130."pasttype"($S4133)
.annotate 'line', 1475
    find_lex $P4134, "$/"
    find_lex $P4135, "$past"
    unless_null $P4135, vivify_2054
    new $P4135, "Undef"
  vivify_2054:
    $P4136 = $P4134."!make"($P4135)
.annotate 'line', 1472
    .return ($P4136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>" :anon :subid("484_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4138
    .param pmc param_4139
.annotate 'line', 1478
    .lex "self", param_4138
    .lex "$/", param_4139
.annotate 'line', 1479
    new $P4140, "Undef"
    .lex "$pasttype", $P4140
.annotate 'line', 1480
    new $P4141, "Undef"
    .lex "$past", $P4141
.annotate 'line', 1479
    new $P4142, "String"
    assign $P4142, "repeat_"
    find_lex $P4143, "$/"
    unless_null $P4143, vivify_2055
    $P4143 = root_new ['parrot';'Hash']
  vivify_2055:
    set $P4144, $P4143["wu"]
    unless_null $P4144, vivify_2056
    new $P4144, "Undef"
  vivify_2056:
    set $S4145, $P4144
    concat $P4146, $P4142, $S4145
    store_lex "$pasttype", $P4146
    find_lex $P4147, "$past"
    unless_null $P4147, vivify_2057
    new $P4147, "Undef"
  vivify_2057:
.annotate 'line', 1481
    find_lex $P4149, "$/"
    unless_null $P4149, vivify_2058
    $P4149 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P4150, $P4149["xblock"]
    unless_null $P4150, vivify_2059
    new $P4150, "Undef"
  vivify_2059:
    if $P4150, if_4148
.annotate 'line', 1486
    get_hll_global $P4157, "GLOBAL"
    nqp_get_package_through_who $P4158, $P4157, "PAST"
    get_who $P4159, $P4158
    set $P4160, $P4159["Op"]
    find_lex $P4161, "$/"
    unless_null $P4161, vivify_2060
    $P4161 = root_new ['parrot';'Hash']
  vivify_2060:
    set $P4162, $P4161["EXPR"]
    unless_null $P4162, vivify_2061
    new $P4162, "Undef"
  vivify_2061:
    $P4163 = $P4162."ast"()
    find_lex $P4164, "$/"
    unless_null $P4164, vivify_2062
    $P4164 = root_new ['parrot';'Hash']
  vivify_2062:
    set $P4165, $P4164["pblock"]
    unless_null $P4165, vivify_2063
    new $P4165, "Undef"
  vivify_2063:
    $P4166 = $P4165."ast"()
    $P4167 = "block_immediate"($P4166)
    find_lex $P4168, "$pasttype"
    unless_null $P4168, vivify_2064
    new $P4168, "Undef"
  vivify_2064:
    find_lex $P4169, "$/"
    unless_null $P4169, vivify_2065
    new $P4169, "Undef"
  vivify_2065:
    $P4170 = $P4160."new"($P4163, $P4167, $P4168 :named("pasttype"), $P4169 :named("node"))
    store_lex "$past", $P4170
.annotate 'line', 1485
    goto if_4148_end
  if_4148:
.annotate 'line', 1482
    find_lex $P4151, "$/"
    unless_null $P4151, vivify_2066
    $P4151 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P4152, $P4151["xblock"]
    unless_null $P4152, vivify_2067
    new $P4152, "Undef"
  vivify_2067:
    $P4153 = $P4152."ast"()
    $P4154 = "xblock_immediate"($P4153)
    store_lex "$past", $P4154
.annotate 'line', 1483
    find_lex $P4155, "$past"
    unless_null $P4155, vivify_2068
    new $P4155, "Undef"
  vivify_2068:
    find_lex $P4156, "$pasttype"
    unless_null $P4156, vivify_2069
    new $P4156, "Undef"
  vivify_2069:
    $P4155."pasttype"($P4156)
  if_4148_end:
.annotate 'line', 1489
    find_lex $P4171, "$/"
    find_lex $P4172, "$past"
    unless_null $P4172, vivify_2070
    new $P4172, "Undef"
  vivify_2070:
    $P4173 = $P4171."!make"($P4172)
.annotate 'line', 1478
    .return ($P4173)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>" :anon :subid("485_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4175
    .param pmc param_4176
.annotate 'line', 1492
    .lex "self", param_4175
    .lex "$/", param_4176
.annotate 'line', 1493
    new $P4177, "Undef"
    .lex "$past", $P4177
.annotate 'line', 1495
    new $P4178, "Undef"
    .lex "$block", $P4178
.annotate 'line', 1493
    find_lex $P4179, "$/"
    unless_null $P4179, vivify_2071
    $P4179 = root_new ['parrot';'Hash']
  vivify_2071:
    set $P4180, $P4179["xblock"]
    unless_null $P4180, vivify_2072
    new $P4180, "Undef"
  vivify_2072:
    $P4181 = $P4180."ast"()
    store_lex "$past", $P4181
.annotate 'line', 1494
    find_lex $P4182, "$past"
    unless_null $P4182, vivify_2073
    new $P4182, "Undef"
  vivify_2073:
    $P4182."pasttype"("for")
.annotate 'line', 1495
    find_lex $P4183, "$past"
    unless_null $P4183, vivify_2074
    $P4183 = root_new ['parrot';'ResizablePMCArray']
  vivify_2074:
    set $P4184, $P4183[1]
    unless_null $P4184, vivify_2075
    new $P4184, "Undef"
  vivify_2075:
    store_lex "$block", $P4184
.annotate 'line', 1496
    find_lex $P4186, "$block"
    unless_null $P4186, vivify_2076
    new $P4186, "Undef"
  vivify_2076:
    $P4187 = $P4186."arity"()
    if $P4187, unless_4185_end
.annotate 'line', 1497
    find_lex $P4188, "$block"
    unless_null $P4188, vivify_2077
    $P4188 = root_new ['parrot';'ResizablePMCArray']
  vivify_2077:
    set $P4189, $P4188[0]
    unless_null $P4189, vivify_2078
    new $P4189, "Undef"
  vivify_2078:
    get_hll_global $P4190, "GLOBAL"
    nqp_get_package_through_who $P4191, $P4190, "PAST"
    get_who $P4192, $P4191
    set $P4193, $P4192["Var"]
    $P4194 = $P4193."new"("$_" :named("name"), "parameter" :named("scope"))
    $P4189."push"($P4194)
.annotate 'line', 1498
    find_lex $P4195, "$block"
    unless_null $P4195, vivify_2079
    new $P4195, "Undef"
  vivify_2079:
    $P4195."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1499
    find_lex $P4196, "$block"
    unless_null $P4196, vivify_2080
    new $P4196, "Undef"
  vivify_2080:
    $P4196."arity"(1)
  unless_4185_end:
.annotate 'line', 1501
    find_lex $P4197, "$block"
    unless_null $P4197, vivify_2081
    new $P4197, "Undef"
  vivify_2081:
    $P4197."blocktype"("immediate")
.annotate 'line', 1502
    find_lex $P4198, "$/"
    find_lex $P4199, "$past"
    unless_null $P4199, vivify_2082
    new $P4199, "Undef"
  vivify_2082:
    $P4200 = $P4198."!make"($P4199)
.annotate 'line', 1492
    .return ($P4200)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>" :anon :subid("486_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4202
    .param pmc param_4203
.annotate 'line', 1505
    .lex "self", param_4202
    .lex "$/", param_4203
.annotate 'line', 1506
    new $P4204, "Undef"
    .lex "$block", $P4204
    find_lex $P4205, "$/"
    unless_null $P4205, vivify_2083
    $P4205 = root_new ['parrot';'Hash']
  vivify_2083:
    set $P4206, $P4205["block"]
    unless_null $P4206, vivify_2084
    new $P4206, "Undef"
  vivify_2084:
    $P4207 = $P4206."ast"()
    store_lex "$block", $P4207
.annotate 'line', 1507
    find_lex $P4208, "$/"
    unless_null $P4208, vivify_2085
    new $P4208, "Undef"
  vivify_2085:
    find_lex $P4209, "$block"
    unless_null $P4209, vivify_2086
    new $P4209, "Undef"
  vivify_2086:
    "push_block_handler"($P4208, $P4209)
.annotate 'line', 1508
    find_lex $P4210, "$?PACKAGE"
    get_who $P4211, $P4210
    set $P4212, $P4211["@BLOCK"]
    unless_null $P4212, vivify_2087
    $P4212 = root_new ['parrot';'ResizablePMCArray']
  vivify_2087:
    set $P4213, $P4212[0]
    unless_null $P4213, vivify_2088
    new $P4213, "Undef"
  vivify_2088:
    $P4214 = $P4213."handlers"()
    set $P4215, $P4214[0]
    unless_null $P4215, vivify_2089
    new $P4215, "Undef"
  vivify_2089:
    $P4215."handle_types_except"("CONTROL")
.annotate 'line', 1509
    find_lex $P4216, "$/"
    get_hll_global $P4217, "GLOBAL"
    nqp_get_package_through_who $P4218, $P4217, "PAST"
    get_who $P4219, $P4218
    set $P4220, $P4219["Stmts"]
    find_lex $P4221, "$/"
    unless_null $P4221, vivify_2090
    new $P4221, "Undef"
  vivify_2090:
    $P4222 = $P4220."new"($P4221 :named("node"))
    $P4223 = $P4216."!make"($P4222)
.annotate 'line', 1505
    .return ($P4223)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>" :anon :subid("487_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4225
    .param pmc param_4226
.annotate 'line', 1512
    .lex "self", param_4225
    .lex "$/", param_4226
.annotate 'line', 1513
    new $P4227, "Undef"
    .lex "$block", $P4227
    find_lex $P4228, "$/"
    unless_null $P4228, vivify_2091
    $P4228 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P4229, $P4228["block"]
    unless_null $P4229, vivify_2092
    new $P4229, "Undef"
  vivify_2092:
    $P4230 = $P4229."ast"()
    store_lex "$block", $P4230
.annotate 'line', 1514
    find_lex $P4231, "$/"
    unless_null $P4231, vivify_2093
    new $P4231, "Undef"
  vivify_2093:
    find_lex $P4232, "$block"
    unless_null $P4232, vivify_2094
    new $P4232, "Undef"
  vivify_2094:
    "push_block_handler"($P4231, $P4232)
.annotate 'line', 1515
    find_lex $P4233, "$?PACKAGE"
    get_who $P4234, $P4233
    set $P4235, $P4234["@BLOCK"]
    unless_null $P4235, vivify_2095
    $P4235 = root_new ['parrot';'ResizablePMCArray']
  vivify_2095:
    set $P4236, $P4235[0]
    unless_null $P4236, vivify_2096
    new $P4236, "Undef"
  vivify_2096:
    $P4237 = $P4236."handlers"()
    set $P4238, $P4237[0]
    unless_null $P4238, vivify_2097
    new $P4238, "Undef"
  vivify_2097:
    $P4238."handle_types"("CONTROL")
.annotate 'line', 1516
    find_lex $P4239, "$/"
    get_hll_global $P4240, "GLOBAL"
    nqp_get_package_through_who $P4241, $P4240, "PAST"
    get_who $P4242, $P4241
    set $P4243, $P4242["Stmts"]
    find_lex $P4244, "$/"
    unless_null $P4244, vivify_2098
    new $P4244, "Undef"
  vivify_2098:
    $P4245 = $P4243."new"($P4244 :named("node"))
    $P4246 = $P4239."!make"($P4245)
.annotate 'line', 1512
    .return ($P4246)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>" :anon :subid("488_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4249
    .param pmc param_4250
.annotate 'line', 1556
    .lex "self", param_4249
    .lex "$/", param_4250
.annotate 'line', 1557
    find_lex $P4251, "$?PACKAGE"
    get_who $P4252, $P4251
    set $P4253, $P4252["@BLOCK"]
    unless_null $P4253, vivify_2099
    $P4253 = root_new ['parrot';'ResizablePMCArray']
  vivify_2099:
    set $P4254, $P4253[0]
    unless_null $P4254, vivify_2100
    new $P4254, "Undef"
  vivify_2100:
    find_lex $P4255, "$/"
    unless_null $P4255, vivify_2101
    $P4255 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P4256, $P4255["blorst"]
    unless_null $P4256, vivify_2102
    new $P4256, "Undef"
  vivify_2102:
    $P4257 = $P4256."ast"()
    $P4254."push"($P4257)
.annotate 'line', 1558
    find_lex $P4258, "$/"
    get_hll_global $P4259, "GLOBAL"
    nqp_get_package_through_who $P4260, $P4259, "PAST"
    get_who $P4261, $P4260
    set $P4262, $P4261["Stmts"]
    $P4263 = $P4262."new"()
    $P4264 = $P4258."!make"($P4263)
.annotate 'line', 1556
    .return ($P4264)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>" :anon :subid("489_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4266
    .param pmc param_4267
.annotate 'line', 1561
    .lex "self", param_4266
    .lex "$/", param_4267
.annotate 'line', 1562
    new $P4268, "Undef"
    .lex "$past", $P4268
    find_lex $P4269, "$/"
    unless_null $P4269, vivify_2103
    $P4269 = root_new ['parrot';'Hash']
  vivify_2103:
    set $P4270, $P4269["blorst"]
    unless_null $P4270, vivify_2104
    new $P4270, "Undef"
  vivify_2104:
    $P4271 = $P4270."ast"()
    store_lex "$past", $P4271
.annotate 'line', 1563
    get_hll_global $P4273, "GLOBAL"
    nqp_get_package_through_who $P4274, $P4273, "PAST"
    get_who $P4275, $P4274
    set $P4276, $P4275["Block"]
    find_lex $P4277, "$past"
    unless_null $P4277, vivify_2105
    new $P4277, "Undef"
  vivify_2105:
    $P4278 = $P4276."ACCEPTS"($P4277)
    if $P4278, unless_4272_end
.annotate 'line', 1564
    get_hll_global $P4279, "GLOBAL"
    nqp_get_package_through_who $P4280, $P4279, "PAST"
    get_who $P4281, $P4280
    set $P4282, $P4281["Block"]
    find_lex $P4283, "$past"
    unless_null $P4283, vivify_2106
    new $P4283, "Undef"
  vivify_2106:
    find_lex $P4284, "$/"
    unless_null $P4284, vivify_2107
    new $P4284, "Undef"
  vivify_2107:
    $P4285 = $P4282."new"($P4283, "immediate" :named("blocktype"), $P4284 :named("node"))
    store_lex "$past", $P4285
  unless_4272_end:
.annotate 'line', 1566
    find_lex $P4287, "$past"
    unless_null $P4287, vivify_2108
    new $P4287, "Undef"
  vivify_2108:
    $P4288 = $P4287."handlers"()
    if $P4288, unless_4286_end
.annotate 'line', 1567
    find_lex $P4289, "$past"
    unless_null $P4289, vivify_2109
    new $P4289, "Undef"
  vivify_2109:
    get_hll_global $P4290, "GLOBAL"
    nqp_get_package_through_who $P4291, $P4290, "PAST"
    get_who $P4292, $P4291
    set $P4293, $P4292["Control"]
.annotate 'line', 1569
    get_hll_global $P4294, "GLOBAL"
    nqp_get_package_through_who $P4295, $P4294, "PAST"
    get_who $P4296, $P4295
    set $P4297, $P4296["Stmts"]
.annotate 'line', 1570
    get_hll_global $P4298, "GLOBAL"
    nqp_get_package_through_who $P4299, $P4298, "PAST"
    get_who $P4300, $P4299
    set $P4301, $P4300["Op"]
.annotate 'line', 1571
    get_hll_global $P4302, "GLOBAL"
    nqp_get_package_through_who $P4303, $P4302, "PAST"
    get_who $P4304, $P4303
    set $P4305, $P4304["Var"]
.annotate 'line', 1572
    get_hll_global $P4306, "GLOBAL"
    nqp_get_package_through_who $P4307, $P4306, "PAST"
    get_who $P4308, $P4307
    set $P4309, $P4308["Var"]
    $P4310 = $P4309."new"("register" :named("scope"), "exception" :named("name"))
    $P4311 = $P4305."new"($P4310, "handled", "keyed" :named("scope"))
.annotate 'line', 1571
    $P4312 = $P4301."new"($P4311, 1, "bind" :named("pasttype"))
.annotate 'line', 1570
    $P4313 = $P4297."new"($P4312)
.annotate 'line', 1569
    $P4314 = $P4293."new"($P4313, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1567
    new $P4315, "ResizablePMCArray"
    push $P4315, $P4314
    $P4289."handlers"($P4315)
  unless_4286_end:
.annotate 'line', 1581
    find_lex $P4316, "$/"
    find_lex $P4317, "$past"
    unless_null $P4317, vivify_2110
    new $P4317, "Undef"
  vivify_2110:
    $P4318 = $P4316."!make"($P4317)
.annotate 'line', 1561
    .return ($P4318)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst" :anon :subid("490_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4320
    .param pmc param_4321
.annotate 'line', 1584
    .lex "self", param_4320
    .lex "$/", param_4321
.annotate 'line', 1585
    find_lex $P4322, "$/"
.annotate 'line', 1586
    find_lex $P4325, "$/"
    unless_null $P4325, vivify_2111
    $P4325 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P4326, $P4325["block"]
    unless_null $P4326, vivify_2112
    new $P4326, "Undef"
  vivify_2112:
    if $P4326, if_4324
.annotate 'line', 1587
    find_lex $P4331, "$/"
    unless_null $P4331, vivify_2113
    $P4331 = root_new ['parrot';'Hash']
  vivify_2113:
    set $P4332, $P4331["statement"]
    unless_null $P4332, vivify_2114
    new $P4332, "Undef"
  vivify_2114:
    $P4333 = $P4332."ast"()
    set $P4323, $P4333
.annotate 'line', 1586
    goto if_4324_end
  if_4324:
    find_lex $P4327, "$/"
    unless_null $P4327, vivify_2115
    $P4327 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P4328, $P4327["block"]
    unless_null $P4328, vivify_2116
    new $P4328, "Undef"
  vivify_2116:
    $P4329 = $P4328."ast"()
    $P4330 = "block_immediate"($P4329)
    set $P4323, $P4330
  if_4324_end:
    $P4334 = $P4322."!make"($P4323)
.annotate 'line', 1584
    .return ($P4334)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>" :anon :subid("491_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4336
    .param pmc param_4337
.annotate 'line', 1592
    .lex "self", param_4336
    .lex "$/", param_4337
    find_lex $P4338, "$/"
    find_lex $P4339, "$/"
    unless_null $P4339, vivify_2117
    $P4339 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P4340, $P4339["cond"]
    unless_null $P4340, vivify_2118
    new $P4340, "Undef"
  vivify_2118:
    $P4341 = $P4340."ast"()
    $P4342 = $P4338."!make"($P4341)
    .return ($P4342)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>" :anon :subid("492_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4344
    .param pmc param_4345
.annotate 'line', 1593
    .lex "self", param_4344
    .lex "$/", param_4345
    find_lex $P4346, "$/"
    find_lex $P4347, "$/"
    unless_null $P4347, vivify_2119
    $P4347 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4348, $P4347["cond"]
    unless_null $P4348, vivify_2120
    new $P4348, "Undef"
  vivify_2120:
    $P4349 = $P4348."ast"()
    $P4350 = $P4346."!make"($P4349)
    .return ($P4350)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>" :anon :subid("493_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4352
    .param pmc param_4353
.annotate 'line', 1595
    .lex "self", param_4352
    .lex "$/", param_4353
    find_lex $P4354, "$/"
    find_lex $P4355, "$/"
    unless_null $P4355, vivify_2121
    $P4355 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P4356, $P4355["cond"]
    unless_null $P4356, vivify_2122
    new $P4356, "Undef"
  vivify_2122:
    $P4357 = $P4356."ast"()
    $P4358 = $P4354."!make"($P4357)
    .return ($P4358)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>" :anon :subid("494_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4360
    .param pmc param_4361
.annotate 'line', 1596
    .lex "self", param_4360
    .lex "$/", param_4361
    find_lex $P4362, "$/"
    find_lex $P4363, "$/"
    unless_null $P4363, vivify_2123
    $P4363 = root_new ['parrot';'Hash']
  vivify_2123:
    set $P4364, $P4363["cond"]
    unless_null $P4364, vivify_2124
    new $P4364, "Undef"
  vivify_2124:
    $P4365 = $P4364."ast"()
    $P4366 = $P4362."!make"($P4365)
    .return ($P4366)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>" :anon :subid("495_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4368
    .param pmc param_4369
.annotate 'line', 1600
    .lex "self", param_4368
    .lex "$/", param_4369
    find_lex $P4370, "$/"
    find_lex $P4371, "$/"
    unless_null $P4371, vivify_2125
    $P4371 = root_new ['parrot';'Hash']
  vivify_2125:
    set $P4372, $P4371["fatarrow"]
    unless_null $P4372, vivify_2126
    new $P4372, "Undef"
  vivify_2126:
    $P4373 = $P4372."ast"()
    $P4374 = $P4370."!make"($P4373)
    .return ($P4374)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>" :anon :subid("496_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4376
    .param pmc param_4377
.annotate 'line', 1601
    .lex "self", param_4376
    .lex "$/", param_4377
    find_lex $P4378, "$/"
    find_lex $P4379, "$/"
    unless_null $P4379, vivify_2127
    $P4379 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P4380, $P4379["colonpair"]
    unless_null $P4380, vivify_2128
    new $P4380, "Undef"
  vivify_2128:
    $P4381 = $P4380."ast"()
    $P4382 = $P4378."!make"($P4381)
    .return ($P4382)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>" :anon :subid("497_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4384
    .param pmc param_4385
.annotate 'line', 1602
    .lex "self", param_4384
    .lex "$/", param_4385
    find_lex $P4386, "$/"
    find_lex $P4387, "$/"
    unless_null $P4387, vivify_2129
    $P4387 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P4388, $P4387["variable"]
    unless_null $P4388, vivify_2130
    new $P4388, "Undef"
  vivify_2130:
    $P4389 = $P4388."ast"()
    $P4390 = $P4386."!make"($P4389)
    .return ($P4390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>" :anon :subid("498_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4392
    .param pmc param_4393
.annotate 'line', 1603
    .lex "self", param_4392
    .lex "$/", param_4393
    find_lex $P4394, "$/"
    find_lex $P4395, "$/"
    unless_null $P4395, vivify_2131
    $P4395 = root_new ['parrot';'Hash']
  vivify_2131:
    set $P4396, $P4395["package_declarator"]
    unless_null $P4396, vivify_2132
    new $P4396, "Undef"
  vivify_2132:
    $P4397 = $P4396."ast"()
    $P4398 = $P4394."!make"($P4397)
    .return ($P4398)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>" :anon :subid("499_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4400
    .param pmc param_4401
.annotate 'line', 1604
    .lex "self", param_4400
    .lex "$/", param_4401
    find_lex $P4402, "$/"
    find_lex $P4403, "$/"
    unless_null $P4403, vivify_2133
    $P4403 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P4404, $P4403["scope_declarator"]
    unless_null $P4404, vivify_2134
    new $P4404, "Undef"
  vivify_2134:
    $P4405 = $P4404."ast"()
    $P4406 = $P4402."!make"($P4405)
    .return ($P4406)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>" :anon :subid("500_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4408
    .param pmc param_4409
.annotate 'line', 1605
    .lex "self", param_4408
    .lex "$/", param_4409
    find_lex $P4410, "$/"
    find_lex $P4411, "$/"
    unless_null $P4411, vivify_2135
    $P4411 = root_new ['parrot';'Hash']
  vivify_2135:
    set $P4412, $P4411["routine_declarator"]
    unless_null $P4412, vivify_2136
    new $P4412, "Undef"
  vivify_2136:
    $P4413 = $P4412."ast"()
    $P4414 = $P4410."!make"($P4413)
    .return ($P4414)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>" :anon :subid("501_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4416
    .param pmc param_4417
.annotate 'line', 1606
    .lex "self", param_4416
    .lex "$/", param_4417
    find_lex $P4418, "$/"
    find_lex $P4419, "$/"
    unless_null $P4419, vivify_2137
    $P4419 = root_new ['parrot';'Hash']
  vivify_2137:
    set $P4420, $P4419["regex_declarator"]
    unless_null $P4420, vivify_2138
    new $P4420, "Undef"
  vivify_2138:
    $P4421 = $P4420."ast"()
    $P4422 = $P4418."!make"($P4421)
    .return ($P4422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>" :anon :subid("502_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4424
    .param pmc param_4425
.annotate 'line', 1607
    .lex "self", param_4424
    .lex "$/", param_4425
    find_lex $P4426, "$/"
    find_lex $P4427, "$/"
    unless_null $P4427, vivify_2139
    $P4427 = root_new ['parrot';'Hash']
  vivify_2139:
    set $P4428, $P4427["statement_prefix"]
    unless_null $P4428, vivify_2140
    new $P4428, "Undef"
  vivify_2140:
    $P4429 = $P4428."ast"()
    $P4430 = $P4426."!make"($P4429)
    .return ($P4430)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>" :anon :subid("503_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4432
    .param pmc param_4433
.annotate 'line', 1608
    .lex "self", param_4432
    .lex "$/", param_4433
    find_lex $P4434, "$/"
    find_lex $P4435, "$/"
    unless_null $P4435, vivify_2141
    $P4435 = root_new ['parrot';'Hash']
  vivify_2141:
    set $P4436, $P4435["pblock"]
    unless_null $P4436, vivify_2142
    new $P4436, "Undef"
  vivify_2142:
    $P4437 = $P4436."ast"()
    $P4438 = $P4434."!make"($P4437)
    .return ($P4438)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow" :anon :subid("504_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4440
    .param pmc param_4441
.annotate 'line', 1610
    .lex "self", param_4440
    .lex "$/", param_4441
.annotate 'line', 1611
    new $P4442, "Undef"
    .lex "$past", $P4442
    find_lex $P4443, "$/"
    unless_null $P4443, vivify_2143
    $P4443 = root_new ['parrot';'Hash']
  vivify_2143:
    set $P4444, $P4443["val"]
    unless_null $P4444, vivify_2144
    new $P4444, "Undef"
  vivify_2144:
    $P4445 = $P4444."ast"()
    store_lex "$past", $P4445
.annotate 'line', 1612
    find_lex $P4446, "$past"
    unless_null $P4446, vivify_2145
    new $P4446, "Undef"
  vivify_2145:
    find_lex $P4447, "$/"
    unless_null $P4447, vivify_2146
    $P4447 = root_new ['parrot';'Hash']
  vivify_2146:
    set $P4448, $P4447["key"]
    unless_null $P4448, vivify_2147
    new $P4448, "Undef"
  vivify_2147:
    $P4449 = $P4448."Str"()
    $P4446."named"($P4449)
.annotate 'line', 1613
    find_lex $P4450, "$/"
    find_lex $P4451, "$past"
    unless_null $P4451, vivify_2148
    new $P4451, "Undef"
  vivify_2148:
    $P4452 = $P4450."!make"($P4451)
.annotate 'line', 1610
    .return ($P4452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair" :anon :subid("505_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4454
    .param pmc param_4455
.annotate 'line', 1616
    .lex "self", param_4454
    .lex "$/", param_4455
.annotate 'line', 1617
    new $P4456, "Undef"
    .lex "$past", $P4456
.annotate 'line', 1618
    find_lex $P4459, "$/"
    unless_null $P4459, vivify_2149
    $P4459 = root_new ['parrot';'Hash']
  vivify_2149:
    set $P4460, $P4459["circumfix"]
    unless_null $P4460, vivify_2150
    new $P4460, "Undef"
  vivify_2150:
    if $P4460, if_4458
.annotate 'line', 1619
    get_hll_global $P4465, "GLOBAL"
    nqp_get_package_through_who $P4466, $P4465, "PAST"
    get_who $P4467, $P4466
    set $P4468, $P4467["Val"]
    find_lex $P4469, "$/"
    unless_null $P4469, vivify_2151
    $P4469 = root_new ['parrot';'Hash']
  vivify_2151:
    set $P4470, $P4469["not"]
    unless_null $P4470, vivify_2152
    new $P4470, "Undef"
  vivify_2152:
    isfalse $I4471, $P4470
    $P4472 = $P4468."new"($I4471 :named("value"))
    set $P4457, $P4472
.annotate 'line', 1618
    goto if_4458_end
  if_4458:
    find_lex $P4461, "$/"
    unless_null $P4461, vivify_2153
    $P4461 = root_new ['parrot';'Hash']
  vivify_2153:
    set $P4462, $P4461["circumfix"]
    unless_null $P4462, vivify_2154
    $P4462 = root_new ['parrot';'ResizablePMCArray']
  vivify_2154:
    set $P4463, $P4462[0]
    unless_null $P4463, vivify_2155
    new $P4463, "Undef"
  vivify_2155:
    $P4464 = $P4463."ast"()
    set $P4457, $P4464
  if_4458_end:
    store_lex "$past", $P4457
.annotate 'line', 1620
    find_lex $P4473, "$past"
    unless_null $P4473, vivify_2156
    new $P4473, "Undef"
  vivify_2156:
    find_lex $P4474, "$/"
    unless_null $P4474, vivify_2157
    $P4474 = root_new ['parrot';'Hash']
  vivify_2157:
    set $P4475, $P4474["identifier"]
    unless_null $P4475, vivify_2158
    new $P4475, "Undef"
  vivify_2158:
    set $S4476, $P4475
    $P4473."named"($S4476)
.annotate 'line', 1621
    find_lex $P4477, "$/"
    find_lex $P4478, "$past"
    unless_null $P4478, vivify_2159
    new $P4478, "Undef"
  vivify_2159:
    $P4479 = $P4477."!make"($P4478)
.annotate 'line', 1616
    .return ($P4479)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable" :anon :subid("506_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4481
    .param pmc param_4482
.annotate 'line', 1624
    .const 'Sub' $P4498 = "507_1305640955.436" 
    capture_lex $P4498
    .lex "self", param_4481
    .lex "$/", param_4482
.annotate 'line', 1625
    new $P4483, "Undef"
    .lex "$past", $P4483
.annotate 'line', 1624
    find_lex $P4484, "$past"
    unless_null $P4484, vivify_2160
    new $P4484, "Undef"
  vivify_2160:
.annotate 'line', 1626
    find_lex $P4486, "$/"
    unless_null $P4486, vivify_2161
    $P4486 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P4487, $P4486["postcircumfix"]
    unless_null $P4487, vivify_2162
    new $P4487, "Undef"
  vivify_2162:
    if $P4487, if_4485
.annotate 'line', 1630
    .const 'Sub' $P4498 = "507_1305640955.436" 
    capture_lex $P4498
    $P4498()
    goto if_4485_end
  if_4485:
.annotate 'line', 1627
    find_lex $P4488, "$/"
    unless_null $P4488, vivify_2219
    $P4488 = root_new ['parrot';'Hash']
  vivify_2219:
    set $P4489, $P4488["postcircumfix"]
    unless_null $P4489, vivify_2220
    new $P4489, "Undef"
  vivify_2220:
    $P4490 = $P4489."ast"()
    store_lex "$past", $P4490
.annotate 'line', 1628
    find_lex $P4491, "$past"
    unless_null $P4491, vivify_2221
    new $P4491, "Undef"
  vivify_2221:
    get_hll_global $P4492, "GLOBAL"
    nqp_get_package_through_who $P4493, $P4492, "PAST"
    get_who $P4494, $P4493
    set $P4495, $P4494["Var"]
    $P4496 = $P4495."new"("$/" :named("name"))
    $P4491."unshift"($P4496)
  if_4485_end:
.annotate 'line', 1689
    find_lex $P4680, "$/"
    find_lex $P4681, "$past"
    unless_null $P4681, vivify_2222
    new $P4681, "Undef"
  vivify_2222:
    $P4682 = $P4680."!make"($P4681)
.annotate 'line', 1624
    .return ($P4682)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4497"  :anon :subid("507_1305640955.436") :outer("506_1305640955.436")
.annotate 'line', 1630
    .const 'Sub' $P4574 = "509_1305640955.436" 
    capture_lex $P4574
    .const 'Sub' $P4533 = "508_1305640955.436" 
    capture_lex $P4533
.annotate 'line', 1631
    $P4499 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4499
    get_hll_global $P4500, "GLOBAL"
    nqp_get_package_through_who $P4501, $P4500, "NQP"
    get_who $P4502, $P4501
    set $P4503, $P4502["Compiler"]
    find_lex $P4504, "$/"
    unless_null $P4504, vivify_2163
    new $P4504, "Undef"
  vivify_2163:
    set $S4505, $P4504
    $P4506 = $P4503."parse_name"($S4505)
    store_lex "@name", $P4506
.annotate 'line', 1632
    find_lex $P4509, "@name"
    unless_null $P4509, vivify_2164
    $P4509 = root_new ['parrot';'ResizablePMCArray']
  vivify_2164:
    set $N4510, $P4509
    isgt $I4511, $N4510, 1.0
    if $I4511, if_4508
.annotate 'line', 1639
    find_lex $P4527, "$/"
    unless_null $P4527, vivify_2165
    $P4527 = root_new ['parrot';'Hash']
  vivify_2165:
    set $P4528, $P4527["twigil"]
    unless_null $P4528, vivify_2166
    $P4528 = root_new ['parrot';'ResizablePMCArray']
  vivify_2166:
    set $P4529, $P4528[0]
    unless_null $P4529, vivify_2167
    new $P4529, "Undef"
  vivify_2167:
    set $S4530, $P4529
    iseq $I4531, $S4530, "*"
    if $I4531, if_4526
.annotate 'line', 1650
    find_lex $P4568, "$/"
    unless_null $P4568, vivify_2168
    $P4568 = root_new ['parrot';'Hash']
  vivify_2168:
    set $P4569, $P4568["twigil"]
    unless_null $P4569, vivify_2169
    $P4569 = root_new ['parrot';'ResizablePMCArray']
  vivify_2169:
    set $P4570, $P4569[0]
    unless_null $P4570, vivify_2170
    new $P4570, "Undef"
  vivify_2170:
    set $S4571, $P4570
    iseq $I4572, $S4571, "!"
    if $I4572, if_4567
.annotate 'line', 1679
    find_lex $P4657, "@name"
    unless_null $P4657, vivify_2171
    $P4657 = root_new ['parrot';'ResizablePMCArray']
  vivify_2171:
    set $P4658, $P4657[0]
    unless_null $P4658, vivify_2172
    new $P4658, "Undef"
  vivify_2172:
    set $S4659, $P4658
    $P4660 = "is_package"($S4659)
    if $P4660, if_4656
.annotate 'line', 1684
    get_hll_global $P4669, "GLOBAL"
    nqp_get_package_through_who $P4670, $P4669, "PAST"
    get_who $P4671, $P4670
    set $P4672, $P4671["Var"]
.annotate 'line', 1685
    find_lex $P4673, "@name"
    unless_null $P4673, vivify_2173
    $P4673 = root_new ['parrot';'ResizablePMCArray']
  vivify_2173:
    $P4674 = $P4673."pop"()
    set $S4675, $P4674
    find_lex $P4676, "$/"
    unless_null $P4676, vivify_2174
    $P4676 = root_new ['parrot';'Hash']
  vivify_2174:
    set $P4677, $P4676["sigil"]
    unless_null $P4677, vivify_2175
    new $P4677, "Undef"
  vivify_2175:
    $P4678 = "vivitype"($P4677)
    $P4679 = $P4672."new"($S4675 :named("name"), $P4678 :named("viviself"))
.annotate 'line', 1684
    store_lex "$past", $P4679
.annotate 'line', 1683
    set $P4655, $P4679
.annotate 'line', 1679
    goto if_4656_end
  if_4656:
.annotate 'line', 1680
    find_lex $P4661, "@name"
    unless_null $P4661, vivify_2176
    $P4661 = root_new ['parrot';'ResizablePMCArray']
  vivify_2176:
    find_lex $P4662, "$/"
    unless_null $P4662, vivify_2177
    new $P4662, "Undef"
  vivify_2177:
    $P4663 = "lexical_package_lookup"($P4661, $P4662)
    store_lex "$past", $P4663
.annotate 'line', 1681
    find_lex $P4664, "$past"
    unless_null $P4664, vivify_2178
    new $P4664, "Undef"
  vivify_2178:
    find_lex $P4665, "$/"
    unless_null $P4665, vivify_2179
    $P4665 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P4666, $P4665["sigil"]
    unless_null $P4666, vivify_2180
    new $P4666, "Undef"
  vivify_2180:
    $P4667 = "vivitype"($P4666)
    $P4668 = $P4664."viviself"($P4667)
.annotate 'line', 1679
    set $P4655, $P4668
  if_4656_end:
    set $P4566, $P4655
.annotate 'line', 1650
    goto if_4567_end
  if_4567:
    .const 'Sub' $P4574 = "509_1305640955.436" 
    capture_lex $P4574
    $P4654 = $P4574()
    set $P4566, $P4654
  if_4567_end:
    set $P4525, $P4566
.annotate 'line', 1639
    goto if_4526_end
  if_4526:
    .const 'Sub' $P4533 = "508_1305640955.436" 
    capture_lex $P4533
    $P4565 = $P4533()
    set $P4525, $P4565
  if_4526_end:
    set $P4507, $P4525
.annotate 'line', 1632
    goto if_4508_end
  if_4508:
.annotate 'line', 1633
    find_lex $P4513, "$/"
    unless_null $P4513, vivify_2211
    $P4513 = root_new ['parrot';'Hash']
  vivify_2211:
    set $P4514, $P4513["twigil"]
    unless_null $P4514, vivify_2212
    new $P4514, "Undef"
  vivify_2212:
    unless $P4514, if_4512_end
.annotate 'line', 1634
    find_lex $P4515, "$/"
    unless_null $P4515, vivify_2213
    new $P4515, "Undef"
  vivify_2213:
    $P4516 = $P4515."CURSOR"()
    $P4516."panic"("Twigil not allowed on multi-part name")
  if_4512_end:
.annotate 'line', 1636
    find_lex $P4517, "@name"
    unless_null $P4517, vivify_2214
    $P4517 = root_new ['parrot';'ResizablePMCArray']
  vivify_2214:
    find_lex $P4518, "$/"
    unless_null $P4518, vivify_2215
    new $P4518, "Undef"
  vivify_2215:
    $P4519 = "lexical_package_lookup"($P4517, $P4518)
    store_lex "$past", $P4519
.annotate 'line', 1637
    find_lex $P4520, "$past"
    unless_null $P4520, vivify_2216
    new $P4520, "Undef"
  vivify_2216:
    find_lex $P4521, "$/"
    unless_null $P4521, vivify_2217
    $P4521 = root_new ['parrot';'Hash']
  vivify_2217:
    set $P4522, $P4521["sigil"]
    unless_null $P4522, vivify_2218
    new $P4522, "Undef"
  vivify_2218:
    $P4523 = "vivitype"($P4522)
    $P4524 = $P4520."viviself"($P4523)
.annotate 'line', 1632
    set $P4507, $P4524
  if_4508_end:
.annotate 'line', 1630
    .return ($P4507)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4573"  :anon :subid("509_1305640955.436") :outer("507_1305640955.436")
.annotate 'line', 1650
    .const 'Sub' $P4605 = "510_1305640955.436" 
    capture_lex $P4605
.annotate 'line', 1652
    new $P4575, "Undef"
    .lex "$name", $P4575
    find_lex $P4576, "@name"
    unless_null $P4576, vivify_2181
    $P4576 = root_new ['parrot';'ResizablePMCArray']
  vivify_2181:
    $P4577 = $P4576."pop"()
    set $S4578, $P4577
    new $P4579, 'String'
    set $P4579, $S4578
    store_lex "$name", $P4579
.annotate 'line', 1653
    get_hll_global $P4580, "GLOBAL"
    nqp_get_package_through_who $P4581, $P4580, "PAST"
    get_who $P4582, $P4581
    set $P4583, $P4582["Var"]
    find_lex $P4584, "$name"
    unless_null $P4584, vivify_2182
    new $P4584, "Undef"
  vivify_2182:
.annotate 'line', 1655
    find_lex $P4585, "$/"
    unless_null $P4585, vivify_2183
    $P4585 = root_new ['parrot';'Hash']
  vivify_2183:
    set $P4586, $P4585["sigil"]
    unless_null $P4586, vivify_2184
    new $P4586, "Undef"
  vivify_2184:
    $P4587 = "vivitype"($P4586)
.annotate 'line', 1656
    get_hll_global $P4588, "GLOBAL"
    nqp_get_package_through_who $P4589, $P4588, "PAST"
    get_who $P4590, $P4589
    set $P4591, $P4590["Var"]
    $P4592 = $P4591."new"("self" :named("name"))
.annotate 'line', 1657
    get_hll_global $P4593, "GLOBAL"
    nqp_get_package_through_who $P4594, $P4593, "PAST"
    get_who $P4595, $P4594
    set $P4596, $P4595["Var"]
    $P4597 = $P4596."new"("$?CLASS" :named("name"))
    $P4598 = $P4583."new"($P4592, $P4597, $P4584 :named("name"), "attribute_6model" :named("scope"), $P4587 :named("viviself"))
.annotate 'line', 1653
    store_lex "$past", $P4598
.annotate 'line', 1661
    find_dynamic_lex $P4603, "$*IN_DECL"
    unless_null $P4603, vivify_2185
    get_hll_global $P4601, "GLOBAL"
    get_who $P4602, $P4601
    set $P4603, $P4602["$IN_DECL"]
    unless_null $P4603, vivify_2186
    die "Contextual $*IN_DECL not found"
  vivify_2186:
  vivify_2185:
    unless $P4603, unless_4600
    set $P4599, $P4603
    goto unless_4600_end
  unless_4600:
    .const 'Sub' $P4605 = "510_1305640955.436" 
    capture_lex $P4605
    $P4653 = $P4605()
    set $P4599, $P4653
  unless_4600_end:
.annotate 'line', 1650
    .return ($P4599)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4604"  :anon :subid("510_1305640955.436") :outer("509_1305640955.436")
.annotate 'line', 1661
    .const 'Sub' $P4620 = "511_1305640955.436" 
    capture_lex $P4620
.annotate 'line', 1662
    new $P4606, "Undef"
    .lex "$attr", $P4606
.annotate 'line', 1661
    find_lex $P4607, "$attr"
    unless_null $P4607, vivify_2187
    new $P4607, "Undef"
  vivify_2187:
.annotate 'line', 1663
    find_dynamic_lex $P4611, "$*PACKAGE"
    unless_null $P4611, vivify_2188
    get_hll_global $P4609, "GLOBAL"
    get_who $P4610, $P4609
    set $P4611, $P4610["$PACKAGE"]
    unless_null $P4611, vivify_2189
    die "Contextual $*PACKAGE not found"
  vivify_2189:
  vivify_2188:
    get_how $P4612, $P4611
    find_dynamic_lex $P4615, "$*PACKAGE"
    unless_null $P4615, vivify_2190
    get_hll_global $P4613, "GLOBAL"
    get_who $P4614, $P4613
    set $P4615, $P4614["$PACKAGE"]
    unless_null $P4615, vivify_2191
    die "Contextual $*PACKAGE not found"
  vivify_2191:
  vivify_2190:
    $P4616 = $P4612."attributes"($P4615, 1 :named("local"))
    defined $I4617, $P4616
    unless $I4617, for_undef_2192
    iter $P4608, $P4616
    new $P4632, 'ExceptionHandler'
    set_label $P4632, loop4631_handler
    $P4632."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4632
  loop4631_test:
    unless $P4608, loop4631_done
    shift $P4618, $P4608
  loop4631_redo:
    .const 'Sub' $P4620 = "511_1305640955.436" 
    capture_lex $P4620
    $P4620($P4618)
  loop4631_next:
    goto loop4631_test
  loop4631_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4633, exception, 'type'
    eq $P4633, .CONTROL_LOOP_NEXT, loop4631_next
    eq $P4633, .CONTROL_LOOP_REDO, loop4631_redo
  loop4631_done:
    pop_eh 
  for_undef_2192:
.annotate 'line', 1669
    find_lex $P4636, "$attr"
    unless_null $P4636, vivify_2196
    new $P4636, "Undef"
  vivify_2196:
    defined $I4637, $P4636
    if $I4637, if_4635
.annotate 'line', 1675
    find_lex $P4646, "$/"
    unless_null $P4646, vivify_2197
    new $P4646, "Undef"
  vivify_2197:
    $P4647 = $P4646."CURSOR"()
    new $P4648, 'String'
    set $P4648, "Attribute '"
    find_lex $P4649, "$name"
    unless_null $P4649, vivify_2198
    new $P4649, "Undef"
  vivify_2198:
    concat $P4650, $P4648, $P4649
    concat $P4651, $P4650, "' not declared"
    $P4652 = $P4647."panic"($P4651)
.annotate 'line', 1674
    set $P4634, $P4652
.annotate 'line', 1669
    goto if_4635_end
  if_4635:
.annotate 'line', 1670
    find_lex $P4640, "$attr"
    unless_null $P4640, vivify_2199
    new $P4640, "Undef"
  vivify_2199:
    can $I4641, $P4640, "type"
    if $I4641, if_4639
    new $P4638, 'Integer'
    set $P4638, $I4641
    goto if_4639_end
  if_4639:
.annotate 'line', 1671
    find_lex $P4642, "$past"
    unless_null $P4642, vivify_2200
    new $P4642, "Undef"
  vivify_2200:
    find_lex $P4643, "$attr"
    unless_null $P4643, vivify_2201
    new $P4643, "Undef"
  vivify_2201:
    $P4644 = $P4643."type"()
    $P4645 = $P4642."type"($P4644)
.annotate 'line', 1670
    set $P4638, $P4645
  if_4639_end:
.annotate 'line', 1669
    set $P4634, $P4638
  if_4635_end:
.annotate 'line', 1661
    .return ($P4634)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4619"  :anon :subid("511_1305640955.436") :outer("510_1305640955.436")
    .param pmc param_4621
.annotate 'line', 1663
    .lex "$_", param_4621
.annotate 'line', 1664
    find_lex $P4624, "$_"
    unless_null $P4624, vivify_2193
    new $P4624, "Undef"
  vivify_2193:
    $S4625 = $P4624."name"()
    find_lex $P4626, "$name"
    unless_null $P4626, vivify_2194
    new $P4626, "Undef"
  vivify_2194:
    set $S4627, $P4626
    iseq $I4628, $S4625, $S4627
    if $I4628, if_4623
    new $P4622, 'Integer'
    set $P4622, $I4628
    goto if_4623_end
  if_4623:
.annotate 'line', 1665
    find_lex $P4629, "$_"
    unless_null $P4629, vivify_2195
    new $P4629, "Undef"
  vivify_2195:
    store_lex "$attr", $P4629
.annotate 'line', 1666
    set $I4630, .CONTROL_LOOP_LAST
    die 0, $I4630
  if_4623_end:
.annotate 'line', 1663
    .return ($P4622)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4532"  :anon :subid("508_1305640955.436") :outer("507_1305640955.436")
.annotate 'line', 1640
    new $P4534, "Undef"
    .lex "$global_fallback", $P4534
    find_lex $P4535, "$/"
    unless_null $P4535, vivify_2202
    $P4535 = root_new ['parrot';'Hash']
  vivify_2202:
    set $P4536, $P4535["sigil"]
    unless_null $P4536, vivify_2203
    new $P4536, "Undef"
  vivify_2203:
    set $S4537, $P4536
    new $P4538, 'String'
    set $P4538, $S4537
    find_lex $P4539, "$/"
    unless_null $P4539, vivify_2204
    $P4539 = root_new ['parrot';'Hash']
  vivify_2204:
    set $P4540, $P4539["desigilname"]
    unless_null $P4540, vivify_2205
    new $P4540, "Undef"
  vivify_2205:
    concat $P4541, $P4538, $P4540
    new $P4542, "ResizablePMCArray"
    push $P4542, "GLOBAL"
    push $P4542, $P4541
    find_lex $P4543, "$/"
    unless_null $P4543, vivify_2206
    new $P4543, "Undef"
  vivify_2206:
    $P4544 = "lexical_package_lookup"($P4542, $P4543)
    store_lex "$global_fallback", $P4544
.annotate 'line', 1641
    find_lex $P4545, "$global_fallback"
    unless_null $P4545, vivify_2207
    new $P4545, "Undef"
  vivify_2207:
    get_hll_global $P4546, "GLOBAL"
    nqp_get_package_through_who $P4547, $P4546, "PAST"
    get_who $P4548, $P4547
    set $P4549, $P4548["Op"]
.annotate 'line', 1642
    new $P4550, "String"
    assign $P4550, "Contextual "
    find_lex $P4551, "$/"
    unless_null $P4551, vivify_2208
    new $P4551, "Undef"
  vivify_2208:
    set $S4552, $P4551
    concat $P4553, $P4550, $S4552
    concat $P4554, $P4553, " not found"
    $P4555 = $P4549."new"($P4554, "die" :named("pirop"))
.annotate 'line', 1641
    $P4545."viviself"($P4555)
.annotate 'line', 1645
    get_hll_global $P4556, "GLOBAL"
    nqp_get_package_through_who $P4557, $P4556, "PAST"
    get_who $P4558, $P4557
    set $P4559, $P4558["Var"]
.annotate 'line', 1646
    find_lex $P4560, "@name"
    unless_null $P4560, vivify_2209
    $P4560 = root_new ['parrot';'ResizablePMCArray']
  vivify_2209:
    $P4561 = $P4560."pop"()
    set $S4562, $P4561
    find_lex $P4563, "$global_fallback"
    unless_null $P4563, vivify_2210
    new $P4563, "Undef"
  vivify_2210:
    $P4564 = $P4559."new"($S4562 :named("name"), "contextual" :named("scope"), $P4563 :named("viviself"))
.annotate 'line', 1645
    store_lex "$past", $P4564
.annotate 'line', 1639
    .return ($P4564)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>" :anon :subid("512_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4684
    .param pmc param_4685
.annotate 'line', 1692
    .lex "self", param_4684
    .lex "$/", param_4685
    find_lex $P4686, "$/"
    find_lex $P4687, "$/"
    unless_null $P4687, vivify_2223
    $P4687 = root_new ['parrot';'Hash']
  vivify_2223:
    set $P4688, $P4687["package_def"]
    unless_null $P4688, vivify_2224
    new $P4688, "Undef"
  vivify_2224:
    $P4689 = $P4688."ast"()
    $P4690 = $P4686."!make"($P4689)
    .return ($P4690)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>" :anon :subid("513_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4692
    .param pmc param_4693
.annotate 'line', 1693
    .lex "self", param_4692
    .lex "$/", param_4693
    find_lex $P4694, "$/"
    find_lex $P4695, "$/"
    unless_null $P4695, vivify_2225
    $P4695 = root_new ['parrot';'Hash']
  vivify_2225:
    set $P4696, $P4695["package_def"]
    unless_null $P4696, vivify_2226
    new $P4696, "Undef"
  vivify_2226:
    $P4697 = $P4696."ast"()
    $P4698 = $P4694."!make"($P4697)
    .return ($P4698)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>" :anon :subid("514_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4700
    .param pmc param_4701
.annotate 'line', 1694
    .lex "self", param_4700
    .lex "$/", param_4701
    find_lex $P4702, "$/"
    find_lex $P4703, "$/"
    unless_null $P4703, vivify_2227
    $P4703 = root_new ['parrot';'Hash']
  vivify_2227:
    set $P4704, $P4703["package_def"]
    unless_null $P4704, vivify_2228
    new $P4704, "Undef"
  vivify_2228:
    $P4705 = $P4704."ast"()
    $P4706 = $P4702."!make"($P4705)
    .return ($P4706)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>" :anon :subid("515_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4708
    .param pmc param_4709
.annotate 'line', 1695
    .lex "self", param_4708
    .lex "$/", param_4709
    find_lex $P4710, "$/"
    find_lex $P4711, "$/"
    unless_null $P4711, vivify_2229
    $P4711 = root_new ['parrot';'Hash']
  vivify_2229:
    set $P4712, $P4711["package_def"]
    unless_null $P4712, vivify_2230
    new $P4712, "Undef"
  vivify_2230:
    $P4713 = $P4712."ast"()
    $P4714 = $P4710."!make"($P4713)
    .return ($P4714)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>" :anon :subid("516_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4716
    .param pmc param_4717
.annotate 'line', 1696
    .lex "self", param_4716
    .lex "$/", param_4717
    find_lex $P4718, "$/"
    find_lex $P4719, "$/"
    unless_null $P4719, vivify_2231
    $P4719 = root_new ['parrot';'Hash']
  vivify_2231:
    set $P4720, $P4719["package_def"]
    unless_null $P4720, vivify_2232
    new $P4720, "Undef"
  vivify_2232:
    $P4721 = $P4720."ast"()
    $P4722 = $P4718."!make"($P4721)
    .return ($P4722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>" :anon :subid("517_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4724
    .param pmc param_4725
.annotate 'line', 1697
    .lex "self", param_4724
    .lex "$/", param_4725
    find_lex $P4726, "$/"
    find_lex $P4727, "$/"
    unless_null $P4727, vivify_2233
    $P4727 = root_new ['parrot';'Hash']
  vivify_2233:
    set $P4728, $P4727["package_def"]
    unless_null $P4728, vivify_2234
    new $P4728, "Undef"
  vivify_2234:
    $P4729 = $P4728."ast"()
    $P4730 = $P4726."!make"($P4729)
    .return ($P4730)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<stub>" :anon :subid("518_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4732
    .param pmc param_4733
.annotate 'line', 1699
    .lex "self", param_4732
    .lex "$/", param_4733
.annotate 'line', 1702
    new $P4734, "Undef"
    .lex "$HOW", $P4734
.annotate 'line', 1703
    new $P4735, "Undef"
    .lex "$PACKAGE", $P4735
.annotate 'line', 1702
    find_lex $P4736, "$/"
    unless_null $P4736, vivify_2235
    $P4736 = root_new ['parrot';'Hash']
  vivify_2235:
    set $P4737, $P4736["metaclass"]
    unless_null $P4737, vivify_2236
    $P4737 = root_new ['parrot';'Hash']
  vivify_2236:
    set $P4738, $P4737["identifier"]
    unless_null $P4738, vivify_2237
    new $P4738, "Undef"
  vivify_2237:
    find_lex $P4739, "$/"
    unless_null $P4739, vivify_2238
    new $P4739, "Undef"
  vivify_2238:
    $P4740 = "find_sym"($P4738, $P4739)
    store_lex "$HOW", $P4740
.annotate 'line', 1703
    find_dynamic_lex $P4743, "$*SC"
    unless_null $P4743, vivify_2239
    get_hll_global $P4741, "GLOBAL"
    get_who $P4742, $P4741
    set $P4743, $P4742["$SC"]
    unless_null $P4743, vivify_2240
    die "Contextual $*SC not found"
  vivify_2240:
  vivify_2239:
    find_lex $P4744, "$HOW"
    unless_null $P4744, vivify_2241
    new $P4744, "Undef"
  vivify_2241:
    find_lex $P4745, "$/"
    unless_null $P4745, vivify_2242
    $P4745 = root_new ['parrot';'Hash']
  vivify_2242:
    set $P4746, $P4745["name"]
    unless_null $P4746, vivify_2243
    new $P4746, "Undef"
  vivify_2243:
    set $S4747, $P4746
    $P4748 = $P4743."pkg_create_mo"($P4744, $S4747 :named("name"))
    store_lex "$PACKAGE", $P4748
.annotate 'line', 1706
    find_dynamic_lex $P4754, "$*SCOPE"
    unless_null $P4754, vivify_2244
    get_hll_global $P4752, "GLOBAL"
    get_who $P4753, $P4752
    set $P4754, $P4753["$SCOPE"]
    unless_null $P4754, vivify_2245
    die "Contextual $*SCOPE not found"
  vivify_2245:
  vivify_2244:
    set $S4755, $P4754
    iseq $I4756, $S4755, "our"
    unless $I4756, unless_4751
    new $P4750, 'Integer'
    set $P4750, $I4756
    goto unless_4751_end
  unless_4751:
    find_dynamic_lex $P4759, "$*SCOPE"
    unless_null $P4759, vivify_2246
    get_hll_global $P4757, "GLOBAL"
    get_who $P4758, $P4757
    set $P4759, $P4758["$SCOPE"]
    unless_null $P4759, vivify_2247
    die "Contextual $*SCOPE not found"
  vivify_2247:
  vivify_2246:
    set $S4760, $P4759
    iseq $I4761, $S4760, ""
    new $P4750, 'Integer'
    set $P4750, $I4761
  unless_4751_end:
    if $P4750, if_4749
.annotate 'line', 1712
    find_dynamic_lex $P4793, "$*SCOPE"
    unless_null $P4793, vivify_2248
    get_hll_global $P4791, "GLOBAL"
    get_who $P4792, $P4791
    set $P4793, $P4792["$SCOPE"]
    unless_null $P4793, vivify_2249
    die "Contextual $*SCOPE not found"
  vivify_2249:
  vivify_2248:
    set $S4794, $P4793
    iseq $I4795, $S4794, "my"
    if $I4795, if_4790
.annotate 'line', 1719
    find_lex $P4817, "$/"
    unless_null $P4817, vivify_2250
    new $P4817, "Undef"
  vivify_2250:
    $P4818 = $P4817."CURSOR"()
    find_dynamic_lex $P4821, "$*SCOPE"
    unless_null $P4821, vivify_2251
    get_hll_global $P4819, "GLOBAL"
    get_who $P4820, $P4819
    set $P4821, $P4820["$SCOPE"]
    unless_null $P4821, vivify_2252
    die "Contextual $*SCOPE not found"
  vivify_2252:
  vivify_2251:
    concat $P4822, $P4821, " scoped packages are not supported"
    $P4818."panic"($P4822)
.annotate 'line', 1718
    goto if_4790_end
  if_4790:
.annotate 'line', 1713
    find_lex $P4797, "$/"
    unless_null $P4797, vivify_2253
    $P4797 = root_new ['parrot';'Hash']
  vivify_2253:
    set $P4798, $P4797["name"]
    unless_null $P4798, vivify_2254
    $P4798 = root_new ['parrot';'Hash']
  vivify_2254:
    set $P4799, $P4798["identifier"]
    unless_null $P4799, vivify_2255
    new $P4799, "Undef"
  vivify_2255:
    set $N4800, $P4799
    isne $I4801, $N4800, 1.0
    unless $I4801, if_4796_end
.annotate 'line', 1714
    find_lex $P4802, "$/"
    unless_null $P4802, vivify_2256
    $P4802 = root_new ['parrot';'Hash']
  vivify_2256:
    set $P4803, $P4802["name"]
    unless_null $P4803, vivify_2257
    new $P4803, "Undef"
  vivify_2257:
    $P4804 = $P4803."CURSOR"()
    $P4804."panic"("A my scoped package cannot have a multi-part name yet")
  if_4796_end:
.annotate 'line', 1716
    find_dynamic_lex $P4807, "$*SC"
    unless_null $P4807, vivify_2258
    get_hll_global $P4805, "GLOBAL"
    get_who $P4806, $P4805
    set $P4807, $P4806["$SC"]
    unless_null $P4807, vivify_2259
    die "Contextual $*SC not found"
  vivify_2259:
  vivify_2258:
    find_lex $P4808, "$?PACKAGE"
    get_who $P4809, $P4808
    set $P4810, $P4809["@BLOCK"]
    unless_null $P4810, vivify_2260
    $P4810 = root_new ['parrot';'ResizablePMCArray']
  vivify_2260:
    set $P4811, $P4810[0]
    unless_null $P4811, vivify_2261
    new $P4811, "Undef"
  vivify_2261:
    find_lex $P4812, "$/"
    unless_null $P4812, vivify_2262
    $P4812 = root_new ['parrot';'Hash']
  vivify_2262:
    set $P4813, $P4812["name"]
    unless_null $P4813, vivify_2263
    $P4813 = root_new ['parrot';'Hash']
  vivify_2263:
    set $P4814, $P4813["identifier"]
    unless_null $P4814, vivify_2264
    $P4814 = root_new ['parrot';'ResizablePMCArray']
  vivify_2264:
    set $P4815, $P4814[0]
    unless_null $P4815, vivify_2265
    new $P4815, "Undef"
  vivify_2265:
    find_lex $P4816, "$PACKAGE"
    unless_null $P4816, vivify_2266
    new $P4816, "Undef"
  vivify_2266:
    $P4807."install_lexical_symbol"($P4811, $P4815, $P4816)
  if_4790_end:
.annotate 'line', 1712
    goto if_4749_end
  if_4749:
.annotate 'line', 1707
    find_dynamic_lex $P4764, "$*SC"
    unless_null $P4764, vivify_2267
    get_hll_global $P4762, "GLOBAL"
    get_who $P4763, $P4762
    set $P4764, $P4763["$SC"]
    unless_null $P4764, vivify_2268
    die "Contextual $*SC not found"
  vivify_2268:
  vivify_2267:
    find_dynamic_lex $P4767, "$*OUTERPACKAGE"
    unless_null $P4767, vivify_2269
    get_hll_global $P4765, "GLOBAL"
    get_who $P4766, $P4765
    set $P4767, $P4766["$OUTERPACKAGE"]
    unless_null $P4767, vivify_2270
    die "Contextual $*OUTERPACKAGE not found"
  vivify_2270:
  vivify_2269:
    find_lex $P4768, "$/"
    unless_null $P4768, vivify_2271
    $P4768 = root_new ['parrot';'Hash']
  vivify_2271:
    set $P4769, $P4768["name"]
    unless_null $P4769, vivify_2272
    $P4769 = root_new ['parrot';'Hash']
  vivify_2272:
    set $P4770, $P4769["identifier"]
    unless_null $P4770, vivify_2273
    new $P4770, "Undef"
  vivify_2273:
    find_lex $P4771, "$PACKAGE"
    unless_null $P4771, vivify_2274
    new $P4771, "Undef"
  vivify_2274:
    $P4764."install_package_symbol"($P4767, $P4770, $P4771)
.annotate 'line', 1708
    find_lex $P4773, "$/"
    unless_null $P4773, vivify_2275
    $P4773 = root_new ['parrot';'Hash']
  vivify_2275:
    set $P4774, $P4773["name"]
    unless_null $P4774, vivify_2276
    $P4774 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P4775, $P4774["identifier"]
    unless_null $P4775, vivify_2277
    new $P4775, "Undef"
  vivify_2277:
    set $N4776, $P4775
    iseq $I4777, $N4776, 1.0
    unless $I4777, if_4772_end
.annotate 'line', 1709
    find_dynamic_lex $P4780, "$*SC"
    unless_null $P4780, vivify_2278
    get_hll_global $P4778, "GLOBAL"
    get_who $P4779, $P4778
    set $P4780, $P4779["$SC"]
    unless_null $P4780, vivify_2279
    die "Contextual $*SC not found"
  vivify_2279:
  vivify_2278:
    find_lex $P4781, "$?PACKAGE"
    get_who $P4782, $P4781
    set $P4783, $P4782["@BLOCK"]
    unless_null $P4783, vivify_2280
    $P4783 = root_new ['parrot';'ResizablePMCArray']
  vivify_2280:
    set $P4784, $P4783[0]
    unless_null $P4784, vivify_2281
    new $P4784, "Undef"
  vivify_2281:
    find_lex $P4785, "$/"
    unless_null $P4785, vivify_2282
    $P4785 = root_new ['parrot';'Hash']
  vivify_2282:
    set $P4786, $P4785["name"]
    unless_null $P4786, vivify_2283
    $P4786 = root_new ['parrot';'Hash']
  vivify_2283:
    set $P4787, $P4786["identifier"]
    unless_null $P4787, vivify_2284
    $P4787 = root_new ['parrot';'ResizablePMCArray']
  vivify_2284:
    set $P4788, $P4787[0]
    unless_null $P4788, vivify_2285
    new $P4788, "Undef"
  vivify_2285:
    find_lex $P4789, "$PACKAGE"
    unless_null $P4789, vivify_2286
    new $P4789, "Undef"
  vivify_2286:
    $P4780."install_lexical_symbol"($P4784, $P4788, $P4789)
  if_4772_end:
  if_4749_end:
.annotate 'line', 1722
    find_lex $P4823, "$/"
    get_hll_global $P4824, "GLOBAL"
    nqp_get_package_through_who $P4825, $P4824, "PAST"
    get_who $P4826, $P4825
    set $P4827, $P4826["Stmts"]
    $P4828 = $P4827."new"()
    $P4829 = $P4823."!make"($P4828)
.annotate 'line', 1699
    .return ($P4829)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def" :anon :subid("519_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_4831
    .param pmc param_4832
.annotate 'line', 1725
    .const 'Sub' $P5012 = "523_1305640955.436" 
    capture_lex $P5012
    .const 'Sub' $P4982 = "522_1305640955.436" 
    capture_lex $P4982
    .const 'Sub' $P4935 = "520_1305640955.436" 
    capture_lex $P4935
    .lex "self", param_4831
    .lex "$/", param_4832
.annotate 'line', 1727
    $P4833 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4833
.annotate 'line', 1728
    new $P4834, "Undef"
    .lex "$name", $P4834
.annotate 'line', 1729
    new $P4835, "Undef"
    .lex "$how", $P4835
.annotate 'line', 1732
    new $P4836, "Undef"
    .lex "$past", $P4836
.annotate 'line', 1727
    find_lex $P4837, "$/"
    unless_null $P4837, vivify_2287
    $P4837 = root_new ['parrot';'Hash']
  vivify_2287:
    set $P4838, $P4837["name"]
    unless_null $P4838, vivify_2288
    $P4838 = root_new ['parrot';'Hash']
  vivify_2288:
    set $P4839, $P4838["identifier"]
    unless_null $P4839, vivify_2289
    new $P4839, "Undef"
  vivify_2289:
    clone $P4840, $P4839
    store_lex "@ns", $P4840
.annotate 'line', 1728
    find_lex $P4841, "@ns"
    unless_null $P4841, vivify_2290
    $P4841 = root_new ['parrot';'ResizablePMCArray']
  vivify_2290:
    $P4842 = $P4841."pop"()
    set $S4843, $P4842
    new $P4844, 'String'
    set $P4844, $S4843
    store_lex "$name", $P4844
.annotate 'line', 1729
    find_dynamic_lex $P4847, "$*PKGDECL"
    unless_null $P4847, vivify_2291
    get_hll_global $P4845, "GLOBAL"
    get_who $P4846, $P4845
    set $P4847, $P4846["$PKGDECL"]
    unless_null $P4847, vivify_2292
    die "Contextual $*PKGDECL not found"
  vivify_2292:
  vivify_2291:
    find_dynamic_lex $P4850, "%*HOW"
    unless_null $P4850, vivify_2293
    get_hll_global $P4848, "GLOBAL"
    get_who $P4849, $P4848
    set $P4850, $P4849["%HOW"]
    unless_null $P4850, vivify_2294
    die "Contextual %*HOW not found"
  vivify_2294:
  vivify_2293:
    set $P4851, $P4850[$P4847]
    unless_null $P4851, vivify_2295
    new $P4851, "Undef"
  vivify_2295:
    store_lex "$how", $P4851
.annotate 'line', 1732
    find_lex $P4854, "$/"
    unless_null $P4854, vivify_2296
    $P4854 = root_new ['parrot';'Hash']
  vivify_2296:
    set $P4855, $P4854["block"]
    unless_null $P4855, vivify_2297
    new $P4855, "Undef"
  vivify_2297:
    if $P4855, if_4853
    find_lex $P4859, "$/"
    unless_null $P4859, vivify_2298
    $P4859 = root_new ['parrot';'Hash']
  vivify_2298:
    set $P4860, $P4859["comp_unit"]
    unless_null $P4860, vivify_2299
    new $P4860, "Undef"
  vivify_2299:
    $P4861 = $P4860."ast"()
    set $P4852, $P4861
    goto if_4853_end
  if_4853:
    find_lex $P4856, "$/"
    unless_null $P4856, vivify_2300
    $P4856 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P4857, $P4856["block"]
    unless_null $P4857, vivify_2301
    new $P4857, "Undef"
  vivify_2301:
    $P4858 = $P4857."ast"()
    set $P4852, $P4858
  if_4853_end:
    store_lex "$past", $P4852
.annotate 'line', 1733
    find_dynamic_lex $P4867, "$*SCOPE"
    unless_null $P4867, vivify_2302
    get_hll_global $P4865, "GLOBAL"
    get_who $P4866, $P4865
    set $P4867, $P4866["$SCOPE"]
    unless_null $P4867, vivify_2303
    die "Contextual $*SCOPE not found"
  vivify_2303:
  vivify_2302:
    set $S4868, $P4867
    iseq $I4869, $S4868, "our"
    unless $I4869, unless_4864
    new $P4863, 'Integer'
    set $P4863, $I4869
    goto unless_4864_end
  unless_4864:
    find_dynamic_lex $P4872, "$*SCOPE"
    unless_null $P4872, vivify_2304
    get_hll_global $P4870, "GLOBAL"
    get_who $P4871, $P4870
    set $P4872, $P4871["$SCOPE"]
    unless_null $P4872, vivify_2305
    die "Contextual $*SCOPE not found"
  vivify_2305:
  vivify_2304:
    set $S4873, $P4872
    iseq $I4874, $S4873, ""
    new $P4863, 'Integer'
    set $P4863, $I4874
  unless_4864_end:
    unless $P4863, if_4862_end
.annotate 'line', 1734
    find_lex $P4875, "$past"
    unless_null $P4875, vivify_2306
    new $P4875, "Undef"
  vivify_2306:
    find_lex $P4876, "$/"
    unless_null $P4876, vivify_2307
    $P4876 = root_new ['parrot';'Hash']
  vivify_2307:
    set $P4877, $P4876["name"]
    unless_null $P4877, vivify_2308
    $P4877 = root_new ['parrot';'Hash']
  vivify_2308:
    set $P4878, $P4877["identifier"]
    unless_null $P4878, vivify_2309
    new $P4878, "Undef"
  vivify_2309:
    $P4875."namespace"($P4878)
  if_4862_end:
.annotate 'line', 1741
    find_lex $P4882, "$how"
    unless_null $P4882, vivify_2310
    new $P4882, "Undef"
  vivify_2310:
    can $I4883, $P4882, "parametric"
    if $I4883, if_4881
    new $P4880, 'Integer'
    set $P4880, $I4883
    goto if_4881_end
  if_4881:
    find_lex $P4884, "$how"
    unless_null $P4884, vivify_2311
    new $P4884, "Undef"
  vivify_2311:
    find_lex $P4885, "$how"
    unless_null $P4885, vivify_2312
    new $P4885, "Undef"
  vivify_2312:
    $P4886 = $P4884."parametric"($P4885)
    set $P4880, $P4886
  if_4881_end:
    if $P4880, if_4879
.annotate 'line', 1750
    find_lex $P4916, "$past"
    unless_null $P4916, vivify_2313
    new $P4916, "Undef"
  vivify_2313:
    $P4916."blocktype"("immediate")
.annotate 'line', 1751
    find_dynamic_lex $P4919, "$*SC"
    unless_null $P4919, vivify_2314
    get_hll_global $P4917, "GLOBAL"
    get_who $P4918, $P4917
    set $P4919, $P4918["$SC"]
    unless_null $P4919, vivify_2315
    die "Contextual $*SC not found"
  vivify_2315:
  vivify_2314:
    find_lex $P4920, "$past"
    unless_null $P4920, vivify_2316
    new $P4920, "Undef"
  vivify_2316:
    find_dynamic_lex $P4923, "$*PACKAGE"
    unless_null $P4923, vivify_2317
    get_hll_global $P4921, "GLOBAL"
    get_who $P4922, $P4921
    set $P4923, $P4922["$PACKAGE"]
    unless_null $P4923, vivify_2318
    die "Contextual $*PACKAGE not found"
  vivify_2318:
  vivify_2317:
    $P4919."install_lexical_symbol"($P4920, "$?PACKAGE", $P4923)
.annotate 'line', 1752
    find_dynamic_lex $P4926, "$*SC"
    unless_null $P4926, vivify_2319
    get_hll_global $P4924, "GLOBAL"
    get_who $P4925, $P4924
    set $P4926, $P4925["$SC"]
    unless_null $P4926, vivify_2320
    die "Contextual $*SC not found"
  vivify_2320:
  vivify_2319:
    find_lex $P4927, "$past"
    unless_null $P4927, vivify_2321
    new $P4927, "Undef"
  vivify_2321:
    find_dynamic_lex $P4930, "$*PACKAGE"
    unless_null $P4930, vivify_2322
    get_hll_global $P4928, "GLOBAL"
    get_who $P4929, $P4928
    set $P4930, $P4929["$PACKAGE"]
    unless_null $P4930, vivify_2323
    die "Contextual $*PACKAGE not found"
  vivify_2323:
  vivify_2322:
    $P4926."install_lexical_symbol"($P4927, "$?CLASS", $P4930)
.annotate 'line', 1749
    goto if_4879_end
  if_4879:
.annotate 'line', 1742
    find_lex $P4887, "$past"
    unless_null $P4887, vivify_2324
    new $P4887, "Undef"
  vivify_2324:
    $P4887."blocktype"("declaration")
.annotate 'line', 1743
    find_lex $P4888, "$past"
    unless_null $P4888, vivify_2325
    new $P4888, "Undef"
  vivify_2325:
    get_hll_global $P4889, "GLOBAL"
    nqp_get_package_through_who $P4890, $P4889, "PAST"
    get_who $P4891, $P4890
    set $P4892, $P4891["Var"]
    $P4893 = $P4892."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4888."unshift"($P4893)
.annotate 'line', 1744
    find_lex $P4894, "$past"
    unless_null $P4894, vivify_2326
    new $P4894, "Undef"
  vivify_2326:
    $P4894."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1745
    find_dynamic_lex $P4897, "$*SC"
    unless_null $P4897, vivify_2327
    get_hll_global $P4895, "GLOBAL"
    get_who $P4896, $P4895
    set $P4897, $P4896["$SC"]
    unless_null $P4897, vivify_2328
    die "Contextual $*SC not found"
  vivify_2328:
  vivify_2327:
    find_dynamic_lex $P4900, "$*PACKAGE"
    unless_null $P4900, vivify_2329
    get_hll_global $P4898, "GLOBAL"
    get_who $P4899, $P4898
    set $P4900, $P4899["$PACKAGE"]
    unless_null $P4900, vivify_2330
    die "Contextual $*PACKAGE not found"
  vivify_2330:
  vivify_2329:
    find_lex $P4901, "$past"
    unless_null $P4901, vivify_2331
    new $P4901, "Undef"
  vivify_2331:
    $P4897."pkg_set_body_block"($P4900, $P4901)
.annotate 'line', 1746
    find_dynamic_lex $P4904, "$*SC"
    unless_null $P4904, vivify_2332
    get_hll_global $P4902, "GLOBAL"
    get_who $P4903, $P4902
    set $P4904, $P4903["$SC"]
    unless_null $P4904, vivify_2333
    die "Contextual $*SC not found"
  vivify_2333:
  vivify_2332:
    find_lex $P4905, "$past"
    unless_null $P4905, vivify_2334
    new $P4905, "Undef"
  vivify_2334:
    find_dynamic_lex $P4908, "$*PACKAGE"
    unless_null $P4908, vivify_2335
    get_hll_global $P4906, "GLOBAL"
    get_who $P4907, $P4906
    set $P4908, $P4907["$PACKAGE"]
    unless_null $P4908, vivify_2336
    die "Contextual $*PACKAGE not found"
  vivify_2336:
  vivify_2335:
    $P4904."install_lexical_symbol"($P4905, "$?PACKAGE", $P4908)
.annotate 'line', 1747
    find_dynamic_lex $P4911, "$*SC"
    unless_null $P4911, vivify_2337
    get_hll_global $P4909, "GLOBAL"
    get_who $P4910, $P4909
    set $P4911, $P4910["$SC"]
    unless_null $P4911, vivify_2338
    die "Contextual $*SC not found"
  vivify_2338:
  vivify_2337:
    find_lex $P4912, "$past"
    unless_null $P4912, vivify_2339
    new $P4912, "Undef"
  vivify_2339:
    find_dynamic_lex $P4915, "$*PACKAGE"
    unless_null $P4915, vivify_2340
    get_hll_global $P4913, "GLOBAL"
    get_who $P4914, $P4913
    set $P4915, $P4914["$PACKAGE"]
    unless_null $P4915, vivify_2341
    die "Contextual $*PACKAGE not found"
  vivify_2341:
  vivify_2340:
    $P4911."install_lexical_symbol"($P4912, "$?ROLE", $P4915)
  if_4879_end:
.annotate 'line', 1756
    find_lex $P4932, "$/"
    unless_null $P4932, vivify_2342
    $P4932 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P4933, $P4932["parent"]
    unless_null $P4933, vivify_2343
    new $P4933, "Undef"
  vivify_2343:
    if $P4933, if_4931
.annotate 'line', 1770
    find_lex $P4979, "$how"
    unless_null $P4979, vivify_2344
    new $P4979, "Undef"
  vivify_2344:
    can $I4980, $P4979, "set_default_parent"
    unless $I4980, if_4978_end
    .const 'Sub' $P4982 = "522_1305640955.436" 
    capture_lex $P4982
    $P4982()
  if_4978_end:
    goto if_4931_end
  if_4931:
.annotate 'line', 1756
    .const 'Sub' $P4935 = "520_1305640955.436" 
    capture_lex $P4935
    $P4935()
  if_4931_end:
.annotate 'line', 1777
    find_lex $P5004, "$/"
    unless_null $P5004, vivify_2370
    $P5004 = root_new ['parrot';'Hash']
  vivify_2370:
    set $P5005, $P5004["role"]
    unless_null $P5005, vivify_2371
    new $P5005, "Undef"
  vivify_2371:
    unless $P5005, if_5003_end
.annotate 'line', 1778
    find_lex $P5007, "$/"
    unless_null $P5007, vivify_2372
    $P5007 = root_new ['parrot';'Hash']
  vivify_2372:
    set $P5008, $P5007["role"]
    unless_null $P5008, vivify_2373
    new $P5008, "Undef"
  vivify_2373:
    defined $I5009, $P5008
    unless $I5009, for_undef_2374
    iter $P5006, $P5008
    new $P5053, 'ExceptionHandler'
    set_label $P5053, loop5052_handler
    $P5053."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5053
  loop5052_test:
    unless $P5006, loop5052_done
    shift $P5010, $P5006
  loop5052_redo:
    .const 'Sub' $P5012 = "523_1305640955.436" 
    capture_lex $P5012
    $P5012($P5010)
  loop5052_next:
    goto loop5052_test
  loop5052_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5054, exception, 'type'
    eq $P5054, .CONTROL_LOOP_NEXT, loop5052_next
    eq $P5054, .CONTROL_LOOP_REDO, loop5052_redo
  loop5052_done:
    pop_eh 
  for_undef_2374:
  if_5003_end:
.annotate 'line', 1795
    find_dynamic_lex $P5057, "$*SC"
    unless_null $P5057, vivify_2388
    get_hll_global $P5055, "GLOBAL"
    get_who $P5056, $P5055
    set $P5057, $P5056["$SC"]
    unless_null $P5057, vivify_2389
    die "Contextual $*SC not found"
  vivify_2389:
  vivify_2388:
    find_dynamic_lex $P5060, "$*PACKAGE"
    unless_null $P5060, vivify_2390
    get_hll_global $P5058, "GLOBAL"
    get_who $P5059, $P5058
    set $P5060, $P5059["$PACKAGE"]
    unless_null $P5060, vivify_2391
    die "Contextual $*PACKAGE not found"
  vivify_2391:
  vivify_2390:
    $P5057."pkg_compose"($P5060)
.annotate 'line', 1797
    find_lex $P5061, "$/"
    find_lex $P5062, "$past"
    unless_null $P5062, vivify_2392
    new $P5062, "Undef"
  vivify_2392:
    $P5063 = $P5061."!make"($P5062)
.annotate 'line', 1725
    .return ($P5063)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4981"  :anon :subid("522_1305640955.436") :outer("519_1305640955.436")
.annotate 'line', 1771
    new $P4983, "Undef"
    .lex "$default", $P4983
    find_dynamic_lex $P4988, "$*PKGDECL"
    unless_null $P4988, vivify_2345
    get_hll_global $P4986, "GLOBAL"
    get_who $P4987, $P4986
    set $P4988, $P4987["$PKGDECL"]
    unless_null $P4988, vivify_2346
    die "Contextual $*PKGDECL not found"
  vivify_2346:
  vivify_2345:
    set $S4989, $P4988
    iseq $I4990, $S4989, "grammar"
    if $I4990, if_4985
    new $P4992, "ResizablePMCArray"
    push $P4992, "NQPMu"
    set $P4984, $P4992
    goto if_4985_end
  if_4985:
    new $P4991, "ResizablePMCArray"
    push $P4991, "Regex"
    push $P4991, "Cursor"
    set $P4984, $P4991
  if_4985_end:
    store_lex "$default", $P4984
.annotate 'line', 1772
    find_dynamic_lex $P4995, "$*SC"
    unless_null $P4995, vivify_2347
    get_hll_global $P4993, "GLOBAL"
    get_who $P4994, $P4993
    set $P4995, $P4994["$SC"]
    unless_null $P4995, vivify_2348
    die "Contextual $*SC not found"
  vivify_2348:
  vivify_2347:
    find_dynamic_lex $P4998, "$*PACKAGE"
    unless_null $P4998, vivify_2349
    get_hll_global $P4996, "GLOBAL"
    get_who $P4997, $P4996
    set $P4998, $P4997["$PACKAGE"]
    unless_null $P4998, vivify_2350
    die "Contextual $*PACKAGE not found"
  vivify_2350:
  vivify_2349:
.annotate 'line', 1773
    find_lex $P4999, "$default"
    unless_null $P4999, vivify_2351
    new $P4999, "Undef"
  vivify_2351:
    find_lex $P5000, "$/"
    unless_null $P5000, vivify_2352
    new $P5000, "Undef"
  vivify_2352:
    $P5001 = "find_sym"($P4999, $P5000)
    $P5002 = $P4995."pkg_add_parent_or_role"($P4998, "set_default_parent", $P5001)
.annotate 'line', 1770
    .return ($P5002)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4934"  :anon :subid("520_1305640955.436") :outer("519_1305640955.436")
.annotate 'line', 1756
    .const 'Sub' $P4941 = "521_1305640955.436" 
    capture_lex $P4941
.annotate 'line', 1757
    new $P4936, "Undef"
    .lex "$parent", $P4936
.annotate 'line', 1758
    new $P4937, "Undef"
    .lex "$parent_found", $P4937
.annotate 'line', 1756
    find_lex $P4938, "$parent"
    unless_null $P4938, vivify_2353
    new $P4938, "Undef"
  vivify_2353:
    find_lex $P4939, "$parent_found"
    unless_null $P4939, vivify_2354
    new $P4939, "Undef"
  vivify_2354:
.annotate 'line', 1759
    .const 'Sub' $P4941 = "521_1305640955.436" 
    capture_lex $P4941
    $P4941()
.annotate 'line', 1763
    find_lex $P4959, "$parent_found"
    unless_null $P4959, vivify_2360
    new $P4959, "Undef"
  vivify_2360:
    if $P4959, if_4958
.annotate 'line', 1767
    find_lex $P4968, "$/"
    unless_null $P4968, vivify_2361
    new $P4968, "Undef"
  vivify_2361:
    $P4969 = $P4968."CURSOR"()
    new $P4970, "String"
    assign $P4970, "Could not find parent class '"
    find_lex $P4971, "$/"
    unless_null $P4971, vivify_2362
    $P4971 = root_new ['parrot';'Hash']
  vivify_2362:
    set $P4972, $P4971["parent"]
    unless_null $P4972, vivify_2363
    $P4972 = root_new ['parrot';'ResizablePMCArray']
  vivify_2363:
    set $P4973, $P4972[0]
    unless_null $P4973, vivify_2364
    new $P4973, "Undef"
  vivify_2364:
    set $S4974, $P4973
    concat $P4975, $P4970, $S4974
    concat $P4976, $P4975, "'"
    $P4977 = $P4969."panic"($P4976)
.annotate 'line', 1766
    set $P4957, $P4977
.annotate 'line', 1763
    goto if_4958_end
  if_4958:
.annotate 'line', 1764
    find_dynamic_lex $P4962, "$*SC"
    unless_null $P4962, vivify_2365
    get_hll_global $P4960, "GLOBAL"
    get_who $P4961, $P4960
    set $P4962, $P4961["$SC"]
    unless_null $P4962, vivify_2366
    die "Contextual $*SC not found"
  vivify_2366:
  vivify_2365:
    find_dynamic_lex $P4965, "$*PACKAGE"
    unless_null $P4965, vivify_2367
    get_hll_global $P4963, "GLOBAL"
    get_who $P4964, $P4963
    set $P4965, $P4964["$PACKAGE"]
    unless_null $P4965, vivify_2368
    die "Contextual $*PACKAGE not found"
  vivify_2368:
  vivify_2367:
    find_lex $P4966, "$parent"
    unless_null $P4966, vivify_2369
    new $P4966, "Undef"
  vivify_2369:
    $P4967 = $P4962."pkg_add_parent_or_role"($P4965, "add_parent", $P4966)
.annotate 'line', 1763
    set $P4957, $P4967
  if_4958_end:
.annotate 'line', 1756
    .return ($P4957)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4940"  :anon :subid("521_1305640955.436") :outer("520_1305640955.436")
.annotate 'line', 1759
    new $P4952, 'ExceptionHandler'
    set_label $P4952, control_4951
    $P4952."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4952
.annotate 'line', 1760
    find_lex $P4942, "$/"
    unless_null $P4942, vivify_2355
    $P4942 = root_new ['parrot';'Hash']
  vivify_2355:
    set $P4943, $P4942["parent"]
    unless_null $P4943, vivify_2356
    $P4943 = root_new ['parrot';'ResizablePMCArray']
  vivify_2356:
    set $P4944, $P4943[0]
    unless_null $P4944, vivify_2357
    $P4944 = root_new ['parrot';'Hash']
  vivify_2357:
    set $P4945, $P4944["identifier"]
    unless_null $P4945, vivify_2358
    new $P4945, "Undef"
  vivify_2358:
    clone $P4946, $P4945
    find_lex $P4947, "$/"
    unless_null $P4947, vivify_2359
    new $P4947, "Undef"
  vivify_2359:
    $P4948 = "find_sym"($P4946, $P4947)
    store_lex "$parent", $P4948
.annotate 'line', 1761
    new $P4949, "Integer"
    assign $P4949, 1
    store_lex "$parent_found", $P4949
.annotate 'line', 1759
    pop_eh 
    goto skip_handler_4950
  control_4951:
    .local pmc exception 
    .get_results (exception) 
    new $P4955, 'Integer'
    set $P4955, 1
    set exception["handled"], $P4955
    set $I4956, exception["handled"]
    ne $I4956, 1, nothandled_4954
  handled_4953:
    .return (exception)
  nothandled_4954:
    rethrow exception
  skip_handler_4950:
    .return ($P4949)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5011"  :anon :subid("523_1305640955.436") :outer("519_1305640955.436")
    .param pmc param_5015
.annotate 'line', 1778
    .const 'Sub' $P5019 = "524_1305640955.436" 
    capture_lex $P5019
.annotate 'line', 1779
    new $P5013, "Undef"
    .lex "$role", $P5013
.annotate 'line', 1780
    new $P5014, "Undef"
    .lex "$role_found", $P5014
    .lex "$_", param_5015
.annotate 'line', 1778
    find_lex $P5016, "$role"
    unless_null $P5016, vivify_2375
    new $P5016, "Undef"
  vivify_2375:
    find_lex $P5017, "$role_found"
    unless_null $P5017, vivify_2376
    new $P5017, "Undef"
  vivify_2376:
.annotate 'line', 1781
    .const 'Sub' $P5019 = "524_1305640955.436" 
    capture_lex $P5019
    $P5019()
.annotate 'line', 1785
    find_lex $P5035, "$role_found"
    unless_null $P5035, vivify_2380
    new $P5035, "Undef"
  vivify_2380:
    if $P5035, if_5034
.annotate 'line', 1789
    find_lex $P5044, "$/"
    unless_null $P5044, vivify_2381
    new $P5044, "Undef"
  vivify_2381:
    $P5045 = $P5044."CURSOR"()
    new $P5046, "String"
    assign $P5046, "Could not find role '"
    find_lex $P5047, "$_"
    unless_null $P5047, vivify_2382
    new $P5047, "Undef"
  vivify_2382:
    set $S5048, $P5047
    concat $P5049, $P5046, $S5048
    concat $P5050, $P5049, "'"
    $P5051 = $P5045."panic"($P5050)
.annotate 'line', 1788
    set $P5033, $P5051
.annotate 'line', 1785
    goto if_5034_end
  if_5034:
.annotate 'line', 1786
    find_dynamic_lex $P5038, "$*SC"
    unless_null $P5038, vivify_2383
    get_hll_global $P5036, "GLOBAL"
    get_who $P5037, $P5036
    set $P5038, $P5037["$SC"]
    unless_null $P5038, vivify_2384
    die "Contextual $*SC not found"
  vivify_2384:
  vivify_2383:
    find_dynamic_lex $P5041, "$*PACKAGE"
    unless_null $P5041, vivify_2385
    get_hll_global $P5039, "GLOBAL"
    get_who $P5040, $P5039
    set $P5041, $P5040["$PACKAGE"]
    unless_null $P5041, vivify_2386
    die "Contextual $*PACKAGE not found"
  vivify_2386:
  vivify_2385:
    find_lex $P5042, "$role"
    unless_null $P5042, vivify_2387
    new $P5042, "Undef"
  vivify_2387:
    $P5043 = $P5038."pkg_add_parent_or_role"($P5041, "add_role", $P5042)
.annotate 'line', 1785
    set $P5033, $P5043
  if_5034_end:
.annotate 'line', 1778
    .return ($P5033)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5018"  :anon :subid("524_1305640955.436") :outer("523_1305640955.436")
.annotate 'line', 1781
    new $P5028, 'ExceptionHandler'
    set_label $P5028, control_5027
    $P5028."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P5028
.annotate 'line', 1782
    find_lex $P5020, "$_"
    unless_null $P5020, vivify_2377
    $P5020 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P5021, $P5020["identifier"]
    unless_null $P5021, vivify_2378
    new $P5021, "Undef"
  vivify_2378:
    clone $P5022, $P5021
    find_lex $P5023, "$/"
    unless_null $P5023, vivify_2379
    new $P5023, "Undef"
  vivify_2379:
    $P5024 = "find_sym"($P5022, $P5023)
    store_lex "$role", $P5024
.annotate 'line', 1783
    new $P5025, "Integer"
    assign $P5025, 1
    store_lex "$role_found", $P5025
.annotate 'line', 1781
    pop_eh 
    goto skip_handler_5026
  control_5027:
    .local pmc exception 
    .get_results (exception) 
    new $P5031, 'Integer'
    set $P5031, 1
    set exception["handled"], $P5031
    set $I5032, exception["handled"]
    ne $I5032, 1, nothandled_5030
  handled_5029:
    .return (exception)
  nothandled_5030:
    rethrow exception
  skip_handler_5026:
    .return ($P5025)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>" :anon :subid("525_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5065
    .param pmc param_5066
.annotate 'line', 1800
    .lex "self", param_5065
    .lex "$/", param_5066
    find_lex $P5067, "$/"
    find_lex $P5068, "$/"
    unless_null $P5068, vivify_2393
    $P5068 = root_new ['parrot';'Hash']
  vivify_2393:
    set $P5069, $P5068["scoped"]
    unless_null $P5069, vivify_2394
    new $P5069, "Undef"
  vivify_2394:
    $P5070 = $P5069."ast"()
    $P5071 = $P5067."!make"($P5070)
    .return ($P5071)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>" :anon :subid("526_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5073
    .param pmc param_5074
.annotate 'line', 1801
    .lex "self", param_5073
    .lex "$/", param_5074
    find_lex $P5075, "$/"
    find_lex $P5076, "$/"
    unless_null $P5076, vivify_2395
    $P5076 = root_new ['parrot';'Hash']
  vivify_2395:
    set $P5077, $P5076["scoped"]
    unless_null $P5077, vivify_2396
    new $P5077, "Undef"
  vivify_2396:
    $P5078 = $P5077."ast"()
    $P5079 = $P5075."!make"($P5078)
    .return ($P5079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>" :anon :subid("527_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5081
    .param pmc param_5082
.annotate 'line', 1802
    .lex "self", param_5081
    .lex "$/", param_5082
    find_lex $P5083, "$/"
    find_lex $P5084, "$/"
    unless_null $P5084, vivify_2397
    $P5084 = root_new ['parrot';'Hash']
  vivify_2397:
    set $P5085, $P5084["scoped"]
    unless_null $P5085, vivify_2398
    new $P5085, "Undef"
  vivify_2398:
    $P5086 = $P5085."ast"()
    $P5087 = $P5083."!make"($P5086)
    .return ($P5087)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped" :anon :subid("528_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5089
    .param pmc param_5090
.annotate 'line', 1804
    .lex "self", param_5089
    .lex "$/", param_5090
.annotate 'line', 1805
    find_lex $P5091, "$/"
    find_lex $P5094, "$/"
    unless_null $P5094, vivify_2399
    $P5094 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P5095, $P5094["declarator"]
    unless_null $P5095, vivify_2400
    new $P5095, "Undef"
  vivify_2400:
    if $P5095, if_5093
.annotate 'line', 1806
    find_lex $P5101, "$/"
    unless_null $P5101, vivify_2401
    $P5101 = root_new ['parrot';'Hash']
  vivify_2401:
    set $P5102, $P5101["multi_declarator"]
    unless_null $P5102, vivify_2402
    new $P5102, "Undef"
  vivify_2402:
    if $P5102, if_5100
.annotate 'line', 1807
    find_lex $P5106, "$/"
    unless_null $P5106, vivify_2403
    $P5106 = root_new ['parrot';'Hash']
  vivify_2403:
    set $P5107, $P5106["package_declarator"]
    unless_null $P5107, vivify_2404
    new $P5107, "Undef"
  vivify_2404:
    $P5108 = $P5107."ast"()
    set $P5099, $P5108
.annotate 'line', 1806
    goto if_5100_end
  if_5100:
    find_lex $P5103, "$/"
    unless_null $P5103, vivify_2405
    $P5103 = root_new ['parrot';'Hash']
  vivify_2405:
    set $P5104, $P5103["multi_declarator"]
    unless_null $P5104, vivify_2406
    new $P5104, "Undef"
  vivify_2406:
    $P5105 = $P5104."ast"()
    set $P5099, $P5105
  if_5100_end:
    set $P5092, $P5099
.annotate 'line', 1805
    goto if_5093_end
  if_5093:
    find_lex $P5096, "$/"
    unless_null $P5096, vivify_2407
    $P5096 = root_new ['parrot';'Hash']
  vivify_2407:
    set $P5097, $P5096["declarator"]
    unless_null $P5097, vivify_2408
    new $P5097, "Undef"
  vivify_2408:
    $P5098 = $P5097."ast"()
    set $P5092, $P5098
  if_5093_end:
    $P5109 = $P5091."!make"($P5092)
.annotate 'line', 1804
    .return ($P5109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator" :anon :subid("529_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5111
    .param pmc param_5112
.annotate 'line', 1810
    .lex "self", param_5111
    .lex "$/", param_5112
.annotate 'line', 1811
    find_lex $P5113, "$/"
.annotate 'line', 1812
    find_lex $P5116, "$/"
    unless_null $P5116, vivify_2409
    $P5116 = root_new ['parrot';'Hash']
  vivify_2409:
    set $P5117, $P5116["routine_declarator"]
    unless_null $P5117, vivify_2410
    new $P5117, "Undef"
  vivify_2410:
    if $P5117, if_5115
.annotate 'line', 1813
    find_lex $P5121, "$/"
    unless_null $P5121, vivify_2411
    $P5121 = root_new ['parrot';'Hash']
  vivify_2411:
    set $P5122, $P5121["variable_declarator"]
    unless_null $P5122, vivify_2412
    new $P5122, "Undef"
  vivify_2412:
    $P5123 = $P5122."ast"()
    set $P5114, $P5123
.annotate 'line', 1812
    goto if_5115_end
  if_5115:
    find_lex $P5118, "$/"
    unless_null $P5118, vivify_2413
    $P5118 = root_new ['parrot';'Hash']
  vivify_2413:
    set $P5119, $P5118["routine_declarator"]
    unless_null $P5119, vivify_2414
    new $P5119, "Undef"
  vivify_2414:
    $P5120 = $P5119."ast"()
    set $P5114, $P5120
  if_5115_end:
    $P5124 = $P5113."!make"($P5114)
.annotate 'line', 1810
    .return ($P5124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>" :anon :subid("530_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5126
    .param pmc param_5127
.annotate 'line', 1816
    .lex "self", param_5126
    .lex "$/", param_5127
    find_lex $P5128, "$/"
    find_lex $P5131, "$/"
    unless_null $P5131, vivify_2415
    $P5131 = root_new ['parrot';'Hash']
  vivify_2415:
    set $P5132, $P5131["declarator"]
    unless_null $P5132, vivify_2416
    new $P5132, "Undef"
  vivify_2416:
    if $P5132, if_5130
    find_lex $P5136, "$/"
    unless_null $P5136, vivify_2417
    $P5136 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P5137, $P5136["routine_def"]
    unless_null $P5137, vivify_2418
    new $P5137, "Undef"
  vivify_2418:
    $P5138 = $P5137."ast"()
    set $P5129, $P5138
    goto if_5130_end
  if_5130:
    find_lex $P5133, "$/"
    unless_null $P5133, vivify_2419
    $P5133 = root_new ['parrot';'Hash']
  vivify_2419:
    set $P5134, $P5133["declarator"]
    unless_null $P5134, vivify_2420
    new $P5134, "Undef"
  vivify_2420:
    $P5135 = $P5134."ast"()
    set $P5129, $P5135
  if_5130_end:
    $P5139 = $P5128."!make"($P5129)
    .return ($P5139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>" :anon :subid("531_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5141
    .param pmc param_5142
.annotate 'line', 1817
    .lex "self", param_5141
    .lex "$/", param_5142
    find_lex $P5143, "$/"
    find_lex $P5146, "$/"
    unless_null $P5146, vivify_2421
    $P5146 = root_new ['parrot';'Hash']
  vivify_2421:
    set $P5147, $P5146["declarator"]
    unless_null $P5147, vivify_2422
    new $P5147, "Undef"
  vivify_2422:
    if $P5147, if_5145
    find_lex $P5151, "$/"
    unless_null $P5151, vivify_2423
    $P5151 = root_new ['parrot';'Hash']
  vivify_2423:
    set $P5152, $P5151["routine_def"]
    unless_null $P5152, vivify_2424
    new $P5152, "Undef"
  vivify_2424:
    $P5153 = $P5152."ast"()
    set $P5144, $P5153
    goto if_5145_end
  if_5145:
    find_lex $P5148, "$/"
    unless_null $P5148, vivify_2425
    $P5148 = root_new ['parrot';'Hash']
  vivify_2425:
    set $P5149, $P5148["declarator"]
    unless_null $P5149, vivify_2426
    new $P5149, "Undef"
  vivify_2426:
    $P5150 = $P5149."ast"()
    set $P5144, $P5150
  if_5145_end:
    $P5154 = $P5143."!make"($P5144)
    .return ($P5154)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>" :anon :subid("532_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5156
    .param pmc param_5157
.annotate 'line', 1818
    .lex "self", param_5156
    .lex "$/", param_5157
    find_lex $P5158, "$/"
    find_lex $P5159, "$/"
    unless_null $P5159, vivify_2427
    $P5159 = root_new ['parrot';'Hash']
  vivify_2427:
    set $P5160, $P5159["declarator"]
    unless_null $P5160, vivify_2428
    new $P5160, "Undef"
  vivify_2428:
    $P5161 = $P5160."ast"()
    $P5162 = $P5158."!make"($P5161)
    .return ($P5162)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator" :anon :subid("533_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5164
    .param pmc param_5165
.annotate 'line', 1821
    .const 'Sub' $P5297 = "535_1305640955.436" 
    capture_lex $P5297
    .const 'Sub' $P5199 = "534_1305640955.436" 
    capture_lex $P5199
    .lex "self", param_5164
    .lex "$/", param_5165
.annotate 'line', 1822
    new $P5166, "Undef"
    .lex "$past", $P5166
.annotate 'line', 1823
    new $P5167, "Undef"
    .lex "$sigil", $P5167
.annotate 'line', 1824
    new $P5168, "Undef"
    .lex "$name", $P5168
.annotate 'line', 1825
    new $P5169, "Undef"
    .lex "$BLOCK", $P5169
.annotate 'line', 1822
    find_lex $P5170, "$/"
    unless_null $P5170, vivify_2429
    $P5170 = root_new ['parrot';'Hash']
  vivify_2429:
    set $P5171, $P5170["variable"]
    unless_null $P5171, vivify_2430
    new $P5171, "Undef"
  vivify_2430:
    $P5172 = $P5171."ast"()
    store_lex "$past", $P5172
.annotate 'line', 1823
    find_lex $P5173, "$/"
    unless_null $P5173, vivify_2431
    $P5173 = root_new ['parrot';'Hash']
  vivify_2431:
    set $P5174, $P5173["variable"]
    unless_null $P5174, vivify_2432
    $P5174 = root_new ['parrot';'Hash']
  vivify_2432:
    set $P5175, $P5174["sigil"]
    unless_null $P5175, vivify_2433
    new $P5175, "Undef"
  vivify_2433:
    store_lex "$sigil", $P5175
.annotate 'line', 1824
    find_lex $P5176, "$past"
    unless_null $P5176, vivify_2434
    new $P5176, "Undef"
  vivify_2434:
    $P5177 = $P5176."name"()
    store_lex "$name", $P5177
.annotate 'line', 1825
    find_lex $P5178, "$?PACKAGE"
    get_who $P5179, $P5178
    set $P5180, $P5179["@BLOCK"]
    unless_null $P5180, vivify_2435
    $P5180 = root_new ['parrot';'ResizablePMCArray']
  vivify_2435:
    set $P5181, $P5180[0]
    unless_null $P5181, vivify_2436
    new $P5181, "Undef"
  vivify_2436:
    store_lex "$BLOCK", $P5181
.annotate 'line', 1826
    find_lex $P5185, "$name"
    unless_null $P5185, vivify_2437
    new $P5185, "Undef"
  vivify_2437:
    if $P5185, if_5184
    set $P5183, $P5185
    goto if_5184_end
  if_5184:
    find_lex $P5186, "$BLOCK"
    unless_null $P5186, vivify_2438
    new $P5186, "Undef"
  vivify_2438:
    find_lex $P5187, "$name"
    unless_null $P5187, vivify_2439
    new $P5187, "Undef"
  vivify_2439:
    $P5188 = $P5186."symbol"($P5187)
    set $P5183, $P5188
  if_5184_end:
    unless $P5183, if_5182_end
.annotate 'line', 1827
    find_lex $P5189, "$/"
    unless_null $P5189, vivify_2440
    new $P5189, "Undef"
  vivify_2440:
    $P5190 = $P5189."CURSOR"()
    find_lex $P5191, "$name"
    unless_null $P5191, vivify_2441
    new $P5191, "Undef"
  vivify_2441:
    $P5190."panic"("Redeclaration of symbol ", $P5191)
  if_5182_end:
.annotate 'line', 1829
    find_dynamic_lex $P5195, "$*SCOPE"
    unless_null $P5195, vivify_2442
    get_hll_global $P5193, "GLOBAL"
    get_who $P5194, $P5193
    set $P5195, $P5194["$SCOPE"]
    unless_null $P5195, vivify_2443
    die "Contextual $*SCOPE not found"
  vivify_2443:
  vivify_2442:
    set $S5196, $P5195
    iseq $I5197, $S5196, "has"
    if $I5197, if_5192
.annotate 'line', 1849
    find_dynamic_lex $P5256, "$*SCOPE"
    unless_null $P5256, vivify_2444
    get_hll_global $P5254, "GLOBAL"
    get_who $P5255, $P5254
    set $P5256, $P5255["$SCOPE"]
    unless_null $P5256, vivify_2445
    die "Contextual $*SCOPE not found"
  vivify_2445:
  vivify_2444:
    set $S5257, $P5256
    iseq $I5258, $S5257, "our"
    if $I5258, if_5253
.annotate 'line', 1859
    find_lex $P5272, "$BLOCK"
    unless_null $P5272, vivify_2446
    $P5272 = root_new ['parrot';'ResizablePMCArray']
  vivify_2446:
    set $P5273, $P5272[0]
    unless_null $P5273, vivify_2447
    new $P5273, "Undef"
  vivify_2447:
    get_hll_global $P5274, "GLOBAL"
    nqp_get_package_through_who $P5275, $P5274, "PAST"
    get_who $P5276, $P5275
    set $P5277, $P5276["Var"]
    find_lex $P5278, "$name"
    unless_null $P5278, vivify_2448
    new $P5278, "Undef"
  vivify_2448:
.annotate 'line', 1861
    find_lex $P5279, "$sigil"
    unless_null $P5279, vivify_2449
    new $P5279, "Undef"
  vivify_2449:
    $P5280 = "vivitype"($P5279)
    find_lex $P5281, "$/"
    unless_null $P5281, vivify_2450
    new $P5281, "Undef"
  vivify_2450:
    $P5282 = $P5277."new"($P5278 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5280 :named("viviself"), $P5281 :named("node"))
.annotate 'line', 1859
    $P5273."push"($P5282)
.annotate 'line', 1864
    find_lex $P5283, "$BLOCK"
    unless_null $P5283, vivify_2451
    new $P5283, "Undef"
  vivify_2451:
    find_lex $P5284, "$name"
    unless_null $P5284, vivify_2452
    new $P5284, "Undef"
  vivify_2452:
    $P5283."symbol"($P5284, "lexical" :named("scope"))
.annotate 'line', 1858
    goto if_5253_end
  if_5253:
.annotate 'line', 1853
    find_lex $P5259, "$/"
    unless_null $P5259, vivify_2453
    $P5259 = root_new ['parrot';'Hash']
  vivify_2453:
    set $P5260, $P5259["variable"]
    unless_null $P5260, vivify_2454
    new $P5260, "Undef"
  vivify_2454:
    set $S5261, $P5260
    new $P5262, 'String'
    set $P5262, $S5261
    store_lex "$name", $P5262
.annotate 'line', 1854
    find_lex $P5263, "$name"
    unless_null $P5263, vivify_2455
    new $P5263, "Undef"
  vivify_2455:
    new $P5264, "ResizablePMCArray"
    push $P5264, $P5263
    find_lex $P5265, "$/"
    unless_null $P5265, vivify_2456
    new $P5265, "Undef"
  vivify_2456:
    $P5266 = "lexical_package_lookup"($P5264, $P5265)
    store_lex "$past", $P5266
.annotate 'line', 1855
    find_lex $P5267, "$past"
    unless_null $P5267, vivify_2457
    new $P5267, "Undef"
  vivify_2457:
    find_lex $P5268, "$sigil"
    unless_null $P5268, vivify_2458
    new $P5268, "Undef"
  vivify_2458:
    $P5269 = "vivitype"($P5268)
    $P5267."viviself"($P5269)
.annotate 'line', 1856
    find_lex $P5270, "$BLOCK"
    unless_null $P5270, vivify_2459
    new $P5270, "Undef"
  vivify_2459:
    find_lex $P5271, "$name"
    unless_null $P5271, vivify_2460
    new $P5271, "Undef"
  vivify_2460:
    $P5270."symbol"($P5271, "package" :named("scope"))
  if_5253_end:
.annotate 'line', 1849
    goto if_5192_end
  if_5192:
.annotate 'line', 1829
    .const 'Sub' $P5199 = "534_1305640955.436" 
    capture_lex $P5199
    $P5199()
  if_5192_end:
.annotate 'line', 1868
    find_lex $P5285, "$/"
    find_lex $P5286, "$past"
    unless_null $P5286, vivify_2490
    new $P5286, "Undef"
  vivify_2490:
    $P5285."!make"($P5286)
.annotate 'line', 1870
    find_lex $P5289, "$/"
    unless_null $P5289, vivify_2491
    $P5289 = root_new ['parrot';'Hash']
  vivify_2491:
    set $P5290, $P5289["trait"]
    unless_null $P5290, vivify_2492
    new $P5290, "Undef"
  vivify_2492:
    if $P5290, if_5288
    set $P5287, $P5290
    goto if_5288_end
  if_5288:
.annotate 'line', 1871
    find_lex $P5292, "$/"
    unless_null $P5292, vivify_2493
    $P5292 = root_new ['parrot';'Hash']
  vivify_2493:
    set $P5293, $P5292["trait"]
    unless_null $P5293, vivify_2494
    new $P5293, "Undef"
  vivify_2494:
    defined $I5294, $P5293
    unless $I5294, for_undef_2495
    iter $P5291, $P5293
    new $P5304, 'ExceptionHandler'
    set_label $P5304, loop5303_handler
    $P5304."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5304
  loop5303_test:
    unless $P5291, loop5303_done
    shift $P5295, $P5291
  loop5303_redo:
    .const 'Sub' $P5297 = "535_1305640955.436" 
    capture_lex $P5297
    $P5297($P5295)
  loop5303_next:
    goto loop5303_test
  loop5303_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5305, exception, 'type'
    eq $P5305, .CONTROL_LOOP_NEXT, loop5303_next
    eq $P5305, .CONTROL_LOOP_REDO, loop5303_redo
  loop5303_done:
    pop_eh 
  for_undef_2495:
.annotate 'line', 1870
    set $P5287, $P5291
  if_5288_end:
.annotate 'line', 1821
    .return ($P5287)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5198"  :anon :subid("534_1305640955.436") :outer("533_1305640955.436")
.annotate 'line', 1836
    $P5200 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P5200
.annotate 'line', 1837
    $P5201 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P5201
.annotate 'line', 1831
    find_dynamic_lex $P5208, "$*PKGDECL"
    unless_null $P5208, vivify_2461
    get_hll_global $P5206, "GLOBAL"
    get_who $P5207, $P5206
    set $P5208, $P5207["$PKGDECL"]
    unless_null $P5208, vivify_2462
    die "Contextual $*PKGDECL not found"
  vivify_2462:
  vivify_2461:
    concat $P5209, $P5208, "-attr"
    find_dynamic_lex $P5205, "%*HOW"
    unless_null $P5205, vivify_2463
    get_hll_global $P5203, "GLOBAL"
    get_who $P5204, $P5203
    set $P5205, $P5204["%HOW"]
    unless_null $P5205, vivify_2464
    die "Contextual %*HOW not found"
  vivify_2464:
  vivify_2463:
    exists $I5210, $P5205[$P5209]
    if $I5210, unless_5202_end
.annotate 'line', 1832
    find_lex $P5211, "$/"
    unless_null $P5211, vivify_2465
    new $P5211, "Undef"
  vivify_2465:
    $P5212 = $P5211."CURSOR"()
    find_dynamic_lex $P5215, "$*PKGDECL"
    unless_null $P5215, vivify_2466
    get_hll_global $P5213, "GLOBAL"
    get_who $P5214, $P5213
    set $P5215, $P5214["$PKGDECL"]
    unless_null $P5215, vivify_2467
    die "Contextual $*PKGDECL not found"
  vivify_2467:
  vivify_2466:
    concat $P5216, $P5215, " packages do not support attributes"
    $P5212."panic"($P5216)
  unless_5202_end:
.annotate 'line', 1831
    find_lex $P5217, "%lit_args"
    unless_null $P5217, vivify_2468
    $P5217 = root_new ['parrot';'Hash']
  vivify_2468:
    find_lex $P5218, "%obj_args"
    unless_null $P5218, vivify_2469
    $P5218 = root_new ['parrot';'Hash']
  vivify_2469:
.annotate 'line', 1838
    find_lex $P5219, "$name"
    unless_null $P5219, vivify_2470
    new $P5219, "Undef"
  vivify_2470:
    find_lex $P5220, "%lit_args"
    unless_null $P5220, vivify_2471
    $P5220 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P5220
  vivify_2471:
    set $P5220["name"], $P5219
.annotate 'line', 1839
    find_lex $P5222, "$/"
    unless_null $P5222, vivify_2472
    $P5222 = root_new ['parrot';'Hash']
  vivify_2472:
    set $P5223, $P5222["typename"]
    unless_null $P5223, vivify_2473
    new $P5223, "Undef"
  vivify_2473:
    unless $P5223, if_5221_end
.annotate 'line', 1840
    find_lex $P5224, "$/"
    unless_null $P5224, vivify_2474
    $P5224 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P5225, $P5224["typename"]
    unless_null $P5225, vivify_2475
    $P5225 = root_new ['parrot';'ResizablePMCArray']
  vivify_2475:
    set $P5226, $P5225[0]
    unless_null $P5226, vivify_2476
    new $P5226, "Undef"
  vivify_2476:
    set $S5227, $P5226
    new $P5228, "ResizablePMCArray"
    push $P5228, $S5227
    find_lex $P5229, "$/"
    unless_null $P5229, vivify_2477
    new $P5229, "Undef"
  vivify_2477:
    $P5230 = "find_sym"($P5228, $P5229)
    find_lex $P5231, "%obj_args"
    unless_null $P5231, vivify_2478
    $P5231 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P5231
  vivify_2478:
    set $P5231["type"], $P5230
  if_5221_end:
.annotate 'line', 1844
    find_dynamic_lex $P5234, "$*SC"
    unless_null $P5234, vivify_2479
    get_hll_global $P5232, "GLOBAL"
    get_who $P5233, $P5232
    set $P5234, $P5233["$SC"]
    unless_null $P5234, vivify_2480
    die "Contextual $*SC not found"
  vivify_2480:
  vivify_2479:
    find_dynamic_lex $P5237, "$*PACKAGE"
    unless_null $P5237, vivify_2481
    get_hll_global $P5235, "GLOBAL"
    get_who $P5236, $P5235
    set $P5237, $P5236["$PACKAGE"]
    unless_null $P5237, vivify_2482
    die "Contextual $*PACKAGE not found"
  vivify_2482:
  vivify_2481:
    find_dynamic_lex $P5240, "$*PKGDECL"
    unless_null $P5240, vivify_2483
    get_hll_global $P5238, "GLOBAL"
    get_who $P5239, $P5238
    set $P5240, $P5239["$PKGDECL"]
    unless_null $P5240, vivify_2484
    die "Contextual $*PKGDECL not found"
  vivify_2484:
  vivify_2483:
    concat $P5241, $P5240, "-attr"
    find_dynamic_lex $P5244, "%*HOW"
    unless_null $P5244, vivify_2485
    get_hll_global $P5242, "GLOBAL"
    get_who $P5243, $P5242
    set $P5244, $P5243["%HOW"]
    unless_null $P5244, vivify_2486
    die "Contextual %*HOW not found"
  vivify_2486:
  vivify_2485:
    set $P5245, $P5244[$P5241]
    unless_null $P5245, vivify_2487
    new $P5245, "Undef"
  vivify_2487:
    find_lex $P5246, "%lit_args"
    unless_null $P5246, vivify_2488
    $P5246 = root_new ['parrot';'Hash']
  vivify_2488:
    find_lex $P5247, "%obj_args"
    unless_null $P5247, vivify_2489
    $P5247 = root_new ['parrot';'Hash']
  vivify_2489:
    $P5234."pkg_add_attribute"($P5237, $P5245, $P5246, $P5247)
.annotate 'line', 1847
    get_hll_global $P5248, "GLOBAL"
    nqp_get_package_through_who $P5249, $P5248, "PAST"
    get_who $P5250, $P5249
    set $P5251, $P5250["Stmts"]
    $P5252 = $P5251."new"()
    store_lex "$past", $P5252
.annotate 'line', 1829
    .return ($P5252)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5296"  :anon :subid("535_1305640955.436") :outer("533_1305640955.436")
    .param pmc param_5298
.annotate 'line', 1871
    .lex "$_", param_5298
    find_lex $P5299, "$_"
    unless_null $P5299, vivify_2496
    new $P5299, "Undef"
  vivify_2496:
    $P5300 = $P5299."ast"()
    find_lex $P5301, "$/"
    unless_null $P5301, vivify_2497
    new $P5301, "Undef"
  vivify_2497:
    $P5302 = $P5300($P5301)
    .return ($P5302)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>" :anon :subid("536_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5307
    .param pmc param_5308
.annotate 'line', 1876
    .lex "self", param_5307
    .lex "$/", param_5308
    find_lex $P5309, "$/"
    find_lex $P5310, "$/"
    unless_null $P5310, vivify_2498
    $P5310 = root_new ['parrot';'Hash']
  vivify_2498:
    set $P5311, $P5310["routine_def"]
    unless_null $P5311, vivify_2499
    new $P5311, "Undef"
  vivify_2499:
    $P5312 = $P5311."ast"()
    $P5313 = $P5309."!make"($P5312)
    .return ($P5313)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>" :anon :subid("537_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5315
    .param pmc param_5316
.annotate 'line', 1877
    .lex "self", param_5315
    .lex "$/", param_5316
    find_lex $P5317, "$/"
    find_lex $P5318, "$/"
    unless_null $P5318, vivify_2500
    $P5318 = root_new ['parrot';'Hash']
  vivify_2500:
    set $P5319, $P5318["method_def"]
    unless_null $P5319, vivify_2501
    new $P5319, "Undef"
  vivify_2501:
    $P5320 = $P5319."ast"()
    $P5321 = $P5317."!make"($P5320)
    .return ($P5321)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def" :anon :subid("538_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5323
    .param pmc param_5324
.annotate 'line', 1879
    .const 'Sub' $P5637 = "544_1305640955.436" 
    capture_lex $P5637
    .const 'Sub' $P5346 = "539_1305640955.436" 
    capture_lex $P5346
    .lex "self", param_5323
    .lex "$/", param_5324
.annotate 'line', 1882
    new $P5325, "Undef"
    .lex "$past", $P5325
.annotate 'line', 1893
    new $P5326, "Undef"
    .lex "$block", $P5326
.annotate 'line', 1879
    find_lex $P5327, "$past"
    unless_null $P5327, vivify_2502
    new $P5327, "Undef"
  vivify_2502:
.annotate 'line', 1883
    find_lex $P5329, "$/"
    unless_null $P5329, vivify_2503
    $P5329 = root_new ['parrot';'Hash']
  vivify_2503:
    set $P5330, $P5329["onlystar"]
    unless_null $P5330, vivify_2504
    new $P5330, "Undef"
  vivify_2504:
    if $P5330, if_5328
.annotate 'line', 1887
    find_lex $P5332, "$/"
    unless_null $P5332, vivify_2505
    $P5332 = root_new ['parrot';'Hash']
  vivify_2505:
    set $P5333, $P5332["blockoid"]
    unless_null $P5333, vivify_2506
    new $P5333, "Undef"
  vivify_2506:
    $P5334 = $P5333."ast"()
    store_lex "$past", $P5334
.annotate 'line', 1888
    find_lex $P5335, "$past"
    unless_null $P5335, vivify_2507
    new $P5335, "Undef"
  vivify_2507:
    $P5335."blocktype"("declaration")
.annotate 'line', 1889
    find_dynamic_lex $P5339, "$*RETURN_USED"
    unless_null $P5339, vivify_2508
    get_hll_global $P5337, "GLOBAL"
    get_who $P5338, $P5337
    set $P5339, $P5338["$RETURN_USED"]
    unless_null $P5339, vivify_2509
    die "Contextual $*RETURN_USED not found"
  vivify_2509:
  vivify_2508:
    unless $P5339, if_5336_end
.annotate 'line', 1890
    find_lex $P5340, "$past"
    unless_null $P5340, vivify_2510
    new $P5340, "Undef"
  vivify_2510:
    $P5340."control"("return_pir")
  if_5336_end:
.annotate 'line', 1886
    goto if_5328_end
  if_5328:
.annotate 'line', 1884
    $P5331 = "only_star_block"()
    store_lex "$past", $P5331
  if_5328_end:
.annotate 'line', 1893
    find_lex $P5341, "$past"
    unless_null $P5341, vivify_2511
    new $P5341, "Undef"
  vivify_2511:
    store_lex "$block", $P5341
.annotate 'line', 1895
    find_lex $P5343, "$/"
    unless_null $P5343, vivify_2512
    $P5343 = root_new ['parrot';'Hash']
  vivify_2512:
    set $P5344, $P5343["deflongname"]
    unless_null $P5344, vivify_2513
    new $P5344, "Undef"
  vivify_2513:
    unless $P5344, if_5342_end
    .const 'Sub' $P5346 = "539_1305640955.436" 
    capture_lex $P5346
    $P5346()
  if_5342_end:
.annotate 'line', 1996
    find_lex $P5626, "$block"
    unless_null $P5626, vivify_2619
    new $P5626, "Undef"
  vivify_2619:
    find_lex $P5627, "$past"
    unless_null $P5627, vivify_2620
    $P5627 = root_new ['parrot';'Hash']
    store_lex "$past", $P5627
  vivify_2620:
    set $P5627["block_past"], $P5626
.annotate 'line', 1997
    find_lex $P5629, "$/"
    unless_null $P5629, vivify_2621
    $P5629 = root_new ['parrot';'Hash']
  vivify_2621:
    set $P5630, $P5629["trait"]
    unless_null $P5630, vivify_2622
    new $P5630, "Undef"
  vivify_2622:
    unless $P5630, if_5628_end
.annotate 'line', 1998
    find_lex $P5632, "$/"
    unless_null $P5632, vivify_2623
    $P5632 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P5633, $P5632["trait"]
    unless_null $P5633, vivify_2624
    new $P5633, "Undef"
  vivify_2624:
    defined $I5634, $P5633
    unless $I5634, for_undef_2625
    iter $P5631, $P5633
    new $P5644, 'ExceptionHandler'
    set_label $P5644, loop5643_handler
    $P5644."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5644
  loop5643_test:
    unless $P5631, loop5643_done
    shift $P5635, $P5631
  loop5643_redo:
    .const 'Sub' $P5637 = "544_1305640955.436" 
    capture_lex $P5637
    $P5637($P5635)
  loop5643_next:
    goto loop5643_test
  loop5643_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5645, exception, 'type'
    eq $P5645, .CONTROL_LOOP_NEXT, loop5643_next
    eq $P5645, .CONTROL_LOOP_REDO, loop5643_redo
  loop5643_done:
    pop_eh 
  for_undef_2625:
  if_5628_end:
.annotate 'line', 2001
    find_lex $P5646, "$/"
    find_lex $P5647, "$past"
    unless_null $P5647, vivify_2628
    new $P5647, "Undef"
  vivify_2628:
    $P5648 = $P5646."!make"($P5647)
.annotate 'line', 1879
    .return ($P5648)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5345"  :anon :subid("539_1305640955.436") :outer("538_1305640955.436")
.annotate 'line', 1895
    .const 'Sub' $P5500 = "543_1305640955.436" 
    capture_lex $P5500
    .const 'Sub' $P5387 = "540_1305640955.436" 
    capture_lex $P5387
.annotate 'line', 1896
    new $P5347, "Undef"
    .lex "$name", $P5347
    find_lex $P5348, "$/"
    unless_null $P5348, vivify_2514
    $P5348 = root_new ['parrot';'Hash']
  vivify_2514:
    set $P5349, $P5348["sigil"]
    unless_null $P5349, vivify_2515
    $P5349 = root_new ['parrot';'ResizablePMCArray']
  vivify_2515:
    set $P5350, $P5349[0]
    unless_null $P5350, vivify_2516
    new $P5350, "Undef"
  vivify_2516:
    set $S5351, $P5350
    new $P5352, 'String'
    set $P5352, $S5351
    find_lex $P5353, "$/"
    unless_null $P5353, vivify_2517
    $P5353 = root_new ['parrot';'Hash']
  vivify_2517:
    set $P5354, $P5353["deflongname"]
    unless_null $P5354, vivify_2518
    $P5354 = root_new ['parrot';'ResizablePMCArray']
  vivify_2518:
    set $P5355, $P5354[0]
    unless_null $P5355, vivify_2519
    new $P5355, "Undef"
  vivify_2519:
    $S5356 = $P5355."ast"()
    concat $P5357, $P5352, $S5356
    store_lex "$name", $P5357
.annotate 'line', 1897
    find_lex $P5358, "$past"
    unless_null $P5358, vivify_2520
    new $P5358, "Undef"
  vivify_2520:
    find_lex $P5359, "$name"
    unless_null $P5359, vivify_2521
    new $P5359, "Undef"
  vivify_2521:
    $P5358."name"($P5359)
.annotate 'line', 1898
    find_dynamic_lex $P5367, "$*SCOPE"
    unless_null $P5367, vivify_2522
    get_hll_global $P5365, "GLOBAL"
    get_who $P5366, $P5365
    set $P5367, $P5366["$SCOPE"]
    unless_null $P5367, vivify_2523
    die "Contextual $*SCOPE not found"
  vivify_2523:
  vivify_2522:
    set $S5368, $P5367
    iseq $I5369, $S5368, ""
    unless $I5369, unless_5364
    new $P5363, 'Integer'
    set $P5363, $I5369
    goto unless_5364_end
  unless_5364:
    find_dynamic_lex $P5372, "$*SCOPE"
    unless_null $P5372, vivify_2524
    get_hll_global $P5370, "GLOBAL"
    get_who $P5371, $P5370
    set $P5372, $P5371["$SCOPE"]
    unless_null $P5372, vivify_2525
    die "Contextual $*SCOPE not found"
  vivify_2525:
  vivify_2524:
    set $S5373, $P5372
    iseq $I5374, $S5373, "my"
    new $P5363, 'Integer'
    set $P5363, $I5374
  unless_5364_end:
    unless $P5363, unless_5362
    set $P5361, $P5363
    goto unless_5362_end
  unless_5362:
    find_dynamic_lex $P5377, "$*SCOPE"
    unless_null $P5377, vivify_2526
    get_hll_global $P5375, "GLOBAL"
    get_who $P5376, $P5375
    set $P5377, $P5376["$SCOPE"]
    unless_null $P5377, vivify_2527
    die "Contextual $*SCOPE not found"
  vivify_2527:
  vivify_2526:
    set $S5378, $P5377
    iseq $I5379, $S5378, "our"
    new $P5361, 'Integer'
    set $P5361, $I5379
  unless_5362_end:
    if $P5361, if_5360
.annotate 'line', 1986
    find_lex $P5607, "$/"
    unless_null $P5607, vivify_2528
    new $P5607, "Undef"
  vivify_2528:
    $P5608 = $P5607."CURSOR"()
    find_dynamic_lex $P5611, "$*SCOPE"
    unless_null $P5611, vivify_2529
    get_hll_global $P5609, "GLOBAL"
    get_who $P5610, $P5609
    set $P5611, $P5610["$SCOPE"]
    unless_null $P5611, vivify_2530
    die "Contextual $*SCOPE not found"
  vivify_2530:
  vivify_2529:
    concat $P5612, $P5611, " scoped routines are not supported yet"
    $P5608."panic"($P5612)
.annotate 'line', 1985
    goto if_5360_end
  if_5360:
.annotate 'line', 1899
    find_dynamic_lex $P5383, "$*MULTINESS"
    unless_null $P5383, vivify_2531
    get_hll_global $P5381, "GLOBAL"
    get_who $P5382, $P5381
    set $P5383, $P5382["$MULTINESS"]
    unless_null $P5383, vivify_2532
    die "Contextual $*MULTINESS not found"
  vivify_2532:
  vivify_2531:
    set $S5384, $P5383
    iseq $I5385, $S5384, "multi"
    if $I5385, if_5380
.annotate 'line', 1950
    find_dynamic_lex $P5496, "$*MULTINESS"
    unless_null $P5496, vivify_2533
    get_hll_global $P5494, "GLOBAL"
    get_who $P5495, $P5494
    set $P5496, $P5495["$MULTINESS"]
    unless_null $P5496, vivify_2534
    die "Contextual $*MULTINESS not found"
  vivify_2534:
  vivify_2533:
    set $S5497, $P5496
    iseq $I5498, $S5497, "proto"
    if $I5498, if_5493
.annotate 'line', 1969
    find_lex $P5550, "$?PACKAGE"
    get_who $P5551, $P5550
    set $P5552, $P5551["@BLOCK"]
    unless_null $P5552, vivify_2535
    $P5552 = root_new ['parrot';'ResizablePMCArray']
  vivify_2535:
    set $P5553, $P5552[0]
    unless_null $P5553, vivify_2536
    $P5553 = root_new ['parrot';'ResizablePMCArray']
  vivify_2536:
    set $P5554, $P5553[0]
    unless_null $P5554, vivify_2537
    new $P5554, "Undef"
  vivify_2537:
    get_hll_global $P5555, "GLOBAL"
    nqp_get_package_through_who $P5556, $P5555, "PAST"
    get_who $P5557, $P5556
    set $P5558, $P5557["Var"]
    find_lex $P5559, "$name"
    unless_null $P5559, vivify_2538
    new $P5559, "Undef"
  vivify_2538:
    find_lex $P5560, "$past"
    unless_null $P5560, vivify_2539
    new $P5560, "Undef"
  vivify_2539:
    $P5561 = $P5558."new"($P5559 :named("name"), 1 :named("isdecl"), $P5560 :named("viviself"), "lexical" :named("scope"))
    $P5554."push"($P5561)
.annotate 'line', 1971
    find_lex $P5562, "$?PACKAGE"
    get_who $P5563, $P5562
    set $P5564, $P5563["@BLOCK"]
    unless_null $P5564, vivify_2540
    $P5564 = root_new ['parrot';'ResizablePMCArray']
  vivify_2540:
    set $P5565, $P5564[0]
    unless_null $P5565, vivify_2541
    new $P5565, "Undef"
  vivify_2541:
    find_lex $P5566, "$name"
    unless_null $P5566, vivify_2542
    new $P5566, "Undef"
  vivify_2542:
    $P5565."symbol"($P5566, "lexical" :named("scope"))
.annotate 'line', 1972
    find_dynamic_lex $P5570, "$*SCOPE"
    unless_null $P5570, vivify_2543
    get_hll_global $P5568, "GLOBAL"
    get_who $P5569, $P5568
    set $P5570, $P5569["$SCOPE"]
    unless_null $P5570, vivify_2544
    die "Contextual $*SCOPE not found"
  vivify_2544:
  vivify_2543:
    set $S5571, $P5570
    iseq $I5572, $S5571, "our"
    unless $I5572, if_5567_end
.annotate 'line', 1975
    find_dynamic_lex $P5575, "$*SC"
    unless_null $P5575, vivify_2545
    get_hll_global $P5573, "GLOBAL"
    get_who $P5574, $P5573
    set $P5575, $P5574["$SC"]
    unless_null $P5575, vivify_2546
    die "Contextual $*SC not found"
  vivify_2546:
  vivify_2545:
    find_dynamic_lex $P5578, "$*PACKAGE"
    unless_null $P5578, vivify_2547
    get_hll_global $P5576, "GLOBAL"
    get_who $P5577, $P5576
    set $P5578, $P5577["$PACKAGE"]
    unless_null $P5578, vivify_2548
    die "Contextual $*PACKAGE not found"
  vivify_2548:
  vivify_2547:
    find_lex $P5579, "$name"
    unless_null $P5579, vivify_2549
    new $P5579, "Undef"
  vivify_2549:
    find_lex $P5580, "$past"
    unless_null $P5580, vivify_2550
    new $P5580, "Undef"
  vivify_2550:
    $P5575."install_package_routine"($P5578, $P5579, $P5580)
.annotate 'line', 1976
    find_lex $P5581, "$?PACKAGE"
    get_who $P5582, $P5581
    set $P5583, $P5582["@BLOCK"]
    unless_null $P5583, vivify_2551
    $P5583 = root_new ['parrot';'ResizablePMCArray']
  vivify_2551:
    set $P5584, $P5583[0]
    unless_null $P5584, vivify_2552
    $P5584 = root_new ['parrot';'ResizablePMCArray']
  vivify_2552:
    set $P5585, $P5584[0]
    unless_null $P5585, vivify_2553
    new $P5585, "Undef"
  vivify_2553:
    get_hll_global $P5586, "GLOBAL"
    nqp_get_package_through_who $P5587, $P5586, "PAST"
    get_who $P5588, $P5587
    set $P5589, $P5588["Op"]
.annotate 'line', 1978
    find_lex $P5590, "$name"
    unless_null $P5590, vivify_2554
    new $P5590, "Undef"
  vivify_2554:
    new $P5591, "ResizablePMCArray"
    push $P5591, $P5590
    find_lex $P5592, "$/"
    unless_null $P5592, vivify_2555
    new $P5592, "Undef"
  vivify_2555:
    $P5593 = "lexical_package_lookup"($P5591, $P5592)
.annotate 'line', 1979
    get_hll_global $P5594, "GLOBAL"
    nqp_get_package_through_who $P5595, $P5594, "PAST"
    get_who $P5596, $P5595
    set $P5597, $P5596["Var"]
    find_lex $P5598, "$name"
    unless_null $P5598, vivify_2556
    new $P5598, "Undef"
  vivify_2556:
    $P5599 = $P5597."new"($P5598 :named("name"), "lexical" :named("scope"))
    $P5600 = $P5589."new"($P5593, $P5599, "bind" :named("pasttype"))
.annotate 'line', 1976
    $P5585."push"($P5600)
  if_5567_end:
.annotate 'line', 1968
    goto if_5493_end
  if_5493:
.annotate 'line', 1950
    .const 'Sub' $P5500 = "543_1305640955.436" 
    capture_lex $P5500
    $P5500()
  if_5493_end:
    goto if_5380_end
  if_5380:
.annotate 'line', 1899
    .const 'Sub' $P5387 = "540_1305640955.436" 
    capture_lex $P5387
    $P5387()
  if_5380_end:
.annotate 'line', 1983
    get_hll_global $P5601, "GLOBAL"
    nqp_get_package_through_who $P5602, $P5601, "PAST"
    get_who $P5603, $P5602
    set $P5604, $P5603["Var"]
    find_lex $P5605, "$name"
    unless_null $P5605, vivify_2614
    new $P5605, "Undef"
  vivify_2614:
    $P5606 = $P5604."new"($P5605 :named("name"))
    store_lex "$past", $P5606
  if_5360_end:
.annotate 'line', 1990
    find_lex $P5617, "$name"
    unless_null $P5617, vivify_2615
    new $P5617, "Undef"
  vivify_2615:
    set $S5618, $P5617
    iseq $I5619, $S5618, "MAIN"
    if $I5619, if_5616
    new $P5615, 'Integer'
    set $P5615, $I5619
    goto if_5616_end
  if_5616:
    find_dynamic_lex $P5622, "$*MULTINESS"
    unless_null $P5622, vivify_2616
    get_hll_global $P5620, "GLOBAL"
    get_who $P5621, $P5620
    set $P5622, $P5621["$MULTINESS"]
    unless_null $P5622, vivify_2617
    die "Contextual $*MULTINESS not found"
  vivify_2617:
  vivify_2616:
    set $S5623, $P5622
    isne $I5624, $S5623, "multi"
    new $P5615, 'Integer'
    set $P5615, $I5624
  if_5616_end:
    if $P5615, if_5614
    set $P5613, $P5615
    goto if_5614_end
  if_5614:
.annotate 'line', 1991
    find_lex $P5625, "$block"
    unless_null $P5625, vivify_2618
    new $P5625, "Undef"
  vivify_2618:
    store_dynamic_lex "$*MAIN_SUB", $P5625
.annotate 'line', 1990
    set $P5613, $P5625
  if_5614_end:
.annotate 'line', 1895
    .return ($P5613)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5499"  :anon :subid("543_1305640955.436") :outer("539_1305640955.436")
.annotate 'line', 1955
    new $P5501, "Undef"
    .lex "$cholder", $P5501
.annotate 'line', 1954
    find_dynamic_lex $P5505, "$*SCOPE"
    unless_null $P5505, vivify_2557
    get_hll_global $P5503, "GLOBAL"
    get_who $P5504, $P5503
    set $P5505, $P5504["$SCOPE"]
    unless_null $P5505, vivify_2558
    die "Contextual $*SCOPE not found"
  vivify_2558:
  vivify_2557:
    set $S5506, $P5505
    iseq $I5507, $S5506, "our"
    unless $I5507, if_5502_end
    die "our-scoped protos not yet implemented"
  if_5502_end:
.annotate 'line', 1955
    get_hll_global $P5508, "GLOBAL"
    nqp_get_package_through_who $P5509, $P5508, "PAST"
    get_who $P5510, $P5509
    set $P5511, $P5510["Op"]
    $P5512 = $P5511."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5512
.annotate 'line', 1956
    find_lex $P5513, "$?PACKAGE"
    get_who $P5514, $P5513
    set $P5515, $P5514["@BLOCK"]
    unless_null $P5515, vivify_2559
    $P5515 = root_new ['parrot';'ResizablePMCArray']
  vivify_2559:
    set $P5516, $P5515[0]
    unless_null $P5516, vivify_2560
    $P5516 = root_new ['parrot';'ResizablePMCArray']
  vivify_2560:
    set $P5517, $P5516[0]
    unless_null $P5517, vivify_2561
    new $P5517, "Undef"
  vivify_2561:
    get_hll_global $P5518, "GLOBAL"
    nqp_get_package_through_who $P5519, $P5518, "PAST"
    get_who $P5520, $P5519
    set $P5521, $P5520["Var"]
    find_lex $P5522, "$name"
    unless_null $P5522, vivify_2562
    new $P5522, "Undef"
  vivify_2562:
    find_lex $P5523, "$past"
    unless_null $P5523, vivify_2563
    new $P5523, "Undef"
  vivify_2563:
    $P5524 = $P5521."new"($P5522 :named("name"), 1 :named("isdecl"), $P5523 :named("viviself"), "lexical" :named("scope"))
    $P5517."push"($P5524)
.annotate 'line', 1958
    find_lex $P5525, "$?PACKAGE"
    get_who $P5526, $P5525
    set $P5527, $P5526["@BLOCK"]
    unless_null $P5527, vivify_2564
    $P5527 = root_new ['parrot';'ResizablePMCArray']
  vivify_2564:
    set $P5528, $P5527[0]
    unless_null $P5528, vivify_2565
    $P5528 = root_new ['parrot';'ResizablePMCArray']
  vivify_2565:
    set $P5529, $P5528[0]
    unless_null $P5529, vivify_2566
    new $P5529, "Undef"
  vivify_2566:
    get_hll_global $P5530, "GLOBAL"
    nqp_get_package_through_who $P5531, $P5530, "PAST"
    get_who $P5532, $P5531
    set $P5533, $P5532["Op"]
.annotate 'line', 1960
    get_hll_global $P5534, "GLOBAL"
    nqp_get_package_through_who $P5535, $P5534, "PAST"
    get_who $P5536, $P5535
    set $P5537, $P5536["Var"]
    find_lex $P5538, "$name"
    unless_null $P5538, vivify_2567
    new $P5538, "Undef"
  vivify_2567:
    $P5539 = $P5537."new"($P5538 :named("name"))
    find_lex $P5540, "$cholder"
    unless_null $P5540, vivify_2568
    new $P5540, "Undef"
  vivify_2568:
    $P5541 = $P5533."new"($P5539, $P5540, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1958
    $P5529."push"($P5541)
.annotate 'line', 1963
    find_lex $P5542, "$?PACKAGE"
    get_who $P5543, $P5542
    set $P5544, $P5543["@BLOCK"]
    unless_null $P5544, vivify_2569
    $P5544 = root_new ['parrot';'ResizablePMCArray']
  vivify_2569:
    set $P5545, $P5544[0]
    unless_null $P5545, vivify_2570
    new $P5545, "Undef"
  vivify_2570:
    find_lex $P5546, "$name"
    unless_null $P5546, vivify_2571
    new $P5546, "Undef"
  vivify_2571:
    find_lex $P5547, "$cholder"
    unless_null $P5547, vivify_2572
    new $P5547, "Undef"
  vivify_2572:
    $P5545."symbol"($P5546, "lexical" :named("scope"), 1 :named("proto"), $P5547 :named("cholder"))
.annotate 'line', 1966
    find_lex $P5548, "$past"
    unless_null $P5548, vivify_2573
    new $P5548, "Undef"
  vivify_2573:
    $P5549 = $P5548."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1950
    .return ($P5549)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5386"  :anon :subid("540_1305640955.436") :outer("539_1305640955.436")
.annotate 'line', 1899
    .const 'Sub' $P5409 = "541_1305640955.436" 
    capture_lex $P5409
.annotate 'line', 1902
    new $P5388, "Undef"
    .lex "$cholder", $P5388
.annotate 'line', 1903
    $P5389 = root_new ['parrot';'Hash']
    .lex "%sym", $P5389
.annotate 'line', 1901
    find_dynamic_lex $P5393, "$*SCOPE"
    unless_null $P5393, vivify_2574
    get_hll_global $P5391, "GLOBAL"
    get_who $P5392, $P5391
    set $P5393, $P5392["$SCOPE"]
    unless_null $P5393, vivify_2575
    die "Contextual $*SCOPE not found"
  vivify_2575:
  vivify_2574:
    set $S5394, $P5393
    iseq $I5395, $S5394, "our"
    unless $I5395, if_5390_end
    die "our-scoped multis not yet implemented"
  if_5390_end:
    find_lex $P5396, "$cholder"
    unless_null $P5396, vivify_2576
    new $P5396, "Undef"
  vivify_2576:
.annotate 'line', 1903
    find_lex $P5397, "$?PACKAGE"
    get_who $P5398, $P5397
    set $P5399, $P5398["@BLOCK"]
    unless_null $P5399, vivify_2577
    $P5399 = root_new ['parrot';'ResizablePMCArray']
  vivify_2577:
    set $P5400, $P5399[0]
    unless_null $P5400, vivify_2578
    new $P5400, "Undef"
  vivify_2578:
    find_lex $P5401, "$name"
    unless_null $P5401, vivify_2579
    new $P5401, "Undef"
  vivify_2579:
    $P5402 = $P5400."symbol"($P5401)
    store_lex "%sym", $P5402
.annotate 'line', 1904
    find_lex $P5404, "%sym"
    unless_null $P5404, vivify_2580
    $P5404 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P5405, $P5404["cholder"]
    unless_null $P5405, vivify_2581
    new $P5405, "Undef"
  vivify_2581:
    if $P5405, if_5403
.annotate 'line', 1909
    .const 'Sub' $P5409 = "541_1305640955.436" 
    capture_lex $P5409
    $P5409()
    goto if_5403_end
  if_5403:
.annotate 'line', 1905
    find_lex $P5406, "%sym"
    unless_null $P5406, vivify_2609
    $P5406 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5407, $P5406["cholder"]
    unless_null $P5407, vivify_2610
    new $P5407, "Undef"
  vivify_2610:
    store_lex "$cholder", $P5407
  if_5403_end:
.annotate 'line', 1945
    find_lex $P5489, "$cholder"
    unless_null $P5489, vivify_2611
    new $P5489, "Undef"
  vivify_2611:
    find_lex $P5490, "$past"
    unless_null $P5490, vivify_2612
    new $P5490, "Undef"
  vivify_2612:
    $P5489."push"($P5490)
.annotate 'line', 1948
    find_lex $P5491, "$past"
    unless_null $P5491, vivify_2613
    new $P5491, "Undef"
  vivify_2613:
    $P5492 = "attach_multi_signature"($P5491)
.annotate 'line', 1899
    .return ($P5492)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5408"  :anon :subid("541_1305640955.436") :outer("540_1305640955.436")
.annotate 'line', 1909
    .const 'Sub' $P5425 = "542_1305640955.436" 
    capture_lex $P5425
.annotate 'line', 1916
    new $P5410, "Undef"
    .lex "$found_proto", $P5410
.annotate 'line', 1934
    new $P5411, "Undef"
    .lex "$dispatch_setup", $P5411
.annotate 'line', 1911
    find_lex $P5413, "%sym"
    unless_null $P5413, vivify_2582
    $P5413 = root_new ['parrot';'Hash']
  vivify_2582:
    set $P5414, $P5413["proto"]
    unless_null $P5414, vivify_2583
    new $P5414, "Undef"
  vivify_2583:
    unless $P5414, if_5412_end
.annotate 'line', 1914
    find_lex $P5415, "$/"
    unless_null $P5415, vivify_2584
    new $P5415, "Undef"
  vivify_2584:
    $P5416 = $P5415."CURSOR"()
    $P5416."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5412_end:
.annotate 'line', 1911
    find_lex $P5417, "$found_proto"
    unless_null $P5417, vivify_2585
    new $P5417, "Undef"
  vivify_2585:
.annotate 'line', 1917
    find_lex $P5419, "$?PACKAGE"
    get_who $P5420, $P5419
    set $P5421, $P5420["@BLOCK"]
    unless_null $P5421, vivify_2586
    $P5421 = root_new ['parrot';'ResizablePMCArray']
  vivify_2586:
    defined $I5422, $P5421
    unless $I5422, for_undef_2587
    iter $P5418, $P5421
    new $P5447, 'ExceptionHandler'
    set_label $P5447, loop5446_handler
    $P5447."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5447
  loop5446_test:
    unless $P5418, loop5446_done
    shift $P5423, $P5418
  loop5446_redo:
    .const 'Sub' $P5425 = "542_1305640955.436" 
    capture_lex $P5425
    $P5425($P5423)
  loop5446_next:
    goto loop5446_test
  loop5446_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5448, exception, 'type'
    eq $P5448, .CONTROL_LOOP_NEXT, loop5446_next
    eq $P5448, .CONTROL_LOOP_REDO, loop5446_redo
  loop5446_done:
    pop_eh 
  for_undef_2587:
.annotate 'line', 1928
    find_lex $P5450, "$found_proto"
    unless_null $P5450, vivify_2596
    new $P5450, "Undef"
  vivify_2596:
    if $P5450, unless_5449_end
.annotate 'line', 1929
    find_lex $P5451, "$/"
    unless_null $P5451, vivify_2597
    new $P5451, "Undef"
  vivify_2597:
    $P5452 = $P5451."CURSOR"()
    $P5452."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5449_end:
.annotate 'line', 1933
    get_hll_global $P5453, "GLOBAL"
    nqp_get_package_through_who $P5454, $P5453, "PAST"
    get_who $P5455, $P5454
    set $P5456, $P5455["Op"]
    $P5457 = $P5456."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5457
.annotate 'line', 1934
    get_hll_global $P5458, "GLOBAL"
    nqp_get_package_through_who $P5459, $P5458, "PAST"
    get_who $P5460, $P5459
    set $P5461, $P5460["Op"]
.annotate 'line', 1936
    get_hll_global $P5462, "GLOBAL"
    nqp_get_package_through_who $P5463, $P5462, "PAST"
    get_who $P5464, $P5463
    set $P5465, $P5464["Var"]
    find_lex $P5466, "$name"
    unless_null $P5466, vivify_2598
    new $P5466, "Undef"
  vivify_2598:
    $P5467 = $P5465."new"($P5466 :named("name"), "outer" :named("scope"))
    find_lex $P5468, "$cholder"
    unless_null $P5468, vivify_2599
    new $P5468, "Undef"
  vivify_2599:
    $P5469 = $P5461."new"($P5467, $P5468, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1934
    store_lex "$dispatch_setup", $P5469
.annotate 'line', 1939
    find_lex $P5470, "$?PACKAGE"
    get_who $P5471, $P5470
    set $P5472, $P5471["@BLOCK"]
    unless_null $P5472, vivify_2600
    $P5472 = root_new ['parrot';'ResizablePMCArray']
  vivify_2600:
    set $P5473, $P5472[0]
    unless_null $P5473, vivify_2601
    $P5473 = root_new ['parrot';'ResizablePMCArray']
  vivify_2601:
    set $P5474, $P5473[0]
    unless_null $P5474, vivify_2602
    new $P5474, "Undef"
  vivify_2602:
    get_hll_global $P5475, "GLOBAL"
    nqp_get_package_through_who $P5476, $P5475, "PAST"
    get_who $P5477, $P5476
    set $P5478, $P5477["Var"]
    find_lex $P5479, "$name"
    unless_null $P5479, vivify_2603
    new $P5479, "Undef"
  vivify_2603:
    find_lex $P5480, "$dispatch_setup"
    unless_null $P5480, vivify_2604
    new $P5480, "Undef"
  vivify_2604:
    $P5481 = $P5478."new"($P5479 :named("name"), 1 :named("isdecl"), $P5480 :named("viviself"), "lexical" :named("scope"))
    $P5474."push"($P5481)
.annotate 'line', 1941
    find_lex $P5482, "$?PACKAGE"
    get_who $P5483, $P5482
    set $P5484, $P5483["@BLOCK"]
    unless_null $P5484, vivify_2605
    $P5484 = root_new ['parrot';'ResizablePMCArray']
  vivify_2605:
    set $P5485, $P5484[0]
    unless_null $P5485, vivify_2606
    new $P5485, "Undef"
  vivify_2606:
    find_lex $P5486, "$name"
    unless_null $P5486, vivify_2607
    new $P5486, "Undef"
  vivify_2607:
    find_lex $P5487, "$cholder"
    unless_null $P5487, vivify_2608
    new $P5487, "Undef"
  vivify_2608:
    $P5488 = $P5485."symbol"($P5486, "lexical" :named("scope"), $P5487 :named("cholder"))
.annotate 'line', 1909
    .return ($P5488)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5424"  :anon :subid("542_1305640955.436") :outer("541_1305640955.436")
    .param pmc param_5427
.annotate 'line', 1918
    $P5426 = root_new ['parrot';'Hash']
    .lex "%sym", $P5426
    .lex "$_", param_5427
    find_lex $P5428, "$_"
    unless_null $P5428, vivify_2588
    new $P5428, "Undef"
  vivify_2588:
    find_lex $P5429, "$name"
    unless_null $P5429, vivify_2589
    new $P5429, "Undef"
  vivify_2589:
    $P5430 = $P5428."symbol"($P5429)
    store_lex "%sym", $P5430
.annotate 'line', 1919
    find_lex $P5435, "%sym"
    unless_null $P5435, vivify_2590
    $P5435 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5436, $P5435["proto"]
    unless_null $P5436, vivify_2591
    new $P5436, "Undef"
  vivify_2591:
    unless $P5436, unless_5434
    set $P5433, $P5436
    goto unless_5434_end
  unless_5434:
    find_lex $P5437, "%sym"
    unless_null $P5437, vivify_2592
    $P5437 = root_new ['parrot';'Hash']
  vivify_2592:
    set $P5438, $P5437["cholder"]
    unless_null $P5438, vivify_2593
    new $P5438, "Undef"
  vivify_2593:
    set $P5433, $P5438
  unless_5434_end:
    if $P5433, if_5432
.annotate 'line', 1922
    find_lex $P5442, "%sym"
    unless_null $P5442, vivify_2594
    $P5442 = root_new ['parrot';'Hash']
  vivify_2594:
    if $P5442, if_5441
    set $P5440, $P5442
    goto if_5441_end
  if_5441:
.annotate 'line', 1923
    find_lex $P5443, "$/"
    unless_null $P5443, vivify_2595
    new $P5443, "Undef"
  vivify_2595:
    $P5444 = $P5443."CURSOR"()
    $P5445 = $P5444."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1922
    set $P5440, $P5445
  if_5441_end:
    set $P5431, $P5440
.annotate 'line', 1919
    goto if_5432_end
  if_5432:
.annotate 'line', 1920
    new $P5439, "Integer"
    assign $P5439, 1
    store_lex "$found_proto", $P5439
.annotate 'line', 1919
    set $P5431, $P5439
  if_5432_end:
.annotate 'line', 1917
    .return ($P5431)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5636"  :anon :subid("544_1305640955.436") :outer("538_1305640955.436")
    .param pmc param_5638
.annotate 'line', 1998
    .lex "$_", param_5638
    find_lex $P5639, "$_"
    unless_null $P5639, vivify_2626
    new $P5639, "Undef"
  vivify_2626:
    $P5640 = $P5639."ast"()
    find_lex $P5641, "$/"
    unless_null $P5641, vivify_2627
    new $P5641, "Undef"
  vivify_2627:
    $P5642 = $P5640($P5641)
    .return ($P5642)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def" :anon :subid("545_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5650
    .param pmc param_5651
.annotate 'line', 2005
    .const 'Sub' $P5780 = "547_1305640955.436" 
    capture_lex $P5780
    .const 'Sub' $P5689 = "546_1305640955.436" 
    capture_lex $P5689
    .lex "self", param_5650
    .lex "$/", param_5651
.annotate 'line', 2008
    new $P5652, "Undef"
    .lex "$past", $P5652
.annotate 'line', 2005
    find_lex $P5653, "$past"
    unless_null $P5653, vivify_2629
    new $P5653, "Undef"
  vivify_2629:
.annotate 'line', 2009
    find_lex $P5655, "$/"
    unless_null $P5655, vivify_2630
    $P5655 = root_new ['parrot';'Hash']
  vivify_2630:
    set $P5656, $P5655["onlystar"]
    unless_null $P5656, vivify_2631
    new $P5656, "Undef"
  vivify_2631:
    if $P5656, if_5654
.annotate 'line', 2013
    find_lex $P5658, "$/"
    unless_null $P5658, vivify_2632
    $P5658 = root_new ['parrot';'Hash']
  vivify_2632:
    set $P5659, $P5658["blockoid"]
    unless_null $P5659, vivify_2633
    new $P5659, "Undef"
  vivify_2633:
    $P5660 = $P5659."ast"()
    store_lex "$past", $P5660
.annotate 'line', 2014
    find_lex $P5661, "$past"
    unless_null $P5661, vivify_2634
    new $P5661, "Undef"
  vivify_2634:
    $P5661."blocktype"("declaration")
.annotate 'line', 2015
    find_dynamic_lex $P5665, "$*RETURN_USED"
    unless_null $P5665, vivify_2635
    get_hll_global $P5663, "GLOBAL"
    get_who $P5664, $P5663
    set $P5665, $P5664["$RETURN_USED"]
    unless_null $P5665, vivify_2636
    die "Contextual $*RETURN_USED not found"
  vivify_2636:
  vivify_2635:
    unless $P5665, if_5662_end
.annotate 'line', 2016
    find_lex $P5666, "$past"
    unless_null $P5666, vivify_2637
    new $P5666, "Undef"
  vivify_2637:
    $P5666."control"("return_pir")
  if_5662_end:
.annotate 'line', 2012
    goto if_5654_end
  if_5654:
.annotate 'line', 2010
    $P5657 = "only_star_block"()
    store_lex "$past", $P5657
  if_5654_end:
.annotate 'line', 2021
    find_lex $P5668, "$past"
    unless_null $P5668, vivify_2638
    $P5668 = root_new ['parrot';'Hash']
  vivify_2638:
    set $P5669, $P5668["signature_has_invocant"]
    unless_null $P5669, vivify_2639
    new $P5669, "Undef"
  vivify_2639:
    if $P5669, unless_5667_end
.annotate 'line', 2022
    find_lex $P5670, "$past"
    unless_null $P5670, vivify_2640
    $P5670 = root_new ['parrot';'ResizablePMCArray']
  vivify_2640:
    set $P5671, $P5670[0]
    unless_null $P5671, vivify_2641
    new $P5671, "Undef"
  vivify_2641:
    get_hll_global $P5672, "GLOBAL"
    nqp_get_package_through_who $P5673, $P5672, "PAST"
    get_who $P5674, $P5673
    set $P5675, $P5674["Var"]
.annotate 'line', 2024
    find_dynamic_lex $P5678, "$*SC"
    unless_null $P5678, vivify_2642
    get_hll_global $P5676, "GLOBAL"
    get_who $P5677, $P5676
    set $P5678, $P5677["$SC"]
    unless_null $P5678, vivify_2643
    die "Contextual $*SC not found"
  vivify_2643:
  vivify_2642:
    find_dynamic_lex $P5681, "$*PACKAGE"
    unless_null $P5681, vivify_2644
    get_hll_global $P5679, "GLOBAL"
    get_who $P5680, $P5679
    set $P5681, $P5680["$PACKAGE"]
    unless_null $P5681, vivify_2645
    die "Contextual $*PACKAGE not found"
  vivify_2645:
  vivify_2644:
    $P5682 = $P5678."get_object_sc_ref_past"($P5681)
    $P5683 = $P5675."new"("self" :named("name"), "parameter" :named("scope"), $P5682 :named("multitype"))
.annotate 'line', 2022
    $P5671."unshift"($P5683)
  unless_5667_end:
.annotate 'line', 2027
    find_lex $P5684, "$past"
    unless_null $P5684, vivify_2646
    new $P5684, "Undef"
  vivify_2646:
    $P5684."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 2030
    find_lex $P5686, "$/"
    unless_null $P5686, vivify_2647
    $P5686 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P5687, $P5686["deflongname"]
    unless_null $P5687, vivify_2648
    new $P5687, "Undef"
  vivify_2648:
    unless $P5687, if_5685_end
    .const 'Sub' $P5689 = "546_1305640955.436" 
    capture_lex $P5689
    $P5689()
  if_5685_end:
.annotate 'line', 2057
    find_lex $P5766, "$/"
    find_lex $P5767, "$past"
    unless_null $P5767, vivify_2683
    new $P5767, "Undef"
  vivify_2683:
    $P5766."!make"($P5767)
.annotate 'line', 2058
    find_lex $P5768, "$past"
    unless_null $P5768, vivify_2684
    new $P5768, "Undef"
  vivify_2684:
    find_lex $P5769, "$past"
    unless_null $P5769, vivify_2685
    $P5769 = root_new ['parrot';'Hash']
    store_lex "$past", $P5769
  vivify_2685:
    set $P5769["block_past"], $P5768
.annotate 'line', 2059
    find_lex $P5772, "$/"
    unless_null $P5772, vivify_2686
    $P5772 = root_new ['parrot';'Hash']
  vivify_2686:
    set $P5773, $P5772["trait"]
    unless_null $P5773, vivify_2687
    new $P5773, "Undef"
  vivify_2687:
    if $P5773, if_5771
    set $P5770, $P5773
    goto if_5771_end
  if_5771:
.annotate 'line', 2060
    find_lex $P5775, "$/"
    unless_null $P5775, vivify_2688
    $P5775 = root_new ['parrot';'Hash']
  vivify_2688:
    set $P5776, $P5775["trait"]
    unless_null $P5776, vivify_2689
    new $P5776, "Undef"
  vivify_2689:
    defined $I5777, $P5776
    unless $I5777, for_undef_2690
    iter $P5774, $P5776
    new $P5787, 'ExceptionHandler'
    set_label $P5787, loop5786_handler
    $P5787."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5787
  loop5786_test:
    unless $P5774, loop5786_done
    shift $P5778, $P5774
  loop5786_redo:
    .const 'Sub' $P5780 = "547_1305640955.436" 
    capture_lex $P5780
    $P5780($P5778)
  loop5786_next:
    goto loop5786_test
  loop5786_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5788, exception, 'type'
    eq $P5788, .CONTROL_LOOP_NEXT, loop5786_next
    eq $P5788, .CONTROL_LOOP_REDO, loop5786_redo
  loop5786_done:
    pop_eh 
  for_undef_2690:
.annotate 'line', 2059
    set $P5770, $P5774
  if_5771_end:
.annotate 'line', 2005
    .return ($P5770)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5688"  :anon :subid("546_1305640955.436") :outer("545_1305640955.436")
.annotate 'line', 2032
    new $P5690, "Undef"
    .lex "$name", $P5690
.annotate 'line', 2040
    new $P5691, "Undef"
    .lex "$meta_meth", $P5691
.annotate 'line', 2041
    new $P5692, "Undef"
    .lex "$is_dispatcher", $P5692
.annotate 'line', 2032
    find_lex $P5693, "$/"
    unless_null $P5693, vivify_2649
    $P5693 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P5694, $P5693["private"]
    unless_null $P5694, vivify_2650
    new $P5694, "Undef"
  vivify_2650:
    set $S5695, $P5694
    new $P5696, 'String'
    set $P5696, $S5695
    find_lex $P5697, "$/"
    unless_null $P5697, vivify_2651
    $P5697 = root_new ['parrot';'Hash']
  vivify_2651:
    set $P5698, $P5697["deflongname"]
    unless_null $P5698, vivify_2652
    $P5698 = root_new ['parrot';'ResizablePMCArray']
  vivify_2652:
    set $P5699, $P5698[0]
    unless_null $P5699, vivify_2653
    new $P5699, "Undef"
  vivify_2653:
    $P5700 = $P5699."ast"()
    set $S5701, $P5700
    concat $P5702, $P5696, $S5701
    store_lex "$name", $P5702
.annotate 'line', 2033
    find_lex $P5703, "$past"
    unless_null $P5703, vivify_2654
    new $P5703, "Undef"
  vivify_2654:
    find_lex $P5704, "$name"
    unless_null $P5704, vivify_2655
    new $P5704, "Undef"
  vivify_2655:
    $P5703."name"($P5704)
.annotate 'line', 2037
    find_dynamic_lex $P5708, "$*MULTINESS"
    unless_null $P5708, vivify_2656
    get_hll_global $P5706, "GLOBAL"
    get_who $P5707, $P5706
    set $P5708, $P5707["$MULTINESS"]
    unless_null $P5708, vivify_2657
    die "Contextual $*MULTINESS not found"
  vivify_2657:
  vivify_2656:
    set $S5709, $P5708
    iseq $I5710, $S5709, "multi"
    unless $I5710, if_5705_end
    find_lex $P5711, "$past"
    unless_null $P5711, vivify_2658
    new $P5711, "Undef"
  vivify_2658:
    "attach_multi_signature"($P5711)
  if_5705_end:
.annotate 'line', 2040
    find_dynamic_lex $P5716, "$*MULTINESS"
    unless_null $P5716, vivify_2659
    get_hll_global $P5714, "GLOBAL"
    get_who $P5715, $P5714
    set $P5716, $P5715["$MULTINESS"]
    unless_null $P5716, vivify_2660
    die "Contextual $*MULTINESS not found"
  vivify_2660:
  vivify_2659:
    set $S5717, $P5716
    iseq $I5718, $S5717, "multi"
    if $I5718, if_5713
    new $P5720, "String"
    assign $P5720, "add_method"
    set $P5712, $P5720
    goto if_5713_end
  if_5713:
    new $P5719, "String"
    assign $P5719, "add_multi_method"
    set $P5712, $P5719
  if_5713_end:
    store_lex "$meta_meth", $P5712
.annotate 'line', 2041
    find_dynamic_lex $P5723, "$*MULTINESS"
    unless_null $P5723, vivify_2661
    get_hll_global $P5721, "GLOBAL"
    get_who $P5722, $P5721
    set $P5723, $P5722["$MULTINESS"]
    unless_null $P5723, vivify_2662
    die "Contextual $*MULTINESS not found"
  vivify_2662:
  vivify_2661:
    set $S5724, $P5723
    iseq $I5725, $S5724, "proto"
    new $P5726, 'Integer'
    set $P5726, $I5725
    store_lex "$is_dispatcher", $P5726
.annotate 'line', 2042
    find_dynamic_lex $P5729, "$*SC"
    unless_null $P5729, vivify_2663
    get_hll_global $P5727, "GLOBAL"
    get_who $P5728, $P5727
    set $P5729, $P5728["$SC"]
    unless_null $P5729, vivify_2664
    die "Contextual $*SC not found"
  vivify_2664:
  vivify_2663:
    find_dynamic_lex $P5732, "$*PACKAGE"
    unless_null $P5732, vivify_2665
    get_hll_global $P5730, "GLOBAL"
    get_who $P5731, $P5730
    set $P5732, $P5731["$PACKAGE"]
    unless_null $P5732, vivify_2666
    die "Contextual $*PACKAGE not found"
  vivify_2666:
  vivify_2665:
    find_lex $P5733, "$meta_meth"
    unless_null $P5733, vivify_2667
    new $P5733, "Undef"
  vivify_2667:
    find_lex $P5734, "$name"
    unless_null $P5734, vivify_2668
    new $P5734, "Undef"
  vivify_2668:
    find_lex $P5735, "$past"
    unless_null $P5735, vivify_2669
    new $P5735, "Undef"
  vivify_2669:
    find_lex $P5736, "$is_dispatcher"
    unless_null $P5736, vivify_2670
    new $P5736, "Undef"
  vivify_2670:
    $P5729."pkg_add_method"($P5732, $P5733, $P5734, $P5735, $P5736)
.annotate 'line', 2045
    find_dynamic_lex $P5741, "$*SCOPE"
    unless_null $P5741, vivify_2671
    get_hll_global $P5739, "GLOBAL"
    get_who $P5740, $P5739
    set $P5741, $P5740["$SCOPE"]
    unless_null $P5741, vivify_2672
    die "Contextual $*SCOPE not found"
  vivify_2672:
  vivify_2671:
    set $S5742, $P5741
    iseq $I5743, $S5742, "our"
    if $I5743, if_5738
.annotate 'line', 2048
    find_lex $P5755, "$past"
    unless_null $P5755, vivify_2673
    new $P5755, "Undef"
  vivify_2673:
    $P5756 = $P5755."pirflags"()
    if $P5756, if_5754
.annotate 'line', 2051
    find_lex $P5764, "$past"
    unless_null $P5764, vivify_2674
    new $P5764, "Undef"
  vivify_2674:
    $P5765 = $P5764."pirflags"(":anon")
.annotate 'line', 2050
    set $P5753, $P5765
.annotate 'line', 2048
    goto if_5754_end
  if_5754:
.annotate 'line', 2049
    find_lex $P5757, "$past"
    unless_null $P5757, vivify_2675
    new $P5757, "Undef"
  vivify_2675:
    find_lex $P5758, "$past"
    unless_null $P5758, vivify_2676
    new $P5758, "Undef"
  vivify_2676:
    $P5759 = $P5758."pirflags"()
    set $S5760, $P5759
    new $P5761, 'String'
    set $P5761, $S5760
    concat $P5762, $P5761, ":anon"
    $P5763 = $P5757."pirflags"($P5762)
.annotate 'line', 2048
    set $P5753, $P5763
  if_5754_end:
.annotate 'line', 2047
    set $P5737, $P5753
.annotate 'line', 2045
    goto if_5738_end
  if_5738:
.annotate 'line', 2046
    find_dynamic_lex $P5746, "$*SC"
    unless_null $P5746, vivify_2677
    get_hll_global $P5744, "GLOBAL"
    get_who $P5745, $P5744
    set $P5746, $P5745["$SC"]
    unless_null $P5746, vivify_2678
    die "Contextual $*SC not found"
  vivify_2678:
  vivify_2677:
    find_dynamic_lex $P5749, "$*PACKAGE"
    unless_null $P5749, vivify_2679
    get_hll_global $P5747, "GLOBAL"
    get_who $P5748, $P5747
    set $P5749, $P5748["$PACKAGE"]
    unless_null $P5749, vivify_2680
    die "Contextual $*PACKAGE not found"
  vivify_2680:
  vivify_2679:
    find_lex $P5750, "$name"
    unless_null $P5750, vivify_2681
    new $P5750, "Undef"
  vivify_2681:
    find_lex $P5751, "$past"
    unless_null $P5751, vivify_2682
    new $P5751, "Undef"
  vivify_2682:
    $P5752 = $P5746."install_package_routine"($P5749, $P5750, $P5751)
.annotate 'line', 2045
    set $P5737, $P5752
  if_5738_end:
.annotate 'line', 2030
    .return ($P5737)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5779"  :anon :subid("547_1305640955.436") :outer("545_1305640955.436")
    .param pmc param_5781
.annotate 'line', 2060
    .lex "$_", param_5781
    find_lex $P5782, "$_"
    unless_null $P5782, vivify_2691
    new $P5782, "Undef"
  vivify_2691:
    $P5783 = $P5782."ast"()
    find_lex $P5784, "$/"
    unless_null $P5784, vivify_2692
    new $P5784, "Undef"
  vivify_2692:
    $P5785 = $P5783($P5784)
    .return ($P5785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature" :anon :subid("548_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5792
    .param pmc param_5793
.annotate 'line', 2089
    .const 'Sub' $P5836 = "550_1305640955.436" 
    capture_lex $P5836
    .const 'Sub' $P5804 = "549_1305640955.436" 
    capture_lex $P5804
    .lex "self", param_5792
    .lex "$/", param_5793
.annotate 'line', 2090
    new $P5794, "Undef"
    .lex "$BLOCKINIT", $P5794
    find_lex $P5795, "$?PACKAGE"
    get_who $P5796, $P5795
    set $P5797, $P5796["@BLOCK"]
    unless_null $P5797, vivify_2693
    $P5797 = root_new ['parrot';'ResizablePMCArray']
  vivify_2693:
    set $P5798, $P5797[0]
    unless_null $P5798, vivify_2694
    $P5798 = root_new ['parrot';'ResizablePMCArray']
  vivify_2694:
    set $P5799, $P5798[0]
    unless_null $P5799, vivify_2695
    new $P5799, "Undef"
  vivify_2695:
    store_lex "$BLOCKINIT", $P5799
.annotate 'line', 2091
    find_lex $P5801, "$/"
    unless_null $P5801, vivify_2696
    $P5801 = root_new ['parrot';'Hash']
  vivify_2696:
    set $P5802, $P5801["invocant"]
    unless_null $P5802, vivify_2697
    new $P5802, "Undef"
  vivify_2697:
    unless $P5802, if_5800_end
    .const 'Sub' $P5804 = "549_1305640955.436" 
    capture_lex $P5804
    $P5804()
  if_5800_end:
.annotate 'line', 2100
    find_lex $P5831, "$/"
    unless_null $P5831, vivify_2707
    $P5831 = root_new ['parrot';'Hash']
  vivify_2707:
    set $P5832, $P5831["parameter"]
    unless_null $P5832, vivify_2708
    new $P5832, "Undef"
  vivify_2708:
    defined $I5833, $P5832
    unless $I5833, for_undef_2709
    iter $P5830, $P5832
    new $P5843, 'ExceptionHandler'
    set_label $P5843, loop5842_handler
    $P5843."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5843
  loop5842_test:
    unless $P5830, loop5842_done
    shift $P5834, $P5830
  loop5842_redo:
    .const 'Sub' $P5836 = "550_1305640955.436" 
    capture_lex $P5836
    $P5836($P5834)
  loop5842_next:
    goto loop5842_test
  loop5842_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5844, exception, 'type'
    eq $P5844, .CONTROL_LOOP_NEXT, loop5842_next
    eq $P5844, .CONTROL_LOOP_REDO, loop5842_redo
  loop5842_done:
    pop_eh 
  for_undef_2709:
.annotate 'line', 2089
    .return ($P5830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5803"  :anon :subid("549_1305640955.436") :outer("548_1305640955.436")
.annotate 'line', 2092
    new $P5805, "Undef"
    .lex "$inv", $P5805
    find_lex $P5806, "$/"
    unless_null $P5806, vivify_2698
    $P5806 = root_new ['parrot';'Hash']
  vivify_2698:
    set $P5807, $P5806["invocant"]
    unless_null $P5807, vivify_2699
    $P5807 = root_new ['parrot';'ResizablePMCArray']
  vivify_2699:
    set $P5808, $P5807[0]
    unless_null $P5808, vivify_2700
    new $P5808, "Undef"
  vivify_2700:
    $P5809 = $P5808."ast"()
    store_lex "$inv", $P5809
.annotate 'line', 2093
    find_lex $P5810, "$BLOCKINIT"
    unless_null $P5810, vivify_2701
    new $P5810, "Undef"
  vivify_2701:
    find_lex $P5811, "$inv"
    unless_null $P5811, vivify_2702
    new $P5811, "Undef"
  vivify_2702:
    $P5810."push"($P5811)
.annotate 'line', 2094
    find_lex $P5812, "$BLOCKINIT"
    unless_null $P5812, vivify_2703
    new $P5812, "Undef"
  vivify_2703:
    get_hll_global $P5813, "GLOBAL"
    nqp_get_package_through_who $P5814, $P5813, "PAST"
    get_who $P5815, $P5814
    set $P5816, $P5815["Var"]
.annotate 'line', 2096
    get_hll_global $P5817, "GLOBAL"
    nqp_get_package_through_who $P5818, $P5817, "PAST"
    get_who $P5819, $P5818
    set $P5820, $P5819["Var"]
    find_lex $P5821, "$inv"
    unless_null $P5821, vivify_2704
    new $P5821, "Undef"
  vivify_2704:
    $P5822 = $P5821."name"()
    $P5823 = $P5820."new"("lexical" :named("scope"), $P5822 :named("name"))
    $P5824 = $P5816."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5823 :named("viviself"))
.annotate 'line', 2094
    $P5812."push"($P5824)
.annotate 'line', 2098
    new $P5825, "Integer"
    assign $P5825, 1
    find_lex $P5826, "$?PACKAGE"
    get_who $P5827, $P5826
    set $P5828, $P5827["@BLOCK"]
    unless_null $P5828, vivify_2705
    $P5828 = root_new ['parrot';'ResizablePMCArray']
    set $P5827["@BLOCK"], $P5828
  vivify_2705:
    set $P5829, $P5828[0]
    unless_null $P5829, vivify_2706
    $P5829 = root_new ['parrot';'Hash']
    set $P5828[0], $P5829
  vivify_2706:
    set $P5829["signature_has_invocant"], $P5825
.annotate 'line', 2091
    .return ($P5825)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5835"  :anon :subid("550_1305640955.436") :outer("548_1305640955.436")
    .param pmc param_5837
.annotate 'line', 2100
    .lex "$_", param_5837
    find_lex $P5838, "$BLOCKINIT"
    unless_null $P5838, vivify_2710
    new $P5838, "Undef"
  vivify_2710:
    find_lex $P5839, "$_"
    unless_null $P5839, vivify_2711
    new $P5839, "Undef"
  vivify_2711:
    $P5840 = $P5839."ast"()
    $P5841 = $P5838."push"($P5840)
    .return ($P5841)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter" :anon :subid("551_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5846
    .param pmc param_5847
.annotate 'line', 2103
    .lex "self", param_5846
    .lex "$/", param_5847
.annotate 'line', 2104
    new $P5848, "Undef"
    .lex "$quant", $P5848
.annotate 'line', 2105
    new $P5849, "Undef"
    .lex "$past", $P5849
.annotate 'line', 2104
    find_lex $P5850, "$/"
    unless_null $P5850, vivify_2712
    $P5850 = root_new ['parrot';'Hash']
  vivify_2712:
    set $P5851, $P5850["quant"]
    unless_null $P5851, vivify_2713
    new $P5851, "Undef"
  vivify_2713:
    store_lex "$quant", $P5851
    find_lex $P5852, "$past"
    unless_null $P5852, vivify_2714
    new $P5852, "Undef"
  vivify_2714:
.annotate 'line', 2106
    find_lex $P5854, "$/"
    unless_null $P5854, vivify_2715
    $P5854 = root_new ['parrot';'Hash']
  vivify_2715:
    set $P5855, $P5854["named_param"]
    unless_null $P5855, vivify_2716
    new $P5855, "Undef"
  vivify_2716:
    if $P5855, if_5853
.annotate 'line', 2113
    find_lex $P5869, "$/"
    unless_null $P5869, vivify_2717
    $P5869 = root_new ['parrot';'Hash']
  vivify_2717:
    set $P5870, $P5869["param_var"]
    unless_null $P5870, vivify_2718
    new $P5870, "Undef"
  vivify_2718:
    $P5871 = $P5870."ast"()
    store_lex "$past", $P5871
.annotate 'line', 2114
    find_lex $P5873, "$quant"
    unless_null $P5873, vivify_2719
    new $P5873, "Undef"
  vivify_2719:
    set $S5874, $P5873
    iseq $I5875, $S5874, "*"
    if $I5875, if_5872
.annotate 'line', 2118
    find_lex $P5884, "$quant"
    unless_null $P5884, vivify_2720
    new $P5884, "Undef"
  vivify_2720:
    set $S5885, $P5884
    iseq $I5886, $S5885, "?"
    unless $I5886, if_5883_end
.annotate 'line', 2119
    find_lex $P5887, "$past"
    unless_null $P5887, vivify_2721
    new $P5887, "Undef"
  vivify_2721:
    find_lex $P5888, "$/"
    unless_null $P5888, vivify_2722
    $P5888 = root_new ['parrot';'Hash']
  vivify_2722:
    set $P5889, $P5888["param_var"]
    unless_null $P5889, vivify_2723
    $P5889 = root_new ['parrot';'Hash']
  vivify_2723:
    set $P5890, $P5889["sigil"]
    unless_null $P5890, vivify_2724
    new $P5890, "Undef"
  vivify_2724:
    $P5891 = "vivitype"($P5890)
    $P5887."viviself"($P5891)
  if_5883_end:
.annotate 'line', 2118
    goto if_5872_end
  if_5872:
.annotate 'line', 2115
    find_lex $P5876, "$past"
    unless_null $P5876, vivify_2725
    new $P5876, "Undef"
  vivify_2725:
    $P5876."slurpy"(1)
.annotate 'line', 2116
    find_lex $P5877, "$past"
    unless_null $P5877, vivify_2726
    new $P5877, "Undef"
  vivify_2726:
    find_lex $P5878, "$/"
    unless_null $P5878, vivify_2727
    $P5878 = root_new ['parrot';'Hash']
  vivify_2727:
    set $P5879, $P5878["param_var"]
    unless_null $P5879, vivify_2728
    $P5879 = root_new ['parrot';'Hash']
  vivify_2728:
    set $P5880, $P5879["sigil"]
    unless_null $P5880, vivify_2729
    new $P5880, "Undef"
  vivify_2729:
    set $S5881, $P5880
    iseq $I5882, $S5881, "%"
    $P5877."named"($I5882)
  if_5872_end:
.annotate 'line', 2112
    goto if_5853_end
  if_5853:
.annotate 'line', 2107
    find_lex $P5856, "$/"
    unless_null $P5856, vivify_2730
    $P5856 = root_new ['parrot';'Hash']
  vivify_2730:
    set $P5857, $P5856["named_param"]
    unless_null $P5857, vivify_2731
    new $P5857, "Undef"
  vivify_2731:
    $P5858 = $P5857."ast"()
    store_lex "$past", $P5858
.annotate 'line', 2108
    find_lex $P5860, "$quant"
    unless_null $P5860, vivify_2732
    new $P5860, "Undef"
  vivify_2732:
    set $S5861, $P5860
    isne $I5862, $S5861, "!"
    unless $I5862, if_5859_end
.annotate 'line', 2109
    find_lex $P5863, "$past"
    unless_null $P5863, vivify_2733
    new $P5863, "Undef"
  vivify_2733:
    find_lex $P5864, "$/"
    unless_null $P5864, vivify_2734
    $P5864 = root_new ['parrot';'Hash']
  vivify_2734:
    set $P5865, $P5864["named_param"]
    unless_null $P5865, vivify_2735
    $P5865 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P5866, $P5865["param_var"]
    unless_null $P5866, vivify_2736
    $P5866 = root_new ['parrot';'Hash']
  vivify_2736:
    set $P5867, $P5866["sigil"]
    unless_null $P5867, vivify_2737
    new $P5867, "Undef"
  vivify_2737:
    $P5868 = "vivitype"($P5867)
    $P5863."viviself"($P5868)
  if_5859_end:
  if_5853_end:
.annotate 'line', 2122
    find_lex $P5893, "$/"
    unless_null $P5893, vivify_2738
    $P5893 = root_new ['parrot';'Hash']
  vivify_2738:
    set $P5894, $P5893["default_value"]
    unless_null $P5894, vivify_2739
    new $P5894, "Undef"
  vivify_2739:
    unless $P5894, if_5892_end
.annotate 'line', 2123
    find_lex $P5896, "$quant"
    unless_null $P5896, vivify_2740
    new $P5896, "Undef"
  vivify_2740:
    set $S5897, $P5896
    iseq $I5898, $S5897, "*"
    unless $I5898, if_5895_end
.annotate 'line', 2124
    find_lex $P5899, "$/"
    unless_null $P5899, vivify_2741
    new $P5899, "Undef"
  vivify_2741:
    $P5900 = $P5899."CURSOR"()
    $P5900."panic"("Can't put default on slurpy parameter")
  if_5895_end:
.annotate 'line', 2126
    find_lex $P5902, "$quant"
    unless_null $P5902, vivify_2742
    new $P5902, "Undef"
  vivify_2742:
    set $S5903, $P5902
    iseq $I5904, $S5903, "!"
    unless $I5904, if_5901_end
.annotate 'line', 2127
    find_lex $P5905, "$/"
    unless_null $P5905, vivify_2743
    new $P5905, "Undef"
  vivify_2743:
    $P5906 = $P5905."CURSOR"()
    $P5906."panic"("Can't put default on required parameter")
  if_5901_end:
.annotate 'line', 2129
    find_lex $P5907, "$past"
    unless_null $P5907, vivify_2744
    new $P5907, "Undef"
  vivify_2744:
    find_lex $P5908, "$/"
    unless_null $P5908, vivify_2745
    $P5908 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P5909, $P5908["default_value"]
    unless_null $P5909, vivify_2746
    $P5909 = root_new ['parrot';'ResizablePMCArray']
  vivify_2746:
    set $P5910, $P5909[0]
    unless_null $P5910, vivify_2747
    $P5910 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P5911, $P5910["EXPR"]
    unless_null $P5911, vivify_2748
    new $P5911, "Undef"
  vivify_2748:
    $P5912 = $P5911."ast"()
    $P5907."viviself"($P5912)
  if_5892_end:
.annotate 'line', 2131
    find_lex $P5914, "$past"
    unless_null $P5914, vivify_2749
    new $P5914, "Undef"
  vivify_2749:
    $P5915 = $P5914."viviself"()
    if $P5915, unless_5913_end
    find_lex $P5916, "$?PACKAGE"
    get_who $P5917, $P5916
    set $P5918, $P5917["@BLOCK"]
    unless_null $P5918, vivify_2750
    $P5918 = root_new ['parrot';'ResizablePMCArray']
  vivify_2750:
    set $P5919, $P5918[0]
    unless_null $P5919, vivify_2751
    new $P5919, "Undef"
  vivify_2751:
    find_lex $P5920, "$?PACKAGE"
    get_who $P5921, $P5920
    set $P5922, $P5921["@BLOCK"]
    unless_null $P5922, vivify_2752
    $P5922 = root_new ['parrot';'ResizablePMCArray']
  vivify_2752:
    set $P5923, $P5922[0]
    unless_null $P5923, vivify_2753
    new $P5923, "Undef"
  vivify_2753:
    $P5924 = $P5923."arity"()
    set $N5925, $P5924
    new $P5926, 'Float'
    set $P5926, $N5925
    add $P5927, $P5926, 1
    $P5919."arity"($P5927)
  unless_5913_end:
.annotate 'line', 2135
    find_lex $P5929, "$/"
    unless_null $P5929, vivify_2754
    $P5929 = root_new ['parrot';'Hash']
  vivify_2754:
    set $P5930, $P5929["typename"]
    unless_null $P5930, vivify_2755
    new $P5930, "Undef"
  vivify_2755:
    unless $P5930, if_5928_end
.annotate 'line', 2136
    find_lex $P5931, "$past"
    unless_null $P5931, vivify_2756
    new $P5931, "Undef"
  vivify_2756:
    find_lex $P5932, "$/"
    unless_null $P5932, vivify_2757
    $P5932 = root_new ['parrot';'Hash']
  vivify_2757:
    set $P5933, $P5932["typename"]
    unless_null $P5933, vivify_2758
    $P5933 = root_new ['parrot';'ResizablePMCArray']
  vivify_2758:
    set $P5934, $P5933[0]
    unless_null $P5934, vivify_2759
    new $P5934, "Undef"
  vivify_2759:
    $P5935 = $P5934."ast"()
    $P5931."multitype"($P5935)
  if_5928_end:
.annotate 'line', 2140
    find_lex $P5937, "$/"
    unless_null $P5937, vivify_2760
    $P5937 = root_new ['parrot';'Hash']
  vivify_2760:
    set $P5938, $P5937["definedness"]
    unless_null $P5938, vivify_2761
    new $P5938, "Undef"
  vivify_2761:
    unless $P5938, if_5936_end
.annotate 'line', 2141
    find_lex $P5939, "$/"
    unless_null $P5939, vivify_2762
    $P5939 = root_new ['parrot';'Hash']
  vivify_2762:
    set $P5940, $P5939["definedness"]
    unless_null $P5940, vivify_2763
    $P5940 = root_new ['parrot';'ResizablePMCArray']
  vivify_2763:
    set $P5941, $P5940[0]
    unless_null $P5941, vivify_2764
    new $P5941, "Undef"
  vivify_2764:
    set $S5942, $P5941
    new $P5943, 'String'
    set $P5943, $S5942
    find_lex $P5944, "$past"
    unless_null $P5944, vivify_2765
    $P5944 = root_new ['parrot';'Hash']
    store_lex "$past", $P5944
  vivify_2765:
    set $P5944["definedness"], $P5943
  if_5936_end:
.annotate 'line', 2144
    find_lex $P5945, "$/"
    find_lex $P5946, "$past"
    unless_null $P5946, vivify_2766
    new $P5946, "Undef"
  vivify_2766:
    $P5947 = $P5945."!make"($P5946)
.annotate 'line', 2103
    .return ($P5947)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var" :anon :subid("552_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5949
    .param pmc param_5950
.annotate 'line', 2147
    .lex "self", param_5949
    .lex "$/", param_5950
.annotate 'line', 2148
    new $P5951, "Undef"
    .lex "$name", $P5951
.annotate 'line', 2149
    new $P5952, "Undef"
    .lex "$past", $P5952
.annotate 'line', 2148
    find_lex $P5953, "$/"
    unless_null $P5953, vivify_2767
    new $P5953, "Undef"
  vivify_2767:
    set $S5954, $P5953
    new $P5955, 'String'
    set $P5955, $S5954
    store_lex "$name", $P5955
.annotate 'line', 2149
    get_hll_global $P5956, "GLOBAL"
    nqp_get_package_through_who $P5957, $P5956, "PAST"
    get_who $P5958, $P5957
    set $P5959, $P5958["Var"]
    find_lex $P5960, "$name"
    unless_null $P5960, vivify_2768
    new $P5960, "Undef"
  vivify_2768:
    find_lex $P5961, "$/"
    unless_null $P5961, vivify_2769
    new $P5961, "Undef"
  vivify_2769:
    $P5962 = $P5959."new"($P5960 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5961 :named("node"))
    store_lex "$past", $P5962
.annotate 'line', 2151
    find_lex $P5963, "$?PACKAGE"
    get_who $P5964, $P5963
    set $P5965, $P5964["@BLOCK"]
    unless_null $P5965, vivify_2770
    $P5965 = root_new ['parrot';'ResizablePMCArray']
  vivify_2770:
    set $P5966, $P5965[0]
    unless_null $P5966, vivify_2771
    new $P5966, "Undef"
  vivify_2771:
    find_lex $P5967, "$name"
    unless_null $P5967, vivify_2772
    new $P5967, "Undef"
  vivify_2772:
    $P5966."symbol"($P5967, "lexical" :named("scope"))
.annotate 'line', 2152
    find_lex $P5968, "$/"
    find_lex $P5969, "$past"
    unless_null $P5969, vivify_2773
    new $P5969, "Undef"
  vivify_2773:
    $P5970 = $P5968."!make"($P5969)
.annotate 'line', 2147
    .return ($P5970)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param" :anon :subid("553_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5972
    .param pmc param_5973
.annotate 'line', 2155
    .lex "self", param_5972
    .lex "$/", param_5973
.annotate 'line', 2156
    new $P5974, "Undef"
    .lex "$past", $P5974
    find_lex $P5975, "$/"
    unless_null $P5975, vivify_2774
    $P5975 = root_new ['parrot';'Hash']
  vivify_2774:
    set $P5976, $P5975["param_var"]
    unless_null $P5976, vivify_2775
    new $P5976, "Undef"
  vivify_2775:
    $P5977 = $P5976."ast"()
    store_lex "$past", $P5977
.annotate 'line', 2157
    find_lex $P5978, "$past"
    unless_null $P5978, vivify_2776
    new $P5978, "Undef"
  vivify_2776:
    find_lex $P5979, "$/"
    unless_null $P5979, vivify_2777
    $P5979 = root_new ['parrot';'Hash']
  vivify_2777:
    set $P5980, $P5979["param_var"]
    unless_null $P5980, vivify_2778
    $P5980 = root_new ['parrot';'Hash']
  vivify_2778:
    set $P5981, $P5980["name"]
    unless_null $P5981, vivify_2779
    new $P5981, "Undef"
  vivify_2779:
    set $S5982, $P5981
    $P5978."named"($S5982)
.annotate 'line', 2158
    find_lex $P5983, "$/"
    find_lex $P5984, "$past"
    unless_null $P5984, vivify_2780
    new $P5984, "Undef"
  vivify_2780:
    $P5985 = $P5983."!make"($P5984)
.annotate 'line', 2155
    .return ($P5985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename" :anon :subid("554_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_5987
    .param pmc param_5988
.annotate 'line', 2161
    .const 'Sub' $P6000 = "555_1305640955.436" 
    capture_lex $P6000
    .lex "self", param_5987
    .lex "$/", param_5988
.annotate 'line', 2165
    $P5989 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5989
.annotate 'line', 2166
    new $P5990, "Undef"
    .lex "$found", $P5990
.annotate 'line', 2165
    get_hll_global $P5991, "GLOBAL"
    nqp_get_package_through_who $P5992, $P5991, "HLL"
    get_who $P5993, $P5992
    set $P5994, $P5993["Compiler"]
    find_lex $P5995, "$/"
    unless_null $P5995, vivify_2781
    new $P5995, "Undef"
  vivify_2781:
    set $S5996, $P5995
    $P5997 = $P5994."parse_name"($S5996)
    store_lex "@name", $P5997
.annotate 'line', 2166
    new $P5998, "Integer"
    assign $P5998, 0
    store_lex "$found", $P5998
.annotate 'line', 2167
    .const 'Sub' $P6000 = "555_1305640955.436" 
    capture_lex $P6000
    $P6000()
.annotate 'line', 2172
    find_lex $P6021, "$found"
    unless_null $P6021, vivify_2787
    new $P6021, "Undef"
  vivify_2787:
    unless $P6021, unless_6020
    set $P6019, $P6021
    goto unless_6020_end
  unless_6020:
.annotate 'line', 2173
    find_lex $P6022, "$/"
    unless_null $P6022, vivify_2788
    new $P6022, "Undef"
  vivify_2788:
    $P6023 = $P6022."CURSOR"()
    new $P6024, "String"
    assign $P6024, "Use of undeclared type '"
    find_lex $P6025, "$/"
    unless_null $P6025, vivify_2789
    new $P6025, "Undef"
  vivify_2789:
    set $S6026, $P6025
    concat $P6027, $P6024, $S6026
    concat $P6028, $P6027, "'"
    $P6029 = $P6023."panic"($P6028)
.annotate 'line', 2172
    set $P6019, $P6029
  unless_6020_end:
.annotate 'line', 2161
    .return ($P6019)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5999"  :anon :subid("555_1305640955.436") :outer("554_1305640955.436")
.annotate 'line', 2167
    new $P6014, 'ExceptionHandler'
    set_label $P6014, control_6013
    $P6014."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P6014
.annotate 'line', 2168
    new $P6001, "Undef"
    .lex "$sym", $P6001
    find_lex $P6002, "@name"
    unless_null $P6002, vivify_2782
    $P6002 = root_new ['parrot';'ResizablePMCArray']
  vivify_2782:
    find_lex $P6003, "$/"
    unless_null $P6003, vivify_2783
    new $P6003, "Undef"
  vivify_2783:
    $P6004 = "find_sym"($P6002, $P6003)
    store_lex "$sym", $P6004
.annotate 'line', 2169
    find_dynamic_lex $P6005, "$/"
    find_dynamic_lex $P6008, "$*SC"
    unless_null $P6008, vivify_2784
    get_hll_global $P6006, "GLOBAL"
    get_who $P6007, $P6006
    set $P6008, $P6007["$SC"]
    unless_null $P6008, vivify_2785
    die "Contextual $*SC not found"
  vivify_2785:
  vivify_2784:
    find_lex $P6009, "$sym"
    unless_null $P6009, vivify_2786
    new $P6009, "Undef"
  vivify_2786:
    $P6010 = $P6008."get_object_sc_ref_past"($P6009)
    $P6005."!make"($P6010)
.annotate 'line', 2170
    new $P6011, "Integer"
    assign $P6011, 1
    store_lex "$found", $P6011
.annotate 'line', 2167
    pop_eh 
    goto skip_handler_6012
  control_6013:
    .local pmc exception 
    .get_results (exception) 
    new $P6017, 'Integer'
    set $P6017, 1
    set exception["handled"], $P6017
    set $I6018, exception["handled"]
    ne $I6018, 1, nothandled_6016
  handled_6015:
    .return (exception)
  nothandled_6016:
    rethrow exception
  skip_handler_6012:
    .return ($P6011)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait" :anon :subid("556_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6031
    .param pmc param_6032
.annotate 'line', 2177
    .lex "self", param_6031
    .lex "$/", param_6032
.annotate 'line', 2178
    find_lex $P6033, "$/"
    find_lex $P6034, "$/"
    unless_null $P6034, vivify_2790
    $P6034 = root_new ['parrot';'Hash']
  vivify_2790:
    set $P6035, $P6034["trait_mod"]
    unless_null $P6035, vivify_2791
    new $P6035, "Undef"
  vivify_2791:
    $P6036 = $P6035."ast"()
    $P6037 = $P6033."!make"($P6036)
.annotate 'line', 2177
    .return ($P6037)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>" :anon :subid("557_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6039
    .param pmc param_6040
.annotate 'line', 2181
    .const 'Sub' $P6101 = "560_1305640955.436" 
    capture_lex $P6101
    .const 'Sub' $P6048 = "558_1305640955.436" 
    capture_lex $P6048
    .lex "self", param_6039
    .lex "$/", param_6040
.annotate 'line', 2182
    find_lex $P6043, "$/"
    unless_null $P6043, vivify_2792
    $P6043 = root_new ['parrot';'Hash']
  vivify_2792:
    set $P6044, $P6043["longname"]
    unless_null $P6044, vivify_2793
    new $P6044, "Undef"
  vivify_2793:
    set $S6045, $P6044
    iseq $I6046, $S6045, "parrot_vtable"
    if $I6046, if_6042
.annotate 'line', 2195
    find_lex $P6096, "$/"
    unless_null $P6096, vivify_2794
    $P6096 = root_new ['parrot';'Hash']
  vivify_2794:
    set $P6097, $P6096["longname"]
    unless_null $P6097, vivify_2795
    new $P6097, "Undef"
  vivify_2795:
    set $S6098, $P6097
    iseq $I6099, $S6098, "parrot_vtable_handler"
    if $I6099, if_6095
.annotate 'line', 2206
    find_lex $P6141, "$/"
    unless_null $P6141, vivify_2796
    $P6141 = root_new ['parrot';'Hash']
  vivify_2796:
    set $P6142, $P6141["longname"]
    unless_null $P6142, vivify_2797
    new $P6142, "Undef"
  vivify_2797:
    set $S6143, $P6142
    iseq $I6144, $S6143, "pirflags"
    if $I6144, if_6140
.annotate 'line', 2210
    find_lex $P6148, "$/"
    unless_null $P6148, vivify_2798
    new $P6148, "Undef"
  vivify_2798:
    $P6149 = $P6148."CURSOR"()
    new $P6150, 'String'
    set $P6150, "Trait '"
    find_lex $P6151, "$/"
    unless_null $P6151, vivify_2799
    $P6151 = root_new ['parrot';'Hash']
  vivify_2799:
    set $P6152, $P6151["longname"]
    unless_null $P6152, vivify_2800
    new $P6152, "Undef"
  vivify_2800:
    concat $P6153, $P6150, $P6152
    concat $P6154, $P6153, "' not implemented"
    $P6155 = $P6149."panic"($P6154)
.annotate 'line', 2209
    set $P6139, $P6155
.annotate 'line', 2206
    goto if_6140_end
  if_6140:
.annotate 'line', 2207
    find_lex $P6145, "$/"
    unless_null $P6145, vivify_2801
    new $P6145, "Undef"
  vivify_2801:
    $P6146 = $P6145."CURSOR"()
    $P6147 = $P6146."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2206
    set $P6139, $P6147
  if_6140_end:
    set $P6094, $P6139
.annotate 'line', 2195
    goto if_6095_end
  if_6095:
    .const 'Sub' $P6101 = "560_1305640955.436" 
    capture_lex $P6101
    $P6138 = $P6101()
    set $P6094, $P6138
  if_6095_end:
    set $P6041, $P6094
.annotate 'line', 2182
    goto if_6042_end
  if_6042:
    .const 'Sub' $P6048 = "558_1305640955.436" 
    capture_lex $P6048
    $P6093 = $P6048()
    set $P6041, $P6093
  if_6042_end:
.annotate 'line', 2181
    .return ($P6041)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6100"  :anon :subid("560_1305640955.436") :outer("557_1305640955.436")
.annotate 'line', 2195
    .const 'Sub' $P6125 = "561_1305640955.436" 
    capture_lex $P6125
.annotate 'line', 2197
    new $P6102, "Undef"
    .lex "$cpast", $P6102
.annotate 'line', 2200
    new $P6103, "Undef"
    .lex "$name", $P6103
.annotate 'line', 2201
    new $P6104, "Undef"
    .lex "$package", $P6104
.annotate 'line', 2197
    find_lex $P6105, "$/"
    unless_null $P6105, vivify_2802
    $P6105 = root_new ['parrot';'Hash']
  vivify_2802:
    set $P6106, $P6105["circumfix"]
    unless_null $P6106, vivify_2803
    $P6106 = root_new ['parrot';'ResizablePMCArray']
  vivify_2803:
    set $P6107, $P6106[0]
    unless_null $P6107, vivify_2804
    new $P6107, "Undef"
  vivify_2804:
    $P6108 = $P6107."ast"()
    store_lex "$cpast", $P6108
.annotate 'line', 2199
    get_hll_global $P6110, "GLOBAL"
    nqp_get_package_through_who $P6111, $P6110, "PAST"
    get_who $P6112, $P6111
    set $P6113, $P6112["Val"]
    find_lex $P6114, "$cpast"
    unless_null $P6114, vivify_2805
    new $P6114, "Undef"
  vivify_2805:
    $P6115 = $P6113."ACCEPTS"($P6114)
    if $P6115, unless_6109_end
.annotate 'line', 2198
    find_lex $P6116, "$/"
    unless_null $P6116, vivify_2806
    new $P6116, "Undef"
  vivify_2806:
    $P6117 = $P6116."CURSOR"()
    $P6117."panic"("Trait 'parrot_vtable_handler' requires constant scalar argument")
  unless_6109_end:
.annotate 'line', 2200
    find_lex $P6118, "$cpast"
    unless_null $P6118, vivify_2807
    new $P6118, "Undef"
  vivify_2807:
    $P6119 = $P6118."value"()
    store_lex "$name", $P6119
.annotate 'line', 2201
    find_dynamic_lex $P6122, "$*PACKAGE"
    unless_null $P6122, vivify_2808
    get_hll_global $P6120, "GLOBAL"
    get_who $P6121, $P6120
    set $P6122, $P6121["$PACKAGE"]
    unless_null $P6122, vivify_2809
    die "Contextual $*PACKAGE not found"
  vivify_2809:
  vivify_2808:
    store_lex "$package", $P6122
.annotate 'line', 2202
    find_dynamic_lex $P6123, "$/"
    .const 'Sub' $P6125 = "561_1305640955.436" 
    newclosure $P6136, $P6125
    $P6137 = $P6123."!make"($P6136)
.annotate 'line', 2195
    .return ($P6137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6124"  :anon :subid("561_1305640955.436") :outer("560_1305640955.436")
    .param pmc param_6126
.annotate 'line', 2202
    .lex "$match", param_6126
.annotate 'line', 2203
    find_dynamic_lex $P6129, "$*SC"
    unless_null $P6129, vivify_2810
    get_hll_global $P6127, "GLOBAL"
    get_who $P6128, $P6127
    set $P6129, $P6128["$SC"]
    unless_null $P6129, vivify_2811
    die "Contextual $*SC not found"
  vivify_2811:
  vivify_2810:
    find_lex $P6130, "$package"
    unless_null $P6130, vivify_2812
    new $P6130, "Undef"
  vivify_2812:
    find_lex $P6131, "$name"
    unless_null $P6131, vivify_2813
    new $P6131, "Undef"
  vivify_2813:
    find_lex $P6132, "$match"
    unless_null $P6132, vivify_2814
    $P6132 = root_new ['parrot';'Hash']
  vivify_2814:
    set $P6133, $P6132["variable"]
    unless_null $P6133, vivify_2815
    new $P6133, "Undef"
  vivify_2815:
    set $S6134, $P6133
    $P6135 = $P6129."pkg_add_parrot_vtable_handler_mapping"($P6130, $P6131, $S6134)
.annotate 'line', 2202
    .return ($P6135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6047"  :anon :subid("558_1305640955.436") :outer("557_1305640955.436")
.annotate 'line', 2182
    .const 'Sub' $P6079 = "559_1305640955.436" 
    capture_lex $P6079
.annotate 'line', 2184
    new $P6049, "Undef"
    .lex "$cpast", $P6049
.annotate 'line', 2187
    new $P6050, "Undef"
    .lex "$name", $P6050
.annotate 'line', 2188
    new $P6051, "Undef"
    .lex "$package", $P6051
.annotate 'line', 2189
    new $P6052, "Undef"
    .lex "$is_dispatcher", $P6052
.annotate 'line', 2184
    find_lex $P6053, "$/"
    unless_null $P6053, vivify_2816
    $P6053 = root_new ['parrot';'Hash']
  vivify_2816:
    set $P6054, $P6053["circumfix"]
    unless_null $P6054, vivify_2817
    $P6054 = root_new ['parrot';'ResizablePMCArray']
  vivify_2817:
    set $P6055, $P6054[0]
    unless_null $P6055, vivify_2818
    new $P6055, "Undef"
  vivify_2818:
    $P6056 = $P6055."ast"()
    store_lex "$cpast", $P6056
.annotate 'line', 2186
    get_hll_global $P6058, "GLOBAL"
    nqp_get_package_through_who $P6059, $P6058, "PAST"
    get_who $P6060, $P6059
    set $P6061, $P6060["Val"]
    find_lex $P6062, "$cpast"
    unless_null $P6062, vivify_2819
    new $P6062, "Undef"
  vivify_2819:
    $P6063 = $P6061."ACCEPTS"($P6062)
    if $P6063, unless_6057_end
.annotate 'line', 2185
    find_lex $P6064, "$/"
    unless_null $P6064, vivify_2820
    new $P6064, "Undef"
  vivify_2820:
    $P6065 = $P6064."CURSOR"()
    $P6065."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_6057_end:
.annotate 'line', 2187
    find_lex $P6066, "$cpast"
    unless_null $P6066, vivify_2821
    new $P6066, "Undef"
  vivify_2821:
    $P6067 = $P6066."value"()
    store_lex "$name", $P6067
.annotate 'line', 2188
    find_dynamic_lex $P6070, "$*PACKAGE"
    unless_null $P6070, vivify_2822
    get_hll_global $P6068, "GLOBAL"
    get_who $P6069, $P6068
    set $P6070, $P6069["$PACKAGE"]
    unless_null $P6070, vivify_2823
    die "Contextual $*PACKAGE not found"
  vivify_2823:
  vivify_2822:
    store_lex "$package", $P6070
.annotate 'line', 2189
    find_dynamic_lex $P6073, "$*SCOPE"
    unless_null $P6073, vivify_2824
    get_hll_global $P6071, "GLOBAL"
    get_who $P6072, $P6071
    set $P6073, $P6072["$SCOPE"]
    unless_null $P6073, vivify_2825
    die "Contextual $*SCOPE not found"
  vivify_2825:
  vivify_2824:
    set $S6074, $P6073
    iseq $I6075, $S6074, "proto"
    new $P6076, 'Integer'
    set $P6076, $I6075
    store_lex "$is_dispatcher", $P6076
.annotate 'line', 2190
    find_dynamic_lex $P6077, "$/"
    .const 'Sub' $P6079 = "559_1305640955.436" 
    newclosure $P6091, $P6079
    $P6092 = $P6077."!make"($P6091)
.annotate 'line', 2182
    .return ($P6092)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6078"  :anon :subid("559_1305640955.436") :outer("558_1305640955.436")
    .param pmc param_6080
.annotate 'line', 2190
    .lex "$match", param_6080
.annotate 'line', 2191
    find_dynamic_lex $P6083, "$*SC"
    unless_null $P6083, vivify_2826
    get_hll_global $P6081, "GLOBAL"
    get_who $P6082, $P6081
    set $P6083, $P6082["$SC"]
    unless_null $P6083, vivify_2827
    die "Contextual $*SC not found"
  vivify_2827:
  vivify_2826:
    find_lex $P6084, "$package"
    unless_null $P6084, vivify_2828
    new $P6084, "Undef"
  vivify_2828:
    find_lex $P6085, "$name"
    unless_null $P6085, vivify_2829
    new $P6085, "Undef"
  vivify_2829:
.annotate 'line', 2192
    find_lex $P6086, "$match"
    unless_null $P6086, vivify_2830
    new $P6086, "Undef"
  vivify_2830:
    $P6087 = $P6086."ast"()
    set $P6088, $P6087["block_past"]
    unless_null $P6088, vivify_2831
    new $P6088, "Undef"
  vivify_2831:
.annotate 'line', 2191
    find_lex $P6089, "$is_dispatcher"
    unless_null $P6089, vivify_2832
    new $P6089, "Undef"
  vivify_2832:
    $P6090 = $P6083."pkg_add_method"($P6084, "add_parrot_vtable_mapping", $P6085, $P6088, $P6089)
.annotate 'line', 2190
    .return ($P6090)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator" :anon :subid("562_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6159
    .param pmc param_6160
    .param pmc param_6161 :optional
    .param int has_param_6161 :opt_flag
.annotate 'line', 2214
    .const 'Sub' $P6288 = "565_1305640955.436" 
    capture_lex $P6288
    .const 'Sub' $P6250 = "564_1305640955.436" 
    capture_lex $P6250
    .const 'Sub' $P6230 = "563_1305640955.436" 
    capture_lex $P6230
    new $P6158, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6158, control_6157
    push_eh $P6158
    .lex "self", param_6159
    .lex "$/", param_6160
    if has_param_6161, optparam_2833
    new $P6162, "Undef"
    set param_6161, $P6162
  optparam_2833:
    .lex "$key", param_6161
.annotate 'line', 2215
    $P6163 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P6163
.annotate 'line', 2216
    new $P6164, "Undef"
    .lex "$name", $P6164
.annotate 'line', 2217
    new $P6165, "Undef"
    .lex "$past", $P6165
.annotate 'line', 2215
    get_hll_global $P6166, "GLOBAL"
    nqp_get_package_through_who $P6167, $P6166, "Regex"
    nqp_get_package_through_who $P6168, $P6167, "P6Regex"
    nqp_get_package_through_who $P6169, $P6168, "Actions"
    get_who $P6170, $P6169
    set $P6171, $P6170["@MODIFIERS"]
    unless_null $P6171, vivify_2834
    $P6171 = root_new ['parrot';'ResizablePMCArray']
  vivify_2834:
    store_lex "@MODIFIERS", $P6171
.annotate 'line', 2216
    find_lex $P6172, "$/"
    unless_null $P6172, vivify_2835
    $P6172 = root_new ['parrot';'Hash']
  vivify_2835:
    set $P6173, $P6172["deflongname"]
    unless_null $P6173, vivify_2836
    new $P6173, "Undef"
  vivify_2836:
    $P6174 = $P6173."ast"()
    set $S6175, $P6174
    new $P6176, 'String'
    set $P6176, $S6175
    store_lex "$name", $P6176
    find_lex $P6177, "$past"
    unless_null $P6177, vivify_2837
    new $P6177, "Undef"
  vivify_2837:
.annotate 'line', 2218
    find_lex $P6179, "$/"
    unless_null $P6179, vivify_2838
    $P6179 = root_new ['parrot';'Hash']
  vivify_2838:
    set $P6180, $P6179["proto"]
    unless_null $P6180, vivify_2839
    new $P6180, "Undef"
  vivify_2839:
    if $P6180, if_6178
.annotate 'line', 2248
    find_lex $P6246, "$key"
    unless_null $P6246, vivify_2840
    new $P6246, "Undef"
  vivify_2840:
    set $S6247, $P6246
    iseq $I6248, $S6247, "open"
    if $I6248, if_6245
.annotate 'line', 2258
    .const 'Sub' $P6288 = "565_1305640955.436" 
    capture_lex $P6288
    $P6288()
    goto if_6245_end
  if_6245:
.annotate 'line', 2248
    .const 'Sub' $P6250 = "564_1305640955.436" 
    capture_lex $P6250
    $P6250()
  if_6245_end:
    goto if_6178_end
  if_6178:
.annotate 'line', 2220
    get_hll_global $P6181, "GLOBAL"
    nqp_get_package_through_who $P6182, $P6181, "PAST"
    get_who $P6183, $P6182
    set $P6184, $P6183["Stmts"]
.annotate 'line', 2221
    get_hll_global $P6185, "GLOBAL"
    nqp_get_package_through_who $P6186, $P6185, "PAST"
    get_who $P6187, $P6186
    set $P6188, $P6187["Block"]
    find_lex $P6189, "$name"
    unless_null $P6189, vivify_2890
    new $P6189, "Undef"
  vivify_2890:
.annotate 'line', 2222
    get_hll_global $P6190, "GLOBAL"
    nqp_get_package_through_who $P6191, $P6190, "PAST"
    get_who $P6192, $P6191
    set $P6193, $P6192["Op"]
.annotate 'line', 2223
    get_hll_global $P6194, "GLOBAL"
    nqp_get_package_through_who $P6195, $P6194, "PAST"
    get_who $P6196, $P6195
    set $P6197, $P6196["Var"]
    $P6198 = $P6197."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P6199, "$name"
    unless_null $P6199, vivify_2891
    new $P6199, "Undef"
  vivify_2891:
    $P6200 = $P6193."new"($P6198, $P6199, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2222
    find_lex $P6201, "$/"
    unless_null $P6201, vivify_2892
    new $P6201, "Undef"
  vivify_2892:
    $P6202 = $P6188."new"($P6200, $P6189 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P6201 :named("node"))
.annotate 'line', 2232
    get_hll_global $P6203, "GLOBAL"
    nqp_get_package_through_who $P6204, $P6203, "PAST"
    get_who $P6205, $P6204
    set $P6206, $P6205["Block"]
    new $P6207, "String"
    assign $P6207, "!PREFIX__"
    find_lex $P6208, "$name"
    unless_null $P6208, vivify_2893
    new $P6208, "Undef"
  vivify_2893:
    concat $P6209, $P6207, $P6208
.annotate 'line', 2233
    get_hll_global $P6210, "GLOBAL"
    nqp_get_package_through_who $P6211, $P6210, "PAST"
    get_who $P6212, $P6211
    set $P6213, $P6212["Op"]
.annotate 'line', 2234
    get_hll_global $P6214, "GLOBAL"
    nqp_get_package_through_who $P6215, $P6214, "PAST"
    get_who $P6216, $P6215
    set $P6217, $P6216["Var"]
    $P6218 = $P6217."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P6219, "$name"
    unless_null $P6219, vivify_2894
    new $P6219, "Undef"
  vivify_2894:
    $P6220 = $P6213."new"($P6218, $P6219, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2233
    find_lex $P6221, "$/"
    unless_null $P6221, vivify_2895
    new $P6221, "Undef"
  vivify_2895:
    $P6222 = $P6206."new"($P6220, $P6209 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P6221 :named("node"))
.annotate 'line', 2232
    $P6223 = $P6184."new"($P6202, $P6222)
.annotate 'line', 2220
    store_lex "$past", $P6223
.annotate 'line', 2244
    find_lex $P6225, "$past"
    unless_null $P6225, vivify_2896
    new $P6225, "Undef"
  vivify_2896:
    $P6226 = $P6225."list"()
    defined $I6227, $P6226
    unless $I6227, for_undef_2897
    iter $P6224, $P6226
    new $P6243, 'ExceptionHandler'
    set_label $P6243, loop6242_handler
    $P6243."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6243
  loop6242_test:
    unless $P6224, loop6242_done
    shift $P6228, $P6224
  loop6242_redo:
    .const 'Sub' $P6230 = "563_1305640955.436" 
    capture_lex $P6230
    $P6230($P6228)
  loop6242_next:
    goto loop6242_test
  loop6242_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6244, exception, 'type'
    eq $P6244, .CONTROL_LOOP_NEXT, loop6242_next
    eq $P6244, .CONTROL_LOOP_REDO, loop6242_redo
  loop6242_done:
    pop_eh 
  for_undef_2897:
  if_6178_end:
.annotate 'line', 2289
    find_lex $P6381, "$/"
    find_lex $P6382, "$past"
    unless_null $P6382, vivify_2904
    new $P6382, "Undef"
  vivify_2904:
    $P6383 = $P6381."!make"($P6382)
.annotate 'line', 2214
    .return ($P6383)
  control_6157:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6384, exception, "payload"
    .return ($P6384)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6287"  :anon :subid("565_1305640955.436") :outer("562_1305640955.436")
.annotate 'line', 2258
    .const 'Sub' $P6320 = "566_1305640955.436" 
    capture_lex $P6320
.annotate 'line', 2259
    new $P6289, "Undef"
    .lex "$regex", $P6289
.annotate 'line', 2262
    new $P6290, "Undef"
    .lex "$prefix_meth", $P6290
.annotate 'line', 2260
    get_hll_global $P6291, "GLOBAL"
    nqp_get_package_through_who $P6292, $P6291, "Regex"
    nqp_get_package_through_who $P6293, $P6292, "P6Regex"
    nqp_get_package_through_who $P6294, $P6293, "Actions"
    get_who $P6295, $P6294
    set $P6296, $P6295["buildsub"]
    find_lex $P6297, "$/"
    unless_null $P6297, vivify_2841
    $P6297 = root_new ['parrot';'Hash']
  vivify_2841:
    set $P6298, $P6297["p6regex"]
    unless_null $P6298, vivify_2842
    new $P6298, "Undef"
  vivify_2842:
    $P6299 = $P6298."ast"()
    find_lex $P6300, "$?PACKAGE"
    get_who $P6301, $P6300
    set $P6302, $P6301["@BLOCK"]
    unless_null $P6302, vivify_2843
    $P6302 = root_new ['parrot';'ResizablePMCArray']
  vivify_2843:
    $P6303 = $P6302."shift"()
    $P6304 = $P6296($P6299, $P6303)
    store_lex "$regex", $P6304
.annotate 'line', 2261
    find_lex $P6305, "$regex"
    unless_null $P6305, vivify_2844
    new $P6305, "Undef"
  vivify_2844:
    find_lex $P6306, "$name"
    unless_null $P6306, vivify_2845
    new $P6306, "Undef"
  vivify_2845:
    $P6305."name"($P6306)
    find_lex $P6307, "$prefix_meth"
    unless_null $P6307, vivify_2846
    new $P6307, "Undef"
  vivify_2846:
.annotate 'line', 2264
    find_dynamic_lex $P6313, "$*PKGDECL"
    unless_null $P6313, vivify_2847
    get_hll_global $P6311, "GLOBAL"
    get_who $P6312, $P6311
    set $P6313, $P6312["$PKGDECL"]
    unless_null $P6313, vivify_2848
    die "Contextual $*PKGDECL not found"
  vivify_2848:
  vivify_2847:
    if $P6313, if_6310
    set $P6309, $P6313
    goto if_6310_end
  if_6310:
    find_dynamic_lex $P6316, "$*PACKAGE"
    unless_null $P6316, vivify_2849
    get_hll_global $P6314, "GLOBAL"
    get_who $P6315, $P6314
    set $P6316, $P6315["$PACKAGE"]
    unless_null $P6316, vivify_2850
    die "Contextual $*PACKAGE not found"
  vivify_2850:
  vivify_2849:
    get_how $P6317, $P6316
    can $I6318, $P6317, "add_method"
    new $P6309, 'Integer'
    set $P6309, $I6318
  if_6310_end:
    unless $P6309, if_6308_end
    .const 'Sub' $P6320 = "566_1305640955.436" 
    capture_lex $P6320
    $P6320()
  if_6308_end:
.annotate 'line', 2279
    get_hll_global $P6358, "GLOBAL"
    nqp_get_package_through_who $P6359, $P6358, "PAST"
    get_who $P6360, $P6359
    set $P6361, $P6360["Op"]
.annotate 'line', 2281
    new $P6362, "ResizablePMCArray"
    push $P6362, "Regex"
    push $P6362, "Method"
    find_lex $P6363, "$/"
    unless_null $P6363, vivify_2867
    new $P6363, "Undef"
  vivify_2867:
    $P6364 = "lexical_package_lookup"($P6362, $P6363)
    find_lex $P6365, "$regex"
    unless_null $P6365, vivify_2868
    new $P6365, "Undef"
  vivify_2868:
    $P6366 = $P6361."new"($P6364, $P6365, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2279
    store_lex "$past", $P6366
.annotate 'line', 2284
    find_lex $P6369, "$prefix_meth"
    unless_null $P6369, vivify_2869
    new $P6369, "Undef"
  vivify_2869:
    if $P6369, if_6368
    find_lex $P6377, "$regex"
    unless_null $P6377, vivify_2870
    new $P6377, "Undef"
  vivify_2870:
    set $P6367, $P6377
    goto if_6368_end
  if_6368:
.annotate 'line', 2285
    get_hll_global $P6370, "GLOBAL"
    nqp_get_package_through_who $P6371, $P6370, "PAST"
    get_who $P6372, $P6371
    set $P6373, $P6372["Stmts"]
    find_lex $P6374, "$regex"
    unless_null $P6374, vivify_2871
    new $P6374, "Undef"
  vivify_2871:
    find_lex $P6375, "$prefix_meth"
    unless_null $P6375, vivify_2872
    new $P6375, "Undef"
  vivify_2872:
    $P6376 = $P6373."new"($P6374, $P6375)
    set $P6367, $P6376
  if_6368_end:
.annotate 'line', 2284
    find_lex $P6378, "$past"
    unless_null $P6378, vivify_2873
    $P6378 = root_new ['parrot';'Hash']
    store_lex "$past", $P6378
  vivify_2873:
    set $P6378["sink"], $P6367
.annotate 'line', 2287
    find_lex $P6379, "@MODIFIERS"
    unless_null $P6379, vivify_2874
    $P6379 = root_new ['parrot';'ResizablePMCArray']
  vivify_2874:
    $P6380 = $P6379."shift"()
.annotate 'line', 2258
    .return ($P6380)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6319"  :anon :subid("566_1305640955.436") :outer("565_1305640955.436")
.annotate 'line', 2269
    $P6321 = root_new ['parrot';'ResizablePMCArray']
    .lex "@prefixes", $P6321
.annotate 'line', 2266
    find_dynamic_lex $P6324, "$*SC"
    unless_null $P6324, vivify_2851
    get_hll_global $P6322, "GLOBAL"
    get_who $P6323, $P6322
    set $P6324, $P6323["$SC"]
    unless_null $P6324, vivify_2852
    die "Contextual $*SC not found"
  vivify_2852:
  vivify_2851:
    find_dynamic_lex $P6327, "$*PACKAGE"
    unless_null $P6327, vivify_2853
    get_hll_global $P6325, "GLOBAL"
    get_who $P6326, $P6325
    set $P6327, $P6326["$PACKAGE"]
    unless_null $P6327, vivify_2854
    die "Contextual $*PACKAGE not found"
  vivify_2854:
  vivify_2853:
    find_lex $P6328, "$name"
    unless_null $P6328, vivify_2855
    new $P6328, "Undef"
  vivify_2855:
    find_lex $P6329, "$regex"
    unless_null $P6329, vivify_2856
    new $P6329, "Undef"
  vivify_2856:
    $P6324."pkg_add_method"($P6327, "add_method", $P6328, $P6329, 0)
.annotate 'line', 2269
    find_lex $P6330, "$/"
    unless_null $P6330, vivify_2857
    $P6330 = root_new ['parrot';'Hash']
  vivify_2857:
    set $P6331, $P6330["p6regex"]
    unless_null $P6331, vivify_2858
    new $P6331, "Undef"
  vivify_2858:
    $P6332 = $P6331."ast"()
    $P6333 = $P6332."prefix_list"()
    store_lex "@prefixes", $P6333
.annotate 'line', 2270
    get_hll_global $P6334, "GLOBAL"
    nqp_get_package_through_who $P6335, $P6334, "PAST"
    get_who $P6336, $P6335
    set $P6337, $P6336["Block"]
.annotate 'line', 2271
    new $P6338, "String"
    assign $P6338, "!PREFIX__"
    find_lex $P6339, "$name"
    unless_null $P6339, vivify_2859
    new $P6339, "Undef"
  vivify_2859:
    concat $P6340, $P6338, $P6339
.annotate 'line', 2272
    get_hll_global $P6341, "GLOBAL"
    nqp_get_package_through_who $P6342, $P6341, "PAST"
    get_who $P6343, $P6342
    set $P6344, $P6343["Op"]
    find_lex $P6345, "@prefixes"
    unless_null $P6345, vivify_2860
    $P6345 = root_new ['parrot';'ResizablePMCArray']
  vivify_2860:
    $P6346 = $P6344."new"($P6345 :flat, "list" :named("pasttype"))
    $P6347 = $P6337."new"($P6346, $P6340 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2270
    store_lex "$prefix_meth", $P6347
.annotate 'line', 2274
    find_dynamic_lex $P6350, "$*SC"
    unless_null $P6350, vivify_2861
    get_hll_global $P6348, "GLOBAL"
    get_who $P6349, $P6348
    set $P6350, $P6349["$SC"]
    unless_null $P6350, vivify_2862
    die "Contextual $*SC not found"
  vivify_2862:
  vivify_2861:
    find_dynamic_lex $P6353, "$*PACKAGE"
    unless_null $P6353, vivify_2863
    get_hll_global $P6351, "GLOBAL"
    get_who $P6352, $P6351
    set $P6353, $P6352["$PACKAGE"]
    unless_null $P6353, vivify_2864
    die "Contextual $*PACKAGE not found"
  vivify_2864:
  vivify_2863:
    find_lex $P6354, "$prefix_meth"
    unless_null $P6354, vivify_2865
    new $P6354, "Undef"
  vivify_2865:
    $P6355 = $P6354."name"()
    find_lex $P6356, "$prefix_meth"
    unless_null $P6356, vivify_2866
    new $P6356, "Undef"
  vivify_2866:
    $P6357 = $P6350."pkg_add_method"($P6353, "add_method", $P6355, $P6356, 0)
.annotate 'line', 2264
    .return ($P6357)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6249"  :anon :subid("564_1305640955.436") :outer("562_1305640955.436")
.annotate 'line', 2249
    $P6251 = root_new ['parrot';'Hash']
    .lex "%h", $P6251
.annotate 'line', 2248
    find_lex $P6252, "%h"
    unless_null $P6252, vivify_2875
    $P6252 = root_new ['parrot';'Hash']
  vivify_2875:
.annotate 'line', 2250
    find_lex $P6254, "$/"
    unless_null $P6254, vivify_2876
    $P6254 = root_new ['parrot';'Hash']
  vivify_2876:
    set $P6255, $P6254["sym"]
    unless_null $P6255, vivify_2877
    new $P6255, "Undef"
  vivify_2877:
    set $S6256, $P6255
    iseq $I6257, $S6256, "token"
    unless $I6257, if_6253_end
    new $P6258, "Integer"
    assign $P6258, 1
    find_lex $P6259, "%h"
    unless_null $P6259, vivify_2878
    $P6259 = root_new ['parrot';'Hash']
    store_lex "%h", $P6259
  vivify_2878:
    set $P6259["r"], $P6258
  if_6253_end:
.annotate 'line', 2251
    find_lex $P6261, "$/"
    unless_null $P6261, vivify_2879
    $P6261 = root_new ['parrot';'Hash']
  vivify_2879:
    set $P6262, $P6261["sym"]
    unless_null $P6262, vivify_2880
    new $P6262, "Undef"
  vivify_2880:
    set $S6263, $P6262
    iseq $I6264, $S6263, "rule"
    unless $I6264, if_6260_end
    new $P6265, "Integer"
    assign $P6265, 1
    find_lex $P6266, "%h"
    unless_null $P6266, vivify_2881
    $P6266 = root_new ['parrot';'Hash']
    store_lex "%h", $P6266
  vivify_2881:
    set $P6266["r"], $P6265
    new $P6267, "Integer"
    assign $P6267, 1
    find_lex $P6268, "%h"
    unless_null $P6268, vivify_2882
    $P6268 = root_new ['parrot';'Hash']
    store_lex "%h", $P6268
  vivify_2882:
    set $P6268["s"], $P6267
  if_6260_end:
.annotate 'line', 2252
    find_lex $P6269, "@MODIFIERS"
    unless_null $P6269, vivify_2883
    $P6269 = root_new ['parrot';'ResizablePMCArray']
  vivify_2883:
    find_lex $P6270, "%h"
    unless_null $P6270, vivify_2884
    $P6270 = root_new ['parrot';'Hash']
  vivify_2884:
    $P6269."unshift"($P6270)
.annotate 'line', 2253
    find_lex $P6271, "$name"
    unless_null $P6271, vivify_2885
    new $P6271, "Undef"
  vivify_2885:
    get_hll_global $P6272, "GLOBAL"
    nqp_get_package_through_who $P6273, $P6272, "Regex"
    nqp_get_package_through_who $P6274, $P6273, "P6Regex"
    nqp_get_package_through_who $P6275, $P6274, "Actions"
    get_who $P6276, $P6275
    set $P6276["$REGEXNAME"], $P6271
.annotate 'line', 2254
    find_lex $P6277, "$?PACKAGE"
    get_who $P6278, $P6277
    set $P6279, $P6278["@BLOCK"]
    unless_null $P6279, vivify_2886
    $P6279 = root_new ['parrot';'ResizablePMCArray']
  vivify_2886:
    set $P6280, $P6279[0]
    unless_null $P6280, vivify_2887
    new $P6280, "Undef"
  vivify_2887:
    $P6280."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2255
    find_lex $P6281, "$?PACKAGE"
    get_who $P6282, $P6281
    set $P6283, $P6282["@BLOCK"]
    unless_null $P6283, vivify_2888
    $P6283 = root_new ['parrot';'ResizablePMCArray']
  vivify_2888:
    set $P6284, $P6283[0]
    unless_null $P6284, vivify_2889
    new $P6284, "Undef"
  vivify_2889:
    $P6284."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2256
    new $P6285, "Exception"
    set $P6285['type'], .CONTROL_RETURN
    new $P6286, "Integer"
    assign $P6286, 0
    setattribute $P6285, 'payload', $P6286
    throw $P6285
.annotate 'line', 2248
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6229"  :anon :subid("563_1305640955.436") :outer("562_1305640955.436")
    .param pmc param_6231
.annotate 'line', 2244
    .lex "$_", param_6231
.annotate 'line', 2245
    find_dynamic_lex $P6234, "$*SC"
    unless_null $P6234, vivify_2898
    get_hll_global $P6232, "GLOBAL"
    get_who $P6233, $P6232
    set $P6234, $P6233["$SC"]
    unless_null $P6234, vivify_2899
    die "Contextual $*SC not found"
  vivify_2899:
  vivify_2898:
    find_dynamic_lex $P6237, "$*PACKAGE"
    unless_null $P6237, vivify_2900
    get_hll_global $P6235, "GLOBAL"
    get_who $P6236, $P6235
    set $P6237, $P6236["$PACKAGE"]
    unless_null $P6237, vivify_2901
    die "Contextual $*PACKAGE not found"
  vivify_2901:
  vivify_2900:
    find_lex $P6238, "$_"
    unless_null $P6238, vivify_2902
    new $P6238, "Undef"
  vivify_2902:
    $P6239 = $P6238."name"()
    find_lex $P6240, "$_"
    unless_null $P6240, vivify_2903
    new $P6240, "Undef"
  vivify_2903:
    $P6241 = $P6234."pkg_add_method"($P6237, "add_method", $P6239, $P6240, 0)
.annotate 'line', 2244
    .return ($P6241)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty" :anon :subid("567_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6386
    .param pmc param_6387
.annotate 'line', 2293
    .lex "self", param_6386
    .lex "$/", param_6387
.annotate 'line', 2294
    new $P6388, "Undef"
    .lex "$past", $P6388
    find_lex $P6391, "$/"
    unless_null $P6391, vivify_2905
    $P6391 = root_new ['parrot';'Hash']
  vivify_2905:
    set $P6392, $P6391["args"]
    unless_null $P6392, vivify_2906
    new $P6392, "Undef"
  vivify_2906:
    if $P6392, if_6390
    get_hll_global $P6397, "GLOBAL"
    nqp_get_package_through_who $P6398, $P6397, "PAST"
    get_who $P6399, $P6398
    set $P6400, $P6399["Op"]
    find_lex $P6401, "$/"
    unless_null $P6401, vivify_2907
    new $P6401, "Undef"
  vivify_2907:
    $P6402 = $P6400."new"($P6401 :named("node"))
    set $P6389, $P6402
    goto if_6390_end
  if_6390:
    find_lex $P6393, "$/"
    unless_null $P6393, vivify_2908
    $P6393 = root_new ['parrot';'Hash']
  vivify_2908:
    set $P6394, $P6393["args"]
    unless_null $P6394, vivify_2909
    $P6394 = root_new ['parrot';'ResizablePMCArray']
  vivify_2909:
    set $P6395, $P6394[0]
    unless_null $P6395, vivify_2910
    new $P6395, "Undef"
  vivify_2910:
    $P6396 = $P6395."ast"()
    set $P6389, $P6396
  if_6390_end:
    store_lex "$past", $P6389
.annotate 'line', 2295
    find_lex $P6404, "$/"
    unless_null $P6404, vivify_2911
    $P6404 = root_new ['parrot';'Hash']
  vivify_2911:
    set $P6405, $P6404["quote"]
    unless_null $P6405, vivify_2912
    new $P6405, "Undef"
  vivify_2912:
    if $P6405, if_6403
.annotate 'line', 2299
    find_lex $P6412, "$/"
    unless_null $P6412, vivify_2913
    $P6412 = root_new ['parrot';'Hash']
  vivify_2913:
    set $P6413, $P6412["longname"]
    unless_null $P6413, vivify_2914
    new $P6413, "Undef"
  vivify_2914:
    set $S6414, $P6413
    iseq $I6415, $S6414, "HOW"
    if $I6415, if_6411
.annotate 'line', 2302
    find_lex $P6418, "$/"
    unless_null $P6418, vivify_2915
    $P6418 = root_new ['parrot';'Hash']
  vivify_2915:
    set $P6419, $P6418["longname"]
    unless_null $P6419, vivify_2916
    new $P6419, "Undef"
  vivify_2916:
    set $S6420, $P6419
    iseq $I6421, $S6420, "WHAT"
    if $I6421, if_6417
.annotate 'line', 2305
    find_lex $P6424, "$/"
    unless_null $P6424, vivify_2917
    $P6424 = root_new ['parrot';'Hash']
  vivify_2917:
    set $P6425, $P6424["longname"]
    unless_null $P6425, vivify_2918
    new $P6425, "Undef"
  vivify_2918:
    set $S6426, $P6425
    iseq $I6427, $S6426, "WHO"
    if $I6427, if_6423
.annotate 'line', 2309
    find_lex $P6429, "$past"
    unless_null $P6429, vivify_2919
    new $P6429, "Undef"
  vivify_2919:
    find_lex $P6430, "$/"
    unless_null $P6430, vivify_2920
    $P6430 = root_new ['parrot';'Hash']
  vivify_2920:
    set $P6431, $P6430["longname"]
    unless_null $P6431, vivify_2921
    new $P6431, "Undef"
  vivify_2921:
    set $S6432, $P6431
    $P6429."name"($S6432)
.annotate 'line', 2310
    find_lex $P6433, "$past"
    unless_null $P6433, vivify_2922
    new $P6433, "Undef"
  vivify_2922:
    $P6433."pasttype"("callmethod")
.annotate 'line', 2308
    goto if_6423_end
  if_6423:
.annotate 'line', 2306
    find_lex $P6428, "$past"
    unless_null $P6428, vivify_2923
    new $P6428, "Undef"
  vivify_2923:
    $P6428."pirop"("get_who PP")
  if_6423_end:
.annotate 'line', 2305
    goto if_6417_end
  if_6417:
.annotate 'line', 2303
    find_lex $P6422, "$past"
    unless_null $P6422, vivify_2924
    new $P6422, "Undef"
  vivify_2924:
    $P6422."pirop"("get_what PP")
  if_6417_end:
.annotate 'line', 2302
    goto if_6411_end
  if_6411:
.annotate 'line', 2300
    find_lex $P6416, "$past"
    unless_null $P6416, vivify_2925
    new $P6416, "Undef"
  vivify_2925:
    $P6416."pirop"("get_how PP")
  if_6411_end:
.annotate 'line', 2299
    goto if_6403_end
  if_6403:
.annotate 'line', 2296
    find_lex $P6406, "$past"
    unless_null $P6406, vivify_2926
    new $P6406, "Undef"
  vivify_2926:
    find_lex $P6407, "$/"
    unless_null $P6407, vivify_2927
    $P6407 = root_new ['parrot';'Hash']
  vivify_2927:
    set $P6408, $P6407["quote"]
    unless_null $P6408, vivify_2928
    new $P6408, "Undef"
  vivify_2928:
    $P6409 = $P6408."ast"()
    $P6406."name"($P6409)
.annotate 'line', 2297
    find_lex $P6410, "$past"
    unless_null $P6410, vivify_2929
    new $P6410, "Undef"
  vivify_2929:
    $P6410."pasttype"("callmethod")
  if_6403_end:
.annotate 'line', 2312
    find_lex $P6434, "$/"
    find_lex $P6435, "$past"
    unless_null $P6435, vivify_2930
    new $P6435, "Undef"
  vivify_2930:
    $P6436 = $P6434."!make"($P6435)
.annotate 'line', 2293
    .return ($P6436)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>" :anon :subid("568_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6438
    .param pmc param_6439
.annotate 'line', 2317
    .lex "self", param_6438
    .lex "$/", param_6439
.annotate 'line', 2318
    find_lex $P6440, "$/"
    get_hll_global $P6441, "GLOBAL"
    nqp_get_package_through_who $P6442, $P6441, "PAST"
    get_who $P6443, $P6442
    set $P6444, $P6443["Var"]
    $P6445 = $P6444."new"("self" :named("name"))
    $P6446 = $P6440."!make"($P6445)
.annotate 'line', 2317
    .return ($P6446)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>" :anon :subid("569_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6448
    .param pmc param_6449
.annotate 'line', 2321
    .lex "self", param_6448
    .lex "$/", param_6449
.annotate 'line', 2322
    new $P6450, "Undef"
    .lex "$past", $P6450
    find_lex $P6451, "$/"
    unless_null $P6451, vivify_2931
    $P6451 = root_new ['parrot';'Hash']
  vivify_2931:
    set $P6452, $P6451["args"]
    unless_null $P6452, vivify_2932
    new $P6452, "Undef"
  vivify_2932:
    $P6453 = $P6452."ast"()
    store_lex "$past", $P6453
.annotate 'line', 2323
    find_lex $P6454, "$past"
    unless_null $P6454, vivify_2933
    new $P6454, "Undef"
  vivify_2933:
    find_lex $P6455, "$/"
    unless_null $P6455, vivify_2934
    $P6455 = root_new ['parrot';'Hash']
  vivify_2934:
    set $P6456, $P6455["deflongname"]
    unless_null $P6456, vivify_2935
    new $P6456, "Undef"
  vivify_2935:
    set $S6457, $P6456
    $P6454."name"($S6457)
.annotate 'line', 2324
    find_lex $P6458, "$/"
    find_lex $P6459, "$past"
    unless_null $P6459, vivify_2936
    new $P6459, "Undef"
  vivify_2936:
    $P6460 = $P6458."!make"($P6459)
.annotate 'line', 2321
    .return ($P6460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>" :anon :subid("570_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6462
    .param pmc param_6463
.annotate 'line', 2327
    .const 'Sub' $P6481 = "571_1305640955.436" 
    capture_lex $P6481
    .lex "self", param_6462
    .lex "$/", param_6463
.annotate 'line', 2329
    new $P6464, "Undef"
    .lex "$var", $P6464
.annotate 'line', 2339
    new $P6465, "Undef"
    .lex "$past", $P6465
.annotate 'line', 2327
    find_lex $P6466, "$var"
    unless_null $P6466, vivify_2937
    new $P6466, "Undef"
  vivify_2937:
.annotate 'line', 2330
    find_lex $P6468, "$/"
    unless_null $P6468, vivify_2938
    $P6468 = root_new ['parrot';'Hash']
  vivify_2938:
    set $P6469, $P6468["name"]
    unless_null $P6469, vivify_2939
    new $P6469, "Undef"
  vivify_2939:
    set $S6470, $P6469
    $P6471 = "is_lexical"($S6470)
    if $P6471, if_6467
.annotate 'line', 2333
    .const 'Sub' $P6481 = "571_1305640955.436" 
    capture_lex $P6481
    $P6481()
    goto if_6467_end
  if_6467:
.annotate 'line', 2331
    get_hll_global $P6472, "GLOBAL"
    nqp_get_package_through_who $P6473, $P6472, "PAST"
    get_who $P6474, $P6473
    set $P6475, $P6474["Var"]
    find_lex $P6476, "$/"
    unless_null $P6476, vivify_2945
    $P6476 = root_new ['parrot';'Hash']
  vivify_2945:
    set $P6477, $P6476["name"]
    unless_null $P6477, vivify_2946
    new $P6477, "Undef"
  vivify_2946:
    set $S6478, $P6477
    $P6479 = $P6475."new"($S6478 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6479
  if_6467_end:
.annotate 'line', 2339
    find_lex $P6490, "$var"
    unless_null $P6490, vivify_2947
    new $P6490, "Undef"
  vivify_2947:
    store_lex "$past", $P6490
.annotate 'line', 2340
    find_lex $P6492, "$/"
    unless_null $P6492, vivify_2948
    $P6492 = root_new ['parrot';'Hash']
  vivify_2948:
    set $P6493, $P6492["args"]
    unless_null $P6493, vivify_2949
    new $P6493, "Undef"
  vivify_2949:
    unless $P6493, if_6491_end
.annotate 'line', 2341
    find_lex $P6494, "$/"
    unless_null $P6494, vivify_2950
    $P6494 = root_new ['parrot';'Hash']
  vivify_2950:
    set $P6495, $P6494["args"]
    unless_null $P6495, vivify_2951
    $P6495 = root_new ['parrot';'ResizablePMCArray']
  vivify_2951:
    set $P6496, $P6495[0]
    unless_null $P6496, vivify_2952
    new $P6496, "Undef"
  vivify_2952:
    $P6497 = $P6496."ast"()
    store_lex "$past", $P6497
.annotate 'line', 2342
    find_lex $P6498, "$past"
    unless_null $P6498, vivify_2953
    new $P6498, "Undef"
  vivify_2953:
    find_lex $P6499, "$var"
    unless_null $P6499, vivify_2954
    new $P6499, "Undef"
  vivify_2954:
    $P6498."unshift"($P6499)
  if_6491_end:
.annotate 'line', 2344
    find_lex $P6500, "$/"
    find_lex $P6501, "$past"
    unless_null $P6501, vivify_2955
    new $P6501, "Undef"
  vivify_2955:
    $P6502 = $P6500."!make"($P6501)
.annotate 'line', 2327
    .return ($P6502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6480"  :anon :subid("571_1305640955.436") :outer("570_1305640955.436")
.annotate 'line', 2334
    $P6482 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6482
    find_lex $P6483, "$/"
    unless_null $P6483, vivify_2940
    $P6483 = root_new ['parrot';'Hash']
  vivify_2940:
    set $P6484, $P6483["name"]
    unless_null $P6484, vivify_2941
    $P6484 = root_new ['parrot';'Hash']
  vivify_2941:
    set $P6485, $P6484["identifier"]
    unless_null $P6485, vivify_2942
    new $P6485, "Undef"
  vivify_2942:
    clone $P6486, $P6485
    store_lex "@ns", $P6486
.annotate 'line', 2335
    find_lex $P6487, "@ns"
    unless_null $P6487, vivify_2943
    $P6487 = root_new ['parrot';'ResizablePMCArray']
  vivify_2943:
    find_lex $P6488, "$/"
    unless_null $P6488, vivify_2944
    new $P6488, "Undef"
  vivify_2944:
    $P6489 = "lexical_package_lookup"($P6487, $P6488)
    store_lex "$var", $P6489
.annotate 'line', 2333
    .return ($P6489)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>" :anon :subid("572_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6504
    .param pmc param_6505
.annotate 'line', 2347
    .lex "self", param_6504
    .lex "$/", param_6505
.annotate 'line', 2348
    new $P6506, "Undef"
    .lex "$past", $P6506
.annotate 'line', 2349
    new $P6507, "Undef"
    .lex "$pirop", $P6507
.annotate 'line', 2348
    find_lex $P6510, "$/"
    unless_null $P6510, vivify_2956
    $P6510 = root_new ['parrot';'Hash']
  vivify_2956:
    set $P6511, $P6510["args"]
    unless_null $P6511, vivify_2957
    new $P6511, "Undef"
  vivify_2957:
    if $P6511, if_6509
    get_hll_global $P6516, "GLOBAL"
    nqp_get_package_through_who $P6517, $P6516, "PAST"
    get_who $P6518, $P6517
    set $P6519, $P6518["Op"]
    find_lex $P6520, "$/"
    unless_null $P6520, vivify_2958
    new $P6520, "Undef"
  vivify_2958:
    $P6521 = $P6519."new"($P6520 :named("node"))
    set $P6508, $P6521
    goto if_6509_end
  if_6509:
    find_lex $P6512, "$/"
    unless_null $P6512, vivify_2959
    $P6512 = root_new ['parrot';'Hash']
  vivify_2959:
    set $P6513, $P6512["args"]
    unless_null $P6513, vivify_2960
    $P6513 = root_new ['parrot';'ResizablePMCArray']
  vivify_2960:
    set $P6514, $P6513[0]
    unless_null $P6514, vivify_2961
    new $P6514, "Undef"
  vivify_2961:
    $P6515 = $P6514."ast"()
    set $P6508, $P6515
  if_6509_end:
    store_lex "$past", $P6508
.annotate 'line', 2349
    find_lex $P6522, "$/"
    unless_null $P6522, vivify_2962
    $P6522 = root_new ['parrot';'Hash']
  vivify_2962:
    set $P6523, $P6522["op"]
    unless_null $P6523, vivify_2963
    new $P6523, "Undef"
  vivify_2963:
    set $S6524, $P6523
    new $P6525, 'String'
    set $P6525, $S6524
    store_lex "$pirop", $P6525
.annotate 'line', 2350
    find_lex $P6526, "$pirop"
    unless_null $P6526, vivify_2964
    new $P6526, "Undef"
  vivify_2964:
    set $S6527, $P6526
    split $P6528, "__", $S6527
    join $S6529, " ", $P6528
    new $P6530, 'String'
    set $P6530, $S6529
    store_lex "$pirop", $P6530
.annotate 'line', 2351
    find_lex $P6531, "$past"
    unless_null $P6531, vivify_2965
    new $P6531, "Undef"
  vivify_2965:
    find_lex $P6532, "$pirop"
    unless_null $P6532, vivify_2966
    new $P6532, "Undef"
  vivify_2966:
    $P6531."pirop"($P6532)
.annotate 'line', 2352
    find_lex $P6533, "$past"
    unless_null $P6533, vivify_2967
    new $P6533, "Undef"
  vivify_2967:
    $P6533."pasttype"("pirop")
.annotate 'line', 2353
    find_lex $P6534, "$/"
    find_lex $P6535, "$past"
    unless_null $P6535, vivify_2968
    new $P6535, "Undef"
  vivify_2968:
    $P6536 = $P6534."!make"($P6535)
.annotate 'line', 2347
    .return ($P6536)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>" :anon :subid("573_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6538
    .param pmc param_6539
.annotate 'line', 2356
    .lex "self", param_6538
    .lex "$/", param_6539
.annotate 'line', 2357
    find_lex $P6540, "$/"
    get_hll_global $P6541, "GLOBAL"
    nqp_get_package_through_who $P6542, $P6541, "PAST"
    get_who $P6543, $P6542
    set $P6544, $P6543["Op"]
    $P6545 = $P6544."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6546 = $P6540."!make"($P6545)
.annotate 'line', 2356
    .return ($P6546)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args" :anon :subid("574_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6548
    .param pmc param_6549
.annotate 'line', 2362
    .lex "self", param_6548
    .lex "$/", param_6549
    find_lex $P6550, "$/"
    find_lex $P6551, "$/"
    unless_null $P6551, vivify_2969
    $P6551 = root_new ['parrot';'Hash']
  vivify_2969:
    set $P6552, $P6551["arglist"]
    unless_null $P6552, vivify_2970
    new $P6552, "Undef"
  vivify_2970:
    $P6553 = $P6552."ast"()
    $P6554 = $P6550."!make"($P6553)
    .return ($P6554)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist" :anon :subid("575_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6556
    .param pmc param_6557
.annotate 'line', 2364
    .const 'Sub' $P6571 = "576_1305640955.436" 
    capture_lex $P6571
    .lex "self", param_6556
    .lex "$/", param_6557
.annotate 'line', 2365
    new $P6558, "Undef"
    .lex "$past", $P6558
.annotate 'line', 2373
    new $P6559, "Undef"
    .lex "$i", $P6559
.annotate 'line', 2374
    new $P6560, "Undef"
    .lex "$n", $P6560
.annotate 'line', 2365
    get_hll_global $P6561, "GLOBAL"
    nqp_get_package_through_who $P6562, $P6561, "PAST"
    get_who $P6563, $P6562
    set $P6564, $P6563["Op"]
    find_lex $P6565, "$/"
    unless_null $P6565, vivify_2971
    new $P6565, "Undef"
  vivify_2971:
    $P6566 = $P6564."new"("call" :named("pasttype"), $P6565 :named("node"))
    store_lex "$past", $P6566
.annotate 'line', 2366
    find_lex $P6568, "$/"
    unless_null $P6568, vivify_2972
    $P6568 = root_new ['parrot';'Hash']
  vivify_2972:
    set $P6569, $P6568["EXPR"]
    unless_null $P6569, vivify_2973
    new $P6569, "Undef"
  vivify_2973:
    unless $P6569, if_6567_end
    .const 'Sub' $P6571 = "576_1305640955.436" 
    capture_lex $P6571
    $P6571()
  if_6567_end:
.annotate 'line', 2373
    new $P6603, "Integer"
    assign $P6603, 0
    store_lex "$i", $P6603
.annotate 'line', 2374
    find_lex $P6604, "$past"
    unless_null $P6604, vivify_2984
    new $P6604, "Undef"
  vivify_2984:
    $P6605 = $P6604."list"()
    set $N6606, $P6605
    new $P6607, 'Float'
    set $P6607, $N6606
    store_lex "$n", $P6607
.annotate 'line', 2375
    new $P6658, 'ExceptionHandler'
    set_label $P6658, loop6657_handler
    $P6658."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6658
  loop6657_test:
    find_lex $P6608, "$i"
    unless_null $P6608, vivify_2985
    new $P6608, "Undef"
  vivify_2985:
    set $N6609, $P6608
    find_lex $P6610, "$n"
    unless_null $P6610, vivify_2986
    new $P6610, "Undef"
  vivify_2986:
    set $N6611, $P6610
    islt $I6612, $N6609, $N6611
    unless $I6612, loop6657_done
  loop6657_redo:
.annotate 'line', 2376
    find_lex $P6614, "$i"
    unless_null $P6614, vivify_2987
    new $P6614, "Undef"
  vivify_2987:
    set $I6615, $P6614
    find_lex $P6616, "$past"
    unless_null $P6616, vivify_2988
    $P6616 = root_new ['parrot';'ResizablePMCArray']
  vivify_2988:
    set $P6617, $P6616[$I6615]
    unless_null $P6617, vivify_2989
    new $P6617, "Undef"
  vivify_2989:
    $S6618 = $P6617."name"()
    iseq $I6619, $S6618, "&prefix:<|>"
    unless $I6619, if_6613_end
.annotate 'line', 2377
    find_lex $P6620, "$i"
    unless_null $P6620, vivify_2990
    new $P6620, "Undef"
  vivify_2990:
    set $I6621, $P6620
    find_lex $P6622, "$past"
    unless_null $P6622, vivify_2991
    $P6622 = root_new ['parrot';'ResizablePMCArray']
  vivify_2991:
    set $P6623, $P6622[$I6621]
    unless_null $P6623, vivify_2992
    $P6623 = root_new ['parrot';'ResizablePMCArray']
  vivify_2992:
    set $P6624, $P6623[0]
    unless_null $P6624, vivify_2993
    new $P6624, "Undef"
  vivify_2993:
    find_lex $P6625, "$i"
    unless_null $P6625, vivify_2994
    new $P6625, "Undef"
  vivify_2994:
    set $I6626, $P6625
    find_lex $P6627, "$past"
    unless_null $P6627, vivify_2995
    $P6627 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6627
  vivify_2995:
    set $P6627[$I6626], $P6624
.annotate 'line', 2378
    find_lex $P6628, "$i"
    unless_null $P6628, vivify_2996
    new $P6628, "Undef"
  vivify_2996:
    set $I6629, $P6628
    find_lex $P6630, "$past"
    unless_null $P6630, vivify_2997
    $P6630 = root_new ['parrot';'ResizablePMCArray']
  vivify_2997:
    set $P6631, $P6630[$I6629]
    unless_null $P6631, vivify_2998
    new $P6631, "Undef"
  vivify_2998:
    $P6631."flat"(1)
.annotate 'line', 2379
    find_lex $P6635, "$i"
    unless_null $P6635, vivify_2999
    new $P6635, "Undef"
  vivify_2999:
    set $I6636, $P6635
    find_lex $P6637, "$past"
    unless_null $P6637, vivify_3000
    $P6637 = root_new ['parrot';'ResizablePMCArray']
  vivify_3000:
    set $P6638, $P6637[$I6636]
    unless_null $P6638, vivify_3001
    new $P6638, "Undef"
  vivify_3001:
    get_hll_global $P6639, "GLOBAL"
    nqp_get_package_through_who $P6640, $P6639, "PAST"
    get_who $P6641, $P6640
    set $P6642, $P6641["Val"]
    $P6643 = $P6638."isa"($P6642)
    if $P6643, if_6634
    set $P6633, $P6643
    goto if_6634_end
  if_6634:
.annotate 'line', 2380
    find_lex $P6644, "$i"
    unless_null $P6644, vivify_3002
    new $P6644, "Undef"
  vivify_3002:
    set $I6645, $P6644
    find_lex $P6646, "$past"
    unless_null $P6646, vivify_3003
    $P6646 = root_new ['parrot';'ResizablePMCArray']
  vivify_3003:
    set $P6647, $P6646[$I6645]
    unless_null $P6647, vivify_3004
    new $P6647, "Undef"
  vivify_3004:
    $S6648 = $P6647."name"()
    substr $S6649, $S6648, 0, 1
    iseq $I6650, $S6649, "%"
    new $P6633, 'Integer'
    set $P6633, $I6650
  if_6634_end:
    unless $P6633, if_6632_end
.annotate 'line', 2381
    find_lex $P6651, "$i"
    unless_null $P6651, vivify_3005
    new $P6651, "Undef"
  vivify_3005:
    set $I6652, $P6651
    find_lex $P6653, "$past"
    unless_null $P6653, vivify_3006
    $P6653 = root_new ['parrot';'ResizablePMCArray']
  vivify_3006:
    set $P6654, $P6653[$I6652]
    unless_null $P6654, vivify_3007
    new $P6654, "Undef"
  vivify_3007:
    $P6654."named"(1)
  if_6632_end:
  if_6613_end:
.annotate 'line', 2376
    find_lex $P6655, "$i"
    unless_null $P6655, vivify_3008
    new $P6655, "Undef"
  vivify_3008:
    clone $P6656, $P6655
    inc $P6655
  loop6657_next:
.annotate 'line', 2375
    goto loop6657_test
  loop6657_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6659, exception, 'type'
    eq $P6659, .CONTROL_LOOP_NEXT, loop6657_next
    eq $P6659, .CONTROL_LOOP_REDO, loop6657_redo
  loop6657_done:
    pop_eh 
.annotate 'line', 2386
    find_lex $P6660, "$/"
    find_lex $P6661, "$past"
    unless_null $P6661, vivify_3009
    new $P6661, "Undef"
  vivify_3009:
    $P6662 = $P6660."!make"($P6661)
.annotate 'line', 2364
    .return ($P6662)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6570"  :anon :subid("576_1305640955.436") :outer("575_1305640955.436")
.annotate 'line', 2366
    .const 'Sub' $P6592 = "577_1305640955.436" 
    capture_lex $P6592
.annotate 'line', 2367
    new $P6572, "Undef"
    .lex "$expr", $P6572
    find_lex $P6573, "$/"
    unless_null $P6573, vivify_2974
    $P6573 = root_new ['parrot';'Hash']
  vivify_2974:
    set $P6574, $P6573["EXPR"]
    unless_null $P6574, vivify_2975
    new $P6574, "Undef"
  vivify_2975:
    $P6575 = $P6574."ast"()
    store_lex "$expr", $P6575
.annotate 'line', 2368
    find_lex $P6580, "$expr"
    unless_null $P6580, vivify_2976
    new $P6580, "Undef"
  vivify_2976:
    $S6581 = $P6580."name"()
    iseq $I6582, $S6581, "&infix:<,>"
    if $I6582, if_6579
    new $P6578, 'Integer'
    set $P6578, $I6582
    goto if_6579_end
  if_6579:
    find_lex $P6583, "$expr"
    unless_null $P6583, vivify_2977
    new $P6583, "Undef"
  vivify_2977:
    $P6584 = $P6583."named"()
    isfalse $I6585, $P6584
    new $P6578, 'Integer'
    set $P6578, $I6585
  if_6579_end:
    if $P6578, if_6577
.annotate 'line', 2371
    find_lex $P6600, "$past"
    unless_null $P6600, vivify_2978
    new $P6600, "Undef"
  vivify_2978:
    find_lex $P6601, "$expr"
    unless_null $P6601, vivify_2979
    new $P6601, "Undef"
  vivify_2979:
    $P6602 = $P6600."push"($P6601)
    set $P6576, $P6602
.annotate 'line', 2368
    goto if_6577_end
  if_6577:
.annotate 'line', 2369
    find_lex $P6587, "$expr"
    unless_null $P6587, vivify_2980
    new $P6587, "Undef"
  vivify_2980:
    $P6588 = $P6587."list"()
    defined $I6589, $P6588
    unless $I6589, for_undef_2981
    iter $P6586, $P6588
    new $P6598, 'ExceptionHandler'
    set_label $P6598, loop6597_handler
    $P6598."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6598
  loop6597_test:
    unless $P6586, loop6597_done
    shift $P6590, $P6586
  loop6597_redo:
    .const 'Sub' $P6592 = "577_1305640955.436" 
    capture_lex $P6592
    $P6592($P6590)
  loop6597_next:
    goto loop6597_test
  loop6597_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6599, exception, 'type'
    eq $P6599, .CONTROL_LOOP_NEXT, loop6597_next
    eq $P6599, .CONTROL_LOOP_REDO, loop6597_redo
  loop6597_done:
    pop_eh 
  for_undef_2981:
.annotate 'line', 2368
    set $P6576, $P6586
  if_6577_end:
.annotate 'line', 2366
    .return ($P6576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6591"  :anon :subid("577_1305640955.436") :outer("576_1305640955.436")
    .param pmc param_6593
.annotate 'line', 2369
    .lex "$_", param_6593
    find_lex $P6594, "$past"
    unless_null $P6594, vivify_2982
    new $P6594, "Undef"
  vivify_2982:
    find_lex $P6595, "$_"
    unless_null $P6595, vivify_2983
    new $P6595, "Undef"
  vivify_2983:
    $P6596 = $P6594."push"($P6595)
    .return ($P6596)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>" :anon :subid("578_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6664
    .param pmc param_6665
.annotate 'line', 2389
    .lex "self", param_6664
    .lex "$/", param_6665
    find_lex $P6666, "$/"
    find_lex $P6667, "$/"
    unless_null $P6667, vivify_3010
    $P6667 = root_new ['parrot';'Hash']
  vivify_3010:
    set $P6668, $P6667["multi_declarator"]
    unless_null $P6668, vivify_3011
    new $P6668, "Undef"
  vivify_3011:
    $P6669 = $P6668."ast"()
    $P6670 = $P6666."!make"($P6669)
    .return ($P6670)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>" :anon :subid("579_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6672
    .param pmc param_6673
.annotate 'line', 2391
    .lex "self", param_6672
    .lex "$/", param_6673
    find_lex $P6674, "$/"
    find_lex $P6675, "$/"
    unless_null $P6675, vivify_3012
    $P6675 = root_new ['parrot';'Hash']
  vivify_3012:
    set $P6676, $P6675["value"]
    unless_null $P6676, vivify_3013
    new $P6676, "Undef"
  vivify_3013:
    $P6677 = $P6676."ast"()
    $P6678 = $P6674."!make"($P6677)
    .return ($P6678)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>" :anon :subid("580_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6680
    .param pmc param_6681
.annotate 'line', 2393
    .lex "self", param_6680
    .lex "$/", param_6681
.annotate 'line', 2394
    find_lex $P6682, "$/"
.annotate 'line', 2395
    find_lex $P6685, "$/"
    unless_null $P6685, vivify_3014
    $P6685 = root_new ['parrot';'Hash']
  vivify_3014:
    set $P6686, $P6685["EXPR"]
    unless_null $P6686, vivify_3015
    new $P6686, "Undef"
  vivify_3015:
    if $P6686, if_6684
.annotate 'line', 2396
    get_hll_global $P6691, "GLOBAL"
    nqp_get_package_through_who $P6692, $P6691, "PAST"
    get_who $P6693, $P6692
    set $P6694, $P6693["Op"]
    find_lex $P6695, "$/"
    unless_null $P6695, vivify_3016
    new $P6695, "Undef"
  vivify_3016:
    $P6696 = $P6694."new"("list" :named("pasttype"), $P6695 :named("node"))
    set $P6683, $P6696
.annotate 'line', 2395
    goto if_6684_end
  if_6684:
    find_lex $P6687, "$/"
    unless_null $P6687, vivify_3017
    $P6687 = root_new ['parrot';'Hash']
  vivify_3017:
    set $P6688, $P6687["EXPR"]
    unless_null $P6688, vivify_3018
    $P6688 = root_new ['parrot';'ResizablePMCArray']
  vivify_3018:
    set $P6689, $P6688[0]
    unless_null $P6689, vivify_3019
    new $P6689, "Undef"
  vivify_3019:
    $P6690 = $P6689."ast"()
    set $P6683, $P6690
  if_6684_end:
    $P6697 = $P6682."!make"($P6683)
.annotate 'line', 2393
    .return ($P6697)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>" :anon :subid("581_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6699
    .param pmc param_6700
.annotate 'line', 2399
    .lex "self", param_6699
    .lex "$/", param_6700
.annotate 'line', 2400
    new $P6701, "Undef"
    .lex "$past", $P6701
.annotate 'line', 2399
    find_lex $P6702, "$past"
    unless_null $P6702, vivify_3020
    new $P6702, "Undef"
  vivify_3020:
.annotate 'line', 2401
    find_lex $P6704, "$/"
    unless_null $P6704, vivify_3021
    $P6704 = root_new ['parrot';'Hash']
  vivify_3021:
    set $P6705, $P6704["EXPR"]
    unless_null $P6705, vivify_3022
    new $P6705, "Undef"
  vivify_3022:
    if $P6705, if_6703
.annotate 'line', 2408
    get_hll_global $P6720, "GLOBAL"
    nqp_get_package_through_who $P6721, $P6720, "PAST"
    get_who $P6722, $P6721
    set $P6723, $P6722["Op"]
    $P6724 = $P6723."new"("list" :named("pasttype"))
    store_lex "$past", $P6724
.annotate 'line', 2407
    goto if_6703_end
  if_6703:
.annotate 'line', 2402
    find_lex $P6706, "$/"
    unless_null $P6706, vivify_3023
    $P6706 = root_new ['parrot';'Hash']
  vivify_3023:
    set $P6707, $P6706["EXPR"]
    unless_null $P6707, vivify_3024
    $P6707 = root_new ['parrot';'ResizablePMCArray']
  vivify_3024:
    set $P6708, $P6707[0]
    unless_null $P6708, vivify_3025
    new $P6708, "Undef"
  vivify_3025:
    $P6709 = $P6708."ast"()
    store_lex "$past", $P6709
.annotate 'line', 2403
    find_lex $P6711, "$past"
    unless_null $P6711, vivify_3026
    new $P6711, "Undef"
  vivify_3026:
    $S6712 = $P6711."name"()
    isne $I6713, $S6712, "&infix:<,>"
    unless $I6713, if_6710_end
.annotate 'line', 2404
    get_hll_global $P6714, "GLOBAL"
    nqp_get_package_through_who $P6715, $P6714, "PAST"
    get_who $P6716, $P6715
    set $P6717, $P6716["Op"]
    find_lex $P6718, "$past"
    unless_null $P6718, vivify_3027
    new $P6718, "Undef"
  vivify_3027:
    $P6719 = $P6717."new"($P6718, "list" :named("pasttype"))
    store_lex "$past", $P6719
  if_6710_end:
  if_6703_end:
.annotate 'line', 2410
    find_lex $P6725, "$past"
    unless_null $P6725, vivify_3028
    new $P6725, "Undef"
  vivify_3028:
    $P6725."name"("&circumfix:<[ ]>")
.annotate 'line', 2411
    find_lex $P6726, "$/"
    find_lex $P6727, "$past"
    unless_null $P6727, vivify_3029
    new $P6727, "Undef"
  vivify_3029:
    $P6728 = $P6726."!make"($P6727)
.annotate 'line', 2399
    .return ($P6728)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>" :anon :subid("582_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6730
    .param pmc param_6731
.annotate 'line', 2414
    .lex "self", param_6730
    .lex "$/", param_6731
    find_lex $P6732, "$/"
    find_lex $P6733, "$/"
    unless_null $P6733, vivify_3030
    $P6733 = root_new ['parrot';'Hash']
  vivify_3030:
    set $P6734, $P6733["quote_EXPR"]
    unless_null $P6734, vivify_3031
    new $P6734, "Undef"
  vivify_3031:
    $P6735 = $P6734."ast"()
    $P6736 = $P6732."!make"($P6735)
    .return ($P6736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>" :anon :subid("583_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6738
    .param pmc param_6739
.annotate 'line', 2415
    .lex "self", param_6738
    .lex "$/", param_6739
    find_lex $P6740, "$/"
    find_lex $P6741, "$/"
    unless_null $P6741, vivify_3032
    $P6741 = root_new ['parrot';'Hash']
  vivify_3032:
    set $P6742, $P6741["quote_EXPR"]
    unless_null $P6742, vivify_3033
    new $P6742, "Undef"
  vivify_3033:
    $P6743 = $P6742."ast"()
    $P6744 = $P6740."!make"($P6743)
    .return ($P6744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>" :anon :subid("584_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6746
    .param pmc param_6747
.annotate 'line', 2417
    .const 'Sub' $P6758 = "585_1305640955.436" 
    capture_lex $P6758
    .lex "self", param_6746
    .lex "$/", param_6747
.annotate 'line', 2418
    find_lex $P6750, "$/"
    unless_null $P6750, vivify_3034
    $P6750 = root_new ['parrot';'Hash']
  vivify_3034:
    set $P6751, $P6750["pblock"]
    unless_null $P6751, vivify_3035
    $P6751 = root_new ['parrot';'Hash']
  vivify_3035:
    set $P6752, $P6751["blockoid"]
    unless_null $P6752, vivify_3036
    $P6752 = root_new ['parrot';'Hash']
  vivify_3036:
    set $P6753, $P6752["statementlist"]
    unless_null $P6753, vivify_3037
    $P6753 = root_new ['parrot';'Hash']
  vivify_3037:
    set $P6754, $P6753["statement"]
    unless_null $P6754, vivify_3038
    new $P6754, "Undef"
  vivify_3038:
    set $N6755, $P6754
    isgt $I6756, $N6755, 0.0
    if $I6756, if_6749
.annotate 'line', 2423
    find_lex $P6771, "$/"
    unless_null $P6771, vivify_3039
    $P6771 = root_new ['parrot';'Hash']
  vivify_3039:
    set $P6772, $P6771["pblock"]
    unless_null $P6772, vivify_3040
    $P6772 = root_new ['parrot';'Hash']
  vivify_3040:
    set $P6773, $P6772["blockoid"]
    unless_null $P6773, vivify_3041
    $P6773 = root_new ['parrot';'Hash']
  vivify_3041:
    set $P6774, $P6773["you_are_here"]
    unless_null $P6774, vivify_3042
    new $P6774, "Undef"
  vivify_3042:
    if $P6774, if_6770
.annotate 'line', 2427
    find_lex $P6780, "$/"
    $P6781 = "vivitype"("%")
    $P6782 = $P6780."!make"($P6781)
.annotate 'line', 2426
    set $P6769, $P6782
.annotate 'line', 2423
    goto if_6770_end
  if_6770:
.annotate 'line', 2424
    find_lex $P6775, "$/"
    find_lex $P6776, "$/"
    unless_null $P6776, vivify_3043
    $P6776 = root_new ['parrot';'Hash']
  vivify_3043:
    set $P6777, $P6776["pblock"]
    unless_null $P6777, vivify_3044
    new $P6777, "Undef"
  vivify_3044:
    $P6778 = $P6777."ast"()
    $P6779 = $P6775."!make"($P6778)
.annotate 'line', 2423
    set $P6769, $P6779
  if_6770_end:
    set $P6748, $P6769
.annotate 'line', 2418
    goto if_6749_end
  if_6749:
    .const 'Sub' $P6758 = "585_1305640955.436" 
    capture_lex $P6758
    $P6768 = $P6758()
    set $P6748, $P6768
  if_6749_end:
.annotate 'line', 2417
    .return ($P6748)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6757"  :anon :subid("585_1305640955.436") :outer("584_1305640955.436")
.annotate 'line', 2419
    new $P6759, "Undef"
    .lex "$past", $P6759
    find_lex $P6760, "$/"
    unless_null $P6760, vivify_3045
    $P6760 = root_new ['parrot';'Hash']
  vivify_3045:
    set $P6761, $P6760["pblock"]
    unless_null $P6761, vivify_3046
    new $P6761, "Undef"
  vivify_3046:
    $P6762 = $P6761."ast"()
    store_lex "$past", $P6762
.annotate 'line', 2420
    new $P6763, "Integer"
    assign $P6763, 1
    find_lex $P6764, "$past"
    unless_null $P6764, vivify_3047
    $P6764 = root_new ['parrot';'Hash']
    store_lex "$past", $P6764
  vivify_3047:
    set $P6764["bareblock"], $P6763
.annotate 'line', 2421
    find_dynamic_lex $P6765, "$/"
    find_lex $P6766, "$past"
    unless_null $P6766, vivify_3048
    new $P6766, "Undef"
  vivify_3048:
    $P6767 = $P6765."!make"($P6766)
.annotate 'line', 2418
    .return ($P6767)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>" :anon :subid("586_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6784
    .param pmc param_6785
.annotate 'line', 2431
    .lex "self", param_6784
    .lex "$/", param_6785
.annotate 'line', 2432
    new $P6786, "Undef"
    .lex "$name", $P6786
    find_lex $P6789, "$/"
    unless_null $P6789, vivify_3049
    $P6789 = root_new ['parrot';'Hash']
  vivify_3049:
    set $P6790, $P6789["sigil"]
    unless_null $P6790, vivify_3050
    new $P6790, "Undef"
  vivify_3050:
    set $S6791, $P6790
    iseq $I6792, $S6791, "@"
    if $I6792, if_6788
.annotate 'line', 2433
    find_lex $P6796, "$/"
    unless_null $P6796, vivify_3051
    $P6796 = root_new ['parrot';'Hash']
  vivify_3051:
    set $P6797, $P6796["sigil"]
    unless_null $P6797, vivify_3052
    new $P6797, "Undef"
  vivify_3052:
    set $S6798, $P6797
    iseq $I6799, $S6798, "%"
    if $I6799, if_6795
    new $P6801, "String"
    assign $P6801, "item"
    set $P6794, $P6801
    goto if_6795_end
  if_6795:
    new $P6800, "String"
    assign $P6800, "hash"
    set $P6794, $P6800
  if_6795_end:
    set $P6787, $P6794
.annotate 'line', 2432
    goto if_6788_end
  if_6788:
    new $P6793, "String"
    assign $P6793, "list"
    set $P6787, $P6793
  if_6788_end:
    store_lex "$name", $P6787
.annotate 'line', 2435
    find_lex $P6802, "$/"
    get_hll_global $P6803, "GLOBAL"
    nqp_get_package_through_who $P6804, $P6803, "PAST"
    get_who $P6805, $P6804
    set $P6806, $P6805["Op"]
    find_lex $P6807, "$name"
    unless_null $P6807, vivify_3053
    new $P6807, "Undef"
  vivify_3053:
    find_lex $P6808, "$/"
    unless_null $P6808, vivify_3054
    $P6808 = root_new ['parrot';'Hash']
  vivify_3054:
    set $P6809, $P6808["semilist"]
    unless_null $P6809, vivify_3055
    new $P6809, "Undef"
  vivify_3055:
    $P6810 = $P6809."ast"()
    $P6811 = $P6806."new"($P6810, "callmethod" :named("pasttype"), $P6807 :named("name"))
    $P6812 = $P6802."!make"($P6811)
.annotate 'line', 2431
    .return ($P6812)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist" :anon :subid("587_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6814
    .param pmc param_6815
.annotate 'line', 2438
    .lex "self", param_6814
    .lex "$/", param_6815
    find_lex $P6816, "$/"
    find_lex $P6817, "$/"
    unless_null $P6817, vivify_3056
    $P6817 = root_new ['parrot';'Hash']
  vivify_3056:
    set $P6818, $P6817["statement"]
    unless_null $P6818, vivify_3057
    new $P6818, "Undef"
  vivify_3057:
    $P6819 = $P6818."ast"()
    $P6820 = $P6816."!make"($P6819)
    .return ($P6820)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>" :anon :subid("588_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6822
    .param pmc param_6823
.annotate 'line', 2440
    .lex "self", param_6822
    .lex "$/", param_6823
.annotate 'line', 2441
    find_lex $P6824, "$/"
    get_hll_global $P6825, "GLOBAL"
    nqp_get_package_through_who $P6826, $P6825, "PAST"
    get_who $P6827, $P6826
    set $P6828, $P6827["Var"]
    find_lex $P6829, "$/"
    unless_null $P6829, vivify_3058
    $P6829 = root_new ['parrot';'Hash']
  vivify_3058:
    set $P6830, $P6829["EXPR"]
    unless_null $P6830, vivify_3059
    new $P6830, "Undef"
  vivify_3059:
    $P6831 = $P6830."ast"()
.annotate 'line', 2443
    $P6832 = "vivitype"("@")
    $P6833 = $P6828."new"($P6831, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6832 :named("vivibase"))
.annotate 'line', 2441
    $P6834 = $P6824."!make"($P6833)
.annotate 'line', 2440
    .return ($P6834)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>" :anon :subid("589_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6836
    .param pmc param_6837
.annotate 'line', 2446
    .lex "self", param_6836
    .lex "$/", param_6837
.annotate 'line', 2447
    find_lex $P6838, "$/"
    get_hll_global $P6839, "GLOBAL"
    nqp_get_package_through_who $P6840, $P6839, "PAST"
    get_who $P6841, $P6840
    set $P6842, $P6841["Var"]
    find_lex $P6843, "$/"
    unless_null $P6843, vivify_3060
    $P6843 = root_new ['parrot';'Hash']
  vivify_3060:
    set $P6844, $P6843["EXPR"]
    unless_null $P6844, vivify_3061
    new $P6844, "Undef"
  vivify_3061:
    $P6845 = $P6844."ast"()
.annotate 'line', 2449
    $P6846 = "vivitype"("%")
    $P6847 = $P6842."new"($P6845, "keyed" :named("scope"), "Undef" :named("viviself"), $P6846 :named("vivibase"))
.annotate 'line', 2447
    $P6848 = $P6838."!make"($P6847)
.annotate 'line', 2446
    .return ($P6848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>" :anon :subid("590_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6850
    .param pmc param_6851
.annotate 'line', 2452
    .lex "self", param_6850
    .lex "$/", param_6851
.annotate 'line', 2453
    find_lex $P6852, "$/"
    get_hll_global $P6853, "GLOBAL"
    nqp_get_package_through_who $P6854, $P6853, "PAST"
    get_who $P6855, $P6854
    set $P6856, $P6855["Var"]
    find_lex $P6857, "$/"
    unless_null $P6857, vivify_3062
    $P6857 = root_new ['parrot';'Hash']
  vivify_3062:
    set $P6858, $P6857["quote_EXPR"]
    unless_null $P6858, vivify_3063
    new $P6858, "Undef"
  vivify_3063:
    $P6859 = $P6858."ast"()
.annotate 'line', 2455
    $P6860 = "vivitype"("%")
    $P6861 = $P6856."new"($P6859, "keyed" :named("scope"), "Undef" :named("viviself"), $P6860 :named("vivibase"))
.annotate 'line', 2453
    $P6862 = $P6852."!make"($P6861)
.annotate 'line', 2452
    .return ($P6862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>" :anon :subid("591_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6864
    .param pmc param_6865
.annotate 'line', 2458
    .lex "self", param_6864
    .lex "$/", param_6865
.annotate 'line', 2459
    find_lex $P6866, "$/"
    find_lex $P6867, "$/"
    unless_null $P6867, vivify_3064
    $P6867 = root_new ['parrot';'Hash']
  vivify_3064:
    set $P6868, $P6867["arglist"]
    unless_null $P6868, vivify_3065
    new $P6868, "Undef"
  vivify_3065:
    $P6869 = $P6868."ast"()
    $P6870 = $P6866."!make"($P6869)
.annotate 'line', 2458
    .return ($P6870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value" :anon :subid("592_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6872
    .param pmc param_6873
.annotate 'line', 2462
    .lex "self", param_6872
    .lex "$/", param_6873
.annotate 'line', 2463
    find_lex $P6874, "$/"
    find_lex $P6877, "$/"
    unless_null $P6877, vivify_3066
    $P6877 = root_new ['parrot';'Hash']
  vivify_3066:
    set $P6878, $P6877["quote"]
    unless_null $P6878, vivify_3067
    new $P6878, "Undef"
  vivify_3067:
    if $P6878, if_6876
    find_lex $P6882, "$/"
    unless_null $P6882, vivify_3068
    $P6882 = root_new ['parrot';'Hash']
  vivify_3068:
    set $P6883, $P6882["number"]
    unless_null $P6883, vivify_3069
    new $P6883, "Undef"
  vivify_3069:
    $P6884 = $P6883."ast"()
    set $P6875, $P6884
    goto if_6876_end
  if_6876:
    find_lex $P6879, "$/"
    unless_null $P6879, vivify_3070
    $P6879 = root_new ['parrot';'Hash']
  vivify_3070:
    set $P6880, $P6879["quote"]
    unless_null $P6880, vivify_3071
    new $P6880, "Undef"
  vivify_3071:
    $P6881 = $P6880."ast"()
    set $P6875, $P6881
  if_6876_end:
    $P6885 = $P6874."!make"($P6875)
.annotate 'line', 2462
    .return ($P6885)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number" :anon :subid("593_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6887
    .param pmc param_6888
.annotate 'line', 2466
    .lex "self", param_6887
    .lex "$/", param_6888
.annotate 'line', 2467
    new $P6889, "Undef"
    .lex "$value", $P6889
    find_lex $P6892, "$/"
    unless_null $P6892, vivify_3072
    $P6892 = root_new ['parrot';'Hash']
  vivify_3072:
    set $P6893, $P6892["dec_number"]
    unless_null $P6893, vivify_3073
    new $P6893, "Undef"
  vivify_3073:
    if $P6893, if_6891
    find_lex $P6897, "$/"
    unless_null $P6897, vivify_3074
    $P6897 = root_new ['parrot';'Hash']
  vivify_3074:
    set $P6898, $P6897["integer"]
    unless_null $P6898, vivify_3075
    new $P6898, "Undef"
  vivify_3075:
    $P6899 = $P6898."ast"()
    set $P6890, $P6899
    goto if_6891_end
  if_6891:
    find_lex $P6894, "$/"
    unless_null $P6894, vivify_3076
    $P6894 = root_new ['parrot';'Hash']
  vivify_3076:
    set $P6895, $P6894["dec_number"]
    unless_null $P6895, vivify_3077
    new $P6895, "Undef"
  vivify_3077:
    $P6896 = $P6895."ast"()
    set $P6890, $P6896
  if_6891_end:
    store_lex "$value", $P6890
.annotate 'line', 2468
    find_lex $P6901, "$/"
    unless_null $P6901, vivify_3078
    $P6901 = root_new ['parrot';'Hash']
  vivify_3078:
    set $P6902, $P6901["sign"]
    unless_null $P6902, vivify_3079
    new $P6902, "Undef"
  vivify_3079:
    set $S6903, $P6902
    iseq $I6904, $S6903, "-"
    unless $I6904, if_6900_end
    find_lex $P6905, "$value"
    unless_null $P6905, vivify_3080
    new $P6905, "Undef"
  vivify_3080:
    neg $P6906, $P6905
    store_lex "$value", $P6906
  if_6900_end:
.annotate 'line', 2469
    find_lex $P6907, "$/"
    get_hll_global $P6908, "GLOBAL"
    nqp_get_package_through_who $P6909, $P6908, "PAST"
    get_who $P6910, $P6909
    set $P6911, $P6910["Val"]
    find_lex $P6912, "$value"
    unless_null $P6912, vivify_3081
    new $P6912, "Undef"
  vivify_3081:
    $P6913 = $P6911."new"($P6912 :named("value"))
    $P6914 = $P6907."!make"($P6913)
.annotate 'line', 2466
    .return ($P6914)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>" :anon :subid("594_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6916
    .param pmc param_6917
.annotate 'line', 2472
    .lex "self", param_6916
    .lex "$/", param_6917
    find_lex $P6918, "$/"
    find_lex $P6919, "$/"
    unless_null $P6919, vivify_3082
    $P6919 = root_new ['parrot';'Hash']
  vivify_3082:
    set $P6920, $P6919["quote_EXPR"]
    unless_null $P6920, vivify_3083
    new $P6920, "Undef"
  vivify_3083:
    $P6921 = $P6920."ast"()
    $P6922 = $P6918."!make"($P6921)
    .return ($P6922)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>" :anon :subid("595_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6924
    .param pmc param_6925
.annotate 'line', 2473
    .lex "self", param_6924
    .lex "$/", param_6925
    find_lex $P6926, "$/"
    find_lex $P6927, "$/"
    unless_null $P6927, vivify_3084
    $P6927 = root_new ['parrot';'Hash']
  vivify_3084:
    set $P6928, $P6927["quote_EXPR"]
    unless_null $P6928, vivify_3085
    new $P6928, "Undef"
  vivify_3085:
    $P6929 = $P6928."ast"()
    $P6930 = $P6926."!make"($P6929)
    .return ($P6930)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>" :anon :subid("596_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6932
    .param pmc param_6933
.annotate 'line', 2474
    .lex "self", param_6932
    .lex "$/", param_6933
    find_lex $P6934, "$/"
    find_lex $P6935, "$/"
    unless_null $P6935, vivify_3086
    $P6935 = root_new ['parrot';'Hash']
  vivify_3086:
    set $P6936, $P6935["quote_EXPR"]
    unless_null $P6936, vivify_3087
    new $P6936, "Undef"
  vivify_3087:
    $P6937 = $P6936."ast"()
    $P6938 = $P6934."!make"($P6937)
    .return ($P6938)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>" :anon :subid("597_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6940
    .param pmc param_6941
.annotate 'line', 2475
    .lex "self", param_6940
    .lex "$/", param_6941
    find_lex $P6942, "$/"
    find_lex $P6943, "$/"
    unless_null $P6943, vivify_3088
    $P6943 = root_new ['parrot';'Hash']
  vivify_3088:
    set $P6944, $P6943["quote_EXPR"]
    unless_null $P6944, vivify_3089
    new $P6944, "Undef"
  vivify_3089:
    $P6945 = $P6944."ast"()
    $P6946 = $P6942."!make"($P6945)
    .return ($P6946)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>" :anon :subid("598_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6948
    .param pmc param_6949
.annotate 'line', 2476
    .lex "self", param_6948
    .lex "$/", param_6949
    find_lex $P6950, "$/"
    find_lex $P6951, "$/"
    unless_null $P6951, vivify_3090
    $P6951 = root_new ['parrot';'Hash']
  vivify_3090:
    set $P6952, $P6951["quote_EXPR"]
    unless_null $P6952, vivify_3091
    new $P6952, "Undef"
  vivify_3091:
    $P6953 = $P6952."ast"()
    $P6954 = $P6950."!make"($P6953)
    .return ($P6954)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>" :anon :subid("599_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6956
    .param pmc param_6957
.annotate 'line', 2477
    .lex "self", param_6956
    .lex "$/", param_6957
.annotate 'line', 2478
    find_lex $P6958, "$/"
    get_hll_global $P6959, "GLOBAL"
    nqp_get_package_through_who $P6960, $P6959, "PAST"
    get_who $P6961, $P6960
    set $P6962, $P6961["Op"]
    find_lex $P6963, "$/"
    unless_null $P6963, vivify_3092
    $P6963 = root_new ['parrot';'Hash']
  vivify_3092:
    set $P6964, $P6963["quote_EXPR"]
    unless_null $P6964, vivify_3093
    new $P6964, "Undef"
  vivify_3093:
    $P6965 = $P6964."ast"()
    $P6966 = $P6965."value"()
    find_lex $P6967, "$/"
    unless_null $P6967, vivify_3094
    new $P6967, "Undef"
  vivify_3094:
    $P6968 = $P6962."new"($P6966 :named("inline"), "inline" :named("pasttype"), $P6967 :named("node"))
    $P6969 = $P6958."!make"($P6968)
.annotate 'line', 2477
    .return ($P6969)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />" :anon :subid("600_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_6973
    .param pmc param_6974
    .param pmc param_6975 :optional
    .param int has_param_6975 :opt_flag
.annotate 'line', 2483
    new $P6972, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6972, control_6971
    push_eh $P6972
    .lex "self", param_6973
    .lex "$/", param_6974
    if has_param_6975, optparam_3095
    new $P6976, "Undef"
    set param_6975, $P6976
  optparam_3095:
    .lex "$key", param_6975
.annotate 'line', 2490
    new $P6977, "Undef"
    .lex "$regex", $P6977
.annotate 'line', 2492
    new $P6978, "Undef"
    .lex "$past", $P6978
.annotate 'line', 2484
    find_lex $P6980, "$key"
    unless_null $P6980, vivify_3096
    new $P6980, "Undef"
  vivify_3096:
    set $S6981, $P6980
    iseq $I6982, $S6981, "open"
    unless $I6982, if_6979_end
.annotate 'line', 2485
    null $P6983
    get_hll_global $P6984, "GLOBAL"
    nqp_get_package_through_who $P6985, $P6984, "Regex"
    nqp_get_package_through_who $P6986, $P6985, "P6Regex"
    nqp_get_package_through_who $P6987, $P6986, "Actions"
    get_who $P6988, $P6987
    set $P6988["$REGEXNAME"], $P6983
.annotate 'line', 2486
    find_lex $P6989, "$?PACKAGE"
    get_who $P6990, $P6989
    set $P6991, $P6990["@BLOCK"]
    unless_null $P6991, vivify_3097
    $P6991 = root_new ['parrot';'ResizablePMCArray']
  vivify_3097:
    set $P6992, $P6991[0]
    unless_null $P6992, vivify_3098
    new $P6992, "Undef"
  vivify_3098:
    $P6992."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2487
    find_lex $P6993, "$?PACKAGE"
    get_who $P6994, $P6993
    set $P6995, $P6994["@BLOCK"]
    unless_null $P6995, vivify_3099
    $P6995 = root_new ['parrot';'ResizablePMCArray']
  vivify_3099:
    set $P6996, $P6995[0]
    unless_null $P6996, vivify_3100
    new $P6996, "Undef"
  vivify_3100:
    $P6996."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2488
    new $P6997, "Exception"
    set $P6997['type'], .CONTROL_RETURN
    new $P6998, "Integer"
    assign $P6998, 0
    setattribute $P6997, 'payload', $P6998
    throw $P6997
  if_6979_end:
.annotate 'line', 2491
    get_hll_global $P6999, "GLOBAL"
    nqp_get_package_through_who $P7000, $P6999, "Regex"
    nqp_get_package_through_who $P7001, $P7000, "P6Regex"
    nqp_get_package_through_who $P7002, $P7001, "Actions"
    get_who $P7003, $P7002
    set $P7004, $P7003["buildsub"]
    find_lex $P7005, "$/"
    unless_null $P7005, vivify_3101
    $P7005 = root_new ['parrot';'Hash']
  vivify_3101:
    set $P7006, $P7005["p6regex"]
    unless_null $P7006, vivify_3102
    new $P7006, "Undef"
  vivify_3102:
    $P7007 = $P7006."ast"()
    find_lex $P7008, "$?PACKAGE"
    get_who $P7009, $P7008
    set $P7010, $P7009["@BLOCK"]
    unless_null $P7010, vivify_3103
    $P7010 = root_new ['parrot';'ResizablePMCArray']
  vivify_3103:
    $P7011 = $P7010."shift"()
    $P7012 = $P7004($P7007, $P7011)
    store_lex "$regex", $P7012
.annotate 'line', 2493
    get_hll_global $P7013, "GLOBAL"
    nqp_get_package_through_who $P7014, $P7013, "PAST"
    get_who $P7015, $P7014
    set $P7016, $P7015["Op"]
.annotate 'line', 2495
    new $P7017, "ResizablePMCArray"
    push $P7017, "Regex"
    push $P7017, "Regex"
    find_lex $P7018, "$/"
    unless_null $P7018, vivify_3104
    new $P7018, "Undef"
  vivify_3104:
    $P7019 = "lexical_package_lookup"($P7017, $P7018)
    find_lex $P7020, "$regex"
    unless_null $P7020, vivify_3105
    new $P7020, "Undef"
  vivify_3105:
    $P7021 = $P7016."new"($P7019, $P7020, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2493
    store_lex "$past", $P7021
.annotate 'line', 2499
    find_lex $P7022, "$regex"
    unless_null $P7022, vivify_3106
    new $P7022, "Undef"
  vivify_3106:
    find_lex $P7023, "$past"
    unless_null $P7023, vivify_3107
    $P7023 = root_new ['parrot';'Hash']
    store_lex "$past", $P7023
  vivify_3107:
    set $P7023["sink"], $P7022
.annotate 'line', 2500
    find_lex $P7024, "$/"
    find_lex $P7025, "$past"
    unless_null $P7025, vivify_3108
    new $P7025, "Undef"
  vivify_3108:
    $P7026 = $P7024."!make"($P7025)
.annotate 'line', 2483
    .return ($P7026)
  control_6971:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P7027, exception, "payload"
    .return ($P7027)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>" :anon :subid("601_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7029
    .param pmc param_7030
.annotate 'line', 2503
    .lex "self", param_7029
    .lex "$/", param_7030
    find_lex $P7031, "$/"
    find_lex $P7032, "$/"
    unless_null $P7032, vivify_3109
    $P7032 = root_new ['parrot';'Hash']
  vivify_3109:
    set $P7033, $P7032["variable"]
    unless_null $P7033, vivify_3110
    new $P7033, "Undef"
  vivify_3110:
    $P7034 = $P7033."ast"()
    $P7035 = $P7031."!make"($P7034)
    .return ($P7035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>" :anon :subid("602_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7037
    .param pmc param_7038
.annotate 'line', 2504
    .lex "self", param_7037
    .lex "$/", param_7038
.annotate 'line', 2505
    find_lex $P7039, "$/"
    get_hll_global $P7040, "GLOBAL"
    nqp_get_package_through_who $P7041, $P7040, "PAST"
    get_who $P7042, $P7041
    set $P7043, $P7042["Op"]
.annotate 'line', 2506
    find_lex $P7044, "$/"
    unless_null $P7044, vivify_3111
    $P7044 = root_new ['parrot';'Hash']
  vivify_3111:
    set $P7045, $P7044["block"]
    unless_null $P7045, vivify_3112
    new $P7045, "Undef"
  vivify_3112:
    $P7046 = $P7045."ast"()
    $P7047 = "block_immediate"($P7046)
    find_lex $P7048, "$/"
    unless_null $P7048, vivify_3113
    new $P7048, "Undef"
  vivify_3113:
    $P7049 = $P7043."new"($P7047, "set S*" :named("pirop"), $P7048 :named("node"))
.annotate 'line', 2505
    $P7050 = $P7039."!make"($P7049)
.annotate 'line', 2504
    .return ($P7050)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>" :anon :subid("603_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7052
    .param pmc param_7053
.annotate 'line', 2509
    .lex "self", param_7052
    .lex "$/", param_7053
    find_lex $P7054, "$/"
    $P7055 = $P7054."!make"("\e")
    .return ($P7055)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>" :anon :subid("604_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7057
    .param pmc param_7058
.annotate 'line', 2513
    .lex "self", param_7057
    .lex "$/", param_7058
    find_lex $P7059, "$/"
    find_lex $P7060, "$/"
    unless_null $P7060, vivify_3114
    $P7060 = root_new ['parrot';'Hash']
  vivify_3114:
    set $P7061, $P7060["dotty"]
    unless_null $P7061, vivify_3115
    new $P7061, "Undef"
  vivify_3115:
    $P7062 = $P7061."ast"()
    $P7063 = $P7059."!make"($P7062)
    .return ($P7063)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>" :anon :subid("605_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7065
    .param pmc param_7066
.annotate 'line', 2515
    .lex "self", param_7065
    .lex "$/", param_7066
.annotate 'line', 2516
    find_lex $P7067, "$/"
    get_hll_global $P7068, "GLOBAL"
    nqp_get_package_through_who $P7069, $P7068, "PAST"
    get_who $P7070, $P7069
    set $P7071, $P7070["Op"]
.annotate 'line', 2517
    new $P7072, "ResizablePMCArray"
    push $P7072, "    clone %r, %0"
    push $P7072, "    inc %0"
    $P7073 = $P7071."new"("postfix:<++>" :named("name"), $P7072 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2516
    $P7074 = $P7067."!make"($P7073)
.annotate 'line', 2515
    .return ($P7074)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->" :anon :subid("606_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7076
    .param pmc param_7077
.annotate 'line', 2521
    .lex "self", param_7076
    .lex "$/", param_7077
.annotate 'line', 2522
    find_lex $P7078, "$/"
    get_hll_global $P7079, "GLOBAL"
    nqp_get_package_through_who $P7080, $P7079, "PAST"
    get_who $P7081, $P7080
    set $P7082, $P7081["Op"]
.annotate 'line', 2523
    new $P7083, "ResizablePMCArray"
    push $P7083, "    clone %r, %0"
    push $P7083, "    dec %0"
    $P7084 = $P7082."new"("postfix:<-->" :named("name"), $P7083 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2522
    $P7085 = $P7078."!make"($P7084)
.annotate 'line', 2521
    .return ($P7085)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>" :anon :subid("607_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7087
    .param pmc param_7088
.annotate 'line', 2527
    .lex "self", param_7087
    .lex "$/", param_7088
.annotate 'line', 2528
    find_lex $P7089, "$/"
    get_hll_global $P7090, "GLOBAL"
    nqp_get_package_through_who $P7091, $P7090, "PAST"
    get_who $P7092, $P7091
    set $P7093, $P7092["Op"]
.annotate 'line', 2529
    get_hll_global $P7094, "GLOBAL"
    nqp_get_package_through_who $P7095, $P7094, "PAST"
    get_who $P7096, $P7095
    set $P7097, $P7096["Var"]
    $P7098 = $P7097."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P7099, "$/"
    unless_null $P7099, vivify_3116
    new $P7099, "Undef"
  vivify_3116:
    $P7100 = $P7093."new"($P7098, "callmethod" :named("pasttype"), "!make" :named("name"), $P7099 :named("node"))
.annotate 'line', 2528
    $P7101 = $P7089."!make"($P7100)
.annotate 'line', 2527
    .return ($P7101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>" :anon :subid("608_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7104
    .param pmc param_7105
.annotate 'line', 2545
    .lex "self", param_7104
    .lex "$/", param_7105
    find_lex $P7106, "$/"
    unless_null $P7106, vivify_3117
    new $P7106, "Undef"
  vivify_3117:
    $P7107 = "control"($P7106, "CONTROL_LOOP_NEXT")
    .return ($P7107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>" :anon :subid("609_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7109
    .param pmc param_7110
.annotate 'line', 2546
    .lex "self", param_7109
    .lex "$/", param_7110
    find_lex $P7111, "$/"
    unless_null $P7111, vivify_3118
    new $P7111, "Undef"
  vivify_3118:
    $P7112 = "control"($P7111, "CONTROL_LOOP_LAST")
    .return ($P7112)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>" :anon :subid("610_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7114
    .param pmc param_7115
.annotate 'line', 2547
    .lex "self", param_7114
    .lex "$/", param_7115
    find_lex $P7116, "$/"
    unless_null $P7116, vivify_3119
    new $P7116, "Undef"
  vivify_3119:
    $P7117 = "control"($P7116, "CONTROL_LOOP_REDO")
    .return ($P7117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>" :anon :subid("611_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7119
    .param pmc param_7120
.annotate 'line', 2549
    .lex "self", param_7119
    .lex "$/", param_7120
.annotate 'line', 2550
    find_lex $P7121, "$/"
    get_hll_global $P7122, "GLOBAL"
    nqp_get_package_through_who $P7123, $P7122, "PAST"
    get_who $P7124, $P7123
    set $P7125, $P7124["Op"]
    find_lex $P7126, "$/"
    unless_null $P7126, vivify_3120
    new $P7126, "Undef"
  vivify_3120:
    $P7127 = $P7125."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P7126 :named("node"))
    $P7128 = $P7121."!make"($P7127)
.annotate 'line', 2549
    .return ($P7128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym" :anon :subid("612_1305640955.436") :outer("435_1305640955.436")
    .param pmc param_7134
    .param pmc param_7135
    .param pmc param_7136
.annotate 'line', 2627
    .const 'Sub' $P7140 = "613_1305640955.436" 
    capture_lex $P7140
    .lex "self", param_7134
    .lex "$/", param_7135
    .lex "@name", param_7136
.annotate 'line', 2628
    new $P7137, "Undef"
    .lex "$known", $P7137
    new $P7138, "Integer"
    assign $P7138, 0
    store_lex "$known", $P7138
.annotate 'line', 2629
    .const 'Sub' $P7140 = "613_1305640955.436" 
    capture_lex $P7140
    $P7140()
    find_lex $P7151, "$known"
    unless_null $P7151, vivify_3123
    new $P7151, "Undef"
  vivify_3123:
.annotate 'line', 2627
    .return ($P7151)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block7139"  :anon :subid("613_1305640955.436") :outer("612_1305640955.436")
.annotate 'line', 2629
    new $P7146, 'ExceptionHandler'
    set_label $P7146, control_7145
    $P7146."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P7146
.annotate 'line', 2630
    find_lex $P7141, "@name"
    unless_null $P7141, vivify_3121
    $P7141 = root_new ['parrot';'ResizablePMCArray']
  vivify_3121:
    find_lex $P7142, "$/"
    unless_null $P7142, vivify_3122
    new $P7142, "Undef"
  vivify_3122:
    "find_sym"($P7141, $P7142)
.annotate 'line', 2631
    new $P7143, "Integer"
    assign $P7143, 1
    store_lex "$known", $P7143
.annotate 'line', 2629
    pop_eh 
    goto skip_handler_7144
  control_7145:
    .local pmc exception 
    .get_results (exception) 
    new $P7149, 'Integer'
    set $P7149, 1
    set exception["handled"], $P7149
    set $I7150, exception["handled"]
    ne $I7150, 1, nothandled_7148
  handled_7147:
    .return (exception)
  nothandled_7148:
    rethrow exception
  skip_handler_7144:
    .return ($P7143)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7153"  :subid("614_1305640955.436") :outer("10_1305640955.436")
.annotate 'line', 2696
    .const 'Sub' $P7247 = "621_1305640955.436" 
    capture_lex $P7247
    .const 'Sub' $P7233 = "620_1305640955.436" 
    capture_lex $P7233
    .const 'Sub' $P7215 = "619_1305640955.436" 
    capture_lex $P7215
    .const 'Sub' $P7201 = "618_1305640955.436" 
    capture_lex $P7201
    .const 'Sub' $P7187 = "617_1305640955.436" 
    capture_lex $P7187
    .const 'Sub' $P7173 = "616_1305640955.436" 
    capture_lex $P7173
    .const 'Sub' $P7157 = "615_1305640955.436" 
    capture_lex $P7157
    .lex "$?PACKAGE", $P7155
    .lex "$?CLASS", $P7156
.annotate 'line', 2730
    .const 'Sub' $P7247 = "621_1305640955.436" 
    newclosure $P7285, $P7247
.annotate 'line', 2696
    .return ($P7285)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>" :anon :subid("615_1305640955.436") :outer("614_1305640955.436")
    .param pmc param_7158
    .param pmc param_7159
.annotate 'line', 2698
    .lex "self", param_7158
    .lex "$/", param_7159
.annotate 'line', 2699
    new $P7160, "Undef"
    .lex "$past", $P7160
    find_lex $P7161, "$/"
    unless_null $P7161, vivify_3124
    $P7161 = root_new ['parrot';'Hash']
  vivify_3124:
    set $P7162, $P7161["statement"]
    unless_null $P7162, vivify_3125
    new $P7162, "Undef"
  vivify_3125:
    $P7163 = $P7162."ast"()
    store_lex "$past", $P7163
.annotate 'line', 2700
    find_lex $P7164, "$/"
    get_hll_global $P7165, "GLOBAL"
    nqp_get_package_through_who $P7166, $P7165, "PAST"
    get_who $P7167, $P7166
    set $P7168, $P7167["Regex"]
    find_lex $P7169, "$past"
    unless_null $P7169, vivify_3126
    new $P7169, "Undef"
  vivify_3126:
    find_lex $P7170, "$/"
    unless_null $P7170, vivify_3127
    new $P7170, "Undef"
  vivify_3127:
    $P7171 = $P7168."new"($P7169, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P7170 :named("node"))
    $P7172 = $P7164."!make"($P7171)
.annotate 'line', 2698
    .return ($P7172)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>" :anon :subid("616_1305640955.436") :outer("614_1305640955.436")
    .param pmc param_7174
    .param pmc param_7175
.annotate 'line', 2704
    .lex "self", param_7174
    .lex "$/", param_7175
.annotate 'line', 2705
    find_lex $P7176, "$/"
    get_hll_global $P7177, "GLOBAL"
    nqp_get_package_through_who $P7178, $P7177, "PAST"
    get_who $P7179, $P7178
    set $P7180, $P7179["Regex"]
    find_lex $P7181, "$/"
    unless_null $P7181, vivify_3128
    $P7181 = root_new ['parrot';'Hash']
  vivify_3128:
    set $P7182, $P7181["codeblock"]
    unless_null $P7182, vivify_3129
    new $P7182, "Undef"
  vivify_3129:
    $P7183 = $P7182."ast"()
    find_lex $P7184, "$/"
    unless_null $P7184, vivify_3130
    new $P7184, "Undef"
  vivify_3130:
    $P7185 = $P7180."new"($P7183, "pastnode" :named("pasttype"), $P7184 :named("node"))
    $P7186 = $P7176."!make"($P7185)
.annotate 'line', 2704
    .return ($P7186)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>" :anon :subid("617_1305640955.436") :outer("614_1305640955.436")
    .param pmc param_7188
    .param pmc param_7189
.annotate 'line', 2709
    .lex "self", param_7188
    .lex "$/", param_7189
.annotate 'line', 2710
    find_lex $P7190, "$/"
    get_hll_global $P7191, "GLOBAL"
    nqp_get_package_through_who $P7192, $P7191, "PAST"
    get_who $P7193, $P7192
    set $P7194, $P7193["Regex"]
    find_lex $P7195, "$/"
    unless_null $P7195, vivify_3131
    $P7195 = root_new ['parrot';'Hash']
  vivify_3131:
    set $P7196, $P7195["var"]
    unless_null $P7196, vivify_3132
    new $P7196, "Undef"
  vivify_3132:
    $P7197 = $P7196."ast"()
    find_lex $P7198, "$/"
    unless_null $P7198, vivify_3133
    new $P7198, "Undef"
  vivify_3133:
    $P7199 = $P7194."new"("!INTERPOLATE", $P7197, "subrule" :named("pasttype"), "method" :named("subtype"), $P7198 :named("node"))
    $P7200 = $P7190."!make"($P7199)
.annotate 'line', 2709
    .return ($P7200)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>" :anon :subid("618_1305640955.436") :outer("614_1305640955.436")
    .param pmc param_7202
    .param pmc param_7203
.annotate 'line', 2714
    .lex "self", param_7202
    .lex "$/", param_7203
.annotate 'line', 2715
    find_lex $P7204, "$/"
    get_hll_global $P7205, "GLOBAL"
    nqp_get_package_through_who $P7206, $P7205, "PAST"
    get_who $P7207, $P7206
    set $P7208, $P7207["Regex"]
    find_lex $P7209, "$/"
    unless_null $P7209, vivify_3134
    $P7209 = root_new ['parrot';'Hash']
  vivify_3134:
    set $P7210, $P7209["codeblock"]
    unless_null $P7210, vivify_3135
    new $P7210, "Undef"
  vivify_3135:
    $P7211 = $P7210."ast"()
    find_lex $P7212, "$/"
    unless_null $P7212, vivify_3136
    new $P7212, "Undef"
  vivify_3136:
    $P7213 = $P7208."new"("!INTERPOLATE_REGEX", $P7211, "subrule" :named("pasttype"), "method" :named("subtype"), $P7212 :named("node"))
    $P7214 = $P7204."!make"($P7213)
.annotate 'line', 2714
    .return ($P7214)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>" :anon :subid("619_1305640955.436") :outer("614_1305640955.436")
    .param pmc param_7216
    .param pmc param_7217
.annotate 'line', 2719
    .lex "self", param_7216
    .lex "$/", param_7217
.annotate 'line', 2720
    find_lex $P7218, "$/"
    get_hll_global $P7219, "GLOBAL"
    nqp_get_package_through_who $P7220, $P7219, "PAST"
    get_who $P7221, $P7220
    set $P7222, $P7221["Regex"]
    find_lex $P7223, "$/"
    unless_null $P7223, vivify_3137
    $P7223 = root_new ['parrot';'Hash']
  vivify_3137:
    set $P7224, $P7223["codeblock"]
    unless_null $P7224, vivify_3138
    new $P7224, "Undef"
  vivify_3138:
    $P7225 = $P7224."ast"()
.annotate 'line', 2721
    find_lex $P7226, "$/"
    unless_null $P7226, vivify_3139
    $P7226 = root_new ['parrot';'Hash']
  vivify_3139:
    set $P7227, $P7226["zw"]
    unless_null $P7227, vivify_3140
    new $P7227, "Undef"
  vivify_3140:
    set $S7228, $P7227
    iseq $I7229, $S7228, "!"
    find_lex $P7230, "$/"
    unless_null $P7230, vivify_3141
    new $P7230, "Undef"
  vivify_3141:
    $P7231 = $P7222."new"($P7225, "zerowidth" :named("subtype"), $I7229 :named("negate"), "pastnode" :named("pasttype"), $P7230 :named("node"))
.annotate 'line', 2720
    $P7232 = $P7218."!make"($P7231)
.annotate 'line', 2719
    .return ($P7232)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>" :anon :subid("620_1305640955.436") :outer("614_1305640955.436")
    .param pmc param_7234
    .param pmc param_7235
.annotate 'line', 2725
    .lex "self", param_7234
    .lex "$/", param_7235
.annotate 'line', 2726
    find_lex $P7236, "$/"
    get_hll_global $P7237, "GLOBAL"
    nqp_get_package_through_who $P7238, $P7237, "PAST"
    get_who $P7239, $P7238
    set $P7240, $P7239["Regex"]
    find_lex $P7241, "$/"
    unless_null $P7241, vivify_3142
    $P7241 = root_new ['parrot';'Hash']
  vivify_3142:
    set $P7242, $P7241["var"]
    unless_null $P7242, vivify_3143
    new $P7242, "Undef"
  vivify_3143:
    $P7243 = $P7242."ast"()
    find_lex $P7244, "$/"
    unless_null $P7244, vivify_3144
    new $P7244, "Undef"
  vivify_3144:
    $P7245 = $P7240."new"("!INTERPOLATE_REGEX", $P7243, "subrule" :named("pasttype"), "method" :named("subtype"), $P7244 :named("node"))
    $P7246 = $P7236."!make"($P7245)
.annotate 'line', 2725
    .return ($P7246)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock" :anon :subid("621_1305640955.436") :outer("614_1305640955.436")
    .param pmc param_7248
    .param pmc param_7249
.annotate 'line', 2730
    .lex "self", param_7248
    .lex "$/", param_7249
.annotate 'line', 2731
    new $P7250, "Undef"
    .lex "$block", $P7250
.annotate 'line', 2733
    new $P7251, "Undef"
    .lex "$past", $P7251
.annotate 'line', 2731
    find_lex $P7252, "$/"
    unless_null $P7252, vivify_3145
    $P7252 = root_new ['parrot';'Hash']
  vivify_3145:
    set $P7253, $P7252["block"]
    unless_null $P7253, vivify_3146
    new $P7253, "Undef"
  vivify_3146:
    $P7254 = $P7253."ast"()
    store_lex "$block", $P7254
.annotate 'line', 2732
    find_lex $P7255, "$block"
    unless_null $P7255, vivify_3147
    new $P7255, "Undef"
  vivify_3147:
    $P7255."blocktype"("immediate")
.annotate 'line', 2734
    get_hll_global $P7256, "GLOBAL"
    nqp_get_package_through_who $P7257, $P7256, "PAST"
    get_who $P7258, $P7257
    set $P7259, $P7258["Stmts"]
.annotate 'line', 2735
    get_hll_global $P7260, "GLOBAL"
    nqp_get_package_through_who $P7261, $P7260, "PAST"
    get_who $P7262, $P7261
    set $P7263, $P7262["Op"]
.annotate 'line', 2736
    get_hll_global $P7264, "GLOBAL"
    nqp_get_package_through_who $P7265, $P7264, "PAST"
    get_who $P7266, $P7265
    set $P7267, $P7266["Var"]
    $P7268 = $P7267."new"("$/" :named("name"))
.annotate 'line', 2737
    get_hll_global $P7269, "GLOBAL"
    nqp_get_package_through_who $P7270, $P7269, "PAST"
    get_who $P7271, $P7270
    set $P7272, $P7271["Op"]
.annotate 'line', 2738
    get_hll_global $P7273, "GLOBAL"
    nqp_get_package_through_who $P7274, $P7273, "PAST"
    get_who $P7275, $P7274
    set $P7276, $P7275["Var"]
    $P7277 = $P7276."new"(unicode:"$\x{a2}" :named("name"))
    $P7278 = $P7272."new"($P7277, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2737
    $P7279 = $P7263."new"($P7268, $P7278, "bind" :named("pasttype"))
.annotate 'line', 2735
    find_lex $P7280, "$block"
    unless_null $P7280, vivify_3148
    new $P7280, "Undef"
  vivify_3148:
    $P7281 = $P7259."new"($P7279, $P7280)
.annotate 'line', 2734
    store_lex "$past", $P7281
.annotate 'line', 2746
    find_lex $P7282, "$/"
    find_lex $P7283, "$past"
    unless_null $P7283, vivify_3149
    new $P7283, "Undef"
  vivify_3149:
    $P7284 = $P7282."!make"($P7283)
.annotate 'line', 2730
    .return ($P7284)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7286"  :subid("622_1305640955.436") :outer("10_1305640955.436")
.annotate 'line', 2751
    .lex "$?PACKAGE", $P7288
    .lex "$?CLASS", $P7289
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block7300" :load :anon :subid("623_1305640955.436")
.annotate 'line', 1
    .const 'Sub' $P7302 = "10_1305640955.436" 
    $P7303 = $P7302()
    .return ($P7303)
.end

