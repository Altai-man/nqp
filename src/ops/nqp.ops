BEGIN_OPS_PREAMBLE

/* Parroty includes. */
#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"

/* 6modely includes. */
#include "../metamodel/rakudoobject.h"
#include "../metamodel/repr_registry.h"
#include "../pmc/pmc_dispatchersub.h"
#include "../pmc/pmc_nqpmultisig.h"
#include "../metamodel/multi_dispatch.h"
#include "../metamodel/serialization_context.h"
#include "pmc_sub.h"

/* Did we do the dynop setup yet?
 * XXX Relies on this happening once in a single thread at startup. */
static INTVAL initialized = 0;

/* Cached type IDs. */
static INTVAL stable_id = 0;
static INTVAL repr_id   = 0;
static INTVAL ro_id     = 0;
static INTVAL disp_id   = 0;
static INTVAL ms_id     = 0;

END_OPS_PREAMBLE

/*

=item nqp_dynop_setup()

Does various setup tasks for the benefit of the other dynops.

=cut

*/
inline op nqp_dynop_setup() :base_core {
    if (!initialized) {
        initialized = 1;

        /* Look up and cache some type IDs. */
        stable_id = pmc_type(interp, Parrot_str_new(interp, "STable", 0));
        repr_id   = pmc_type(interp, Parrot_str_new(interp, "REPR", 0));
        ro_id     = pmc_type(interp, Parrot_str_new(interp, "RakudoObject", 0));
        disp_id   = pmc_type(interp, Parrot_str_new(interp, "DispatcherSub", 0));
        ms_id     = pmc_type(interp, Parrot_str_new(interp, "NQPMultiSig", 0));

        /* Initialize the object model. */
        RakudoObject_initialize(interp);
    }
}

/*

=item get_how(obj)

Gets the HOW for a Rakudo Object.

=cut

*/
inline op get_how(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = STABLE($2)->HOW;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_how on a RakudoObject");
}

/*

=item get_what(obj)

Gets the WHAT for a Rakudo Object.

=cut

*/
inline op get_what(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = STABLE($2)->WHAT;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_what on a RakudoObject");
}

/*

=item repr_type_object_for(how, repr_name)

Creates a type object associated with the given HOW and of the given
representation.

=cut

*/
inline op repr_type_object_for(out PMC, in PMC, in STR) :base_core {
    PMC *REPR = REPR_get_by_name(interp, $3);
    $1 = REPR_STRUCT(REPR)->type_object_for(interp, REPR, $2);
}

/*

=item repr_instance_of()

Instantiates a new RakudoObject based on the given WHAT.

=cut

*/
inline op repr_instance_of(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->instance_of(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_instance_of on a RakudoObject");
}

/*

=item repr_defined()

Checks the REPRs idea of definedness.

=cut

*/
inline op repr_defined(out INT, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->defined(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_defined on a RakudoObject");
}

/*

=item repr_get_attr_int()

Gets the specified int attribute. Note that the attribute must be stored as
a native int - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_get_attr_int(out INT, in PMC, in PMC, in STR) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->get_attribute_int(interp, REPR_PMC($2), $2, $3, $4, NO_HINT);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_get_attr_int on a RakudoObject");
}

/*

=item repr_get_attr_num()

Gets the specified num attribute. Note that the attribute must be stored as
a native num - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_get_attr_int(out NUM, in PMC, in PMC, in STR) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->get_attribute_num(interp, REPR_PMC($2), $2, $3, $4, NO_HINT);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_get_attr_num on a RakudoObject");
}

/*

=item repr_get_attr_str()

Gets the specified str attribute. Note that the attribute must be stored as
a native str - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_get_attr_str(out STR, in PMC, in PMC, in STR) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->get_attribute_str(interp, REPR_PMC($2), $2, $3, $4, NO_HINT);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_get_attr_str on a RakudoObject");
}

/*

=item repr_bind_attr_int()

Binds the specified int attribute. Note that the attribute must be stored as
a native int - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_bind_attr_int(in PMC, in PMC, in STR, in INT) :base_core {
    if ($1->vtable->base_type == ro_id)
        REPR($1)->bind_attribute_int(interp, REPR_PMC($1), $1, $2, $3, NO_HINT, $4);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_bind_attr_int on a RakudoObject");
}

/*

=item repr_bind_attr_num()

Binds the specified num attribute. Note that the attribute must be stored as
a native num - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_bind_attr_num(in PMC, in PMC, in STR, in NUM) :base_core {
    if ($1->vtable->base_type == ro_id)
        REPR($1)->bind_attribute_num(interp, REPR_PMC($1), $1, $2, $3, NO_HINT, $4);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_bind_attr_num on a RakudoObject");
}

/*

=item repr_bind_attr_str()

Binds the specified str attribute. Note that the attribute must be stored as
a native str - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_bind_attr_num(in PMC, in PMC, in STR, in STR) :base_core {
    if ($1->vtable->base_type == ro_id)
        REPR($1)->bind_attribute_str(interp, REPR_PMC($1), $1, $2, $3, NO_HINT, $4);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_bind_attr_str on a RakudoObject");
}

/*

=item type_check(obj, wanted_type)

Checks if the given object's type accepts the checked type, using the
type check cache if one was published. Note, assumes that $3 is a type
object. If you're not sure that's what you have, call C<get_what> to
make sure.

=cut

*/
inline op type_check(out INT, in PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id && $3->vtable->base_type == ro_id) {
        $1 = STABLE($2)->type_check(interp, $2, $3);
    }    
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use type_check on two RakudoObjects");
    }
}


/*

=item publish_type_check_cache(WHAT, type_list)

Publishes a type check cache, to be stored in the S-Table.

=cut

*/
inline op publish_type_check_cache(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == ro_id) {
        STable *target_st = STABLE($1);
        INTVAL items      = VTABLE_elements(interp, $2);
        if (items > 0) {
            PMC    **cache    = mem_sys_allocate(sizeof(PMC *) * items);
            INTVAL i;
            for (i = 0; i < items; i++)
                cache[i] = VTABLE_get_pmc_keyed_int(interp, $2, i);
            target_st->type_check_cache = cache;
            target_st->type_check_cache_length = items;
        }
        else {
            target_st->type_check_cache = NULL;
            target_st->type_check_cache_length = 0;
        }
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "First argument to publish_type_check_cache must be a RakudoObject");
    }
}


/*

=item publish_method_cache(WHAT, method_cache_hash)

Publishes a method dispatch cache - essentially, a set of name to code object
mappings.

=cut

*/
inline op publish_method_cache(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == ro_id) {
        /* We copy the cache items to a Parrot hash to avoid making
         * calls into the language's own hash implementation every
         * time, which may be far more costly. */
        STable *target_st = STABLE($1);
        PMC    *cache     = pmc_new(interp, enum_class_Hash);
        PMC    *iter      = VTABLE_get_iter(interp, $2);
        while (VTABLE_get_bool(interp, iter)) {
            STRING *name = VTABLE_shift_string(interp, iter);
            PMC    *meth = VTABLE_get_pmc_keyed_str(interp, $2, name);
            VTABLE_set_pmc_keyed_str(interp, cache, name, meth);
        }
        target_st->method_cache = cache;
        PARROT_GC_WRITE_BARRIER(interp, STABLE_PMC($1));
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "First argument to publish_method_cache must be a RakudoObject");
    }
}


/*

=item repr_unbox_str()

Tries to unbox a native string using the REPR API.

=cut

*/
inline op repr_unbox_str(out STR, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->get_str(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_unbox_str on a RakudoObject");
}

/*

=item repr_unbox_int()

Tries to unbox a native integer using the REPR API.

=cut

*/
inline op repr_unbox_int(out INT, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->get_int(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_unbox_int on a RakudoObject");
}

/*

=item repr_unbox_num()

Tries to unbox a native floating pint number using the REPR API.

=cut

*/
inline op repr_unbox_num(out NUM, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->get_num(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_unbox_num on a RakudoObject");
}

/*

=item repr_box_str()

Box a native string to an instance of the specified type.

=cut

*/
inline op repr_box_str(out PMC, in STR, in PMC) :base_core {
    if ($3->vtable->base_type == ro_id) {
        $1 = REPR($3)->instance_of(interp, REPR_PMC($3), $3);
        REPR($1)->set_str(interp, REPR_PMC($1), $1, $2);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_box_str with a RakudoObject as the box target");
}

/*

=item repr_box_int()

Box a native int to an instance of the specified type.

=cut

*/
inline op repr_box_int(out PMC, in INT, in PMC) :base_core {
    if ($3->vtable->base_type == ro_id) {
        $1 = REPR($3)->instance_of(interp, REPR_PMC($3), $3);
        REPR($1)->set_int(interp, REPR_PMC($1), $1, $2);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_box_int with a RakudoObject as the box target");
}

/*

=item repr_box_num()

Box a native floating point number to an instance of the specified type.

=cut

*/
inline op repr_box_num(out PMC, in NUM, in PMC) :base_core {
    if ($3->vtable->base_type == ro_id) {
        $1 = REPR($3)->instance_of(interp, REPR_PMC($3), $3);
        REPR($1)->set_num(interp, REPR_PMC($1), $1, $2);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_box_num with a RakudoObject as the box target");
}

/*

=item multi_dispatch_over_lexical_candidates()

Entry point to multi-dispatch over the current dispatchee list.

=cut

*/
inline op multi_dispatch_over_lexical_candidates(out PMC) :base_core {
    INTVAL done = 0;
    PMC *cur_ctx = CURRENT_CONTEXT(interp);
    while (!PMC_IS_NULL(cur_ctx)) {
        Parrot_Context *ctx_struct = CONTEXT_STRUCT(cur_ctx);
        if (ctx_struct->current_sub->vtable->base_type == disp_id) {
            /* Found a dispatcher. Enter the multi-dispatcher to find a the
             * best candidate, if any. */
            PMC *chosen = nqp_multi_dispatch(interp, ctx_struct->current_sub, cur_ctx);
            if (!PMC_IS_NULL(chosen)) {
                /* Invoke the chosen candidate using a copy of the original args. */
                PMC *arg_copy = VTABLE_clone(interp, cur_ctx);
                PMC *result;
                PMC *prev_ctx = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
                Parrot_pcc_invoke_from_sig_object(interp, chosen, arg_copy);
                result = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
                Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), prev_ctx);
                $1 = VTABLE_get_pmc_keyed_int(interp, result, 0);
            }
            else {
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                        "Multiple dispatcher returned a null candidate.");
            }
            done = 1;
            break;
        }
        cur_ctx = ctx_struct->outer_ctx;
    }
    if (!done)
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "multi_dispatch_over_lexical_candidates was unable to find a candidate list");
}

/*

=item set_dispatchees()

Sets the dispatchees of the code object in $1, which must be a DispatcherSub,
to the array in $2.

=cut

*/
inline op set_dispatchees(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == disp_id)
        PARROT_DISPATCHERSUB($1)->dispatchees = $2;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use set_dispatchees if first operand is a DispatcherSub.");
}

/*

=item create_dispatch_and_add_candidates()

Creates an instantiation of the dispatch routine (or proto, which may
serve as one) supplied and augments it with the provided candidates.
It relies on being passed the instantiation of the dispatcher from the
last outer scope that had an instantiation, and we thus take its
candidates.

$1 will be set to the new, augmented dispatch routine. $2 is the proto
or instantiation of it to clone. $3 is an array of candidates to add.

=cut

*/
inline op create_dispatch_and_add_candidates(out PMC, in PMC, in PMC) :base_core {
    /* Ensure we have a dispatcher. */
    if ($2->vtable->base_type == disp_id) {
        /* Copy it (which makes an "instance") and add new candidates. */
        PMC *  copy   = VTABLE_clone(interp, $2);
        INTVAL i      = 0;
        INTVAL to_add = VTABLE_elements(interp, $3);
        PARROT_DISPATCHERSUB(copy)->dispatchees = VTABLE_clone(interp,
                PARROT_DISPATCHERSUB($2)->dispatchees);
        for (i = 0; i < to_add; i++)
            VTABLE_push_pmc(interp, PARROT_DISPATCHERSUB(copy)->dispatchees,
                    VTABLE_get_pmc_keyed_int(interp, $3, i));
        $1 = copy;
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use create_dispatch_and_add_candidates if first operand is a DispatcherSub.");
}

/*

=item push_dispatchee()

Adds a single new code object to the end of a dispatcher's dispatchee list.

=cut

*/
inline op push_dispatchee(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == disp_id)
        VTABLE_push_pmc(interp, PARROT_DISPATCHERSUB($1)->dispatchees, $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use push_dispatchee if first operand is a DispatcherSub.");
}

/*

=item is_dispatcher()

Checks if a routine is considered a dispatcher (that is, if it has a
list of dispatchees).

=cut

*/
inline op is_dispatcher(out INT, in PMC) :base_core {
    $1 = $2->vtable->base_type == disp_id && 
            !PMC_IS_NULL(PARROT_DISPATCHERSUB($2)->dispatchees);
}

/*

=item set_sub_multisig()

Sets a sub's multi_signature. $1 is the sub, $2 is an array of type objects
and $3 is is an array of definedness constraint descriptors.

=cut

*/
inline op set_sub_multisig(in PMC, in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == enum_class_Sub) {
        PMC *sig = Parrot_pmc_new(interp, ms_id);
        SETATTR_NQPMultiSig_types(interp, sig, $2);
        SETATTR_NQPMultiSig_definedness_constraints(interp, sig, $3);
        SETATTR_Sub_multi_signature(interp, $1, sig);
        PARROT_GC_WRITE_BARRIER(interp, $1);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use set_sub_multisig if first operand is a Sub.");
}

/*

=item publish_vtable_mapping()

Publishes a Parrot v-table mapping, which will be hung off the s-table.
It's stored as an array, so lookups will be speedy.

=cut

*/
inline op stable_publish_vtable_mapping(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == ro_id) {
        INTVAL i;

        /* Get s-table and iterator over the mapping. */
        STable *st = STABLE($1);
        PMC    *it = VTABLE_get_iter(interp, $2);

        /* Toss any exist mapping array; allocate new one. */
        if (st->parrot_vtable_mapping)
            mem_sys_free(st->parrot_vtable_mapping);
        st->parrot_vtable_mapping = mem_allocate_n_zeroed_typed(NUM_VTABLE_FUNCTIONS, PMC *);

        /* Go through the various mapped names and insert them into the
         * mapping table. */
        while (VTABLE_get_bool(interp, it)) {
            STRING *name   = VTABLE_shift_string(interp, it);
            char   *c_name = Parrot_str_to_cstring(interp, name);
            PMC    *meth   = VTABLE_get_pmc_keyed_str(interp, $2, name);
            INTVAL  idx    = -1;
            for (i = PARROT_VTABLE_LOW; i < NUM_VTABLE_FUNCTIONS; i++) {
                if (strcmp(Parrot_vtable_slot_names[i], c_name) == 0) {
                    idx = i;
                    break;
                }
            }
            if (idx >= 0)
                st->parrot_vtable_mapping[idx] = meth;
            else
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                    "No such Parrot v-table '%Ss'", name);
        }
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use stable_publish_vtable_mapping with a RakudoObject");
}

/*

=item nqp_get_sc_object()

Fetches an object from the serialization context keyed by handle and index.

=cut

*/
inline op nqp_get_sc_object(out PMC, in STR, in INT) :base_core {
    PMC *sc = SC_get_sc(interp, $2);
    if (!PMC_IS_NULL(sc))
        $1 = VTABLE_get_pmc_keyed_int(interp, sc, $3);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Cannot fetch object from non-existance serialization context %Ss",
            $2);
}

/*

=item nqp_get_sc()

Gets the serialization context with the specified handle. Returns
NULL if it does not exist.

=cut

*/
inline op nqp_get_sc(out PMC, in STR) {
    $1 = SC_get_sc(interp, $2);
}

/*

=item nqp_create_sc()

Creates a serialization context with the specified handle, adds it
to the registry and returns it.

=cut

*/
inline op nqp_create_sc(out PMC, in STR) {
    $1 = pmc_new(interp, pmc_type(interp,
        Parrot_str_new(interp, "SerializationContext", 0)));
    VTABLE_set_string_native(interp, $1, $2);
    SC_set_sc(interp, $2, $1);
}

/*

=item nqp_set_sc_object()

Stores an object in the serialization context keyed by handle and index.

=cut

*/
inline op nqp_set_sc_object(in STR, in INT, in PMC) :base_core {
    PMC *sc = SC_get_sc(interp, $1);
    if (!PMC_IS_NULL(sc))
        VTABLE_set_pmc_keyed_int(interp, sc, $2, $3);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Cannot fetch object from non-existance serialization context %Ss",
            $1);
}

/*

=item nqp_set_sc_for_object()

Sets an object's serialization context.

=cut

*/
inline op nqp_set_sc_for_object(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == ro_id)
        SC_PMC($1) = $2;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use nqp_set_sc_for_object with a RakudoObject");
}

/*

=item nqp_get_sc_for_object()

Gets an object's serialization context. Returns NULL if there
is none.

=cut

*/
inline op nqp_get_sc_for_object(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = SC_PMC($2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use nqp_get_sc_for_object with a RakudoObject");
}
