BEGIN_OPS_PREAMBLE

/* Parroty includes. */
#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"

/* 6modely includes. */
#include "../metamodel/rakudoobject.h"
#include "../metamodel/repr_registry.h"

/* Cached type IDs. */
static INTVAL stable_id = 0;
static INTVAL repr_id   = 0;
static INTVAL ro_id     = 0;

END_OPS_PREAMBLE

/*

=item nqp_dynop_setup()

Does various setup tasks for the benefit of the other dynops.

=cut

*/
inline op nqp_dynop_setup() :base_core {
    /* Look up and cache some type IDs. */
    stable_id = pmc_type(interp, Parrot_str_new(interp, "STable", 0));
    repr_id   = pmc_type(interp, Parrot_str_new(interp, "REPR", 0));
    ro_id     = pmc_type(interp, Parrot_str_new(interp, "RakudoObject", 0));

    /* Initialize the object model. */
    RakudoObject_initialize(interp);
}

/*

=item get_how(obj)

Gets the HOW for a Rakudo Object.

=cut

*/
inline op get_how(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = STABLE($2)->HOW;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_how on a RakudoObject");
}

/*

=item get_what(obj)

Gets the WHAT for a Rakudo Object.

=cut

*/
inline op get_what(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = STABLE($2)->WHAT;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_what on a RakudoObject");
}

/*

=item repr_type_object_for(how, repr_name)

Creates a type object associated with the given HOW and of the given
representation.

=cut

*/
inline op repr_type_object_for(out PMC, in PMC, in STR) :base_core {
    PMC *REPR = REPR_get_by_name(interp, $3);
    $1 = REPR_STRUCT(REPR)->type_object_for(interp, REPR, $2);
}

/*

=item repr_instance_of()

Instantiates a new RakudoObject based on the given WHAT.

=cut

*/
inline op repr_instance_of(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->instance_of(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_instance_of on a RakudoObject");
}

/*

=item repr_defined()

Checks the REPRs idea of definedness.

=cut

*/
inline op repr_defined(out INT, in PMC) :base_core {
    if ($2->vtable->base_type == ro_id)
        $1 = REPR($2)->defined(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_defined on a RakudoObject");
}
