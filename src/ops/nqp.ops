BEGIN_OPS_PREAMBLE

/* Parroty includes. */
#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"

/* 6modely includes. */
#include "../6model/sixmodelobject.h"
#include "../6model/repr_registry.h"
#include "../pmc/pmc_dispatchersub.h"
#include "../pmc/pmc_nqpmultisig.h"
#include "../6model/multi_dispatch.h"
#include "../6model/serialization_context.h"
#include "pmc_sub.h"

/* Did we do the dynop setup yet?
 * XXX Relies on this happening once in a single thread at startup. */
static INTVAL initialized = 0;

/* Cached type IDs. */
static INTVAL stable_id = 0;
static INTVAL repr_id   = 0;
static INTVAL smo_id    = 0;
static INTVAL disp_id   = 0;
static INTVAL ms_id     = 0;

/* Built-in meta-objects. */
static PMC *KnowHOW = NULL;
static PMC *KnowHOWAttribute = NULL;

END_OPS_PREAMBLE

/*

=item nqp_dynop_setup()

Does various setup tasks for the benefit of the other dynops.

=cut

*/
inline op nqp_dynop_setup() :base_core {
    if (!initialized) {
        initialized = 1;

        /* Look up and cache some type IDs. */
        stable_id = pmc_type(interp, Parrot_str_new(interp, "STable", 0));
        repr_id   = pmc_type(interp, Parrot_str_new(interp, "REPR", 0));
        smo_id    = pmc_type(interp, Parrot_str_new(interp, "SixModelObject", 0));
        disp_id   = pmc_type(interp, Parrot_str_new(interp, "DispatcherSub", 0));
        ms_id     = pmc_type(interp, Parrot_str_new(interp, "NQPMultiSig", 0));

        /* Initialize the object model. */
        SixModelObject_initialize(interp, &KnowHOW, &KnowHOWAttribute);
    }
}


/*

=item get_knowhow()

Returns the 6model core meta-object, KnowHOW.

=cut

*/
inline op get_knowhow(out PMC) :base_core {
    if (KnowHOW)
        $1 = KnowHOW;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "6model not yet initialized; cannot use get_knowhow");
}


/*

=item get_knowhow_attribute()

Returns the 6model core meta-attribute, KnowHOWAttribute.

=cut

*/
inline op get_knowhow_attribute(out PMC) :base_core {
    if (KnowHOWAttribute)
        $1 = KnowHOWAttribute;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "6model not yet initialized; cannot use get_knowhow_attribute");
}


/*

=item get_how(obj)

Gets the HOW for a 6model Object.

=cut

*/
inline op get_how(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = STABLE($2)->HOW;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_how on a SixModelObject");
}

/*

=item get_what(obj)

Gets the WHAT for a 6model Object.

=cut

*/
inline op get_what(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = STABLE($2)->WHAT;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_what on a SixModelObject");
}

/*

=item get_who(obj)

Gets the WHO for a 6model Object.

=cut

*/
inline op get_who(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = STABLE($2)->WHO;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_who on a SixModelObject");
}

/*

=item set_who(obj)

Sets the WHO for a 6model Object.

=cut

*/
inline op set_who(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == smo_id) {
        STABLE($1)->WHO = $2;
        PARROT_GC_WRITE_BARRIER(interp, STABLE_PMC($1));
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use set_who on a SixModelObject");
}

/*

=item repr_type_object_for(how, repr_name)

Creates a type object associated with the given HOW and of the given
representation.

=cut

*/
inline op repr_type_object_for(out PMC, in PMC, in STR) :base_core {
    PMC *REPR = REPR_get_by_name(interp, $3);
    $1 = REPR_STRUCT(REPR)->type_object_for(interp, REPR, $2);
}

/*

=item repr_instance_of()

Instantiates a new object based on the given WHAT.

=cut

*/
inline op repr_instance_of(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->instance_of(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_instance_of on a SixModelObject");
}

/*

=item repr_defined()

Checks the REPRs idea of definedness.

=cut

*/
inline op repr_defined(out INT, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->defined(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_defined on a SixModelObject");
}

/*

=item repr_get_attr_int()

Gets the specified int attribute. Note that the attribute must be stored as
a native int - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_get_attr_int(out INT, in PMC, in PMC, in STR) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->get_attribute_int(interp, REPR_PMC($2), $2, $3, $4, NO_HINT);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_get_attr_int on a SixModelObject");
}

/*

=item repr_get_attr_num()

Gets the specified num attribute. Note that the attribute must be stored as
a native num - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_get_attr_int(out NUM, in PMC, in PMC, in STR) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->get_attribute_num(interp, REPR_PMC($2), $2, $3, $4, NO_HINT);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_get_attr_num on a SixModelObject");
}

/*

=item repr_get_attr_str()

Gets the specified str attribute. Note that the attribute must be stored as
a native str - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_get_attr_str(out STR, in PMC, in PMC, in STR) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->get_attribute_str(interp, REPR_PMC($2), $2, $3, $4, NO_HINT);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_get_attr_str on a SixModelObject");
}

/*

=item repr_bind_attr_int()

Binds the specified int attribute. Note that the attribute must be stored as
a native int - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_bind_attr_int(in PMC, in PMC, in STR, in INT) :base_core {
    if ($1->vtable->base_type == smo_id)
        REPR($1)->bind_attribute_int(interp, REPR_PMC($1), $1, $2, $3, NO_HINT, $4);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_bind_attr_int on a SixModelObject");
}

/*

=item repr_bind_attr_num()

Binds the specified num attribute. Note that the attribute must be stored as
a native num - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_bind_attr_num(in PMC, in PMC, in STR, in NUM) :base_core {
    if ($1->vtable->base_type == smo_id)
        REPR($1)->bind_attribute_num(interp, REPR_PMC($1), $1, $2, $3, NO_HINT, $4);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_bind_attr_num on a SixModelObject");
}

/*

=item repr_bind_attr_str()

Binds the specified str attribute. Note that the attribute must be stored as
a native str - the repr is not obligated to do boxing/unboxing for you.

=cut

*/
inline op repr_bind_attr_str(in PMC, in PMC, in STR, in STR) :base_core {
    if ($1->vtable->base_type == smo_id)
        REPR($1)->bind_attribute_str(interp, REPR_PMC($1), $1, $2, $3, NO_HINT, $4);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_bind_attr_str on a SixModelObject");
}

/*

=item type_check(obj, wanted_type)

Checks if the given object's type accepts the checked type, using the
type check cache if one was published. Note, assumes that $3 is a type
object. If you're not sure that's what you have, call C<get_what> to
make sure.

=cut

*/
inline op type_check(out INT, in PMC, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id && $3->vtable->base_type == smo_id) {
        $1 = STABLE($2)->type_check(interp, $2, $3);
    }    
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use type_check on two SixModelObjects");
    }
}


/*

=item publish_type_check_cache(WHAT, type_list)

Publishes a type check cache, to be stored in the S-Table.

=cut

*/
inline op publish_type_check_cache(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == smo_id) {
        STable *target_st = STABLE($1);
        INTVAL items      = VTABLE_elements(interp, $2);
        if (items > 0) {
            PMC    **cache    = mem_sys_allocate(sizeof(PMC *) * items);
            INTVAL i;
            for (i = 0; i < items; i++)
                cache[i] = VTABLE_get_pmc_keyed_int(interp, $2, i);
            target_st->type_check_cache = cache;
            target_st->type_check_cache_length = items;
        }
        else {
            target_st->type_check_cache = NULL;
            target_st->type_check_cache_length = 0;
        }
        PARROT_GC_WRITE_BARRIER(interp, STABLE_PMC($1));
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "First argument to publish_type_check_cache must be a SixModelObject");
    }
}


/*

=item publish_method_cache(WHAT, method_cache_hash)

Publishes a method dispatch cache - essentially, a set of name to code object
mappings.

=cut

*/
inline op publish_method_cache(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == smo_id) {
        /* We copy the cache items to a Parrot hash to avoid making
         * calls into the language's own hash implementation every
         * time, which may be far more costly. */
        STable *target_st = STABLE($1);
        PMC    *cache     = pmc_new(interp, enum_class_Hash);
        PMC    *iter      = VTABLE_get_iter(interp, $2);
        while (VTABLE_get_bool(interp, iter)) {
            STRING *name = VTABLE_shift_string(interp, iter);
            PMC    *meth = VTABLE_get_pmc_keyed_str(interp, $2, name);
            VTABLE_set_pmc_keyed_str(interp, cache, name, meth);
        }
        target_st->method_cache = cache;
        PARROT_GC_WRITE_BARRIER(interp, STABLE_PMC($1));
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "First argument to publish_method_cache must be a SixModelObject");
    }
}


/*

=item repr_unbox_str()

Tries to unbox a native string using the REPR API.

=cut

*/
inline op repr_unbox_str(out STR, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->get_str(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_unbox_str on a SixModelObject");
}

/*

=item repr_unbox_int()

Tries to unbox a native integer using the REPR API.

=cut

*/
inline op repr_unbox_int(out INT, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->get_int(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_unbox_int on a SixModelObject");
}

/*

=item repr_unbox_num()

Tries to unbox a native floating pint number using the REPR API.

=cut

*/
inline op repr_unbox_num(out NUM, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = REPR($2)->get_num(interp, REPR_PMC($2), $2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_unbox_num on a SixModelObject");
}

/*

=item repr_box_str()

Box a native string to an instance of the specified type.

=cut

*/
inline op repr_box_str(out PMC, in STR, in PMC) :base_core {
    if ($3->vtable->base_type == smo_id) {
        $1 = REPR($3)->instance_of(interp, REPR_PMC($3), $3);
        REPR($1)->set_str(interp, REPR_PMC($1), $1, $2);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_box_str with a SixModelObject as the box target");
}

/*

=item repr_box_int()

Box a native int to an instance of the specified type.

=cut

*/
inline op repr_box_int(out PMC, in INT, in PMC) :base_core {
    if ($3->vtable->base_type == smo_id) {
        $1 = REPR($3)->instance_of(interp, REPR_PMC($3), $3);
        REPR($1)->set_int(interp, REPR_PMC($1), $1, $2);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_box_int with a SixModelObject as the box target");
}

/*

=item repr_box_num()

Box a native floating point number to an instance of the specified type.

=cut

*/
inline op repr_box_num(out PMC, in NUM, in PMC) :base_core {
    if ($3->vtable->base_type == smo_id) {
        $1 = REPR($3)->instance_of(interp, REPR_PMC($3), $3);
        REPR($1)->set_num(interp, REPR_PMC($1), $1, $2);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use repr_box_num with a SixModelObject as the box target");
}

/*

=item multi_dispatch_over_lexical_candidates()

Entry point to multi-dispatch over the current dispatchee list.

=cut

*/
inline op multi_dispatch_over_lexical_candidates(out PMC) :base_core {
    INTVAL done = 0;
    PMC *cur_ctx = CURRENT_CONTEXT(interp);
    while (!PMC_IS_NULL(cur_ctx)) {
        Parrot_Context *ctx_struct = CONTEXT_STRUCT(cur_ctx);
        if (ctx_struct->current_sub->vtable->base_type == disp_id) {
            /* Found a dispatcher. Enter the multi-dispatcher to find a the
             * best candidate, if any. */
            PMC *chosen = nqp_multi_dispatch(interp, ctx_struct->current_sub, cur_ctx);
            if (!PMC_IS_NULL(chosen)) {
                /* Invoke the chosen candidate using a copy of the original args. */
                PMC *arg_copy = VTABLE_clone(interp, cur_ctx);
                PMC *result;
                PMC *prev_ctx = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
                Parrot_pcc_invoke_from_sig_object(interp, chosen, arg_copy);
                result = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
                Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), prev_ctx);
                $1 = VTABLE_get_pmc_keyed_int(interp, result, 0);
            }
            else {
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                        "Multiple dispatcher returned a null candidate.");
            }
            done = 1;
            break;
        }
        cur_ctx = ctx_struct->outer_ctx;
    }
    if (!done)
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "multi_dispatch_over_lexical_candidates was unable to find a candidate list");
}

/*

=item set_dispatchees()

Sets the dispatchees of the code object in $1, which must be a DispatcherSub,
to the array in $2.

=cut

*/
inline op set_dispatchees(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == disp_id) {
        PARROT_DISPATCHERSUB($1)->dispatchees = $2;
        PARROT_GC_WRITE_BARRIER(interp, $1);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use set_dispatchees if first operand is a DispatcherSub.");
}

/*

=item create_dispatch_and_add_candidates()

Creates an instantiation of the dispatch routine (or proto, which may
serve as one) supplied and augments it with the provided candidates.
It relies on being passed the instantiation of the dispatcher from the
last outer scope that had an instantiation, and we thus take its
candidates.

$1 will be set to the new, augmented dispatch routine. $2 is the proto
or instantiation of it to clone. $3 is an array of candidates to add.

=cut

*/
inline op create_dispatch_and_add_candidates(out PMC, in PMC, in PMC) :base_core {
    /* Ensure we have a dispatcher. */
    if ($2->vtable->base_type == disp_id) {
        /* Copy it (which makes an "instance") and add new candidates. */
        PMC *  copy   = VTABLE_clone(interp, $2);
        INTVAL i      = 0;
        INTVAL to_add = VTABLE_elements(interp, $3);
        PARROT_DISPATCHERSUB(copy)->dispatchees = VTABLE_clone(interp,
                PARROT_DISPATCHERSUB($2)->dispatchees);
        PARROT_GC_WRITE_BARRIER(interp, copy);
        for (i = 0; i < to_add; i++)
            VTABLE_push_pmc(interp, PARROT_DISPATCHERSUB(copy)->dispatchees,
                    VTABLE_get_pmc_keyed_int(interp, $3, i));
        $1 = copy;
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use create_dispatch_and_add_candidates if first operand is a DispatcherSub.");
}

/*

=item push_dispatchee()

Adds a single new code object to the end of a dispatcher's dispatchee list.

=cut

*/
inline op push_dispatchee(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == disp_id) {
        if (PMC_IS_NULL(PARROT_DISPATCHERSUB($1)->dispatchees)) {
            PARROT_DISPATCHERSUB($1)->dispatchees = pmc_new(interp, enum_class_ResizablePMCArray);
            PARROT_GC_WRITE_BARRIER(interp, $1);
        }
        VTABLE_push_pmc(interp, PARROT_DISPATCHERSUB($1)->dispatchees, $2);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use push_dispatchee if first operand is a DispatcherSub.");
}

/*

=item is_dispatcher()

Checks if a routine is considered a dispatcher (that is, if it has a
list of dispatchees).

=cut

*/
inline op is_dispatcher(out INT, in PMC) :base_core {
    $1 = $2->vtable->base_type == disp_id;
}

/*

=item set_sub_multisig()

Sets a sub's multi_signature. $1 is the sub, $2 is an array of type objects
and $3 is is an array of definedness constraint descriptors.

=cut

*/
inline op set_sub_multisig(in PMC, in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == enum_class_Sub) {
        PMC *sig = Parrot_pmc_new(interp, ms_id);
        SETATTR_NQPMultiSig_types(interp, sig, $2);
        SETATTR_NQPMultiSig_definedness_constraints(interp, sig, $3);
        SETATTR_Sub_multi_signature(interp, $1, sig);
        PARROT_GC_WRITE_BARRIER(interp, $1);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use set_sub_multisig if first operand is a Sub.");
}

/*

=item publish_vtable_mapping()

Publishes a Parrot v-table mapping, which will be hung off the s-table.
It's stored as an array, so lookups will be speedy.

=cut

*/
inline op stable_publish_vtable_mapping(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == smo_id) {
        INTVAL i;

        /* Get s-table and iterator over the mapping. */
        STable *st = STABLE($1);
        PMC    *it = VTABLE_get_iter(interp, $2);

        /* Toss any exist mapping array; allocate new one. */
        if (st->parrot_vtable_mapping)
            mem_sys_free(st->parrot_vtable_mapping);
        st->parrot_vtable_mapping = mem_allocate_n_zeroed_typed(NUM_VTABLE_FUNCTIONS + PARROT_VTABLE_LOW, PMC *);

        /* Go through the various mapped names and insert them into the
         * mapping table. */
        while (VTABLE_get_bool(interp, it)) {
            STRING *name   = VTABLE_shift_string(interp, it);
            char   *c_name = Parrot_str_to_cstring(interp, name);
            PMC    *meth   = VTABLE_get_pmc_keyed_str(interp, $2, name);
            INTVAL  idx    = -1;
            for (i = PARROT_VTABLE_LOW; i < NUM_VTABLE_FUNCTIONS + PARROT_VTABLE_LOW; i++) {
                if (strcmp(Parrot_vtable_slot_names[i], c_name) == 0) {
                    idx = i;
                    break;
                }
            }
            if (idx >= 0)
                st->parrot_vtable_mapping[idx] = meth;
            else
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                    "No such Parrot v-table '%Ss'", name);
        }
        
        PARROT_GC_WRITE_BARRIER(interp, STABLE_PMC($1));
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use stable_publish_vtable_mapping with a SixModelObject");
}

/*
=item publish_vtable_handler_mapping()

Publishes a Parrot v-table handler mapping, which will be hung off the s-table.
It's stored as an array, so lookups will be speedy.

=cut

*/
inline op stable_publish_vtable_handler_mapping(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == smo_id) {
        INTVAL i;

        /* Get s-table and iterator over the mapping. */
        STable *st = STABLE($1);
        PMC    *it = VTABLE_get_iter(interp, $2);

        /* Toss any exist mapping array; allocate new one. */
        if (st->parrot_vtable_handler_mapping)
            mem_sys_free(st->parrot_vtable_handler_mapping);
        st->parrot_vtable_handler_mapping = mem_allocate_n_zeroed_typed(NUM_VTABLE_FUNCTIONS + PARROT_VTABLE_LOW, ParrotVtableHandlerSlot);

        /* Go through the various mapped names and insert them into the
         * mapping table. */
        while (VTABLE_get_bool(interp, it)) {
            STRING *name   = VTABLE_shift_string(interp, it);
            char   *c_name = Parrot_str_to_cstring(interp, name);
            PMC    *slot   = VTABLE_get_pmc_keyed_str(interp, $2, name);
            INTVAL  idx    = -1;
            for (i = PARROT_VTABLE_LOW; i < NUM_VTABLE_FUNCTIONS + PARROT_VTABLE_LOW; i++) {
                if (strcmp(Parrot_vtable_slot_names[i], c_name) == 0) {
                    idx = i;
                    break;
                }
            }
            if (idx >= 0) {
                st->parrot_vtable_handler_mapping[idx].class_handle = VTABLE_get_pmc_keyed_int(interp,slot,0);
                st->parrot_vtable_handler_mapping[idx].att_name = VTABLE_get_string_keyed_int(interp,slot,1);
            }
			else
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                    "No such Parrot v-table '%Ss'", name);
        }

        PARROT_GC_WRITE_BARRIER(interp, STABLE_PMC($1));
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use stable_publish_vtable_handler_mapping with a SixModelObject");
}

/*

=item nqp_get_sc_object()

Fetches an object from the serialization context keyed by handle and index.

=cut

*/
inline op nqp_get_sc_object(out PMC, in STR, in INT) :base_core {
    PMC *sc = SC_get_sc(interp, $2);
    if (!PMC_IS_NULL(sc))
        $1 = VTABLE_get_pmc_keyed_int(interp, sc, $3);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Cannot fetch object from non-existant serialization context %Ss",
            $2);
}

/*

=item nqp_get_sc()

Gets the serialization context with the specified handle. Returns
NULL if it does not exist.

=cut

*/
inline op nqp_get_sc(out PMC, in STR) {
    $1 = SC_get_sc(interp, $2);
}

/*

=item nqp_create_sc()

Creates a serialization context with the specified handle, adds it
to the registry and returns it.

=cut

*/
inline op nqp_create_sc(out PMC, in STR) {
    $1 = pmc_new(interp, pmc_type(interp,
        Parrot_str_new(interp, "SerializationContext", 0)));
    VTABLE_set_string_native(interp, $1, $2);
    SC_set_sc(interp, $2, $1);
}

/*

=item nqp_set_sc_object()

Stores an object in the serialization context keyed by handle and index.

=cut

*/
inline op nqp_set_sc_object(in STR, in INT, in PMC) :base_core {
    PMC *sc = SC_get_sc(interp, $1);
    if (!PMC_IS_NULL(sc))
        VTABLE_set_pmc_keyed_int(interp, sc, $2, $3);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Cannot fetch object from non-existant serialization context %Ss",
            $1);
}

/*

=item nqp_set_sc_for_object()

Sets an object's serialization context.

=cut

*/
inline op nqp_set_sc_for_object(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == smo_id) {
        SC_PMC($1) = $2;
        PARROT_GC_WRITE_BARRIER(interp, $1);
    }
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use nqp_set_sc_for_object with a SixModelObject");
}

/*

=item nqp_get_sc_for_object()

Gets an object's serialization context. Returns NULL if there
is none.

=cut

*/
inline op nqp_get_sc_for_object(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = SC_PMC($2);
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use nqp_get_sc_for_object with a SixModelObject");
}


/*

=item nqp_get_package_through_who

Takes a type object and uses its associated symbol table (in .WHO)
to look for a package within it. It will auto-vivify the package if
non exists.

=cut

*/
inline op nqp_get_package_through_who(out PMC, in PMC, in STR) :base_core {
    if ($2->vtable->base_type == smo_id) {
        PMC *who = STABLE($2)->WHO;
        PMC *pkg = VTABLE_get_pmc_keyed_str(interp, who, $3);
        if (PMC_IS_NULL(pkg)) {
            /* Create the package object. This is just like a call:
             * pkg = KnowHOW.new_type(:name($3))
             * XXX For now just create a KnowHOW; we can switch to a lighter
             * package temp type later. */
            PMC *old_ctx = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
            PMC *meth    = VTABLE_find_method(interp, KnowHOW, Parrot_str_new(interp, "new_type", 0));
            PMC *cappy   = Parrot_pmc_new(interp, enum_class_CallContext);
            VTABLE_push_pmc(interp, cappy, KnowHOW);
            VTABLE_set_string_keyed_str(interp, cappy, Parrot_str_new(interp, "name", 0), $3);
            Parrot_pcc_invoke_from_sig_object(interp, meth, cappy);
            cappy = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
            Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), old_ctx);
            pkg = VTABLE_get_pmc_keyed_int(interp, cappy, 0);
            
            /* Install it in the outer package's .WHO. */
            VTABLE_set_pmc_keyed_str(interp, who, $3, pkg);
        }
        $1 = pkg;
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use nqp_get_package_through_who with a SixModelObject");
    }
}

/*

=item is_invokable

Checks if we have something that overrides the Parrot invoke v-table or
is not a 6model object must is otherwise marked invokable.

=cut

*/
inline op is_invokable(out INT, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id) {
        PMC **vt = STABLE($2)->parrot_vtable_mapping;
        $1 = vt && !PMC_IS_NULL(vt[PARROT_VTABLE_SLOT_INVOKE]);
    }
    else {
        $1 = VTABLE_does(interp, $2, Parrot_str_new(interp, "invokable", 0));
    }
}

/*

=item repr_get_primitive_type_spec

If the representation represents a primitive type that we can store access
unboxed, this will return what sort of primitive type it is.

=cut

*/
inline op repr_get_primitive_type_spec(out INT, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id) {
        storage_spec ss = REPR($2)->get_storage_spec(interp, REPR_PMC($2));
        $1 = ss.inlineable ? ss.boxed_primitive : STORAGE_SPEC_BP_NONE;
    }
    else {
        $1 = STORAGE_SPEC_BP_NONE;
    }
}
