BEGIN_OPS_PREAMBLE

/* Parroty includes. */
#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"
#include "../6model/sixmodelobject.h"
#include "../6model/reprs/P6bigint.h"

static mp_int * get_bigint(PARROT_INTERP, PMC *obj) {
    /* XXX sanity checks... */
    return &((P6bigintInstance *)PMC_data(obj))->i;
}

END_OPS_PREAMBLE

/*
 * The ops in here mostly just delegate off to libtommath. nqp_bigint_setup must be
 * called before you create any types using the bigint representation. For all of the
 * rest ops there are two variants. The first variant simply takes two objects and
 * assumes they directly use the P6bigint REPR; the second one pulls out an (inlined)
 * P6bigint attribute and works on that; this avoids the overhead of creating a boxed
 * version only to throw it away again.
 */

inline op nqp_bigint_setup() :base_core {
    /* Register the bigint representation. */
    REGISTER_DYNAMIC_REPR(interp,
        Parrot_str_new_constant(interp, "P6bigint"),
        P6bigint_initialize);
}

inline op nqp_bigint_add(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_add(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_sub(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_sub(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_mul(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_mul(a, b, get_bigint(interp, $1));
}
