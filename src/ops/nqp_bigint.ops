BEGIN_OPS_PREAMBLE

/* Parroty includes. */
#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"
#include "../6model/sixmodelobject.h"
#include "../6model/reprs/P6bigint.h"

/* The ID of the bigint REPR. */
static INTVAL bigint_repr_id = 0;

static mp_int * get_bigint(PARROT_INTERP, PMC *obj) {
    struct SixModel_REPROps *r = REPR(obj);
    if (r->ID == bigint_repr_id)
        return &((P6bigintInstance *)PMC_data(obj))->body.i;
    else
        return &((P6bigintBody *)r->get_boxed_ref(interp, STABLE(obj), OBJECT_BODY(obj),
            bigint_repr_id))->i;
}

END_OPS_PREAMBLE

/*
 * The ops in here mostly just delegate off to libtommath. nqp_bigint_setup must be
 * called before you create any types using the bigint representation. For all of the
 * rest ops there are two variants. The first variant simply takes two objects and
 * assumes they directly use the P6bigint REPR; the second one pulls out an (inlined)
 * P6bigint attribute and works on that; this avoids the overhead of creating a boxed
 * version only to throw it away again.
 */

inline op nqp_bigint_setup() :base_core {
    /* Register the bigint representation. */
    bigint_repr_id = REGISTER_DYNAMIC_REPR(interp,
        Parrot_str_new_constant(interp, "P6bigint"),
        P6bigint_initialize);
}

inline op nqp_bigint_add(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_add(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_sub(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_sub(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_mul(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_mul(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_div(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    mp_int remainder;
    mp_init(&remainder);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_div(a, b, get_bigint(interp, $1), &remainder);
    mp_clear(&remainder);
}

inline op nqp_bigint_mod(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_mod(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_neg(out PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_neg(a, get_bigint(interp, $1));
}
inline op nqp_bigint_abs(out PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_abs(a, get_bigint(interp, $1));
}

inline op nqp_bigint_cmp(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = mp_cmp(a, b);
}

inline op nqp_bigint_bool(out INT, in PMC) :base_core {
    $1 = !mp_iszero(get_bigint(interp, $2));
}

inline op nqp_bigint_eq(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_EQ == mp_cmp(a, b);
}

inline op nqp_bigint_ne(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_EQ != mp_cmp(a, b);
}

inline op nqp_bigint_gt(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_GT == mp_cmp(a, b);
}

inline op nqp_bigint_ge(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_LT != mp_cmp(a, b);
}

inline op nqp_bigint_lt(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_LT == mp_cmp(a, b);
}

inline op nqp_bigint_le(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_GT != mp_cmp(a, b);
}

inline op nqp_bigint_gcd(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_gcd(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_lcm(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_lcm(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_from_str(out PMC, in PMC, in STR) :base_core {
    char *buf = Parrot_str_cstring(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_read_radix(get_bigint(interp, $1), buf, 10);
}

inline op nqp_bigint_to_str(out STR, in PMC) :base_core {
    mp_int *i = get_bigint(interp, $2);
    int len;
    char *buf;
    mp_radix_size(i, 10, &len);
    buf = mem_sys_allocate(len);
    mp_toradix_n(i, buf, 10, len);
    /* len - 1 because buf is \0-terminated */
    $1 = Parrot_str_new(interp, buf, len - 1);
    mem_sys_free(buf);
}

inline op nqp_bigint_shr(out PMC, in PMC, in INT) :base_core {
    mp_int *a = get_bigint(interp, $2);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_div_2d(a, $3, get_bigint(interp, $1), NULL);
}

inline op nqp_bigint_shl(out PMC, in PMC, in INT) :base_core {
    mp_int *b;
    mp_int *a = get_bigint(interp, $2);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    b = get_bigint(interp, $1);
    mp_mul_2d(a, $3, b);
}

inline op nqp_bigint_band(out PMC, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_and(a, b, get_bigint(interp, $1));
}
inline op nqp_bigint_bor(out PMC, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_or(a, b, get_bigint(interp, $1));
}
inline op nqp_bigint_bxor(out PMC, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    mp_xor(a, b, get_bigint(interp, $1));
}
inline op nqp_bigint_bnot(out PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b;
    $1 = REPR($2)->allocate(interp, STABLE($2));
    REPR($1)->initialize(interp, STABLE($1), OBJECT_BODY($1));
    b = get_bigint(interp, $1);

    /* 2s complement: add 1, negate */
    mp_add_d(a, 1, b);
    mp_neg(b, b);
}
