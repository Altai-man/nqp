BEGIN_OPS_PREAMBLE

/* Parroty includes. */
#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"
#include "../6model/sixmodelobject.h"
#include "../6model/reprs/P6bigint.h"

static mp_int * get_bigint(PARROT_INTERP, PMC *obj) {
    /* XXX sanity checks... */
    return &((P6bigintInstance *)PMC_data(obj))->i;
}

END_OPS_PREAMBLE

/*
 * The ops in here mostly just delegate off to libtommath. nqp_bigint_setup must be
 * called before you create any types using the bigint representation. For all of the
 * rest ops there are two variants. The first variant simply takes two objects and
 * assumes they directly use the P6bigint REPR; the second one pulls out an (inlined)
 * P6bigint attribute and works on that; this avoids the overhead of creating a boxed
 * version only to throw it away again.
 */

inline op nqp_bigint_setup() :base_core {
    /* Register the bigint representation. */
    REGISTER_DYNAMIC_REPR(interp,
        Parrot_str_new_constant(interp, "P6bigint"),
        P6bigint_initialize);
}

inline op nqp_bigint_add(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_add(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_sub(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_sub(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_mul(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_mul(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_div(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    mp_int *remainder = get_bigint(interp, REPR($2)->instance_of(interp, $2));
    $1 = REPR($2)->instance_of(interp, $2);
    mp_div(a, b, get_bigint(interp, $1), remainder);
    /* XXX do I need to destroy remainder myself? */
}

inline op nqp_bigint_mod(out PMC, in PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_mod(a, b, get_bigint(interp, $1));
}

inline op nqp_bigint_neg(out PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_neg(a, get_bigint(interp, $1));
}
inline op nqp_bigint_abs(out PMC, in PMC) :base_core {
    mp_int *a = get_bigint(interp, $2);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_abs(a, get_bigint(interp, $1));
}

inline op nqp_bigint_cmp(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = mp_cmp(a, b);
}

inline op nqp_bigint_eq(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_EQ == mp_cmp(a, b);
}

inline op nqp_bigint_ne(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_EQ != mp_cmp(a, b);
}

inline op nqp_bigint_gt(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_GT == mp_cmp(a, b);
}

inline op nqp_bigint_ge(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_LT != mp_cmp(a, b);
}

inline op nqp_bigint_lt(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_LT == mp_cmp(a, b);
}

inline op nqp_bigint_le(out INT, in PMC, in PMC) :base_cor {
    mp_int *a = get_bigint(interp, $2);
    mp_int *b = get_bigint(interp, $3);
    $1 = MP_GT != mp_cmp(a, b);
}
inline op nqp_bigint_from_str(out PMC, in PMC, in STR) :base_core {
    char *buf = Parrot_str_cstring(interp, $3);
    $1 = REPR($2)->instance_of(interp, $2);
    mp_read_radix(get_bigint(interp, $1), buf, 10);
}

inline op nqp_bigint_to_str(out STR, in PMC) :base_core {
    mp_int *i = get_bigint(interp, $2);
    int len;
    char *buf;
    mp_radix_size(i, 10, &len);
    buf = mem_sys_allocate(len);
    mp_toradix_n(i, buf, 10, len);
    $1 = Parrot_str_new(interp, buf, len);
    mem_sys_free(buf);
}
